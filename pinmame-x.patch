diff --git a/makefile.unix b/makefile.unix
new file mode 100644
index 0000000..9b43528
--- /dev/null
+++ b/makefile.unix
@@ -0,0 +1,750 @@
+###########################################################################
+#                                                                         #
+# makefile for xmame/xmess                                                #
+#                                                                         #
+# Original version by Juan Antonio Martinez and Hans de Goede.            #
+# Current version by Lawrence Gold, with much inspiration from XviD.      #
+# http://x.mame.net                                                       #
+# mailto:gold@aros.net                                                    #
+#                                                                         #
+#                                                                         #
+# READ COMMENTS AND MODIFY CONFIGURABLE OPTIONS WITH CARE.                #
+#                                                                         #
+# Members of the MAME and Xmame projects assume no responsibility         #
+# implicit or explicit about illegal or incorrect use of this             #
+# sofware and about possible hardware or software damage caused           #
+# by its use.                                                             #
+#                                                                         #
+# THIS SOFTWARE IS DISTRIBUTED "AS IS".  USE AT YOUR OWN RISK             #
+#                                                                         #
+# MAME and Xmame are Copyright (c) Nicola Salmoria and Mirko buffoni      #
+# and distributed under terms simular to the GNU General Public           #
+# License.  See doc/readme.unix for more details                          # 
+#                                                                         #
+# Arcade ROM images are copyrighted by their authors.  DISTRIBUTING       #
+# MAME OR XMAME WITH ROM IMAGES IN THE SAME PACKAGE IS ILLEGAL AND        #
+# CONSTITUTES A VIOLATION OF TERMS OF COPYRIGHT.                          #
+#                                                                         #
+###########################################################################
+
+
+###########################################################################
+# Xmame or xmess or...?
+###########################################################################
+
+# Uncomment one of these.
+TARGET = pinmame
+# AVICAPTURE = 1
+# TARGET = mame
+# TARGET = mess
+# TARGET = neomame
+# TARGET = cpmame
+# TARGET = mmsnd
+# example for a tiny compile
+# TARGET = tiny
+
+
+###########################################################################
+# Special features
+###########################################################################
+
+# Enable experimental network support.  See 
+# src/unix/doc/multiplayer-readme.txt for more information.
+# XMAME_NET = 1
+
+# Uncomment the next lines to use x86-asm cpu cores.  This is only
+# supported for x86 machines with nasm-0.98 or higher available in your
+# path!  The asm 68k core could cause problems with certain games; please 
+# test with the C core before you report any problems.
+
+# Uncomment to use assembler 68000 engine.
+# X86_ASM_68000 = 1
+# Uncomment to use assembler 68020 engine (CURRENTLY BROKEN).
+# X86_ASM_68020 = 1
+
+# Uncomment to use DRC MIPS3 engine
+# X86_MIPS3_DRC = 1
+
+
+###########################################################################
+# Development environment options 
+###########################################################################
+
+# GNU make is MANDATORY!!!
+
+
+###########################################################################
+# Choose your compiler.
+###########################################################################
+
+# Support for the Intel C++ Compiler is new and experimental.  Be sure
+# to check the CFLAGS, RANLIB, IL, LD, and MY_CPU sections in this 
+# makefile.  If you've set up a nice environment or alias or wrapper
+# script, then you can use `icc'.
+#
+# Use of `c89' is recommend for Ultrix as it generates faster code, which
+# means fewer frames to be skipped and better graphics, but `gcc' works 
+# just as well.  However, stay away from the `cc' Ultrix compiler if 
+# possible.
+
+#CC	= /usr/i686-pc-linux-gnu/gcc-bin/3.4.6/gcc
+CC	= gcc-3.4.6
+# CC    = cc
+# CC	= icc
+# CC	= c89
+
+# Uncomment for Sun Forte 7 and above C/C++ compiler, see below for
+# additional optimizations.
+# CC = sun-forte
+
+###########################################################################
+# Reset CFLAGS
+###########################################################################
+
+# If you want to use whatever CFLAGS are currently set in your 
+# environment, then comment this out.
+CFLAGS =
+
+
+###########################################################################
+# Choose from some preset CFLAGS.  Or, if you want to tweak some more, skip
+# this section.
+###########################################################################
+
+CFLAGS = -fomit-frame-pointer -Wall -Wno-unused
+
+# gcc on x86 with some optimizations
+# CFLAGS = -O2 -Wall -Wno-unused -mcpu=i686 -fomit-frame-pointer \
+#  -fstrict-aliasing -fstrength-reduce -ffast-math
+
+# gcc on Linux/PowerPC
+# CFLAGS = -O2 -Wall -Wno-unused -funroll-loops -fstrength-reduce \
+#  -fomit-frame-pointer -ffast-math -fsigned-char
+
+# gcc on OpenStep/Intel
+# CFLAGS = -O2 -Wall -Wno-unused -finline-functions -ffast-math \
+#  -fstrength-reduce -traditional-cpp
+
+# gcc on OpenStep/PPC or Mac OS X
+# CFLAGS = -O2 -Wall  -Wno-unused -funroll-loops -traditional-cpp \
+#  -fstrength-reduce -fomit-frame-pointer -ffast-math -fsigned-char
+
+# IRIX MIPSpro with really serious optimization for R10K O2
+# CFLAGS = -fullwarn -n32 -mips4 -Ofast=ip32_10k -TARG:platform=ip32_10k \
+#  -OPT:Olimit=0 -IPA
+
+# IRIX with more general optimization for R5+K MIPS machines
+# CFLAGS = -fullwarn -n32 -mips4 -Ofast -OPT:Olimit=0 -IPA
+
+# IRIX with R4K MIPS chips (older Indys, Indigo2s, etc).
+# CFLAGS = -fullwarn -n32 -mips3 -Ofast -OPT:Olimit=0 -IPA
+
+# PlayStation2 Linux
+# CFLAGS = -O2 -mcpu=r5900 -Wall -Wno-unused -fsingle-precision-constant \
+#  -fstrength-reduce -fomit-frame-pointer -ffast-math -fsigned-char -pipe \
+#  -malign-loops=2 -malign-jumps=2 -funroll-loops
+
+ifneq (,$(findstring gcc,$(CC)))
+
+  #########################################################################
+  # Special cases
+  #########################################################################
+
+  # Uncomment for Linux on a PowerPC system.
+  # CFLAGS += -fsigned-char
+
+  # Uncomment for OpenStep and Mac OS X. 
+  # CFLAGS += -traditional-cpp
+
+
+  #########################################################################
+  # Warnings
+  #########################################################################
+  
+  # Show all warnings.
+  # CFLAGS += -Wall
+
+  # Don't warn about unused variables.
+  # CFLAGS += -Wno-unused
+
+
+  #########################################################################
+  # Debugging
+  #########################################################################
+
+  # Detect non-ANSI C code.
+  # CFLAGS += -pedantic -ansi -D_XOPEN_SOURCE -D_BSD_SOURCE \
+  # -Wno-long-long -Wno-trigraphs -Dasm=__asm__
+ 
+  # Check for C89 compliance.
+  # CFLAGS += -std=c89
+
+  # Enable debugging (e.g., using gdb).
+  # CFLAGS += -ggdb
+
+
+  #########################################################################
+  # General optimizations
+  #########################################################################
+  
+  # Optimization level -- choose one of these.
+  # Use -O1 if you suspect that -O2 is producing bad code; use -O3 for a 
+  # possible speedup; use -Os for a smaller executable.
+CFLAGS += -O2
+  # CFLAGS += -O1
+  # CFLAGS += -O3
+  # CFLAGS += -Os
+
+  # This option should reduce compilation time and disk activity
+CFLAGS += -pipe
+  
+  # Free up the frame pointer register for other uses.  This can make 
+  # debugging impossible on some platforms, notably x86.  Also, gcc-3.0.2 
+  # can produce invalid code for x86 with this enabled.
+  # CFLAGS += -fomit-frame-pointer
+
+  # Use with gcc-2.95.1 and above for a nice speedup.  For gcc-3.0 and
+  # above, this is automatically turned on by -O2 and above.
+  # CFLAGS += -fstrict-aliasing
+
+  # Use with egcs-1.1.x and gcc-2.95; otherwise, xmame compilation will 
+  # break.
+  # CFLAGS += -fno-strict-aliasing
+ 
+  # Unroll loops for a possible speedup.  Beware that combining this with 
+  # -O2 in gcc-3.0.x on x86 platforms miscompiles src/sndhrdw/williams.c, 
+  # causing narc (and possibly other games) to segfault.
+CFLAGS += -funroll-loops
+
+  # Produce faster floating point code that isn't IEEE/ISO-compliant.
+  # CFLAGS += -ffast-math
+
+  # Strength reduction and elimination of iteration variables.
+  # CFLAGS += -fstrength-reduce
+
+  # Enable minor optimizations that are relatively expensive.
+  # CFLAGS += -fexpensive-optimizations
+
+
+  #########################################################################
+  # Architecture-specific optimizations
+  #########################################################################
+  
+  # Note that -march may produce an executable that won't run on lesser 
+  # CPUs.  If you're aiming for portability across an entire architecture, 
+  # use -mcpu instead.  For example, -mcpu=pentiumpro will produce an 
+  # executable that (in theory) should be optimized for a PentiumPro 
+  # system, but it will still run on a 386.
+
+  # Valid x86 options that work with any version of gcc.
+  # CFLAGS += -march=i386
+  # CFLAGS += -march=i486
+  # CFLAGS += -march=i586
+  # CFLAGS += -march=i686
+  # CFLAGS += -march=pentium
+  # CFLAGS += -march=pentiumpro
+
+  # Valid x86 options that work only with newer versions of gcc.
+  # CFLAGS += -march=pentium-mmx
+  # CFLAGS += -march=pentium3
+  # CFLAGS += -march=pentium4
+  # CFLAGS += -march=k6
+  # CFLAGS += -march=k6-2
+  # CFLAGS += -march=k6-3
+  # CFLAGS += -march=athlon
+  # CFLAGS += -march=athlon-tbird
+#### CFLAGS += -march=athlon-xp
+  CFLAGS += -march=athlon64
+  # CFLAGS += -march=athlon-mp
+  # CFLAGS += -march=athlon-4
+
+else
+ifeq ($(CC),icc)
+
+  # Optimizations for the Intel compiler.
+  CFLAGS    = -O3 -rcd -Xa -ipo -ipo_obj
+
+else
+ifeq ($(CC),sun-forte)
+  #
+  # sun-forte given above is just an artifice to get us into this section
+  CC = cc
+
+  # uncomment to set compiler defaults oriented for maximum performance
+  XOPT += -fast
+
+  # Choose one optimization level;
+  #XOPT += -xO0
+  #XOPT += -xO1
+  #XOPT += -xO2
+  #XOPT += -xO3
+  # -xO4 and above automatically inline
+  #XOPT += -xO4
+  XOPT += -xO5
+
+  # uncomment for code generation targeted to the local machine; this
+  # supplies -xarch, -xcpu, -xtarget.  It also seems to cause an annoying
+  # message related to code generated at -native being compatible with 
+  # older hardware, which apparently can't be disabled.  As an alternative,
+  # the particular -xtarget for your system could be specified; 
+  # -xtarget=ultra2/2300
+  XTARGET += -native 
+  #XTARGET += -xtarget=ultra2/2300
+
+  # uncomment to inline library math functions
+  EXTRA_OPTS += -xlibmil
+
+  ######################################################
+  # Additional options for parallelization optimizations
+  ######################################################
+  # uncomment for automatic parallelization (if your machine has > 1 cpu)
+  # Before starting xmame, be sure to set the env variable PARALLEL to the #
+  # of processors to use; PARALLEL=2 ./xmame.x11 
+  # xmame doesn't appear to like these at present
+  # XPARALLEL += -xparallel
+  # uncomment to have cc collapse various math expression sequences, possibly 
+  # affecting roundoffs.  Requires -xparallel
+  # EXTRA_OPTS += -xreduction
+
+  # Sparc only, uncomment to do loop restructuring optimizations
+  # and speculative prefetch for v8plusa and above
+  EXTRA_OPTS += -xdepend  -xsafe=mem
+
+  #################################################
+  # Additional options for glx builds
+  #################################################
+  #
+  # uncomment and modify as required if Mesa wants /lib/libCrun.so
+  # (libGLU dlopen() complains of missing name mangled symbols)
+  # GLCFLAGS += -DSUN_FORTE_DLOPEN_LIBCRUN='\"libCrun.so.1\"'
+
+  CFLAGS= $(XOPT) $(XTARGET) $(XPARALLEL) $(EXTRA_OPTS)
+  LDFLAGS=$(XOPT) $(XTARGET) $(XPARALLEL) $(EXTRA_OPTS)
+
+  # uncomment for silence...
+  CFLAGS += -erroff
+  # Tell xmame that we really are in fact elf.  If not supplied, SHARED_PREFIX 
+  # is set causing dlopen()'s to fail.
+  CFLAGS += -D__ELF__ 
+endif
+endif
+endif
+
+###########################################################################
+# Inlining
+###########################################################################
+
+# This can very noticably increase xmame's performance, so enabling this 
+# is encouraged.  It works fine with gcc and probably with most other 
+# compilers.
+IL	= '-DINLINE=static __inline__'
+
+# Use this with strict ANSI or BeOS or Sun Forte
+# IL	= -DINLINE=static
+
+# Intel C++ Compiler doesn't know about __inline__.
+# IL	= '-DINLINE=static inline'
+
+
+###########################################################################
+# Linker and linker flags
+###########################################################################
+
+# Normal linking.
+LD	= $(CC) -Wl,-s
+
+# For the Intel C++ Compiler -- expect large link time due to -ipo 
+# optimization.
+# LD	= $(CC) -Wl,-s -ipo -ipo_obj
+
+# To profile with gcc and gprof.
+# LD	= $(CC) -pg
+
+# No profiling (less strace output), but include debug info.
+# LD	= $(CC)
+
+# For debugging only.  This only works with GNU binutils!!
+# LD	= $(CC) -Wl,-warn-common
+
+# For IRIX R5+K MIPSpro, optimization at link time.  This takes nearly a 
+# gig of memory!!
+# LD    = $(CC) -fullwarn -n32 -mips4 -IPA
+
+# For IRIX R4K MIPSpro, optimization at link time.  This takes nearly a gig
+# of memory!!
+# LD  = $(CC) -fullwarn -n32 -mips3 -IP
+
+
+###########################################################################
+# Math library and ranlib
+###########################################################################
+
+# Does your platform have a separate libm?  Only comment this out if you
+# have math libraries included within libc.  This is very rare; you will
+# probably only need it for OpenStep and BeOS systems.
+SEPARATE_LIBM = 1
+
+# Does your platform have ranlib?  Leave this untouched unless you are
+# using IRIX, Unixware 7, or the Intel C++ Compiler.
+RANLIB = ranlib
+# RANLIB = true
+
+
+###########################################################################
+# Install method and paths for the executable, man pages, and data
+###########################################################################
+
+# OSes that don't have an install command should use the provided 
+# install.sh script.
+INSTALL =              /usr/bin/install
+# INSTALL =            install-sh
+# INSTALL =            /bin/install
+# INSTALL =            install      # e.g., for BeOS 
+
+# The user and group to be used for installation.
+INSTALL_USER =         root
+INSTALL_GROUP =        bin
+
+INSTALL_PROGRAM_DIR =	$(INSTALL) -d    -o $(INSTALL_USER) -g $(INSTALL_GROUP) -m  755
+INSTALL_MAN_DIR =	$(INSTALL) -d    -o $(INSTALL_USER) -g $(INSTALL_GROUP) -m  755
+INSTALL_DATA_DIR =	$(INSTALL) -d    -o $(INSTALL_USER) -g $(INSTALL_GROUP) -m  755
+INSTALL_PROGRAM =	$(INSTALL) -c -s -o $(INSTALL_USER) -g $(INSTALL_GROUP) -m  555
+INSTALL_PROGRAM_SUID =	$(INSTALL) -c -s -o $(INSTALL_USER) -g $(INSTALL_GROUP) -m 4555
+INSTALL_MAN =		$(INSTALL) -c    -o $(INSTALL_USER) -g $(INSTALL_GROUP) -m  444
+INSTALL_DATA =		$(INSTALL) -c    -o $(INSTALL_USER) -g $(INSTALL_GROUP) -m  644
+
+
+###########################################################################
+# Extra include and/or library paths
+###########################################################################
+
+# These are sometimes needed for zlib.
+# SuSE Linux may require -L/usr/X11R6/lib.
+# UnixWare7 requires -lsocket.
+# LIBS     = -L/usr/X11R6/lib -L/usr/local/lib
+# INCLUDES = -I/usr/X11R6/include -I/usr/local/include
+
+
+###########################################################################
+# Miscellaneous settings
+###########################################################################
+
+# If your system doesn't have zlib, or your systems zlib is giving you
+# troubles, you can use the one distributed with xmame.  Uncomment the 
+# following line to use xmame's own version of zlib.
+# ZLIB = 1
+
+# Does your system support the gettimeofday() function?  If so, we 
+# encourage you to enable this feature.  Otherwise, comment it out.
+# :-(
+HAVE_GETTIMEOFDAY = 1
+
+# Uncomment this if you want to link with ElectricFence (for developers 
+# only).
+# EFENCE = 1
+
+
+###########################################################################
+# Configuration files and directories
+###########################################################################
+
+# Select destination directory for your compiled program, manual page,
+# and binary distribution.
+ifndef PREFIX
+PREFIX = /usr/local
+endif
+BINDIR = $(PREFIX)/bin
+MANDIR = $(PREFIX)/share/man/man6
+
+# This is the default path for ROMs and other data files.
+XMAMEROOT = $(PREFIX)/share/x$(TARGET)
+
+
+###########################################################################
+# Architecture; choose your CPU (only one!!) 
+###########################################################################
+
+# i386, GNU asm
+MY_CPU = i386
+
+# i386, no asm -- needed for the Intel C++ compiler, which does not fully
+# understand gcc's inline assembly syntax, though you may still enable 
+# X86_ASM_68000, etc., which are assembled by NASM.  You may also need to 
+# use this for BeOS.
+# MY_CPU = i386_noasm
+
+# IA64
+# MY_CPU = ia64
+
+# DEC Alpha
+# MY_CPU = alpha
+
+# Motorola M68K
+# MY_CPU = m68k
+
+# Generic RISC (PowerPC, SPARC, HPPA, IBM)
+# MY_CPU = risc
+
+# Generic RISC, LSB-first (RISC (Ultrix machines) & PlayStation2)
+# MY_CPU = risc_lsb
+
+# MIPS (generic RISC + SGI compiler bug workarounds)
+# MY_CPU = mips
+
+
+###########################################################################
+# Architecture; choose your OS (only one!!) 
+###########################################################################
+
+# Linux 
+ARCH  = linux
+
+# FreeBSD
+# ARCH  = freebsd
+
+# NetBSD
+# ARCH  = netbsd
+
+# OpenBSD
+# ARCH = openbsd
+
+# Solaris/SunOS
+# ARCH  = solaris
+# For Solaris, add paths where other stuff is; libjpeg and so on...
+# CFLAGS += -I/usr/local/include -I/usr/sfw/include 
+# LDFLAGS += -L/usr/local/lib -L/usr/sfw/lib
+
+# QNX Neutrino (QNX4/QNX6)
+# ARCH = nto
+
+# OpenStep on NeXT systems
+# ARCH  = next
+
+# OpenStep on Apple systems (Cocoa)
+# ARCH  = macosx
+
+# IRIX (with sound requires the dmedia package) (*)
+# ARCH  = irix
+
+# IRIX (with sound using the new al package) (*)
+# ARCH  = irix_al
+
+# AIX (with sound, you'll need the UMS and SOM lpp's installed (under 
+# AIX4))
+# ARCH  = aix
+
+# BeOS on Intel
+# ARCH = beos
+
+# generic UNIX, no sound
+# ARCH  = generic
+
+# (*) For IRIX 6.5 or higher add -DHAVE_SNPRINTF to CFLAGS.irix(_al) in
+# src/unix/Makefile
+
+
+###########################################################################
+# Input Devices
+###########################################################################
+
+# Uncomment any joystick types that you want to use; the one that is 
+# actually used can be selected at runtime with the -joytype switch.
+
+# X Input Extensions-based joystick.  This is known to not work right now.
+# JOY_X11 = 1
+
+# On x86-based OSes, if supported, you can use standard joystick driver.
+# JOY_I386 = 1
+
+# Linux FM-TOWNS game pad joystick emulation support.  Thanks to Osamu 
+# Kurati.
+# JOY_PAD = 1
+
+# NetBSD/FreeBSD USB joystick support.
+# JOY_USB = 1
+
+# PlayStation2-linux native pad support.
+# JOY_PS2 = 1
+
+# This will enable the use of the Happ Controls UGCI(tm) USB devices'
+# Coin/Start inputs using the libugci library available from
+# http://www.phunnypharm.org/ugci/
+# UGCICOIN = 1
+
+
+###########################################################################
+# Sound Devices
+###########################################################################
+
+# Choose any additonal sound drivers you want to include, besides the 
+# native sound driver for your system.
+# SOUND_ESOUND = 1
+# SOUND_ALSA = 1
+# SOUND_ARTS_TEIRA = 1
+# SOUND_ARTS_SMOTEK = 1
+# SOUND_SDL = 1
+# SOUND_WAVEOUT = 1
+
+
+###########################################################################
+# Select your display method; choose only one.
+###########################################################################
+
+# Note: x11 is the only one supported on almost all platforms.  For BeOS, 
+# use SDL.
+
+# X11
+DISPLAY_METHOD = x11
+
+# SDL library 
+# DISPLAY_METHOD = SDL
+
+# SVGALib, only supported under Linux
+# DISPLAY_METHOD = svgalib
+
+# GGI, only tested under Linux
+# DISPLAY_METHOD = ggi
+
+# OpenGL under X11
+# DISPLAY_METHOD = xgl
+
+# Glide under X11
+# DISPLAY_METHOD = xfx
+
+# Glide in console mode
+# DISPLAY_METHOD = svgafx
+
+# OpenStep bitmaps
+# DISPLAY_METHOD = openstep
+
+# Photon 2.x (QNX6), currently buggy, but working...
+# DISPLAY_METHOD = photon2
+
+
+###########################################################################
+# X-Window options (only needed when X is the display method)
+###########################################################################
+
+# Uncomment any extensions you wish to use.
+
+# MIT-Shared Memory X Extensions
+X11_MITSHM = 1
+
+# Use Xv extension for hardware scaling.
+X11_XV = 1
+
+# Enable XFree86 DGA.  This also causes "make install" to set the suid bit 
+# on the executable.
+# X11_DGA = 1
+
+# Work around a bug in the XFree86 tdfx driver that prevents the original 
+# mode from being restored when leaving DGA2 mode.
+# TDFX_DGA_WORKAROUND = 1
+
+# The XIL library (Solaris 2.5.1 and higher)
+# X11_XIL = 1
+# Turn off the annoying obsolesence message if XIL is enabled
+# CFLAGS += -DSUNXIL_WARNING_DISABLE
+
+# Choose the location of your X headers and libraries.
+
+# Standard location for X11 
+# X11INC		= -I/usr/include/X11
+# X11LIB		= -L/usr/lib/X11
+
+# Standard location for XFree86
+X11INC		= -I/usr/X11R6/include
+X11LIB		= -L/usr/X11R6/lib
+
+# Standard location for Sun systems
+# X11INC		= -I/usr/openwin/include
+# X11LIB		= -L/usr/openwin/lib
+
+# Some non-standard locations
+# X11INC		= -I/usr/local/include/X11
+# X11LIB		= -L/usr/local/lib
+
+# The default name for the input device used by the X11 joystick driver.
+# Use provided program "xlistdev" to list available ones.
+X11_JOYNAME = "Joystick"
+
+# Uncomment this to use XInput devices, e.g. additional mice as 
+# trackballs.
+# XINPUT_DEVICES = 1
+
+
+##############################################################################
+# SDL options (only needed when SDL is the display method)
+##############################################################################
+
+# The name of your sdl-config executable
+SDL_CONFIG	= sdl-config
+
+
+##############################################################################
+# OpenGL info -- configure if you are using the xgl display option
+##############################################################################
+GLLIBS += -ldl
+
+# General OpenGL (GL/GLU) dynamic loading support for:
+#
+# <OS - System>          <#define>  commentary
+# -----------------------------------------------
+# GNU/Linux, UNIX/X11    _X11_      (loads glx also)
+# Macinstosh OS 9        _MAC_OS9_
+# Macinstosh OS X        _MAC_OSX_
+# Win32                  _WIN32_    (load wgl also)
+#
+# GLU version 1.2 is recommended (e.g., from SGI).  If you 
+# use Mesa's GLU, you may have to add -DGLU_VERSION_1_2 to 
+# the GLCFLAGS below.
+#
+# To get more verbose debugging messages, just add -DGLDEBUG !
+GLCFLAGS += -D_X11_
+
+# Uncomment to add more libraries that Mesa may require.
+# GLLIBS += -lXmu -lXi
+
+# Building against Sun's OpenGL will probably need these.
+# GLCFLAGS += -DNOGLEXT78 -DNOTEXIDXSIZE
+
+# Uncomment depending on which is supplying GLX functions.  nVidia uses
+# libglx, Mesa/SGI use libglut 
+GLCFLAGS+=-DGLXLIB_NAME='\"libglut.so\"'
+# GLCFLAGS+=-DGLXLIB_NAME='\"libglx.so\"'
+
+###########################################################################
+# Debug support and object file format
+###########################################################################
+
+# Comment out the next line if you want to compile CPU disassemblers in
+# MAME for debugging.
+CFLAGS += -DNDEBUG
+
+# Uncomment the next lines to build xmame with a built-in debugger (only
+# supported for X11 and SVGALib). Only enable this if you need it -- if you
+# want to develop drivers, that is, since it slows down xmame considerably.
+DEBUG = 1
+
+ifdef DEBUG
+NAME=x$(TARGET)d
+else
+NAME=x$(TARGET)
+endif
+
+# Choose ELF or a.out
+# ELF settings: No leading underscores + ELF object format.  Tested with
+# Linux/i386.  Also for Solaris/x86, for example.
+ASM_STRIP = src/unix/contrib/porting/strip_
+NASM_FMT  = -f elf
+# a.out settings: Leading underscores + a.out object format.  Tested with
+# netBSD i386.  Also for older Linux installs, FreeBSD, and others.
+# ASM_STRIP = true  # no strip command
+# NASM_FMT  = -f aoutb
+
+
+###########################################################################
+# All done.  Type make -f makefile.unix and enjoy xmame/xmess.  ;)
+# No configurable options below this line.
+###########################################################################
+include src/unix/unix.mak
diff --git a/src/mamedbg.c b/src/mamedbg.c
index 26d9cd7..42486f4 100644
--- a/src/mamedbg.c
+++ b/src/mamedbg.c
@@ -1706,7 +1706,11 @@ static void trace_output( void )
 		for( i = count = 0; i < MAX_LOOPS; i++ )
 			if( TRACE.last_pc[i] == pc )
 				count++;
-		if( count > 1 )
+#ifdef CONFIG_FOR_FREEWPC
+		if( count > 32)
+#else
+		if( count > 1)
+#endif
 		{
 			TRACE.loops++;
 		}
@@ -1721,6 +1725,9 @@ static void trace_output( void )
 			}
 			if( TRACE.regs[0] )
 			{
+#ifdef CONFIG_FOR_FREEWPC
+				dst += sprintf (dst, "#%u ", activecpu_gettotalcycles ());
+#endif
 				for( i = 0; i < MAX_REGS && TRACE.regs[i]; i++ )
 					dst += sprintf( dst, "%s ", activecpu_dump_reg(TRACE.regs[i]) );
 			}
diff --git a/src/osdepend.h b/src/osdepend.h
index a615c09..1f7f6f5 100644
--- a/src/osdepend.h
+++ b/src/osdepend.h
@@ -2,6 +2,9 @@
 #define OSDEPEND_H
 
 #include "osd_cpu.h"
+#ifdef PINMAME
+#include "pinmame.h"
+#endif
 #include "inptport.h"
 
 #ifdef __cplusplus
diff --git a/src/pinmame.mak b/src/pinmame.mak
index 5427a4c..d58ba67 100644
--- a/src/pinmame.mak
+++ b/src/pinmame.mak
@@ -31,6 +31,7 @@ DRVLIBS += $(OBJ)/vidhrdw/tms9928a.o $(OBJ)/machine/pic8259.o
 #
 DRVLIBS += $(PINOBJ)/s4.o $(PINOBJ)/s6.o $(PINOBJ)/s7.o $(PINOBJ)/s11.o
 DRVLIBS += $(PINOBJ)/wpc.o $(PINOBJ)/wmssnd.o
+DRVLIBS += $(PINOBJ)/serial.o
 DRVLIBS += $(PINOBJ)/dedmd.o $(PINOBJ)/desound.o
 DRVLIBS += $(PINOBJ)/gts3.o $(PINOBJ)/gts3dmd.o
 DRVLIBS += $(PINOBJ)/se.o
@@ -230,6 +231,7 @@ $(OBJ)/allgames.a: $(PINGAMES)
 # Preprocessor Definitions
 #
 
+ifdef WINDOWS
 DEFS += -DDIRECTSOUND_VERSION=0x0300 \
         -DDIRECTINPUT_VERSION=0x0500 \
         -DDIRECTDRAW_VERSION=0x0300 \
@@ -238,6 +240,7 @@ DEFS += -DDIRECTSOUND_VERSION=0x0300 \
         -D_WIN32_WINNT=0x0400 \
         -DWIN32 \
         -UWINNT
+endif
 
 # generated text files
 TEXTS += gamelist.txt
@@ -253,6 +256,6 @@ cleanpinmame:
 	$(RM) $(EMULATOR)
 
 ifdef DEBUG
-LDFLAGS+= -Xlinker -Map -Xlinker $(TARGET).map -Xlinker --cref
+LDFLAGS+= -Xlinker -Map -Xlinker $(TARGET).map
 endif
 
diff --git a/src/sound/votrax.c b/src/sound/votrax.c
index afcd12b..724382f 100644
--- a/src/sound/votrax.c
+++ b/src/sound/votrax.c
@@ -34,12 +34,13 @@ ACK to ACK and STROBE to STROBE.
 
 #include "driver.h"
 #include "votrax.h"
-#include "windows.h"
 #ifdef REAL_DEVICE
 #include "dlportio.h"
 #endif
 #include "math.h"
 
+typedef unsigned char byte;
+
 static struct {
 	int	baseFrequency;
 	int busy;
diff --git a/src/unix/Makefile b/src/unix/Makefile
new file mode 100644
index 0000000..ec49b8f
--- /dev/null
+++ b/src/unix/Makefile
@@ -0,0 +1,157 @@
+OBJDIR = ../../$(OBJ)/unix.$(DISPLAY_METHOD)
+MY_TARGET = $(OBJDIR)/osdepend.a
+
+##############################################################################
+# *** object listings
+##############################################################################
+
+# common objs
+COMMON_OBJS  =  \
+	$(OBJDIR)/main.o $(OBJDIR)/sound.o \
+	$(OBJDIR)/keyboard.o $(OBJDIR)/devices.o \
+	$(OBJDIR)/video.o $(OBJDIR)/mode.o \
+	$(OBJDIR)/fileio.o $(OBJDIR)/dirio.o $(OBJDIR)/config.o \
+	$(OBJDIR)/fronthlp.o $(OBJDIR)/ident.o $(OBJDIR)/network.o \
+	$(OBJDIR)/snprintf.o $(OBJDIR)/nec765_dummy.o $(OBJDIR)/effect.o \
+	$(OBJDIR)/ticker.o $(OBJDIR)/parallel.o
+
+# sysdep objs
+SYSDEP_DIR  = $(OBJDIR)/sysdep
+SYSDEP_OBJS = $(SYSDEP_DIR)/rc.o $(SYSDEP_DIR)/misc.o \
+   $(SYSDEP_DIR)/plugin_manager.o $(SYSDEP_DIR)/sound_stream.o \
+   $(SYSDEP_DIR)/sysdep_palette.o $(SYSDEP_DIR)/sysdep_dsp.o \
+   $(SYSDEP_DIR)/sysdep_mixer.o
+   
+# video driver objs per display method
+VID_DIR = $(OBJDIR)/video-drivers
+VID_OBJS.x11    = $(VID_DIR)/xinput.o $(VID_DIR)/xil.o \
+	$(VID_DIR)/x11_window.o \
+	$(VID_DIR)/xf86_dga1.o $(VID_DIR)/xf86_dga2.o $(VID_DIR)/xf86_dga.o
+VID_OBJS.xgl    = $(VID_DIR)/gltool.o $(VID_DIR)/glxtool.o $(VID_DIR)/glcaps.o \
+		  $(VID_DIR)/glvec.o $(VID_DIR)/glgen.o $(VID_DIR)/glexport.o \
+		  $(VID_DIR)/glcab.o $(VID_DIR)/gljpg.o \
+		  $(VID_DIR)/xinput.o
+VID_OBJS.xfx    = $(VID_DIR)/fxgen.o $(VID_DIR)/xinput.o
+VID_OBJS.svgalib = $(VID_DIR)/svgainput.o
+VID_OBJS.svgafx = $(VID_DIR)/svgainput.o $(VID_DIR)/fxgen.o
+VID_OBJS.openstep = $(VID_DIR)/openstep_input.o
+VID_OBJS.photon2 = $(VID_DIR)/photon2_input.o \
+	$(VID_DIR)/photon2_window.o \
+	$(VID_DIR)/photon2_overlay.o
+VID_OBJS = $(VID_DIR)/$(DISPLAY_METHOD).o $(VID_OBJS.$(DISPLAY_METHOD))
+
+# sound driver objs per arch
+DSP_DIR = $(OBJDIR)/sysdep/dsp-drivers
+MIXER_DIR = $(OBJDIR)/sysdep/mixer-drivers
+SOUND_OBJS.linux   = $(DSP_DIR)/oss.o $(MIXER_DIR)/oss.o $(DSP_DIR)/alsa.o
+SOUND_OBJS.freebsd = $(DSP_DIR)/oss.o $(MIXER_DIR)/oss.o
+SOUND_OBJS.netbsd  = $(DSP_DIR)/netbsd.o
+#SOUND_OBJS.openbsd = $(DSP_DIR)/oss.o $(MIXER_DIR)/oss.o
+SOUND_OBJS.openbsd = $(DSP_DIR)/netbsd.o 
+SOUND_OBJS.solaris = $(DSP_DIR)/solaris.o $(MIXER_DIR)/solaris.o
+SOUND_OBJS.next    = $(DSP_DIR)/soundkit.o
+SOUND_OBJS.macosx  = $(DSP_DIR)/coreaudio.o
+SOUND_OBJS.nto     = $(DSP_DIR)/io-audio.o
+SOUND_OBJS.irix    = $(DSP_DIR)/irix.o
+SOUND_OBJS.irix_al = $(DSP_DIR)/irix_al.o
+SOUND_OBJS.beos    =
+SOUND_OBJS.generic =
+#these need to be converted to plugins first
+#SOUND_OBJS.aix     = $(DSP_DIR)/aix.o
+SOUND_OBJS = $(SOUND_OBJS.$(ARCH)) $(DSP_DIR)/esound.o $(DSP_DIR)/artssound.o \
+    $(DSP_DIR)/arts.o $(DSP_DIR)/sdl.o $(DSP_DIR)/waveout.o
+
+# joystick objs
+JOY_DIR  = $(OBJDIR)/joystick-drivers
+JOY_OBJS = $(JOY_DIR)/joy_i386.o $(JOY_DIR)/joy_pad.o $(JOY_DIR)/joy_x11.o \
+    $(JOY_DIR)/joy_usb.o $(JOY_DIR)/joy_ps2.o $(JOY_DIR)/joy_SDL.o \
+    $(JOY_DIR)/XInputDevices.o
+
+# framskip objs
+FRAMESKIP_DIR  = $(OBJDIR)/frameskip-drivers
+FRAMESKIP_OBJS = $(FRAMESKIP_DIR)/dos.o $(FRAMESKIP_DIR)/barath.o
+
+# all objs
+OBJS = $(COMMON_OBJS) $(SYSDEP_OBJS) $(VID_OBJS) $(SOUND_OBJS) $(JOY_OBJS) \
+   $(FRAMESKIP_OBJS)
+
+# obj dirs
+OBJDIRS = $(OBJDIR) $(SYSDEP_DIR) $(DSP_DIR) $(MIXER_DIR) $(VID_DIR) \
+   $(JOY_DIR) $(FRAMESKIP_DIR)
+
+
+##############################################################################
+# *** cflags
+##############################################################################
+
+# per arch
+CFLAGS.linux      = -DSYSDEP_DSP_OSS -DSYSDEP_MIXER_OSS -DHAVE_SNPRINTF -DHAVE_VSNPRINTF
+CFLAGS.freebsd    = -DSYSDEP_DSP_OSS -DSYSDEP_MIXER_OSS -DHAVE_SNPRINTF -DHAVE_VSNPRINTF
+CFLAGS.netbsd     = -DSYSDEP_DSP_NETBSD -DHAVE_SNPRINTF -DHAVE_VSNPRINTF
+#CFLAGS.openbsd    = -DSYSDEP_DSP_OSS -DSYSDEP_MIXER_OSS -DHAVE_SNPRINTF -DHAVE_VSNPRINTF
+CFLAGS.openbsd    = -DSYSDEP_DSP_NETBSD -DHAVE_SNPRINTF -DHAVE_VSNPRINTF
+CFLAGS.solaris    = -DSYSDEP_DSP_SOLARIS -DSYSDEP_MIXER_SOLARIS
+CFLAGS.next       = -DSYSDEP_DSP_SOUNDKIT -DBSD43
+CFLAGS.macosx     = -DSYSDEP_DSP_COREAUDIO -DHAVE_SNPRINTF -DHAVE_VSNPRINTF
+CFLAGS.nto        = -DSYSDEP_DSP_ALSA -DSYSDEP_MIXER_ALSA
+CFLAGS.irix       = -DSYSDEP_DSP_IRIX -DHAVE_SNPRINTF
+CFLAGS.irix_al    = -DSYSDEP_DSP_IRIX -DHAVE_SNPRINTF
+CFLAGS.beos       = `sdl-config --cflags` -DSYSDEP_DSP_SDL
+CFLAGS.generic    =
+#these need to be converted to plugins first
+#CFLAGS.aix        = -DSYSDEP_DSP_AIX -I/usr/include/UMS -I/usr/lpp/som/include
+
+#all cflags
+MY_CFLAGS = -I. -I.. -I../.. -I../../mess $(CFLAGS) $(CFLAGS.$(ARCH)) 
+
+
+##############################################################################
+# *** begin of the real makefile
+##############################################################################
+all:	$(OBJDIRS) $(MY_TARGET)
+
+clean:
+	rm -f $(MY_TARGET) $(OBJS)
+
+$(MY_TARGET): $(OBJS)
+	$(CC_COMMENT) @echo 'Archiving $@ ...'
+	$(CC_COMPILE) ar $(AR_OPTS) $@ $(OBJS)
+	$(CC_COMPILE) $(RANLIB) $@
+
+$(OBJDIRS):
+	-mkdir $@
+
+$(OBJDIR)/%.o: %.c xmame.h
+	$(CC_COMMENT) @echo 'Compiling src/unix/$< ...'
+	$(CC_COMPILE) $(CC) $(MY_CFLAGS) -o $@ -c $<
+
+$(OBJDIR)/%.o: %.m xmame.h
+	$(CC_COMMENT) @echo 'Compiling src/unix/$< ...'
+	$(CC_COMPILE) $(CC) $(MY_CFLAGS) -o $@ -c $<
+
+$(OBJDIR)/video.o: video-drivers/glmame.h effect.h
+$(OBJDIR)/effect.o: effect.h
+
+$(VID_DIR)/x11_window.o: video-drivers/blit.h video-drivers/blit_core.h effect.h
+$(VID_DIR)/svgalib.o: video-drivers/blit.h video-drivers/blit_core.h video-drivers/twkmodes.h video-drivers/twkuser.c effect.h
+$(VID_DIR)/xf86_dga1.o: video-drivers/xf86_dga1.c video-drivers/blit.h video-drivers/blit_core.h effect.h
+$(VID_DIR)/xf86_dga2.o: video-drivers/xf86_dga2.c video-drivers/blit.h video-drivers/blit_core.h effect.h
+$(VID_DIR)/SDL.o: video-drivers/blit.h video-drivers/blit_core.h effect.h
+$(VID_DIR)/xinput.o:  video-drivers/xkeyboard.h video-drivers/glmame.h
+$(VID_DIR)/xinput.o:  video-drivers/xkeyboard.h video-drivers/glmame.h
+$(VID_DIR)/xinput.o:  video-drivers/xkeyboard.h
+$(VID_DIR)/glgen.o:   video-drivers/glmame.h video-drivers/gltool.h \
+	              video-drivers/glxtool.h 
+$(VID_DIR)/glvec.o:   video-drivers/glmame.h video-drivers/gltool.h \
+	              video-drivers/glxtool.h
+$(VID_DIR)/glcab.o:   video-drivers/glmame.h video-drivers/gltool.h \
+	              video-drivers/glxtool.h
+$(VID_DIR)/gltool.o:  video-drivers/gltool.h \
+	              video-drivers/glxtool.h video-drivers/glcaps.h
+$(VID_DIR)/glcaps.o:  video-drivers/gltool.h 
+$(VID_DIR)/glxtool.o: video-drivers/gltool.h \
+	              video-drivers/glxtool.h video-drivers/glcaps.h
+$(VID_DIR)/xgl.o:     video-drivers/glmame.h video-drivers/gltool.h \
+	              video-drivers/glxtool.h
+$(VID_DIR)/gltool.h:  video-drivers/gl-disp-var.h video-drivers/glu-disp-var.h
+
diff --git a/src/unix/arch-defines-used.txt b/src/unix/arch-defines-used.txt
new file mode 100644
index 0000000..e691c09
--- /dev/null
+++ b/src/unix/arch-defines-used.txt
@@ -0,0 +1,9 @@
+src/unix/joystick-drivers/joy_i386.c:#elif defined __ARCH_linux
+src/unix/video-drivers/svgalib.c:#ifdef __CPU_i386
+src/unix/video-drivers/svgalib.c:#endif /* ifdef __CPU_i386 */
+src/unix/video-drivers/svgalib.c:#ifdef __CPU_i386
+src/unix/video-drivers/svgalib.c:#ifdef __CPU_i386
+src/unix/sysdep/dsp-drivers/oss.c:#ifdef __ARCH_freebsd
+src/unix/joystick-drivers/joy_i386.c:#ifdef __ARCH_netbsd
+src/unix/joystick-drivers/joy_i386.c:#ifdef __ARCH_netbsd
+src/unix/joystick-drivers/joy_i386.c:#ifdef __ARCH_netbsd
diff --git a/src/unix/cab/glmame/cabfront.jpg b/src/unix/cab/glmame/cabfront.jpg
new file mode 100644
index 0000000..c7238cd
Binary files /dev/null and b/src/unix/cab/glmame/cabfront.jpg differ
diff --git a/src/unix/cab/glmame/cabtitle.jpg b/src/unix/cab/glmame/cabtitle.jpg
new file mode 100644
index 0000000..3655e45
Binary files /dev/null and b/src/unix/cab/glmame/cabtitle.jpg differ
diff --git a/src/unix/cab/glmame/glmame.cab b/src/unix/cab/glmame/glmame.cab
new file mode 100644
index 0000000..59aeadc
--- /dev/null
+++ b/src/unix/cab/glmame/glmame.cab
@@ -0,0 +1,193 @@
+cabv1.0							# version number of the .cab format (required)
+								# must be the first 7 characters of the file
+#
+# Default GLmame cabinet
+#
+# Designed by Mike Oliphant
+#
+#
+camerapan 7						# we're going to define a 7-pan camera move
+
+#		  xyz location   xyz point      xyz norma   frames
+
+goto	  -5.0 0.0 5.0  0.0 0.0 -5.0   0.0 1.0 0.0
+moveto	  0.0 0.0 -12.0  0.0 -0.75 -20.0  0.0 1.0 0.0  120
+moveto	  0.0 0.0 -12.0  0.0 -0.75 -20.0  0.0 1.0 0.0  120
+moveto	  5.0 0.0 5.0  0.0 0.0 -5.0  0.0 1.0 0.0  120
+moveto	  0.0 0.0 10.0  0.0 -2.0 -20.0  0.0 1.0 0.0  120
+moveto	  0.0 0.0 10.0  0.0 -2.0 -20.0  0.0 1.0 0.0  120
+moveto	  -5.0 0.0 5.0  0.0 0.0 -5.0  0.0 1.0 0.0  120
+end  # camerapan ended with end statement
+
+numtex 2						# number of textures we are going to use
+
+loadtex 0 128 64 cabtitle.jpg	# load the title texture as texture 0
+                                # with dimensions 128x64
+
+loadtex 1 32 32 cabfront.jpg
+
+startgeom						# this line must come after the textures
+								#  have been loaded, but before any model
+								#  geometry is defined
+
+shading flat					# set flat shading
+
+color3 1.0 1.0 0.0				# set the color to yellow
+
+# left side of cabinet
+
+begin polygon					# begin a 6-vertex polygon
+vertex -2.0 -4.0 2.0
+vertex -2.0 -0.2 2.0
+vertex -2.0 0.0 1.0
+vertex -2.0 2.5 0.0
+vertex -2.0 2.5 -2.0
+vertex -2.0 -4.0 -2.0
+end 
+
+begin polygon
+vertex 2.0 2.5 0.0
+vertex 2.0 3.0 1.2
+vertex 2.0 4.0 1.0
+vertex 2.0 3.0 -2.0
+vertex 2.0 2.5 -2.0
+end 
+
+# Right side
+
+begin polygon
+vertex 2.0 -4.0 2.0
+vertex 2.0 -0.2 2.0
+vertex 2.0 0.0 1.0
+vertex 2.0 2.5 0.0
+vertex 2.0 2.5 -2.0
+vertex 2.0 -4.0 -2.0
+end 
+
+begin polygon
+vertex -2.0 2.5 0.0
+vertex -2.0 3.0 1.2
+vertex -2.0 4.0 1.0
+vertex -2.0 3.0 -2.0
+vertex -2.0 2.5 -2.0
+end 
+
+begin quad_strip						# begin a strip of quads
+										# (a series four-sided polygons where
+										# each shares an edge with the next
+# Back
+
+color3 1.0 0.0 0.0
+
+vertex -2.0 -4.0 -2.0
+vertex 2.0 -4.0 -2.0
+vertex -2.0 3.0 -2.0
+vertex 2.0 3.0 -2.0
+
+# Top
+
+color3 1.0 1.0 0.0
+
+vertex -2.0 4.0 1.0
+vertex 2.0 4.0 1.0
+
+end  # quad_strip
+
+# Title bit
+
+color3 1.0 1.0 1.0
+
+enable texture							# enable texturing
+
+settex 0								# select texture 0 (the title)
+
+begin quads
+texcoord 0 1
+vertex -2.0 4.0 1.0
+texcoord 1 1
+vertex 2.0 4.0 1.0
+texcoord 1 0
+vertex 2.0 3.0 1.2
+texcoord 0 0
+vertex -2.0 3.0 1.2
+end
+
+disable texture							# turn off texturing
+
+shading smooth
+
+begin quad_strip
+
+# Under top side
+
+color3 0.0 1.0 1.0
+
+vertex -2.0 3.0 1.2
+vertex 2.0 3.0 1.2
+
+color3 0.0 1.0 0.0
+
+vertex -2.0 2.5 0.0
+vertex 2.0 2.5 0.0
+
+# Screen backing
+
+color3 0.5 0.5 0.5
+
+vertex -2.0 0.0 1.0
+vertex 2.0 0.0 1.0
+
+# Control panel
+
+color3 0.0 0.0 1.0
+
+vertex -2.0 -0.2 2.0
+vertex 2.0 -0.2 2.0
+
+# Front
+
+end		# quad_strip
+
+shading flat								# switch to flat shading
+
+color3 1.0 1.0 1.0
+
+enable texture
+settex 1
+
+begin quads
+
+texcoord 0 1
+vertex -2.0 -0.2 2.0
+texcoord 1 1
+vertex 2.0 -0.2 2.0
+texcoord 1 0
+vertex 2.0 -4.0 2.0
+texcoord 0 0
+vertex -2.0 -4.0 2.0
+
+disable texture
+
+# Screen
+
+color3 0.0 0.0 0.0							# put black behind the screen
+
+vertex -1.7 2.5 0.005
+vertex 1.7 2.5 0.005
+vertex 1.7 0.0 1.05
+vertex -1.7 0.0 1.05
+end #quads
+
+color3 1.0 1.0 1.0							# Color to modulate the screen
+											# bitmap with (white means don't
+											# mess with it
+
+begin screen								# this tells GLmame where the
+vertex -1.7 2.5 0.01						# actual game screen should go
+vertex 1.7 2.5 0.01
+vertex 1.7 0.0 1.1
+vertex -1.7 0.0 1.1
+end #screen
+
+
+# that's all folks!
diff --git a/src/unix/cab/glmamejau/cabfront.jpg b/src/unix/cab/glmamejau/cabfront.jpg
new file mode 100644
index 0000000..c7238cd
Binary files /dev/null and b/src/unix/cab/glmamejau/cabfront.jpg differ
diff --git a/src/unix/cab/glmamejau/cabside.jpg b/src/unix/cab/glmamejau/cabside.jpg
new file mode 100644
index 0000000..ba080ab
Binary files /dev/null and b/src/unix/cab/glmamejau/cabside.jpg differ
diff --git a/src/unix/cab/glmamejau/cabtitle.jpg b/src/unix/cab/glmamejau/cabtitle.jpg
new file mode 100644
index 0000000..3655e45
Binary files /dev/null and b/src/unix/cab/glmamejau/cabtitle.jpg differ
diff --git a/src/unix/cab/glmamejau/glmamejau.cab b/src/unix/cab/glmamejau/glmamejau.cab
new file mode 100644
index 0000000..1265f25
--- /dev/null
+++ b/src/unix/cab/glmamejau/glmamejau.cab
@@ -0,0 +1,297 @@
+cabv1.1				# version number of the .cab format (required)
+				# must be the first 7 characters of the file
+#
+# Default GLmame cabinet
+#
+# Designed by Mike Oliphant
+#
+# Modified by Sven Goethel
+#
+#
+
+#	  xyz location   xyz point      xyz norma   frames
+
+#
+# still watch the right cabinet side
+#
+#camerapan 2
+#
+#goto     5.0 0.0 -1.0  0.0 0.0 -1.0  0.0 1.0 0.0  120
+#moveto   5.0 0.0 -1.0  0.0 0.0 -1.0  0.0 1.0 0.0  120
+#end
+#
+
+#
+# watch from the left , front, right, and back
+#
+camerapan 8
+
+goto     -5.0 0.0 -0.5  0.0 -0.2 -1.0  0.0 1.0 0.0  120    # left
+moveto	  0.0 0.0 4.0  0.0 -0.75 -5.0  0.0 1.0 0.0  120   # far fron
+moveto	  0.0 0.0 -1.0  0.0 -0.75 -4.5  0.0 1.0 0.0  180  # near front ..
+moveto	  0.0 0.0 -1.0  0.0 -0.75 -5.0  0.0 1.0 0.0  180 # near front
+moveto	  0.0 0.0 4.0  0.0 -0.75 -5.0  0.0 1.0 0.0  120   # far front
+moveto   5.0 0.0 -1.0  0.0 0.0 -1.0  0.0 1.0 0.0  120      # right
+moveto	  0.0 0.0 4.0  0.0 -0.75 -5.0  0.0 1.0 0.0  120    # far front
+moveto   -5.0 0.0 -1.0  0.0 -0.2 -1.0  0.0 1.0 0.0  120    # left
+end
+
+numtex 3			# number of textures we are going to use
+
+loadtex 0 128 64 cabtitle.jpg	# load the title texture as texture 0
+                                # with dimensions 128x64
+
+loadtex 1 32 32  cabfront.jpg
+
+loadtex 2 256 64 cabside.jpg
+
+startgeom			# this line must come after the textures
+				#  have been loaded, but before any model
+				#  geometry is defined
+
+shading smooth
+
+color3 1.0 1.0 0.0		# set the color to yellow
+
+# left side of cabinet
+
+begin polygon			# begin a 6-vertex polygon
+vertex -2.0 -4.0 2.0
+vertex -2.0 -0.2 2.0
+vertex -2.0 0.0 1.0
+vertex -2.0 2.5 0.0
+vertex -2.0 2.5 -2.0
+vertex -2.0 -4.0 -2.0
+end 
+
+begin polygon
+vertex 2.0 2.5 0.0
+vertex 2.0 3.0 1.2
+vertex 2.0 4.0 1.0
+vertex 2.0 3.0 -2.0
+vertex 2.0 2.5 -2.0
+end 
+
+color3 1.0 1.0 1.0
+
+enable texture	# enable texturing
+
+settex 2	# select texture 0 (the jau-side left)
+
+begin quads
+texcoord 0 1
+vertex -2.001 3.4 -0.6 # P1
+
+texcoord 1 1
+vertex -2.001 -3.0  2.0 # P2
+
+texcoord 1 0
+vertex -2.001 -3.5 0.7 # P3
+
+texcoord 0 0
+vertex -2.001 2.8 -2.0 # P4
+
+end
+
+disable texture	# turn off texturing
+
+#
+# just some checkpoints !
+#
+pointsize 20
+
+begin points
+
+color3 0.0 0.0 1.0
+vertex -2.001 3.4 -0.6 # P1
+vertex -2.001 -3.0  2.0 # P2
+vertex -2.001 -3.5 0.7 # P3
+vertex -2.001 2.8 -2.0 # P4
+
+end
+
+pointsize 1
+
+
+color3 1.0 1.0 0.0		# set the color to yellow
+
+# Right side
+
+begin polygon
+vertex 2.0 -4.0 2.0
+vertex 2.0 -0.2 2.0
+vertex 2.0 0.0 1.0
+vertex 2.0 2.5 0.0
+vertex 2.0 2.5 -2.0
+vertex 2.0 -4.0 -2.0
+end 
+
+begin polygon
+vertex -2.0 2.5 0.0
+vertex -2.0 3.0 1.2
+vertex -2.0 4.0 1.0
+vertex -2.0 3.0 -2.0
+vertex -2.0 2.5 -2.0
+end 
+
+color3 1.0 1.0 1.0
+
+enable texture	# enable texturing
+
+settex 2	# select texture 0 (the jau-side right)
+
+begin quads
+texcoord 1 1
+vertex 2.001 3.4 -0.6 # P1
+
+texcoord 0 1
+vertex 2.001 -3.0  2.0 # P2
+
+texcoord 0 0
+vertex 2.001 -3.5 0.7 # P3
+
+texcoord 1 0
+vertex 2.001 2.8 -2.0 # P4
+
+end
+
+disable texture	# turn off texturing
+
+#
+# just some checkpoints !
+#
+pointsize 20
+
+begin points
+
+color3 0.0 0.0 1.0
+vertex 2.001 3.4 -0.6 # P1
+vertex 2.001 -3.0  2.0 # P2
+vertex 2.001 -3.5 0.7 # P3
+vertex 2.001 2.8 -2.0 # P4
+
+end
+
+pointsize 1
+
+
+color3 1.0 1.0 0.0		# set the color to yellow
+
+begin quad_strip		# begin a strip of quads
+										# (a series four-sided polygons where
+										# each shares an edge with the next
+# Back
+
+color3 1.0 0.0 0.0
+
+vertex -2.0 -4.0 -2.0
+vertex 2.0 -4.0 -2.0
+vertex -2.0 3.0 -2.0
+vertex 2.0 3.0 -2.0
+
+# Top
+
+color3 1.0 1.0 0.0
+
+vertex -2.0 4.0 1.0
+vertex 2.0 4.0 1.0
+
+end  # quad_strip
+
+# Title bit
+
+color3 1.0 1.0 1.0
+
+enable texture	# enable texturing
+
+settex 0	# select texture 0 (the title)
+
+begin quads
+texcoord 0 1
+vertex -2.0 4.0 1.0
+texcoord 1 1
+vertex 2.0 4.0 1.0
+texcoord 1 0
+vertex 2.0 3.0 1.2
+texcoord 0 0
+vertex -2.0 3.0 1.2
+end
+
+disable texture	# turn off texturing
+
+begin quad_strip
+
+# Under top side
+
+color3 0.0 1.0 1.0
+
+vertex -2.0 3.0 1.2
+vertex 2.0 3.0 1.2
+
+color3 0.0 1.0 0.0
+
+vertex -2.0 2.5 0.0
+vertex 2.0 2.5 0.0
+
+# Screen backing
+
+color3 0.5 0.5 0.5
+
+vertex -2.0 0.0 1.0
+vertex 2.0 0.0 1.0
+
+# Control panel
+
+color3 0.0 0.0 1.0
+
+vertex -2.0 -0.2 2.0
+vertex 2.0 -0.2 2.0
+
+# Front
+
+end		# quad_strip
+
+color3 1.0 1.0 1.0
+
+enable texture
+
+settex 1
+
+begin quads
+texcoord 0 1
+vertex -2.0 -0.2 2.0
+texcoord 1 1
+vertex 2.0 -0.2 2.0
+texcoord 1 0
+vertex 2.0 -4.0 2.0
+texcoord 0 0
+vertex -2.0 -4.0 2.0
+end
+
+disable texture
+
+begin quads
+
+# Screen
+
+color3 0.0 0.0 0.0			# put black behind the screen
+
+vertex -1.7 2.5 0.005
+vertex 1.7 2.5 0.005
+vertex 1.7 0.0 1.05
+vertex -1.7 0.0 1.05
+end #quads
+
+color3 1.0 1.0 1.0			# Color to modulate the screen
+											# bitmap with (white means don't
+											# mess with it
+
+begin screen			# this tells GLmame where the
+vertex -1.7 2.5 0.01		# actual game screen should go
+vertex 1.7 2.5 0.01
+vertex 1.7 0.0 1.1
+vertex -1.7 0.0 1.1
+end #screen
+
+
+# that's all folks!
diff --git a/src/unix/cab/trans/trans.cab b/src/unix/cab/trans/trans.cab
new file mode 100644
index 0000000..5e54fa5
--- /dev/null
+++ b/src/unix/cab/trans/trans.cab
@@ -0,0 +1,88 @@
+cabv1.0							# version number of the .cab format (required)
+								# must be the first 7 characters of the file
+#
+# Transparrent "cabinet"
+#
+# Designed by Mike Oliphant
+#
+#
+camerapan 7						# we're going to define a 7-pan camera move
+
+#		  xyz location   xyz point      xyz norma   frames
+
+goto	  -5.0 0.0 5.0  0.0 0.0 -5.0   0.0 1.0 0.0
+moveto	  0.0 0.0 -12.0  0.0 -0.75 -20.0  0.0 1.0 0.0  120
+moveto	  0.0 0.0 -12.0  0.0 -0.75 -20.0  0.0 1.0 0.0  120
+moveto	  5.0 0.0 5.0  0.0 0.0 -5.0  0.0 1.0 0.0  120
+moveto	  0.0 0.0 10.0  0.0 -2.0 -20.0  0.0 1.0 0.0  120
+moveto	  0.0 0.0 10.0  0.0 -2.0 -20.0  0.0 1.0 0.0  120
+moveto	  -5.0 0.0 5.0  0.0 0.0 -5.0  0.0 1.0 0.0  120
+end  # camerapan ended with end statement
+
+startgeom						# this line must come after the textures
+								#  have been loaded, but before any model
+								#  geometry is defined
+
+shading flat					# set flat shading
+
+color3 1.0 0.0 0.0
+
+begin quad_strip
+
+vertex -1.7 0.0 0.0
+vertex -1.7 2.5 0.0
+
+color3 0.0 1.0 0.0
+
+vertex -1.7 0.0 -2.0
+vertex -1.7 2.5 -2.0
+
+color3 0.0 0.0 1.0
+
+vertex 1.7 0.0 -2.0
+vertex 1.7 2.5 -2.0
+
+color3 1.0 0.0 0.0
+
+vertex 1.7 0.0 0.0
+vertex 1.7 2.5 0.0
+
+end  # quad_strip
+
+color3 1.0 1.0 0.0
+
+begin quads
+
+vertex -1.7 2.5 0.0
+vertex -1.7 2.5 -2.0
+vertex 1.7 2.5 -2.0
+vertex 1.7 2.5 0.0
+
+vertex -1.7 0.0 0.0
+vertex -1.7 0.0 -2.0
+vertex 1.7 0.0 -2.0
+vertex 1.7 0.0 0.0
+
+end  # quads
+
+# Screen
+
+color3 0.0 0.0 0.0							# put black behind the screen
+
+vertex -1.7 2.5 0.005
+vertex 1.7 2.5 0.005
+vertex 1.7 0.0 0.005
+vertex -1.7 0.0 0.005
+end #quads
+
+color4 1.0 1.0 1.0 0.5
+
+begin screen								# this tells GLmame where the
+vertex -1.7 2.5 0.01						# actual game screen should go
+vertex 1.7 2.5 0.01
+vertex 1.7 0.0 0.01
+vertex -1.7 0.0 0.01
+end #screen
+
+
+# that's all folks!
diff --git a/src/unix/config.c b/src/unix/config.c
new file mode 100644
index 0000000..0241548
--- /dev/null
+++ b/src/unix/config.c
@@ -0,0 +1,741 @@
+/*
+ * X-mame config-file and commandline parsing
+ * We don't use stderr_file resp stdout_file in here since we don't know if 
+ * it's valid yet.
+ */
+
+#define __CONFIG_C_
+#include <time.h>
+#include "xmame.h"
+#include "fileio.h"
+#include "driver.h"
+#include "audit.h"
+#include "sysdep/sysdep_dsp.h"
+#include "sysdep/sysdep_mixer.h"
+#include "sysdep/misc.h"
+#include "effect.h"
+
+/* be sure that device names are nullified */
+extern void XInput_trackballs_reset();
+
+/* from ... */
+extern char *cheatfile;
+extern char *db_filename;
+extern char *history_filename;
+extern char *mameinfo_filename;
+
+extern char *playbackname;
+extern char *recordname;
+
+/* some local vars */
+static int showconfig = 0;
+static int showmanusage = 0;
+static int showversion = 0;
+static int showusage  = 0;
+static int use_fuzzycmp = 1;
+static int loadconfig = 1;
+static char *language = NULL;
+static char *gamename = NULL;
+char *rompath_extra = NULL;
+#ifndef MESS
+static char *defaultgamename;
+#else
+static const char *mess_opts;
+void build_crc_database_filename(int game_index);
+
+static int specify_ram(struct rc_option *option, const char *arg, int priority)
+{
+	UINT32 specified_ram;
+
+	specified_ram = ram_parse_string(arg);
+	if (specified_ram == 0)
+	{
+		fprintf(stderr, "Cannot recognize the RAM option %s; aborting\n", arg);
+		return -1;
+	}
+	options.ram = specified_ram;
+	return 0;
+}
+#endif
+
+static int config_handle_arg(char *arg);
+#ifdef MAME_DEBUG
+static int config_handle_debug_size(struct rc_option *option, const char *arg,
+		int priority);
+#endif
+void show_usage(void);
+
+#ifdef MESS
+static int add_device(struct rc_option *option, const char *arg, int priority);
+#endif
+
+/* struct definitions */
+static struct rc_option opts[] = {
+   /* name, shortname, type, dest, deflt, min, max, func, help */
+	{ NULL, NULL, rc_link, video_opts, NULL, 0, 0, NULL, NULL },
+	{ NULL, NULL, rc_link, sound_opts, NULL, 0, 0, NULL, NULL },
+	{ NULL, NULL, rc_link, input_opts, NULL, 0, 0, NULL, NULL },
+	{ NULL, NULL, rc_link, network_opts, NULL, 0, 0, NULL, NULL },
+	{ NULL, NULL, rc_link, fileio_opts, NULL, 0, 0, NULL, NULL },
+#ifdef MESS
+	/* FIXME - these option->names should NOT be hardcoded! */
+	{ "MESS specific options", NULL, rc_seperator, NULL, NULL, 0, 0, NULL, NULL },
+	{ "cartridge", "cart", rc_string, &mess_opts, NULL, 0, 0, add_device, "Attach software to cartridge device" },
+	{ "floppydisk","flop", rc_string, &mess_opts, NULL, 0, 0, add_device, "Attach software to floppy disk device" },
+	{ "harddisk",  "hard", rc_string, &mess_opts, NULL, 0, 0, add_device, "Attach software to hard disk device" },
+	{ "cylinder",  "cyln", rc_string, &mess_opts, NULL, 0, 0, add_device, "Attach software to cylinder device" },
+	{ "cassette",  "cass", rc_string, &mess_opts, NULL, 0, 0, add_device, "Attach software to cassette device" },
+	{ "punchcard", "pcrd", rc_string, &mess_opts, NULL, 0, 0, add_device, "Attach software to punch card device" },
+	{ "punchtape", "ptap", rc_string, &mess_opts, NULL, 0, 0, add_device, "Attach software to punch tape device" },
+	{ "printer",   "prin", rc_string, &mess_opts, NULL, 0, 0, add_device, "Attach software to printer device" },
+	{ "serial",    "serl", rc_string, &mess_opts, NULL, 0, 0, add_device, "Attach software to serial device" },
+	{ "parallel",  "parl", rc_string, &mess_opts, NULL, 0, 0, add_device, "Attach software to parallel device" },
+	{ "snapshot",  "dump", rc_string, &mess_opts, NULL, 0, 0, add_device, "Attach software to snapshot device" },
+	{ "quickload", "quik", rc_string, &mess_opts, NULL, 0, 0, add_device, "Attach software to quickload device" },
+	{ "ramsize", "ram", rc_string, &mess_opts, NULL, 0, 0, specify_ram, "Specifies size of RAM (if supported by driver)" },
+#else
+	{ "MAME Related", NULL, rc_seperator, NULL, NULL, 0, 0, NULL, NULL },
+	{ "defaultgame", "def", rc_string, &defaultgamename, "pacman", 0, 0, NULL, "Set the default game started when no game is given on the commandline, only useful for in the configfiles" },
+#endif
+	{ "language", "lang", rc_string, &language, "english", 0, 0, NULL, "Select the language for the menus and osd" },
+	{ "fuzzycmp", "fc", rc_bool, &use_fuzzycmp, "1", 0, 0, NULL, "Enable/disable use of fuzzy gamename matching when there is no exact match" },
+	{ "cheat", "c", rc_bool, &options.cheat, "0", 0, 0, NULL, "Enable/disable cheat subsystem" },
+	{ "skip_disclaimer", NULL, rc_bool, &options.skip_disclaimer, "0", 0, 0, NULL, "Skip displaying the disclaimer screen" },
+	{ "skip_gameinfo", NULL, rc_bool, &options.skip_gameinfo, "0", 0, 0, NULL, "Skip displaying the game info screen" },
+	{ "crconly", NULL, rc_bool, &options.crc_only, "0", 0, 0, NULL, "Use only CRC for all integrity checks" },
+	{ "bios", NULL, rc_string, &options.bios, "default", 0, 14, NULL, "change system bios" },
+#ifdef MAME_DEBUG
+	{ "debug", "d", rc_bool, &options.mame_debug, NULL, 0, 0, NULL, "Enable/disable debugger" },
+	{ "debug-size", "ds", rc_use_function, NULL, "640x480", 0, 0, config_handle_debug_size, "Specify the resolution/window size to use for the debugger (window) in the form of XRESxYRES (minimum size = 640x480)" },
+#endif
+	{ NULL, NULL, rc_link, frontend_list_opts, NULL, 0, 0, NULL, NULL },
+	{ NULL, NULL, rc_link, frontend_ident_opts, NULL, 0, 0, NULL, NULL },
+	{ "General Options", NULL, rc_seperator, NULL, NULL, 0, 0, NULL, NULL },
+	{ "loadconfig", "lcf", rc_bool, &loadconfig, "1", 0, 0, NULL, "Load (don't load) configfiles" },
+	{ "showconfig", "sc", rc_set_int, &showconfig, NULL, 1, 0, NULL, "Display running parameters in rc style" },
+	{ "manhelp", "mh", rc_set_int, &showmanusage, NULL, 1, 0, NULL, "Print commandline help in man format, useful for manpage creation" },
+	{ "version", "V", rc_set_int, &showversion, NULL, 1, 0, NULL, "Display version" },
+	{ "help", "?", rc_set_int, &showusage, NULL, 1, 0, NULL, "Show this help" },
+	{ NULL, NULL, rc_end, NULL, NULL, 0, 0, NULL, NULL }
+};
+
+/* fuzzy string compare, compare short string against long string        */
+/* e.g. astdel == "Asteroids Deluxe". The return code is the fuzz index, */
+/* we simply count the gaps between maching chars.                       */
+static int fuzzycmp (const char *s, const char *l)
+{
+	int gaps = 0;
+	int match = 0;
+	int last = 1;
+
+	for (; *s && *l; l++)
+	{
+		if (*s == *l)
+			match = 1;
+		else if (*s >= 'a' && *s <= 'z' && (*s - 'a') == (*l - 'A'))
+			match = 1;
+		else if (*s >= 'A' && *s <= 'Z' && (*s - 'A') == (*l - 'a'))
+			match = 1;
+		else
+			match = 0;
+
+		if (match)
+			s++;
+
+		if (match != last)
+		{
+			last = match;
+			if (!match)
+				gaps++;
+		}
+	}
+
+	/* penalty if short string does not completely fit in */
+	for (; *s; s++)
+		gaps++;
+
+	return gaps;
+}
+
+#ifndef MESS
+/* for verify roms which is used for the random game selection */
+static int config_printf(const char *fmt, ...)
+{
+	return 0;
+}
+#endif
+
+static int config_handle_arg(char *arg)
+{
+	static int got_gamename = 0;
+
+	if (!got_gamename) /* notice: for MESS game means system */
+	{
+		gamename     = arg;
+		got_gamename = 1;
+	}
+	else
+#ifdef MESS
+	{
+		if( options.image_count >= MAX_IMAGES )
+		{
+			fprintf(stderr, "error: too many image names specified!\n");
+			return -1;
+		}
+		/* options.image_files[options.image_count].type = iodevice_type; */
+		/* options.image_files[options.image_count].name = arg; */
+		/* options.image_count++; */
+	}
+#else
+	{
+		fprintf(stderr,"error: duplicate gamename: %s\n", arg);
+		return -1;
+	}
+#endif
+
+	return 0;
+}
+
+#ifdef MAME_DEBUG
+static int config_handle_debug_size(struct rc_option *option, const char *arg,
+		int priority)
+{
+	int width, height;
+
+	if (sscanf(arg, "%dx%d", &width, &height) == 2)
+	{
+		if((width >= 640) && (height >= 480))
+		{
+			options.debug_width  = width;
+			options.debug_height = height;
+			return 0;
+		}
+	}
+	fprintf(stderr,
+			"error: invalid debugger size or too small (minimum size = 640x480): \"%s\".\n",
+			arg);
+	return -1;
+}
+#endif /* MAME_DEBUG */
+
+/*
+ * get configuration from configfile and env.
+ */
+int config_init (int argc, char *argv[])
+{
+	char buffer[BUF_SIZE];
+	unsigned char lsb_test[2]={0,1};
+	int i;
+
+	memset(&options,0,sizeof(options));
+
+	/* reset trackball devices */
+#ifdef USE_XINPUT_DEVICES
+	XInput_trackballs_reset();
+#endif
+
+	/* Let's see if the endianess of this arch is correct; otherwise,
+	   YELL about it and bail out. */
+#ifdef LSB_FIRST
+	if(*((unsigned short*)lsb_test) != 0x0100)
+#else	
+	if(*((unsigned short*)lsb_test) != 0x0001)
+#endif
+	{
+		fprintf(stderr, "error: compiled byte ordering doesn't match machine byte ordering\n"
+				"are you sure you choose the right arch?\n"
+#ifdef LSB_FIRST
+				"compiled for lsb-first, are you sure you choose the right cpu in makefile.unix\n");
+#else
+				"compiled for msb-first, are you sure you choose the right cpu in makefile.unix\n");
+#endif
+		return OSD_NOT_OK;
+	}
+
+	/* some settings which are static for xmame and thus aren't controled
+	   by options */
+	options.gui_host = 1;
+	cheatfile = NULL;
+	db_filename = NULL;
+	history_filename = NULL;
+	mameinfo_filename = NULL;
+
+	/* create the rc object */
+	if (!(rc = rc_create()))
+		return OSD_NOT_OK;
+
+	if(sysdep_dsp_init(rc, NULL))
+		return OSD_NOT_OK;
+
+	if(sysdep_mixer_init(rc, NULL))
+		return OSD_NOT_OK;
+
+	if(rc_register(rc, opts))
+		return OSD_NOT_OK;
+
+	/* get the homedir */
+	if(!(home_dir = rc_get_home_dir()))
+		return OSD_NOT_OK;
+
+	/* check that the required dirs exist, and create them if necessary */
+	snprintf(buffer, BUF_SIZE, "%s/.%s", home_dir, NAME);
+	if (rc_check_and_create_dir(buffer))
+		return OSD_NOT_OK;
+
+	snprintf(buffer, BUF_SIZE, "%s/.%s/%s", home_dir, NAME, "cfg");
+	if (rc_check_and_create_dir(buffer))
+		return OSD_NOT_OK;
+
+	snprintf(buffer, BUF_SIZE, "%s/.%s/%s", home_dir, NAME, "mem");
+	if (rc_check_and_create_dir(buffer))
+		return OSD_NOT_OK;
+
+	snprintf(buffer, BUF_SIZE, "%s/.%s/%s", home_dir, NAME, "sta");
+	if (rc_check_and_create_dir(buffer))
+		return OSD_NOT_OK;
+
+	snprintf(buffer, BUF_SIZE, "%s/.%s/%s", home_dir, NAME, "nvram");
+	if (rc_check_and_create_dir(buffer))
+		return OSD_NOT_OK;
+
+	snprintf(buffer, BUF_SIZE, "%s/.%s/%s", home_dir, NAME, "diff");
+	if (rc_check_and_create_dir(buffer))
+		return OSD_NOT_OK;
+
+	snprintf(buffer, BUF_SIZE, "%s/.%s/%s", home_dir, NAME, "rc");
+	if (rc_check_and_create_dir(buffer))
+		return OSD_NOT_OK;
+
+	snprintf(buffer, BUF_SIZE, "%s/.%s/%s", home_dir, NAME, "hi");
+	if (rc_check_and_create_dir(buffer))
+		return OSD_NOT_OK;
+
+	snprintf(buffer, BUF_SIZE, "%s/.%s/%s", home_dir, NAME, "inp");
+	if (rc_check_and_create_dir(buffer))
+		return OSD_NOT_OK;
+
+	/* parse the commandline */
+	if (rc_parse_commandline(rc, argc, argv, 2, config_handle_arg))
+		return OSD_NOT_OK;
+
+	/* parse the various configfiles, starting with the one with the
+	   lowest priority */
+	if(loadconfig)
+	{
+		snprintf(buffer, BUF_SIZE, "%s/%src", XMAMEROOT, NAME);
+		if(rc_load(rc, buffer, 1, 1))
+			return OSD_NOT_OK;
+		snprintf(buffer, BUF_SIZE, "%s/.%s/%src", home_dir, NAME, NAME);
+		if(rc_load(rc, buffer, 1, 1))
+			return OSD_NOT_OK;
+		snprintf(buffer, BUF_SIZE, "%s/%s-%src", XMAMEROOT, NAME, DISPLAY_METHOD);
+		if(rc_load(rc, buffer, 1, 1))
+			return OSD_NOT_OK;
+		snprintf(buffer, BUF_SIZE, "%s/.%s/%s-%src", home_dir, NAME, NAME,
+				DISPLAY_METHOD);
+		if(rc_load(rc, buffer, 1, 1))
+			return OSD_NOT_OK;
+	}
+
+	/* setup stderr_file and stdout_file */
+	if (!stderr_file) stderr_file = stderr;
+	if (!stdout_file) stdout_file = stdout;
+
+	effect_init1();
+
+	if (showconfig)
+	{
+		rc_write(rc, stdout_file, NAME" running parameters");
+		return OSD_OK;
+	}
+
+	if (showmanusage)
+	{
+		rc_print_man_options(rc, stdout_file);
+		return OSD_OK;
+	}
+
+	if (showversion)
+	{
+		fprintf(stdout_file, "%s\n", title);
+		return OSD_OK;
+	}
+
+	if (showusage)
+	{
+		show_usage();
+		return OSD_OK;
+	}
+
+	/* handle frontend options */
+	if ( (i=frontend_list(gamename)) != 1234)
+		return i;
+
+	if ( (i=frontend_ident(gamename)) != 1234)
+		return i;
+
+	if (playbackname)
+	{
+		options.playback = mame_fopen(playbackname, 0, FILETYPE_INPUTLOG, 0);
+		if (!options.playback)
+		{
+			fprintf(stderr, "failed to open %s for playback\n", playbackname);
+			exit(1);
+		}
+	}
+
+	/* check for game name embedded in .inp header */
+	if (options.playback)
+	{
+		INP_HEADER inp_header;
+
+		/* read playback header */
+		mame_fread(options.playback, &inp_header, sizeof(INP_HEADER));
+
+		if (!isalnum(inp_header.name[0])) /* If first byte is not alpha-numeric */
+			mame_fseek(options.playback, 0, SEEK_SET); /* old .inp file - no header */
+		else
+		{
+			for (i = 0; (drivers[i] != 0); i++) /* find game and play it */
+			{
+				if (strcmp(drivers[i]->name, inp_header.name) == 0)
+				{
+					game_index = i;
+					gamename = (char *)drivers[i]->name;
+					printf("Playing back previously recorded game %s (%s) [press return]\n",
+							drivers[game_index]->name,drivers[game_index]->description);
+					getchar();
+					break;
+				}
+			}
+		}
+	}
+
+	/* handle the game selection */
+	game_index = -1;
+
+	if (!gamename)
+#ifdef MESS
+	{
+		show_usage();
+		return OSD_NOT_OK;
+	}
+#else
+	gamename = defaultgamename;
+
+	/* random game? */
+	if (strcasecmp(gamename, "random") == 0)
+	{
+		for (i=0; drivers[i]; i++) ; /* count available drivers */
+
+		srand(time(NULL));
+
+		for(;;)
+		{
+			game_index = (float)rand()*i/RAND_MAX;
+
+			fprintf(stdout_file, "Random game selected: %s (%s)\n  verifying roms... ",drivers[game_index]->name,drivers[game_index]->description);
+			if(VerifyRomSet (game_index, (verify_printf_proc)config_printf) == CORRECT)
+			{
+				fprintf(stdout_file, "OK\n");
+				break;
+			}
+			else
+				fprintf(stdout_file, "FAILED\n");
+		}
+	}
+	else
+#endif
+		/* do we have a driver for this? */
+#ifdef MESS
+		for (i = 0; drivers[i]; i++)
+		{
+			if (strcasecmp(gamename,drivers[i]->name) == 0)
+			{
+				game_index = i;
+				break;
+			}
+		}
+#else
+	{
+		char *begin = strrchr(gamename, '/'), *end;
+		int len;
+
+		if (begin == 0)
+			begin = gamename;
+		else
+			begin++;
+
+		end = strchr(begin, '.');
+		if (end == 0)
+			len = strlen(begin);
+		else
+			len = end - begin;            
+
+		for (i = 0; drivers[i]; i++)
+		{
+			if (strncasecmp(begin, drivers[i]->name, len) == 0 
+					&& len == strlen(drivers[i]->name))
+			{
+				begin = strrchr(gamename,'/');
+				if (begin)
+				{
+					*begin='\0'; /* dynamic allocation and copying will be better */
+					rompath_extra = malloc(strlen(gamename) + 1);
+					strcpy(rompath_extra, gamename);
+				}
+				game_index = i;
+				break;
+			}
+		}
+	}
+#endif                                
+
+	/* educated guess on what the user wants to play */
+	if ( (game_index == -1) && use_fuzzycmp)
+	{
+		int fuzz = 9999; /*best fuzz factor so far*/
+
+		for (i = 0; (drivers[i] != 0); i++)
+		{
+			int tmp;
+			tmp = fuzzycmp(gamename, drivers[i]->description);
+			/* continue if the fuzz index is worse */
+			if (tmp > fuzz)
+				continue;
+			/* on equal fuzz index, we prefear working, original games */
+			if (tmp == fuzz)
+			{
+				/* game is a clone */
+				if (drivers[i]->clone_of != 0 && !(drivers[i]->clone_of->flags & NOT_A_DRIVER))
+				{
+					if ((!drivers[game_index]->flags & GAME_NOT_WORKING) || (drivers[i]->flags & GAME_NOT_WORKING))
+						continue;
+				}
+				else continue;
+			}
+
+
+			/* we found a better match */
+			game_index = i;
+			fuzz = tmp;
+		}
+
+		if (game_index != -1)
+			fprintf(stdout_file,
+					"fuzzy name compare, running %s\n", drivers[game_index]->name);
+	}
+
+	if (game_index == -1)
+	{
+		fprintf(stderr_file, "\"%s\" not supported\n", gamename);
+		return OSD_NOT_OK;
+	}
+
+	/* now that we've got the gamename parse the game specific configfile */
+	if (loadconfig)
+	{
+		snprintf(buffer, BUF_SIZE, "%s/rc/%src", XMAMEROOT,
+				drivers[game_index]->name);
+		if(rc_load(rc, buffer, 1, 1))
+			return OSD_NOT_OK;
+		snprintf(buffer, BUF_SIZE, "%s/.%s/rc/%src", home_dir, NAME,
+				drivers[game_index]->name);
+		if(rc_load(rc, buffer, 1, 1))
+			return OSD_NOT_OK;
+	}
+
+#ifdef MESS
+	build_crc_database_filename(game_index);
+
+	/* set the image type if nescesarry */
+	for(i=0; i<options.image_count; i++)
+	{
+		if(options.image_files[i].type)
+		{
+			logerror("User specified %s for %s\n",
+					device_typename(options.image_files[i].type),
+					options.image_files[i].name);
+		}
+		else
+		{
+			char *ext;
+			char name[BUF_SIZE];
+			const struct IODevice *dev;
+
+			/* make a copy of the name */
+			strncpy(name, options.image_files[i].name, BUF_SIZE);
+			/* strncpy is buggy */
+			name[BUF_SIZE-1]=0;
+
+			/* get ext, skip .gz */
+			ext = strrchr(name, '.');
+			if (ext && !strcmp(ext, ".gz"))
+			{
+				*ext = 0;
+				ext = strrchr(name, '.');
+			}
+
+			/* Look up the filename extension in the drivers device list */
+			if (ext && (dev = device_first(drivers[game_index])))
+			{
+				ext++; /* skip the "." */
+
+				while (dev)
+				{
+					const char *dst = dev->file_extensions;
+					/* scan supported extensions for this device */
+					while (dst && *dst)
+					{
+						if (strcasecmp(dst,ext) == 0)
+						{
+							logerror("Extension match %s [%s] for %s\n",
+									device_typename(dev->type), dst,
+									options.image_files[i].name);
+
+							options.image_files[i].type = dev->type;
+						}
+						/* skip '\0' once in the list of extensions */
+						dst += strlen(dst) + 1;
+					}
+					dev = device_next(drivers[game_index], dev); 
+				}
+			}
+			if(!options.image_files[i].type)
+				options.image_files[i].type = IO_CARTSLOT;
+		}
+	}
+#endif
+
+	if (recordname)
+	{
+		options.record = mame_fopen(recordname, 0, FILETYPE_INPUTLOG, 1);
+		if (!options.record)
+		{
+			fprintf(stderr_file, "failed to open %s for recording\n", recordname);
+			exit(1);
+		}
+	}
+
+	if (options.record)
+	{
+		INP_HEADER inp_header;
+
+		memset(&inp_header, '\0', sizeof(INP_HEADER));
+		strcpy(inp_header.name, drivers[game_index]->name);
+		mame_fwrite(options.record, &inp_header, sizeof(INP_HEADER));
+	}
+
+	if(language)
+		options.language_file = mame_fopen(0,language,FILETYPE_LANGUAGE,0);
+
+	return 1234;
+}
+
+void config_exit(void)
+{
+	if(rc)
+	{
+		sysdep_mixer_exit();
+		sysdep_dsp_exit();
+		rc_destroy(rc);
+	}
+
+	if(home_dir)
+		free(home_dir);
+
+	/* close open files */
+	if (options.playback)
+		mame_fclose(options.playback);
+	if (options.record)
+		mame_fclose(options.record);
+	if (options.language_file)
+		mame_fclose(options.language_file);
+}
+
+/* 
+ * show help and exit
+ */
+void show_usage(void) 
+{
+	/* header */
+	fprintf(stdout_file, 
+#ifdef MESS
+			"Usage: xmess <system> [game] [options]\n"
+#else
+			"Usage: xmame [game] [options]\n"
+#endif 
+			"Options:\n");
+
+	/* actual help message */
+	rc_print_help(rc, stdout_file);
+
+	/* footer */
+	fprintf(stdout_file, "\nFiles:\n\n");
+	fprintf(stdout_file, "Config Files are parsed in the following order:\n");
+	fprint_columns(stdout_file, XMAMEROOT"/"NAME"rc",
+			"Global configuration config file");
+	fprint_columns(stdout_file, "${HOME}/."NAME"/"NAME"rc",
+			"User configuration config file");
+	fprint_columns(stdout_file, XMAMEROOT"/"NAME"-"DISPLAY_METHOD"rc",
+			"Global per display method config file");
+	fprint_columns(stdout_file, "${HOME}/."NAME"/"NAME"-"DISPLAY_METHOD"rc",
+			"User per display method config file");
+	fprint_columns(stdout_file, XMAMEROOT"/rc/<game>rc",
+			"Global per game config file");
+	fprint_columns(stdout_file, "${HOME}/."NAME"/rc/<game>rc",
+			"User per game config file");
+	/*  fprintf(stdout_file, "\nEnvironment variables:\n\n");
+	    fprint_columns(stdout_file, "ROMPATH", "Rom search path"); */
+	fprintf(stdout_file, "\n"
+#ifdef MESS
+			"M.E.S.S. - Multi-Emulator Super System\n"
+			"Copyright (C) 1998-2003 by the MESS team\n"
+#else
+			"M.A.M.E. - Multiple Arcade Machine Emulator\n"
+			"Copyright (C) 1997-2003 by Nicola Salmoria and the MAME Team\n"
+#endif
+			"%s port maintained by Lawrence Gold\n", NAME);
+}
+
+#ifdef MESS
+/*	add_device() is called when the MESS CLI option has been identified
+ *	This searches throught the devices{} struct array to grab the ID of the
+ *	option, which then registers the device using register_device()
+ */
+static int add_device(struct rc_option *option, const char *arg, int priority)
+{
+	int id;
+	id = device_typeid(option->name);
+	if (id < 0)
+	{
+		/* If we get to here, log the error - This is mostly due to a mismatch in the array */
+		logerror("Command Line Option [-%s] not a valid device - ignoring\n", option->name);
+		return -1;
+	}
+
+	/* A match!  we now know the ID of the device */
+	option->priority = priority;
+	return register_device(id, arg);
+}
+#endif
+
+
+/*============================================================ */
+/*	logerror */
+/*============================================================ */
+
+extern FILE *errorlog;
+
+void logerror(const char *text, ...)
+{
+	va_list arg;
+
+	if (errorlog)
+	{
+		va_start(arg, text);
+		vfprintf(errorlog, text, arg);
+		va_end(arg);
+		fflush(errorlog);
+	}
+}
diff --git a/src/unix/contrib/cutzlib-1.1.4/Makefile b/src/unix/contrib/cutzlib-1.1.4/Makefile
new file mode 100644
index 0000000..7448747
--- /dev/null
+++ b/src/unix/contrib/cutzlib-1.1.4/Makefile
@@ -0,0 +1,174 @@
+# Makefile for zlib
+# Copyright (C) 1995-2002 Jean-loup Gailly.
+# For conditions of distribution and use, see copyright notice in zlib.h 
+
+# To compile and test, type:
+#   ./configure; make test
+# The call of configure is optional if you don't have special requirements
+# If you wish to build zlib as a shared library, use: ./configure -s
+
+# To install /usr/local/lib/libz.* and /usr/local/include/zlib.h, type:
+#    make install
+# To install in $HOME instead of /usr/local, use:
+#    make install prefix=$HOME
+
+CC=gcc
+
+CFLAGS=-O3 -DHAVE_UNISTD_H -DUSE_MMAP
+#CFLAGS=-O -DMAX_WBITS=14 -DMAX_MEM_LEVEL=7
+#CFLAGS=-g -DDEBUG
+#CFLAGS=-O3 -Wall -Wwrite-strings -Wpointer-arith -Wconversion \
+#           -Wstrict-prototypes -Wmissing-prototypes
+
+LDFLAGS=-L. -lz
+LDSHARED=gcc
+CPP=gcc -E
+
+VER=1.1.4
+LIBS=libz.a
+SHAREDLIB=libz.so
+
+AR=ar rc
+RANLIB=ranlib
+TAR=tar
+SHELL=/bin/sh
+
+prefix =/usr/local
+exec_prefix =${prefix}
+libdir =${exec_prefix}/lib
+includedir =${prefix}/include
+
+OBJS = adler32.o compress.o crc32.o gzio.o uncompr.o deflate.o trees.o \
+       zutil.o inflate.o infblock.o inftrees.o infcodes.o infutil.o inffast.o
+
+OBJA =
+# to use the asm code: make OBJA=match.o
+
+TEST_OBJS = example.o minigzip.o
+
+DISTFILES = README FAQ INDEX ChangeLog configure Make*[a-z0-9] *.[ch] *.mms \
+  algorithm.txt zlib.3 msdos/Make*[a-z0-9] msdos/zlib.def msdos/zlib.rc \
+  nt/Make*[a-z0-9] nt/zlib.dnt amiga/Make*.??? os2/M*.os2 os2/zlib.def \
+  contrib/RE*.contrib contrib/*.txt contrib/asm386/*.asm contrib/asm386/*.c \
+  contrib/asm386/*.bat contrib/asm386/zlibvc.d?? contrib/asm[56]86/*.?86 \
+  contrib/asm[56]86/*.S contrib/iostream/*.cpp \
+  contrib/iostream/*.h  contrib/iostream2/*.h contrib/iostream2/*.cpp \
+  contrib/untgz/Makefile contrib/untgz/*.c contrib/untgz/*.w32 \
+  contrib/minizip/[CM]*[pe] contrib/minizip/*.[ch] contrib/minizip/*.[td]?? \
+  contrib/delphi*/*.???
+
+all: example minigzip
+
+test: all
+	@LD_LIBRARY_PATH=.:$(LD_LIBRARY_PATH) ; export LD_LIBRARY_PATH; \
+	echo hello world | ./minigzip | ./minigzip -d || \
+	  echo '		*** minigzip test FAILED ***' ; \
+	if ./example; then \
+	  echo '		*** zlib test OK ***'; \
+	else \
+	  echo '		*** zlib test FAILED ***'; \
+	fi
+
+libz.a: $(OBJS) $(OBJA)
+	$(AR) $@ $(OBJS) $(OBJA)
+	-@ ($(RANLIB) $@ || true) >/dev/null 2>&1
+
+match.o: match.S
+	$(CPP) match.S > _match.s
+	$(CC) -c _match.s
+	mv _match.o match.o
+	rm -f _match.s
+
+$(SHAREDLIB).$(VER): $(OBJS)
+	$(LDSHARED) -o $@ $(OBJS)
+	rm -f $(SHAREDLIB) $(SHAREDLIB).1
+	ln -s $@ $(SHAREDLIB)
+	ln -s $@ $(SHAREDLIB).1
+
+example: example.o $(LIBS)
+	$(CC) $(CFLAGS) -o $@ example.o $(LDFLAGS)
+
+minigzip: minigzip.o $(LIBS)
+	$(CC) $(CFLAGS) -o $@ minigzip.o $(LDFLAGS)
+
+install: $(LIBS)
+	-@if [ ! -d $(includedir)  ]; then mkdir $(includedir); fi
+	-@if [ ! -d $(libdir) ]; then mkdir $(libdir); fi
+	cp zlib.h zconf.h $(includedir)
+	chmod 644 $(includedir)/zlib.h $(includedir)/zconf.h
+	cp $(LIBS) $(libdir)
+	cd $(libdir); chmod 755 $(LIBS)
+	-@(cd $(libdir); $(RANLIB) libz.a || true) >/dev/null 2>&1
+	cd $(libdir); if test -f $(SHAREDLIB).$(VER); then \
+	  rm -f $(SHAREDLIB) $(SHAREDLIB).1; \
+	  ln -s $(SHAREDLIB).$(VER) $(SHAREDLIB); \
+	  ln -s $(SHAREDLIB).$(VER) $(SHAREDLIB).1; \
+	  (ldconfig || true)  >/dev/null 2>&1; \
+	fi
+# The ranlib in install is needed on NeXTSTEP which checks file times
+# ldconfig is for Linux
+
+uninstall:
+	cd $(includedir); \
+	v=$(VER); \
+	if test -f zlib.h; then \
+	  v=`sed -n '/VERSION "/s/.*"\(.*\)".*/\1/p' < zlib.h`; \
+          rm -f zlib.h zconf.h; \
+	fi; \
+	cd $(libdir); rm -f libz.a; \
+	if test -f $(SHAREDLIB).$$v; then \
+	  rm -f $(SHAREDLIB).$$v $(SHAREDLIB) $(SHAREDLIB).1; \
+	fi
+
+clean:
+	rm -f *.o *~ example minigzip libz.a libz.so* foo.gz so_locations \
+	   _match.s maketree
+
+distclean:	clean
+
+zip:
+	mv Makefile Makefile~; cp -p Makefile.in Makefile
+	rm -f test.c ztest*.c contrib/minizip/test.zip
+	v=`sed -n -e 's/\.//g' -e '/VERSION "/s/.*"\(.*\)".*/\1/p' < zlib.h`;\
+	zip -ul9 zlib$$v $(DISTFILES)
+	mv Makefile~ Makefile
+
+dist:
+	mv Makefile Makefile~; cp -p Makefile.in Makefile
+	rm -f test.c ztest*.c contrib/minizip/test.zip
+	d=zlib-`sed -n '/VERSION "/s/.*"\(.*\)".*/\1/p' < zlib.h`;\
+	rm -f $$d.tar.gz; \
+	if test ! -d ../$$d; then rm -f ../$$d; ln -s `pwd` ../$$d; fi; \
+	files=""; \
+	for f in $(DISTFILES); do files="$$files $$d/$$f"; done; \
+	cd ..; \
+	GZIP=-9 $(TAR) chofz $$d/$$d.tar.gz $$files; \
+	if test ! -d $$d; then rm -f $$d; fi
+	mv Makefile~ Makefile
+
+tags:	
+	etags *.[ch]
+
+depend:
+	makedepend -- $(CFLAGS) -- *.[ch]
+
+# DO NOT DELETE THIS LINE -- make depend depends on it.
+
+adler32.o: zlib.h zconf.h
+compress.o: zlib.h zconf.h
+crc32.o: zlib.h zconf.h
+deflate.o: deflate.h zutil.h zlib.h zconf.h
+example.o: zlib.h zconf.h
+gzio.o: zutil.h zlib.h zconf.h
+infblock.o: infblock.h inftrees.h infcodes.h infutil.h zutil.h zlib.h zconf.h
+infcodes.o: zutil.h zlib.h zconf.h
+infcodes.o: inftrees.h infblock.h infcodes.h infutil.h inffast.h
+inffast.o: zutil.h zlib.h zconf.h inftrees.h
+inffast.o: infblock.h infcodes.h infutil.h inffast.h
+inflate.o: zutil.h zlib.h zconf.h infblock.h
+inftrees.o: zutil.h zlib.h zconf.h inftrees.h
+infutil.o: zutil.h zlib.h zconf.h infblock.h inftrees.h infcodes.h infutil.h
+minigzip.o:  zlib.h zconf.h 
+trees.o: deflate.h zutil.h zlib.h zconf.h trees.h
+uncompr.o: zlib.h zconf.h
+zutil.o: zutil.h zlib.h zconf.h  
diff --git a/src/unix/contrib/cutzlib-1.1.4/Makefile.in b/src/unix/contrib/cutzlib-1.1.4/Makefile.in
new file mode 100644
index 0000000..64b8826
--- /dev/null
+++ b/src/unix/contrib/cutzlib-1.1.4/Makefile.in
@@ -0,0 +1,174 @@
+# Makefile for zlib
+# Copyright (C) 1995-2002 Jean-loup Gailly.
+# For conditions of distribution and use, see copyright notice in zlib.h 
+
+# To compile and test, type:
+#   ./configure; make test
+# The call of configure is optional if you don't have special requirements
+# If you wish to build zlib as a shared library, use: ./configure -s
+
+# To install /usr/local/lib/libz.* and /usr/local/include/zlib.h, type:
+#    make install
+# To install in $HOME instead of /usr/local, use:
+#    make install prefix=$HOME
+
+CC=cc
+
+CFLAGS=-O
+#CFLAGS=-O -DMAX_WBITS=14 -DMAX_MEM_LEVEL=7
+#CFLAGS=-g -DDEBUG
+#CFLAGS=-O3 -Wall -Wwrite-strings -Wpointer-arith -Wconversion \
+#           -Wstrict-prototypes -Wmissing-prototypes
+
+LDFLAGS=-L. -lz
+LDSHARED=$(CC)
+CPP=$(CC) -E
+
+VER=1.1.4
+LIBS=libz.a
+SHAREDLIB=libz.so
+
+AR=ar rc
+RANLIB=ranlib
+TAR=tar
+SHELL=/bin/sh
+
+prefix = /usr/local
+exec_prefix = ${prefix}
+libdir = ${exec_prefix}/lib
+includedir = ${prefix}/include
+
+OBJS = adler32.o compress.o crc32.o gzio.o uncompr.o deflate.o trees.o \
+       zutil.o inflate.o infblock.o inftrees.o infcodes.o infutil.o inffast.o
+
+OBJA =
+# to use the asm code: make OBJA=match.o
+
+TEST_OBJS = example.o minigzip.o
+
+DISTFILES = README FAQ INDEX ChangeLog configure Make*[a-z0-9] *.[ch] *.mms \
+  algorithm.txt zlib.3 msdos/Make*[a-z0-9] msdos/zlib.def msdos/zlib.rc \
+  nt/Make*[a-z0-9] nt/zlib.dnt amiga/Make*.??? os2/M*.os2 os2/zlib.def \
+  contrib/RE*.contrib contrib/*.txt contrib/asm386/*.asm contrib/asm386/*.c \
+  contrib/asm386/*.bat contrib/asm386/zlibvc.d?? contrib/asm[56]86/*.?86 \
+  contrib/asm[56]86/*.S contrib/iostream/*.cpp \
+  contrib/iostream/*.h  contrib/iostream2/*.h contrib/iostream2/*.cpp \
+  contrib/untgz/Makefile contrib/untgz/*.c contrib/untgz/*.w32 \
+  contrib/minizip/[CM]*[pe] contrib/minizip/*.[ch] contrib/minizip/*.[td]?? \
+  contrib/delphi*/*.???
+
+all: example minigzip
+
+test: all
+	@LD_LIBRARY_PATH=.:$(LD_LIBRARY_PATH) ; export LD_LIBRARY_PATH; \
+	echo hello world | ./minigzip | ./minigzip -d || \
+	  echo '		*** minigzip test FAILED ***' ; \
+	if ./example; then \
+	  echo '		*** zlib test OK ***'; \
+	else \
+	  echo '		*** zlib test FAILED ***'; \
+	fi
+
+libz.a: $(OBJS) $(OBJA)
+	$(AR) $@ $(OBJS) $(OBJA)
+	-@ ($(RANLIB) $@ || true) >/dev/null 2>&1
+
+match.o: match.S
+	$(CPP) match.S > _match.s
+	$(CC) -c _match.s
+	mv _match.o match.o
+	rm -f _match.s
+
+$(SHAREDLIB).$(VER): $(OBJS)
+	$(LDSHARED) -o $@ $(OBJS)
+	rm -f $(SHAREDLIB) $(SHAREDLIB).1
+	ln -s $@ $(SHAREDLIB)
+	ln -s $@ $(SHAREDLIB).1
+
+example: example.o $(LIBS)
+	$(CC) $(CFLAGS) -o $@ example.o $(LDFLAGS)
+
+minigzip: minigzip.o $(LIBS)
+	$(CC) $(CFLAGS) -o $@ minigzip.o $(LDFLAGS)
+
+install: $(LIBS)
+	-@if [ ! -d $(includedir)  ]; then mkdir $(includedir); fi
+	-@if [ ! -d $(libdir) ]; then mkdir $(libdir); fi
+	cp zlib.h zconf.h $(includedir)
+	chmod 644 $(includedir)/zlib.h $(includedir)/zconf.h
+	cp $(LIBS) $(libdir)
+	cd $(libdir); chmod 755 $(LIBS)
+	-@(cd $(libdir); $(RANLIB) libz.a || true) >/dev/null 2>&1
+	cd $(libdir); if test -f $(SHAREDLIB).$(VER); then \
+	  rm -f $(SHAREDLIB) $(SHAREDLIB).1; \
+	  ln -s $(SHAREDLIB).$(VER) $(SHAREDLIB); \
+	  ln -s $(SHAREDLIB).$(VER) $(SHAREDLIB).1; \
+	  (ldconfig || true)  >/dev/null 2>&1; \
+	fi
+# The ranlib in install is needed on NeXTSTEP which checks file times
+# ldconfig is for Linux
+
+uninstall:
+	cd $(includedir); \
+	v=$(VER); \
+	if test -f zlib.h; then \
+	  v=`sed -n '/VERSION "/s/.*"\(.*\)".*/\1/p' < zlib.h`; \
+          rm -f zlib.h zconf.h; \
+	fi; \
+	cd $(libdir); rm -f libz.a; \
+	if test -f $(SHAREDLIB).$$v; then \
+	  rm -f $(SHAREDLIB).$$v $(SHAREDLIB) $(SHAREDLIB).1; \
+	fi
+
+clean:
+	rm -f *.o *~ example minigzip libz.a libz.so* foo.gz so_locations \
+	   _match.s maketree
+
+distclean:	clean
+
+zip:
+	mv Makefile Makefile~; cp -p Makefile.in Makefile
+	rm -f test.c ztest*.c contrib/minizip/test.zip
+	v=`sed -n -e 's/\.//g' -e '/VERSION "/s/.*"\(.*\)".*/\1/p' < zlib.h`;\
+	zip -ul9 zlib$$v $(DISTFILES)
+	mv Makefile~ Makefile
+
+dist:
+	mv Makefile Makefile~; cp -p Makefile.in Makefile
+	rm -f test.c ztest*.c contrib/minizip/test.zip
+	d=zlib-`sed -n '/VERSION "/s/.*"\(.*\)".*/\1/p' < zlib.h`;\
+	rm -f $$d.tar.gz; \
+	if test ! -d ../$$d; then rm -f ../$$d; ln -s `pwd` ../$$d; fi; \
+	files=""; \
+	for f in $(DISTFILES); do files="$$files $$d/$$f"; done; \
+	cd ..; \
+	GZIP=-9 $(TAR) chofz $$d/$$d.tar.gz $$files; \
+	if test ! -d $$d; then rm -f $$d; fi
+	mv Makefile~ Makefile
+
+tags:	
+	etags *.[ch]
+
+depend:
+	makedepend -- $(CFLAGS) -- *.[ch]
+
+# DO NOT DELETE THIS LINE -- make depend depends on it.
+
+adler32.o: zlib.h zconf.h
+compress.o: zlib.h zconf.h
+crc32.o: zlib.h zconf.h
+deflate.o: deflate.h zutil.h zlib.h zconf.h
+example.o: zlib.h zconf.h
+gzio.o: zutil.h zlib.h zconf.h
+infblock.o: infblock.h inftrees.h infcodes.h infutil.h zutil.h zlib.h zconf.h
+infcodes.o: zutil.h zlib.h zconf.h
+infcodes.o: inftrees.h infblock.h infcodes.h infutil.h inffast.h
+inffast.o: zutil.h zlib.h zconf.h inftrees.h
+inffast.o: infblock.h infcodes.h infutil.h inffast.h
+inflate.o: zutil.h zlib.h zconf.h infblock.h
+inftrees.o: zutil.h zlib.h zconf.h inftrees.h
+infutil.o: zutil.h zlib.h zconf.h infblock.h inftrees.h infcodes.h infutil.h
+minigzip.o:  zlib.h zconf.h 
+trees.o: deflate.h zutil.h zlib.h zconf.h trees.h
+uncompr.o: zlib.h zconf.h
+zutil.o: zutil.h zlib.h zconf.h  
diff --git a/src/unix/contrib/cutzlib-1.1.4/README b/src/unix/contrib/cutzlib-1.1.4/README
new file mode 100644
index 0000000..29d6714
--- /dev/null
+++ b/src/unix/contrib/cutzlib-1.1.4/README
@@ -0,0 +1,147 @@
+zlib 1.1.4 is a general purpose data compression library.  All the code
+is thread safe.  The data format used by the zlib library
+is described by RFCs (Request for Comments) 1950 to 1952 in the files 
+http://www.ietf.org/rfc/rfc1950.txt (zlib format), rfc1951.txt (deflate
+format) and rfc1952.txt (gzip format). These documents are also available in
+other formats from ftp://ftp.uu.net/graphics/png/documents/zlib/zdoc-index.html
+
+All functions of the compression library are documented in the file zlib.h
+(volunteer to write man pages welcome, contact jloup@gzip.org). A usage
+example of the library is given in the file example.c which also tests that
+the library is working correctly. Another example is given in the file
+minigzip.c. The compression library itself is composed of all source files
+except example.c and minigzip.c.
+
+To compile all files and run the test program, follow the instructions
+given at the top of Makefile. In short "make test; make install"
+should work for most machines. For Unix: "./configure; make test; make install"
+For MSDOS, use one of the special makefiles such as Makefile.msc.
+For VMS, use Make_vms.com or descrip.mms.
+
+Questions about zlib should be sent to <zlib@gzip.org>, or to
+Gilles Vollant <info@winimage.com> for the Windows DLL version.
+The zlib home page is http://www.zlib.org or http://www.gzip.org/zlib/
+Before reporting a problem, please check this site to verify that
+you have the latest version of zlib; otherwise get the latest version and
+check whether the problem still exists or not.
+
+PLEASE read the zlib FAQ http://www.gzip.org/zlib/zlib_faq.html
+before asking for help.
+
+Mark Nelson <markn@ieee.org> wrote an article about zlib for the Jan. 1997
+issue of  Dr. Dobb's Journal; a copy of the article is available in
+http://dogma.net/markn/articles/zlibtool/zlibtool.htm
+
+The changes made in version 1.1.4 are documented in the file ChangeLog.
+The only changes made since 1.1.3 are bug corrections:
+
+- ZFREE was repeated on same allocation on some error conditions.
+  This creates a security problem described in
+  http://www.zlib.org/advisory-2002-03-11.txt
+- Returned incorrect error (Z_MEM_ERROR) on some invalid data
+- Avoid accesses before window for invalid distances with inflate window
+  less than 32K.
+- force windowBits > 8 to avoid a bug in the encoder for a window size
+  of 256 bytes. (A complete fix will be available in 1.1.5).
+
+The beta version 1.1.5beta includes many more changes. A new official
+version 1.1.5 will be released as soon as extensive testing has been
+completed on it.
+
+
+Unsupported third party contributions are provided in directory "contrib".
+
+A Java implementation of zlib is available in the Java Development Kit
+http://www.javasoft.com/products/JDK/1.1/docs/api/Package-java.util.zip.html
+See the zlib home page http://www.zlib.org for details.
+
+A Perl interface to zlib written by Paul Marquess <pmarquess@bfsec.bt.co.uk>
+is in the CPAN (Comprehensive Perl Archive Network) sites
+http://www.cpan.org/modules/by-module/Compress/
+
+A Python interface to zlib written by A.M. Kuchling <amk@magnet.com>
+is available in Python 1.5 and later versions, see
+http://www.python.org/doc/lib/module-zlib.html
+
+A zlib binding for TCL written by Andreas Kupries <a.kupries@westend.com>
+is availlable at http://www.westend.com/~kupries/doc/trf/man/man.html
+
+An experimental package to read and write files in .zip format,
+written on top of zlib by Gilles Vollant <info@winimage.com>, is
+available at http://www.winimage.com/zLibDll/unzip.html
+and also in the contrib/minizip directory of zlib.
+
+
+Notes for some targets:
+
+- To build a Windows DLL version, include in a DLL project zlib.def, zlib.rc
+  and all .c files except example.c and minigzip.c; compile with -DZLIB_DLL
+  The zlib DLL support was initially done by Alessandro Iacopetti and is
+  now maintained by Gilles Vollant <info@winimage.com>. Check the zlib DLL
+  home page at http://www.winimage.com/zLibDll
+
+  From Visual Basic, you can call the DLL functions which do not take
+  a structure as argument: compress, uncompress and all gz* functions.
+  See contrib/visual-basic.txt for more information, or get
+  http://www.tcfb.com/dowseware/cmp-z-it.zip
+
+- For 64-bit Irix, deflate.c must be compiled without any optimization.
+  With -O, one libpng test fails. The test works in 32 bit mode (with
+  the -n32 compiler flag). The compiler bug has been reported to SGI.
+
+- zlib doesn't work with gcc 2.6.3 on a DEC 3000/300LX under OSF/1 2.1   
+  it works when compiled with cc.
+
+- on Digital Unix 4.0D (formely OSF/1) on AlphaServer, the cc option -std1
+  is necessary to get gzprintf working correctly. This is done by configure.
+
+- zlib doesn't work on HP-UX 9.05 with some versions of /bin/cc. It works
+  with other compilers. Use "make test" to check your compiler.
+
+- gzdopen is not supported on RISCOS, BEOS and by some Mac compilers.
+
+- For Turbo C the small model is supported only with reduced performance to
+  avoid any far allocation; it was tested with -DMAX_WBITS=11 -DMAX_MEM_LEVEL=3
+
+- For PalmOs, see http://www.cs.uit.no/~perm/PASTA/pilot/software.html
+  Per Harald Myrvang <perm@stud.cs.uit.no>
+
+
+Acknowledgments:
+
+  The deflate format used by zlib was defined by Phil Katz. The deflate
+  and zlib specifications were written by L. Peter Deutsch. Thanks to all the
+  people who reported problems and suggested various improvements in zlib;
+  they are too numerous to cite here.
+
+Copyright notice:
+
+ (C) 1995-2002 Jean-loup Gailly and Mark Adler
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+
+  Jean-loup Gailly        Mark Adler
+  jloup@gzip.org          madler@alumni.caltech.edu
+
+If you use the zlib library in a product, we would appreciate *not*
+receiving lengthy legal documents to sign. The sources are provided
+for free but without warranty of any kind.  The library has been
+entirely written by Jean-loup Gailly and Mark Adler; it does not
+include third-party code.
+
+If you redistribute modified sources, we would appreciate that you include
+in the file ChangeLog history information documenting your changes.
diff --git a/src/unix/contrib/cutzlib-1.1.4/README.mame b/src/unix/contrib/cutzlib-1.1.4/README.mame
new file mode 100644
index 0000000..65fc694
--- /dev/null
+++ b/src/unix/contrib/cutzlib-1.1.4/README.mame
@@ -0,0 +1,8 @@
+This directory contains a cutdown, but further unmodified version of zlib 1.1.4
+for use with xmame.
+
+A complete version of zlib can be downloaded from:
+http://www.zlib.org
+
+For more information and the copyright under which zlib falls see:
+README in the dir.
diff --git a/src/unix/contrib/cutzlib-1.1.4/adler32.c b/src/unix/contrib/cutzlib-1.1.4/adler32.c
new file mode 100644
index 0000000..fafe504
--- /dev/null
+++ b/src/unix/contrib/cutzlib-1.1.4/adler32.c
@@ -0,0 +1,48 @@
+/* adler32.c -- compute the Adler-32 checksum of a data stream
+ * Copyright (C) 1995-2002 Mark Adler
+ * For conditions of distribution and use, see copyright notice in zlib.h 
+ */
+
+/* @(#) $Id: adler32.c,v 1.1 2002/04/18 21:15:03 l_g Exp $ */
+
+#include "zlib.h"
+
+#define BASE 65521L /* largest prime smaller than 65536 */
+#define NMAX 5552
+/* NMAX is the largest n such that 255n(n+1)/2 + (n+1)(BASE-1) <= 2^32-1 */
+
+#define DO1(buf,i)  {s1 += buf[i]; s2 += s1;}
+#define DO2(buf,i)  DO1(buf,i); DO1(buf,i+1);
+#define DO4(buf,i)  DO2(buf,i); DO2(buf,i+2);
+#define DO8(buf,i)  DO4(buf,i); DO4(buf,i+4);
+#define DO16(buf)   DO8(buf,0); DO8(buf,8);
+
+/* ========================================================================= */
+uLong ZEXPORT adler32(adler, buf, len)
+    uLong adler;
+    const Bytef *buf;
+    uInt len;
+{
+    unsigned long s1 = adler & 0xffff;
+    unsigned long s2 = (adler >> 16) & 0xffff;
+    int k;
+
+    if (buf == Z_NULL) return 1L;
+
+    while (len > 0) {
+        k = len < NMAX ? len : NMAX;
+        len -= k;
+        while (k >= 16) {
+            DO16(buf);
+	    buf += 16;
+            k -= 16;
+        }
+        if (k != 0) do {
+            s1 += *buf++;
+	    s2 += s1;
+        } while (--k);
+        s1 %= BASE;
+        s2 %= BASE;
+    }
+    return (s2 << 16) | s1;
+}
diff --git a/src/unix/contrib/cutzlib-1.1.4/compress.c b/src/unix/contrib/cutzlib-1.1.4/compress.c
new file mode 100644
index 0000000..a9d2f30
--- /dev/null
+++ b/src/unix/contrib/cutzlib-1.1.4/compress.c
@@ -0,0 +1,68 @@
+/* compress.c -- compress a memory buffer
+ * Copyright (C) 1995-2002 Jean-loup Gailly.
+ * For conditions of distribution and use, see copyright notice in zlib.h 
+ */
+
+/* @(#) $Id: compress.c,v 1.1 2002/04/18 21:15:03 l_g Exp $ */
+
+#include "zlib.h"
+
+/* ===========================================================================
+     Compresses the source buffer into the destination buffer. The level
+   parameter has the same meaning as in deflateInit.  sourceLen is the byte
+   length of the source buffer. Upon entry, destLen is the total size of the
+   destination buffer, which must be at least 0.1% larger than sourceLen plus
+   12 bytes. Upon exit, destLen is the actual size of the compressed buffer.
+
+     compress2 returns Z_OK if success, Z_MEM_ERROR if there was not enough
+   memory, Z_BUF_ERROR if there was not enough room in the output buffer,
+   Z_STREAM_ERROR if the level parameter is invalid.
+*/
+int ZEXPORT compress2 (dest, destLen, source, sourceLen, level)
+    Bytef *dest;
+    uLongf *destLen;
+    const Bytef *source;
+    uLong sourceLen;
+    int level;
+{
+    z_stream stream;
+    int err;
+
+    stream.next_in = (Bytef*)source;
+    stream.avail_in = (uInt)sourceLen;
+#ifdef MAXSEG_64K
+    /* Check for source > 64K on 16-bit machine: */
+    if ((uLong)stream.avail_in != sourceLen) return Z_BUF_ERROR;
+#endif
+    stream.next_out = dest;
+    stream.avail_out = (uInt)*destLen;
+    if ((uLong)stream.avail_out != *destLen) return Z_BUF_ERROR;
+
+    stream.zalloc = (alloc_func)0;
+    stream.zfree = (free_func)0;
+    stream.opaque = (voidpf)0;
+
+    err = deflateInit(&stream, level);
+    if (err != Z_OK) return err;
+
+    err = deflate(&stream, Z_FINISH);
+    if (err != Z_STREAM_END) {
+        deflateEnd(&stream);
+        return err == Z_OK ? Z_BUF_ERROR : err;
+    }
+    *destLen = stream.total_out;
+
+    err = deflateEnd(&stream);
+    return err;
+}
+
+/* ===========================================================================
+ */
+int ZEXPORT compress (dest, destLen, source, sourceLen)
+    Bytef *dest;
+    uLongf *destLen;
+    const Bytef *source;
+    uLong sourceLen;
+{
+    return compress2(dest, destLen, source, sourceLen, Z_DEFAULT_COMPRESSION);
+}
diff --git a/src/unix/contrib/cutzlib-1.1.4/configure b/src/unix/contrib/cutzlib-1.1.4/configure
new file mode 100755
index 0000000..e894235
--- /dev/null
+++ b/src/unix/contrib/cutzlib-1.1.4/configure
@@ -0,0 +1,212 @@
+#!/bin/sh
+# configure script for zlib. This script is needed only if
+# you wish to build a shared library and your system supports them,
+# of if you need special compiler, flags or install directory.
+# Otherwise, you can just use directly "make test; make install"
+#
+# To create a shared library, use "configure --shared"; by default a static
+# library is created. If the primitive shared library support provided here
+# does not work, use ftp://prep.ai.mit.edu/pub/gnu/libtool-*.tar.gz
+#
+# To impose specific compiler or flags or install directory, use for example:
+#    prefix=$HOME CC=cc CFLAGS="-O4" ./configure
+# or for csh/tcsh users:
+#    (setenv prefix $HOME; setenv CC cc; setenv CFLAGS "-O4"; ./configure)
+# LDSHARED is the command to be used to create a shared library
+
+# Incorrect settings of CC or CFLAGS may prevent creating a shared library.
+# If you have problems, try without defining CC and CFLAGS before reporting
+# an error.
+
+LIBS=libz.a
+SHAREDLIB=libz.so
+VER=`sed -n -e '/VERSION "/s/.*"\(.*\)".*/\1/p' < zlib.h`
+AR=${AR-"ar rc"}
+RANLIB=${RANLIB-"ranlib"}
+prefix=${prefix-/usr/local}
+exec_prefix=${exec_prefix-'${prefix}'}
+libdir=${libdir-'${exec_prefix}/lib'}
+includedir=${includedir-'${prefix}/include'}
+shared_ext='.so'
+shared=0
+gcc=0
+old_cc="$CC"
+old_cflags="$CFLAGS"
+
+while test $# -ge 1
+do
+case "$1" in
+    -h* | --h*)
+      echo 'usage:'
+      echo '  configure [--shared] [--prefix=PREFIX]  [--exec_prefix=EXPREFIX]'
+      echo '     [--libdir=LIBDIR] [--includedir=INCLUDEDIR]'
+        exit 0;;
+    -p*=* | --p*=*) prefix=`echo $1 | sed 's/[-a-z_]*=//'`; shift;;
+    -e*=* | --e*=*) exec_prefix=`echo $1 | sed 's/[-a-z_]*=//'`; shift;;
+    -l*=* | --libdir=*) libdir=`echo $1 | sed 's/[-a-z_]*=//'`; shift;;
+    -i*=* | --includedir=*) includedir=`echo $1 | sed 's/[-a-z_]*=//'`;shift;;
+    -p* | --p*) prefix="$2"; shift; shift;;
+    -e* | --e*) exec_prefix="$2"; shift; shift;;
+    -l* | --l*) libdir="$2"; shift; shift;;
+    -i* | --i*) includedir="$2"; shift; shift;;
+    -s* | --s*) shared=1; shift;;
+    esac
+done
+
+test=ztest$$
+cat > $test.c <<EOF
+extern int getchar();
+int hello() {return getchar();}
+EOF
+
+test -z "$CC" && echo Checking for gcc...
+cc=${CC-gcc}
+cflags=${CFLAGS-"-O3"}
+# to force the asm version use: CFLAGS="-O3 -DASMV" ./configure
+case "$cc" in
+  *gcc*) gcc=1;;
+esac
+
+if test "$gcc" -eq 1 && ($cc -c $cflags $test.c) 2>/dev/null; then
+  CC="$cc"
+  SFLAGS=${CFLAGS-"-fPIC -O3"}
+  CFLAGS="$cflags"
+  case `(uname -s || echo unknown) 2>/dev/null` in
+  Linux | linux) LDSHARED=${LDSHARED-"gcc -shared -Wl,-soname,libz.so.1"};;
+  *)             LDSHARED=${LDSHARED-"gcc -shared"};;
+  esac
+else
+  # find system name and corresponding cc options
+  CC=${CC-cc}
+  case `(uname -sr || echo unknown) 2>/dev/null` in
+  HP-UX*)    SFLAGS=${CFLAGS-"-O +z"}
+	     CFLAGS=${CFLAGS-"-O"}
+#	     LDSHARED=${LDSHARED-"ld -b +vnocompatwarnings"}
+	     LDSHARED=${LDSHARED-"ld -b"}
+	     shared_ext='.sl'
+	     SHAREDLIB='libz.sl';;
+  IRIX*)     SFLAGS=${CFLAGS-"-ansi -O2 -rpath ."}
+	     CFLAGS=${CFLAGS-"-ansi -O2"}
+	     LDSHARED=${LDSHARED-"cc -shared"};;
+  OSF1\ V4*) SFLAGS=${CFLAGS-"-O -std1"}
+	     CFLAGS=${CFLAGS-"-O -std1"}
+	     LDSHARED=${LDSHARED-"cc -shared  -Wl,-soname,$SHAREDLIB -Wl,-msym -Wl,-rpath,$(libdir) -Wl,-set_version,${VER}:1.0"};;
+  OSF1*)     SFLAGS=${CFLAGS-"-O -std1"}
+	     CFLAGS=${CFLAGS-"-O -std1"}
+	     LDSHARED=${LDSHARED-"cc -shared"};;
+  QNX*)      SFLAGS=${CFLAGS-"-4 -O"}
+             CFLAGS=${CFLAGS-"-4 -O"}
+	     LDSHARED=${LDSHARED-"cc"}
+             RANLIB=${RANLIB-"true"}
+             AR="cc -A";;
+  SCO_SV\ 3.2*) SFLAGS=${CFLAGS-"-O3 -dy -KPIC "}
+	     CFLAGS=${CFLAGS-"-O3"}
+	     LDSHARED=${LDSHARED-"cc -dy -KPIC -G"};;
+  SunOS\ 5*) SFLAGS=${CFLAGS-"-fast -xcg89 -KPIC -R."}
+             CFLAGS=${CFLAGS-"-fast -xcg89"}
+	     LDSHARED=${LDSHARED-"cc -G"};;
+  SunOS\ 4*) SFLAGS=${CFLAGS-"-O2 -PIC"}
+	     CFLAGS=${CFLAGS-"-O2"}
+	     LDSHARED=${LDSHARED-"ld"};;
+  UNIX_System_V\ 4.2.0) 
+	     SFLAGS=${CFLAGS-"-KPIC -O"}
+	     CFLAGS=${CFLAGS-"-O"}
+	     LDSHARED=${LDSHARED-"cc -G"};;
+  UNIX_SV\ 4.2MP)
+	     SFLAGS=${CFLAGS-"-Kconform_pic -O"}
+	     CFLAGS=${CFLAGS-"-O"}
+	     LDSHARED=${LDSHARED-"cc -G"};;
+  # send working options for other systems to support@gzip.org
+  *)         SFLAGS=${CFLAGS-"-O"}
+	     CFLAGS=${CFLAGS-"-O"}
+	     LDSHARED=${LDSHARED-"cc -shared"};;
+  esac
+fi
+
+if test $shared -eq 1; then
+  echo Checking for shared library support...
+  # we must test in two steps (cc then ld), required at least on SunOS 4.x
+  if test "`($CC -c $SFLAGS $test.c) 2>&1`" = "" &&
+     test "`($LDSHARED -o $test$shared_ext $test.o) 2>&1`" = ""; then
+    CFLAGS="$SFLAGS"
+    LIBS="$SHAREDLIB.$VER"
+    echo Building shared library $SHAREDLIB.$VER with $CC.
+  elif test -z "$old_cc" -a -z "$old_cflags"; then
+    echo No shared library suppport.
+    shared=0;
+  else
+    echo 'No shared library suppport; try without defining CC and CFLAGS'
+    shared=0;
+  fi
+fi
+if test $shared -eq 0; then
+  LDSHARED="$CC"
+  echo Building static library $LIBS version $VER with $CC.
+fi
+
+cat > $test.c <<EOF
+#include <unistd.h>
+int main() { return 0; }
+EOF
+if test "`($CC -c $CFLAGS $test.c) 2>&1`" = ""; then
+  CFLAGS="$CFLAGS -DHAVE_UNISTD_H"
+  echo "Checking for unistd.h... Yes."
+else
+  echo "Checking for unistd.h... No."
+fi
+
+cat > $test.c <<EOF
+#include <errno.h>
+int main() { return 0; }
+EOF
+if test "`($CC -c $CFLAGS $test.c) 2>&1`" = ""; then
+  echo "Checking for errno.h...	 Yes."
+else
+  echo "Checking for errno.h...	 No."
+  CFLAGS="$CFLAGS -DNO_ERRNO_H"
+fi
+
+cat > $test.c <<EOF
+#include <sys/types.h>
+#include <sys/mman.h>
+#include <sys/stat.h>
+caddr_t hello() {
+  return mmap((caddr_t)0, (off_t)0, PROT_READ, MAP_SHARED, 0, (off_t)0); 
+}
+EOF
+if test "`($CC -c $CFLAGS $test.c) 2>&1`" = ""; then
+  CFLAGS="$CFLAGS -DUSE_MMAP"
+  echo Checking for mmap support... Yes.
+else
+  echo Checking for mmap support... No.
+fi
+
+CPP=${CPP-"$CC -E"}
+case $CFLAGS in
+  *ASMV*)
+    if test "`nm $test.o | grep _hello`" = ""; then
+      CPP="$CPP -DNO_UNDERLINE"
+      echo Checking for underline in external names... No.
+    else
+      echo Checking for underline in external names... Yes.
+    fi;;
+esac
+
+rm -f $test.[co] $test$shared_ext
+
+# udpate Makefile
+sed < Makefile.in "
+/^CC *=/s%=.*%=$CC%
+/^CFLAGS *=/s%=.*%=$CFLAGS%
+/^CPP *=/s%=.*%=$CPP%
+/^LDSHARED *=/s%=.*%=$LDSHARED%
+/^LIBS *=/s%=.*%=$LIBS%
+/^SHAREDLIB *=/s%=.*%=$SHAREDLIB%
+/^AR *=/s%=.*%=$AR%
+/^RANLIB *=/s%=.*%=$RANLIB%
+/^VER *=/s%=.*%=$VER%
+/^prefix *=/s%=.*%=$prefix%
+/^exec_prefix *=/s%=.*%=$exec_prefix%
+/^libdir *=/s%=.*%=$libdir%
+/^includedir *=/s%=.*%=$includedir%
+" > Makefile
diff --git a/src/unix/contrib/cutzlib-1.1.4/crc32.c b/src/unix/contrib/cutzlib-1.1.4/crc32.c
new file mode 100644
index 0000000..10e10c3
--- /dev/null
+++ b/src/unix/contrib/cutzlib-1.1.4/crc32.c
@@ -0,0 +1,162 @@
+/* crc32.c -- compute the CRC-32 of a data stream
+ * Copyright (C) 1995-2002 Mark Adler
+ * For conditions of distribution and use, see copyright notice in zlib.h 
+ */
+
+/* @(#) $Id: crc32.c,v 1.1 2002/04/18 21:15:03 l_g Exp $ */
+
+#include "zlib.h"
+
+#define local static
+
+#ifdef DYNAMIC_CRC_TABLE
+
+local int crc_table_empty = 1;
+local uLongf crc_table[256];
+local void make_crc_table OF((void));
+
+/*
+  Generate a table for a byte-wise 32-bit CRC calculation on the polynomial:
+  x^32+x^26+x^23+x^22+x^16+x^12+x^11+x^10+x^8+x^7+x^5+x^4+x^2+x+1.
+
+  Polynomials over GF(2) are represented in binary, one bit per coefficient,
+  with the lowest powers in the most significant bit.  Then adding polynomials
+  is just exclusive-or, and multiplying a polynomial by x is a right shift by
+  one.  If we call the above polynomial p, and represent a byte as the
+  polynomial q, also with the lowest power in the most significant bit (so the
+  byte 0xb1 is the polynomial x^7+x^3+x+1), then the CRC is (q*x^32) mod p,
+  where a mod b means the remainder after dividing a by b.
+
+  This calculation is done using the shift-register method of multiplying and
+  taking the remainder.  The register is initialized to zero, and for each
+  incoming bit, x^32 is added mod p to the register if the bit is a one (where
+  x^32 mod p is p+x^32 = x^26+...+1), and the register is multiplied mod p by
+  x (which is shifting right by one and adding x^32 mod p if the bit shifted
+  out is a one).  We start with the highest power (least significant bit) of
+  q and repeat for all eight bits of q.
+
+  The table is simply the CRC of all possible eight bit values.  This is all
+  the information needed to generate CRC's on data a byte at a time for all
+  combinations of CRC register values and incoming bytes.
+*/
+local void make_crc_table()
+{
+  uLong c;
+  int n, k;
+  uLong poly;            /* polynomial exclusive-or pattern */
+  /* terms of polynomial defining this crc (except x^32): */
+  static const Byte p[] = {0,1,2,4,5,7,8,10,11,12,16,22,23,26};
+
+  /* make exclusive-or pattern from polynomial (0xedb88320L) */
+  poly = 0L;
+  for (n = 0; n < sizeof(p)/sizeof(Byte); n++)
+    poly |= 1L << (31 - p[n]);
+ 
+  for (n = 0; n < 256; n++)
+  {
+    c = (uLong)n;
+    for (k = 0; k < 8; k++)
+      c = c & 1 ? poly ^ (c >> 1) : c >> 1;
+    crc_table[n] = c;
+  }
+  crc_table_empty = 0;
+}
+#else
+/* ========================================================================
+ * Table of CRC-32's of all single-byte values (made by make_crc_table)
+ */
+local const uLongf crc_table[256] = {
+  0x00000000L, 0x77073096L, 0xee0e612cL, 0x990951baL, 0x076dc419L,
+  0x706af48fL, 0xe963a535L, 0x9e6495a3L, 0x0edb8832L, 0x79dcb8a4L,
+  0xe0d5e91eL, 0x97d2d988L, 0x09b64c2bL, 0x7eb17cbdL, 0xe7b82d07L,
+  0x90bf1d91L, 0x1db71064L, 0x6ab020f2L, 0xf3b97148L, 0x84be41deL,
+  0x1adad47dL, 0x6ddde4ebL, 0xf4d4b551L, 0x83d385c7L, 0x136c9856L,
+  0x646ba8c0L, 0xfd62f97aL, 0x8a65c9ecL, 0x14015c4fL, 0x63066cd9L,
+  0xfa0f3d63L, 0x8d080df5L, 0x3b6e20c8L, 0x4c69105eL, 0xd56041e4L,
+  0xa2677172L, 0x3c03e4d1L, 0x4b04d447L, 0xd20d85fdL, 0xa50ab56bL,
+  0x35b5a8faL, 0x42b2986cL, 0xdbbbc9d6L, 0xacbcf940L, 0x32d86ce3L,
+  0x45df5c75L, 0xdcd60dcfL, 0xabd13d59L, 0x26d930acL, 0x51de003aL,
+  0xc8d75180L, 0xbfd06116L, 0x21b4f4b5L, 0x56b3c423L, 0xcfba9599L,
+  0xb8bda50fL, 0x2802b89eL, 0x5f058808L, 0xc60cd9b2L, 0xb10be924L,
+  0x2f6f7c87L, 0x58684c11L, 0xc1611dabL, 0xb6662d3dL, 0x76dc4190L,
+  0x01db7106L, 0x98d220bcL, 0xefd5102aL, 0x71b18589L, 0x06b6b51fL,
+  0x9fbfe4a5L, 0xe8b8d433L, 0x7807c9a2L, 0x0f00f934L, 0x9609a88eL,
+  0xe10e9818L, 0x7f6a0dbbL, 0x086d3d2dL, 0x91646c97L, 0xe6635c01L,
+  0x6b6b51f4L, 0x1c6c6162L, 0x856530d8L, 0xf262004eL, 0x6c0695edL,
+  0x1b01a57bL, 0x8208f4c1L, 0xf50fc457L, 0x65b0d9c6L, 0x12b7e950L,
+  0x8bbeb8eaL, 0xfcb9887cL, 0x62dd1ddfL, 0x15da2d49L, 0x8cd37cf3L,
+  0xfbd44c65L, 0x4db26158L, 0x3ab551ceL, 0xa3bc0074L, 0xd4bb30e2L,
+  0x4adfa541L, 0x3dd895d7L, 0xa4d1c46dL, 0xd3d6f4fbL, 0x4369e96aL,
+  0x346ed9fcL, 0xad678846L, 0xda60b8d0L, 0x44042d73L, 0x33031de5L,
+  0xaa0a4c5fL, 0xdd0d7cc9L, 0x5005713cL, 0x270241aaL, 0xbe0b1010L,
+  0xc90c2086L, 0x5768b525L, 0x206f85b3L, 0xb966d409L, 0xce61e49fL,
+  0x5edef90eL, 0x29d9c998L, 0xb0d09822L, 0xc7d7a8b4L, 0x59b33d17L,
+  0x2eb40d81L, 0xb7bd5c3bL, 0xc0ba6cadL, 0xedb88320L, 0x9abfb3b6L,
+  0x03b6e20cL, 0x74b1d29aL, 0xead54739L, 0x9dd277afL, 0x04db2615L,
+  0x73dc1683L, 0xe3630b12L, 0x94643b84L, 0x0d6d6a3eL, 0x7a6a5aa8L,
+  0xe40ecf0bL, 0x9309ff9dL, 0x0a00ae27L, 0x7d079eb1L, 0xf00f9344L,
+  0x8708a3d2L, 0x1e01f268L, 0x6906c2feL, 0xf762575dL, 0x806567cbL,
+  0x196c3671L, 0x6e6b06e7L, 0xfed41b76L, 0x89d32be0L, 0x10da7a5aL,
+  0x67dd4accL, 0xf9b9df6fL, 0x8ebeeff9L, 0x17b7be43L, 0x60b08ed5L,
+  0xd6d6a3e8L, 0xa1d1937eL, 0x38d8c2c4L, 0x4fdff252L, 0xd1bb67f1L,
+  0xa6bc5767L, 0x3fb506ddL, 0x48b2364bL, 0xd80d2bdaL, 0xaf0a1b4cL,
+  0x36034af6L, 0x41047a60L, 0xdf60efc3L, 0xa867df55L, 0x316e8eefL,
+  0x4669be79L, 0xcb61b38cL, 0xbc66831aL, 0x256fd2a0L, 0x5268e236L,
+  0xcc0c7795L, 0xbb0b4703L, 0x220216b9L, 0x5505262fL, 0xc5ba3bbeL,
+  0xb2bd0b28L, 0x2bb45a92L, 0x5cb36a04L, 0xc2d7ffa7L, 0xb5d0cf31L,
+  0x2cd99e8bL, 0x5bdeae1dL, 0x9b64c2b0L, 0xec63f226L, 0x756aa39cL,
+  0x026d930aL, 0x9c0906a9L, 0xeb0e363fL, 0x72076785L, 0x05005713L,
+  0x95bf4a82L, 0xe2b87a14L, 0x7bb12baeL, 0x0cb61b38L, 0x92d28e9bL,
+  0xe5d5be0dL, 0x7cdcefb7L, 0x0bdbdf21L, 0x86d3d2d4L, 0xf1d4e242L,
+  0x68ddb3f8L, 0x1fda836eL, 0x81be16cdL, 0xf6b9265bL, 0x6fb077e1L,
+  0x18b74777L, 0x88085ae6L, 0xff0f6a70L, 0x66063bcaL, 0x11010b5cL,
+  0x8f659effL, 0xf862ae69L, 0x616bffd3L, 0x166ccf45L, 0xa00ae278L,
+  0xd70dd2eeL, 0x4e048354L, 0x3903b3c2L, 0xa7672661L, 0xd06016f7L,
+  0x4969474dL, 0x3e6e77dbL, 0xaed16a4aL, 0xd9d65adcL, 0x40df0b66L,
+  0x37d83bf0L, 0xa9bcae53L, 0xdebb9ec5L, 0x47b2cf7fL, 0x30b5ffe9L,
+  0xbdbdf21cL, 0xcabac28aL, 0x53b39330L, 0x24b4a3a6L, 0xbad03605L,
+  0xcdd70693L, 0x54de5729L, 0x23d967bfL, 0xb3667a2eL, 0xc4614ab8L,
+  0x5d681b02L, 0x2a6f2b94L, 0xb40bbe37L, 0xc30c8ea1L, 0x5a05df1bL,
+  0x2d02ef8dL
+};
+#endif
+
+/* =========================================================================
+ * This function can be used by asm versions of crc32()
+ */
+const uLongf * ZEXPORT get_crc_table()
+{
+#ifdef DYNAMIC_CRC_TABLE
+  if (crc_table_empty) make_crc_table();
+#endif
+  return (const uLongf *)crc_table;
+}
+
+/* ========================================================================= */
+#define DO1(buf) crc = crc_table[((int)crc ^ (*buf++)) & 0xff] ^ (crc >> 8);
+#define DO2(buf)  DO1(buf); DO1(buf);
+#define DO4(buf)  DO2(buf); DO2(buf);
+#define DO8(buf)  DO4(buf); DO4(buf);
+
+/* ========================================================================= */
+uLong ZEXPORT crc32(crc, buf, len)
+    uLong crc;
+    const Bytef *buf;
+    uInt len;
+{
+    if (buf == Z_NULL) return 0L;
+#ifdef DYNAMIC_CRC_TABLE
+    if (crc_table_empty)
+      make_crc_table();
+#endif
+    crc = crc ^ 0xffffffffL;
+    while (len >= 8)
+    {
+      DO8(buf);
+      len -= 8;
+    }
+    if (len) do {
+      DO1(buf);
+    } while (--len);
+    return crc ^ 0xffffffffL;
+}
diff --git a/src/unix/contrib/cutzlib-1.1.4/deflate.c b/src/unix/contrib/cutzlib-1.1.4/deflate.c
new file mode 100644
index 0000000..9afab7f
--- /dev/null
+++ b/src/unix/contrib/cutzlib-1.1.4/deflate.c
@@ -0,0 +1,1350 @@
+/* deflate.c -- compress data using the deflation algorithm
+ * Copyright (C) 1995-2002 Jean-loup Gailly.
+ * For conditions of distribution and use, see copyright notice in zlib.h 
+ */
+
+/*
+ *  ALGORITHM
+ *
+ *      The "deflation" process depends on being able to identify portions
+ *      of the input text which are identical to earlier input (within a
+ *      sliding window trailing behind the input currently being processed).
+ *
+ *      The most straightforward technique turns out to be the fastest for
+ *      most input files: try all possible matches and select the longest.
+ *      The key feature of this algorithm is that insertions into the string
+ *      dictionary are very simple and thus fast, and deletions are avoided
+ *      completely. Insertions are performed at each input character, whereas
+ *      string matches are performed only when the previous match ends. So it
+ *      is preferable to spend more time in matches to allow very fast string
+ *      insertions and avoid deletions. The matching algorithm for small
+ *      strings is inspired from that of Rabin & Karp. A brute force approach
+ *      is used to find longer strings when a small match has been found.
+ *      A similar algorithm is used in comic (by Jan-Mark Wams) and freeze
+ *      (by Leonid Broukhis).
+ *         A previous version of this file used a more sophisticated algorithm
+ *      (by Fiala and Greene) which is guaranteed to run in linear amortized
+ *      time, but has a larger average cost, uses more memory and is patented.
+ *      However the F&G algorithm may be faster for some highly redundant
+ *      files if the parameter max_chain_length (described below) is too large.
+ *
+ *  ACKNOWLEDGEMENTS
+ *
+ *      The idea of lazy evaluation of matches is due to Jan-Mark Wams, and
+ *      I found it in 'freeze' written by Leonid Broukhis.
+ *      Thanks to many people for bug reports and testing.
+ *
+ *  REFERENCES
+ *
+ *      Deutsch, L.P.,"DEFLATE Compressed Data Format Specification".
+ *      Available in ftp://ds.internic.net/rfc/rfc1951.txt
+ *
+ *      A description of the Rabin and Karp algorithm is given in the book
+ *         "Algorithms" by R. Sedgewick, Addison-Wesley, p252.
+ *
+ *      Fiala,E.R., and Greene,D.H.
+ *         Data Compression with Finite Windows, Comm.ACM, 32,4 (1989) 490-595
+ *
+ */
+
+/* @(#) $Id: deflate.c,v 1.1 2002/04/18 21:15:04 l_g Exp $ */
+
+#include "deflate.h"
+
+const char deflate_copyright[] =
+   " deflate 1.1.4 Copyright 1995-2002 Jean-loup Gailly ";
+/*
+  If you use the zlib library in a product, an acknowledgment is welcome
+  in the documentation of your product. If for some reason you cannot
+  include such an acknowledgment, I would appreciate that you keep this
+  copyright string in the executable of your product.
+ */
+
+/* ===========================================================================
+ *  Function prototypes.
+ */
+typedef enum {
+    need_more,      /* block not completed, need more input or more output */
+    block_done,     /* block flush performed */
+    finish_started, /* finish started, need only more output at next deflate */
+    finish_done     /* finish done, accept no more input or output */
+} block_state;
+
+typedef block_state (*compress_func) OF((deflate_state *s, int flush));
+/* Compression function. Returns the block state after the call. */
+
+local void fill_window    OF((deflate_state *s));
+local block_state deflate_stored OF((deflate_state *s, int flush));
+local block_state deflate_fast   OF((deflate_state *s, int flush));
+local block_state deflate_slow   OF((deflate_state *s, int flush));
+local void lm_init        OF((deflate_state *s));
+local void putShortMSB    OF((deflate_state *s, uInt b));
+local void flush_pending  OF((z_streamp strm));
+local int read_buf        OF((z_streamp strm, Bytef *buf, unsigned size));
+#ifdef ASMV
+      void match_init OF((void)); /* asm code initialization */
+      uInt longest_match  OF((deflate_state *s, IPos cur_match));
+#else
+local uInt longest_match  OF((deflate_state *s, IPos cur_match));
+#endif
+
+#ifdef DEBUG
+local  void check_match OF((deflate_state *s, IPos start, IPos match,
+                            int length));
+#endif
+
+/* ===========================================================================
+ * Local data
+ */
+
+#define NIL 0
+/* Tail of hash chains */
+
+#ifndef TOO_FAR
+#  define TOO_FAR 4096
+#endif
+/* Matches of length 3 are discarded if their distance exceeds TOO_FAR */
+
+#define MIN_LOOKAHEAD (MAX_MATCH+MIN_MATCH+1)
+/* Minimum amount of lookahead, except at the end of the input file.
+ * See deflate.c for comments about the MIN_MATCH+1.
+ */
+
+/* Values for max_lazy_match, good_match and max_chain_length, depending on
+ * the desired pack level (0..9). The values given below have been tuned to
+ * exclude worst case performance for pathological files. Better values may be
+ * found for specific files.
+ */
+typedef struct config_s {
+   ush good_length; /* reduce lazy search above this match length */
+   ush max_lazy;    /* do not perform lazy search above this match length */
+   ush nice_length; /* quit search above this match length */
+   ush max_chain;
+   compress_func func;
+} config;
+
+local const config configuration_table[10] = {
+/*      good lazy nice chain */
+/* 0 */ {0,    0,  0,    0, deflate_stored},  /* store only */
+/* 1 */ {4,    4,  8,    4, deflate_fast}, /* maximum speed, no lazy matches */
+/* 2 */ {4,    5, 16,    8, deflate_fast},
+/* 3 */ {4,    6, 32,   32, deflate_fast},
+
+/* 4 */ {4,    4, 16,   16, deflate_slow},  /* lazy matches */
+/* 5 */ {8,   16, 32,   32, deflate_slow},
+/* 6 */ {8,   16, 128, 128, deflate_slow},
+/* 7 */ {8,   32, 128, 256, deflate_slow},
+/* 8 */ {32, 128, 258, 1024, deflate_slow},
+/* 9 */ {32, 258, 258, 4096, deflate_slow}}; /* maximum compression */
+
+/* Note: the deflate() code requires max_lazy >= MIN_MATCH and max_chain >= 4
+ * For deflate_fast() (levels <= 3) good is ignored and lazy has a different
+ * meaning.
+ */
+
+#define EQUAL 0
+/* result of memcmp for equal strings */
+
+struct static_tree_desc_s {int dummy;}; /* for buggy compilers */
+
+/* ===========================================================================
+ * Update a hash value with the given input byte
+ * IN  assertion: all calls to to UPDATE_HASH are made with consecutive
+ *    input characters, so that a running hash key can be computed from the
+ *    previous key instead of complete recalculation each time.
+ */
+#define UPDATE_HASH(s,h,c) (h = (((h)<<s->hash_shift) ^ (c)) & s->hash_mask)
+
+
+/* ===========================================================================
+ * Insert string str in the dictionary and set match_head to the previous head
+ * of the hash chain (the most recent string with same hash key). Return
+ * the previous length of the hash chain.
+ * If this file is compiled with -DFASTEST, the compression level is forced
+ * to 1, and no hash chains are maintained.
+ * IN  assertion: all calls to to INSERT_STRING are made with consecutive
+ *    input characters and the first MIN_MATCH bytes of str are valid
+ *    (except for the last MIN_MATCH-1 bytes of the input file).
+ */
+#ifdef FASTEST
+#define INSERT_STRING(s, str, match_head) \
+   (UPDATE_HASH(s, s->ins_h, s->window[(str) + (MIN_MATCH-1)]), \
+    match_head = s->head[s->ins_h], \
+    s->head[s->ins_h] = (Pos)(str))
+#else
+#define INSERT_STRING(s, str, match_head) \
+   (UPDATE_HASH(s, s->ins_h, s->window[(str) + (MIN_MATCH-1)]), \
+    s->prev[(str) & s->w_mask] = match_head = s->head[s->ins_h], \
+    s->head[s->ins_h] = (Pos)(str))
+#endif
+
+/* ===========================================================================
+ * Initialize the hash table (avoiding 64K overflow for 16 bit systems).
+ * prev[] will be initialized on the fly.
+ */
+#define CLEAR_HASH(s) \
+    s->head[s->hash_size-1] = NIL; \
+    zmemzero((Bytef *)s->head, (unsigned)(s->hash_size-1)*sizeof(*s->head));
+
+/* ========================================================================= */
+int ZEXPORT deflateInit_(strm, level, version, stream_size)
+    z_streamp strm;
+    int level;
+    const char *version;
+    int stream_size;
+{
+    return deflateInit2_(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL,
+			 Z_DEFAULT_STRATEGY, version, stream_size);
+    /* To do: ignore strm->next_in if we use it as window */
+}
+
+/* ========================================================================= */
+int ZEXPORT deflateInit2_(strm, level, method, windowBits, memLevel, strategy,
+		  version, stream_size)
+    z_streamp strm;
+    int  level;
+    int  method;
+    int  windowBits;
+    int  memLevel;
+    int  strategy;
+    const char *version;
+    int stream_size;
+{
+    deflate_state *s;
+    int noheader = 0;
+    static const char* my_version = ZLIB_VERSION;
+
+    ushf *overlay;
+    /* We overlay pending_buf and d_buf+l_buf. This works since the average
+     * output size for (length,distance) codes is <= 24 bits.
+     */
+
+    if (version == Z_NULL || version[0] != my_version[0] ||
+        stream_size != sizeof(z_stream)) {
+	return Z_VERSION_ERROR;
+    }
+    if (strm == Z_NULL) return Z_STREAM_ERROR;
+
+    strm->msg = Z_NULL;
+    if (strm->zalloc == Z_NULL) {
+	strm->zalloc = zcalloc;
+	strm->opaque = (voidpf)0;
+    }
+    if (strm->zfree == Z_NULL) strm->zfree = zcfree;
+
+    if (level == Z_DEFAULT_COMPRESSION) level = 6;
+#ifdef FASTEST
+    level = 1;
+#endif
+
+    if (windowBits < 0) { /* undocumented feature: suppress zlib header */
+        noheader = 1;
+        windowBits = -windowBits;
+    }
+    if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method != Z_DEFLATED ||
+        windowBits < 9 || windowBits > 15 || level < 0 || level > 9 ||
+	strategy < 0 || strategy > Z_HUFFMAN_ONLY) {
+        return Z_STREAM_ERROR;
+    }
+    s = (deflate_state *) ZALLOC(strm, 1, sizeof(deflate_state));
+    if (s == Z_NULL) return Z_MEM_ERROR;
+    strm->state = (struct internal_state FAR *)s;
+    s->strm = strm;
+
+    s->noheader = noheader;
+    s->w_bits = windowBits;
+    s->w_size = 1 << s->w_bits;
+    s->w_mask = s->w_size - 1;
+
+    s->hash_bits = memLevel + 7;
+    s->hash_size = 1 << s->hash_bits;
+    s->hash_mask = s->hash_size - 1;
+    s->hash_shift =  ((s->hash_bits+MIN_MATCH-1)/MIN_MATCH);
+
+    s->window = (Bytef *) ZALLOC(strm, s->w_size, 2*sizeof(Byte));
+    s->prev   = (Posf *)  ZALLOC(strm, s->w_size, sizeof(Pos));
+    s->head   = (Posf *)  ZALLOC(strm, s->hash_size, sizeof(Pos));
+
+    s->lit_bufsize = 1 << (memLevel + 6); /* 16K elements by default */
+
+    overlay = (ushf *) ZALLOC(strm, s->lit_bufsize, sizeof(ush)+2);
+    s->pending_buf = (uchf *) overlay;
+    s->pending_buf_size = (ulg)s->lit_bufsize * (sizeof(ush)+2L);
+
+    if (s->window == Z_NULL || s->prev == Z_NULL || s->head == Z_NULL ||
+        s->pending_buf == Z_NULL) {
+        strm->msg = (char*)ERR_MSG(Z_MEM_ERROR);
+        deflateEnd (strm);
+        return Z_MEM_ERROR;
+    }
+    s->d_buf = overlay + s->lit_bufsize/sizeof(ush);
+    s->l_buf = s->pending_buf + (1+sizeof(ush))*s->lit_bufsize;
+
+    s->level = level;
+    s->strategy = strategy;
+    s->method = (Byte)method;
+
+    return deflateReset(strm);
+}
+
+/* ========================================================================= */
+int ZEXPORT deflateSetDictionary (strm, dictionary, dictLength)
+    z_streamp strm;
+    const Bytef *dictionary;
+    uInt  dictLength;
+{
+    deflate_state *s;
+    uInt length = dictLength;
+    uInt n;
+    IPos hash_head = 0;
+
+    if (strm == Z_NULL || strm->state == Z_NULL || dictionary == Z_NULL ||
+        strm->state->status != INIT_STATE) return Z_STREAM_ERROR;
+
+    s = strm->state;
+    strm->adler = adler32(strm->adler, dictionary, dictLength);
+
+    if (length < MIN_MATCH) return Z_OK;
+    if (length > MAX_DIST(s)) {
+	length = MAX_DIST(s);
+#ifndef USE_DICT_HEAD
+	dictionary += dictLength - length; /* use the tail of the dictionary */
+#endif
+    }
+    zmemcpy(s->window, dictionary, length);
+    s->strstart = length;
+    s->block_start = (long)length;
+
+    /* Insert all strings in the hash table (except for the last two bytes).
+     * s->lookahead stays null, so s->ins_h will be recomputed at the next
+     * call of fill_window.
+     */
+    s->ins_h = s->window[0];
+    UPDATE_HASH(s, s->ins_h, s->window[1]);
+    for (n = 0; n <= length - MIN_MATCH; n++) {
+	INSERT_STRING(s, n, hash_head);
+    }
+    if (hash_head) hash_head = 0;  /* to make compiler happy */
+    return Z_OK;
+}
+
+/* ========================================================================= */
+int ZEXPORT deflateReset (strm)
+    z_streamp strm;
+{
+    deflate_state *s;
+    
+    if (strm == Z_NULL || strm->state == Z_NULL ||
+        strm->zalloc == Z_NULL || strm->zfree == Z_NULL) return Z_STREAM_ERROR;
+
+    strm->total_in = strm->total_out = 0;
+    strm->msg = Z_NULL; /* use zfree if we ever allocate msg dynamically */
+    strm->data_type = Z_UNKNOWN;
+
+    s = (deflate_state *)strm->state;
+    s->pending = 0;
+    s->pending_out = s->pending_buf;
+
+    if (s->noheader < 0) {
+        s->noheader = 0; /* was set to -1 by deflate(..., Z_FINISH); */
+    }
+    s->status = s->noheader ? BUSY_STATE : INIT_STATE;
+    strm->adler = 1;
+    s->last_flush = Z_NO_FLUSH;
+
+    _tr_init(s);
+    lm_init(s);
+
+    return Z_OK;
+}
+
+/* ========================================================================= */
+int ZEXPORT deflateParams(strm, level, strategy)
+    z_streamp strm;
+    int level;
+    int strategy;
+{
+    deflate_state *s;
+    compress_func func;
+    int err = Z_OK;
+
+    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
+    s = strm->state;
+
+    if (level == Z_DEFAULT_COMPRESSION) {
+	level = 6;
+    }
+    if (level < 0 || level > 9 || strategy < 0 || strategy > Z_HUFFMAN_ONLY) {
+	return Z_STREAM_ERROR;
+    }
+    func = configuration_table[s->level].func;
+
+    if (func != configuration_table[level].func && strm->total_in != 0) {
+	/* Flush the last buffer: */
+	err = deflate(strm, Z_PARTIAL_FLUSH);
+    }
+    if (s->level != level) {
+	s->level = level;
+	s->max_lazy_match   = configuration_table[level].max_lazy;
+	s->good_match       = configuration_table[level].good_length;
+	s->nice_match       = configuration_table[level].nice_length;
+	s->max_chain_length = configuration_table[level].max_chain;
+    }
+    s->strategy = strategy;
+    return err;
+}
+
+/* =========================================================================
+ * Put a short in the pending buffer. The 16-bit value is put in MSB order.
+ * IN assertion: the stream state is correct and there is enough room in
+ * pending_buf.
+ */
+local void putShortMSB (s, b)
+    deflate_state *s;
+    uInt b;
+{
+    put_byte(s, (Byte)(b >> 8));
+    put_byte(s, (Byte)(b & 0xff));
+}   
+
+/* =========================================================================
+ * Flush as much pending output as possible. All deflate() output goes
+ * through this function so some applications may wish to modify it
+ * to avoid allocating a large strm->next_out buffer and copying into it.
+ * (See also read_buf()).
+ */
+local void flush_pending(strm)
+    z_streamp strm;
+{
+    unsigned len = strm->state->pending;
+
+    if (len > strm->avail_out) len = strm->avail_out;
+    if (len == 0) return;
+
+    zmemcpy(strm->next_out, strm->state->pending_out, len);
+    strm->next_out  += len;
+    strm->state->pending_out  += len;
+    strm->total_out += len;
+    strm->avail_out  -= len;
+    strm->state->pending -= len;
+    if (strm->state->pending == 0) {
+        strm->state->pending_out = strm->state->pending_buf;
+    }
+}
+
+/* ========================================================================= */
+int ZEXPORT deflate (strm, flush)
+    z_streamp strm;
+    int flush;
+{
+    int old_flush; /* value of flush param for previous deflate call */
+    deflate_state *s;
+
+    if (strm == Z_NULL || strm->state == Z_NULL ||
+	flush > Z_FINISH || flush < 0) {
+        return Z_STREAM_ERROR;
+    }
+    s = strm->state;
+
+    if (strm->next_out == Z_NULL ||
+        (strm->next_in == Z_NULL && strm->avail_in != 0) ||
+	(s->status == FINISH_STATE && flush != Z_FINISH)) {
+        ERR_RETURN(strm, Z_STREAM_ERROR);
+    }
+    if (strm->avail_out == 0) ERR_RETURN(strm, Z_BUF_ERROR);
+
+    s->strm = strm; /* just in case */
+    old_flush = s->last_flush;
+    s->last_flush = flush;
+
+    /* Write the zlib header */
+    if (s->status == INIT_STATE) {
+
+        uInt header = (Z_DEFLATED + ((s->w_bits-8)<<4)) << 8;
+        uInt level_flags = (s->level-1) >> 1;
+
+        if (level_flags > 3) level_flags = 3;
+        header |= (level_flags << 6);
+	if (s->strstart != 0) header |= PRESET_DICT;
+        header += 31 - (header % 31);
+
+        s->status = BUSY_STATE;
+        putShortMSB(s, header);
+
+	/* Save the adler32 of the preset dictionary: */
+	if (s->strstart != 0) {
+	    putShortMSB(s, (uInt)(strm->adler >> 16));
+	    putShortMSB(s, (uInt)(strm->adler & 0xffff));
+	}
+	strm->adler = 1L;
+    }
+
+    /* Flush as much pending output as possible */
+    if (s->pending != 0) {
+        flush_pending(strm);
+        if (strm->avail_out == 0) {
+	    /* Since avail_out is 0, deflate will be called again with
+	     * more output space, but possibly with both pending and
+	     * avail_in equal to zero. There won't be anything to do,
+	     * but this is not an error situation so make sure we
+	     * return OK instead of BUF_ERROR at next call of deflate:
+             */
+	    s->last_flush = -1;
+	    return Z_OK;
+	}
+
+    /* Make sure there is something to do and avoid duplicate consecutive
+     * flushes. For repeated and useless calls with Z_FINISH, we keep
+     * returning Z_STREAM_END instead of Z_BUFF_ERROR.
+     */
+    } else if (strm->avail_in == 0 && flush <= old_flush &&
+	       flush != Z_FINISH) {
+        ERR_RETURN(strm, Z_BUF_ERROR);
+    }
+
+    /* User must not provide more input after the first FINISH: */
+    if (s->status == FINISH_STATE && strm->avail_in != 0) {
+        ERR_RETURN(strm, Z_BUF_ERROR);
+    }
+
+    /* Start a new block or continue the current one.
+     */
+    if (strm->avail_in != 0 || s->lookahead != 0 ||
+        (flush != Z_NO_FLUSH && s->status != FINISH_STATE)) {
+        block_state bstate;
+
+	bstate = (*(configuration_table[s->level].func))(s, flush);
+
+        if (bstate == finish_started || bstate == finish_done) {
+            s->status = FINISH_STATE;
+        }
+        if (bstate == need_more || bstate == finish_started) {
+	    if (strm->avail_out == 0) {
+	        s->last_flush = -1; /* avoid BUF_ERROR next call, see above */
+	    }
+	    return Z_OK;
+	    /* If flush != Z_NO_FLUSH && avail_out == 0, the next call
+	     * of deflate should use the same flush parameter to make sure
+	     * that the flush is complete. So we don't have to output an
+	     * empty block here, this will be done at next call. This also
+	     * ensures that for a very small output buffer, we emit at most
+	     * one empty block.
+	     */
+	}
+        if (bstate == block_done) {
+            if (flush == Z_PARTIAL_FLUSH) {
+                _tr_align(s);
+            } else { /* FULL_FLUSH or SYNC_FLUSH */
+                _tr_stored_block(s, (char*)0, 0L, 0);
+                /* For a full flush, this empty block will be recognized
+                 * as a special marker by inflate_sync().
+                 */
+                if (flush == Z_FULL_FLUSH) {
+                    CLEAR_HASH(s);             /* forget history */
+                }
+            }
+            flush_pending(strm);
+	    if (strm->avail_out == 0) {
+	      s->last_flush = -1; /* avoid BUF_ERROR at next call, see above */
+	      return Z_OK;
+	    }
+        }
+    }
+    Assert(strm->avail_out > 0, "bug2");
+
+    if (flush != Z_FINISH) return Z_OK;
+    if (s->noheader) return Z_STREAM_END;
+
+    /* Write the zlib trailer (adler32) */
+    putShortMSB(s, (uInt)(strm->adler >> 16));
+    putShortMSB(s, (uInt)(strm->adler & 0xffff));
+    flush_pending(strm);
+    /* If avail_out is zero, the application will call deflate again
+     * to flush the rest.
+     */
+    s->noheader = -1; /* write the trailer only once! */
+    return s->pending != 0 ? Z_OK : Z_STREAM_END;
+}
+
+/* ========================================================================= */
+int ZEXPORT deflateEnd (strm)
+    z_streamp strm;
+{
+    int status;
+
+    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
+
+    status = strm->state->status;
+    if (status != INIT_STATE && status != BUSY_STATE &&
+	status != FINISH_STATE) {
+      return Z_STREAM_ERROR;
+    }
+
+    /* Deallocate in reverse order of allocations: */
+    TRY_FREE(strm, strm->state->pending_buf);
+    TRY_FREE(strm, strm->state->head);
+    TRY_FREE(strm, strm->state->prev);
+    TRY_FREE(strm, strm->state->window);
+
+    ZFREE(strm, strm->state);
+    strm->state = Z_NULL;
+
+    return status == BUSY_STATE ? Z_DATA_ERROR : Z_OK;
+}
+
+/* =========================================================================
+ * Copy the source state to the destination state.
+ * To simplify the source, this is not supported for 16-bit MSDOS (which
+ * doesn't have enough memory anyway to duplicate compression states).
+ */
+int ZEXPORT deflateCopy (dest, source)
+    z_streamp dest;
+    z_streamp source;
+{
+#ifdef MAXSEG_64K
+    return Z_STREAM_ERROR;
+#else
+    deflate_state *ds;
+    deflate_state *ss;
+    ushf *overlay;
+
+
+    if (source == Z_NULL || dest == Z_NULL || source->state == Z_NULL) {
+        return Z_STREAM_ERROR;
+    }
+
+    ss = source->state;
+
+    *dest = *source;
+
+    ds = (deflate_state *) ZALLOC(dest, 1, sizeof(deflate_state));
+    if (ds == Z_NULL) return Z_MEM_ERROR;
+    dest->state = (struct internal_state FAR *) ds;
+    *ds = *ss;
+    ds->strm = dest;
+
+    ds->window = (Bytef *) ZALLOC(dest, ds->w_size, 2*sizeof(Byte));
+    ds->prev   = (Posf *)  ZALLOC(dest, ds->w_size, sizeof(Pos));
+    ds->head   = (Posf *)  ZALLOC(dest, ds->hash_size, sizeof(Pos));
+    overlay = (ushf *) ZALLOC(dest, ds->lit_bufsize, sizeof(ush)+2);
+    ds->pending_buf = (uchf *) overlay;
+
+    if (ds->window == Z_NULL || ds->prev == Z_NULL || ds->head == Z_NULL ||
+        ds->pending_buf == Z_NULL) {
+        deflateEnd (dest);
+        return Z_MEM_ERROR;
+    }
+    /* following zmemcpy do not work for 16-bit MSDOS */
+    zmemcpy(ds->window, ss->window, ds->w_size * 2 * sizeof(Byte));
+    zmemcpy(ds->prev, ss->prev, ds->w_size * sizeof(Pos));
+    zmemcpy(ds->head, ss->head, ds->hash_size * sizeof(Pos));
+    zmemcpy(ds->pending_buf, ss->pending_buf, (uInt)ds->pending_buf_size);
+
+    ds->pending_out = ds->pending_buf + (ss->pending_out - ss->pending_buf);
+    ds->d_buf = overlay + ds->lit_bufsize/sizeof(ush);
+    ds->l_buf = ds->pending_buf + (1+sizeof(ush))*ds->lit_bufsize;
+
+    ds->l_desc.dyn_tree = ds->dyn_ltree;
+    ds->d_desc.dyn_tree = ds->dyn_dtree;
+    ds->bl_desc.dyn_tree = ds->bl_tree;
+
+    return Z_OK;
+#endif
+}
+
+/* ===========================================================================
+ * Read a new buffer from the current input stream, update the adler32
+ * and total number of bytes read.  All deflate() input goes through
+ * this function so some applications may wish to modify it to avoid
+ * allocating a large strm->next_in buffer and copying from it.
+ * (See also flush_pending()).
+ */
+local int read_buf(strm, buf, size)
+    z_streamp strm;
+    Bytef *buf;
+    unsigned size;
+{
+    unsigned len = strm->avail_in;
+
+    if (len > size) len = size;
+    if (len == 0) return 0;
+
+    strm->avail_in  -= len;
+
+    if (!strm->state->noheader) {
+        strm->adler = adler32(strm->adler, strm->next_in, len);
+    }
+    zmemcpy(buf, strm->next_in, len);
+    strm->next_in  += len;
+    strm->total_in += len;
+
+    return (int)len;
+}
+
+/* ===========================================================================
+ * Initialize the "longest match" routines for a new zlib stream
+ */
+local void lm_init (s)
+    deflate_state *s;
+{
+    s->window_size = (ulg)2L*s->w_size;
+
+    CLEAR_HASH(s);
+
+    /* Set the default configuration parameters:
+     */
+    s->max_lazy_match   = configuration_table[s->level].max_lazy;
+    s->good_match       = configuration_table[s->level].good_length;
+    s->nice_match       = configuration_table[s->level].nice_length;
+    s->max_chain_length = configuration_table[s->level].max_chain;
+
+    s->strstart = 0;
+    s->block_start = 0L;
+    s->lookahead = 0;
+    s->match_length = s->prev_length = MIN_MATCH-1;
+    s->match_available = 0;
+    s->ins_h = 0;
+#ifdef ASMV
+    match_init(); /* initialize the asm code */
+#endif
+}
+
+/* ===========================================================================
+ * Set match_start to the longest match starting at the given string and
+ * return its length. Matches shorter or equal to prev_length are discarded,
+ * in which case the result is equal to prev_length and match_start is
+ * garbage.
+ * IN assertions: cur_match is the head of the hash chain for the current
+ *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1
+ * OUT assertion: the match length is not greater than s->lookahead.
+ */
+#ifndef ASMV
+/* For 80x86 and 680x0, an optimized version will be provided in match.asm or
+ * match.S. The code will be functionally equivalent.
+ */
+#ifndef FASTEST
+local uInt longest_match(s, cur_match)
+    deflate_state *s;
+    IPos cur_match;                             /* current match */
+{
+    unsigned chain_length = s->max_chain_length;/* max hash chain length */
+    register Bytef *scan = s->window + s->strstart; /* current string */
+    register Bytef *match;                       /* matched string */
+    register int len;                           /* length of current match */
+    int best_len = s->prev_length;              /* best match length so far */
+    int nice_match = s->nice_match;             /* stop if match long enough */
+    IPos limit = s->strstart > (IPos)MAX_DIST(s) ?
+        s->strstart - (IPos)MAX_DIST(s) : NIL;
+    /* Stop when cur_match becomes <= limit. To simplify the code,
+     * we prevent matches with the string of window index 0.
+     */
+    Posf *prev = s->prev;
+    uInt wmask = s->w_mask;
+
+#ifdef UNALIGNED_OK
+    /* Compare two bytes at a time. Note: this is not always beneficial.
+     * Try with and without -DUNALIGNED_OK to check.
+     */
+    register Bytef *strend = s->window + s->strstart + MAX_MATCH - 1;
+    register ush scan_start = *(ushf*)scan;
+    register ush scan_end   = *(ushf*)(scan+best_len-1);
+#else
+    register Bytef *strend = s->window + s->strstart + MAX_MATCH;
+    register Byte scan_end1  = scan[best_len-1];
+    register Byte scan_end   = scan[best_len];
+#endif
+
+    /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.
+     * It is easy to get rid of this optimization if necessary.
+     */
+    Assert(s->hash_bits >= 8 && MAX_MATCH == 258, "Code too clever");
+
+    /* Do not waste too much time if we already have a good match: */
+    if (s->prev_length >= s->good_match) {
+        chain_length >>= 2;
+    }
+    /* Do not look for matches beyond the end of the input. This is necessary
+     * to make deflate deterministic.
+     */
+    if ((uInt)nice_match > s->lookahead) nice_match = s->lookahead;
+
+    Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, "need lookahead");
+
+    do {
+        Assert(cur_match < s->strstart, "no future");
+        match = s->window + cur_match;
+
+        /* Skip to next match if the match length cannot increase
+         * or if the match length is less than 2:
+         */
+#if (defined(UNALIGNED_OK) && MAX_MATCH == 258)
+        /* This code assumes sizeof(unsigned short) == 2. Do not use
+         * UNALIGNED_OK if your compiler uses a different size.
+         */
+        if (*(ushf*)(match+best_len-1) != scan_end ||
+            *(ushf*)match != scan_start) continue;
+
+        /* It is not necessary to compare scan[2] and match[2] since they are
+         * always equal when the other bytes match, given that the hash keys
+         * are equal and that HASH_BITS >= 8. Compare 2 bytes at a time at
+         * strstart+3, +5, ... up to strstart+257. We check for insufficient
+         * lookahead only every 4th comparison; the 128th check will be made
+         * at strstart+257. If MAX_MATCH-2 is not a multiple of 8, it is
+         * necessary to put more guard bytes at the end of the window, or
+         * to check more often for insufficient lookahead.
+         */
+        Assert(scan[2] == match[2], "scan[2]?");
+        scan++, match++;
+        do {
+        } while (*(ushf*)(scan+=2) == *(ushf*)(match+=2) &&
+                 *(ushf*)(scan+=2) == *(ushf*)(match+=2) &&
+                 *(ushf*)(scan+=2) == *(ushf*)(match+=2) &&
+                 *(ushf*)(scan+=2) == *(ushf*)(match+=2) &&
+                 scan < strend);
+        /* The funny "do {}" generates better code on most compilers */
+
+        /* Here, scan <= window+strstart+257 */
+        Assert(scan <= s->window+(unsigned)(s->window_size-1), "wild scan");
+        if (*scan == *match) scan++;
+
+        len = (MAX_MATCH - 1) - (int)(strend-scan);
+        scan = strend - (MAX_MATCH-1);
+
+#else /* UNALIGNED_OK */
+
+        if (match[best_len]   != scan_end  ||
+            match[best_len-1] != scan_end1 ||
+            *match            != *scan     ||
+            *++match          != scan[1])      continue;
+
+        /* The check at best_len-1 can be removed because it will be made
+         * again later. (This heuristic is not always a win.)
+         * It is not necessary to compare scan[2] and match[2] since they
+         * are always equal when the other bytes match, given that
+         * the hash keys are equal and that HASH_BITS >= 8.
+         */
+        scan += 2, match++;
+        Assert(*scan == *match, "match[2]?");
+
+        /* We check for insufficient lookahead only every 8th comparison;
+         * the 256th check will be made at strstart+258.
+         */
+        do {
+        } while (*++scan == *++match && *++scan == *++match &&
+                 *++scan == *++match && *++scan == *++match &&
+                 *++scan == *++match && *++scan == *++match &&
+                 *++scan == *++match && *++scan == *++match &&
+                 scan < strend);
+
+        Assert(scan <= s->window+(unsigned)(s->window_size-1), "wild scan");
+
+        len = MAX_MATCH - (int)(strend - scan);
+        scan = strend - MAX_MATCH;
+
+#endif /* UNALIGNED_OK */
+
+        if (len > best_len) {
+            s->match_start = cur_match;
+            best_len = len;
+            if (len >= nice_match) break;
+#ifdef UNALIGNED_OK
+            scan_end = *(ushf*)(scan+best_len-1);
+#else
+            scan_end1  = scan[best_len-1];
+            scan_end   = scan[best_len];
+#endif
+        }
+    } while ((cur_match = prev[cur_match & wmask]) > limit
+             && --chain_length != 0);
+
+    if ((uInt)best_len <= s->lookahead) return (uInt)best_len;
+    return s->lookahead;
+}
+
+#else /* FASTEST */
+/* ---------------------------------------------------------------------------
+ * Optimized version for level == 1 only
+ */
+local uInt longest_match(s, cur_match)
+    deflate_state *s;
+    IPos cur_match;                             /* current match */
+{
+    register Bytef *scan = s->window + s->strstart; /* current string */
+    register Bytef *match;                       /* matched string */
+    register int len;                           /* length of current match */
+    register Bytef *strend = s->window + s->strstart + MAX_MATCH;
+
+    /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.
+     * It is easy to get rid of this optimization if necessary.
+     */
+    Assert(s->hash_bits >= 8 && MAX_MATCH == 258, "Code too clever");
+
+    Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, "need lookahead");
+
+    Assert(cur_match < s->strstart, "no future");
+
+    match = s->window + cur_match;
+
+    /* Return failure if the match length is less than 2:
+     */
+    if (match[0] != scan[0] || match[1] != scan[1]) return MIN_MATCH-1;
+
+    /* The check at best_len-1 can be removed because it will be made
+     * again later. (This heuristic is not always a win.)
+     * It is not necessary to compare scan[2] and match[2] since they
+     * are always equal when the other bytes match, given that
+     * the hash keys are equal and that HASH_BITS >= 8.
+     */
+    scan += 2, match += 2;
+    Assert(*scan == *match, "match[2]?");
+
+    /* We check for insufficient lookahead only every 8th comparison;
+     * the 256th check will be made at strstart+258.
+     */
+    do {
+    } while (*++scan == *++match && *++scan == *++match &&
+	     *++scan == *++match && *++scan == *++match &&
+	     *++scan == *++match && *++scan == *++match &&
+	     *++scan == *++match && *++scan == *++match &&
+	     scan < strend);
+
+    Assert(scan <= s->window+(unsigned)(s->window_size-1), "wild scan");
+
+    len = MAX_MATCH - (int)(strend - scan);
+
+    if (len < MIN_MATCH) return MIN_MATCH - 1;
+
+    s->match_start = cur_match;
+    return len <= s->lookahead ? len : s->lookahead;
+}
+#endif /* FASTEST */
+#endif /* ASMV */
+
+#ifdef DEBUG
+/* ===========================================================================
+ * Check that the match at match_start is indeed a match.
+ */
+local void check_match(s, start, match, length)
+    deflate_state *s;
+    IPos start, match;
+    int length;
+{
+    /* check that the match is indeed a match */
+    if (zmemcmp(s->window + match,
+                s->window + start, length) != EQUAL) {
+        fprintf(stderr, " start %u, match %u, length %d\n",
+		start, match, length);
+        do {
+	    fprintf(stderr, "%c%c", s->window[match++], s->window[start++]);
+	} while (--length != 0);
+        z_error("invalid match");
+    }
+    if (z_verbose > 1) {
+        fprintf(stderr,"\\[%d,%d]", start-match, length);
+        do { putc(s->window[start++], stderr); } while (--length != 0);
+    }
+}
+#else
+#  define check_match(s, start, match, length)
+#endif
+
+/* ===========================================================================
+ * Fill the window when the lookahead becomes insufficient.
+ * Updates strstart and lookahead.
+ *
+ * IN assertion: lookahead < MIN_LOOKAHEAD
+ * OUT assertions: strstart <= window_size-MIN_LOOKAHEAD
+ *    At least one byte has been read, or avail_in == 0; reads are
+ *    performed for at least two bytes (required for the zip translate_eol
+ *    option -- not supported here).
+ */
+local void fill_window(s)
+    deflate_state *s;
+{
+    register unsigned n, m;
+    register Posf *p;
+    unsigned more;    /* Amount of free space at the end of the window. */
+    uInt wsize = s->w_size;
+
+    do {
+        more = (unsigned)(s->window_size -(ulg)s->lookahead -(ulg)s->strstart);
+
+        /* Deal with !@#$% 64K limit: */
+        if (more == 0 && s->strstart == 0 && s->lookahead == 0) {
+            more = wsize;
+
+        } else if (more == (unsigned)(-1)) {
+            /* Very unlikely, but possible on 16 bit machine if strstart == 0
+             * and lookahead == 1 (input done one byte at time)
+             */
+            more--;
+
+        /* If the window is almost full and there is insufficient lookahead,
+         * move the upper half to the lower one to make room in the upper half.
+         */
+        } else if (s->strstart >= wsize+MAX_DIST(s)) {
+
+            zmemcpy(s->window, s->window+wsize, (unsigned)wsize);
+            s->match_start -= wsize;
+            s->strstart    -= wsize; /* we now have strstart >= MAX_DIST */
+            s->block_start -= (long) wsize;
+
+            /* Slide the hash table (could be avoided with 32 bit values
+               at the expense of memory usage). We slide even when level == 0
+               to keep the hash table consistent if we switch back to level > 0
+               later. (Using level 0 permanently is not an optimal usage of
+               zlib, so we don't care about this pathological case.)
+             */
+	    n = s->hash_size;
+	    p = &s->head[n];
+	    do {
+		m = *--p;
+		*p = (Pos)(m >= wsize ? m-wsize : NIL);
+	    } while (--n);
+
+	    n = wsize;
+#ifndef FASTEST
+	    p = &s->prev[n];
+	    do {
+		m = *--p;
+		*p = (Pos)(m >= wsize ? m-wsize : NIL);
+		/* If n is not on any hash chain, prev[n] is garbage but
+		 * its value will never be used.
+		 */
+	    } while (--n);
+#endif
+            more += wsize;
+        }
+        if (s->strm->avail_in == 0) return;
+
+        /* If there was no sliding:
+         *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&
+         *    more == window_size - lookahead - strstart
+         * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)
+         * => more >= window_size - 2*WSIZE + 2
+         * In the BIG_MEM or MMAP case (not yet supported),
+         *   window_size == input_size + MIN_LOOKAHEAD  &&
+         *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.
+         * Otherwise, window_size == 2*WSIZE so more >= 2.
+         * If there was sliding, more >= WSIZE. So in all cases, more >= 2.
+         */
+        Assert(more >= 2, "more < 2");
+
+        n = read_buf(s->strm, s->window + s->strstart + s->lookahead, more);
+        s->lookahead += n;
+
+        /* Initialize the hash value now that we have some input: */
+        if (s->lookahead >= MIN_MATCH) {
+            s->ins_h = s->window[s->strstart];
+            UPDATE_HASH(s, s->ins_h, s->window[s->strstart+1]);
+#if MIN_MATCH != 3
+            Call UPDATE_HASH() MIN_MATCH-3 more times
+#endif
+        }
+        /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,
+         * but this is not important since only literal bytes will be emitted.
+         */
+
+    } while (s->lookahead < MIN_LOOKAHEAD && s->strm->avail_in != 0);
+}
+
+/* ===========================================================================
+ * Flush the current block, with given end-of-file flag.
+ * IN assertion: strstart is set to the end of the current match.
+ */
+#define FLUSH_BLOCK_ONLY(s, eof) { \
+   _tr_flush_block(s, (s->block_start >= 0L ? \
+                   (charf *)&s->window[(unsigned)s->block_start] : \
+                   (charf *)Z_NULL), \
+		(ulg)((long)s->strstart - s->block_start), \
+		(eof)); \
+   s->block_start = s->strstart; \
+   flush_pending(s->strm); \
+   Tracev((stderr,"[FLUSH]")); \
+}
+
+/* Same but force premature exit if necessary. */
+#define FLUSH_BLOCK(s, eof) { \
+   FLUSH_BLOCK_ONLY(s, eof); \
+   if (s->strm->avail_out == 0) return (eof) ? finish_started : need_more; \
+}
+
+/* ===========================================================================
+ * Copy without compression as much as possible from the input stream, return
+ * the current block state.
+ * This function does not insert new strings in the dictionary since
+ * uncompressible data is probably not useful. This function is used
+ * only for the level=0 compression option.
+ * NOTE: this function should be optimized to avoid extra copying from
+ * window to pending_buf.
+ */
+local block_state deflate_stored(s, flush)
+    deflate_state *s;
+    int flush;
+{
+    /* Stored blocks are limited to 0xffff bytes, pending_buf is limited
+     * to pending_buf_size, and each stored block has a 5 byte header:
+     */
+    ulg max_block_size = 0xffff;
+    ulg max_start;
+
+    if (max_block_size > s->pending_buf_size - 5) {
+        max_block_size = s->pending_buf_size - 5;
+    }
+
+    /* Copy as much as possible from input to output: */
+    for (;;) {
+        /* Fill the window as much as possible: */
+        if (s->lookahead <= 1) {
+
+            Assert(s->strstart < s->w_size+MAX_DIST(s) ||
+		   s->block_start >= (long)s->w_size, "slide too late");
+
+            fill_window(s);
+            if (s->lookahead == 0 && flush == Z_NO_FLUSH) return need_more;
+
+            if (s->lookahead == 0) break; /* flush the current block */
+        }
+	Assert(s->block_start >= 0L, "block gone");
+
+	s->strstart += s->lookahead;
+	s->lookahead = 0;
+
+	/* Emit a stored block if pending_buf will be full: */
+ 	max_start = s->block_start + max_block_size;
+        if (s->strstart == 0 || (ulg)s->strstart >= max_start) {
+	    /* strstart == 0 is possible when wraparound on 16-bit machine */
+	    s->lookahead = (uInt)(s->strstart - max_start);
+	    s->strstart = (uInt)max_start;
+            FLUSH_BLOCK(s, 0);
+	}
+	/* Flush if we may have to slide, otherwise block_start may become
+         * negative and the data will be gone:
+         */
+        if (s->strstart - (uInt)s->block_start >= MAX_DIST(s)) {
+            FLUSH_BLOCK(s, 0);
+	}
+    }
+    FLUSH_BLOCK(s, flush == Z_FINISH);
+    return flush == Z_FINISH ? finish_done : block_done;
+}
+
+/* ===========================================================================
+ * Compress as much as possible from the input stream, return the current
+ * block state.
+ * This function does not perform lazy evaluation of matches and inserts
+ * new strings in the dictionary only for unmatched strings or for short
+ * matches. It is used only for the fast compression options.
+ */
+local block_state deflate_fast(s, flush)
+    deflate_state *s;
+    int flush;
+{
+    IPos hash_head = NIL; /* head of the hash chain */
+    int bflush;           /* set if current block must be flushed */
+
+    for (;;) {
+        /* Make sure that we always have enough lookahead, except
+         * at the end of the input file. We need MAX_MATCH bytes
+         * for the next match, plus MIN_MATCH bytes to insert the
+         * string following the next match.
+         */
+        if (s->lookahead < MIN_LOOKAHEAD) {
+            fill_window(s);
+            if (s->lookahead < MIN_LOOKAHEAD && flush == Z_NO_FLUSH) {
+	        return need_more;
+	    }
+            if (s->lookahead == 0) break; /* flush the current block */
+        }
+
+        /* Insert the string window[strstart .. strstart+2] in the
+         * dictionary, and set hash_head to the head of the hash chain:
+         */
+        if (s->lookahead >= MIN_MATCH) {
+            INSERT_STRING(s, s->strstart, hash_head);
+        }
+
+        /* Find the longest match, discarding those <= prev_length.
+         * At this point we have always match_length < MIN_MATCH
+         */
+        if (hash_head != NIL && s->strstart - hash_head <= MAX_DIST(s)) {
+            /* To simplify the code, we prevent matches with the string
+             * of window index 0 (in particular we have to avoid a match
+             * of the string with itself at the start of the input file).
+             */
+            if (s->strategy != Z_HUFFMAN_ONLY) {
+                s->match_length = longest_match (s, hash_head);
+            }
+            /* longest_match() sets match_start */
+        }
+        if (s->match_length >= MIN_MATCH) {
+            check_match(s, s->strstart, s->match_start, s->match_length);
+
+            _tr_tally_dist(s, s->strstart - s->match_start,
+                           s->match_length - MIN_MATCH, bflush);
+
+            s->lookahead -= s->match_length;
+
+            /* Insert new strings in the hash table only if the match length
+             * is not too large. This saves time but degrades compression.
+             */
+#ifndef FASTEST
+            if (s->match_length <= s->max_insert_length &&
+                s->lookahead >= MIN_MATCH) {
+                s->match_length--; /* string at strstart already in hash table */
+                do {
+                    s->strstart++;
+                    INSERT_STRING(s, s->strstart, hash_head);
+                    /* strstart never exceeds WSIZE-MAX_MATCH, so there are
+                     * always MIN_MATCH bytes ahead.
+                     */
+                } while (--s->match_length != 0);
+                s->strstart++; 
+            } else
+#endif
+	    {
+                s->strstart += s->match_length;
+                s->match_length = 0;
+                s->ins_h = s->window[s->strstart];
+                UPDATE_HASH(s, s->ins_h, s->window[s->strstart+1]);
+#if MIN_MATCH != 3
+                Call UPDATE_HASH() MIN_MATCH-3 more times
+#endif
+                /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not
+                 * matter since it will be recomputed at next deflate call.
+                 */
+            }
+        } else {
+            /* No match, output a literal byte */
+            Tracevv((stderr,"%c", s->window[s->strstart]));
+            _tr_tally_lit (s, s->window[s->strstart], bflush);
+            s->lookahead--;
+            s->strstart++; 
+        }
+        if (bflush) FLUSH_BLOCK(s, 0);
+    }
+    FLUSH_BLOCK(s, flush == Z_FINISH);
+    return flush == Z_FINISH ? finish_done : block_done;
+}
+
+/* ===========================================================================
+ * Same as above, but achieves better compression. We use a lazy
+ * evaluation for matches: a match is finally adopted only if there is
+ * no better match at the next window position.
+ */
+local block_state deflate_slow(s, flush)
+    deflate_state *s;
+    int flush;
+{
+    IPos hash_head = NIL;    /* head of hash chain */
+    int bflush;              /* set if current block must be flushed */
+
+    /* Process the input block. */
+    for (;;) {
+        /* Make sure that we always have enough lookahead, except
+         * at the end of the input file. We need MAX_MATCH bytes
+         * for the next match, plus MIN_MATCH bytes to insert the
+         * string following the next match.
+         */
+        if (s->lookahead < MIN_LOOKAHEAD) {
+            fill_window(s);
+            if (s->lookahead < MIN_LOOKAHEAD && flush == Z_NO_FLUSH) {
+	        return need_more;
+	    }
+            if (s->lookahead == 0) break; /* flush the current block */
+        }
+
+        /* Insert the string window[strstart .. strstart+2] in the
+         * dictionary, and set hash_head to the head of the hash chain:
+         */
+        if (s->lookahead >= MIN_MATCH) {
+            INSERT_STRING(s, s->strstart, hash_head);
+        }
+
+        /* Find the longest match, discarding those <= prev_length.
+         */
+        s->prev_length = s->match_length, s->prev_match = s->match_start;
+        s->match_length = MIN_MATCH-1;
+
+        if (hash_head != NIL && s->prev_length < s->max_lazy_match &&
+            s->strstart - hash_head <= MAX_DIST(s)) {
+            /* To simplify the code, we prevent matches with the string
+             * of window index 0 (in particular we have to avoid a match
+             * of the string with itself at the start of the input file).
+             */
+            if (s->strategy != Z_HUFFMAN_ONLY) {
+                s->match_length = longest_match (s, hash_head);
+            }
+            /* longest_match() sets match_start */
+
+            if (s->match_length <= 5 && (s->strategy == Z_FILTERED ||
+                 (s->match_length == MIN_MATCH &&
+                  s->strstart - s->match_start > TOO_FAR))) {
+
+                /* If prev_match is also MIN_MATCH, match_start is garbage
+                 * but we will ignore the current match anyway.
+                 */
+                s->match_length = MIN_MATCH-1;
+            }
+        }
+        /* If there was a match at the previous step and the current
+         * match is not better, output the previous match:
+         */
+        if (s->prev_length >= MIN_MATCH && s->match_length <= s->prev_length) {
+            uInt max_insert = s->strstart + s->lookahead - MIN_MATCH;
+            /* Do not insert strings in hash table beyond this. */
+
+            check_match(s, s->strstart-1, s->prev_match, s->prev_length);
+
+            _tr_tally_dist(s, s->strstart -1 - s->prev_match,
+			   s->prev_length - MIN_MATCH, bflush);
+
+            /* Insert in hash table all strings up to the end of the match.
+             * strstart-1 and strstart are already inserted. If there is not
+             * enough lookahead, the last two strings are not inserted in
+             * the hash table.
+             */
+            s->lookahead -= s->prev_length-1;
+            s->prev_length -= 2;
+            do {
+                if (++s->strstart <= max_insert) {
+                    INSERT_STRING(s, s->strstart, hash_head);
+                }
+            } while (--s->prev_length != 0);
+            s->match_available = 0;
+            s->match_length = MIN_MATCH-1;
+            s->strstart++;
+
+            if (bflush) FLUSH_BLOCK(s, 0);
+
+        } else if (s->match_available) {
+            /* If there was no match at the previous position, output a
+             * single literal. If there was a match but the current match
+             * is longer, truncate the previous match to a single literal.
+             */
+            Tracevv((stderr,"%c", s->window[s->strstart-1]));
+	    _tr_tally_lit(s, s->window[s->strstart-1], bflush);
+	    if (bflush) {
+                FLUSH_BLOCK_ONLY(s, 0);
+            }
+            s->strstart++;
+            s->lookahead--;
+            if (s->strm->avail_out == 0) return need_more;
+        } else {
+            /* There is no previous match to compare with, wait for
+             * the next step to decide.
+             */
+            s->match_available = 1;
+            s->strstart++;
+            s->lookahead--;
+        }
+    }
+    Assert (flush != Z_NO_FLUSH, "no flush?");
+    if (s->match_available) {
+        Tracevv((stderr,"%c", s->window[s->strstart-1]));
+        _tr_tally_lit(s, s->window[s->strstart-1], bflush);
+        s->match_available = 0;
+    }
+    FLUSH_BLOCK(s, flush == Z_FINISH);
+    return flush == Z_FINISH ? finish_done : block_done;
+}
diff --git a/src/unix/contrib/cutzlib-1.1.4/deflate.h b/src/unix/contrib/cutzlib-1.1.4/deflate.h
new file mode 100644
index 0000000..7a87401
--- /dev/null
+++ b/src/unix/contrib/cutzlib-1.1.4/deflate.h
@@ -0,0 +1,318 @@
+/* deflate.h -- internal compression state
+ * Copyright (C) 1995-2002 Jean-loup Gailly
+ * For conditions of distribution and use, see copyright notice in zlib.h 
+ */
+
+/* WARNING: this file should *not* be used by applications. It is
+   part of the implementation of the compression library and is
+   subject to change. Applications should only use zlib.h.
+ */
+
+/* @(#) $Id: deflate.h,v 1.1 2002/04/18 21:15:04 l_g Exp $ */
+
+#ifndef _DEFLATE_H
+#define _DEFLATE_H
+
+#include "zutil.h"
+
+/* ===========================================================================
+ * Internal compression state.
+ */
+
+#define LENGTH_CODES 29
+/* number of length codes, not counting the special END_BLOCK code */
+
+#define LITERALS  256
+/* number of literal bytes 0..255 */
+
+#define L_CODES (LITERALS+1+LENGTH_CODES)
+/* number of Literal or Length codes, including the END_BLOCK code */
+
+#define D_CODES   30
+/* number of distance codes */
+
+#define BL_CODES  19
+/* number of codes used to transfer the bit lengths */
+
+#define HEAP_SIZE (2*L_CODES+1)
+/* maximum heap size */
+
+#define MAX_BITS 15
+/* All codes must not exceed MAX_BITS bits */
+
+#define INIT_STATE    42
+#define BUSY_STATE   113
+#define FINISH_STATE 666
+/* Stream status */
+
+
+/* Data structure describing a single value and its code string. */
+typedef struct ct_data_s {
+    union {
+        ush  freq;       /* frequency count */
+        ush  code;       /* bit string */
+    } fc;
+    union {
+        ush  dad;        /* father node in Huffman tree */
+        ush  len;        /* length of bit string */
+    } dl;
+} FAR ct_data;
+
+#define Freq fc.freq
+#define Code fc.code
+#define Dad  dl.dad
+#define Len  dl.len
+
+typedef struct static_tree_desc_s  static_tree_desc;
+
+typedef struct tree_desc_s {
+    ct_data *dyn_tree;           /* the dynamic tree */
+    int     max_code;            /* largest code with non zero frequency */
+    static_tree_desc *stat_desc; /* the corresponding static tree */
+} FAR tree_desc;
+
+typedef ush Pos;
+typedef Pos FAR Posf;
+typedef unsigned IPos;
+
+/* A Pos is an index in the character window. We use short instead of int to
+ * save space in the various tables. IPos is used only for parameter passing.
+ */
+
+typedef struct internal_state {
+    z_streamp strm;      /* pointer back to this zlib stream */
+    int   status;        /* as the name implies */
+    Bytef *pending_buf;  /* output still pending */
+    ulg   pending_buf_size; /* size of pending_buf */
+    Bytef *pending_out;  /* next pending byte to output to the stream */
+    int   pending;       /* nb of bytes in the pending buffer */
+    int   noheader;      /* suppress zlib header and adler32 */
+    Byte  data_type;     /* UNKNOWN, BINARY or ASCII */
+    Byte  method;        /* STORED (for zip only) or DEFLATED */
+    int   last_flush;    /* value of flush param for previous deflate call */
+
+                /* used by deflate.c: */
+
+    uInt  w_size;        /* LZ77 window size (32K by default) */
+    uInt  w_bits;        /* log2(w_size)  (8..16) */
+    uInt  w_mask;        /* w_size - 1 */
+
+    Bytef *window;
+    /* Sliding window. Input bytes are read into the second half of the window,
+     * and move to the first half later to keep a dictionary of at least wSize
+     * bytes. With this organization, matches are limited to a distance of
+     * wSize-MAX_MATCH bytes, but this ensures that IO is always
+     * performed with a length multiple of the block size. Also, it limits
+     * the window size to 64K, which is quite useful on MSDOS.
+     * To do: use the user input buffer as sliding window.
+     */
+
+    ulg window_size;
+    /* Actual size of window: 2*wSize, except when the user input buffer
+     * is directly used as sliding window.
+     */
+
+    Posf *prev;
+    /* Link to older string with same hash index. To limit the size of this
+     * array to 64K, this link is maintained only for the last 32K strings.
+     * An index in this array is thus a window index modulo 32K.
+     */
+
+    Posf *head; /* Heads of the hash chains or NIL. */
+
+    uInt  ins_h;          /* hash index of string to be inserted */
+    uInt  hash_size;      /* number of elements in hash table */
+    uInt  hash_bits;      /* log2(hash_size) */
+    uInt  hash_mask;      /* hash_size-1 */
+
+    uInt  hash_shift;
+    /* Number of bits by which ins_h must be shifted at each input
+     * step. It must be such that after MIN_MATCH steps, the oldest
+     * byte no longer takes part in the hash key, that is:
+     *   hash_shift * MIN_MATCH >= hash_bits
+     */
+
+    long block_start;
+    /* Window position at the beginning of the current output block. Gets
+     * negative when the window is moved backwards.
+     */
+
+    uInt match_length;           /* length of best match */
+    IPos prev_match;             /* previous match */
+    int match_available;         /* set if previous match exists */
+    uInt strstart;               /* start of string to insert */
+    uInt match_start;            /* start of matching string */
+    uInt lookahead;              /* number of valid bytes ahead in window */
+
+    uInt prev_length;
+    /* Length of the best match at previous step. Matches not greater than this
+     * are discarded. This is used in the lazy match evaluation.
+     */
+
+    uInt max_chain_length;
+    /* To speed up deflation, hash chains are never searched beyond this
+     * length.  A higher limit improves compression ratio but degrades the
+     * speed.
+     */
+
+    uInt max_lazy_match;
+    /* Attempt to find a better match only when the current match is strictly
+     * smaller than this value. This mechanism is used only for compression
+     * levels >= 4.
+     */
+#   define max_insert_length  max_lazy_match
+    /* Insert new strings in the hash table only if the match length is not
+     * greater than this length. This saves time but degrades compression.
+     * max_insert_length is used only for compression levels <= 3.
+     */
+
+    int level;    /* compression level (1..9) */
+    int strategy; /* favor or force Huffman coding*/
+
+    uInt good_match;
+    /* Use a faster search when the previous match is longer than this */
+
+    int nice_match; /* Stop searching when current match exceeds this */
+
+                /* used by trees.c: */
+    /* Didn't use ct_data typedef below to supress compiler warning */
+    struct ct_data_s dyn_ltree[HEAP_SIZE];   /* literal and length tree */
+    struct ct_data_s dyn_dtree[2*D_CODES+1]; /* distance tree */
+    struct ct_data_s bl_tree[2*BL_CODES+1];  /* Huffman tree for bit lengths */
+
+    struct tree_desc_s l_desc;               /* desc. for literal tree */
+    struct tree_desc_s d_desc;               /* desc. for distance tree */
+    struct tree_desc_s bl_desc;              /* desc. for bit length tree */
+
+    ush bl_count[MAX_BITS+1];
+    /* number of codes at each bit length for an optimal tree */
+
+    int heap[2*L_CODES+1];      /* heap used to build the Huffman trees */
+    int heap_len;               /* number of elements in the heap */
+    int heap_max;               /* element of largest frequency */
+    /* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.
+     * The same heap array is used to build all trees.
+     */
+
+    uch depth[2*L_CODES+1];
+    /* Depth of each subtree used as tie breaker for trees of equal frequency
+     */
+
+    uchf *l_buf;          /* buffer for literals or lengths */
+
+    uInt  lit_bufsize;
+    /* Size of match buffer for literals/lengths.  There are 4 reasons for
+     * limiting lit_bufsize to 64K:
+     *   - frequencies can be kept in 16 bit counters
+     *   - if compression is not successful for the first block, all input
+     *     data is still in the window so we can still emit a stored block even
+     *     when input comes from standard input.  (This can also be done for
+     *     all blocks if lit_bufsize is not greater than 32K.)
+     *   - if compression is not successful for a file smaller than 64K, we can
+     *     even emit a stored file instead of a stored block (saving 5 bytes).
+     *     This is applicable only for zip (not gzip or zlib).
+     *   - creating new Huffman trees less frequently may not provide fast
+     *     adaptation to changes in the input data statistics. (Take for
+     *     example a binary file with poorly compressible code followed by
+     *     a highly compressible string table.) Smaller buffer sizes give
+     *     fast adaptation but have of course the overhead of transmitting
+     *     trees more frequently.
+     *   - I can't count above 4
+     */
+
+    uInt last_lit;      /* running index in l_buf */
+
+    ushf *d_buf;
+    /* Buffer for distances. To simplify the code, d_buf and l_buf have
+     * the same number of elements. To use different lengths, an extra flag
+     * array would be necessary.
+     */
+
+    ulg opt_len;        /* bit length of current block with optimal trees */
+    ulg static_len;     /* bit length of current block with static trees */
+    uInt matches;       /* number of string matches in current block */
+    int last_eob_len;   /* bit length of EOB code for last block */
+
+#ifdef DEBUG
+    ulg compressed_len; /* total bit length of compressed file mod 2^32 */
+    ulg bits_sent;      /* bit length of compressed data sent mod 2^32 */
+#endif
+
+    ush bi_buf;
+    /* Output buffer. bits are inserted starting at the bottom (least
+     * significant bits).
+     */
+    int bi_valid;
+    /* Number of valid bits in bi_buf.  All bits above the last valid bit
+     * are always zero.
+     */
+
+} FAR deflate_state;
+
+/* Output a byte on the stream.
+ * IN assertion: there is enough room in pending_buf.
+ */
+#define put_byte(s, c) {s->pending_buf[s->pending++] = (c);}
+
+
+#define MIN_LOOKAHEAD (MAX_MATCH+MIN_MATCH+1)
+/* Minimum amount of lookahead, except at the end of the input file.
+ * See deflate.c for comments about the MIN_MATCH+1.
+ */
+
+#define MAX_DIST(s)  ((s)->w_size-MIN_LOOKAHEAD)
+/* In order to simplify the code, particularly on 16 bit machines, match
+ * distances are limited to MAX_DIST instead of WSIZE.
+ */
+
+        /* in trees.c */
+void _tr_init         OF((deflate_state *s));
+int  _tr_tally        OF((deflate_state *s, unsigned dist, unsigned lc));
+void _tr_flush_block  OF((deflate_state *s, charf *buf, ulg stored_len,
+			  int eof));
+void _tr_align        OF((deflate_state *s));
+void _tr_stored_block OF((deflate_state *s, charf *buf, ulg stored_len,
+                          int eof));
+
+#define d_code(dist) \
+   ((dist) < 256 ? _dist_code[dist] : _dist_code[256+((dist)>>7)])
+/* Mapping from a distance to a distance code. dist is the distance - 1 and
+ * must not have side effects. _dist_code[256] and _dist_code[257] are never
+ * used.
+ */
+
+#ifndef DEBUG
+/* Inline versions of _tr_tally for speed: */
+
+#if defined(GEN_TREES_H) || !defined(STDC)
+  extern uch _length_code[];
+  extern uch _dist_code[];
+#else
+  extern const uch _length_code[];
+  extern const uch _dist_code[];
+#endif
+
+# define _tr_tally_lit(s, c, flush) \
+  { uch cc = (c); \
+    s->d_buf[s->last_lit] = 0; \
+    s->l_buf[s->last_lit++] = cc; \
+    s->dyn_ltree[cc].Freq++; \
+    flush = (s->last_lit == s->lit_bufsize-1); \
+   }
+# define _tr_tally_dist(s, distance, length, flush) \
+  { uch len = (length); \
+    ush dist = (distance); \
+    s->d_buf[s->last_lit] = dist; \
+    s->l_buf[s->last_lit++] = len; \
+    dist--; \
+    s->dyn_ltree[_length_code[len]+LITERALS+1].Freq++; \
+    s->dyn_dtree[d_code(dist)].Freq++; \
+    flush = (s->last_lit == s->lit_bufsize-1); \
+  }
+#else
+# define _tr_tally_lit(s, c, flush) flush = _tr_tally(s, 0, c)
+# define _tr_tally_dist(s, distance, length, flush) \
+              flush = _tr_tally(s, distance, length) 
+#endif
+
+#endif
diff --git a/src/unix/contrib/cutzlib-1.1.4/gzio.c b/src/unix/contrib/cutzlib-1.1.4/gzio.c
new file mode 100644
index 0000000..20281d1
--- /dev/null
+++ b/src/unix/contrib/cutzlib-1.1.4/gzio.c
@@ -0,0 +1,875 @@
+/* gzio.c -- IO on .gz files
+ * Copyright (C) 1995-2002 Jean-loup Gailly.
+ * For conditions of distribution and use, see copyright notice in zlib.h
+ *
+ * Compile this file with -DNO_DEFLATE to avoid the compression code.
+ */
+
+/* @(#) $Id: gzio.c,v 1.1 2002/04/18 21:15:04 l_g Exp $ */
+
+#include <stdio.h>
+
+#include "zutil.h"
+
+struct internal_state {int dummy;}; /* for buggy compilers */
+
+#ifndef Z_BUFSIZE
+#  ifdef MAXSEG_64K
+#    define Z_BUFSIZE 4096 /* minimize memory usage for 16-bit DOS */
+#  else
+#    define Z_BUFSIZE 16384
+#  endif
+#endif
+#ifndef Z_PRINTF_BUFSIZE
+#  define Z_PRINTF_BUFSIZE 4096
+#endif
+
+#define ALLOC(size) malloc(size)
+#define TRYFREE(p) {if (p) free(p);}
+
+static int gz_magic[2] = {0x1f, 0x8b}; /* gzip magic header */
+
+/* gzip flag byte */
+#define ASCII_FLAG   0x01 /* bit 0 set: file probably ascii text */
+#define HEAD_CRC     0x02 /* bit 1 set: header CRC present */
+#define EXTRA_FIELD  0x04 /* bit 2 set: extra field present */
+#define ORIG_NAME    0x08 /* bit 3 set: original file name present */
+#define COMMENT      0x10 /* bit 4 set: file comment present */
+#define RESERVED     0xE0 /* bits 5..7: reserved */
+
+typedef struct gz_stream {
+    z_stream stream;
+    int      z_err;   /* error code for last stream operation */
+    int      z_eof;   /* set if end of input file */
+    FILE     *file;   /* .gz file */
+    Byte     *inbuf;  /* input buffer */
+    Byte     *outbuf; /* output buffer */
+    uLong    crc;     /* crc32 of uncompressed data */
+    char     *msg;    /* error message */
+    char     *path;   /* path name for debugging only */
+    int      transparent; /* 1 if input file is not a .gz file */
+    char     mode;    /* 'w' or 'r' */
+    long     startpos; /* start of compressed data in file (header skipped) */
+} gz_stream;
+
+
+local gzFile gz_open      OF((const char *path, const char *mode, int  fd));
+local int do_flush        OF((gzFile file, int flush));
+local int    get_byte     OF((gz_stream *s));
+local void   check_header OF((gz_stream *s));
+local int    destroy      OF((gz_stream *s));
+local void   putLong      OF((FILE *file, uLong x));
+local uLong  getLong      OF((gz_stream *s));
+
+/* ===========================================================================
+     Opens a gzip (.gz) file for reading or writing. The mode parameter
+   is as in fopen ("rb" or "wb"). The file is given either by file descriptor
+   or path name (if fd == -1).
+     gz_open return NULL if the file could not be opened or if there was
+   insufficient memory to allocate the (de)compression state; errno
+   can be checked to distinguish the two cases (if errno is zero, the
+   zlib error is Z_MEM_ERROR).
+*/
+local gzFile gz_open (path, mode, fd)
+    const char *path;
+    const char *mode;
+    int  fd;
+{
+    int err;
+    int level = Z_DEFAULT_COMPRESSION; /* compression level */
+    int strategy = Z_DEFAULT_STRATEGY; /* compression strategy */
+    char *p = (char*)mode;
+    gz_stream *s;
+    char fmode[80]; /* copy of mode, without the compression level */
+    char *m = fmode;
+
+    if (!path || !mode) return Z_NULL;
+
+    s = (gz_stream *)ALLOC(sizeof(gz_stream));
+    if (!s) return Z_NULL;
+
+    s->stream.zalloc = (alloc_func)0;
+    s->stream.zfree = (free_func)0;
+    s->stream.opaque = (voidpf)0;
+    s->stream.next_in = s->inbuf = Z_NULL;
+    s->stream.next_out = s->outbuf = Z_NULL;
+    s->stream.avail_in = s->stream.avail_out = 0;
+    s->file = NULL;
+    s->z_err = Z_OK;
+    s->z_eof = 0;
+    s->crc = crc32(0L, Z_NULL, 0);
+    s->msg = NULL;
+    s->transparent = 0;
+
+    s->path = (char*)ALLOC(strlen(path)+1);
+    if (s->path == NULL) {
+        return destroy(s), (gzFile)Z_NULL;
+    }
+    strcpy(s->path, path); /* do this early for debugging */
+
+    s->mode = '\0';
+    do {
+        if (*p == 'r') s->mode = 'r';
+        if (*p == 'w' || *p == 'a') s->mode = 'w';
+        if (*p >= '0' && *p <= '9') {
+	    level = *p - '0';
+	} else if (*p == 'f') {
+	  strategy = Z_FILTERED;
+	} else if (*p == 'h') {
+	  strategy = Z_HUFFMAN_ONLY;
+	} else {
+	    *m++ = *p; /* copy the mode */
+	}
+    } while (*p++ && m != fmode + sizeof(fmode));
+    if (s->mode == '\0') return destroy(s), (gzFile)Z_NULL;
+    
+    if (s->mode == 'w') {
+#ifdef NO_DEFLATE
+        err = Z_STREAM_ERROR;
+#else
+        err = deflateInit2(&(s->stream), level,
+                           Z_DEFLATED, -MAX_WBITS, DEF_MEM_LEVEL, strategy);
+        /* windowBits is passed < 0 to suppress zlib header */
+
+        s->stream.next_out = s->outbuf = (Byte*)ALLOC(Z_BUFSIZE);
+#endif
+        if (err != Z_OK || s->outbuf == Z_NULL) {
+            return destroy(s), (gzFile)Z_NULL;
+        }
+    } else {
+        s->stream.next_in  = s->inbuf = (Byte*)ALLOC(Z_BUFSIZE);
+
+        err = inflateInit2(&(s->stream), -MAX_WBITS);
+        /* windowBits is passed < 0 to tell that there is no zlib header.
+         * Note that in this case inflate *requires* an extra "dummy" byte
+         * after the compressed stream in order to complete decompression and
+         * return Z_STREAM_END. Here the gzip CRC32 ensures that 4 bytes are
+         * present after the compressed stream.
+         */
+        if (err != Z_OK || s->inbuf == Z_NULL) {
+            return destroy(s), (gzFile)Z_NULL;
+        }
+    }
+    s->stream.avail_out = Z_BUFSIZE;
+
+    errno = 0;
+    s->file = fd < 0 ? F_OPEN(path, fmode) : (FILE*)fdopen(fd, fmode);
+
+    if (s->file == NULL) {
+        return destroy(s), (gzFile)Z_NULL;
+    }
+    if (s->mode == 'w') {
+        /* Write a very simple .gz header:
+         */
+        fprintf(s->file, "%c%c%c%c%c%c%c%c%c%c", gz_magic[0], gz_magic[1],
+             Z_DEFLATED, 0 /*flags*/, 0,0,0,0 /*time*/, 0 /*xflags*/, OS_CODE);
+	s->startpos = 10L;
+	/* We use 10L instead of ftell(s->file) to because ftell causes an
+         * fflush on some systems. This version of the library doesn't use
+         * startpos anyway in write mode, so this initialization is not
+         * necessary.
+         */
+    } else {
+	check_header(s); /* skip the .gz header */
+	s->startpos = (ftell(s->file) - s->stream.avail_in);
+    }
+    
+    return (gzFile)s;
+}
+
+/* ===========================================================================
+     Opens a gzip (.gz) file for reading or writing.
+*/
+gzFile ZEXPORT gzopen (path, mode)
+    const char *path;
+    const char *mode;
+{
+    return gz_open (path, mode, -1);
+}
+
+/* ===========================================================================
+     Associate a gzFile with the file descriptor fd. fd is not dup'ed here
+   to mimic the behavio(u)r of fdopen.
+*/
+gzFile ZEXPORT gzdopen (fd, mode)
+    int fd;
+    const char *mode;
+{
+    char name[20];
+
+    if (fd < 0) return (gzFile)Z_NULL;
+    sprintf(name, "<fd:%d>", fd); /* for debugging */
+
+    return gz_open (name, mode, fd);
+}
+
+/* ===========================================================================
+ * Update the compression level and strategy
+ */
+int ZEXPORT gzsetparams (file, level, strategy)
+    gzFile file;
+    int level;
+    int strategy;
+{
+    gz_stream *s = (gz_stream*)file;
+
+    if (s == NULL || s->mode != 'w') return Z_STREAM_ERROR;
+
+    /* Make room to allow flushing */
+    if (s->stream.avail_out == 0) {
+
+	s->stream.next_out = s->outbuf;
+	if (fwrite(s->outbuf, 1, Z_BUFSIZE, s->file) != Z_BUFSIZE) {
+	    s->z_err = Z_ERRNO;
+	}
+	s->stream.avail_out = Z_BUFSIZE;
+    }
+
+    return deflateParams (&(s->stream), level, strategy);
+}
+
+/* ===========================================================================
+     Read a byte from a gz_stream; update next_in and avail_in. Return EOF
+   for end of file.
+   IN assertion: the stream s has been sucessfully opened for reading.
+*/
+local int get_byte(s)
+    gz_stream *s;
+{
+    if (s->z_eof) return EOF;
+    if (s->stream.avail_in == 0) {
+	errno = 0;
+	s->stream.avail_in = fread(s->inbuf, 1, Z_BUFSIZE, s->file);
+	if (s->stream.avail_in == 0) {
+	    s->z_eof = 1;
+	    if (ferror(s->file)) s->z_err = Z_ERRNO;
+	    return EOF;
+	}
+	s->stream.next_in = s->inbuf;
+    }
+    s->stream.avail_in--;
+    return *(s->stream.next_in)++;
+}
+
+/* ===========================================================================
+      Check the gzip header of a gz_stream opened for reading. Set the stream
+    mode to transparent if the gzip magic header is not present; set s->err
+    to Z_DATA_ERROR if the magic header is present but the rest of the header
+    is incorrect.
+    IN assertion: the stream s has already been created sucessfully;
+       s->stream.avail_in is zero for the first time, but may be non-zero
+       for concatenated .gz files.
+*/
+local void check_header(s)
+    gz_stream *s;
+{
+    int method; /* method byte */
+    int flags;  /* flags byte */
+    uInt len;
+    int c;
+
+    /* Check the gzip magic header */
+    for (len = 0; len < 2; len++) {
+	c = get_byte(s);
+	if (c != gz_magic[len]) {
+	    if (len != 0) s->stream.avail_in++, s->stream.next_in--;
+	    if (c != EOF) {
+		s->stream.avail_in++, s->stream.next_in--;
+		s->transparent = 1;
+	    }
+	    s->z_err = s->stream.avail_in != 0 ? Z_OK : Z_STREAM_END;
+	    return;
+	}
+    }
+    method = get_byte(s);
+    flags = get_byte(s);
+    if (method != Z_DEFLATED || (flags & RESERVED) != 0) {
+	s->z_err = Z_DATA_ERROR;
+	return;
+    }
+
+    /* Discard time, xflags and OS code: */
+    for (len = 0; len < 6; len++) (void)get_byte(s);
+
+    if ((flags & EXTRA_FIELD) != 0) { /* skip the extra field */
+	len  =  (uInt)get_byte(s);
+	len += ((uInt)get_byte(s))<<8;
+	/* len is garbage if EOF but the loop below will quit anyway */
+	while (len-- != 0 && get_byte(s) != EOF) ;
+    }
+    if ((flags & ORIG_NAME) != 0) { /* skip the original file name */
+	while ((c = get_byte(s)) != 0 && c != EOF) ;
+    }
+    if ((flags & COMMENT) != 0) {   /* skip the .gz file comment */
+	while ((c = get_byte(s)) != 0 && c != EOF) ;
+    }
+    if ((flags & HEAD_CRC) != 0) {  /* skip the header crc */
+	for (len = 0; len < 2; len++) (void)get_byte(s);
+    }
+    s->z_err = s->z_eof ? Z_DATA_ERROR : Z_OK;
+}
+
+ /* ===========================================================================
+ * Cleanup then free the given gz_stream. Return a zlib error code.
+   Try freeing in the reverse order of allocations.
+ */
+local int destroy (s)
+    gz_stream *s;
+{
+    int err = Z_OK;
+
+    if (!s) return Z_STREAM_ERROR;
+
+    TRYFREE(s->msg);
+
+    if (s->stream.state != NULL) {
+	if (s->mode == 'w') {
+#ifdef NO_DEFLATE
+	    err = Z_STREAM_ERROR;
+#else
+	    err = deflateEnd(&(s->stream));
+#endif
+	} else if (s->mode == 'r') {
+	    err = inflateEnd(&(s->stream));
+	}
+    }
+    if (s->file != NULL && fclose(s->file)) {
+#ifdef ESPIPE
+	if (errno != ESPIPE) /* fclose is broken for pipes in HP/UX */
+#endif
+	    err = Z_ERRNO;
+    }
+    if (s->z_err < 0) err = s->z_err;
+
+    TRYFREE(s->inbuf);
+    TRYFREE(s->outbuf);
+    TRYFREE(s->path);
+    TRYFREE(s);
+    return err;
+}
+
+/* ===========================================================================
+     Reads the given number of uncompressed bytes from the compressed file.
+   gzread returns the number of bytes actually read (0 for end of file).
+*/
+int ZEXPORT gzread (file, buf, len)
+    gzFile file;
+    voidp buf;
+    unsigned len;
+{
+    gz_stream *s = (gz_stream*)file;
+    Bytef *start = (Bytef*)buf; /* starting point for crc computation */
+    Byte  *next_out; /* == stream.next_out but not forced far (for MSDOS) */
+
+    if (s == NULL || s->mode != 'r') return Z_STREAM_ERROR;
+
+    if (s->z_err == Z_DATA_ERROR || s->z_err == Z_ERRNO) return -1;
+    if (s->z_err == Z_STREAM_END) return 0;  /* EOF */
+
+    next_out = (Byte*)buf;
+    s->stream.next_out = (Bytef*)buf;
+    s->stream.avail_out = len;
+
+    while (s->stream.avail_out != 0) {
+
+	if (s->transparent) {
+	    /* Copy first the lookahead bytes: */
+	    uInt n = s->stream.avail_in;
+	    if (n > s->stream.avail_out) n = s->stream.avail_out;
+	    if (n > 0) {
+		zmemcpy(s->stream.next_out, s->stream.next_in, n);
+		next_out += n;
+		s->stream.next_out = next_out;
+		s->stream.next_in   += n;
+		s->stream.avail_out -= n;
+		s->stream.avail_in  -= n;
+	    }
+	    if (s->stream.avail_out > 0) {
+		s->stream.avail_out -= fread(next_out, 1, s->stream.avail_out,
+					     s->file);
+	    }
+	    len -= s->stream.avail_out;
+	    s->stream.total_in  += (uLong)len;
+	    s->stream.total_out += (uLong)len;
+            if (len == 0) s->z_eof = 1;
+	    return (int)len;
+	}
+        if (s->stream.avail_in == 0 && !s->z_eof) {
+
+            errno = 0;
+            s->stream.avail_in = fread(s->inbuf, 1, Z_BUFSIZE, s->file);
+            if (s->stream.avail_in == 0) {
+                s->z_eof = 1;
+		if (ferror(s->file)) {
+		    s->z_err = Z_ERRNO;
+		    break;
+		}
+            }
+            s->stream.next_in = s->inbuf;
+        }
+        s->z_err = inflate(&(s->stream), Z_NO_FLUSH);
+
+	if (s->z_err == Z_STREAM_END) {
+	    /* Check CRC and original size */
+	    s->crc = crc32(s->crc, start, (uInt)(s->stream.next_out - start));
+	    start = s->stream.next_out;
+
+	    if (getLong(s) != s->crc) {
+		s->z_err = Z_DATA_ERROR;
+	    } else {
+	        (void)getLong(s);
+                /* The uncompressed length returned by above getlong() may
+                 * be different from s->stream.total_out) in case of
+		 * concatenated .gz files. Check for such files:
+		 */
+		check_header(s);
+		if (s->z_err == Z_OK) {
+		    uLong total_in = s->stream.total_in;
+		    uLong total_out = s->stream.total_out;
+
+		    inflateReset(&(s->stream));
+		    s->stream.total_in = total_in;
+		    s->stream.total_out = total_out;
+		    s->crc = crc32(0L, Z_NULL, 0);
+		}
+	    }
+	}
+	if (s->z_err != Z_OK || s->z_eof) break;
+    }
+    s->crc = crc32(s->crc, start, (uInt)(s->stream.next_out - start));
+
+    return (int)(len - s->stream.avail_out);
+}
+
+
+/* ===========================================================================
+      Reads one byte from the compressed file. gzgetc returns this byte
+   or -1 in case of end of file or error.
+*/
+int ZEXPORT gzgetc(file)
+    gzFile file;
+{
+    unsigned char c;
+
+    return gzread(file, &c, 1) == 1 ? c : -1;
+}
+
+
+/* ===========================================================================
+      Reads bytes from the compressed file until len-1 characters are
+   read, or a newline character is read and transferred to buf, or an
+   end-of-file condition is encountered.  The string is then terminated
+   with a null character.
+      gzgets returns buf, or Z_NULL in case of error.
+
+      The current implementation is not optimized at all.
+*/
+char * ZEXPORT gzgets(file, buf, len)
+    gzFile file;
+    char *buf;
+    int len;
+{
+    char *b = buf;
+    if (buf == Z_NULL || len <= 0) return Z_NULL;
+
+    while (--len > 0 && gzread(file, buf, 1) == 1 && *buf++ != '\n') ;
+    *buf = '\0';
+    return b == buf && len > 0 ? Z_NULL : b;
+}
+
+
+#ifndef NO_DEFLATE
+/* ===========================================================================
+     Writes the given number of uncompressed bytes into the compressed file.
+   gzwrite returns the number of bytes actually written (0 in case of error).
+*/
+int ZEXPORT gzwrite (file, buf, len)
+    gzFile file;
+    const voidp buf;
+    unsigned len;
+{
+    gz_stream *s = (gz_stream*)file;
+
+    if (s == NULL || s->mode != 'w') return Z_STREAM_ERROR;
+
+    s->stream.next_in = (Bytef*)buf;
+    s->stream.avail_in = len;
+
+    while (s->stream.avail_in != 0) {
+
+        if (s->stream.avail_out == 0) {
+
+            s->stream.next_out = s->outbuf;
+            if (fwrite(s->outbuf, 1, Z_BUFSIZE, s->file) != Z_BUFSIZE) {
+                s->z_err = Z_ERRNO;
+                break;
+            }
+            s->stream.avail_out = Z_BUFSIZE;
+        }
+        s->z_err = deflate(&(s->stream), Z_NO_FLUSH);
+        if (s->z_err != Z_OK) break;
+    }
+    s->crc = crc32(s->crc, (const Bytef *)buf, len);
+
+    return (int)(len - s->stream.avail_in);
+}
+
+/* ===========================================================================
+     Converts, formats, and writes the args to the compressed file under
+   control of the format string, as in fprintf. gzprintf returns the number of
+   uncompressed bytes actually written (0 in case of error).
+*/
+#ifdef STDC
+#include <stdarg.h>
+
+int ZEXPORTVA gzprintf (gzFile file, const char *format, /* args */ ...)
+{
+    char buf[Z_PRINTF_BUFSIZE];
+    va_list va;
+    int len;
+
+    va_start(va, format);
+#ifdef HAS_vsnprintf
+    (void)vsnprintf(buf, sizeof(buf), format, va);
+#else
+    (void)vsprintf(buf, format, va);
+#endif
+    va_end(va);
+    len = strlen(buf); /* some *sprintf don't return the nb of bytes written */
+    if (len <= 0) return 0;
+
+    return gzwrite(file, buf, (unsigned)len);
+}
+#else /* not ANSI C */
+
+int ZEXPORTVA gzprintf (file, format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10,
+	               a11, a12, a13, a14, a15, a16, a17, a18, a19, a20)
+    gzFile file;
+    const char *format;
+    int a1, a2, a3, a4, a5, a6, a7, a8, a9, a10,
+	a11, a12, a13, a14, a15, a16, a17, a18, a19, a20;
+{
+    char buf[Z_PRINTF_BUFSIZE];
+    int len;
+
+#ifdef HAS_snprintf
+    snprintf(buf, sizeof(buf), format, a1, a2, a3, a4, a5, a6, a7, a8,
+	     a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20);
+#else
+    sprintf(buf, format, a1, a2, a3, a4, a5, a6, a7, a8,
+	    a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20);
+#endif
+    len = strlen(buf); /* old sprintf doesn't return the nb of bytes written */
+    if (len <= 0) return 0;
+
+    return gzwrite(file, buf, len);
+}
+#endif
+
+/* ===========================================================================
+      Writes c, converted to an unsigned char, into the compressed file.
+   gzputc returns the value that was written, or -1 in case of error.
+*/
+int ZEXPORT gzputc(file, c)
+    gzFile file;
+    int c;
+{
+    unsigned char cc = (unsigned char) c; /* required for big endian systems */
+
+    return gzwrite(file, &cc, 1) == 1 ? (int)cc : -1;
+}
+
+
+/* ===========================================================================
+      Writes the given null-terminated string to the compressed file, excluding
+   the terminating null character.
+      gzputs returns the number of characters written, or -1 in case of error.
+*/
+int ZEXPORT gzputs(file, s)
+    gzFile file;
+    const char *s;
+{
+    return gzwrite(file, (char*)s, (unsigned)strlen(s));
+}
+
+
+/* ===========================================================================
+     Flushes all pending output into the compressed file. The parameter
+   flush is as in the deflate() function.
+*/
+local int do_flush (file, flush)
+    gzFile file;
+    int flush;
+{
+    uInt len;
+    int done = 0;
+    gz_stream *s = (gz_stream*)file;
+
+    if (s == NULL || s->mode != 'w') return Z_STREAM_ERROR;
+
+    s->stream.avail_in = 0; /* should be zero already anyway */
+
+    for (;;) {
+        len = Z_BUFSIZE - s->stream.avail_out;
+
+        if (len != 0) {
+            if ((uInt)fwrite(s->outbuf, 1, len, s->file) != len) {
+                s->z_err = Z_ERRNO;
+                return Z_ERRNO;
+            }
+            s->stream.next_out = s->outbuf;
+            s->stream.avail_out = Z_BUFSIZE;
+        }
+        if (done) break;
+        s->z_err = deflate(&(s->stream), flush);
+
+	/* Ignore the second of two consecutive flushes: */
+	if (len == 0 && s->z_err == Z_BUF_ERROR) s->z_err = Z_OK;
+
+        /* deflate has finished flushing only when it hasn't used up
+         * all the available space in the output buffer: 
+         */
+        done = (s->stream.avail_out != 0 || s->z_err == Z_STREAM_END);
+ 
+        if (s->z_err != Z_OK && s->z_err != Z_STREAM_END) break;
+    }
+    return  s->z_err == Z_STREAM_END ? Z_OK : s->z_err;
+}
+
+int ZEXPORT gzflush (file, flush)
+     gzFile file;
+     int flush;
+{
+    gz_stream *s = (gz_stream*)file;
+    int err = do_flush (file, flush);
+
+    if (err) return err;
+    fflush(s->file);
+    return  s->z_err == Z_STREAM_END ? Z_OK : s->z_err;
+}
+#endif /* NO_DEFLATE */
+
+/* ===========================================================================
+      Sets the starting position for the next gzread or gzwrite on the given
+   compressed file. The offset represents a number of bytes in the
+      gzseek returns the resulting offset location as measured in bytes from
+   the beginning of the uncompressed stream, or -1 in case of error.
+      SEEK_END is not implemented, returns error.
+      In this version of the library, gzseek can be extremely slow.
+*/
+z_off_t ZEXPORT gzseek (file, offset, whence)
+    gzFile file;
+    z_off_t offset;
+    int whence;
+{
+    gz_stream *s = (gz_stream*)file;
+
+    if (s == NULL || whence == SEEK_END ||
+	s->z_err == Z_ERRNO || s->z_err == Z_DATA_ERROR) {
+	return -1L;
+    }
+    
+    if (s->mode == 'w') {
+#ifdef NO_DEFLATE
+	return -1L;
+#else
+	if (whence == SEEK_SET) {
+	    offset -= s->stream.total_in;
+	}
+	if (offset < 0) return -1L;
+
+	/* At this point, offset is the number of zero bytes to write. */
+	if (s->inbuf == Z_NULL) {
+	    s->inbuf = (Byte*)ALLOC(Z_BUFSIZE); /* for seeking */
+	    zmemzero(s->inbuf, Z_BUFSIZE);
+	}
+	while (offset > 0)  {
+	    uInt size = Z_BUFSIZE;
+	    if (offset < Z_BUFSIZE) size = (uInt)offset;
+
+	    size = gzwrite(file, s->inbuf, size);
+	    if (size == 0) return -1L;
+
+	    offset -= size;
+	}
+	return (z_off_t)s->stream.total_in;
+#endif
+    }
+    /* Rest of function is for reading only */
+
+    /* compute absolute position */
+    if (whence == SEEK_CUR) {
+	offset += s->stream.total_out;
+    }
+    if (offset < 0) return -1L;
+
+    if (s->transparent) {
+	/* map to fseek */
+	s->stream.avail_in = 0;
+	s->stream.next_in = s->inbuf;
+        if (fseek(s->file, offset, SEEK_SET) < 0) return -1L;
+
+	s->stream.total_in = s->stream.total_out = (uLong)offset;
+	return offset;
+    }
+
+    /* For a negative seek, rewind and use positive seek */
+    if ((uLong)offset >= s->stream.total_out) {
+	offset -= s->stream.total_out;
+    } else if (gzrewind(file) < 0) {
+	return -1L;
+    }
+    /* offset is now the number of bytes to skip. */
+
+    if (offset != 0 && s->outbuf == Z_NULL) {
+	s->outbuf = (Byte*)ALLOC(Z_BUFSIZE);
+    }
+    while (offset > 0)  {
+	int size = Z_BUFSIZE;
+	if (offset < Z_BUFSIZE) size = (int)offset;
+
+	size = gzread(file, s->outbuf, (uInt)size);
+	if (size <= 0) return -1L;
+	offset -= size;
+    }
+    return (z_off_t)s->stream.total_out;
+}
+
+/* ===========================================================================
+     Rewinds input file. 
+*/
+int ZEXPORT gzrewind (file)
+    gzFile file;
+{
+    gz_stream *s = (gz_stream*)file;
+    
+    if (s == NULL || s->mode != 'r') return -1;
+
+    s->z_err = Z_OK;
+    s->z_eof = 0;
+    s->stream.avail_in = 0;
+    s->stream.next_in = s->inbuf;
+    s->crc = crc32(0L, Z_NULL, 0);
+	
+    if (s->startpos == 0) { /* not a compressed file */
+	rewind(s->file);
+	return 0;
+    }
+
+    (void) inflateReset(&s->stream);
+    return fseek(s->file, s->startpos, SEEK_SET);
+}
+
+/* ===========================================================================
+     Returns the starting position for the next gzread or gzwrite on the
+   given compressed file. This position represents a number of bytes in the
+   uncompressed data stream.
+*/
+z_off_t ZEXPORT gztell (file)
+    gzFile file;
+{
+    return gzseek(file, 0L, SEEK_CUR);
+}
+
+/* ===========================================================================
+     Returns 1 when EOF has previously been detected reading the given
+   input stream, otherwise zero.
+*/
+int ZEXPORT gzeof (file)
+    gzFile file;
+{
+    gz_stream *s = (gz_stream*)file;
+    
+    return (s == NULL || s->mode != 'r') ? 0 : s->z_eof;
+}
+
+/* ===========================================================================
+   Outputs a long in LSB order to the given file
+*/
+local void putLong (file, x)
+    FILE *file;
+    uLong x;
+{
+    int n;
+    for (n = 0; n < 4; n++) {
+        fputc((int)(x & 0xff), file);
+        x >>= 8;
+    }
+}
+
+/* ===========================================================================
+   Reads a long in LSB order from the given gz_stream. Sets z_err in case
+   of error.
+*/
+local uLong getLong (s)
+    gz_stream *s;
+{
+    uLong x = (uLong)get_byte(s);
+    int c;
+
+    x += ((uLong)get_byte(s))<<8;
+    x += ((uLong)get_byte(s))<<16;
+    c = get_byte(s);
+    if (c == EOF) s->z_err = Z_DATA_ERROR;
+    x += ((uLong)c)<<24;
+    return x;
+}
+
+/* ===========================================================================
+     Flushes all pending output if necessary, closes the compressed file
+   and deallocates all the (de)compression state.
+*/
+int ZEXPORT gzclose (file)
+    gzFile file;
+{
+    int err;
+    gz_stream *s = (gz_stream*)file;
+
+    if (s == NULL) return Z_STREAM_ERROR;
+
+    if (s->mode == 'w') {
+#ifdef NO_DEFLATE
+	return Z_STREAM_ERROR;
+#else
+        err = do_flush (file, Z_FINISH);
+        if (err != Z_OK) return destroy((gz_stream*)file);
+
+        putLong (s->file, s->crc);
+        putLong (s->file, s->stream.total_in);
+#endif
+    }
+    return destroy((gz_stream*)file);
+}
+
+/* ===========================================================================
+     Returns the error message for the last error which occured on the
+   given compressed file. errnum is set to zlib error number. If an
+   error occured in the file system and not in the compression library,
+   errnum is set to Z_ERRNO and the application may consult errno
+   to get the exact error code.
+*/
+const char*  ZEXPORT gzerror (file, errnum)
+    gzFile file;
+    int *errnum;
+{
+    char *m;
+    gz_stream *s = (gz_stream*)file;
+
+    if (s == NULL) {
+        *errnum = Z_STREAM_ERROR;
+        return (const char*)ERR_MSG(Z_STREAM_ERROR);
+    }
+    *errnum = s->z_err;
+    if (*errnum == Z_OK) return (const char*)"";
+
+    m =  (char*)(*errnum == Z_ERRNO ? zstrerror(errno) : s->stream.msg);
+
+    if (m == NULL || *m == '\0') m = (char*)ERR_MSG(s->z_err);
+
+    TRYFREE(s->msg);
+    s->msg = (char*)ALLOC(strlen(s->path) + strlen(m) + 3);
+    strcpy(s->msg, s->path);
+    strcat(s->msg, ": ");
+    strcat(s->msg, m);
+    return (const char*)s->msg;
+}
diff --git a/src/unix/contrib/cutzlib-1.1.4/infblock.c b/src/unix/contrib/cutzlib-1.1.4/infblock.c
new file mode 100644
index 0000000..dd7a6d4
--- /dev/null
+++ b/src/unix/contrib/cutzlib-1.1.4/infblock.c
@@ -0,0 +1,403 @@
+/* infblock.c -- interpret and process block types to last block
+ * Copyright (C) 1995-2002 Mark Adler
+ * For conditions of distribution and use, see copyright notice in zlib.h 
+ */
+
+#include "zutil.h"
+#include "infblock.h"
+#include "inftrees.h"
+#include "infcodes.h"
+#include "infutil.h"
+
+struct inflate_codes_state {int dummy;}; /* for buggy compilers */
+
+/* simplify the use of the inflate_huft type with some defines */
+#define exop word.what.Exop
+#define bits word.what.Bits
+
+/* Table for deflate from PKZIP's appnote.txt. */
+local const uInt border[] = { /* Order of the bit length code lengths */
+        16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};
+
+/*
+   Notes beyond the 1.93a appnote.txt:
+
+   1. Distance pointers never point before the beginning of the output
+      stream.
+   2. Distance pointers can point back across blocks, up to 32k away.
+   3. There is an implied maximum of 7 bits for the bit length table and
+      15 bits for the actual data.
+   4. If only one code exists, then it is encoded using one bit.  (Zero
+      would be more efficient, but perhaps a little confusing.)  If two
+      codes exist, they are coded using one bit each (0 and 1).
+   5. There is no way of sending zero distance codes--a dummy must be
+      sent if there are none.  (History: a pre 2.0 version of PKZIP would
+      store blocks with no distance codes, but this was discovered to be
+      too harsh a criterion.)  Valid only for 1.93a.  2.04c does allow
+      zero distance codes, which is sent as one code of zero bits in
+      length.
+   6. There are up to 286 literal/length codes.  Code 256 represents the
+      end-of-block.  Note however that the static length tree defines
+      288 codes just to fill out the Huffman codes.  Codes 286 and 287
+      cannot be used though, since there is no length base or extra bits
+      defined for them.  Similarily, there are up to 30 distance codes.
+      However, static trees define 32 codes (all 5 bits) to fill out the
+      Huffman codes, but the last two had better not show up in the data.
+   7. Unzip can check dynamic Huffman blocks for complete code sets.
+      The exception is that a single code would not be complete (see #4).
+   8. The five bits following the block type is really the number of
+      literal codes sent minus 257.
+   9. Length codes 8,16,16 are interpreted as 13 length codes of 8 bits
+      (1+6+6).  Therefore, to output three times the length, you output
+      three codes (1+1+1), whereas to output four times the same length,
+      you only need two codes (1+3).  Hmm.
+  10. In the tree reconstruction algorithm, Code = Code + Increment
+      only if BitLength(i) is not zero.  (Pretty obvious.)
+  11. Correction: 4 Bits: # of Bit Length codes - 4     (4 - 19)
+  12. Note: length code 284 can represent 227-258, but length code 285
+      really is 258.  The last length deserves its own, short code
+      since it gets used a lot in very redundant files.  The length
+      258 is special since 258 - 3 (the min match length) is 255.
+  13. The literal/length and distance code bit lengths are read as a
+      single stream of lengths.  It is possible (and advantageous) for
+      a repeat code (16, 17, or 18) to go across the boundary between
+      the two sets of lengths.
+ */
+
+
+void inflate_blocks_reset(s, z, c)
+inflate_blocks_statef *s;
+z_streamp z;
+uLongf *c;
+{
+  if (c != Z_NULL)
+    *c = s->check;
+  if (s->mode == BTREE || s->mode == DTREE)
+    ZFREE(z, s->sub.trees.blens);
+  if (s->mode == CODES)
+    inflate_codes_free(s->sub.decode.codes, z);
+  s->mode = TYPE;
+  s->bitk = 0;
+  s->bitb = 0;
+  s->read = s->write = s->window;
+  if (s->checkfn != Z_NULL)
+    z->adler = s->check = (*s->checkfn)(0L, (const Bytef *)Z_NULL, 0);
+  Tracev((stderr, "inflate:   blocks reset\n"));
+}
+
+
+inflate_blocks_statef *inflate_blocks_new(z, c, w)
+z_streamp z;
+check_func c;
+uInt w;
+{
+  inflate_blocks_statef *s;
+
+  if ((s = (inflate_blocks_statef *)ZALLOC
+       (z,1,sizeof(struct inflate_blocks_state))) == Z_NULL)
+    return s;
+  if ((s->hufts =
+       (inflate_huft *)ZALLOC(z, sizeof(inflate_huft), MANY)) == Z_NULL)
+  {
+    ZFREE(z, s);
+    return Z_NULL;
+  }
+  if ((s->window = (Bytef *)ZALLOC(z, 1, w)) == Z_NULL)
+  {
+    ZFREE(z, s->hufts);
+    ZFREE(z, s);
+    return Z_NULL;
+  }
+  s->end = s->window + w;
+  s->checkfn = c;
+  s->mode = TYPE;
+  Tracev((stderr, "inflate:   blocks allocated\n"));
+  inflate_blocks_reset(s, z, Z_NULL);
+  return s;
+}
+
+
+int inflate_blocks(s, z, r)
+inflate_blocks_statef *s;
+z_streamp z;
+int r;
+{
+  uInt t;               /* temporary storage */
+  uLong b;              /* bit buffer */
+  uInt k;               /* bits in bit buffer */
+  Bytef *p;             /* input data pointer */
+  uInt n;               /* bytes available there */
+  Bytef *q;             /* output window write pointer */
+  uInt m;               /* bytes to end of window or read pointer */
+
+  /* copy input/output information to locals (UPDATE macro restores) */
+  LOAD
+
+  /* process input based on current state */
+  while (1) switch (s->mode)
+  {
+    case TYPE:
+      NEEDBITS(3)
+      t = (uInt)b & 7;
+      s->last = t & 1;
+      switch (t >> 1)
+      {
+        case 0:                         /* stored */
+          Tracev((stderr, "inflate:     stored block%s\n",
+                 s->last ? " (last)" : ""));
+          DUMPBITS(3)
+          t = k & 7;                    /* go to byte boundary */
+          DUMPBITS(t)
+          s->mode = LENS;               /* get length of stored block */
+          break;
+        case 1:                         /* fixed */
+          Tracev((stderr, "inflate:     fixed codes block%s\n",
+                 s->last ? " (last)" : ""));
+          {
+            uInt bl, bd;
+            inflate_huft *tl, *td;
+
+            inflate_trees_fixed(&bl, &bd, &tl, &td, z);
+            s->sub.decode.codes = inflate_codes_new(bl, bd, tl, td, z);
+            if (s->sub.decode.codes == Z_NULL)
+            {
+              r = Z_MEM_ERROR;
+              LEAVE
+            }
+          }
+          DUMPBITS(3)
+          s->mode = CODES;
+          break;
+        case 2:                         /* dynamic */
+          Tracev((stderr, "inflate:     dynamic codes block%s\n",
+                 s->last ? " (last)" : ""));
+          DUMPBITS(3)
+          s->mode = TABLE;
+          break;
+        case 3:                         /* illegal */
+          DUMPBITS(3)
+          s->mode = BAD;
+          z->msg = (char*)"invalid block type";
+          r = Z_DATA_ERROR;
+          LEAVE
+      }
+      break;
+    case LENS:
+      NEEDBITS(32)
+      if ((((~b) >> 16) & 0xffff) != (b & 0xffff))
+      {
+        s->mode = BAD;
+        z->msg = (char*)"invalid stored block lengths";
+        r = Z_DATA_ERROR;
+        LEAVE
+      }
+      s->sub.left = (uInt)b & 0xffff;
+      b = k = 0;                      /* dump bits */
+      Tracev((stderr, "inflate:       stored length %u\n", s->sub.left));
+      s->mode = s->sub.left ? STORED : (s->last ? DRY : TYPE);
+      break;
+    case STORED:
+      if (n == 0)
+        LEAVE
+      NEEDOUT
+      t = s->sub.left;
+      if (t > n) t = n;
+      if (t > m) t = m;
+      zmemcpy(q, p, t);
+      p += t;  n -= t;
+      q += t;  m -= t;
+      if ((s->sub.left -= t) != 0)
+        break;
+      Tracev((stderr, "inflate:       stored end, %lu total out\n",
+              z->total_out + (q >= s->read ? q - s->read :
+              (s->end - s->read) + (q - s->window))));
+      s->mode = s->last ? DRY : TYPE;
+      break;
+    case TABLE:
+      NEEDBITS(14)
+      s->sub.trees.table = t = (uInt)b & 0x3fff;
+#ifndef PKZIP_BUG_WORKAROUND
+      if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)
+      {
+        s->mode = BAD;
+        z->msg = (char*)"too many length or distance symbols";
+        r = Z_DATA_ERROR;
+        LEAVE
+      }
+#endif
+      t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);
+      if ((s->sub.trees.blens = (uIntf*)ZALLOC(z, t, sizeof(uInt))) == Z_NULL)
+      {
+        r = Z_MEM_ERROR;
+        LEAVE
+      }
+      DUMPBITS(14)
+      s->sub.trees.index = 0;
+      Tracev((stderr, "inflate:       table sizes ok\n"));
+      s->mode = BTREE;
+    case BTREE:
+      while (s->sub.trees.index < 4 + (s->sub.trees.table >> 10))
+      {
+        NEEDBITS(3)
+        s->sub.trees.blens[border[s->sub.trees.index++]] = (uInt)b & 7;
+        DUMPBITS(3)
+      }
+      while (s->sub.trees.index < 19)
+        s->sub.trees.blens[border[s->sub.trees.index++]] = 0;
+      s->sub.trees.bb = 7;
+      t = inflate_trees_bits(s->sub.trees.blens, &s->sub.trees.bb,
+                             &s->sub.trees.tb, s->hufts, z);
+      if (t != Z_OK)
+      {
+        r = t;
+        if (r == Z_DATA_ERROR)
+        {
+          ZFREE(z, s->sub.trees.blens);
+          s->mode = BAD;
+        }
+        LEAVE
+      }
+      s->sub.trees.index = 0;
+      Tracev((stderr, "inflate:       bits tree ok\n"));
+      s->mode = DTREE;
+    case DTREE:
+      while (t = s->sub.trees.table,
+             s->sub.trees.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))
+      {
+        inflate_huft *h;
+        uInt i, j, c;
+
+        t = s->sub.trees.bb;
+        NEEDBITS(t)
+        h = s->sub.trees.tb + ((uInt)b & inflate_mask[t]);
+        t = h->bits;
+        c = h->base;
+        if (c < 16)
+        {
+          DUMPBITS(t)
+          s->sub.trees.blens[s->sub.trees.index++] = c;
+        }
+        else /* c == 16..18 */
+        {
+          i = c == 18 ? 7 : c - 14;
+          j = c == 18 ? 11 : 3;
+          NEEDBITS(t + i)
+          DUMPBITS(t)
+          j += (uInt)b & inflate_mask[i];
+          DUMPBITS(i)
+          i = s->sub.trees.index;
+          t = s->sub.trees.table;
+          if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) ||
+              (c == 16 && i < 1))
+          {
+            ZFREE(z, s->sub.trees.blens);
+            s->mode = BAD;
+            z->msg = (char*)"invalid bit length repeat";
+            r = Z_DATA_ERROR;
+            LEAVE
+          }
+          c = c == 16 ? s->sub.trees.blens[i - 1] : 0;
+          do {
+            s->sub.trees.blens[i++] = c;
+          } while (--j);
+          s->sub.trees.index = i;
+        }
+      }
+      s->sub.trees.tb = Z_NULL;
+      {
+        uInt bl, bd;
+        inflate_huft *tl, *td;
+        inflate_codes_statef *c;
+
+        bl = 9;         /* must be <= 9 for lookahead assumptions */
+        bd = 6;         /* must be <= 9 for lookahead assumptions */
+        t = s->sub.trees.table;
+        t = inflate_trees_dynamic(257 + (t & 0x1f), 1 + ((t >> 5) & 0x1f),
+                                  s->sub.trees.blens, &bl, &bd, &tl, &td,
+                                  s->hufts, z);
+        if (t != Z_OK)
+        {
+          if (t == (uInt)Z_DATA_ERROR)
+          {
+            ZFREE(z, s->sub.trees.blens);
+            s->mode = BAD;
+          }
+          r = t;
+          LEAVE
+        }
+        Tracev((stderr, "inflate:       trees ok\n"));
+        if ((c = inflate_codes_new(bl, bd, tl, td, z)) == Z_NULL)
+        {
+          r = Z_MEM_ERROR;
+          LEAVE
+        }
+        s->sub.decode.codes = c;
+      }
+      ZFREE(z, s->sub.trees.blens);
+      s->mode = CODES;
+    case CODES:
+      UPDATE
+      if ((r = inflate_codes(s, z, r)) != Z_STREAM_END)
+        return inflate_flush(s, z, r);
+      r = Z_OK;
+      inflate_codes_free(s->sub.decode.codes, z);
+      LOAD
+      Tracev((stderr, "inflate:       codes end, %lu total out\n",
+              z->total_out + (q >= s->read ? q - s->read :
+              (s->end - s->read) + (q - s->window))));
+      if (!s->last)
+      {
+        s->mode = TYPE;
+        break;
+      }
+      s->mode = DRY;
+    case DRY:
+      FLUSH
+      if (s->read != s->write)
+        LEAVE
+      s->mode = DONE;
+    case DONE:
+      r = Z_STREAM_END;
+      LEAVE
+    case BAD:
+      r = Z_DATA_ERROR;
+      LEAVE
+    default:
+      r = Z_STREAM_ERROR;
+      LEAVE
+  }
+}
+
+
+int inflate_blocks_free(s, z)
+inflate_blocks_statef *s;
+z_streamp z;
+{
+  inflate_blocks_reset(s, z, Z_NULL);
+  ZFREE(z, s->window);
+  ZFREE(z, s->hufts);
+  ZFREE(z, s);
+  Tracev((stderr, "inflate:   blocks freed\n"));
+  return Z_OK;
+}
+
+
+void inflate_set_dictionary(s, d, n)
+inflate_blocks_statef *s;
+const Bytef *d;
+uInt  n;
+{
+  zmemcpy(s->window, d, n);
+  s->read = s->write = s->window + n;
+}
+
+
+/* Returns true if inflate is currently at the end of a block generated
+ * by Z_SYNC_FLUSH or Z_FULL_FLUSH. 
+ * IN assertion: s != Z_NULL
+ */
+int inflate_blocks_sync_point(s)
+inflate_blocks_statef *s;
+{
+  return s->mode == LENS;
+}
diff --git a/src/unix/contrib/cutzlib-1.1.4/infblock.h b/src/unix/contrib/cutzlib-1.1.4/infblock.h
new file mode 100644
index 0000000..173b226
--- /dev/null
+++ b/src/unix/contrib/cutzlib-1.1.4/infblock.h
@@ -0,0 +1,39 @@
+/* infblock.h -- header to use infblock.c
+ * Copyright (C) 1995-2002 Mark Adler
+ * For conditions of distribution and use, see copyright notice in zlib.h 
+ */
+
+/* WARNING: this file should *not* be used by applications. It is
+   part of the implementation of the compression library and is
+   subject to change. Applications should only use zlib.h.
+ */
+
+struct inflate_blocks_state;
+typedef struct inflate_blocks_state FAR inflate_blocks_statef;
+
+extern inflate_blocks_statef * inflate_blocks_new OF((
+    z_streamp z,
+    check_func c,               /* check function */
+    uInt w));                   /* window size */
+
+extern int inflate_blocks OF((
+    inflate_blocks_statef *,
+    z_streamp ,
+    int));                      /* initial return code */
+
+extern void inflate_blocks_reset OF((
+    inflate_blocks_statef *,
+    z_streamp ,
+    uLongf *));                  /* check value on output */
+
+extern int inflate_blocks_free OF((
+    inflate_blocks_statef *,
+    z_streamp));
+
+extern void inflate_set_dictionary OF((
+    inflate_blocks_statef *s,
+    const Bytef *d,  /* dictionary */
+    uInt  n));       /* dictionary length */
+
+extern int inflate_blocks_sync_point OF((
+    inflate_blocks_statef *s));
diff --git a/src/unix/contrib/cutzlib-1.1.4/infcodes.c b/src/unix/contrib/cutzlib-1.1.4/infcodes.c
new file mode 100644
index 0000000..9abe541
--- /dev/null
+++ b/src/unix/contrib/cutzlib-1.1.4/infcodes.c
@@ -0,0 +1,251 @@
+/* infcodes.c -- process literals and length/distance pairs
+ * Copyright (C) 1995-2002 Mark Adler
+ * For conditions of distribution and use, see copyright notice in zlib.h 
+ */
+
+#include "zutil.h"
+#include "inftrees.h"
+#include "infblock.h"
+#include "infcodes.h"
+#include "infutil.h"
+#include "inffast.h"
+
+/* simplify the use of the inflate_huft type with some defines */
+#define exop word.what.Exop
+#define bits word.what.Bits
+
+typedef enum {        /* waiting for "i:"=input, "o:"=output, "x:"=nothing */
+      START,    /* x: set up for LEN */
+      LEN,      /* i: get length/literal/eob next */
+      LENEXT,   /* i: getting length extra (have base) */
+      DIST,     /* i: get distance next */
+      DISTEXT,  /* i: getting distance extra */
+      COPY,     /* o: copying bytes in window, waiting for space */
+      LIT,      /* o: got literal, waiting for output space */
+      WASH,     /* o: got eob, possibly still output waiting */
+      END,      /* x: got eob and all data flushed */
+      BADCODE}  /* x: got error */
+inflate_codes_mode;
+
+/* inflate codes private state */
+struct inflate_codes_state {
+
+  /* mode */
+  inflate_codes_mode mode;      /* current inflate_codes mode */
+
+  /* mode dependent information */
+  uInt len;
+  union {
+    struct {
+      inflate_huft *tree;       /* pointer into tree */
+      uInt need;                /* bits needed */
+    } code;             /* if LEN or DIST, where in tree */
+    uInt lit;           /* if LIT, literal */
+    struct {
+      uInt get;                 /* bits to get for extra */
+      uInt dist;                /* distance back to copy from */
+    } copy;             /* if EXT or COPY, where and how much */
+  } sub;                /* submode */
+
+  /* mode independent information */
+  Byte lbits;           /* ltree bits decoded per branch */
+  Byte dbits;           /* dtree bits decoder per branch */
+  inflate_huft *ltree;          /* literal/length/eob tree */
+  inflate_huft *dtree;          /* distance tree */
+
+};
+
+
+inflate_codes_statef *inflate_codes_new(bl, bd, tl, td, z)
+uInt bl, bd;
+inflate_huft *tl;
+inflate_huft *td; /* need separate declaration for Borland C++ */
+z_streamp z;
+{
+  inflate_codes_statef *c;
+
+  if ((c = (inflate_codes_statef *)
+       ZALLOC(z,1,sizeof(struct inflate_codes_state))) != Z_NULL)
+  {
+    c->mode = START;
+    c->lbits = (Byte)bl;
+    c->dbits = (Byte)bd;
+    c->ltree = tl;
+    c->dtree = td;
+    Tracev((stderr, "inflate:       codes new\n"));
+  }
+  return c;
+}
+
+
+int inflate_codes(s, z, r)
+inflate_blocks_statef *s;
+z_streamp z;
+int r;
+{
+  uInt j;               /* temporary storage */
+  inflate_huft *t;      /* temporary pointer */
+  uInt e;               /* extra bits or operation */
+  uLong b;              /* bit buffer */
+  uInt k;               /* bits in bit buffer */
+  Bytef *p;             /* input data pointer */
+  uInt n;               /* bytes available there */
+  Bytef *q;             /* output window write pointer */
+  uInt m;               /* bytes to end of window or read pointer */
+  Bytef *f;             /* pointer to copy strings from */
+  inflate_codes_statef *c = s->sub.decode.codes;  /* codes state */
+
+  /* copy input/output information to locals (UPDATE macro restores) */
+  LOAD
+
+  /* process input and output based on current state */
+  while (1) switch (c->mode)
+  {             /* waiting for "i:"=input, "o:"=output, "x:"=nothing */
+    case START:         /* x: set up for LEN */
+#ifndef SLOW
+      if (m >= 258 && n >= 10)
+      {
+        UPDATE
+        r = inflate_fast(c->lbits, c->dbits, c->ltree, c->dtree, s, z);
+        LOAD
+        if (r != Z_OK)
+        {
+          c->mode = r == Z_STREAM_END ? WASH : BADCODE;
+          break;
+        }
+      }
+#endif /* !SLOW */
+      c->sub.code.need = c->lbits;
+      c->sub.code.tree = c->ltree;
+      c->mode = LEN;
+    case LEN:           /* i: get length/literal/eob next */
+      j = c->sub.code.need;
+      NEEDBITS(j)
+      t = c->sub.code.tree + ((uInt)b & inflate_mask[j]);
+      DUMPBITS(t->bits)
+      e = (uInt)(t->exop);
+      if (e == 0)               /* literal */
+      {
+        c->sub.lit = t->base;
+        Tracevv((stderr, t->base >= 0x20 && t->base < 0x7f ?
+                 "inflate:         literal '%c'\n" :
+                 "inflate:         literal 0x%02x\n", t->base));
+        c->mode = LIT;
+        break;
+      }
+      if (e & 16)               /* length */
+      {
+        c->sub.copy.get = e & 15;
+        c->len = t->base;
+        c->mode = LENEXT;
+        break;
+      }
+      if ((e & 64) == 0)        /* next table */
+      {
+        c->sub.code.need = e;
+        c->sub.code.tree = t + t->base;
+        break;
+      }
+      if (e & 32)               /* end of block */
+      {
+        Tracevv((stderr, "inflate:         end of block\n"));
+        c->mode = WASH;
+        break;
+      }
+      c->mode = BADCODE;        /* invalid code */
+      z->msg = (char*)"invalid literal/length code";
+      r = Z_DATA_ERROR;
+      LEAVE
+    case LENEXT:        /* i: getting length extra (have base) */
+      j = c->sub.copy.get;
+      NEEDBITS(j)
+      c->len += (uInt)b & inflate_mask[j];
+      DUMPBITS(j)
+      c->sub.code.need = c->dbits;
+      c->sub.code.tree = c->dtree;
+      Tracevv((stderr, "inflate:         length %u\n", c->len));
+      c->mode = DIST;
+    case DIST:          /* i: get distance next */
+      j = c->sub.code.need;
+      NEEDBITS(j)
+      t = c->sub.code.tree + ((uInt)b & inflate_mask[j]);
+      DUMPBITS(t->bits)
+      e = (uInt)(t->exop);
+      if (e & 16)               /* distance */
+      {
+        c->sub.copy.get = e & 15;
+        c->sub.copy.dist = t->base;
+        c->mode = DISTEXT;
+        break;
+      }
+      if ((e & 64) == 0)        /* next table */
+      {
+        c->sub.code.need = e;
+        c->sub.code.tree = t + t->base;
+        break;
+      }
+      c->mode = BADCODE;        /* invalid code */
+      z->msg = (char*)"invalid distance code";
+      r = Z_DATA_ERROR;
+      LEAVE
+    case DISTEXT:       /* i: getting distance extra */
+      j = c->sub.copy.get;
+      NEEDBITS(j)
+      c->sub.copy.dist += (uInt)b & inflate_mask[j];
+      DUMPBITS(j)
+      Tracevv((stderr, "inflate:         distance %u\n", c->sub.copy.dist));
+      c->mode = COPY;
+    case COPY:          /* o: copying bytes in window, waiting for space */
+      f = q - c->sub.copy.dist;
+      while (f < s->window)             /* modulo window size-"while" instead */
+        f += s->end - s->window;        /* of "if" handles invalid distances */
+      while (c->len)
+      {
+        NEEDOUT
+        OUTBYTE(*f++)
+        if (f == s->end)
+          f = s->window;
+        c->len--;
+      }
+      c->mode = START;
+      break;
+    case LIT:           /* o: got literal, waiting for output space */
+      NEEDOUT
+      OUTBYTE(c->sub.lit)
+      c->mode = START;
+      break;
+    case WASH:          /* o: got eob, possibly more output */
+      if (k > 7)        /* return unused byte, if any */
+      {
+        Assert(k < 16, "inflate_codes grabbed too many bytes")
+        k -= 8;
+        n++;
+        p--;            /* can always return one */
+      }
+      FLUSH
+      if (s->read != s->write)
+        LEAVE
+      c->mode = END;
+    case END:
+      r = Z_STREAM_END;
+      LEAVE
+    case BADCODE:       /* x: got error */
+      r = Z_DATA_ERROR;
+      LEAVE
+    default:
+      r = Z_STREAM_ERROR;
+      LEAVE
+  }
+#ifdef NEED_DUMMY_RETURN
+  return Z_STREAM_ERROR;  /* Some dumb compilers complain without this */
+#endif
+}
+
+
+void inflate_codes_free(c, z)
+inflate_codes_statef *c;
+z_streamp z;
+{
+  ZFREE(z, c);
+  Tracev((stderr, "inflate:       codes free\n"));
+}
diff --git a/src/unix/contrib/cutzlib-1.1.4/infcodes.h b/src/unix/contrib/cutzlib-1.1.4/infcodes.h
new file mode 100644
index 0000000..46821a0
--- /dev/null
+++ b/src/unix/contrib/cutzlib-1.1.4/infcodes.h
@@ -0,0 +1,27 @@
+/* infcodes.h -- header to use infcodes.c
+ * Copyright (C) 1995-2002 Mark Adler
+ * For conditions of distribution and use, see copyright notice in zlib.h 
+ */
+
+/* WARNING: this file should *not* be used by applications. It is
+   part of the implementation of the compression library and is
+   subject to change. Applications should only use zlib.h.
+ */
+
+struct inflate_codes_state;
+typedef struct inflate_codes_state FAR inflate_codes_statef;
+
+extern inflate_codes_statef *inflate_codes_new OF((
+    uInt, uInt,
+    inflate_huft *, inflate_huft *,
+    z_streamp ));
+
+extern int inflate_codes OF((
+    inflate_blocks_statef *,
+    z_streamp ,
+    int));
+
+extern void inflate_codes_free OF((
+    inflate_codes_statef *,
+    z_streamp ));
+
diff --git a/src/unix/contrib/cutzlib-1.1.4/inffast.c b/src/unix/contrib/cutzlib-1.1.4/inffast.c
new file mode 100644
index 0000000..aa7f1d4
--- /dev/null
+++ b/src/unix/contrib/cutzlib-1.1.4/inffast.c
@@ -0,0 +1,183 @@
+/* inffast.c -- process literals and length/distance pairs fast
+ * Copyright (C) 1995-2002 Mark Adler
+ * For conditions of distribution and use, see copyright notice in zlib.h 
+ */
+
+#include "zutil.h"
+#include "inftrees.h"
+#include "infblock.h"
+#include "infcodes.h"
+#include "infutil.h"
+#include "inffast.h"
+
+struct inflate_codes_state {int dummy;}; /* for buggy compilers */
+
+/* simplify the use of the inflate_huft type with some defines */
+#define exop word.what.Exop
+#define bits word.what.Bits
+
+/* macros for bit input with no checking and for returning unused bytes */
+#define GRABBITS(j) {while(k<(j)){b|=((uLong)NEXTBYTE)<<k;k+=8;}}
+#define UNGRAB {c=z->avail_in-n;c=(k>>3)<c?k>>3:c;n+=c;p-=c;k-=c<<3;}
+
+/* Called with number of bytes left to write in window at least 258
+   (the maximum string length) and number of input bytes available
+   at least ten.  The ten bytes are six bytes for the longest length/
+   distance pair plus four bytes for overloading the bit buffer. */
+
+int inflate_fast(bl, bd, tl, td, s, z)
+uInt bl, bd;
+inflate_huft *tl;
+inflate_huft *td; /* need separate declaration for Borland C++ */
+inflate_blocks_statef *s;
+z_streamp z;
+{
+  inflate_huft *t;      /* temporary pointer */
+  uInt e;               /* extra bits or operation */
+  uLong b;              /* bit buffer */
+  uInt k;               /* bits in bit buffer */
+  Bytef *p;             /* input data pointer */
+  uInt n;               /* bytes available there */
+  Bytef *q;             /* output window write pointer */
+  uInt m;               /* bytes to end of window or read pointer */
+  uInt ml;              /* mask for literal/length tree */
+  uInt md;              /* mask for distance tree */
+  uInt c;               /* bytes to copy */
+  uInt d;               /* distance back to copy from */
+  Bytef *r;             /* copy source pointer */
+
+  /* load input, output, bit values */
+  LOAD
+
+  /* initialize masks */
+  ml = inflate_mask[bl];
+  md = inflate_mask[bd];
+
+  /* do until not enough input or output space for fast loop */
+  do {                          /* assume called with m >= 258 && n >= 10 */
+    /* get literal/length code */
+    GRABBITS(20)                /* max bits for literal/length code */
+    if ((e = (t = tl + ((uInt)b & ml))->exop) == 0)
+    {
+      DUMPBITS(t->bits)
+      Tracevv((stderr, t->base >= 0x20 && t->base < 0x7f ?
+                "inflate:         * literal '%c'\n" :
+                "inflate:         * literal 0x%02x\n", t->base));
+      *q++ = (Byte)t->base;
+      m--;
+      continue;
+    }
+    do {
+      DUMPBITS(t->bits)
+      if (e & 16)
+      {
+        /* get extra bits for length */
+        e &= 15;
+        c = t->base + ((uInt)b & inflate_mask[e]);
+        DUMPBITS(e)
+        Tracevv((stderr, "inflate:         * length %u\n", c));
+
+        /* decode distance base of block to copy */
+        GRABBITS(15);           /* max bits for distance code */
+        e = (t = td + ((uInt)b & md))->exop;
+        do {
+          DUMPBITS(t->bits)
+          if (e & 16)
+          {
+            /* get extra bits to add to distance base */
+            e &= 15;
+            GRABBITS(e)         /* get extra bits (up to 13) */
+            d = t->base + ((uInt)b & inflate_mask[e]);
+            DUMPBITS(e)
+            Tracevv((stderr, "inflate:         * distance %u\n", d));
+
+            /* do the copy */
+            m -= c;
+            r = q - d;
+            if (r < s->window)                  /* wrap if needed */
+            {
+              do {
+                r += s->end - s->window;        /* force pointer in window */
+              } while (r < s->window);          /* covers invalid distances */
+              e = s->end - r;
+              if (c > e)
+              {
+                c -= e;                         /* wrapped copy */
+                do {
+                    *q++ = *r++;
+                } while (--e);
+                r = s->window;
+                do {
+                    *q++ = *r++;
+                } while (--c);
+              }
+              else                              /* normal copy */
+              {
+                *q++ = *r++;  c--;
+                *q++ = *r++;  c--;
+                do {
+                    *q++ = *r++;
+                } while (--c);
+              }
+            }
+            else                                /* normal copy */
+            {
+              *q++ = *r++;  c--;
+              *q++ = *r++;  c--;
+              do {
+                *q++ = *r++;
+              } while (--c);
+            }
+            break;
+          }
+          else if ((e & 64) == 0)
+          {
+            t += t->base;
+            e = (t += ((uInt)b & inflate_mask[e]))->exop;
+          }
+          else
+          {
+            z->msg = (char*)"invalid distance code";
+            UNGRAB
+            UPDATE
+            return Z_DATA_ERROR;
+          }
+        } while (1);
+        break;
+      }
+      if ((e & 64) == 0)
+      {
+        t += t->base;
+        if ((e = (t += ((uInt)b & inflate_mask[e]))->exop) == 0)
+        {
+          DUMPBITS(t->bits)
+          Tracevv((stderr, t->base >= 0x20 && t->base < 0x7f ?
+                    "inflate:         * literal '%c'\n" :
+                    "inflate:         * literal 0x%02x\n", t->base));
+          *q++ = (Byte)t->base;
+          m--;
+          break;
+        }
+      }
+      else if (e & 32)
+      {
+        Tracevv((stderr, "inflate:         * end of block\n"));
+        UNGRAB
+        UPDATE
+        return Z_STREAM_END;
+      }
+      else
+      {
+        z->msg = (char*)"invalid literal/length code";
+        UNGRAB
+        UPDATE
+        return Z_DATA_ERROR;
+      }
+    } while (1);
+  } while (m >= 258 && n >= 10);
+
+  /* not enough input or output--restore pointers and return */
+  UNGRAB
+  UPDATE
+  return Z_OK;
+}
diff --git a/src/unix/contrib/cutzlib-1.1.4/inffast.h b/src/unix/contrib/cutzlib-1.1.4/inffast.h
new file mode 100644
index 0000000..a31a4bb
--- /dev/null
+++ b/src/unix/contrib/cutzlib-1.1.4/inffast.h
@@ -0,0 +1,17 @@
+/* inffast.h -- header to use inffast.c
+ * Copyright (C) 1995-2002 Mark Adler
+ * For conditions of distribution and use, see copyright notice in zlib.h 
+ */
+
+/* WARNING: this file should *not* be used by applications. It is
+   part of the implementation of the compression library and is
+   subject to change. Applications should only use zlib.h.
+ */
+
+extern int inflate_fast OF((
+    uInt,
+    uInt,
+    inflate_huft *,
+    inflate_huft *,
+    inflate_blocks_statef *,
+    z_streamp ));
diff --git a/src/unix/contrib/cutzlib-1.1.4/inffixed.h b/src/unix/contrib/cutzlib-1.1.4/inffixed.h
new file mode 100644
index 0000000..77f7e76
--- /dev/null
+++ b/src/unix/contrib/cutzlib-1.1.4/inffixed.h
@@ -0,0 +1,151 @@
+/* inffixed.h -- table for decoding fixed codes
+ * Generated automatically by the maketree.c program
+ */
+
+/* WARNING: this file should *not* be used by applications. It is
+   part of the implementation of the compression library and is
+   subject to change. Applications should only use zlib.h.
+ */
+
+local uInt fixed_bl = 9;
+local uInt fixed_bd = 5;
+local inflate_huft fixed_tl[] = {
+    {{{96,7}},256}, {{{0,8}},80}, {{{0,8}},16}, {{{84,8}},115},
+    {{{82,7}},31}, {{{0,8}},112}, {{{0,8}},48}, {{{0,9}},192},
+    {{{80,7}},10}, {{{0,8}},96}, {{{0,8}},32}, {{{0,9}},160},
+    {{{0,8}},0}, {{{0,8}},128}, {{{0,8}},64}, {{{0,9}},224},
+    {{{80,7}},6}, {{{0,8}},88}, {{{0,8}},24}, {{{0,9}},144},
+    {{{83,7}},59}, {{{0,8}},120}, {{{0,8}},56}, {{{0,9}},208},
+    {{{81,7}},17}, {{{0,8}},104}, {{{0,8}},40}, {{{0,9}},176},
+    {{{0,8}},8}, {{{0,8}},136}, {{{0,8}},72}, {{{0,9}},240},
+    {{{80,7}},4}, {{{0,8}},84}, {{{0,8}},20}, {{{85,8}},227},
+    {{{83,7}},43}, {{{0,8}},116}, {{{0,8}},52}, {{{0,9}},200},
+    {{{81,7}},13}, {{{0,8}},100}, {{{0,8}},36}, {{{0,9}},168},
+    {{{0,8}},4}, {{{0,8}},132}, {{{0,8}},68}, {{{0,9}},232},
+    {{{80,7}},8}, {{{0,8}},92}, {{{0,8}},28}, {{{0,9}},152},
+    {{{84,7}},83}, {{{0,8}},124}, {{{0,8}},60}, {{{0,9}},216},
+    {{{82,7}},23}, {{{0,8}},108}, {{{0,8}},44}, {{{0,9}},184},
+    {{{0,8}},12}, {{{0,8}},140}, {{{0,8}},76}, {{{0,9}},248},
+    {{{80,7}},3}, {{{0,8}},82}, {{{0,8}},18}, {{{85,8}},163},
+    {{{83,7}},35}, {{{0,8}},114}, {{{0,8}},50}, {{{0,9}},196},
+    {{{81,7}},11}, {{{0,8}},98}, {{{0,8}},34}, {{{0,9}},164},
+    {{{0,8}},2}, {{{0,8}},130}, {{{0,8}},66}, {{{0,9}},228},
+    {{{80,7}},7}, {{{0,8}},90}, {{{0,8}},26}, {{{0,9}},148},
+    {{{84,7}},67}, {{{0,8}},122}, {{{0,8}},58}, {{{0,9}},212},
+    {{{82,7}},19}, {{{0,8}},106}, {{{0,8}},42}, {{{0,9}},180},
+    {{{0,8}},10}, {{{0,8}},138}, {{{0,8}},74}, {{{0,9}},244},
+    {{{80,7}},5}, {{{0,8}},86}, {{{0,8}},22}, {{{192,8}},0},
+    {{{83,7}},51}, {{{0,8}},118}, {{{0,8}},54}, {{{0,9}},204},
+    {{{81,7}},15}, {{{0,8}},102}, {{{0,8}},38}, {{{0,9}},172},
+    {{{0,8}},6}, {{{0,8}},134}, {{{0,8}},70}, {{{0,9}},236},
+    {{{80,7}},9}, {{{0,8}},94}, {{{0,8}},30}, {{{0,9}},156},
+    {{{84,7}},99}, {{{0,8}},126}, {{{0,8}},62}, {{{0,9}},220},
+    {{{82,7}},27}, {{{0,8}},110}, {{{0,8}},46}, {{{0,9}},188},
+    {{{0,8}},14}, {{{0,8}},142}, {{{0,8}},78}, {{{0,9}},252},
+    {{{96,7}},256}, {{{0,8}},81}, {{{0,8}},17}, {{{85,8}},131},
+    {{{82,7}},31}, {{{0,8}},113}, {{{0,8}},49}, {{{0,9}},194},
+    {{{80,7}},10}, {{{0,8}},97}, {{{0,8}},33}, {{{0,9}},162},
+    {{{0,8}},1}, {{{0,8}},129}, {{{0,8}},65}, {{{0,9}},226},
+    {{{80,7}},6}, {{{0,8}},89}, {{{0,8}},25}, {{{0,9}},146},
+    {{{83,7}},59}, {{{0,8}},121}, {{{0,8}},57}, {{{0,9}},210},
+    {{{81,7}},17}, {{{0,8}},105}, {{{0,8}},41}, {{{0,9}},178},
+    {{{0,8}},9}, {{{0,8}},137}, {{{0,8}},73}, {{{0,9}},242},
+    {{{80,7}},4}, {{{0,8}},85}, {{{0,8}},21}, {{{80,8}},258},
+    {{{83,7}},43}, {{{0,8}},117}, {{{0,8}},53}, {{{0,9}},202},
+    {{{81,7}},13}, {{{0,8}},101}, {{{0,8}},37}, {{{0,9}},170},
+    {{{0,8}},5}, {{{0,8}},133}, {{{0,8}},69}, {{{0,9}},234},
+    {{{80,7}},8}, {{{0,8}},93}, {{{0,8}},29}, {{{0,9}},154},
+    {{{84,7}},83}, {{{0,8}},125}, {{{0,8}},61}, {{{0,9}},218},
+    {{{82,7}},23}, {{{0,8}},109}, {{{0,8}},45}, {{{0,9}},186},
+    {{{0,8}},13}, {{{0,8}},141}, {{{0,8}},77}, {{{0,9}},250},
+    {{{80,7}},3}, {{{0,8}},83}, {{{0,8}},19}, {{{85,8}},195},
+    {{{83,7}},35}, {{{0,8}},115}, {{{0,8}},51}, {{{0,9}},198},
+    {{{81,7}},11}, {{{0,8}},99}, {{{0,8}},35}, {{{0,9}},166},
+    {{{0,8}},3}, {{{0,8}},131}, {{{0,8}},67}, {{{0,9}},230},
+    {{{80,7}},7}, {{{0,8}},91}, {{{0,8}},27}, {{{0,9}},150},
+    {{{84,7}},67}, {{{0,8}},123}, {{{0,8}},59}, {{{0,9}},214},
+    {{{82,7}},19}, {{{0,8}},107}, {{{0,8}},43}, {{{0,9}},182},
+    {{{0,8}},11}, {{{0,8}},139}, {{{0,8}},75}, {{{0,9}},246},
+    {{{80,7}},5}, {{{0,8}},87}, {{{0,8}},23}, {{{192,8}},0},
+    {{{83,7}},51}, {{{0,8}},119}, {{{0,8}},55}, {{{0,9}},206},
+    {{{81,7}},15}, {{{0,8}},103}, {{{0,8}},39}, {{{0,9}},174},
+    {{{0,8}},7}, {{{0,8}},135}, {{{0,8}},71}, {{{0,9}},238},
+    {{{80,7}},9}, {{{0,8}},95}, {{{0,8}},31}, {{{0,9}},158},
+    {{{84,7}},99}, {{{0,8}},127}, {{{0,8}},63}, {{{0,9}},222},
+    {{{82,7}},27}, {{{0,8}},111}, {{{0,8}},47}, {{{0,9}},190},
+    {{{0,8}},15}, {{{0,8}},143}, {{{0,8}},79}, {{{0,9}},254},
+    {{{96,7}},256}, {{{0,8}},80}, {{{0,8}},16}, {{{84,8}},115},
+    {{{82,7}},31}, {{{0,8}},112}, {{{0,8}},48}, {{{0,9}},193},
+    {{{80,7}},10}, {{{0,8}},96}, {{{0,8}},32}, {{{0,9}},161},
+    {{{0,8}},0}, {{{0,8}},128}, {{{0,8}},64}, {{{0,9}},225},
+    {{{80,7}},6}, {{{0,8}},88}, {{{0,8}},24}, {{{0,9}},145},
+    {{{83,7}},59}, {{{0,8}},120}, {{{0,8}},56}, {{{0,9}},209},
+    {{{81,7}},17}, {{{0,8}},104}, {{{0,8}},40}, {{{0,9}},177},
+    {{{0,8}},8}, {{{0,8}},136}, {{{0,8}},72}, {{{0,9}},241},
+    {{{80,7}},4}, {{{0,8}},84}, {{{0,8}},20}, {{{85,8}},227},
+    {{{83,7}},43}, {{{0,8}},116}, {{{0,8}},52}, {{{0,9}},201},
+    {{{81,7}},13}, {{{0,8}},100}, {{{0,8}},36}, {{{0,9}},169},
+    {{{0,8}},4}, {{{0,8}},132}, {{{0,8}},68}, {{{0,9}},233},
+    {{{80,7}},8}, {{{0,8}},92}, {{{0,8}},28}, {{{0,9}},153},
+    {{{84,7}},83}, {{{0,8}},124}, {{{0,8}},60}, {{{0,9}},217},
+    {{{82,7}},23}, {{{0,8}},108}, {{{0,8}},44}, {{{0,9}},185},
+    {{{0,8}},12}, {{{0,8}},140}, {{{0,8}},76}, {{{0,9}},249},
+    {{{80,7}},3}, {{{0,8}},82}, {{{0,8}},18}, {{{85,8}},163},
+    {{{83,7}},35}, {{{0,8}},114}, {{{0,8}},50}, {{{0,9}},197},
+    {{{81,7}},11}, {{{0,8}},98}, {{{0,8}},34}, {{{0,9}},165},
+    {{{0,8}},2}, {{{0,8}},130}, {{{0,8}},66}, {{{0,9}},229},
+    {{{80,7}},7}, {{{0,8}},90}, {{{0,8}},26}, {{{0,9}},149},
+    {{{84,7}},67}, {{{0,8}},122}, {{{0,8}},58}, {{{0,9}},213},
+    {{{82,7}},19}, {{{0,8}},106}, {{{0,8}},42}, {{{0,9}},181},
+    {{{0,8}},10}, {{{0,8}},138}, {{{0,8}},74}, {{{0,9}},245},
+    {{{80,7}},5}, {{{0,8}},86}, {{{0,8}},22}, {{{192,8}},0},
+    {{{83,7}},51}, {{{0,8}},118}, {{{0,8}},54}, {{{0,9}},205},
+    {{{81,7}},15}, {{{0,8}},102}, {{{0,8}},38}, {{{0,9}},173},
+    {{{0,8}},6}, {{{0,8}},134}, {{{0,8}},70}, {{{0,9}},237},
+    {{{80,7}},9}, {{{0,8}},94}, {{{0,8}},30}, {{{0,9}},157},
+    {{{84,7}},99}, {{{0,8}},126}, {{{0,8}},62}, {{{0,9}},221},
+    {{{82,7}},27}, {{{0,8}},110}, {{{0,8}},46}, {{{0,9}},189},
+    {{{0,8}},14}, {{{0,8}},142}, {{{0,8}},78}, {{{0,9}},253},
+    {{{96,7}},256}, {{{0,8}},81}, {{{0,8}},17}, {{{85,8}},131},
+    {{{82,7}},31}, {{{0,8}},113}, {{{0,8}},49}, {{{0,9}},195},
+    {{{80,7}},10}, {{{0,8}},97}, {{{0,8}},33}, {{{0,9}},163},
+    {{{0,8}},1}, {{{0,8}},129}, {{{0,8}},65}, {{{0,9}},227},
+    {{{80,7}},6}, {{{0,8}},89}, {{{0,8}},25}, {{{0,9}},147},
+    {{{83,7}},59}, {{{0,8}},121}, {{{0,8}},57}, {{{0,9}},211},
+    {{{81,7}},17}, {{{0,8}},105}, {{{0,8}},41}, {{{0,9}},179},
+    {{{0,8}},9}, {{{0,8}},137}, {{{0,8}},73}, {{{0,9}},243},
+    {{{80,7}},4}, {{{0,8}},85}, {{{0,8}},21}, {{{80,8}},258},
+    {{{83,7}},43}, {{{0,8}},117}, {{{0,8}},53}, {{{0,9}},203},
+    {{{81,7}},13}, {{{0,8}},101}, {{{0,8}},37}, {{{0,9}},171},
+    {{{0,8}},5}, {{{0,8}},133}, {{{0,8}},69}, {{{0,9}},235},
+    {{{80,7}},8}, {{{0,8}},93}, {{{0,8}},29}, {{{0,9}},155},
+    {{{84,7}},83}, {{{0,8}},125}, {{{0,8}},61}, {{{0,9}},219},
+    {{{82,7}},23}, {{{0,8}},109}, {{{0,8}},45}, {{{0,9}},187},
+    {{{0,8}},13}, {{{0,8}},141}, {{{0,8}},77}, {{{0,9}},251},
+    {{{80,7}},3}, {{{0,8}},83}, {{{0,8}},19}, {{{85,8}},195},
+    {{{83,7}},35}, {{{0,8}},115}, {{{0,8}},51}, {{{0,9}},199},
+    {{{81,7}},11}, {{{0,8}},99}, {{{0,8}},35}, {{{0,9}},167},
+    {{{0,8}},3}, {{{0,8}},131}, {{{0,8}},67}, {{{0,9}},231},
+    {{{80,7}},7}, {{{0,8}},91}, {{{0,8}},27}, {{{0,9}},151},
+    {{{84,7}},67}, {{{0,8}},123}, {{{0,8}},59}, {{{0,9}},215},
+    {{{82,7}},19}, {{{0,8}},107}, {{{0,8}},43}, {{{0,9}},183},
+    {{{0,8}},11}, {{{0,8}},139}, {{{0,8}},75}, {{{0,9}},247},
+    {{{80,7}},5}, {{{0,8}},87}, {{{0,8}},23}, {{{192,8}},0},
+    {{{83,7}},51}, {{{0,8}},119}, {{{0,8}},55}, {{{0,9}},207},
+    {{{81,7}},15}, {{{0,8}},103}, {{{0,8}},39}, {{{0,9}},175},
+    {{{0,8}},7}, {{{0,8}},135}, {{{0,8}},71}, {{{0,9}},239},
+    {{{80,7}},9}, {{{0,8}},95}, {{{0,8}},31}, {{{0,9}},159},
+    {{{84,7}},99}, {{{0,8}},127}, {{{0,8}},63}, {{{0,9}},223},
+    {{{82,7}},27}, {{{0,8}},111}, {{{0,8}},47}, {{{0,9}},191},
+    {{{0,8}},15}, {{{0,8}},143}, {{{0,8}},79}, {{{0,9}},255}
+  };
+local inflate_huft fixed_td[] = {
+    {{{80,5}},1}, {{{87,5}},257}, {{{83,5}},17}, {{{91,5}},4097},
+    {{{81,5}},5}, {{{89,5}},1025}, {{{85,5}},65}, {{{93,5}},16385},
+    {{{80,5}},3}, {{{88,5}},513}, {{{84,5}},33}, {{{92,5}},8193},
+    {{{82,5}},9}, {{{90,5}},2049}, {{{86,5}},129}, {{{192,5}},24577},
+    {{{80,5}},2}, {{{87,5}},385}, {{{83,5}},25}, {{{91,5}},6145},
+    {{{81,5}},7}, {{{89,5}},1537}, {{{85,5}},97}, {{{93,5}},24577},
+    {{{80,5}},4}, {{{88,5}},769}, {{{84,5}},49}, {{{92,5}},12289},
+    {{{82,5}},13}, {{{90,5}},3073}, {{{86,5}},193}, {{{192,5}},24577}
+  };
diff --git a/src/unix/contrib/cutzlib-1.1.4/inflate.c b/src/unix/contrib/cutzlib-1.1.4/inflate.c
new file mode 100644
index 0000000..dfb2e86
--- /dev/null
+++ b/src/unix/contrib/cutzlib-1.1.4/inflate.c
@@ -0,0 +1,366 @@
+/* inflate.c -- zlib interface to inflate modules
+ * Copyright (C) 1995-2002 Mark Adler
+ * For conditions of distribution and use, see copyright notice in zlib.h 
+ */
+
+#include "zutil.h"
+#include "infblock.h"
+
+struct inflate_blocks_state {int dummy;}; /* for buggy compilers */
+
+typedef enum {
+      METHOD,   /* waiting for method byte */
+      FLAG,     /* waiting for flag byte */
+      DICT4,    /* four dictionary check bytes to go */
+      DICT3,    /* three dictionary check bytes to go */
+      DICT2,    /* two dictionary check bytes to go */
+      DICT1,    /* one dictionary check byte to go */
+      DICT0,    /* waiting for inflateSetDictionary */
+      BLOCKS,   /* decompressing blocks */
+      CHECK4,   /* four check bytes to go */
+      CHECK3,   /* three check bytes to go */
+      CHECK2,   /* two check bytes to go */
+      CHECK1,   /* one check byte to go */
+      DONE,     /* finished check, done */
+      BAD}      /* got an error--stay here */
+inflate_mode;
+
+/* inflate private state */
+struct internal_state {
+
+  /* mode */
+  inflate_mode  mode;   /* current inflate mode */
+
+  /* mode dependent information */
+  union {
+    uInt method;        /* if FLAGS, method byte */
+    struct {
+      uLong was;                /* computed check value */
+      uLong need;               /* stream check value */
+    } check;            /* if CHECK, check values to compare */
+    uInt marker;        /* if BAD, inflateSync's marker bytes count */
+  } sub;        /* submode */
+
+  /* mode independent information */
+  int  nowrap;          /* flag for no wrapper */
+  uInt wbits;           /* log2(window size)  (8..15, defaults to 15) */
+  inflate_blocks_statef 
+    *blocks;            /* current inflate_blocks state */
+
+};
+
+
+int ZEXPORT inflateReset(z)
+z_streamp z;
+{
+  if (z == Z_NULL || z->state == Z_NULL)
+    return Z_STREAM_ERROR;
+  z->total_in = z->total_out = 0;
+  z->msg = Z_NULL;
+  z->state->mode = z->state->nowrap ? BLOCKS : METHOD;
+  inflate_blocks_reset(z->state->blocks, z, Z_NULL);
+  Tracev((stderr, "inflate: reset\n"));
+  return Z_OK;
+}
+
+
+int ZEXPORT inflateEnd(z)
+z_streamp z;
+{
+  if (z == Z_NULL || z->state == Z_NULL || z->zfree == Z_NULL)
+    return Z_STREAM_ERROR;
+  if (z->state->blocks != Z_NULL)
+    inflate_blocks_free(z->state->blocks, z);
+  ZFREE(z, z->state);
+  z->state = Z_NULL;
+  Tracev((stderr, "inflate: end\n"));
+  return Z_OK;
+}
+
+
+int ZEXPORT inflateInit2_(z, w, version, stream_size)
+z_streamp z;
+int w;
+const char *version;
+int stream_size;
+{
+  if (version == Z_NULL || version[0] != ZLIB_VERSION[0] ||
+      stream_size != sizeof(z_stream))
+      return Z_VERSION_ERROR;
+
+  /* initialize state */
+  if (z == Z_NULL)
+    return Z_STREAM_ERROR;
+  z->msg = Z_NULL;
+  if (z->zalloc == Z_NULL)
+  {
+    z->zalloc = zcalloc;
+    z->opaque = (voidpf)0;
+  }
+  if (z->zfree == Z_NULL) z->zfree = zcfree;
+  if ((z->state = (struct internal_state FAR *)
+       ZALLOC(z,1,sizeof(struct internal_state))) == Z_NULL)
+    return Z_MEM_ERROR;
+  z->state->blocks = Z_NULL;
+
+  /* handle undocumented nowrap option (no zlib header or check) */
+  z->state->nowrap = 0;
+  if (w < 0)
+  {
+    w = - w;
+    z->state->nowrap = 1;
+  }
+
+  /* set window size */
+  if (w < 8 || w > 15)
+  {
+    inflateEnd(z);
+    return Z_STREAM_ERROR;
+  }
+  z->state->wbits = (uInt)w;
+
+  /* create inflate_blocks state */
+  if ((z->state->blocks =
+      inflate_blocks_new(z, z->state->nowrap ? Z_NULL : adler32, (uInt)1 << w))
+      == Z_NULL)
+  {
+    inflateEnd(z);
+    return Z_MEM_ERROR;
+  }
+  Tracev((stderr, "inflate: allocated\n"));
+
+  /* reset state */
+  inflateReset(z);
+  return Z_OK;
+}
+
+
+int ZEXPORT inflateInit_(z, version, stream_size)
+z_streamp z;
+const char *version;
+int stream_size;
+{
+  return inflateInit2_(z, DEF_WBITS, version, stream_size);
+}
+
+
+#define NEEDBYTE {if(z->avail_in==0)return r;r=f;}
+#define NEXTBYTE (z->avail_in--,z->total_in++,*z->next_in++)
+
+int ZEXPORT inflate(z, f)
+z_streamp z;
+int f;
+{
+  int r;
+  uInt b;
+
+  if (z == Z_NULL || z->state == Z_NULL || z->next_in == Z_NULL)
+    return Z_STREAM_ERROR;
+  f = f == Z_FINISH ? Z_BUF_ERROR : Z_OK;
+  r = Z_BUF_ERROR;
+  while (1) switch (z->state->mode)
+  {
+    case METHOD:
+      NEEDBYTE
+      if (((z->state->sub.method = NEXTBYTE) & 0xf) != Z_DEFLATED)
+      {
+        z->state->mode = BAD;
+        z->msg = (char*)"unknown compression method";
+        z->state->sub.marker = 5;       /* can't try inflateSync */
+        break;
+      }
+      if ((z->state->sub.method >> 4) + 8 > z->state->wbits)
+      {
+        z->state->mode = BAD;
+        z->msg = (char*)"invalid window size";
+        z->state->sub.marker = 5;       /* can't try inflateSync */
+        break;
+      }
+      z->state->mode = FLAG;
+    case FLAG:
+      NEEDBYTE
+      b = NEXTBYTE;
+      if (((z->state->sub.method << 8) + b) % 31)
+      {
+        z->state->mode = BAD;
+        z->msg = (char*)"incorrect header check";
+        z->state->sub.marker = 5;       /* can't try inflateSync */
+        break;
+      }
+      Tracev((stderr, "inflate: zlib header ok\n"));
+      if (!(b & PRESET_DICT))
+      {
+        z->state->mode = BLOCKS;
+        break;
+      }
+      z->state->mode = DICT4;
+    case DICT4:
+      NEEDBYTE
+      z->state->sub.check.need = (uLong)NEXTBYTE << 24;
+      z->state->mode = DICT3;
+    case DICT3:
+      NEEDBYTE
+      z->state->sub.check.need += (uLong)NEXTBYTE << 16;
+      z->state->mode = DICT2;
+    case DICT2:
+      NEEDBYTE
+      z->state->sub.check.need += (uLong)NEXTBYTE << 8;
+      z->state->mode = DICT1;
+    case DICT1:
+      NEEDBYTE
+      z->state->sub.check.need += (uLong)NEXTBYTE;
+      z->adler = z->state->sub.check.need;
+      z->state->mode = DICT0;
+      return Z_NEED_DICT;
+    case DICT0:
+      z->state->mode = BAD;
+      z->msg = (char*)"need dictionary";
+      z->state->sub.marker = 0;       /* can try inflateSync */
+      return Z_STREAM_ERROR;
+    case BLOCKS:
+      r = inflate_blocks(z->state->blocks, z, r);
+      if (r == Z_DATA_ERROR)
+      {
+        z->state->mode = BAD;
+        z->state->sub.marker = 0;       /* can try inflateSync */
+        break;
+      }
+      if (r == Z_OK)
+        r = f;
+      if (r != Z_STREAM_END)
+        return r;
+      r = f;
+      inflate_blocks_reset(z->state->blocks, z, &z->state->sub.check.was);
+      if (z->state->nowrap)
+      {
+        z->state->mode = DONE;
+        break;
+      }
+      z->state->mode = CHECK4;
+    case CHECK4:
+      NEEDBYTE
+      z->state->sub.check.need = (uLong)NEXTBYTE << 24;
+      z->state->mode = CHECK3;
+    case CHECK3:
+      NEEDBYTE
+      z->state->sub.check.need += (uLong)NEXTBYTE << 16;
+      z->state->mode = CHECK2;
+    case CHECK2:
+      NEEDBYTE
+      z->state->sub.check.need += (uLong)NEXTBYTE << 8;
+      z->state->mode = CHECK1;
+    case CHECK1:
+      NEEDBYTE
+      z->state->sub.check.need += (uLong)NEXTBYTE;
+
+      if (z->state->sub.check.was != z->state->sub.check.need)
+      {
+        z->state->mode = BAD;
+        z->msg = (char*)"incorrect data check";
+        z->state->sub.marker = 5;       /* can't try inflateSync */
+        break;
+      }
+      Tracev((stderr, "inflate: zlib check ok\n"));
+      z->state->mode = DONE;
+    case DONE:
+      return Z_STREAM_END;
+    case BAD:
+      return Z_DATA_ERROR;
+    default:
+      return Z_STREAM_ERROR;
+  }
+#ifdef NEED_DUMMY_RETURN
+  return Z_STREAM_ERROR;  /* Some dumb compilers complain without this */
+#endif
+}
+
+
+int ZEXPORT inflateSetDictionary(z, dictionary, dictLength)
+z_streamp z;
+const Bytef *dictionary;
+uInt  dictLength;
+{
+  uInt length = dictLength;
+
+  if (z == Z_NULL || z->state == Z_NULL || z->state->mode != DICT0)
+    return Z_STREAM_ERROR;
+
+  if (adler32(1L, dictionary, dictLength) != z->adler) return Z_DATA_ERROR;
+  z->adler = 1L;
+
+  if (length >= ((uInt)1<<z->state->wbits))
+  {
+    length = (1<<z->state->wbits)-1;
+    dictionary += dictLength - length;
+  }
+  inflate_set_dictionary(z->state->blocks, dictionary, length);
+  z->state->mode = BLOCKS;
+  return Z_OK;
+}
+
+
+int ZEXPORT inflateSync(z)
+z_streamp z;
+{
+  uInt n;       /* number of bytes to look at */
+  Bytef *p;     /* pointer to bytes */
+  uInt m;       /* number of marker bytes found in a row */
+  uLong r, w;   /* temporaries to save total_in and total_out */
+
+  /* set up */
+  if (z == Z_NULL || z->state == Z_NULL)
+    return Z_STREAM_ERROR;
+  if (z->state->mode != BAD)
+  {
+    z->state->mode = BAD;
+    z->state->sub.marker = 0;
+  }
+  if ((n = z->avail_in) == 0)
+    return Z_BUF_ERROR;
+  p = z->next_in;
+  m = z->state->sub.marker;
+
+  /* search */
+  while (n && m < 4)
+  {
+    static const Byte mark[4] = {0, 0, 0xff, 0xff};
+    if (*p == mark[m])
+      m++;
+    else if (*p)
+      m = 0;
+    else
+      m = 4 - m;
+    p++, n--;
+  }
+
+  /* restore */
+  z->total_in += p - z->next_in;
+  z->next_in = p;
+  z->avail_in = n;
+  z->state->sub.marker = m;
+
+  /* return no joy or set up to restart on a new block */
+  if (m != 4)
+    return Z_DATA_ERROR;
+  r = z->total_in;  w = z->total_out;
+  inflateReset(z);
+  z->total_in = r;  z->total_out = w;
+  z->state->mode = BLOCKS;
+  return Z_OK;
+}
+
+
+/* Returns true if inflate is currently at the end of a block generated
+ * by Z_SYNC_FLUSH or Z_FULL_FLUSH. This function is used by one PPP
+ * implementation to provide an additional safety check. PPP uses Z_SYNC_FLUSH
+ * but removes the length bytes of the resulting empty stored block. When
+ * decompressing, PPP checks that at the end of input packet, inflate is
+ * waiting for these length bytes.
+ */
+int ZEXPORT inflateSyncPoint(z)
+z_streamp z;
+{
+  if (z == Z_NULL || z->state == Z_NULL || z->state->blocks == Z_NULL)
+    return Z_STREAM_ERROR;
+  return inflate_blocks_sync_point(z->state->blocks);
+}
diff --git a/src/unix/contrib/cutzlib-1.1.4/inftrees.c b/src/unix/contrib/cutzlib-1.1.4/inftrees.c
new file mode 100644
index 0000000..4c32ca3
--- /dev/null
+++ b/src/unix/contrib/cutzlib-1.1.4/inftrees.c
@@ -0,0 +1,454 @@
+/* inftrees.c -- generate Huffman trees for efficient decoding
+ * Copyright (C) 1995-2002 Mark Adler
+ * For conditions of distribution and use, see copyright notice in zlib.h 
+ */
+
+#include "zutil.h"
+#include "inftrees.h"
+
+#if !defined(BUILDFIXED) && !defined(STDC)
+#  define BUILDFIXED   /* non ANSI compilers may not accept inffixed.h */
+#endif
+
+const char inflate_copyright[] =
+   " inflate 1.1.4 Copyright 1995-2002 Mark Adler ";
+/*
+  If you use the zlib library in a product, an acknowledgment is welcome
+  in the documentation of your product. If for some reason you cannot
+  include such an acknowledgment, I would appreciate that you keep this
+  copyright string in the executable of your product.
+ */
+struct internal_state  {int dummy;}; /* for buggy compilers */
+
+/* simplify the use of the inflate_huft type with some defines */
+#define exop word.what.Exop
+#define bits word.what.Bits
+
+
+local int huft_build OF((
+    uIntf *,            /* code lengths in bits */
+    uInt,               /* number of codes */
+    uInt,               /* number of "simple" codes */
+    const uIntf *,      /* list of base values for non-simple codes */
+    const uIntf *,      /* list of extra bits for non-simple codes */
+    inflate_huft * FAR*,/* result: starting table */
+    uIntf *,            /* maximum lookup bits (returns actual) */
+    inflate_huft *,     /* space for trees */
+    uInt *,             /* hufts used in space */
+    uIntf * ));         /* space for values */
+
+/* Tables for deflate from PKZIP's appnote.txt. */
+local const uInt cplens[31] = { /* Copy lengths for literal codes 257..285 */
+        3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,
+        35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0};
+        /* see note #13 above about 258 */
+local const uInt cplext[31] = { /* Extra bits for literal codes 257..285 */
+        0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2,
+        3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 112, 112}; /* 112==invalid */
+local const uInt cpdist[30] = { /* Copy offsets for distance codes 0..29 */
+        1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,
+        257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,
+        8193, 12289, 16385, 24577};
+local const uInt cpdext[30] = { /* Extra bits for distance codes */
+        0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6,
+        7, 7, 8, 8, 9, 9, 10, 10, 11, 11,
+        12, 12, 13, 13};
+
+/*
+   Huffman code decoding is performed using a multi-level table lookup.
+   The fastest way to decode is to simply build a lookup table whose
+   size is determined by the longest code.  However, the time it takes
+   to build this table can also be a factor if the data being decoded
+   is not very long.  The most common codes are necessarily the
+   shortest codes, so those codes dominate the decoding time, and hence
+   the speed.  The idea is you can have a shorter table that decodes the
+   shorter, more probable codes, and then point to subsidiary tables for
+   the longer codes.  The time it costs to decode the longer codes is
+   then traded against the time it takes to make longer tables.
+
+   This results of this trade are in the variables lbits and dbits
+   below.  lbits is the number of bits the first level table for literal/
+   length codes can decode in one step, and dbits is the same thing for
+   the distance codes.  Subsequent tables are also less than or equal to
+   those sizes.  These values may be adjusted either when all of the
+   codes are shorter than that, in which case the longest code length in
+   bits is used, or when the shortest code is *longer* than the requested
+   table size, in which case the length of the shortest code in bits is
+   used.
+
+   There are two different values for the two tables, since they code a
+   different number of possibilities each.  The literal/length table
+   codes 286 possible values, or in a flat code, a little over eight
+   bits.  The distance table codes 30 possible values, or a little less
+   than five bits, flat.  The optimum values for speed end up being
+   about one bit more than those, so lbits is 8+1 and dbits is 5+1.
+   The optimum values may differ though from machine to machine, and
+   possibly even between compilers.  Your mileage may vary.
+ */
+
+
+/* If BMAX needs to be larger than 16, then h and x[] should be uLong. */
+#define BMAX 15         /* maximum bit length of any code */
+
+local int huft_build(b, n, s, d, e, t, m, hp, hn, v)
+uIntf *b;               /* code lengths in bits (all assumed <= BMAX) */
+uInt n;                 /* number of codes (assumed <= 288) */
+uInt s;                 /* number of simple-valued codes (0..s-1) */
+const uIntf *d;         /* list of base values for non-simple codes */
+const uIntf *e;         /* list of extra bits for non-simple codes */
+inflate_huft * FAR *t;  /* result: starting table */
+uIntf *m;               /* maximum lookup bits, returns actual */
+inflate_huft *hp;       /* space for trees */
+uInt *hn;               /* hufts used in space */
+uIntf *v;               /* working area: values in order of bit length */
+/* Given a list of code lengths and a maximum table size, make a set of
+   tables to decode that set of codes.  Return Z_OK on success, Z_BUF_ERROR
+   if the given code set is incomplete (the tables are still built in this
+   case), or Z_DATA_ERROR if the input is invalid. */
+{
+
+  uInt a;                       /* counter for codes of length k */
+  uInt c[BMAX+1];               /* bit length count table */
+  uInt f;                       /* i repeats in table every f entries */
+  int g;                        /* maximum code length */
+  int h;                        /* table level */
+  register uInt i;              /* counter, current code */
+  register uInt j;              /* counter */
+  register int k;               /* number of bits in current code */
+  int l;                        /* bits per table (returned in m) */
+  uInt mask;                    /* (1 << w) - 1, to avoid cc -O bug on HP */
+  register uIntf *p;            /* pointer into c[], b[], or v[] */
+  inflate_huft *q;              /* points to current table */
+  struct inflate_huft_s r;      /* table entry for structure assignment */
+  inflate_huft *u[BMAX];        /* table stack */
+  register int w;               /* bits before this table == (l * h) */
+  uInt x[BMAX+1];               /* bit offsets, then code stack */
+  uIntf *xp;                    /* pointer into x */
+  int y;                        /* number of dummy codes added */
+  uInt z;                       /* number of entries in current table */
+
+
+  /* Generate counts for each bit length */
+  p = c;
+#define C0 *p++ = 0;
+#define C2 C0 C0 C0 C0
+#define C4 C2 C2 C2 C2
+  C4                            /* clear c[]--assume BMAX+1 is 16 */
+  p = b;  i = n;
+  do {
+    c[*p++]++;                  /* assume all entries <= BMAX */
+  } while (--i);
+  if (c[0] == n)                /* null input--all zero length codes */
+  {
+    *t = (inflate_huft *)Z_NULL;
+    *m = 0;
+    return Z_OK;
+  }
+
+
+  /* Find minimum and maximum length, bound *m by those */
+  l = *m;
+  for (j = 1; j <= BMAX; j++)
+    if (c[j])
+      break;
+  k = j;                        /* minimum code length */
+  if ((uInt)l < j)
+    l = j;
+  for (i = BMAX; i; i--)
+    if (c[i])
+      break;
+  g = i;                        /* maximum code length */
+  if ((uInt)l > i)
+    l = i;
+  *m = l;
+
+
+  /* Adjust last length count to fill out codes, if needed */
+  for (y = 1 << j; j < i; j++, y <<= 1)
+    if ((y -= c[j]) < 0)
+      return Z_DATA_ERROR;
+  if ((y -= c[i]) < 0)
+    return Z_DATA_ERROR;
+  c[i] += y;
+
+
+  /* Generate starting offsets into the value table for each length */
+  x[1] = j = 0;
+  p = c + 1;  xp = x + 2;
+  while (--i) {                 /* note that i == g from above */
+    *xp++ = (j += *p++);
+  }
+
+
+  /* Make a table of values in order of bit lengths */
+  p = b;  i = 0;
+  do {
+    if ((j = *p++) != 0)
+      v[x[j]++] = i;
+  } while (++i < n);
+  n = x[g];                     /* set n to length of v */
+
+
+  /* Generate the Huffman codes and for each, make the table entries */
+  x[0] = i = 0;                 /* first Huffman code is zero */
+  p = v;                        /* grab values in bit order */
+  h = -1;                       /* no tables yet--level -1 */
+  w = -l;                       /* bits decoded == (l * h) */
+  u[0] = (inflate_huft *)Z_NULL;        /* just to keep compilers happy */
+  q = (inflate_huft *)Z_NULL;   /* ditto */
+  z = 0;                        /* ditto */
+
+  /* go through the bit lengths (k already is bits in shortest code) */
+  for (; k <= g; k++)
+  {
+    a = c[k];
+    while (a--)
+    {
+      /* here i is the Huffman code of length k bits for value *p */
+      /* make tables up to required level */
+      while (k > w + l)
+      {
+        h++;
+        w += l;                 /* previous table always l bits */
+
+        /* compute minimum size table less than or equal to l bits */
+        z = g - w;
+        z = z > (uInt)l ? l : z;        /* table size upper limit */
+        if ((f = 1 << (j = k - w)) > a + 1)     /* try a k-w bit table */
+        {                       /* too few codes for k-w bit table */
+          f -= a + 1;           /* deduct codes from patterns left */
+          xp = c + k;
+          if (j < z)
+            while (++j < z)     /* try smaller tables up to z bits */
+            {
+              if ((f <<= 1) <= *++xp)
+                break;          /* enough codes to use up j bits */
+              f -= *xp;         /* else deduct codes from patterns */
+            }
+        }
+        z = 1 << j;             /* table entries for j-bit table */
+
+        /* allocate new table */
+        if (*hn + z > MANY)     /* (note: doesn't matter for fixed) */
+          return Z_DATA_ERROR;  /* overflow of MANY */
+        u[h] = q = hp + *hn;
+        *hn += z;
+
+        /* connect to last table, if there is one */
+        if (h)
+        {
+          x[h] = i;             /* save pattern for backing up */
+          r.bits = (Byte)l;     /* bits to dump before this table */
+          r.exop = (Byte)j;     /* bits in this table */
+          j = i >> (w - l);
+          r.base = (uInt)(q - u[h-1] - j);   /* offset to this table */
+          u[h-1][j] = r;        /* connect to last table */
+        }
+        else
+          *t = q;               /* first table is returned result */
+      }
+
+      /* set up table entry in r */
+      r.bits = (Byte)(k - w);
+      if (p >= v + n)
+        r.exop = 128 + 64;      /* out of values--invalid code */
+      else if (*p < s)
+      {
+        r.exop = (Byte)(*p < 256 ? 0 : 32 + 64);     /* 256 is end-of-block */
+        r.base = *p++;          /* simple code is just the value */
+      }
+      else
+      {
+        r.exop = (Byte)(e[*p - s] + 16 + 64);/* non-simple--look up in lists */
+        r.base = d[*p++ - s];
+      }
+
+      /* fill code-like entries with r */
+      f = 1 << (k - w);
+      for (j = i >> w; j < z; j += f)
+        q[j] = r;
+
+      /* backwards increment the k-bit code i */
+      for (j = 1 << (k - 1); i & j; j >>= 1)
+        i ^= j;
+      i ^= j;
+
+      /* backup over finished tables */
+      mask = (1 << w) - 1;      /* needed on HP, cc -O bug */
+      while ((i & mask) != x[h])
+      {
+        h--;                    /* don't need to update q */
+        w -= l;
+        mask = (1 << w) - 1;
+      }
+    }
+  }
+
+
+  /* Return Z_BUF_ERROR if we were given an incomplete table */
+  return y != 0 && g != 1 ? Z_BUF_ERROR : Z_OK;
+}
+
+
+int inflate_trees_bits(c, bb, tb, hp, z)
+uIntf *c;               /* 19 code lengths */
+uIntf *bb;              /* bits tree desired/actual depth */
+inflate_huft * FAR *tb; /* bits tree result */
+inflate_huft *hp;       /* space for trees */
+z_streamp z;            /* for messages */
+{
+  int r;
+  uInt hn = 0;          /* hufts used in space */
+  uIntf *v;             /* work area for huft_build */
+
+  if ((v = (uIntf*)ZALLOC(z, 19, sizeof(uInt))) == Z_NULL)
+    return Z_MEM_ERROR;
+  r = huft_build(c, 19, 19, (uIntf*)Z_NULL, (uIntf*)Z_NULL,
+                 tb, bb, hp, &hn, v);
+  if (r == Z_DATA_ERROR)
+    z->msg = (char*)"oversubscribed dynamic bit lengths tree";
+  else if (r == Z_BUF_ERROR || *bb == 0)
+  {
+    z->msg = (char*)"incomplete dynamic bit lengths tree";
+    r = Z_DATA_ERROR;
+  }
+  ZFREE(z, v);
+  return r;
+}
+
+
+int inflate_trees_dynamic(nl, nd, c, bl, bd, tl, td, hp, z)
+uInt nl;                /* number of literal/length codes */
+uInt nd;                /* number of distance codes */
+uIntf *c;               /* that many (total) code lengths */
+uIntf *bl;              /* literal desired/actual bit depth */
+uIntf *bd;              /* distance desired/actual bit depth */
+inflate_huft * FAR *tl; /* literal/length tree result */
+inflate_huft * FAR *td; /* distance tree result */
+inflate_huft *hp;       /* space for trees */
+z_streamp z;            /* for messages */
+{
+  int r;
+  uInt hn = 0;          /* hufts used in space */
+  uIntf *v;             /* work area for huft_build */
+
+  /* allocate work area */
+  if ((v = (uIntf*)ZALLOC(z, 288, sizeof(uInt))) == Z_NULL)
+    return Z_MEM_ERROR;
+
+  /* build literal/length tree */
+  r = huft_build(c, nl, 257, cplens, cplext, tl, bl, hp, &hn, v);
+  if (r != Z_OK || *bl == 0)
+  {
+    if (r == Z_DATA_ERROR)
+      z->msg = (char*)"oversubscribed literal/length tree";
+    else if (r != Z_MEM_ERROR)
+    {
+      z->msg = (char*)"incomplete literal/length tree";
+      r = Z_DATA_ERROR;
+    }
+    ZFREE(z, v);
+    return r;
+  }
+
+  /* build distance tree */
+  r = huft_build(c + nl, nd, 0, cpdist, cpdext, td, bd, hp, &hn, v);
+  if (r != Z_OK || (*bd == 0 && nl > 257))
+  {
+    if (r == Z_DATA_ERROR)
+      z->msg = (char*)"oversubscribed distance tree";
+    else if (r == Z_BUF_ERROR) {
+#ifdef PKZIP_BUG_WORKAROUND
+      r = Z_OK;
+    }
+#else
+      z->msg = (char*)"incomplete distance tree";
+      r = Z_DATA_ERROR;
+    }
+    else if (r != Z_MEM_ERROR)
+    {
+      z->msg = (char*)"empty distance tree with lengths";
+      r = Z_DATA_ERROR;
+    }
+    ZFREE(z, v);
+    return r;
+#endif
+  }
+
+  /* done */
+  ZFREE(z, v);
+  return Z_OK;
+}
+
+
+/* build fixed tables only once--keep them here */
+#ifdef BUILDFIXED
+local int fixed_built = 0;
+#define FIXEDH 544      /* number of hufts used by fixed tables */
+local inflate_huft fixed_mem[FIXEDH];
+local uInt fixed_bl;
+local uInt fixed_bd;
+local inflate_huft *fixed_tl;
+local inflate_huft *fixed_td;
+#else
+#include "inffixed.h"
+#endif
+
+
+int inflate_trees_fixed(bl, bd, tl, td, z)
+uIntf *bl;               /* literal desired/actual bit depth */
+uIntf *bd;               /* distance desired/actual bit depth */
+inflate_huft * FAR *tl;  /* literal/length tree result */
+inflate_huft * FAR *td;  /* distance tree result */
+z_streamp z;             /* for memory allocation */
+{
+#ifdef BUILDFIXED
+  /* build fixed tables if not already */
+  if (!fixed_built)
+  {
+    int k;              /* temporary variable */
+    uInt f = 0;         /* number of hufts used in fixed_mem */
+    uIntf *c;           /* length list for huft_build */
+    uIntf *v;           /* work area for huft_build */
+
+    /* allocate memory */
+    if ((c = (uIntf*)ZALLOC(z, 288, sizeof(uInt))) == Z_NULL)
+      return Z_MEM_ERROR;
+    if ((v = (uIntf*)ZALLOC(z, 288, sizeof(uInt))) == Z_NULL)
+    {
+      ZFREE(z, c);
+      return Z_MEM_ERROR;
+    }
+
+    /* literal table */
+    for (k = 0; k < 144; k++)
+      c[k] = 8;
+    for (; k < 256; k++)
+      c[k] = 9;
+    for (; k < 280; k++)
+      c[k] = 7;
+    for (; k < 288; k++)
+      c[k] = 8;
+    fixed_bl = 9;
+    huft_build(c, 288, 257, cplens, cplext, &fixed_tl, &fixed_bl,
+               fixed_mem, &f, v);
+
+    /* distance table */
+    for (k = 0; k < 30; k++)
+      c[k] = 5;
+    fixed_bd = 5;
+    huft_build(c, 30, 0, cpdist, cpdext, &fixed_td, &fixed_bd,
+               fixed_mem, &f, v);
+
+    /* done */
+    ZFREE(z, v);
+    ZFREE(z, c);
+    fixed_built = 1;
+  }
+#endif
+  *bl = fixed_bl;
+  *bd = fixed_bd;
+  *tl = fixed_tl;
+  *td = fixed_td;
+  return Z_OK;
+}
diff --git a/src/unix/contrib/cutzlib-1.1.4/inftrees.h b/src/unix/contrib/cutzlib-1.1.4/inftrees.h
new file mode 100644
index 0000000..04b73b7
--- /dev/null
+++ b/src/unix/contrib/cutzlib-1.1.4/inftrees.h
@@ -0,0 +1,58 @@
+/* inftrees.h -- header to use inftrees.c
+ * Copyright (C) 1995-2002 Mark Adler
+ * For conditions of distribution and use, see copyright notice in zlib.h 
+ */
+
+/* WARNING: this file should *not* be used by applications. It is
+   part of the implementation of the compression library and is
+   subject to change. Applications should only use zlib.h.
+ */
+
+/* Huffman code lookup table entry--this entry is four bytes for machines
+   that have 16-bit pointers (e.g. PC's in the small or medium model). */
+
+typedef struct inflate_huft_s FAR inflate_huft;
+
+struct inflate_huft_s {
+  union {
+    struct {
+      Byte Exop;        /* number of extra bits or operation */
+      Byte Bits;        /* number of bits in this code or subcode */
+    } what;
+    uInt pad;           /* pad structure to a power of 2 (4 bytes for */
+  } word;               /*  16-bit, 8 bytes for 32-bit int's) */
+  uInt base;            /* literal, length base, distance base,
+                           or table offset */
+};
+
+/* Maximum size of dynamic tree.  The maximum found in a long but non-
+   exhaustive search was 1004 huft structures (850 for length/literals
+   and 154 for distances, the latter actually the result of an
+   exhaustive search).  The actual maximum is not known, but the
+   value below is more than safe. */
+#define MANY 1440
+
+extern int inflate_trees_bits OF((
+    uIntf *,                    /* 19 code lengths */
+    uIntf *,                    /* bits tree desired/actual depth */
+    inflate_huft * FAR *,       /* bits tree result */
+    inflate_huft *,             /* space for trees */
+    z_streamp));                /* for messages */
+
+extern int inflate_trees_dynamic OF((
+    uInt,                       /* number of literal/length codes */
+    uInt,                       /* number of distance codes */
+    uIntf *,                    /* that many (total) code lengths */
+    uIntf *,                    /* literal desired/actual bit depth */
+    uIntf *,                    /* distance desired/actual bit depth */
+    inflate_huft * FAR *,       /* literal/length tree result */
+    inflate_huft * FAR *,       /* distance tree result */
+    inflate_huft *,             /* space for trees */
+    z_streamp));                /* for messages */
+
+extern int inflate_trees_fixed OF((
+    uIntf *,                    /* literal desired/actual bit depth */
+    uIntf *,                    /* distance desired/actual bit depth */
+    inflate_huft * FAR *,       /* literal/length tree result */
+    inflate_huft * FAR *,       /* distance tree result */
+    z_streamp));                /* for memory allocation */
diff --git a/src/unix/contrib/cutzlib-1.1.4/infutil.c b/src/unix/contrib/cutzlib-1.1.4/infutil.c
new file mode 100644
index 0000000..9a07622
--- /dev/null
+++ b/src/unix/contrib/cutzlib-1.1.4/infutil.c
@@ -0,0 +1,87 @@
+/* inflate_util.c -- data and routines common to blocks and codes
+ * Copyright (C) 1995-2002 Mark Adler
+ * For conditions of distribution and use, see copyright notice in zlib.h 
+ */
+
+#include "zutil.h"
+#include "infblock.h"
+#include "inftrees.h"
+#include "infcodes.h"
+#include "infutil.h"
+
+struct inflate_codes_state {int dummy;}; /* for buggy compilers */
+
+/* And'ing with mask[n] masks the lower n bits */
+uInt inflate_mask[17] = {
+    0x0000,
+    0x0001, 0x0003, 0x0007, 0x000f, 0x001f, 0x003f, 0x007f, 0x00ff,
+    0x01ff, 0x03ff, 0x07ff, 0x0fff, 0x1fff, 0x3fff, 0x7fff, 0xffff
+};
+
+
+/* copy as much as possible from the sliding window to the output area */
+int inflate_flush(s, z, r)
+inflate_blocks_statef *s;
+z_streamp z;
+int r;
+{
+  uInt n;
+  Bytef *p;
+  Bytef *q;
+
+  /* local copies of source and destination pointers */
+  p = z->next_out;
+  q = s->read;
+
+  /* compute number of bytes to copy as far as end of window */
+  n = (uInt)((q <= s->write ? s->write : s->end) - q);
+  if (n > z->avail_out) n = z->avail_out;
+  if (n && r == Z_BUF_ERROR) r = Z_OK;
+
+  /* update counters */
+  z->avail_out -= n;
+  z->total_out += n;
+
+  /* update check information */
+  if (s->checkfn != Z_NULL)
+    z->adler = s->check = (*s->checkfn)(s->check, q, n);
+
+  /* copy as far as end of window */
+  zmemcpy(p, q, n);
+  p += n;
+  q += n;
+
+  /* see if more to copy at beginning of window */
+  if (q == s->end)
+  {
+    /* wrap pointers */
+    q = s->window;
+    if (s->write == s->end)
+      s->write = s->window;
+
+    /* compute bytes to copy */
+    n = (uInt)(s->write - q);
+    if (n > z->avail_out) n = z->avail_out;
+    if (n && r == Z_BUF_ERROR) r = Z_OK;
+
+    /* update counters */
+    z->avail_out -= n;
+    z->total_out += n;
+
+    /* update check information */
+    if (s->checkfn != Z_NULL)
+      z->adler = s->check = (*s->checkfn)(s->check, q, n);
+
+    /* copy */
+    zmemcpy(p, q, n);
+    p += n;
+    q += n;
+  }
+
+  /* update pointers */
+  z->next_out = p;
+  s->read = q;
+
+  /* done */
+  return r;
+}
diff --git a/src/unix/contrib/cutzlib-1.1.4/infutil.h b/src/unix/contrib/cutzlib-1.1.4/infutil.h
new file mode 100644
index 0000000..4401df8
--- /dev/null
+++ b/src/unix/contrib/cutzlib-1.1.4/infutil.h
@@ -0,0 +1,98 @@
+/* infutil.h -- types and macros common to blocks and codes
+ * Copyright (C) 1995-2002 Mark Adler
+ * For conditions of distribution and use, see copyright notice in zlib.h 
+ */
+
+/* WARNING: this file should *not* be used by applications. It is
+   part of the implementation of the compression library and is
+   subject to change. Applications should only use zlib.h.
+ */
+
+#ifndef _INFUTIL_H
+#define _INFUTIL_H
+
+typedef enum {
+      TYPE,     /* get type bits (3, including end bit) */
+      LENS,     /* get lengths for stored */
+      STORED,   /* processing stored block */
+      TABLE,    /* get table lengths */
+      BTREE,    /* get bit lengths tree for a dynamic block */
+      DTREE,    /* get length, distance trees for a dynamic block */
+      CODES,    /* processing fixed or dynamic block */
+      DRY,      /* output remaining window bytes */
+      DONE,     /* finished last block, done */
+      BAD}      /* got a data error--stuck here */
+inflate_block_mode;
+
+/* inflate blocks semi-private state */
+struct inflate_blocks_state {
+
+  /* mode */
+  inflate_block_mode  mode;     /* current inflate_block mode */
+
+  /* mode dependent information */
+  union {
+    uInt left;          /* if STORED, bytes left to copy */
+    struct {
+      uInt table;               /* table lengths (14 bits) */
+      uInt index;               /* index into blens (or border) */
+      uIntf *blens;             /* bit lengths of codes */
+      uInt bb;                  /* bit length tree depth */
+      inflate_huft *tb;         /* bit length decoding tree */
+    } trees;            /* if DTREE, decoding info for trees */
+    struct {
+      inflate_codes_statef 
+         *codes;
+    } decode;           /* if CODES, current state */
+  } sub;                /* submode */
+  uInt last;            /* true if this block is the last block */
+
+  /* mode independent information */
+  uInt bitk;            /* bits in bit buffer */
+  uLong bitb;           /* bit buffer */
+  inflate_huft *hufts;  /* single malloc for tree space */
+  Bytef *window;        /* sliding window */
+  Bytef *end;           /* one byte after sliding window */
+  Bytef *read;          /* window read pointer */
+  Bytef *write;         /* window write pointer */
+  check_func checkfn;   /* check function */
+  uLong check;          /* check on output */
+
+};
+
+
+/* defines for inflate input/output */
+/*   update pointers and return */
+#define UPDBITS {s->bitb=b;s->bitk=k;}
+#define UPDIN {z->avail_in=n;z->total_in+=p-z->next_in;z->next_in=p;}
+#define UPDOUT {s->write=q;}
+#define UPDATE {UPDBITS UPDIN UPDOUT}
+#define LEAVE {UPDATE return inflate_flush(s,z,r);}
+/*   get bytes and bits */
+#define LOADIN {p=z->next_in;n=z->avail_in;b=s->bitb;k=s->bitk;}
+#define NEEDBYTE {if(n)r=Z_OK;else LEAVE}
+#define NEXTBYTE (n--,*p++)
+#define NEEDBITS(j) {while(k<(j)){NEEDBYTE;b|=((uLong)NEXTBYTE)<<k;k+=8;}}
+#define DUMPBITS(j) {b>>=(j);k-=(j);}
+/*   output bytes */
+#define WAVAIL (uInt)(q<s->read?s->read-q-1:s->end-q)
+#define LOADOUT {q=s->write;m=(uInt)WAVAIL;}
+#define WRAP {if(q==s->end&&s->read!=s->window){q=s->window;m=(uInt)WAVAIL;}}
+#define FLUSH {UPDOUT r=inflate_flush(s,z,r); LOADOUT}
+#define NEEDOUT {if(m==0){WRAP if(m==0){FLUSH WRAP if(m==0) LEAVE}}r=Z_OK;}
+#define OUTBYTE(a) {*q++=(Byte)(a);m--;}
+/*   load local pointers */
+#define LOAD {LOADIN LOADOUT}
+
+/* masks for lower bits (size given to avoid silly warnings with Visual C++) */
+extern uInt inflate_mask[17];
+
+/* copy as much as possible from the sliding window to the output area */
+extern int inflate_flush OF((
+    inflate_blocks_statef *,
+    z_streamp ,
+    int));
+
+struct internal_state      {int dummy;}; /* for buggy compilers */
+
+#endif
diff --git a/src/unix/contrib/cutzlib-1.1.4/maketree.c b/src/unix/contrib/cutzlib-1.1.4/maketree.c
new file mode 100644
index 0000000..a16d4b1
--- /dev/null
+++ b/src/unix/contrib/cutzlib-1.1.4/maketree.c
@@ -0,0 +1,85 @@
+/* maketree.c -- make inffixed.h table for decoding fixed codes
+ * Copyright (C) 1995-2002 Mark Adler
+ * For conditions of distribution and use, see copyright notice in zlib.h 
+ */
+
+/* WARNING: this file should *not* be used by applications. It is
+   part of the implementation of the compression library and is
+   subject to change. Applications should only use zlib.h.
+ */
+
+/* This program is included in the distribution for completeness.
+   You do not need to compile or run this program since inffixed.h
+   is already included in the distribution.  To use this program
+   you need to compile zlib with BUILDFIXED defined and then compile
+   and link this program with the zlib library.  Then the output of
+   this program can be piped to inffixed.h. */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include "zutil.h"
+#include "inftrees.h"
+
+/* simplify the use of the inflate_huft type with some defines */
+#define exop word.what.Exop
+#define bits word.what.Bits
+
+/* generate initialization table for an inflate_huft structure array */
+void maketree(uInt b, inflate_huft *t)
+{
+  int i, e;
+
+  i = 0;
+  while (1)
+  {
+    e = t[i].exop;
+    if (e && (e & (16+64)) == 0)        /* table pointer */
+    {
+      fprintf(stderr, "maketree: cannot initialize sub-tables!\n");
+      exit(1);
+    }
+    if (i % 4 == 0)
+      printf("\n   ");
+    printf(" {{{%u,%u}},%u}", t[i].exop, t[i].bits, t[i].base);
+    if (++i == (1<<b))
+      break;
+    putchar(',');
+  }
+  puts("");
+}
+
+/* create the fixed tables in C initialization syntax */
+void main(void)
+{
+  int r;
+  uInt bl, bd;
+  inflate_huft *tl, *td;
+  z_stream z;
+
+  z.zalloc = zcalloc;
+  z.opaque = (voidpf)0;
+  z.zfree = zcfree;
+  r = inflate_trees_fixed(&bl, &bd, &tl, &td, &z);
+  if (r)
+  {
+    fprintf(stderr, "inflate_trees_fixed error %d\n", r);
+    return;
+  }
+  puts("/* inffixed.h -- table for decoding fixed codes");
+  puts(" * Generated automatically by the maketree.c program");
+  puts(" */");
+  puts("");
+  puts("/* WARNING: this file should *not* be used by applications. It is");
+  puts("   part of the implementation of the compression library and is");
+  puts("   subject to change. Applications should only use zlib.h.");
+  puts(" */");
+  puts("");
+  printf("local uInt fixed_bl = %d;\n", bl);
+  printf("local uInt fixed_bd = %d;\n", bd);
+  printf("local inflate_huft fixed_tl[] = {");
+  maketree(bl, tl);
+  puts("  };");
+  printf("local inflate_huft fixed_td[] = {");
+  maketree(bd, td);
+  puts("  };");
+}
diff --git a/src/unix/contrib/cutzlib-1.1.4/trees.c b/src/unix/contrib/cutzlib-1.1.4/trees.c
new file mode 100644
index 0000000..ca226ea
--- /dev/null
+++ b/src/unix/contrib/cutzlib-1.1.4/trees.c
@@ -0,0 +1,1214 @@
+/* trees.c -- output deflated data using Huffman coding
+ * Copyright (C) 1995-2002 Jean-loup Gailly
+ * For conditions of distribution and use, see copyright notice in zlib.h 
+ */
+
+/*
+ *  ALGORITHM
+ *
+ *      The "deflation" process uses several Huffman trees. The more
+ *      common source values are represented by shorter bit sequences.
+ *
+ *      Each code tree is stored in a compressed form which is itself
+ * a Huffman encoding of the lengths of all the code strings (in
+ * ascending order by source values).  The actual code strings are
+ * reconstructed from the lengths in the inflate process, as described
+ * in the deflate specification.
+ *
+ *  REFERENCES
+ *
+ *      Deutsch, L.P.,"'Deflate' Compressed Data Format Specification".
+ *      Available in ftp.uu.net:/pub/archiving/zip/doc/deflate-1.1.doc
+ *
+ *      Storer, James A.
+ *          Data Compression:  Methods and Theory, pp. 49-50.
+ *          Computer Science Press, 1988.  ISBN 0-7167-8156-5.
+ *
+ *      Sedgewick, R.
+ *          Algorithms, p290.
+ *          Addison-Wesley, 1983. ISBN 0-201-06672-6.
+ */
+
+/* @(#) $Id: trees.c,v 1.1 2002/04/18 21:15:08 l_g Exp $ */
+
+/* #define GEN_TREES_H */
+
+#include "deflate.h"
+
+#ifdef DEBUG
+#  include <ctype.h>
+#endif
+
+/* ===========================================================================
+ * Constants
+ */
+
+#define MAX_BL_BITS 7
+/* Bit length codes must not exceed MAX_BL_BITS bits */
+
+#define END_BLOCK 256
+/* end of block literal code */
+
+#define REP_3_6      16
+/* repeat previous bit length 3-6 times (2 bits of repeat count) */
+
+#define REPZ_3_10    17
+/* repeat a zero length 3-10 times  (3 bits of repeat count) */
+
+#define REPZ_11_138  18
+/* repeat a zero length 11-138 times  (7 bits of repeat count) */
+
+local const int extra_lbits[LENGTH_CODES] /* extra bits for each length code */
+   = {0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0};
+
+local const int extra_dbits[D_CODES] /* extra bits for each distance code */
+   = {0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13};
+
+local const int extra_blbits[BL_CODES]/* extra bits for each bit length code */
+   = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7};
+
+local const uch bl_order[BL_CODES]
+   = {16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15};
+/* The lengths of the bit length codes are sent in order of decreasing
+ * probability, to avoid transmitting the lengths for unused bit length codes.
+ */
+
+#define Buf_size (8 * 2*sizeof(char))
+/* Number of bits used within bi_buf. (bi_buf might be implemented on
+ * more than 16 bits on some systems.)
+ */
+
+/* ===========================================================================
+ * Local data. These are initialized only once.
+ */
+
+#define DIST_CODE_LEN  512 /* see definition of array dist_code below */
+
+#if defined(GEN_TREES_H) || !defined(STDC)
+/* non ANSI compilers may not accept trees.h */
+
+local ct_data static_ltree[L_CODES+2];
+/* The static literal tree. Since the bit lengths are imposed, there is no
+ * need for the L_CODES extra codes used during heap construction. However
+ * The codes 286 and 287 are needed to build a canonical tree (see _tr_init
+ * below).
+ */
+
+local ct_data static_dtree[D_CODES];
+/* The static distance tree. (Actually a trivial tree since all codes use
+ * 5 bits.)
+ */
+
+uch _dist_code[DIST_CODE_LEN];
+/* Distance codes. The first 256 values correspond to the distances
+ * 3 .. 258, the last 256 values correspond to the top 8 bits of
+ * the 15 bit distances.
+ */
+
+uch _length_code[MAX_MATCH-MIN_MATCH+1];
+/* length code for each normalized match length (0 == MIN_MATCH) */
+
+local int base_length[LENGTH_CODES];
+/* First normalized length for each code (0 = MIN_MATCH) */
+
+local int base_dist[D_CODES];
+/* First normalized distance for each code (0 = distance of 1) */
+
+#else
+#  include "trees.h"
+#endif /* GEN_TREES_H */
+
+struct static_tree_desc_s {
+    const ct_data *static_tree;  /* static tree or NULL */
+    const intf *extra_bits;      /* extra bits for each code or NULL */
+    int     extra_base;          /* base index for extra_bits */
+    int     elems;               /* max number of elements in the tree */
+    int     max_length;          /* max bit length for the codes */
+};
+
+local static_tree_desc  static_l_desc =
+{static_ltree, extra_lbits, LITERALS+1, L_CODES, MAX_BITS};
+
+local static_tree_desc  static_d_desc =
+{static_dtree, extra_dbits, 0,          D_CODES, MAX_BITS};
+
+local static_tree_desc  static_bl_desc =
+{(const ct_data *)0, extra_blbits, 0,   BL_CODES, MAX_BL_BITS};
+
+/* ===========================================================================
+ * Local (static) routines in this file.
+ */
+
+local void tr_static_init OF((void));
+local void init_block     OF((deflate_state *s));
+local void pqdownheap     OF((deflate_state *s, ct_data *tree, int k));
+local void gen_bitlen     OF((deflate_state *s, tree_desc *desc));
+local void gen_codes      OF((ct_data *tree, int max_code, ushf *bl_count));
+local void build_tree     OF((deflate_state *s, tree_desc *desc));
+local void scan_tree      OF((deflate_state *s, ct_data *tree, int max_code));
+local void send_tree      OF((deflate_state *s, ct_data *tree, int max_code));
+local int  build_bl_tree  OF((deflate_state *s));
+local void send_all_trees OF((deflate_state *s, int lcodes, int dcodes,
+                              int blcodes));
+local void compress_block OF((deflate_state *s, ct_data *ltree,
+                              ct_data *dtree));
+local void set_data_type  OF((deflate_state *s));
+local unsigned bi_reverse OF((unsigned value, int length));
+local void bi_windup      OF((deflate_state *s));
+local void bi_flush       OF((deflate_state *s));
+local void copy_block     OF((deflate_state *s, charf *buf, unsigned len,
+                              int header));
+
+#ifdef GEN_TREES_H
+local void gen_trees_header OF((void));
+#endif
+
+#ifndef DEBUG
+#  define send_code(s, c, tree) send_bits(s, tree[c].Code, tree[c].Len)
+   /* Send a code of the given tree. c and tree must not have side effects */
+
+#else /* DEBUG */
+#  define send_code(s, c, tree) \
+     { if (z_verbose>2) fprintf(stderr,"\ncd %3d ",(c)); \
+       send_bits(s, tree[c].Code, tree[c].Len); }
+#endif
+
+/* ===========================================================================
+ * Output a short LSB first on the stream.
+ * IN assertion: there is enough room in pendingBuf.
+ */
+#define put_short(s, w) { \
+    put_byte(s, (uch)((w) & 0xff)); \
+    put_byte(s, (uch)((ush)(w) >> 8)); \
+}
+
+/* ===========================================================================
+ * Send a value on a given number of bits.
+ * IN assertion: length <= 16 and value fits in length bits.
+ */
+#ifdef DEBUG
+local void send_bits      OF((deflate_state *s, int value, int length));
+
+local void send_bits(s, value, length)
+    deflate_state *s;
+    int value;  /* value to send */
+    int length; /* number of bits */
+{
+    Tracevv((stderr," l %2d v %4x ", length, value));
+    Assert(length > 0 && length <= 15, "invalid length");
+    s->bits_sent += (ulg)length;
+
+    /* If not enough room in bi_buf, use (valid) bits from bi_buf and
+     * (16 - bi_valid) bits from value, leaving (width - (16-bi_valid))
+     * unused bits in value.
+     */
+    if (s->bi_valid > (int)Buf_size - length) {
+        s->bi_buf |= (value << s->bi_valid);
+        put_short(s, s->bi_buf);
+        s->bi_buf = (ush)value >> (Buf_size - s->bi_valid);
+        s->bi_valid += length - Buf_size;
+    } else {
+        s->bi_buf |= value << s->bi_valid;
+        s->bi_valid += length;
+    }
+}
+#else /* !DEBUG */
+
+#define send_bits(s, value, length) \
+{ int len = length;\
+  if (s->bi_valid > (int)Buf_size - len) {\
+    int val = value;\
+    s->bi_buf |= (val << s->bi_valid);\
+    put_short(s, s->bi_buf);\
+    s->bi_buf = (ush)val >> (Buf_size - s->bi_valid);\
+    s->bi_valid += len - Buf_size;\
+  } else {\
+    s->bi_buf |= (value) << s->bi_valid;\
+    s->bi_valid += len;\
+  }\
+}
+#endif /* DEBUG */
+
+
+#define MAX(a,b) (a >= b ? a : b)
+/* the arguments must not have side effects */
+
+/* ===========================================================================
+ * Initialize the various 'constant' tables.
+ */
+local void tr_static_init()
+{
+#if defined(GEN_TREES_H) || !defined(STDC)
+    static int static_init_done = 0;
+    int n;        /* iterates over tree elements */
+    int bits;     /* bit counter */
+    int length;   /* length value */
+    int code;     /* code value */
+    int dist;     /* distance index */
+    ush bl_count[MAX_BITS+1];
+    /* number of codes at each bit length for an optimal tree */
+
+    if (static_init_done) return;
+
+    /* For some embedded targets, global variables are not initialized: */
+    static_l_desc.static_tree = static_ltree;
+    static_l_desc.extra_bits = extra_lbits;
+    static_d_desc.static_tree = static_dtree;
+    static_d_desc.extra_bits = extra_dbits;
+    static_bl_desc.extra_bits = extra_blbits;
+
+    /* Initialize the mapping length (0..255) -> length code (0..28) */
+    length = 0;
+    for (code = 0; code < LENGTH_CODES-1; code++) {
+        base_length[code] = length;
+        for (n = 0; n < (1<<extra_lbits[code]); n++) {
+            _length_code[length++] = (uch)code;
+        }
+    }
+    Assert (length == 256, "tr_static_init: length != 256");
+    /* Note that the length 255 (match length 258) can be represented
+     * in two different ways: code 284 + 5 bits or code 285, so we
+     * overwrite length_code[255] to use the best encoding:
+     */
+    _length_code[length-1] = (uch)code;
+
+    /* Initialize the mapping dist (0..32K) -> dist code (0..29) */
+    dist = 0;
+    for (code = 0 ; code < 16; code++) {
+        base_dist[code] = dist;
+        for (n = 0; n < (1<<extra_dbits[code]); n++) {
+            _dist_code[dist++] = (uch)code;
+        }
+    }
+    Assert (dist == 256, "tr_static_init: dist != 256");
+    dist >>= 7; /* from now on, all distances are divided by 128 */
+    for ( ; code < D_CODES; code++) {
+        base_dist[code] = dist << 7;
+        for (n = 0; n < (1<<(extra_dbits[code]-7)); n++) {
+            _dist_code[256 + dist++] = (uch)code;
+        }
+    }
+    Assert (dist == 256, "tr_static_init: 256+dist != 512");
+
+    /* Construct the codes of the static literal tree */
+    for (bits = 0; bits <= MAX_BITS; bits++) bl_count[bits] = 0;
+    n = 0;
+    while (n <= 143) static_ltree[n++].Len = 8, bl_count[8]++;
+    while (n <= 255) static_ltree[n++].Len = 9, bl_count[9]++;
+    while (n <= 279) static_ltree[n++].Len = 7, bl_count[7]++;
+    while (n <= 287) static_ltree[n++].Len = 8, bl_count[8]++;
+    /* Codes 286 and 287 do not exist, but we must include them in the
+     * tree construction to get a canonical Huffman tree (longest code
+     * all ones)
+     */
+    gen_codes((ct_data *)static_ltree, L_CODES+1, bl_count);
+
+    /* The static distance tree is trivial: */
+    for (n = 0; n < D_CODES; n++) {
+        static_dtree[n].Len = 5;
+        static_dtree[n].Code = bi_reverse((unsigned)n, 5);
+    }
+    static_init_done = 1;
+
+#  ifdef GEN_TREES_H
+    gen_trees_header();
+#  endif
+#endif /* defined(GEN_TREES_H) || !defined(STDC) */
+}
+
+/* ===========================================================================
+ * Genererate the file trees.h describing the static trees.
+ */
+#ifdef GEN_TREES_H
+#  ifndef DEBUG
+#    include <stdio.h>
+#  endif
+
+#  define SEPARATOR(i, last, width) \
+      ((i) == (last)? "\n};\n\n" :    \
+       ((i) % (width) == (width)-1 ? ",\n" : ", "))
+
+void gen_trees_header()
+{
+    FILE *header = fopen("trees.h", "w");
+    int i;
+
+    Assert (header != NULL, "Can't open trees.h");
+    fprintf(header,
+	    "/* header created automatically with -DGEN_TREES_H */\n\n");
+
+    fprintf(header, "local const ct_data static_ltree[L_CODES+2] = {\n");
+    for (i = 0; i < L_CODES+2; i++) {
+	fprintf(header, "{{%3u},{%3u}}%s", static_ltree[i].Code,
+		static_ltree[i].Len, SEPARATOR(i, L_CODES+1, 5));
+    }
+
+    fprintf(header, "local const ct_data static_dtree[D_CODES] = {\n");
+    for (i = 0; i < D_CODES; i++) {
+	fprintf(header, "{{%2u},{%2u}}%s", static_dtree[i].Code,
+		static_dtree[i].Len, SEPARATOR(i, D_CODES-1, 5));
+    }
+
+    fprintf(header, "const uch _dist_code[DIST_CODE_LEN] = {\n");
+    for (i = 0; i < DIST_CODE_LEN; i++) {
+	fprintf(header, "%2u%s", _dist_code[i],
+		SEPARATOR(i, DIST_CODE_LEN-1, 20));
+    }
+
+    fprintf(header, "const uch _length_code[MAX_MATCH-MIN_MATCH+1]= {\n");
+    for (i = 0; i < MAX_MATCH-MIN_MATCH+1; i++) {
+	fprintf(header, "%2u%s", _length_code[i],
+		SEPARATOR(i, MAX_MATCH-MIN_MATCH, 20));
+    }
+
+    fprintf(header, "local const int base_length[LENGTH_CODES] = {\n");
+    for (i = 0; i < LENGTH_CODES; i++) {
+	fprintf(header, "%1u%s", base_length[i],
+		SEPARATOR(i, LENGTH_CODES-1, 20));
+    }
+
+    fprintf(header, "local const int base_dist[D_CODES] = {\n");
+    for (i = 0; i < D_CODES; i++) {
+	fprintf(header, "%5u%s", base_dist[i],
+		SEPARATOR(i, D_CODES-1, 10));
+    }
+
+    fclose(header);
+}
+#endif /* GEN_TREES_H */
+
+/* ===========================================================================
+ * Initialize the tree data structures for a new zlib stream.
+ */
+void _tr_init(s)
+    deflate_state *s;
+{
+    tr_static_init();
+
+    s->l_desc.dyn_tree = s->dyn_ltree;
+    s->l_desc.stat_desc = &static_l_desc;
+
+    s->d_desc.dyn_tree = s->dyn_dtree;
+    s->d_desc.stat_desc = &static_d_desc;
+
+    s->bl_desc.dyn_tree = s->bl_tree;
+    s->bl_desc.stat_desc = &static_bl_desc;
+
+    s->bi_buf = 0;
+    s->bi_valid = 0;
+    s->last_eob_len = 8; /* enough lookahead for inflate */
+#ifdef DEBUG
+    s->compressed_len = 0L;
+    s->bits_sent = 0L;
+#endif
+
+    /* Initialize the first block of the first file: */
+    init_block(s);
+}
+
+/* ===========================================================================
+ * Initialize a new block.
+ */
+local void init_block(s)
+    deflate_state *s;
+{
+    int n; /* iterates over tree elements */
+
+    /* Initialize the trees. */
+    for (n = 0; n < L_CODES;  n++) s->dyn_ltree[n].Freq = 0;
+    for (n = 0; n < D_CODES;  n++) s->dyn_dtree[n].Freq = 0;
+    for (n = 0; n < BL_CODES; n++) s->bl_tree[n].Freq = 0;
+
+    s->dyn_ltree[END_BLOCK].Freq = 1;
+    s->opt_len = s->static_len = 0L;
+    s->last_lit = s->matches = 0;
+}
+
+#define SMALLEST 1
+/* Index within the heap array of least frequent node in the Huffman tree */
+
+
+/* ===========================================================================
+ * Remove the smallest element from the heap and recreate the heap with
+ * one less element. Updates heap and heap_len.
+ */
+#define pqremove(s, tree, top) \
+{\
+    top = s->heap[SMALLEST]; \
+    s->heap[SMALLEST] = s->heap[s->heap_len--]; \
+    pqdownheap(s, tree, SMALLEST); \
+}
+
+/* ===========================================================================
+ * Compares to subtrees, using the tree depth as tie breaker when
+ * the subtrees have equal frequency. This minimizes the worst case length.
+ */
+#define smaller(tree, n, m, depth) \
+   (tree[n].Freq < tree[m].Freq || \
+   (tree[n].Freq == tree[m].Freq && depth[n] <= depth[m]))
+
+/* ===========================================================================
+ * Restore the heap property by moving down the tree starting at node k,
+ * exchanging a node with the smallest of its two sons if necessary, stopping
+ * when the heap property is re-established (each father smaller than its
+ * two sons).
+ */
+local void pqdownheap(s, tree, k)
+    deflate_state *s;
+    ct_data *tree;  /* the tree to restore */
+    int k;               /* node to move down */
+{
+    int v = s->heap[k];
+    int j = k << 1;  /* left son of k */
+    while (j <= s->heap_len) {
+        /* Set j to the smallest of the two sons: */
+        if (j < s->heap_len &&
+            smaller(tree, s->heap[j+1], s->heap[j], s->depth)) {
+            j++;
+        }
+        /* Exit if v is smaller than both sons */
+        if (smaller(tree, v, s->heap[j], s->depth)) break;
+
+        /* Exchange v with the smallest son */
+        s->heap[k] = s->heap[j];  k = j;
+
+        /* And continue down the tree, setting j to the left son of k */
+        j <<= 1;
+    }
+    s->heap[k] = v;
+}
+
+/* ===========================================================================
+ * Compute the optimal bit lengths for a tree and update the total bit length
+ * for the current block.
+ * IN assertion: the fields freq and dad are set, heap[heap_max] and
+ *    above are the tree nodes sorted by increasing frequency.
+ * OUT assertions: the field len is set to the optimal bit length, the
+ *     array bl_count contains the frequencies for each bit length.
+ *     The length opt_len is updated; static_len is also updated if stree is
+ *     not null.
+ */
+local void gen_bitlen(s, desc)
+    deflate_state *s;
+    tree_desc *desc;    /* the tree descriptor */
+{
+    ct_data *tree        = desc->dyn_tree;
+    int max_code         = desc->max_code;
+    const ct_data *stree = desc->stat_desc->static_tree;
+    const intf *extra    = desc->stat_desc->extra_bits;
+    int base             = desc->stat_desc->extra_base;
+    int max_length       = desc->stat_desc->max_length;
+    int h;              /* heap index */
+    int n, m;           /* iterate over the tree elements */
+    int bits;           /* bit length */
+    int xbits;          /* extra bits */
+    ush f;              /* frequency */
+    int overflow = 0;   /* number of elements with bit length too large */
+
+    for (bits = 0; bits <= MAX_BITS; bits++) s->bl_count[bits] = 0;
+
+    /* In a first pass, compute the optimal bit lengths (which may
+     * overflow in the case of the bit length tree).
+     */
+    tree[s->heap[s->heap_max]].Len = 0; /* root of the heap */
+
+    for (h = s->heap_max+1; h < HEAP_SIZE; h++) {
+        n = s->heap[h];
+        bits = tree[tree[n].Dad].Len + 1;
+        if (bits > max_length) bits = max_length, overflow++;
+        tree[n].Len = (ush)bits;
+        /* We overwrite tree[n].Dad which is no longer needed */
+
+        if (n > max_code) continue; /* not a leaf node */
+
+        s->bl_count[bits]++;
+        xbits = 0;
+        if (n >= base) xbits = extra[n-base];
+        f = tree[n].Freq;
+        s->opt_len += (ulg)f * (bits + xbits);
+        if (stree) s->static_len += (ulg)f * (stree[n].Len + xbits);
+    }
+    if (overflow == 0) return;
+
+    Trace((stderr,"\nbit length overflow\n"));
+    /* This happens for example on obj2 and pic of the Calgary corpus */
+
+    /* Find the first bit length which could increase: */
+    do {
+        bits = max_length-1;
+        while (s->bl_count[bits] == 0) bits--;
+        s->bl_count[bits]--;      /* move one leaf down the tree */
+        s->bl_count[bits+1] += 2; /* move one overflow item as its brother */
+        s->bl_count[max_length]--;
+        /* The brother of the overflow item also moves one step up,
+         * but this does not affect bl_count[max_length]
+         */
+        overflow -= 2;
+    } while (overflow > 0);
+
+    /* Now recompute all bit lengths, scanning in increasing frequency.
+     * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all
+     * lengths instead of fixing only the wrong ones. This idea is taken
+     * from 'ar' written by Haruhiko Okumura.)
+     */
+    for (bits = max_length; bits != 0; bits--) {
+        n = s->bl_count[bits];
+        while (n != 0) {
+            m = s->heap[--h];
+            if (m > max_code) continue;
+            if (tree[m].Len != (unsigned) bits) {
+                Trace((stderr,"code %d bits %d->%d\n", m, tree[m].Len, bits));
+                s->opt_len += ((long)bits - (long)tree[m].Len)
+                              *(long)tree[m].Freq;
+                tree[m].Len = (ush)bits;
+            }
+            n--;
+        }
+    }
+}
+
+/* ===========================================================================
+ * Generate the codes for a given tree and bit counts (which need not be
+ * optimal).
+ * IN assertion: the array bl_count contains the bit length statistics for
+ * the given tree and the field len is set for all tree elements.
+ * OUT assertion: the field code is set for all tree elements of non
+ *     zero code length.
+ */
+local void gen_codes (tree, max_code, bl_count)
+    ct_data *tree;             /* the tree to decorate */
+    int max_code;              /* largest code with non zero frequency */
+    ushf *bl_count;            /* number of codes at each bit length */
+{
+    ush next_code[MAX_BITS+1]; /* next code value for each bit length */
+    ush code = 0;              /* running code value */
+    int bits;                  /* bit index */
+    int n;                     /* code index */
+
+    /* The distribution counts are first used to generate the code values
+     * without bit reversal.
+     */
+    for (bits = 1; bits <= MAX_BITS; bits++) {
+        next_code[bits] = code = (code + bl_count[bits-1]) << 1;
+    }
+    /* Check that the bit counts in bl_count are consistent. The last code
+     * must be all ones.
+     */
+    Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,
+            "inconsistent bit counts");
+    Tracev((stderr,"\ngen_codes: max_code %d ", max_code));
+
+    for (n = 0;  n <= max_code; n++) {
+        int len = tree[n].Len;
+        if (len == 0) continue;
+        /* Now reverse the bits */
+        tree[n].Code = bi_reverse(next_code[len]++, len);
+
+        Tracecv(tree != static_ltree, (stderr,"\nn %3d %c l %2d c %4x (%x) ",
+             n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len]-1));
+    }
+}
+
+/* ===========================================================================
+ * Construct one Huffman tree and assigns the code bit strings and lengths.
+ * Update the total bit length for the current block.
+ * IN assertion: the field freq is set for all tree elements.
+ * OUT assertions: the fields len and code are set to the optimal bit length
+ *     and corresponding code. The length opt_len is updated; static_len is
+ *     also updated if stree is not null. The field max_code is set.
+ */
+local void build_tree(s, desc)
+    deflate_state *s;
+    tree_desc *desc; /* the tree descriptor */
+{
+    ct_data *tree         = desc->dyn_tree;
+    const ct_data *stree  = desc->stat_desc->static_tree;
+    int elems             = desc->stat_desc->elems;
+    int n, m;          /* iterate over heap elements */
+    int max_code = -1; /* largest code with non zero frequency */
+    int node;          /* new node being created */
+
+    /* Construct the initial heap, with least frequent element in
+     * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].
+     * heap[0] is not used.
+     */
+    s->heap_len = 0, s->heap_max = HEAP_SIZE;
+
+    for (n = 0; n < elems; n++) {
+        if (tree[n].Freq != 0) {
+            s->heap[++(s->heap_len)] = max_code = n;
+            s->depth[n] = 0;
+        } else {
+            tree[n].Len = 0;
+        }
+    }
+
+    /* The pkzip format requires that at least one distance code exists,
+     * and that at least one bit should be sent even if there is only one
+     * possible code. So to avoid special checks later on we force at least
+     * two codes of non zero frequency.
+     */
+    while (s->heap_len < 2) {
+        node = s->heap[++(s->heap_len)] = (max_code < 2 ? ++max_code : 0);
+        tree[node].Freq = 1;
+        s->depth[node] = 0;
+        s->opt_len--; if (stree) s->static_len -= stree[node].Len;
+        /* node is 0 or 1 so it does not have extra bits */
+    }
+    desc->max_code = max_code;
+
+    /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,
+     * establish sub-heaps of increasing lengths:
+     */
+    for (n = s->heap_len/2; n >= 1; n--) pqdownheap(s, tree, n);
+
+    /* Construct the Huffman tree by repeatedly combining the least two
+     * frequent nodes.
+     */
+    node = elems;              /* next internal node of the tree */
+    do {
+        pqremove(s, tree, n);  /* n = node of least frequency */
+        m = s->heap[SMALLEST]; /* m = node of next least frequency */
+
+        s->heap[--(s->heap_max)] = n; /* keep the nodes sorted by frequency */
+        s->heap[--(s->heap_max)] = m;
+
+        /* Create a new node father of n and m */
+        tree[node].Freq = tree[n].Freq + tree[m].Freq;
+        s->depth[node] = (uch) (MAX(s->depth[n], s->depth[m]) + 1);
+        tree[n].Dad = tree[m].Dad = (ush)node;
+#ifdef DUMP_BL_TREE
+        if (tree == s->bl_tree) {
+            fprintf(stderr,"\nnode %d(%d), sons %d(%d) %d(%d)",
+                    node, tree[node].Freq, n, tree[n].Freq, m, tree[m].Freq);
+        }
+#endif
+        /* and insert the new node in the heap */
+        s->heap[SMALLEST] = node++;
+        pqdownheap(s, tree, SMALLEST);
+
+    } while (s->heap_len >= 2);
+
+    s->heap[--(s->heap_max)] = s->heap[SMALLEST];
+
+    /* At this point, the fields freq and dad are set. We can now
+     * generate the bit lengths.
+     */
+    gen_bitlen(s, (tree_desc *)desc);
+
+    /* The field len is now set, we can generate the bit codes */
+    gen_codes ((ct_data *)tree, max_code, s->bl_count);
+}
+
+/* ===========================================================================
+ * Scan a literal or distance tree to determine the frequencies of the codes
+ * in the bit length tree.
+ */
+local void scan_tree (s, tree, max_code)
+    deflate_state *s;
+    ct_data *tree;   /* the tree to be scanned */
+    int max_code;    /* and its largest code of non zero frequency */
+{
+    int n;                     /* iterates over all tree elements */
+    int prevlen = -1;          /* last emitted length */
+    int curlen;                /* length of current code */
+    int nextlen = tree[0].Len; /* length of next code */
+    int count = 0;             /* repeat count of the current code */
+    int max_count = 7;         /* max repeat count */
+    int min_count = 4;         /* min repeat count */
+
+    if (nextlen == 0) max_count = 138, min_count = 3;
+    tree[max_code+1].Len = (ush)0xffff; /* guard */
+
+    for (n = 0; n <= max_code; n++) {
+        curlen = nextlen; nextlen = tree[n+1].Len;
+        if (++count < max_count && curlen == nextlen) {
+            continue;
+        } else if (count < min_count) {
+            s->bl_tree[curlen].Freq += count;
+        } else if (curlen != 0) {
+            if (curlen != prevlen) s->bl_tree[curlen].Freq++;
+            s->bl_tree[REP_3_6].Freq++;
+        } else if (count <= 10) {
+            s->bl_tree[REPZ_3_10].Freq++;
+        } else {
+            s->bl_tree[REPZ_11_138].Freq++;
+        }
+        count = 0; prevlen = curlen;
+        if (nextlen == 0) {
+            max_count = 138, min_count = 3;
+        } else if (curlen == nextlen) {
+            max_count = 6, min_count = 3;
+        } else {
+            max_count = 7, min_count = 4;
+        }
+    }
+}
+
+/* ===========================================================================
+ * Send a literal or distance tree in compressed form, using the codes in
+ * bl_tree.
+ */
+local void send_tree (s, tree, max_code)
+    deflate_state *s;
+    ct_data *tree; /* the tree to be scanned */
+    int max_code;       /* and its largest code of non zero frequency */
+{
+    int n;                     /* iterates over all tree elements */
+    int prevlen = -1;          /* last emitted length */
+    int curlen;                /* length of current code */
+    int nextlen = tree[0].Len; /* length of next code */
+    int count = 0;             /* repeat count of the current code */
+    int max_count = 7;         /* max repeat count */
+    int min_count = 4;         /* min repeat count */
+
+    /* tree[max_code+1].Len = -1; */  /* guard already set */
+    if (nextlen == 0) max_count = 138, min_count = 3;
+
+    for (n = 0; n <= max_code; n++) {
+        curlen = nextlen; nextlen = tree[n+1].Len;
+        if (++count < max_count && curlen == nextlen) {
+            continue;
+        } else if (count < min_count) {
+            do { send_code(s, curlen, s->bl_tree); } while (--count != 0);
+
+        } else if (curlen != 0) {
+            if (curlen != prevlen) {
+                send_code(s, curlen, s->bl_tree); count--;
+            }
+            Assert(count >= 3 && count <= 6, " 3_6?");
+            send_code(s, REP_3_6, s->bl_tree); send_bits(s, count-3, 2);
+
+        } else if (count <= 10) {
+            send_code(s, REPZ_3_10, s->bl_tree); send_bits(s, count-3, 3);
+
+        } else {
+            send_code(s, REPZ_11_138, s->bl_tree); send_bits(s, count-11, 7);
+        }
+        count = 0; prevlen = curlen;
+        if (nextlen == 0) {
+            max_count = 138, min_count = 3;
+        } else if (curlen == nextlen) {
+            max_count = 6, min_count = 3;
+        } else {
+            max_count = 7, min_count = 4;
+        }
+    }
+}
+
+/* ===========================================================================
+ * Construct the Huffman tree for the bit lengths and return the index in
+ * bl_order of the last bit length code to send.
+ */
+local int build_bl_tree(s)
+    deflate_state *s;
+{
+    int max_blindex;  /* index of last bit length code of non zero freq */
+
+    /* Determine the bit length frequencies for literal and distance trees */
+    scan_tree(s, (ct_data *)s->dyn_ltree, s->l_desc.max_code);
+    scan_tree(s, (ct_data *)s->dyn_dtree, s->d_desc.max_code);
+
+    /* Build the bit length tree: */
+    build_tree(s, (tree_desc *)(&(s->bl_desc)));
+    /* opt_len now includes the length of the tree representations, except
+     * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.
+     */
+
+    /* Determine the number of bit length codes to send. The pkzip format
+     * requires that at least 4 bit length codes be sent. (appnote.txt says
+     * 3 but the actual value used is 4.)
+     */
+    for (max_blindex = BL_CODES-1; max_blindex >= 3; max_blindex--) {
+        if (s->bl_tree[bl_order[max_blindex]].Len != 0) break;
+    }
+    /* Update opt_len to include the bit length tree and counts */
+    s->opt_len += 3*(max_blindex+1) + 5+5+4;
+    Tracev((stderr, "\ndyn trees: dyn %ld, stat %ld",
+            s->opt_len, s->static_len));
+
+    return max_blindex;
+}
+
+/* ===========================================================================
+ * Send the header for a block using dynamic Huffman trees: the counts, the
+ * lengths of the bit length codes, the literal tree and the distance tree.
+ * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.
+ */
+local void send_all_trees(s, lcodes, dcodes, blcodes)
+    deflate_state *s;
+    int lcodes, dcodes, blcodes; /* number of codes for each tree */
+{
+    int rank;                    /* index in bl_order */
+
+    Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, "not enough codes");
+    Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,
+            "too many codes");
+    Tracev((stderr, "\nbl counts: "));
+    send_bits(s, lcodes-257, 5); /* not +255 as stated in appnote.txt */
+    send_bits(s, dcodes-1,   5);
+    send_bits(s, blcodes-4,  4); /* not -3 as stated in appnote.txt */
+    for (rank = 0; rank < blcodes; rank++) {
+        Tracev((stderr, "\nbl code %2d ", bl_order[rank]));
+        send_bits(s, s->bl_tree[bl_order[rank]].Len, 3);
+    }
+    Tracev((stderr, "\nbl tree: sent %ld", s->bits_sent));
+
+    send_tree(s, (ct_data *)s->dyn_ltree, lcodes-1); /* literal tree */
+    Tracev((stderr, "\nlit tree: sent %ld", s->bits_sent));
+
+    send_tree(s, (ct_data *)s->dyn_dtree, dcodes-1); /* distance tree */
+    Tracev((stderr, "\ndist tree: sent %ld", s->bits_sent));
+}
+
+/* ===========================================================================
+ * Send a stored block
+ */
+void _tr_stored_block(s, buf, stored_len, eof)
+    deflate_state *s;
+    charf *buf;       /* input block */
+    ulg stored_len;   /* length of input block */
+    int eof;          /* true if this is the last block for a file */
+{
+    send_bits(s, (STORED_BLOCK<<1)+eof, 3);  /* send block type */
+#ifdef DEBUG
+    s->compressed_len = (s->compressed_len + 3 + 7) & (ulg)~7L;
+    s->compressed_len += (stored_len + 4) << 3;
+#endif
+    copy_block(s, buf, (unsigned)stored_len, 1); /* with header */
+}
+
+/* ===========================================================================
+ * Send one empty static block to give enough lookahead for inflate.
+ * This takes 10 bits, of which 7 may remain in the bit buffer.
+ * The current inflate code requires 9 bits of lookahead. If the
+ * last two codes for the previous block (real code plus EOB) were coded
+ * on 5 bits or less, inflate may have only 5+3 bits of lookahead to decode
+ * the last real code. In this case we send two empty static blocks instead
+ * of one. (There are no problems if the previous block is stored or fixed.)
+ * To simplify the code, we assume the worst case of last real code encoded
+ * on one bit only.
+ */
+void _tr_align(s)
+    deflate_state *s;
+{
+    send_bits(s, STATIC_TREES<<1, 3);
+    send_code(s, END_BLOCK, static_ltree);
+#ifdef DEBUG
+    s->compressed_len += 10L; /* 3 for block type, 7 for EOB */
+#endif
+    bi_flush(s);
+    /* Of the 10 bits for the empty block, we have already sent
+     * (10 - bi_valid) bits. The lookahead for the last real code (before
+     * the EOB of the previous block) was thus at least one plus the length
+     * of the EOB plus what we have just sent of the empty static block.
+     */
+    if (1 + s->last_eob_len + 10 - s->bi_valid < 9) {
+        send_bits(s, STATIC_TREES<<1, 3);
+        send_code(s, END_BLOCK, static_ltree);
+#ifdef DEBUG
+        s->compressed_len += 10L;
+#endif
+        bi_flush(s);
+    }
+    s->last_eob_len = 7;
+}
+
+/* ===========================================================================
+ * Determine the best encoding for the current block: dynamic trees, static
+ * trees or store, and output the encoded block to the zip file.
+ */
+void _tr_flush_block(s, buf, stored_len, eof)
+    deflate_state *s;
+    charf *buf;       /* input block, or NULL if too old */
+    ulg stored_len;   /* length of input block */
+    int eof;          /* true if this is the last block for a file */
+{
+    ulg opt_lenb, static_lenb; /* opt_len and static_len in bytes */
+    int max_blindex = 0;  /* index of last bit length code of non zero freq */
+
+    /* Build the Huffman trees unless a stored block is forced */
+    if (s->level > 0) {
+
+	 /* Check if the file is ascii or binary */
+	if (s->data_type == Z_UNKNOWN) set_data_type(s);
+
+	/* Construct the literal and distance trees */
+	build_tree(s, (tree_desc *)(&(s->l_desc)));
+	Tracev((stderr, "\nlit data: dyn %ld, stat %ld", s->opt_len,
+		s->static_len));
+
+	build_tree(s, (tree_desc *)(&(s->d_desc)));
+	Tracev((stderr, "\ndist data: dyn %ld, stat %ld", s->opt_len,
+		s->static_len));
+	/* At this point, opt_len and static_len are the total bit lengths of
+	 * the compressed block data, excluding the tree representations.
+	 */
+
+	/* Build the bit length tree for the above two trees, and get the index
+	 * in bl_order of the last bit length code to send.
+	 */
+	max_blindex = build_bl_tree(s);
+
+	/* Determine the best encoding. Compute first the block length in bytes*/
+	opt_lenb = (s->opt_len+3+7)>>3;
+	static_lenb = (s->static_len+3+7)>>3;
+
+	Tracev((stderr, "\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u ",
+		opt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,
+		s->last_lit));
+
+	if (static_lenb <= opt_lenb) opt_lenb = static_lenb;
+
+    } else {
+        Assert(buf != (char*)0, "lost buf");
+	opt_lenb = static_lenb = stored_len + 5; /* force a stored block */
+    }
+
+#ifdef FORCE_STORED
+    if (buf != (char*)0) { /* force stored block */
+#else
+    if (stored_len+4 <= opt_lenb && buf != (char*)0) {
+                       /* 4: two words for the lengths */
+#endif
+        /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.
+         * Otherwise we can't have processed more than WSIZE input bytes since
+         * the last block flush, because compression would have been
+         * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to
+         * transform a block into a stored block.
+         */
+        _tr_stored_block(s, buf, stored_len, eof);
+
+#ifdef FORCE_STATIC
+    } else if (static_lenb >= 0) { /* force static trees */
+#else
+    } else if (static_lenb == opt_lenb) {
+#endif
+        send_bits(s, (STATIC_TREES<<1)+eof, 3);
+        compress_block(s, (ct_data *)static_ltree, (ct_data *)static_dtree);
+#ifdef DEBUG
+        s->compressed_len += 3 + s->static_len;
+#endif
+    } else {
+        send_bits(s, (DYN_TREES<<1)+eof, 3);
+        send_all_trees(s, s->l_desc.max_code+1, s->d_desc.max_code+1,
+                       max_blindex+1);
+        compress_block(s, (ct_data *)s->dyn_ltree, (ct_data *)s->dyn_dtree);
+#ifdef DEBUG
+        s->compressed_len += 3 + s->opt_len;
+#endif
+    }
+    Assert (s->compressed_len == s->bits_sent, "bad compressed size");
+    /* The above check is made mod 2^32, for files larger than 512 MB
+     * and uLong implemented on 32 bits.
+     */
+    init_block(s);
+
+    if (eof) {
+        bi_windup(s);
+#ifdef DEBUG
+        s->compressed_len += 7;  /* align on byte boundary */
+#endif
+    }
+    Tracev((stderr,"\ncomprlen %lu(%lu) ", s->compressed_len>>3,
+           s->compressed_len-7*eof));
+}
+
+/* ===========================================================================
+ * Save the match info and tally the frequency counts. Return true if
+ * the current block must be flushed.
+ */
+int _tr_tally (s, dist, lc)
+    deflate_state *s;
+    unsigned dist;  /* distance of matched string */
+    unsigned lc;    /* match length-MIN_MATCH or unmatched char (if dist==0) */
+{
+    s->d_buf[s->last_lit] = (ush)dist;
+    s->l_buf[s->last_lit++] = (uch)lc;
+    if (dist == 0) {
+        /* lc is the unmatched char */
+        s->dyn_ltree[lc].Freq++;
+    } else {
+        s->matches++;
+        /* Here, lc is the match length - MIN_MATCH */
+        dist--;             /* dist = match distance - 1 */
+        Assert((ush)dist < (ush)MAX_DIST(s) &&
+               (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&
+               (ush)d_code(dist) < (ush)D_CODES,  "_tr_tally: bad match");
+
+        s->dyn_ltree[_length_code[lc]+LITERALS+1].Freq++;
+        s->dyn_dtree[d_code(dist)].Freq++;
+    }
+
+#ifdef TRUNCATE_BLOCK
+    /* Try to guess if it is profitable to stop the current block here */
+    if ((s->last_lit & 0x1fff) == 0 && s->level > 2) {
+        /* Compute an upper bound for the compressed length */
+        ulg out_length = (ulg)s->last_lit*8L;
+        ulg in_length = (ulg)((long)s->strstart - s->block_start);
+        int dcode;
+        for (dcode = 0; dcode < D_CODES; dcode++) {
+            out_length += (ulg)s->dyn_dtree[dcode].Freq *
+                (5L+extra_dbits[dcode]);
+        }
+        out_length >>= 3;
+        Tracev((stderr,"\nlast_lit %u, in %ld, out ~%ld(%ld%%) ",
+               s->last_lit, in_length, out_length,
+               100L - out_length*100L/in_length));
+        if (s->matches < s->last_lit/2 && out_length < in_length/2) return 1;
+    }
+#endif
+    return (s->last_lit == s->lit_bufsize-1);
+    /* We avoid equality with lit_bufsize because of wraparound at 64K
+     * on 16 bit machines and because stored blocks are restricted to
+     * 64K-1 bytes.
+     */
+}
+
+/* ===========================================================================
+ * Send the block data compressed using the given Huffman trees
+ */
+local void compress_block(s, ltree, dtree)
+    deflate_state *s;
+    ct_data *ltree; /* literal tree */
+    ct_data *dtree; /* distance tree */
+{
+    unsigned dist;      /* distance of matched string */
+    int lc;             /* match length or unmatched char (if dist == 0) */
+    unsigned lx = 0;    /* running index in l_buf */
+    unsigned code;      /* the code to send */
+    int extra;          /* number of extra bits to send */
+
+    if (s->last_lit != 0) do {
+        dist = s->d_buf[lx];
+        lc = s->l_buf[lx++];
+        if (dist == 0) {
+            send_code(s, lc, ltree); /* send a literal byte */
+            Tracecv(isgraph(lc), (stderr," '%c' ", lc));
+        } else {
+            /* Here, lc is the match length - MIN_MATCH */
+            code = _length_code[lc];
+            send_code(s, code+LITERALS+1, ltree); /* send the length code */
+            extra = extra_lbits[code];
+            if (extra != 0) {
+                lc -= base_length[code];
+                send_bits(s, lc, extra);       /* send the extra length bits */
+            }
+            dist--; /* dist is now the match distance - 1 */
+            code = d_code(dist);
+            Assert (code < D_CODES, "bad d_code");
+
+            send_code(s, code, dtree);       /* send the distance code */
+            extra = extra_dbits[code];
+            if (extra != 0) {
+                dist -= base_dist[code];
+                send_bits(s, dist, extra);   /* send the extra distance bits */
+            }
+        } /* literal or match pair ? */
+
+        /* Check that the overlay between pending_buf and d_buf+l_buf is ok: */
+        Assert(s->pending < s->lit_bufsize + 2*lx, "pendingBuf overflow");
+
+    } while (lx < s->last_lit);
+
+    send_code(s, END_BLOCK, ltree);
+    s->last_eob_len = ltree[END_BLOCK].Len;
+}
+
+/* ===========================================================================
+ * Set the data type to ASCII or BINARY, using a crude approximation:
+ * binary if more than 20% of the bytes are <= 6 or >= 128, ascii otherwise.
+ * IN assertion: the fields freq of dyn_ltree are set and the total of all
+ * frequencies does not exceed 64K (to fit in an int on 16 bit machines).
+ */
+local void set_data_type(s)
+    deflate_state *s;
+{
+    int n = 0;
+    unsigned ascii_freq = 0;
+    unsigned bin_freq = 0;
+    while (n < 7)        bin_freq += s->dyn_ltree[n++].Freq;
+    while (n < 128)    ascii_freq += s->dyn_ltree[n++].Freq;
+    while (n < LITERALS) bin_freq += s->dyn_ltree[n++].Freq;
+    s->data_type = (Byte)(bin_freq > (ascii_freq >> 2) ? Z_BINARY : Z_ASCII);
+}
+
+/* ===========================================================================
+ * Reverse the first len bits of a code, using straightforward code (a faster
+ * method would use a table)
+ * IN assertion: 1 <= len <= 15
+ */
+local unsigned bi_reverse(code, len)
+    unsigned code; /* the value to invert */
+    int len;       /* its bit length */
+{
+    register unsigned res = 0;
+    do {
+        res |= code & 1;
+        code >>= 1, res <<= 1;
+    } while (--len > 0);
+    return res >> 1;
+}
+
+/* ===========================================================================
+ * Flush the bit buffer, keeping at most 7 bits in it.
+ */
+local void bi_flush(s)
+    deflate_state *s;
+{
+    if (s->bi_valid == 16) {
+        put_short(s, s->bi_buf);
+        s->bi_buf = 0;
+        s->bi_valid = 0;
+    } else if (s->bi_valid >= 8) {
+        put_byte(s, (Byte)s->bi_buf);
+        s->bi_buf >>= 8;
+        s->bi_valid -= 8;
+    }
+}
+
+/* ===========================================================================
+ * Flush the bit buffer and align the output on a byte boundary
+ */
+local void bi_windup(s)
+    deflate_state *s;
+{
+    if (s->bi_valid > 8) {
+        put_short(s, s->bi_buf);
+    } else if (s->bi_valid > 0) {
+        put_byte(s, (Byte)s->bi_buf);
+    }
+    s->bi_buf = 0;
+    s->bi_valid = 0;
+#ifdef DEBUG
+    s->bits_sent = (s->bits_sent+7) & ~7;
+#endif
+}
+
+/* ===========================================================================
+ * Copy a stored block, storing first the length and its
+ * one's complement if requested.
+ */
+local void copy_block(s, buf, len, header)
+    deflate_state *s;
+    charf    *buf;    /* the input data */
+    unsigned len;     /* its length */
+    int      header;  /* true if block header must be written */
+{
+    bi_windup(s);        /* align on byte boundary */
+    s->last_eob_len = 8; /* enough lookahead for inflate */
+
+    if (header) {
+        put_short(s, (ush)len);   
+        put_short(s, (ush)~len);
+#ifdef DEBUG
+        s->bits_sent += 2*16;
+#endif
+    }
+#ifdef DEBUG
+    s->bits_sent += (ulg)len<<3;
+#endif
+    while (len--) {
+        put_byte(s, *buf++);
+    }
+}
diff --git a/src/unix/contrib/cutzlib-1.1.4/trees.h b/src/unix/contrib/cutzlib-1.1.4/trees.h
new file mode 100644
index 0000000..72facf9
--- /dev/null
+++ b/src/unix/contrib/cutzlib-1.1.4/trees.h
@@ -0,0 +1,128 @@
+/* header created automatically with -DGEN_TREES_H */
+
+local const ct_data static_ltree[L_CODES+2] = {
+{{ 12},{  8}}, {{140},{  8}}, {{ 76},{  8}}, {{204},{  8}}, {{ 44},{  8}},
+{{172},{  8}}, {{108},{  8}}, {{236},{  8}}, {{ 28},{  8}}, {{156},{  8}},
+{{ 92},{  8}}, {{220},{  8}}, {{ 60},{  8}}, {{188},{  8}}, {{124},{  8}},
+{{252},{  8}}, {{  2},{  8}}, {{130},{  8}}, {{ 66},{  8}}, {{194},{  8}},
+{{ 34},{  8}}, {{162},{  8}}, {{ 98},{  8}}, {{226},{  8}}, {{ 18},{  8}},
+{{146},{  8}}, {{ 82},{  8}}, {{210},{  8}}, {{ 50},{  8}}, {{178},{  8}},
+{{114},{  8}}, {{242},{  8}}, {{ 10},{  8}}, {{138},{  8}}, {{ 74},{  8}},
+{{202},{  8}}, {{ 42},{  8}}, {{170},{  8}}, {{106},{  8}}, {{234},{  8}},
+{{ 26},{  8}}, {{154},{  8}}, {{ 90},{  8}}, {{218},{  8}}, {{ 58},{  8}},
+{{186},{  8}}, {{122},{  8}}, {{250},{  8}}, {{  6},{  8}}, {{134},{  8}},
+{{ 70},{  8}}, {{198},{  8}}, {{ 38},{  8}}, {{166},{  8}}, {{102},{  8}},
+{{230},{  8}}, {{ 22},{  8}}, {{150},{  8}}, {{ 86},{  8}}, {{214},{  8}},
+{{ 54},{  8}}, {{182},{  8}}, {{118},{  8}}, {{246},{  8}}, {{ 14},{  8}},
+{{142},{  8}}, {{ 78},{  8}}, {{206},{  8}}, {{ 46},{  8}}, {{174},{  8}},
+{{110},{  8}}, {{238},{  8}}, {{ 30},{  8}}, {{158},{  8}}, {{ 94},{  8}},
+{{222},{  8}}, {{ 62},{  8}}, {{190},{  8}}, {{126},{  8}}, {{254},{  8}},
+{{  1},{  8}}, {{129},{  8}}, {{ 65},{  8}}, {{193},{  8}}, {{ 33},{  8}},
+{{161},{  8}}, {{ 97},{  8}}, {{225},{  8}}, {{ 17},{  8}}, {{145},{  8}},
+{{ 81},{  8}}, {{209},{  8}}, {{ 49},{  8}}, {{177},{  8}}, {{113},{  8}},
+{{241},{  8}}, {{  9},{  8}}, {{137},{  8}}, {{ 73},{  8}}, {{201},{  8}},
+{{ 41},{  8}}, {{169},{  8}}, {{105},{  8}}, {{233},{  8}}, {{ 25},{  8}},
+{{153},{  8}}, {{ 89},{  8}}, {{217},{  8}}, {{ 57},{  8}}, {{185},{  8}},
+{{121},{  8}}, {{249},{  8}}, {{  5},{  8}}, {{133},{  8}}, {{ 69},{  8}},
+{{197},{  8}}, {{ 37},{  8}}, {{165},{  8}}, {{101},{  8}}, {{229},{  8}},
+{{ 21},{  8}}, {{149},{  8}}, {{ 85},{  8}}, {{213},{  8}}, {{ 53},{  8}},
+{{181},{  8}}, {{117},{  8}}, {{245},{  8}}, {{ 13},{  8}}, {{141},{  8}},
+{{ 77},{  8}}, {{205},{  8}}, {{ 45},{  8}}, {{173},{  8}}, {{109},{  8}},
+{{237},{  8}}, {{ 29},{  8}}, {{157},{  8}}, {{ 93},{  8}}, {{221},{  8}},
+{{ 61},{  8}}, {{189},{  8}}, {{125},{  8}}, {{253},{  8}}, {{ 19},{  9}},
+{{275},{  9}}, {{147},{  9}}, {{403},{  9}}, {{ 83},{  9}}, {{339},{  9}},
+{{211},{  9}}, {{467},{  9}}, {{ 51},{  9}}, {{307},{  9}}, {{179},{  9}},
+{{435},{  9}}, {{115},{  9}}, {{371},{  9}}, {{243},{  9}}, {{499},{  9}},
+{{ 11},{  9}}, {{267},{  9}}, {{139},{  9}}, {{395},{  9}}, {{ 75},{  9}},
+{{331},{  9}}, {{203},{  9}}, {{459},{  9}}, {{ 43},{  9}}, {{299},{  9}},
+{{171},{  9}}, {{427},{  9}}, {{107},{  9}}, {{363},{  9}}, {{235},{  9}},
+{{491},{  9}}, {{ 27},{  9}}, {{283},{  9}}, {{155},{  9}}, {{411},{  9}},
+{{ 91},{  9}}, {{347},{  9}}, {{219},{  9}}, {{475},{  9}}, {{ 59},{  9}},
+{{315},{  9}}, {{187},{  9}}, {{443},{  9}}, {{123},{  9}}, {{379},{  9}},
+{{251},{  9}}, {{507},{  9}}, {{  7},{  9}}, {{263},{  9}}, {{135},{  9}},
+{{391},{  9}}, {{ 71},{  9}}, {{327},{  9}}, {{199},{  9}}, {{455},{  9}},
+{{ 39},{  9}}, {{295},{  9}}, {{167},{  9}}, {{423},{  9}}, {{103},{  9}},
+{{359},{  9}}, {{231},{  9}}, {{487},{  9}}, {{ 23},{  9}}, {{279},{  9}},
+{{151},{  9}}, {{407},{  9}}, {{ 87},{  9}}, {{343},{  9}}, {{215},{  9}},
+{{471},{  9}}, {{ 55},{  9}}, {{311},{  9}}, {{183},{  9}}, {{439},{  9}},
+{{119},{  9}}, {{375},{  9}}, {{247},{  9}}, {{503},{  9}}, {{ 15},{  9}},
+{{271},{  9}}, {{143},{  9}}, {{399},{  9}}, {{ 79},{  9}}, {{335},{  9}},
+{{207},{  9}}, {{463},{  9}}, {{ 47},{  9}}, {{303},{  9}}, {{175},{  9}},
+{{431},{  9}}, {{111},{  9}}, {{367},{  9}}, {{239},{  9}}, {{495},{  9}},
+{{ 31},{  9}}, {{287},{  9}}, {{159},{  9}}, {{415},{  9}}, {{ 95},{  9}},
+{{351},{  9}}, {{223},{  9}}, {{479},{  9}}, {{ 63},{  9}}, {{319},{  9}},
+{{191},{  9}}, {{447},{  9}}, {{127},{  9}}, {{383},{  9}}, {{255},{  9}},
+{{511},{  9}}, {{  0},{  7}}, {{ 64},{  7}}, {{ 32},{  7}}, {{ 96},{  7}},
+{{ 16},{  7}}, {{ 80},{  7}}, {{ 48},{  7}}, {{112},{  7}}, {{  8},{  7}},
+{{ 72},{  7}}, {{ 40},{  7}}, {{104},{  7}}, {{ 24},{  7}}, {{ 88},{  7}},
+{{ 56},{  7}}, {{120},{  7}}, {{  4},{  7}}, {{ 68},{  7}}, {{ 36},{  7}},
+{{100},{  7}}, {{ 20},{  7}}, {{ 84},{  7}}, {{ 52},{  7}}, {{116},{  7}},
+{{  3},{  8}}, {{131},{  8}}, {{ 67},{  8}}, {{195},{  8}}, {{ 35},{  8}},
+{{163},{  8}}, {{ 99},{  8}}, {{227},{  8}}
+};
+
+local const ct_data static_dtree[D_CODES] = {
+{{ 0},{ 5}}, {{16},{ 5}}, {{ 8},{ 5}}, {{24},{ 5}}, {{ 4},{ 5}},
+{{20},{ 5}}, {{12},{ 5}}, {{28},{ 5}}, {{ 2},{ 5}}, {{18},{ 5}},
+{{10},{ 5}}, {{26},{ 5}}, {{ 6},{ 5}}, {{22},{ 5}}, {{14},{ 5}},
+{{30},{ 5}}, {{ 1},{ 5}}, {{17},{ 5}}, {{ 9},{ 5}}, {{25},{ 5}},
+{{ 5},{ 5}}, {{21},{ 5}}, {{13},{ 5}}, {{29},{ 5}}, {{ 3},{ 5}},
+{{19},{ 5}}, {{11},{ 5}}, {{27},{ 5}}, {{ 7},{ 5}}, {{23},{ 5}}
+};
+
+const uch _dist_code[DIST_CODE_LEN] = {
+ 0,  1,  2,  3,  4,  4,  5,  5,  6,  6,  6,  6,  7,  7,  7,  7,  8,  8,  8,  8,
+ 8,  8,  8,  8,  9,  9,  9,  9,  9,  9,  9,  9, 10, 10, 10, 10, 10, 10, 10, 10,
+10, 10, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,
+11, 11, 11, 11, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,
+12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 13, 13, 13, 13,
+13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,
+13, 13, 13, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
+14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
+14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
+14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 15, 15, 15, 15, 15, 15, 15, 15,
+15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
+15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
+15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,  0,  0, 16, 17,
+18, 18, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 22, 22, 22, 22, 22, 22, 22, 22,
+23, 23, 23, 23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
+24, 24, 24, 24, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,
+26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26,
+26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 27, 27, 27, 27, 27, 27, 27, 27,
+27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27,
+27, 27, 27, 27, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
+28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
+28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
+28, 28, 28, 28, 28, 28, 28, 28, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
+29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
+29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
+29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29
+};
+
+const uch _length_code[MAX_MATCH-MIN_MATCH+1]= {
+ 0,  1,  2,  3,  4,  5,  6,  7,  8,  8,  9,  9, 10, 10, 11, 11, 12, 12, 12, 12,
+13, 13, 13, 13, 14, 14, 14, 14, 15, 15, 15, 15, 16, 16, 16, 16, 16, 16, 16, 16,
+17, 17, 17, 17, 17, 17, 17, 17, 18, 18, 18, 18, 18, 18, 18, 18, 19, 19, 19, 19,
+19, 19, 19, 19, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
+21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 22, 22, 22, 22,
+22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 23, 23, 23, 23, 23, 23, 23, 23,
+23, 23, 23, 23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
+24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
+25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,
+25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 26, 26, 26, 26, 26, 26, 26, 26,
+26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26,
+26, 26, 26, 26, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27,
+27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 28
+};
+
+local const int base_length[LENGTH_CODES] = {
+0, 1, 2, 3, 4, 5, 6, 7, 8, 10, 12, 14, 16, 20, 24, 28, 32, 40, 48, 56,
+64, 80, 96, 112, 128, 160, 192, 224, 0
+};
+
+local const int base_dist[D_CODES] = {
+    0,     1,     2,     3,     4,     6,     8,    12,    16,    24,
+   32,    48,    64,    96,   128,   192,   256,   384,   512,   768,
+ 1024,  1536,  2048,  3072,  4096,  6144,  8192, 12288, 16384, 24576
+};
+
diff --git a/src/unix/contrib/cutzlib-1.1.4/uncompr.c b/src/unix/contrib/cutzlib-1.1.4/uncompr.c
new file mode 100644
index 0000000..0ec92bd
--- /dev/null
+++ b/src/unix/contrib/cutzlib-1.1.4/uncompr.c
@@ -0,0 +1,58 @@
+/* uncompr.c -- decompress a memory buffer
+ * Copyright (C) 1995-2002 Jean-loup Gailly.
+ * For conditions of distribution and use, see copyright notice in zlib.h 
+ */
+
+/* @(#) $Id: uncompr.c,v 1.1 2002/04/18 21:15:09 l_g Exp $ */
+
+#include "zlib.h"
+
+/* ===========================================================================
+     Decompresses the source buffer into the destination buffer.  sourceLen is
+   the byte length of the source buffer. Upon entry, destLen is the total
+   size of the destination buffer, which must be large enough to hold the
+   entire uncompressed data. (The size of the uncompressed data must have
+   been saved previously by the compressor and transmitted to the decompressor
+   by some mechanism outside the scope of this compression library.)
+   Upon exit, destLen is the actual size of the compressed buffer.
+     This function can be used to decompress a whole file at once if the
+   input file is mmap'ed.
+
+     uncompress returns Z_OK if success, Z_MEM_ERROR if there was not
+   enough memory, Z_BUF_ERROR if there was not enough room in the output
+   buffer, or Z_DATA_ERROR if the input data was corrupted.
+*/
+int ZEXPORT uncompress (dest, destLen, source, sourceLen)
+    Bytef *dest;
+    uLongf *destLen;
+    const Bytef *source;
+    uLong sourceLen;
+{
+    z_stream stream;
+    int err;
+
+    stream.next_in = (Bytef*)source;
+    stream.avail_in = (uInt)sourceLen;
+    /* Check for source > 64K on 16-bit machine: */
+    if ((uLong)stream.avail_in != sourceLen) return Z_BUF_ERROR;
+
+    stream.next_out = dest;
+    stream.avail_out = (uInt)*destLen;
+    if ((uLong)stream.avail_out != *destLen) return Z_BUF_ERROR;
+
+    stream.zalloc = (alloc_func)0;
+    stream.zfree = (free_func)0;
+
+    err = inflateInit(&stream);
+    if (err != Z_OK) return err;
+
+    err = inflate(&stream, Z_FINISH);
+    if (err != Z_STREAM_END) {
+        inflateEnd(&stream);
+        return err == Z_OK ? Z_BUF_ERROR : err;
+    }
+    *destLen = stream.total_out;
+
+    err = inflateEnd(&stream);
+    return err;
+}
diff --git a/src/unix/contrib/cutzlib-1.1.4/zconf.h b/src/unix/contrib/cutzlib-1.1.4/zconf.h
new file mode 100644
index 0000000..09564ca
--- /dev/null
+++ b/src/unix/contrib/cutzlib-1.1.4/zconf.h
@@ -0,0 +1,279 @@
+/* zconf.h -- configuration of the zlib compression library
+ * Copyright (C) 1995-2002 Jean-loup Gailly.
+ * For conditions of distribution and use, see copyright notice in zlib.h 
+ */
+
+/* @(#) $Id: zconf.h,v 1.1 2002/04/18 21:15:09 l_g Exp $ */
+
+#ifndef _ZCONF_H
+#define _ZCONF_H
+
+/*
+ * If you *really* need a unique prefix for all types and library functions,
+ * compile with -DZ_PREFIX. The "standard" zlib should be compiled without it.
+ */
+#ifdef Z_PREFIX
+#  define deflateInit_	z_deflateInit_
+#  define deflate	z_deflate
+#  define deflateEnd	z_deflateEnd
+#  define inflateInit_ 	z_inflateInit_
+#  define inflate	z_inflate
+#  define inflateEnd	z_inflateEnd
+#  define deflateInit2_	z_deflateInit2_
+#  define deflateSetDictionary z_deflateSetDictionary
+#  define deflateCopy	z_deflateCopy
+#  define deflateReset	z_deflateReset
+#  define deflateParams	z_deflateParams
+#  define inflateInit2_	z_inflateInit2_
+#  define inflateSetDictionary z_inflateSetDictionary
+#  define inflateSync	z_inflateSync
+#  define inflateSyncPoint z_inflateSyncPoint
+#  define inflateReset	z_inflateReset
+#  define compress	z_compress
+#  define compress2	z_compress2
+#  define uncompress	z_uncompress
+#  define adler32	z_adler32
+#  define crc32		z_crc32
+#  define get_crc_table z_get_crc_table
+
+#  define Byte		z_Byte
+#  define uInt		z_uInt
+#  define uLong		z_uLong
+#  define Bytef	        z_Bytef
+#  define charf		z_charf
+#  define intf		z_intf
+#  define uIntf		z_uIntf
+#  define uLongf	z_uLongf
+#  define voidpf	z_voidpf
+#  define voidp		z_voidp
+#endif
+
+#if (defined(_WIN32) || defined(__WIN32__)) && !defined(WIN32)
+#  define WIN32
+#endif
+#if defined(__GNUC__) || defined(WIN32) || defined(__386__) || defined(i386)
+#  ifndef __32BIT__
+#    define __32BIT__
+#  endif
+#endif
+#if defined(__MSDOS__) && !defined(MSDOS)
+#  define MSDOS
+#endif
+
+/*
+ * Compile with -DMAXSEG_64K if the alloc function cannot allocate more
+ * than 64k bytes at a time (needed on systems with 16-bit int).
+ */
+#if defined(MSDOS) && !defined(__32BIT__)
+#  define MAXSEG_64K
+#endif
+#ifdef MSDOS
+#  define UNALIGNED_OK
+#endif
+
+#if (defined(MSDOS) || defined(_WINDOWS) || defined(WIN32))  && !defined(STDC)
+#  define STDC
+#endif
+#if defined(__STDC__) || defined(__cplusplus) || defined(__OS2__)
+#  ifndef STDC
+#    define STDC
+#  endif
+#endif
+
+#ifndef STDC
+#  ifndef const /* cannot use !defined(STDC) && !defined(const) on Mac */
+#    define const
+#  endif
+#endif
+
+/* Some Mac compilers merge all .h files incorrectly: */
+#if defined(__MWERKS__) || defined(applec) ||defined(THINK_C) ||defined(__SC__)
+#  define NO_DUMMY_DECL
+#endif
+
+/* Old Borland C incorrectly complains about missing returns: */
+#if defined(__BORLANDC__) && (__BORLANDC__ < 0x500)
+#  define NEED_DUMMY_RETURN
+#endif
+
+
+/* Maximum value for memLevel in deflateInit2 */
+#ifndef MAX_MEM_LEVEL
+#  ifdef MAXSEG_64K
+#    define MAX_MEM_LEVEL 8
+#  else
+#    define MAX_MEM_LEVEL 9
+#  endif
+#endif
+
+/* Maximum value for windowBits in deflateInit2 and inflateInit2.
+ * WARNING: reducing MAX_WBITS makes minigzip unable to extract .gz files
+ * created by gzip. (Files created by minigzip can still be extracted by
+ * gzip.)
+ */
+#ifndef MAX_WBITS
+#  define MAX_WBITS   15 /* 32K LZ77 window */
+#endif
+
+/* The memory requirements for deflate are (in bytes):
+            (1 << (windowBits+2)) +  (1 << (memLevel+9))
+ that is: 128K for windowBits=15  +  128K for memLevel = 8  (default values)
+ plus a few kilobytes for small objects. For example, if you want to reduce
+ the default memory requirements from 256K to 128K, compile with
+     make CFLAGS="-O -DMAX_WBITS=14 -DMAX_MEM_LEVEL=7"
+ Of course this will generally degrade compression (there's no free lunch).
+
+   The memory requirements for inflate are (in bytes) 1 << windowBits
+ that is, 32K for windowBits=15 (default value) plus a few kilobytes
+ for small objects.
+*/
+
+                        /* Type declarations */
+
+#ifndef OF /* function prototypes */
+#  ifdef STDC
+#    define OF(args)  args
+#  else
+#    define OF(args)  ()
+#  endif
+#endif
+
+/* The following definitions for FAR are needed only for MSDOS mixed
+ * model programming (small or medium model with some far allocations).
+ * This was tested only with MSC; for other MSDOS compilers you may have
+ * to define NO_MEMCPY in zutil.h.  If you don't need the mixed model,
+ * just define FAR to be empty.
+ */
+#if (defined(M_I86SM) || defined(M_I86MM)) && !defined(__32BIT__)
+   /* MSC small or medium model */
+#  define SMALL_MEDIUM
+#  ifdef _MSC_VER
+#    define FAR _far
+#  else
+#    define FAR far
+#  endif
+#endif
+#if defined(__BORLANDC__) && (defined(__SMALL__) || defined(__MEDIUM__))
+#  ifndef __32BIT__
+#    define SMALL_MEDIUM
+#    define FAR _far
+#  endif
+#endif
+
+/* Compile with -DZLIB_DLL for Windows DLL support */
+#if defined(ZLIB_DLL)
+#  if defined(_WINDOWS) || defined(WINDOWS)
+#    ifdef FAR
+#      undef FAR
+#    endif
+#    include <windows.h>
+#    define ZEXPORT  WINAPI
+#    ifdef WIN32
+#      define ZEXPORTVA  WINAPIV
+#    else
+#      define ZEXPORTVA  FAR _cdecl _export
+#    endif
+#  endif
+#  if defined (__BORLANDC__)
+#    if (__BORLANDC__ >= 0x0500) && defined (WIN32)
+#      include <windows.h>
+#      define ZEXPORT __declspec(dllexport) WINAPI
+#      define ZEXPORTRVA __declspec(dllexport) WINAPIV
+#    else
+#      if defined (_Windows) && defined (__DLL__)
+#        define ZEXPORT _export
+#        define ZEXPORTVA _export
+#      endif
+#    endif
+#  endif
+#endif
+
+#if defined (__BEOS__)
+#  if defined (ZLIB_DLL)
+#    define ZEXTERN extern __declspec(dllexport)
+#  else
+#    define ZEXTERN extern __declspec(dllimport)
+#  endif
+#endif
+
+#ifndef ZEXPORT
+#  define ZEXPORT
+#endif
+#ifndef ZEXPORTVA
+#  define ZEXPORTVA
+#endif
+#ifndef ZEXTERN
+#  define ZEXTERN extern
+#endif
+
+#ifndef FAR
+#   define FAR
+#endif
+
+#if !defined(MACOS) && !defined(TARGET_OS_MAC)
+typedef unsigned char  Byte;  /* 8 bits */
+#endif
+typedef unsigned int   uInt;  /* 16 bits or more */
+typedef unsigned long  uLong; /* 32 bits or more */
+
+#ifdef SMALL_MEDIUM
+   /* Borland C/C++ and some old MSC versions ignore FAR inside typedef */
+#  define Bytef Byte FAR
+#else
+   typedef Byte  FAR Bytef;
+#endif
+typedef char  FAR charf;
+typedef int   FAR intf;
+typedef uInt  FAR uIntf;
+typedef uLong FAR uLongf;
+
+#ifdef STDC
+   typedef void FAR *voidpf;
+   typedef void     *voidp;
+#else
+   typedef Byte FAR *voidpf;
+   typedef Byte     *voidp;
+#endif
+
+#ifdef HAVE_UNISTD_H
+#  include <sys/types.h> /* for off_t */
+#  include <unistd.h>    /* for SEEK_* and off_t */
+#  define z_off_t  off_t
+#endif
+#ifndef SEEK_SET
+#  define SEEK_SET        0       /* Seek from beginning of file.  */
+#  define SEEK_CUR        1       /* Seek from current position.  */
+#  define SEEK_END        2       /* Set file pointer to EOF plus "offset" */
+#endif
+#ifndef z_off_t
+#  define  z_off_t long
+#endif
+
+/* MVS linker does not support external names larger than 8 bytes */
+#if defined(__MVS__)
+#   pragma map(deflateInit_,"DEIN")
+#   pragma map(deflateInit2_,"DEIN2")
+#   pragma map(deflateEnd,"DEEND")
+#   pragma map(inflateInit_,"ININ")
+#   pragma map(inflateInit2_,"ININ2")
+#   pragma map(inflateEnd,"INEND")
+#   pragma map(inflateSync,"INSY")
+#   pragma map(inflateSetDictionary,"INSEDI")
+#   pragma map(inflate_blocks,"INBL")
+#   pragma map(inflate_blocks_new,"INBLNE")
+#   pragma map(inflate_blocks_free,"INBLFR")
+#   pragma map(inflate_blocks_reset,"INBLRE")
+#   pragma map(inflate_codes_free,"INCOFR")
+#   pragma map(inflate_codes,"INCO")
+#   pragma map(inflate_fast,"INFA")
+#   pragma map(inflate_flush,"INFLU")
+#   pragma map(inflate_mask,"INMA")
+#   pragma map(inflate_set_dictionary,"INSEDI2")
+#   pragma map(inflate_copyright,"INCOPY")
+#   pragma map(inflate_trees_bits,"INTRBI")
+#   pragma map(inflate_trees_dynamic,"INTRDY")
+#   pragma map(inflate_trees_fixed,"INTRFI")
+#   pragma map(inflate_trees_free,"INTRFR")
+#endif
+
+#endif /* _ZCONF_H */
diff --git a/src/unix/contrib/cutzlib-1.1.4/zlib.h b/src/unix/contrib/cutzlib-1.1.4/zlib.h
new file mode 100644
index 0000000..52cb529
--- /dev/null
+++ b/src/unix/contrib/cutzlib-1.1.4/zlib.h
@@ -0,0 +1,893 @@
+/* zlib.h -- interface of the 'zlib' general purpose compression library
+  version 1.1.4, March 11th, 2002
+
+  Copyright (C) 1995-2002 Jean-loup Gailly and Mark Adler
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+
+  Jean-loup Gailly        Mark Adler
+  jloup@gzip.org          madler@alumni.caltech.edu
+
+
+  The data format used by the zlib library is described by RFCs (Request for
+  Comments) 1950 to 1952 in the files ftp://ds.internic.net/rfc/rfc1950.txt
+  (zlib format), rfc1951.txt (deflate format) and rfc1952.txt (gzip format).
+*/
+
+#ifndef _ZLIB_H
+#define _ZLIB_H
+
+#include "zconf.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define ZLIB_VERSION "1.1.4"
+
+/* 
+     The 'zlib' compression library provides in-memory compression and
+  decompression functions, including integrity checks of the uncompressed
+  data.  This version of the library supports only one compression method
+  (deflation) but other algorithms will be added later and will have the same
+  stream interface.
+
+     Compression can be done in a single step if the buffers are large
+  enough (for example if an input file is mmap'ed), or can be done by
+  repeated calls of the compression function.  In the latter case, the
+  application must provide more input and/or consume the output
+  (providing more output space) before each call.
+
+     The library also supports reading and writing files in gzip (.gz) format
+  with an interface similar to that of stdio.
+
+     The library does not install any signal handler. The decoder checks
+  the consistency of the compressed data, so the library should never
+  crash even in case of corrupted input.
+*/
+
+typedef voidpf (*alloc_func) OF((voidpf opaque, uInt items, uInt size));
+typedef void   (*free_func)  OF((voidpf opaque, voidpf address));
+
+struct internal_state;
+
+typedef struct z_stream_s {
+    Bytef    *next_in;  /* next input byte */
+    uInt     avail_in;  /* number of bytes available at next_in */
+    uLong    total_in;  /* total nb of input bytes read so far */
+
+    Bytef    *next_out; /* next output byte should be put there */
+    uInt     avail_out; /* remaining free space at next_out */
+    uLong    total_out; /* total nb of bytes output so far */
+
+    char     *msg;      /* last error message, NULL if no error */
+    struct internal_state FAR *state; /* not visible by applications */
+
+    alloc_func zalloc;  /* used to allocate the internal state */
+    free_func  zfree;   /* used to free the internal state */
+    voidpf     opaque;  /* private data object passed to zalloc and zfree */
+
+    int     data_type;  /* best guess about the data type: ascii or binary */
+    uLong   adler;      /* adler32 value of the uncompressed data */
+    uLong   reserved;   /* reserved for future use */
+} z_stream;
+
+typedef z_stream FAR *z_streamp;
+
+/*
+   The application must update next_in and avail_in when avail_in has
+   dropped to zero. It must update next_out and avail_out when avail_out
+   has dropped to zero. The application must initialize zalloc, zfree and
+   opaque before calling the init function. All other fields are set by the
+   compression library and must not be updated by the application.
+
+   The opaque value provided by the application will be passed as the first
+   parameter for calls of zalloc and zfree. This can be useful for custom
+   memory management. The compression library attaches no meaning to the
+   opaque value.
+
+   zalloc must return Z_NULL if there is not enough memory for the object.
+   If zlib is used in a multi-threaded application, zalloc and zfree must be
+   thread safe.
+
+   On 16-bit systems, the functions zalloc and zfree must be able to allocate
+   exactly 65536 bytes, but will not be required to allocate more than this
+   if the symbol MAXSEG_64K is defined (see zconf.h). WARNING: On MSDOS,
+   pointers returned by zalloc for objects of exactly 65536 bytes *must*
+   have their offset normalized to zero. The default allocation function
+   provided by this library ensures this (see zutil.c). To reduce memory
+   requirements and avoid any allocation of 64K objects, at the expense of
+   compression ratio, compile the library with -DMAX_WBITS=14 (see zconf.h).
+
+   The fields total_in and total_out can be used for statistics or
+   progress reports. After compression, total_in holds the total size of
+   the uncompressed data and may be saved for use in the decompressor
+   (particularly if the decompressor wants to decompress everything in
+   a single step).
+*/
+
+                        /* constants */
+
+#define Z_NO_FLUSH      0
+#define Z_PARTIAL_FLUSH 1 /* will be removed, use Z_SYNC_FLUSH instead */
+#define Z_SYNC_FLUSH    2
+#define Z_FULL_FLUSH    3
+#define Z_FINISH        4
+/* Allowed flush values; see deflate() below for details */
+
+#define Z_OK            0
+#define Z_STREAM_END    1
+#define Z_NEED_DICT     2
+#define Z_ERRNO        (-1)
+#define Z_STREAM_ERROR (-2)
+#define Z_DATA_ERROR   (-3)
+#define Z_MEM_ERROR    (-4)
+#define Z_BUF_ERROR    (-5)
+#define Z_VERSION_ERROR (-6)
+/* Return codes for the compression/decompression functions. Negative
+ * values are errors, positive values are used for special but normal events.
+ */
+
+#define Z_NO_COMPRESSION         0
+#define Z_BEST_SPEED             1
+#define Z_BEST_COMPRESSION       9
+#define Z_DEFAULT_COMPRESSION  (-1)
+/* compression levels */
+
+#define Z_FILTERED            1
+#define Z_HUFFMAN_ONLY        2
+#define Z_DEFAULT_STRATEGY    0
+/* compression strategy; see deflateInit2() below for details */
+
+#define Z_BINARY   0
+#define Z_ASCII    1
+#define Z_UNKNOWN  2
+/* Possible values of the data_type field */
+
+#define Z_DEFLATED   8
+/* The deflate compression method (the only one supported in this version) */
+
+#define Z_NULL  0  /* for initializing zalloc, zfree, opaque */
+
+#define zlib_version zlibVersion()
+/* for compatibility with versions < 1.0.2 */
+
+                        /* basic functions */
+
+ZEXTERN const char * ZEXPORT zlibVersion OF((void));
+/* The application can compare zlibVersion and ZLIB_VERSION for consistency.
+   If the first character differs, the library code actually used is
+   not compatible with the zlib.h header file used by the application.
+   This check is automatically made by deflateInit and inflateInit.
+ */
+
+/* 
+ZEXTERN int ZEXPORT deflateInit OF((z_streamp strm, int level));
+
+     Initializes the internal stream state for compression. The fields
+   zalloc, zfree and opaque must be initialized before by the caller.
+   If zalloc and zfree are set to Z_NULL, deflateInit updates them to
+   use default allocation functions.
+
+     The compression level must be Z_DEFAULT_COMPRESSION, or between 0 and 9:
+   1 gives best speed, 9 gives best compression, 0 gives no compression at
+   all (the input data is simply copied a block at a time).
+   Z_DEFAULT_COMPRESSION requests a default compromise between speed and
+   compression (currently equivalent to level 6).
+
+     deflateInit returns Z_OK if success, Z_MEM_ERROR if there was not
+   enough memory, Z_STREAM_ERROR if level is not a valid compression level,
+   Z_VERSION_ERROR if the zlib library version (zlib_version) is incompatible
+   with the version assumed by the caller (ZLIB_VERSION).
+   msg is set to null if there is no error message.  deflateInit does not
+   perform any compression: this will be done by deflate().
+*/
+
+
+ZEXTERN int ZEXPORT deflate OF((z_streamp strm, int flush));
+/*
+    deflate compresses as much data as possible, and stops when the input
+  buffer becomes empty or the output buffer becomes full. It may introduce some
+  output latency (reading input without producing any output) except when
+  forced to flush.
+
+    The detailed semantics are as follows. deflate performs one or both of the
+  following actions:
+
+  - Compress more input starting at next_in and update next_in and avail_in
+    accordingly. If not all input can be processed (because there is not
+    enough room in the output buffer), next_in and avail_in are updated and
+    processing will resume at this point for the next call of deflate().
+
+  - Provide more output starting at next_out and update next_out and avail_out
+    accordingly. This action is forced if the parameter flush is non zero.
+    Forcing flush frequently degrades the compression ratio, so this parameter
+    should be set only when necessary (in interactive applications).
+    Some output may be provided even if flush is not set.
+
+  Before the call of deflate(), the application should ensure that at least
+  one of the actions is possible, by providing more input and/or consuming
+  more output, and updating avail_in or avail_out accordingly; avail_out
+  should never be zero before the call. The application can consume the
+  compressed output when it wants, for example when the output buffer is full
+  (avail_out == 0), or after each call of deflate(). If deflate returns Z_OK
+  and with zero avail_out, it must be called again after making room in the
+  output buffer because there might be more output pending.
+
+    If the parameter flush is set to Z_SYNC_FLUSH, all pending output is
+  flushed to the output buffer and the output is aligned on a byte boundary, so
+  that the decompressor can get all input data available so far. (In particular
+  avail_in is zero after the call if enough output space has been provided
+  before the call.)  Flushing may degrade compression for some compression
+  algorithms and so it should be used only when necessary.
+
+    If flush is set to Z_FULL_FLUSH, all output is flushed as with
+  Z_SYNC_FLUSH, and the compression state is reset so that decompression can
+  restart from this point if previous compressed data has been damaged or if
+  random access is desired. Using Z_FULL_FLUSH too often can seriously degrade
+  the compression.
+
+    If deflate returns with avail_out == 0, this function must be called again
+  with the same value of the flush parameter and more output space (updated
+  avail_out), until the flush is complete (deflate returns with non-zero
+  avail_out).
+
+    If the parameter flush is set to Z_FINISH, pending input is processed,
+  pending output is flushed and deflate returns with Z_STREAM_END if there
+  was enough output space; if deflate returns with Z_OK, this function must be
+  called again with Z_FINISH and more output space (updated avail_out) but no
+  more input data, until it returns with Z_STREAM_END or an error. After
+  deflate has returned Z_STREAM_END, the only possible operations on the
+  stream are deflateReset or deflateEnd.
+  
+    Z_FINISH can be used immediately after deflateInit if all the compression
+  is to be done in a single step. In this case, avail_out must be at least
+  0.1% larger than avail_in plus 12 bytes.  If deflate does not return
+  Z_STREAM_END, then it must be called again as described above.
+
+    deflate() sets strm->adler to the adler32 checksum of all input read
+  so far (that is, total_in bytes).
+
+    deflate() may update data_type if it can make a good guess about
+  the input data type (Z_ASCII or Z_BINARY). In doubt, the data is considered
+  binary. This field is only for information purposes and does not affect
+  the compression algorithm in any manner.
+
+    deflate() returns Z_OK if some progress has been made (more input
+  processed or more output produced), Z_STREAM_END if all input has been
+  consumed and all output has been produced (only when flush is set to
+  Z_FINISH), Z_STREAM_ERROR if the stream state was inconsistent (for example
+  if next_in or next_out was NULL), Z_BUF_ERROR if no progress is possible
+  (for example avail_in or avail_out was zero).
+*/
+
+
+ZEXTERN int ZEXPORT deflateEnd OF((z_streamp strm));
+/*
+     All dynamically allocated data structures for this stream are freed.
+   This function discards any unprocessed input and does not flush any
+   pending output.
+
+     deflateEnd returns Z_OK if success, Z_STREAM_ERROR if the
+   stream state was inconsistent, Z_DATA_ERROR if the stream was freed
+   prematurely (some input or output was discarded). In the error case,
+   msg may be set but then points to a static string (which must not be
+   deallocated).
+*/
+
+
+/* 
+ZEXTERN int ZEXPORT inflateInit OF((z_streamp strm));
+
+     Initializes the internal stream state for decompression. The fields
+   next_in, avail_in, zalloc, zfree and opaque must be initialized before by
+   the caller. If next_in is not Z_NULL and avail_in is large enough (the exact
+   value depends on the compression method), inflateInit determines the
+   compression method from the zlib header and allocates all data structures
+   accordingly; otherwise the allocation will be deferred to the first call of
+   inflate.  If zalloc and zfree are set to Z_NULL, inflateInit updates them to
+   use default allocation functions.
+
+     inflateInit returns Z_OK if success, Z_MEM_ERROR if there was not enough
+   memory, Z_VERSION_ERROR if the zlib library version is incompatible with the
+   version assumed by the caller.  msg is set to null if there is no error
+   message. inflateInit does not perform any decompression apart from reading
+   the zlib header if present: this will be done by inflate().  (So next_in and
+   avail_in may be modified, but next_out and avail_out are unchanged.)
+*/
+
+
+ZEXTERN int ZEXPORT inflate OF((z_streamp strm, int flush));
+/*
+    inflate decompresses as much data as possible, and stops when the input
+  buffer becomes empty or the output buffer becomes full. It may some
+  introduce some output latency (reading input without producing any output)
+  except when forced to flush.
+
+  The detailed semantics are as follows. inflate performs one or both of the
+  following actions:
+
+  - Decompress more input starting at next_in and update next_in and avail_in
+    accordingly. If not all input can be processed (because there is not
+    enough room in the output buffer), next_in is updated and processing
+    will resume at this point for the next call of inflate().
+
+  - Provide more output starting at next_out and update next_out and avail_out
+    accordingly.  inflate() provides as much output as possible, until there
+    is no more input data or no more space in the output buffer (see below
+    about the flush parameter).
+
+  Before the call of inflate(), the application should ensure that at least
+  one of the actions is possible, by providing more input and/or consuming
+  more output, and updating the next_* and avail_* values accordingly.
+  The application can consume the uncompressed output when it wants, for
+  example when the output buffer is full (avail_out == 0), or after each
+  call of inflate(). If inflate returns Z_OK and with zero avail_out, it
+  must be called again after making room in the output buffer because there
+  might be more output pending.
+
+    If the parameter flush is set to Z_SYNC_FLUSH, inflate flushes as much
+  output as possible to the output buffer. The flushing behavior of inflate is
+  not specified for values of the flush parameter other than Z_SYNC_FLUSH
+  and Z_FINISH, but the current implementation actually flushes as much output
+  as possible anyway.
+
+    inflate() should normally be called until it returns Z_STREAM_END or an
+  error. However if all decompression is to be performed in a single step
+  (a single call of inflate), the parameter flush should be set to
+  Z_FINISH. In this case all pending input is processed and all pending
+  output is flushed; avail_out must be large enough to hold all the
+  uncompressed data. (The size of the uncompressed data may have been saved
+  by the compressor for this purpose.) The next operation on this stream must
+  be inflateEnd to deallocate the decompression state. The use of Z_FINISH
+  is never required, but can be used to inform inflate that a faster routine
+  may be used for the single inflate() call.
+
+     If a preset dictionary is needed at this point (see inflateSetDictionary
+  below), inflate sets strm-adler to the adler32 checksum of the
+  dictionary chosen by the compressor and returns Z_NEED_DICT; otherwise 
+  it sets strm->adler to the adler32 checksum of all output produced
+  so far (that is, total_out bytes) and returns Z_OK, Z_STREAM_END or
+  an error code as described below. At the end of the stream, inflate()
+  checks that its computed adler32 checksum is equal to that saved by the
+  compressor and returns Z_STREAM_END only if the checksum is correct.
+
+    inflate() returns Z_OK if some progress has been made (more input processed
+  or more output produced), Z_STREAM_END if the end of the compressed data has
+  been reached and all uncompressed output has been produced, Z_NEED_DICT if a
+  preset dictionary is needed at this point, Z_DATA_ERROR if the input data was
+  corrupted (input stream not conforming to the zlib format or incorrect
+  adler32 checksum), Z_STREAM_ERROR if the stream structure was inconsistent
+  (for example if next_in or next_out was NULL), Z_MEM_ERROR if there was not
+  enough memory, Z_BUF_ERROR if no progress is possible or if there was not
+  enough room in the output buffer when Z_FINISH is used. In the Z_DATA_ERROR
+  case, the application may then call inflateSync to look for a good
+  compression block.
+*/
+
+
+ZEXTERN int ZEXPORT inflateEnd OF((z_streamp strm));
+/*
+     All dynamically allocated data structures for this stream are freed.
+   This function discards any unprocessed input and does not flush any
+   pending output.
+
+     inflateEnd returns Z_OK if success, Z_STREAM_ERROR if the stream state
+   was inconsistent. In the error case, msg may be set but then points to a
+   static string (which must not be deallocated).
+*/
+
+                        /* Advanced functions */
+
+/*
+    The following functions are needed only in some special applications.
+*/
+
+/*   
+ZEXTERN int ZEXPORT deflateInit2 OF((z_streamp strm,
+                                     int  level,
+                                     int  method,
+                                     int  windowBits,
+                                     int  memLevel,
+                                     int  strategy));
+
+     This is another version of deflateInit with more compression options. The
+   fields next_in, zalloc, zfree and opaque must be initialized before by
+   the caller.
+
+     The method parameter is the compression method. It must be Z_DEFLATED in
+   this version of the library.
+
+     The windowBits parameter is the base two logarithm of the window size
+   (the size of the history buffer).  It should be in the range 8..15 for this
+   version of the library. Larger values of this parameter result in better
+   compression at the expense of memory usage. The default value is 15 if
+   deflateInit is used instead.
+
+     The memLevel parameter specifies how much memory should be allocated
+   for the internal compression state. memLevel=1 uses minimum memory but
+   is slow and reduces compression ratio; memLevel=9 uses maximum memory
+   for optimal speed. The default value is 8. See zconf.h for total memory
+   usage as a function of windowBits and memLevel.
+
+     The strategy parameter is used to tune the compression algorithm. Use the
+   value Z_DEFAULT_STRATEGY for normal data, Z_FILTERED for data produced by a
+   filter (or predictor), or Z_HUFFMAN_ONLY to force Huffman encoding only (no
+   string match).  Filtered data consists mostly of small values with a
+   somewhat random distribution. In this case, the compression algorithm is
+   tuned to compress them better. The effect of Z_FILTERED is to force more
+   Huffman coding and less string matching; it is somewhat intermediate
+   between Z_DEFAULT and Z_HUFFMAN_ONLY. The strategy parameter only affects
+   the compression ratio but not the correctness of the compressed output even
+   if it is not set appropriately.
+
+      deflateInit2 returns Z_OK if success, Z_MEM_ERROR if there was not enough
+   memory, Z_STREAM_ERROR if a parameter is invalid (such as an invalid
+   method). msg is set to null if there is no error message.  deflateInit2 does
+   not perform any compression: this will be done by deflate().
+*/
+                            
+ZEXTERN int ZEXPORT deflateSetDictionary OF((z_streamp strm,
+                                             const Bytef *dictionary,
+                                             uInt  dictLength));
+/*
+     Initializes the compression dictionary from the given byte sequence
+   without producing any compressed output. This function must be called
+   immediately after deflateInit, deflateInit2 or deflateReset, before any
+   call of deflate. The compressor and decompressor must use exactly the same
+   dictionary (see inflateSetDictionary).
+
+     The dictionary should consist of strings (byte sequences) that are likely
+   to be encountered later in the data to be compressed, with the most commonly
+   used strings preferably put towards the end of the dictionary. Using a
+   dictionary is most useful when the data to be compressed is short and can be
+   predicted with good accuracy; the data can then be compressed better than
+   with the default empty dictionary.
+
+     Depending on the size of the compression data structures selected by
+   deflateInit or deflateInit2, a part of the dictionary may in effect be
+   discarded, for example if the dictionary is larger than the window size in
+   deflate or deflate2. Thus the strings most likely to be useful should be
+   put at the end of the dictionary, not at the front.
+
+     Upon return of this function, strm->adler is set to the Adler32 value
+   of the dictionary; the decompressor may later use this value to determine
+   which dictionary has been used by the compressor. (The Adler32 value
+   applies to the whole dictionary even if only a subset of the dictionary is
+   actually used by the compressor.)
+
+     deflateSetDictionary returns Z_OK if success, or Z_STREAM_ERROR if a
+   parameter is invalid (such as NULL dictionary) or the stream state is
+   inconsistent (for example if deflate has already been called for this stream
+   or if the compression method is bsort). deflateSetDictionary does not
+   perform any compression: this will be done by deflate().
+*/
+
+ZEXTERN int ZEXPORT deflateCopy OF((z_streamp dest,
+                                    z_streamp source));
+/*
+     Sets the destination stream as a complete copy of the source stream.
+
+     This function can be useful when several compression strategies will be
+   tried, for example when there are several ways of pre-processing the input
+   data with a filter. The streams that will be discarded should then be freed
+   by calling deflateEnd.  Note that deflateCopy duplicates the internal
+   compression state which can be quite large, so this strategy is slow and
+   can consume lots of memory.
+
+     deflateCopy returns Z_OK if success, Z_MEM_ERROR if there was not
+   enough memory, Z_STREAM_ERROR if the source stream state was inconsistent
+   (such as zalloc being NULL). msg is left unchanged in both source and
+   destination.
+*/
+
+ZEXTERN int ZEXPORT deflateReset OF((z_streamp strm));
+/*
+     This function is equivalent to deflateEnd followed by deflateInit,
+   but does not free and reallocate all the internal compression state.
+   The stream will keep the same compression level and any other attributes
+   that may have been set by deflateInit2.
+
+      deflateReset returns Z_OK if success, or Z_STREAM_ERROR if the source
+   stream state was inconsistent (such as zalloc or state being NULL).
+*/
+
+ZEXTERN int ZEXPORT deflateParams OF((z_streamp strm,
+				      int level,
+				      int strategy));
+/*
+     Dynamically update the compression level and compression strategy.  The
+   interpretation of level and strategy is as in deflateInit2.  This can be
+   used to switch between compression and straight copy of the input data, or
+   to switch to a different kind of input data requiring a different
+   strategy. If the compression level is changed, the input available so far
+   is compressed with the old level (and may be flushed); the new level will
+   take effect only at the next call of deflate().
+
+     Before the call of deflateParams, the stream state must be set as for
+   a call of deflate(), since the currently available input may have to
+   be compressed and flushed. In particular, strm->avail_out must be non-zero.
+
+     deflateParams returns Z_OK if success, Z_STREAM_ERROR if the source
+   stream state was inconsistent or if a parameter was invalid, Z_BUF_ERROR
+   if strm->avail_out was zero.
+*/
+
+/*   
+ZEXTERN int ZEXPORT inflateInit2 OF((z_streamp strm,
+                                     int  windowBits));
+
+     This is another version of inflateInit with an extra parameter. The
+   fields next_in, avail_in, zalloc, zfree and opaque must be initialized
+   before by the caller.
+
+     The windowBits parameter is the base two logarithm of the maximum window
+   size (the size of the history buffer).  It should be in the range 8..15 for
+   this version of the library. The default value is 15 if inflateInit is used
+   instead. If a compressed stream with a larger window size is given as
+   input, inflate() will return with the error code Z_DATA_ERROR instead of
+   trying to allocate a larger window.
+
+      inflateInit2 returns Z_OK if success, Z_MEM_ERROR if there was not enough
+   memory, Z_STREAM_ERROR if a parameter is invalid (such as a negative
+   memLevel). msg is set to null if there is no error message.  inflateInit2
+   does not perform any decompression apart from reading the zlib header if
+   present: this will be done by inflate(). (So next_in and avail_in may be
+   modified, but next_out and avail_out are unchanged.)
+*/
+
+ZEXTERN int ZEXPORT inflateSetDictionary OF((z_streamp strm,
+                                             const Bytef *dictionary,
+                                             uInt  dictLength));
+/*
+     Initializes the decompression dictionary from the given uncompressed byte
+   sequence. This function must be called immediately after a call of inflate
+   if this call returned Z_NEED_DICT. The dictionary chosen by the compressor
+   can be determined from the Adler32 value returned by this call of
+   inflate. The compressor and decompressor must use exactly the same
+   dictionary (see deflateSetDictionary).
+
+     inflateSetDictionary returns Z_OK if success, Z_STREAM_ERROR if a
+   parameter is invalid (such as NULL dictionary) or the stream state is
+   inconsistent, Z_DATA_ERROR if the given dictionary doesn't match the
+   expected one (incorrect Adler32 value). inflateSetDictionary does not
+   perform any decompression: this will be done by subsequent calls of
+   inflate().
+*/
+
+ZEXTERN int ZEXPORT inflateSync OF((z_streamp strm));
+/* 
+    Skips invalid compressed data until a full flush point (see above the
+  description of deflate with Z_FULL_FLUSH) can be found, or until all
+  available input is skipped. No output is provided.
+
+    inflateSync returns Z_OK if a full flush point has been found, Z_BUF_ERROR
+  if no more input was provided, Z_DATA_ERROR if no flush point has been found,
+  or Z_STREAM_ERROR if the stream structure was inconsistent. In the success
+  case, the application may save the current current value of total_in which
+  indicates where valid compressed data was found. In the error case, the
+  application may repeatedly call inflateSync, providing more input each time,
+  until success or end of the input data.
+*/
+
+ZEXTERN int ZEXPORT inflateReset OF((z_streamp strm));
+/*
+     This function is equivalent to inflateEnd followed by inflateInit,
+   but does not free and reallocate all the internal decompression state.
+   The stream will keep attributes that may have been set by inflateInit2.
+
+      inflateReset returns Z_OK if success, or Z_STREAM_ERROR if the source
+   stream state was inconsistent (such as zalloc or state being NULL).
+*/
+
+
+                        /* utility functions */
+
+/*
+     The following utility functions are implemented on top of the
+   basic stream-oriented functions. To simplify the interface, some
+   default options are assumed (compression level and memory usage,
+   standard memory allocation functions). The source code of these
+   utility functions can easily be modified if you need special options.
+*/
+
+ZEXTERN int ZEXPORT compress OF((Bytef *dest,   uLongf *destLen,
+                                 const Bytef *source, uLong sourceLen));
+/*
+     Compresses the source buffer into the destination buffer.  sourceLen is
+   the byte length of the source buffer. Upon entry, destLen is the total
+   size of the destination buffer, which must be at least 0.1% larger than
+   sourceLen plus 12 bytes. Upon exit, destLen is the actual size of the
+   compressed buffer.
+     This function can be used to compress a whole file at once if the
+   input file is mmap'ed.
+     compress returns Z_OK if success, Z_MEM_ERROR if there was not
+   enough memory, Z_BUF_ERROR if there was not enough room in the output
+   buffer.
+*/
+
+ZEXTERN int ZEXPORT compress2 OF((Bytef *dest,   uLongf *destLen,
+                                  const Bytef *source, uLong sourceLen,
+                                  int level));
+/*
+     Compresses the source buffer into the destination buffer. The level
+   parameter has the same meaning as in deflateInit.  sourceLen is the byte
+   length of the source buffer. Upon entry, destLen is the total size of the
+   destination buffer, which must be at least 0.1% larger than sourceLen plus
+   12 bytes. Upon exit, destLen is the actual size of the compressed buffer.
+
+     compress2 returns Z_OK if success, Z_MEM_ERROR if there was not enough
+   memory, Z_BUF_ERROR if there was not enough room in the output buffer,
+   Z_STREAM_ERROR if the level parameter is invalid.
+*/
+
+ZEXTERN int ZEXPORT uncompress OF((Bytef *dest,   uLongf *destLen,
+                                   const Bytef *source, uLong sourceLen));
+/*
+     Decompresses the source buffer into the destination buffer.  sourceLen is
+   the byte length of the source buffer. Upon entry, destLen is the total
+   size of the destination buffer, which must be large enough to hold the
+   entire uncompressed data. (The size of the uncompressed data must have
+   been saved previously by the compressor and transmitted to the decompressor
+   by some mechanism outside the scope of this compression library.)
+   Upon exit, destLen is the actual size of the compressed buffer.
+     This function can be used to decompress a whole file at once if the
+   input file is mmap'ed.
+
+     uncompress returns Z_OK if success, Z_MEM_ERROR if there was not
+   enough memory, Z_BUF_ERROR if there was not enough room in the output
+   buffer, or Z_DATA_ERROR if the input data was corrupted.
+*/
+
+
+typedef voidp gzFile;
+
+ZEXTERN gzFile ZEXPORT gzopen  OF((const char *path, const char *mode));
+/*
+     Opens a gzip (.gz) file for reading or writing. The mode parameter
+   is as in fopen ("rb" or "wb") but can also include a compression level
+   ("wb9") or a strategy: 'f' for filtered data as in "wb6f", 'h' for
+   Huffman only compression as in "wb1h". (See the description
+   of deflateInit2 for more information about the strategy parameter.)
+
+     gzopen can be used to read a file which is not in gzip format; in this
+   case gzread will directly read from the file without decompression.
+
+     gzopen returns NULL if the file could not be opened or if there was
+   insufficient memory to allocate the (de)compression state; errno
+   can be checked to distinguish the two cases (if errno is zero, the
+   zlib error is Z_MEM_ERROR).  */
+
+ZEXTERN gzFile ZEXPORT gzdopen  OF((int fd, const char *mode));
+/*
+     gzdopen() associates a gzFile with the file descriptor fd.  File
+   descriptors are obtained from calls like open, dup, creat, pipe or
+   fileno (in the file has been previously opened with fopen).
+   The mode parameter is as in gzopen.
+     The next call of gzclose on the returned gzFile will also close the
+   file descriptor fd, just like fclose(fdopen(fd), mode) closes the file
+   descriptor fd. If you want to keep fd open, use gzdopen(dup(fd), mode).
+     gzdopen returns NULL if there was insufficient memory to allocate
+   the (de)compression state.
+*/
+
+ZEXTERN int ZEXPORT gzsetparams OF((gzFile file, int level, int strategy));
+/*
+     Dynamically update the compression level or strategy. See the description
+   of deflateInit2 for the meaning of these parameters.
+     gzsetparams returns Z_OK if success, or Z_STREAM_ERROR if the file was not
+   opened for writing.
+*/
+
+ZEXTERN int ZEXPORT    gzread  OF((gzFile file, voidp buf, unsigned len));
+/*
+     Reads the given number of uncompressed bytes from the compressed file.
+   If the input file was not in gzip format, gzread copies the given number
+   of bytes into the buffer.
+     gzread returns the number of uncompressed bytes actually read (0 for
+   end of file, -1 for error). */
+
+ZEXTERN int ZEXPORT    gzwrite OF((gzFile file, 
+				   const voidp buf, unsigned len));
+/*
+     Writes the given number of uncompressed bytes into the compressed file.
+   gzwrite returns the number of uncompressed bytes actually written
+   (0 in case of error).
+*/
+
+ZEXTERN int ZEXPORTVA   gzprintf OF((gzFile file, const char *format, ...));
+/*
+     Converts, formats, and writes the args to the compressed file under
+   control of the format string, as in fprintf. gzprintf returns the number of
+   uncompressed bytes actually written (0 in case of error).
+*/
+
+ZEXTERN int ZEXPORT gzputs OF((gzFile file, const char *s));
+/*
+      Writes the given null-terminated string to the compressed file, excluding
+   the terminating null character.
+      gzputs returns the number of characters written, or -1 in case of error.
+*/
+
+ZEXTERN char * ZEXPORT gzgets OF((gzFile file, char *buf, int len));
+/*
+      Reads bytes from the compressed file until len-1 characters are read, or
+   a newline character is read and transferred to buf, or an end-of-file
+   condition is encountered.  The string is then terminated with a null
+   character.
+      gzgets returns buf, or Z_NULL in case of error.
+*/
+
+ZEXTERN int ZEXPORT    gzputc OF((gzFile file, int c));
+/*
+      Writes c, converted to an unsigned char, into the compressed file.
+   gzputc returns the value that was written, or -1 in case of error.
+*/
+
+ZEXTERN int ZEXPORT    gzgetc OF((gzFile file));
+/*
+      Reads one byte from the compressed file. gzgetc returns this byte
+   or -1 in case of end of file or error.
+*/
+
+ZEXTERN int ZEXPORT    gzflush OF((gzFile file, int flush));
+/*
+     Flushes all pending output into the compressed file. The parameter
+   flush is as in the deflate() function. The return value is the zlib
+   error number (see function gzerror below). gzflush returns Z_OK if
+   the flush parameter is Z_FINISH and all output could be flushed.
+     gzflush should be called only when strictly necessary because it can
+   degrade compression.
+*/
+
+ZEXTERN z_off_t ZEXPORT    gzseek OF((gzFile file,
+				      z_off_t offset, int whence));
+/* 
+      Sets the starting position for the next gzread or gzwrite on the
+   given compressed file. The offset represents a number of bytes in the
+   uncompressed data stream. The whence parameter is defined as in lseek(2);
+   the value SEEK_END is not supported.
+     If the file is opened for reading, this function is emulated but can be
+   extremely slow. If the file is opened for writing, only forward seeks are
+   supported; gzseek then compresses a sequence of zeroes up to the new
+   starting position.
+
+      gzseek returns the resulting offset location as measured in bytes from
+   the beginning of the uncompressed stream, or -1 in case of error, in
+   particular if the file is opened for writing and the new starting position
+   would be before the current position.
+*/
+
+ZEXTERN int ZEXPORT    gzrewind OF((gzFile file));
+/*
+     Rewinds the given file. This function is supported only for reading.
+
+   gzrewind(file) is equivalent to (int)gzseek(file, 0L, SEEK_SET)
+*/
+
+ZEXTERN z_off_t ZEXPORT    gztell OF((gzFile file));
+/*
+     Returns the starting position for the next gzread or gzwrite on the
+   given compressed file. This position represents a number of bytes in the
+   uncompressed data stream.
+
+   gztell(file) is equivalent to gzseek(file, 0L, SEEK_CUR)
+*/
+
+ZEXTERN int ZEXPORT gzeof OF((gzFile file));
+/*
+     Returns 1 when EOF has previously been detected reading the given
+   input stream, otherwise zero.
+*/
+
+ZEXTERN int ZEXPORT    gzclose OF((gzFile file));
+/*
+     Flushes all pending output if necessary, closes the compressed file
+   and deallocates all the (de)compression state. The return value is the zlib
+   error number (see function gzerror below).
+*/
+
+ZEXTERN const char * ZEXPORT gzerror OF((gzFile file, int *errnum));
+/*
+     Returns the error message for the last error which occurred on the
+   given compressed file. errnum is set to zlib error number. If an
+   error occurred in the file system and not in the compression library,
+   errnum is set to Z_ERRNO and the application may consult errno
+   to get the exact error code.
+*/
+
+                        /* checksum functions */
+
+/*
+     These functions are not related to compression but are exported
+   anyway because they might be useful in applications using the
+   compression library.
+*/
+
+ZEXTERN uLong ZEXPORT adler32 OF((uLong adler, const Bytef *buf, uInt len));
+
+/*
+     Update a running Adler-32 checksum with the bytes buf[0..len-1] and
+   return the updated checksum. If buf is NULL, this function returns
+   the required initial value for the checksum.
+   An Adler-32 checksum is almost as reliable as a CRC32 but can be computed
+   much faster. Usage example:
+
+     uLong adler = adler32(0L, Z_NULL, 0);
+
+     while (read_buffer(buffer, length) != EOF) {
+       adler = adler32(adler, buffer, length);
+     }
+     if (adler != original_adler) error();
+*/
+
+ZEXTERN uLong ZEXPORT crc32   OF((uLong crc, const Bytef *buf, uInt len));
+/*
+     Update a running crc with the bytes buf[0..len-1] and return the updated
+   crc. If buf is NULL, this function returns the required initial value
+   for the crc. Pre- and post-conditioning (one's complement) is performed
+   within this function so it shouldn't be done by the application.
+   Usage example:
+
+     uLong crc = crc32(0L, Z_NULL, 0);
+
+     while (read_buffer(buffer, length) != EOF) {
+       crc = crc32(crc, buffer, length);
+     }
+     if (crc != original_crc) error();
+*/
+
+
+                        /* various hacks, don't look :) */
+
+/* deflateInit and inflateInit are macros to allow checking the zlib version
+ * and the compiler's view of z_stream:
+ */
+ZEXTERN int ZEXPORT deflateInit_ OF((z_streamp strm, int level,
+                                     const char *version, int stream_size));
+ZEXTERN int ZEXPORT inflateInit_ OF((z_streamp strm,
+                                     const char *version, int stream_size));
+ZEXTERN int ZEXPORT deflateInit2_ OF((z_streamp strm, int  level, int  method,
+                                      int windowBits, int memLevel,
+                                      int strategy, const char *version,
+                                      int stream_size));
+ZEXTERN int ZEXPORT inflateInit2_ OF((z_streamp strm, int  windowBits,
+                                      const char *version, int stream_size));
+#define deflateInit(strm, level) \
+        deflateInit_((strm), (level),       ZLIB_VERSION, sizeof(z_stream))
+#define inflateInit(strm) \
+        inflateInit_((strm),                ZLIB_VERSION, sizeof(z_stream))
+#define deflateInit2(strm, level, method, windowBits, memLevel, strategy) \
+        deflateInit2_((strm),(level),(method),(windowBits),(memLevel),\
+                      (strategy),           ZLIB_VERSION, sizeof(z_stream))
+#define inflateInit2(strm, windowBits) \
+        inflateInit2_((strm), (windowBits), ZLIB_VERSION, sizeof(z_stream))
+
+
+#if !defined(_Z_UTIL_H) && !defined(NO_DUMMY_DECL)
+    struct internal_state {int dummy;}; /* hack for buggy compilers */
+#endif
+
+ZEXTERN const char   * ZEXPORT zError           OF((int err));
+ZEXTERN int            ZEXPORT inflateSyncPoint OF((z_streamp z));
+ZEXTERN const uLongf * ZEXPORT get_crc_table    OF((void));
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _ZLIB_H */
diff --git a/src/unix/contrib/cutzlib-1.1.4/zutil.c b/src/unix/contrib/cutzlib-1.1.4/zutil.c
new file mode 100644
index 0000000..fe32507
--- /dev/null
+++ b/src/unix/contrib/cutzlib-1.1.4/zutil.c
@@ -0,0 +1,225 @@
+/* zutil.c -- target dependent utility functions for the compression library
+ * Copyright (C) 1995-2002 Jean-loup Gailly.
+ * For conditions of distribution and use, see copyright notice in zlib.h 
+ */
+
+/* @(#) $Id: zutil.c,v 1.1 2002/04/18 21:15:10 l_g Exp $ */
+
+#include "zutil.h"
+
+struct internal_state      {int dummy;}; /* for buggy compilers */
+
+#ifndef STDC
+extern void exit OF((int));
+#endif
+
+const char *z_errmsg[10] = {
+"need dictionary",     /* Z_NEED_DICT       2  */
+"stream end",          /* Z_STREAM_END      1  */
+"",                    /* Z_OK              0  */
+"file error",          /* Z_ERRNO         (-1) */
+"stream error",        /* Z_STREAM_ERROR  (-2) */
+"data error",          /* Z_DATA_ERROR    (-3) */
+"insufficient memory", /* Z_MEM_ERROR     (-4) */
+"buffer error",        /* Z_BUF_ERROR     (-5) */
+"incompatible version",/* Z_VERSION_ERROR (-6) */
+""};
+
+
+const char * ZEXPORT zlibVersion()
+{
+    return ZLIB_VERSION;
+}
+
+#ifdef DEBUG
+
+#  ifndef verbose
+#    define verbose 0
+#  endif
+int z_verbose = verbose;
+
+void z_error (m)
+    char *m;
+{
+    fprintf(stderr, "%s\n", m);
+    exit(1);
+}
+#endif
+
+/* exported to allow conversion of error code to string for compress() and
+ * uncompress()
+ */
+const char * ZEXPORT zError(err)
+    int err;
+{
+    return ERR_MSG(err);
+}
+
+
+#ifndef HAVE_MEMCPY
+
+void zmemcpy(dest, source, len)
+    Bytef* dest;
+    const Bytef* source;
+    uInt  len;
+{
+    if (len == 0) return;
+    do {
+        *dest++ = *source++; /* ??? to be unrolled */
+    } while (--len != 0);
+}
+
+int zmemcmp(s1, s2, len)
+    const Bytef* s1;
+    const Bytef* s2;
+    uInt  len;
+{
+    uInt j;
+
+    for (j = 0; j < len; j++) {
+        if (s1[j] != s2[j]) return 2*(s1[j] > s2[j])-1;
+    }
+    return 0;
+}
+
+void zmemzero(dest, len)
+    Bytef* dest;
+    uInt  len;
+{
+    if (len == 0) return;
+    do {
+        *dest++ = 0;  /* ??? to be unrolled */
+    } while (--len != 0);
+}
+#endif
+
+#ifdef __TURBOC__
+#if (defined( __BORLANDC__) || !defined(SMALL_MEDIUM)) && !defined(__32BIT__)
+/* Small and medium model in Turbo C are for now limited to near allocation
+ * with reduced MAX_WBITS and MAX_MEM_LEVEL
+ */
+#  define MY_ZCALLOC
+
+/* Turbo C malloc() does not allow dynamic allocation of 64K bytes
+ * and farmalloc(64K) returns a pointer with an offset of 8, so we
+ * must fix the pointer. Warning: the pointer must be put back to its
+ * original form in order to free it, use zcfree().
+ */
+
+#define MAX_PTR 10
+/* 10*64K = 640K */
+
+local int next_ptr = 0;
+
+typedef struct ptr_table_s {
+    voidpf org_ptr;
+    voidpf new_ptr;
+} ptr_table;
+
+local ptr_table table[MAX_PTR];
+/* This table is used to remember the original form of pointers
+ * to large buffers (64K). Such pointers are normalized with a zero offset.
+ * Since MSDOS is not a preemptive multitasking OS, this table is not
+ * protected from concurrent access. This hack doesn't work anyway on
+ * a protected system like OS/2. Use Microsoft C instead.
+ */
+
+voidpf zcalloc (voidpf opaque, unsigned items, unsigned size)
+{
+    voidpf buf = opaque; /* just to make some compilers happy */
+    ulg bsize = (ulg)items*size;
+
+    /* If we allocate less than 65520 bytes, we assume that farmalloc
+     * will return a usable pointer which doesn't have to be normalized.
+     */
+    if (bsize < 65520L) {
+        buf = farmalloc(bsize);
+        if (*(ush*)&buf != 0) return buf;
+    } else {
+        buf = farmalloc(bsize + 16L);
+    }
+    if (buf == NULL || next_ptr >= MAX_PTR) return NULL;
+    table[next_ptr].org_ptr = buf;
+
+    /* Normalize the pointer to seg:0 */
+    *((ush*)&buf+1) += ((ush)((uch*)buf-0) + 15) >> 4;
+    *(ush*)&buf = 0;
+    table[next_ptr++].new_ptr = buf;
+    return buf;
+}
+
+void  zcfree (voidpf opaque, voidpf ptr)
+{
+    int n;
+    if (*(ush*)&ptr != 0) { /* object < 64K */
+        farfree(ptr);
+        return;
+    }
+    /* Find the original pointer */
+    for (n = 0; n < next_ptr; n++) {
+        if (ptr != table[n].new_ptr) continue;
+
+        farfree(table[n].org_ptr);
+        while (++n < next_ptr) {
+            table[n-1] = table[n];
+        }
+        next_ptr--;
+        return;
+    }
+    ptr = opaque; /* just to make some compilers happy */
+    Assert(0, "zcfree: ptr not found");
+}
+#endif
+#endif /* __TURBOC__ */
+
+
+#if defined(M_I86) && !defined(__32BIT__)
+/* Microsoft C in 16-bit mode */
+
+#  define MY_ZCALLOC
+
+#if (!defined(_MSC_VER) || (_MSC_VER <= 600))
+#  define _halloc  halloc
+#  define _hfree   hfree
+#endif
+
+voidpf zcalloc (voidpf opaque, unsigned items, unsigned size)
+{
+    if (opaque) opaque = 0; /* to make compiler happy */
+    return _halloc((long)items, size);
+}
+
+void  zcfree (voidpf opaque, voidpf ptr)
+{
+    if (opaque) opaque = 0; /* to make compiler happy */
+    _hfree(ptr);
+}
+
+#endif /* MSC */
+
+
+#ifndef MY_ZCALLOC /* Any system without a special alloc function */
+
+#ifndef STDC
+extern voidp  calloc OF((uInt items, uInt size));
+extern void   free   OF((voidpf ptr));
+#endif
+
+voidpf zcalloc (opaque, items, size)
+    voidpf opaque;
+    unsigned items;
+    unsigned size;
+{
+    if (opaque) items += size - size; /* make compiler happy */
+    return (voidpf)calloc(items, size);
+}
+
+void  zcfree (opaque, ptr)
+    voidpf opaque;
+    voidpf ptr;
+{
+    free(ptr);
+    if (opaque) return; /* make compiler happy */
+}
+
+#endif /* MY_ZCALLOC */
diff --git a/src/unix/contrib/cutzlib-1.1.4/zutil.h b/src/unix/contrib/cutzlib-1.1.4/zutil.h
new file mode 100644
index 0000000..b3cbba9
--- /dev/null
+++ b/src/unix/contrib/cutzlib-1.1.4/zutil.h
@@ -0,0 +1,220 @@
+/* zutil.h -- internal interface and configuration of the compression library
+ * Copyright (C) 1995-2002 Jean-loup Gailly.
+ * For conditions of distribution and use, see copyright notice in zlib.h
+ */
+
+/* WARNING: this file should *not* be used by applications. It is
+   part of the implementation of the compression library and is
+   subject to change. Applications should only use zlib.h.
+ */
+
+/* @(#) $Id: zutil.h,v 1.1 2002/04/18 21:15:10 l_g Exp $ */
+
+#ifndef _Z_UTIL_H
+#define _Z_UTIL_H
+
+#include "zlib.h"
+
+#ifdef STDC
+#  include <stddef.h>
+#  include <string.h>
+#  include <stdlib.h>
+#endif
+#ifdef NO_ERRNO_H
+    extern int errno;
+#else
+#   include <errno.h>
+#endif
+
+#ifndef local
+#  define local static
+#endif
+/* compile with -Dlocal if your debugger can't find static symbols */
+
+typedef unsigned char  uch;
+typedef uch FAR uchf;
+typedef unsigned short ush;
+typedef ush FAR ushf;
+typedef unsigned long  ulg;
+
+extern const char *z_errmsg[10]; /* indexed by 2-zlib_error */
+/* (size given to avoid silly warnings with Visual C++) */
+
+#define ERR_MSG(err) z_errmsg[Z_NEED_DICT-(err)]
+
+#define ERR_RETURN(strm,err) \
+  return (strm->msg = (char*)ERR_MSG(err), (err))
+/* To be used only when the state is known to be valid */
+
+        /* common constants */
+
+#ifndef DEF_WBITS
+#  define DEF_WBITS MAX_WBITS
+#endif
+/* default windowBits for decompression. MAX_WBITS is for compression only */
+
+#if MAX_MEM_LEVEL >= 8
+#  define DEF_MEM_LEVEL 8
+#else
+#  define DEF_MEM_LEVEL  MAX_MEM_LEVEL
+#endif
+/* default memLevel */
+
+#define STORED_BLOCK 0
+#define STATIC_TREES 1
+#define DYN_TREES    2
+/* The three kinds of block type */
+
+#define MIN_MATCH  3
+#define MAX_MATCH  258
+/* The minimum and maximum match lengths */
+
+#define PRESET_DICT 0x20 /* preset dictionary flag in zlib header */
+
+        /* target dependencies */
+
+#ifdef MSDOS
+#  define OS_CODE  0x00
+#  if defined(__TURBOC__) || defined(__BORLANDC__)
+#    if(__STDC__ == 1) && (defined(__LARGE__) || defined(__COMPACT__))
+       /* Allow compilation with ANSI keywords only enabled */
+       void _Cdecl farfree( void *block );
+       void *_Cdecl farmalloc( unsigned long nbytes );
+#    else
+#     include <alloc.h>
+#    endif
+#  else /* MSC or DJGPP */
+#    include <malloc.h>
+#  endif
+#endif
+
+#ifdef OS2
+#  define OS_CODE  0x06
+#endif
+
+#ifdef WIN32 /* Window 95 & Windows NT */
+#  define OS_CODE  0x0b
+#endif
+
+#if defined(VAXC) || defined(VMS)
+#  define OS_CODE  0x02
+#  define F_OPEN(name, mode) \
+     fopen((name), (mode), "mbc=60", "ctx=stm", "rfm=fix", "mrs=512")
+#endif
+
+#ifdef AMIGA
+#  define OS_CODE  0x01
+#endif
+
+#if defined(ATARI) || defined(atarist)
+#  define OS_CODE  0x05
+#endif
+
+#if defined(MACOS) || defined(TARGET_OS_MAC)
+#  define OS_CODE  0x07
+#  if defined(__MWERKS__) && __dest_os != __be_os && __dest_os != __win32_os
+#    include <unix.h> /* for fdopen */
+#  else
+#    ifndef fdopen
+#      define fdopen(fd,mode) NULL /* No fdopen() */
+#    endif
+#  endif
+#endif
+
+#ifdef __50SERIES /* Prime/PRIMOS */
+#  define OS_CODE  0x0F
+#endif
+
+#ifdef TOPS20
+#  define OS_CODE  0x0a
+#endif
+
+#if defined(_BEOS_) || defined(RISCOS)
+#  define fdopen(fd,mode) NULL /* No fdopen() */
+#endif
+
+#if (defined(_MSC_VER) && (_MSC_VER > 600))
+#  define fdopen(fd,type)  _fdopen(fd,type)
+#endif
+
+
+        /* Common defaults */
+
+#ifndef OS_CODE
+#  define OS_CODE  0x03  /* assume Unix */
+#endif
+
+#ifndef F_OPEN
+#  define F_OPEN(name, mode) fopen((name), (mode))
+#endif
+
+         /* functions */
+
+#ifdef HAVE_STRERROR
+   extern char *strerror OF((int));
+#  define zstrerror(errnum) strerror(errnum)
+#else
+#  define zstrerror(errnum) ""
+#endif
+
+#if defined(pyr)
+#  define NO_MEMCPY
+#endif
+#if defined(SMALL_MEDIUM) && !defined(_MSC_VER) && !defined(__SC__)
+ /* Use our own functions for small and medium model with MSC <= 5.0.
+  * You may have to use the same strategy for Borland C (untested).
+  * The __SC__ check is for Symantec.
+  */
+#  define NO_MEMCPY
+#endif
+#if defined(STDC) && !defined(HAVE_MEMCPY) && !defined(NO_MEMCPY)
+#  define HAVE_MEMCPY
+#endif
+#ifdef HAVE_MEMCPY
+#  ifdef SMALL_MEDIUM /* MSDOS small or medium model */
+#    define zmemcpy _fmemcpy
+#    define zmemcmp _fmemcmp
+#    define zmemzero(dest, len) _fmemset(dest, 0, len)
+#  else
+#    define zmemcpy memcpy
+#    define zmemcmp memcmp
+#    define zmemzero(dest, len) memset(dest, 0, len)
+#  endif
+#else
+   extern void zmemcpy  OF((Bytef* dest, const Bytef* source, uInt len));
+   extern int  zmemcmp  OF((const Bytef* s1, const Bytef* s2, uInt len));
+   extern void zmemzero OF((Bytef* dest, uInt len));
+#endif
+
+/* Diagnostic functions */
+#ifdef DEBUG
+#  include <stdio.h>
+   extern int z_verbose;
+   extern void z_error    OF((char *m));
+#  define Assert(cond,msg) {if(!(cond)) z_error(msg);}
+#  define Trace(x) {if (z_verbose>=0) fprintf x ;}
+#  define Tracev(x) {if (z_verbose>0) fprintf x ;}
+#  define Tracevv(x) {if (z_verbose>1) fprintf x ;}
+#  define Tracec(c,x) {if (z_verbose>0 && (c)) fprintf x ;}
+#  define Tracecv(c,x) {if (z_verbose>1 && (c)) fprintf x ;}
+#else
+#  define Assert(cond,msg)
+#  define Trace(x)
+#  define Tracev(x)
+#  define Tracevv(x)
+#  define Tracec(c,x)
+#  define Tracecv(c,x)
+#endif
+
+
+typedef uLong (ZEXPORT *check_func) OF((uLong check, const Bytef *buf,
+				       uInt len));
+voidpf zcalloc OF((voidpf opaque, unsigned items, unsigned size));
+void   zcfree  OF((voidpf opaque, voidpf ptr));
+
+#define ZALLOC(strm, items, size) \
+           (*((strm)->zalloc))((strm)->opaque, (items), (size))
+#define ZFREE(strm, addr)  (*((strm)->zfree))((strm)->opaque, (voidpf)(addr))
+#define TRY_FREE(s, p) {if (p) ZFREE(s, p);}
+
+#endif /* _Z_UTIL_H */
diff --git a/src/unix/contrib/frontends/Mameload-Fvwm95 b/src/unix/contrib/frontends/Mameload-Fvwm95
new file mode 100644
index 0000000..ab52bbf
--- /dev/null
+++ b/src/unix/contrib/frontends/Mameload-Fvwm95
@@ -0,0 +1,53 @@
+#!/bin/sh
+##################################################################
+#	Mameload-Fvwm95 - Tom Jansen tom@toetag.com - 8/15/97	 #
+#							         #
+#	A cheap hack used as a gui for xmame under Fvwm95.	 #
+#	I wrote this because I'm lazy and didn't see the need	 #
+#	for wasting ram on a cool interface.			 #
+#	What the hell it works for me.				 #
+#							         #
+#							         #
+# To use this you must add the following line to your .fvwm95rc  #
+# file under the "AddToMenu Games" line. (or whatever)		 #
+#+ "X-mame            %mini-happy.xpm%"       Popup  X-mame      #
+#								 #
+# After running the script append the output (mamelist-new)	 #
+# to your .fvwm95rc and make any needed changes (like -scale 1)  #
+# Then restart Fvwm95. 						 #
+# Modifications for other window managers should be easy enuf.	 #
+#								 #
+# Instructions for fully automating new menus at the end	 #
+##################################################################
+GAMES=`xmame -listfull |grep -v NAMES |wc -l`
+xmame -listfull | sort -ifbk2 | grep -v NAME | awk '{print "+ "$2 $3 $4 $5 $6 $7 $8 $9" Exec xmame "$1" &"}'  >/tmp/foo
+
+rm -f /tmp/Mame-*
+split -l 40 /tmp/foo /tmp/Mame-
+
+echo "############# Start of Games supported by Xmame ##########" >/tmp/foo
+echo 'AddToMenu "X-mame" "X-mame  '$GAMES' Games" Title' >>/tmp/foo
+
+cd /tmp
+for i in `ls Mame*`
+do 
+echo '+ "More Games 	%mini-happy.xpm%"	Popup '$i >>/tmp/foo
+cat $i >>/tmp/foo
+echo 'AddToMenu "'$i'" "X-mame '$GAMES' Games" Title' >>/tmp/foo
+rm $i
+done
+mv /tmp/foo ~/mamelist-new
+clear
+echo ; echo
+echo " Your mamelist is complete - This version of Xmame supports $GAMES games"; echo
+###################################################################
+# IMPORTANT BEFORE USING THIS FEATURE COPY .fvwmrc to .fvwmrc.bak #
+# I won't be held responsible for you nuking your WM if you don't #
+#								  #
+# Ok, now assuming that you did copy .fvwm2rc95 to .fvwm2rc95.bak #
+# You can now uncomment the last line and your FVWM menus will    #
+# rebuild whenever you run this script.				  #
+###################################################################
+
+#cat ~/.fvwm2rc95.bak ~/mamelist-new > ~/.fvwm2rc95 ; echo "Don't forget to restart your Window Manager"
+
diff --git a/src/unix/contrib/frontends/mamex b/src/unix/contrib/frontends/mamex
new file mode 100755
index 0000000..f4a56ef
--- /dev/null
+++ b/src/unix/contrib/frontends/mamex
@@ -0,0 +1,103 @@
+#!/usr/bin/wish
+#
+# MAMEX - MAME front End v.2
+# 
+# Chris Sharp <sharpc@hursley.ibm.com>
+# 
+# 5/9/97
+#
+# updated by
+#
+# Matthias Brinkhoff <maxim@unity.owl.de>
+#
+# 04.08.98
+#
+
+wm title	. "M.A.M.E. selector"
+wm iconname	. "M.A.M.E. selector"
+
+set listmame xmame
+set gamemame xmame
+#set gamemame "runconsole smame"
+set joy 0
+set mouse 0
+set sound 1
+set FM 1
+set scale 0
+set cheat 0
+set throttle 1
+set frameskip 0
+set autoexit 0
+
+set mamelist [split [ exec -keepnewline $listmame 2>/dev/null -listfull | tail +2 | sort ] "\n" ]
+
+listbox .gameslist -relief raised -borderwidth 2 -yscrollcommand ".scroll set" -height 30 -width 0
+
+scrollbar .scroll -command ".gameslist yview"
+
+bind .gameslist <Double-1> "runMame" 
+
+checkbutton .sound -text sound -variable sound -anchor w 
+checkbutton .fm -text FM -variable FM -anchor w 
+checkbutton .joystick -text Joystick -variable joy -anchor w
+checkbutton .mouse -text Mouse -variable mouse -anchor w
+checkbutton .cheat -text Cheat -variable cheat -anchor w
+checkbutton .throttle -text Throttle -variable throttle -anchor w
+checkbutton .autoexit -text "Exit after launching" -variable autoexit -anchor w
+
+scale .scalefactor -label scale -from 1 -to 3 -orient horizontal -command "setScale"
+scale .frameskip -label frameskip -from 0 -to 4 -orient horizontal -command "setFrameskip"
+
+button .play -text "Play" -command "runMame"
+button .exit -text "Quit" -command exit
+
+foreach i $mamelist {
+  if {$i != "" } {
+    set titlelist [split $i { \"} ]
+    set index [string trim [lindex $titlelist 0]]
+    if {$index != "NAMES:"} {
+      set title [string trim [join [lrange $titlelist 1 end]]]
+      set allGames($title) $index
+      .gameslist insert end $title 
+    }
+  }
+}
+
+pack .gameslist -side left -fill both -expand 1
+pack .scroll -side left -fill y
+pack .sound .fm .joystick .mouse .cheat .throttle .autoexit -side top -anchor w
+pack .scalefactor -side top -anchor w
+pack .frameskip -side top -anchor w
+pack .play .exit -side left -fill x 
+
+proc runMame {} {
+  global sound FM scale frameskip allGames TB mouse joy cheat throttle autoexit gamemame
+  set game "" 
+  set game $allGames([selection get])
+  set options ""
+  if {$sound} { set options " -sound " }
+  if {$FM} { set options "$options -fm " }
+  if {$joy} { set options "$options -joy " }
+  if {$mouse} { set options "$options -mouse" }
+  if {$scale} { set options "$options -scale $scale" }
+  if {$frameskip} { set options "$options -frameskip $frameskip" }
+  if { ! $throttle} { set options "$options -nothrottle" }
+  if {$cheat} { set options "$options -cheat" }
+
+  eval exec $gamemame $game $options &
+
+  if {$autoexit} { exit }
+  
+}
+
+proc setScale value {
+  global scale
+
+  set scale [ .scalefactor get ]
+}
+
+proc setFrameskip value {
+  global frameskip 
+
+  set frameskip [ .frameskip get ]
+}
diff --git a/src/unix/contrib/frontends/mamex.new b/src/unix/contrib/frontends/mamex.new
new file mode 100755
index 0000000..93f7b80
--- /dev/null
+++ b/src/unix/contrib/frontends/mamex.new
@@ -0,0 +1,208 @@
+#!/usr/bin/wish
+#
+# MAMEX - MAME front End v.1.1
+# 
+# Chris Sharp <sharpc@hursley.ibm.com>
+# 
+# 5/9/97
+#
+# - Change Log -
+# Aug 4, 1998 v1.1
+#  enhanced by Takashi MATSUDA <matsu@arch.comp.kyutech.ac.jp>
+#
+# - Known Bug -
+#  zombie process remains when xmame finished.
+#
+
+set RCFILE "~/.mamex"
+set XMAME xmame
+
+wm title	. "M.A.M.E. selector"
+wm iconname	. "M.A.M.E. selector"
+
+
+# define procedures
+
+proc setListItems {type dummy opt} {
+  global allGames gamesAvailable
+  global GAMESLIST
+  upvar $type show_type
+
+  $GAMESLIST delete 0 end
+  foreach title [lsort [array names allGames]] {
+    if {[string compare $show_type "All Games"] == 0 ||
+    	[lsearch $gamesAvailable $allGames($title)] >= 0} {
+      $GAMESLIST insert end $title 
+    }
+  }
+}
+
+proc runMame {} {
+  global XMAME sound FM scale allGames TB JS
+  global BUTTONS OPTENTRY
+
+  set game "" 
+  if [catch {set game $allGames([selection get])}] {
+    bell
+  } else {
+    set options ""
+    if {$sound} { set options " -sound " }
+    if {$FM} { set options "$options -fm" }
+    if {$TB} { set options "$options -trak" }
+    if {$JS} { set options "$options -joy" }
+    if {$scale} { set options "$options -scale $scale" }
+
+    set options "$options [$OPTENTRY get]"
+
+    eval "catch { exec $XMAME $game $options & }"
+  }
+}
+
+proc setScale value {
+  global scale
+  global PANEL
+
+  set scale [ $PANEL.factor get ]
+}
+
+proc quitMamex {} {
+  global sound FM scale TB JS show_type RCFILE
+  global OPTENTRY
+
+  if { ! [ catch { set rcfile [ open $RCFILE w ] } ] } {
+    puts $rcfile "set sound $sound"
+    puts $rcfile "set FM $FM"
+    puts $rcfile "set scale $scale"
+    puts $rcfile "set TB $TB"
+    puts $rcfile "set JS $JS"
+    puts $rcfile "set show_type \"$show_type\""
+    regsub -all {"} [$OPTENTRY get] {} result
+    puts $rcfile "set more_options \"$result\""
+
+    close $rcfile
+  }
+  exit 0
+}
+
+
+# setup configuration.
+
+set sound 0
+set FM 0
+set scale 1
+set TB 0
+set JS 0
+set show_type "Available Games"
+set more_options ""
+
+catch { source $RCFILE }
+
+# find supported games.
+
+catch { [exec $XMAME -listfull 2>/dev/null] } gamelist
+set mamelist [lsort [lrange [split $gamelist "\n"] 1 end]]
+
+foreach i $mamelist {
+  if {$i != "" } {
+    set titlelist [split $i { \"} ]
+    set index [string trim [lindex $titlelist 0]]
+    if {$index != "NAMES:"} {
+      set title [string trim [join [lrange $titlelist 1 end]]]
+      set allGames($title) $index
+    }
+  }
+}
+
+# find available game roms.
+
+catch { exec $XMAME -showconfig } config
+set mamedirs {}
+foreach line [split $config "\n"] {
+  set dir ""
+  regexp -- {mamedir[ \t]*([^ \t\n].*)} $line dummy dir
+  if [string length "$dir"] {
+    lappend mamedirs $dir
+  }
+}
+set gamesAvailable {}
+foreach dir $mamedirs {
+  foreach f [ glob -nocomplain $dir/* ] {
+    if [ file isdirectory $f ] {
+      lappend gamesAvailable [file tail $f]
+    }
+  }
+}
+
+# create widgets
+
+set PANEL	.main.right.top
+set BUTTONS	.main.right.bottom
+
+set GAMESLIST	.main.left.gameslist
+set OPTENTRY	.bottom.option
+
+
+frame 		.main -border 2
+
+frame 		.main.left
+tk_optionMenu 	.main.left.menu show_type "Available Games" "All Games"
+listbox 	$GAMESLIST -relief raised -borderwidth 2 \
+			-yscrollcommand ".main.scroll set" -relief sunken
+scrollbar 	.main.scroll -command ".main.left.gameslist yview"
+
+bind $GAMESLIST <Double-1> "runMame" 
+trace variable show_type w setListItems
+setListItems show_type "" w
+
+frame 		.main.right
+
+frame 		$PANEL
+label 		$PANEL.title -text MAMEX \
+			-font "-*-helvetica-bold-r-*--14-*" -foreground red
+label 		$PANEL.title2 -text "MAME front end v1.1" \
+			-font "-*-helvetica-normal-r-*--10-*"
+checkbutton 	$PANEL.sound -text Sound -variable sound -anchor w 
+checkbutton 	$PANEL.fm -text FM -variable FM -anchor w 
+checkbutton 	$PANEL.trakball -text TrakBall -variable TB -anchor w 
+checkbutton 	$PANEL.joystick -text Joystick -variable JS -anchor w 
+
+scale 		$PANEL.factor -label scale -from 1 -to 3 -length 2c \
+			-orient horizontal -command "setScale"
+
+frame		$BUTTONS -border 2
+button		$BUTTONS.play -text "Play!!" -command "runMame"
+button		$BUTTONS.exit -text "Quit" -command quitMamex
+
+frame		.bottom
+label		.bottom.label -text "More options:"
+entry		$OPTENTRY
+
+$OPTENTRY insert 0 $more_options
+bind $OPTENTRY <Return> "$BUTTONS.play invoke"
+
+# packing widgets
+
+pack .main -fill both -expand 1
+
+pack .main.right -side right -fill y
+pack $PANEL -side top -fill both -expand 1
+pack $PANEL.title -side top
+pack $PANEL.title2 -side top
+pack $PANEL.sound -side top -anchor w
+pack $PANEL.fm -side top -anchor w
+pack $PANEL.trakball -side top -anchor w
+pack $PANEL.joystick -side top -anchor w
+pack $PANEL.factor -side top -anchor nw -fill x -ipady 5
+
+pack $BUTTONS -side bottom -fill x
+pack $BUTTONS.play -side left -fill x -expand 1
+pack $BUTTONS.exit -side right -fill x -expand 1
+
+pack .main.left -side left -fill both -expand 1
+pack .main.left.menu -side top -fill x
+pack $GAMESLIST -side bottom -fill both -expand 1
+pack .main.scroll -side left -fill y
+
+pack .bottom -side bottom -fill x -pady 3 -anchor n
+pack .bottom.label -side left -padx 2 -anchor e
+pack $OPTENTRY -side right -fill x -expand 1 -padx 3 -anchor w
diff --git a/src/unix/contrib/frontends/readme b/src/unix/contrib/frontends/readme
new file mode 100644
index 0000000..002f62c
--- /dev/null
+++ b/src/unix/contrib/frontends/readme
@@ -0,0 +1,26 @@
+The frontends in here are provided as is, no guarentees made.
+
+For a list of more activly maintained frontends with there own webpages see:
+http://x.mame.net
+
+Contents of directory contrib/frontends
+==========================================
+
+1)	Name:		Mameload-Fvwm95 
+	Author:		Tom Hansen <tom@toetag.com>
+	Description:	Script to add a X-Mame Popup menu to .fvwm2rc95 file
+	Notes:		See script instalation notes
+
+2)      Name:		Mamex
+	Author:		Chris Sharp <sharp@hursley.ibm.com>
+	Description:    TcL/Wish frontend for X-Mame
+	Notes:		See readme.mamex file
+
+3)	Name:		readme
+	Author:		Hans de Goede <hans@highrise.nl>
+	Description:	This file
+
+4)      Name:           tkmame.pl
+	Author:         genkai wa doko da <gauze@loa.com>
+	Description:    a TkPerl X-Mame launcher
+	Notes:          See readme.tkmame file
diff --git a/src/unix/contrib/frontends/readme.tkmame b/src/unix/contrib/frontends/readme.tkmame
new file mode 100644
index 0000000..4eec9cb
--- /dev/null
+++ b/src/unix/contrib/frontends/readme.tkmame
@@ -0,0 +1,47 @@
+OK, this is a front end for XWindows for launching XMAME ROMS written in 
+Tkperl...you need to have the Tkperl package compiled for this to work.
+(Check at http://www.perl.org/CPAN/ to get Tkperl source)
+
+1) move tkmame.pl to a directory in your $PATH(or you'll have to run it with full pathname)
+
+2) chmod 755 tkmame.pl
+
+3) open up tkmame.pl in a text editor and change: 
+$MAMEDIR='$PATH to your ROMS'
+$XMAMERC_LOC='$PATH/FILENAME of your configuration file'
+$MAMEBIN='$PATH/FILENAME of your xmame executable'
+
+Default:
+$MAMEDIR = "/usr/local/share/xmame/roms";
+$XMAMERC_LOC = "/usr/local/share/xmame/xmamerc";
+$MAMEBIN = "/usr/local/bin/xmame.linux";
+
+4) play games :-)
+
+you can add a command line switch (rather than changing the *rc file) in the box right above the 'Quit' bar.... you can edit the xmamerc file with the button
+marked as such...(i'd make a back up of your xmamerc just in case, always a good idea with configuration files anyway)
+
+you can run it from command line from an xterm/rxvt/etc or make a menu item
+for it in your window manager of choice...
+
+my line from .fvwmrc:
+
+	Exec	"MAME"		exec /mame/tkmame.pl &
+
+you can change tkmame.pl to another name if you so wish...
+
+BUGS
+----
+I had to use the Tk::BrowseEntry widget instead of the Entry Widget 
+because for some reason I couldn't get Entry to work :-( , maybe a bug in
+Tkperl,Ignore the "Arrow" buttons they do nothing!
+
+TO DO
+-----
+have a "remote control" box to Pause or kill games (kill is easy the pause 
+I am not sure of how to do!)
+email me with suggestions!
+
+-@@@-
+gauze 12/2/97    email:gauze@loa.com
+
diff --git a/src/unix/contrib/frontends/tkmame.pl b/src/unix/contrib/frontends/tkmame.pl
new file mode 100644
index 0000000..aac39cd
--- /dev/null
+++ b/src/unix/contrib/frontends/tkmame.pl
@@ -0,0 +1,140 @@
+#!/usr/bin/perl -w 
+
+# set the path to your ROMS below
+my ($MAMEDIR) = "/usr/local/share/xmame/roms";
+
+# set location/name of xmamerc here (typically ~/xmame/) or (/usr/local/share/xmame/)
+my ($XMAMERC_LOC) = "/usr/local/share/xmame/xmamerc";
+
+# set name of MAME executable/bin
+my ($MAMEBIN) = "/usr/local/bin/xmame";
+
+
+my ($ROM,$ROMLIST,$col,$row,$num,$widget,$mw,$table,@ROMLIST,$SWITCH);
+my ($conf,@mameconf,@mame_settings,$name,$line,$change,$newline,@mamechange,%settings,$setting);
+
+use Tk;
+use English;
+use Tk::Table;
+use strict;
+use Tk::BrowseEntry;
+
+$mw = new MainWindow;
+$mw->Label(-text=>'MAME GAMES')->pack;
+
+
+# set default game options
+$SWITCH = "-cheat";
+
+
+#Note: if you have directories in your $MAMEDIR dir they will be on your menu. 
+#you might want to add more greps if you have other non-ROM stuff in there
+chdir($MAMEDIR);
+opendir(MAME,$MAMEDIR);
+@ROMLIST = sort(grep( /.zip$/ , (grep(-f,readdir(MAME)))));
+closedir(MAME);
+
+chomp (@ROMLIST);
+my ($mycol) = $#ROMLIST/7;
+$mycol =  13 unless ($mycol < 13);
+$table =$mw->Table(-rows=>$mycol,-columns=>7,-scrollbars=>'e',)->pack(-expand=>1,-fill=>'x');
+# the main loop
+$col=0;
+$row=0;
+$num=0;
+foreach $ROM (@ROMLIST) {
+my ($ROM) = $ROM;
+$ROM =~ s/\.zip//ig;
+if ($col > 6) {
+$col=0;
+$row++;
+}
+$widget = $table->Button(-text=>$ROM,-command=>sub{play($ROM)});
+$num++;
+
+$table->put($row,$col,$widget);
+$col++;
+}
+
+$mw->Button(-text=>'Quit',-command=>['destroy',$mw])->pack(-side=>'bottom',-expand=>1,-fill=>'x');
+$mw->Button(-text=>'Configure xmamerc',-command=>sub{&config_mame})->pack(-side=>'bottom',-side=>'right');
+  my  $switch = $mw->BrowseEntry(-label=>"Command line options:",-variable=>\$SWITCH);
+    $switch->pack;
+
+MainLoop;
+
+sub play {
+my ($GAME) = @_;
+system("$MAMEBIN $GAME $SWITCH");
+}
+sub set_switch {
+    ($SWITCH) = @_;
+}
+
+
+
+
+sub config_mame {
+undef(@mameconf);
+undef(@mame_settings);
+%settings = ();
+open(MAMECONF,"+<".$XMAMERC_LOC) || die $!;
+@mameconf= <MAMECONF>;
+close(MAMECONF);
+foreach $name (@mameconf) {
+if ($name !~ /^#/ && $name =~ /\S+/) {
+chomp $name;
+    push(@mame_settings,$name);
+}}
+
+$conf = $mw->Toplevel();
+foreach $setting (@mame_settings) {
+$setting =~ s/\s+/ /g;
+my ($name,$value) = split(/ /,$setting);
+$settings{"$name"} = $value;
+
+$conf->BrowseEntry(-label=>$name,-variable=>\$settings{"$name"})->pack(-side=>'top');
+}
+
+$conf->Button(-text=>"Save Settings to xmamerc",-command=>sub{&write_rc})->pack(-side=>"bottom",-side=>'left',-expand=>1,-fill=>'x');
+$conf->Button(-text=>"Cancel",-command=>['destroy',$conf])->pack(-side=>'bottom',-side=>'right',-expand=>1,-fill=>'x');
+}
+
+sub write_rc {
+undef(@mameconf);
+open(MAMECONF,"+<".$XMAMERC_LOC) || die $!;
+@mameconf = <MAMECONF>;
+close(MAMECONF);
+
+foreach $line (@mameconf) {
+          if ($line !~ /^#/) {
+	       foreach $change (keys %settings) {
+		   if ($line =~ /$change/g) {
+			   $line = "$change"."     "."$settings{($change)}"."\n";
+			   push(@mamechange,$line);
+		       } 
+	       }
+	  } else {     
+	      $line = $line . "\n" unless ($line =~ /\n$/);
+			    push(@mamechange,$line); 
+			}
+
+	}       
+		open(MAMEWRITE,"+<".$XMAMERC_LOC) || die $!;
+		foreach $newline (@mamechange) {
+						print MAMEWRITE $newline;
+						}
+		close(MAMEWRITE);
+		print "Changes saved to ".$XMAMERC_LOC;
+my $msg = $conf->Toplevel;
+	 
+$msg->Label(-text=>"Changes saved to $XMAMERC_LOC")->pack(-side=>'top');
+$msg->Button(-text=>"Dismiss",-command=>['destroy',$conf])->pack(-side=>'bottom');
+}
+
+
+
+
+
+
+
diff --git a/src/unix/contrib/frontends/xmameload/xmameload.c b/src/unix/contrib/frontends/xmameload/xmameload.c
new file mode 100644
index 0000000..2517cde
--- /dev/null
+++ b/src/unix/contrib/frontends/xmameload/xmameload.c
@@ -0,0 +1,68 @@
+/* Form definition file generated with fdesign. */
+
+#include "forms.h"
+#include <stdlib.h>
+#include "xmameload.h"
+
+FD_xmame_main_form *create_form_xmame_main_form(void)
+{
+  FL_OBJECT *obj;
+  FD_xmame_main_form *fdui = (FD_xmame_main_form *) fl_calloc(1, sizeof(*fdui));
+
+  fdui->xmame_main_form = fl_bgn_form(FL_NO_BOX, 670, 300);
+  obj = fl_add_box(FL_UP_BOX,0,0,670,300,"");
+  fdui->file_menu = obj = fl_add_menu(FL_PULLDOWN_MENU,20,10,70,20,"File");
+    fl_set_object_boxtype(obj,FL_FRAME_BOX);
+  fdui->gamlist_browser = obj = fl_add_browser(FL_SELECT_BROWSER,20,60,160,220,"GameList");
+    fl_set_object_lalign(obj,FL_ALIGN_TOP_LEFT);
+  fdui->video_atributes = obj = fl_add_labelframe(FL_ENGRAVED_FRAME,190,110,160,170,"Video Options");
+  fdui->audio_options = obj = fl_add_labelframe(FL_ENGRAVED_FRAME,360,130,130,150,"Audio Options");
+  fdui->io_options = obj = fl_add_labelframe(FL_ENGRAVED_FRAME,500,130,150,150,"Input/Output");
+  fdui->mamedir_input = obj = fl_add_input(FL_NORMAL_INPUT,250,40,240,20,"ROMs Dir");
+  fdui->spooldir_input = obj = fl_add_input(FL_NORMAL_INPUT,250,70,240,20,"HIScores Dir");
+  fdui->dsiplayname_input = obj = fl_add_input(FL_NORMAL_INPUT,240,120,90,20,"Display");
+  fdui->xscale_input = obj = fl_add_counter(FL_SIMPLE_COUNTER,200,160,60,20,"X-Scale");
+  fdui->yscale_input = obj = fl_add_counter(FL_SIMPLE_COUNTER,200,200,60,20,"Y-Scale");
+  fdui->frameskip_input = obj = fl_add_counter(FL_SIMPLE_COUNTER,200,240,60,20,"Skip Frames");
+  fdui->use_xsync_input = obj = fl_add_round3dbutton(FL_PUSH_BUTTON,320,150,30,30,"DoXSync");
+    fl_set_object_lalign(obj,FL_ALIGN_LEFT);
+  fdui->use_mitshm_input = obj = fl_add_round3dbutton(FL_PUSH_BUTTON,320,180,30,30,"MitShmem");
+    fl_set_object_lalign(obj,FL_ALIGN_LEFT);
+  fdui->use_private_cmap_input = obj = fl_add_round3dbutton(FL_PUSH_BUTTON,320,210,30,30,"PrivCmap");
+    fl_set_object_lalign(obj,FL_ALIGN_LEFT);
+  fdui->use_truecolor_input = obj = fl_add_round3dbutton(FL_PUSH_BUTTON,320,240,30,30,"TrueColor");
+    fl_set_object_lalign(obj,FL_ALIGN_LEFT);
+  fdui->use_mouse_input = obj = fl_add_round3dbutton(FL_PUSH_BUTTON,510,140,30,30,"Mouse");
+    fl_set_object_lalign(obj,FL_ALIGN_BOTTOM);
+  fdui->use_joystick_input = obj = fl_add_round3dbutton(FL_PUSH_BUTTON,560,140,30,30,"JoyStick");
+    fl_set_object_lalign(obj,FL_ALIGN_BOTTOM);
+  fdui->use_trakball_input = obj = fl_add_round3dbutton(FL_PUSH_BUTTON,610,140,30,30,"TrakBall");
+    fl_set_object_lalign(obj,FL_ALIGN_BOTTOM);
+  fdui->joyfilter_input = obj = fl_add_counter(FL_SIMPLE_COUNTER,590,220,50,20,"Joy Filter");
+    fl_set_object_lalign(obj,FL_ALIGN_LEFT);
+  fdui->x11_joyname_input = obj = fl_add_input(FL_NORMAL_INPUT,570,250,70,20,"X11 JoyName");
+  fdui->use_audio_input = obj = fl_add_round3dbutton(FL_PUSH_BUTTON,460,130,30,30,"Use Audio");
+    fl_set_object_lalign(obj,FL_ALIGN_LEFT);
+  fdui->use_fm_input = obj = fl_add_round3dbutton(FL_PUSH_BUTTON,460,160,30,30,"Use FM");
+    fl_set_object_lalign(obj,FL_ALIGN_LEFT);
+  fdui->video_menu = obj = fl_add_menu(FL_PULLDOWN_MENU,120,10,70,20,"Video");
+    fl_set_object_boxtype(obj,FL_FRAME_BOX);
+  fdui->audio_menu = obj = fl_add_menu(FL_PULLDOWN_MENU,220,10,70,20,"Audio");
+    fl_set_object_boxtype(obj,FL_FRAME_BOX);
+  fdui->io_menu = obj = fl_add_menu(FL_PULLDOWN_MENU,320,10,70,20,"Devices");
+    fl_set_object_boxtype(obj,FL_FRAME_BOX);
+  fdui->audio_device_input = obj = fl_add_input(FL_NORMAL_INPUT,410,250,70,20,"AudioDev");
+  fdui->sample_freq_input = obj = fl_add_counter(FL_SIMPLE_COUNTER,420,190,60,20,"SampleFreq");
+    fl_set_object_lalign(obj,FL_ALIGN_LEFT);
+  fdui->timer_freq_input = obj = fl_add_counter(FL_SIMPLE_COUNTER,420,220,60,20,"TimerFreq");
+    fl_set_object_lalign(obj,FL_ALIGN_LEFT);
+  fdui->exe_menu = obj = fl_add_menu(FL_PULLDOWN_MENU,420,10,70,20,"Execute");
+    fl_set_object_boxtype(obj,FL_FRAME_BOX);
+  fl_end_form();
+
+  fdui->xmame_main_form->fdui = fdui;
+
+  return fdui;
+}
+/*---------------------------------------*/
+
diff --git a/src/unix/contrib/frontends/xmameload/xmameload.fd b/src/unix/contrib/frontends/xmameload/xmameload.fd
new file mode 100644
index 0000000..3dec0f9
--- /dev/null
+++ b/src/unix/contrib/frontends/xmameload/xmameload.fd
@@ -0,0 +1,556 @@
+Magic: 13000
+
+Internal Form Definition File
+    (do not change)
+
+Number of forms: 1
+Unit of measure: FL_COORD_PIXEL
+
+=============== FORM ===============
+Name: xmame_main_form
+Width: 670
+Height: 300
+Number of Objects: 30
+
+--------------------
+class: FL_BOX
+type: UP_BOX
+box: 0 0 670 300
+boxtype: FL_UP_BOX
+colors: FL_COL1 FL_COL1
+alignment: FL_ALIGN_CENTER
+style: FL_NORMAL_STYLE
+size: FL_DEFAULT_SIZE
+lcol: FL_BLACK
+label: 
+shortcut: 
+resize: FL_RESIZE_ALL
+gravity: FL_NoGravity FL_NoGravity
+name: 
+callback: 
+argument: 
+
+--------------------
+class: FL_MENU
+type: PULLDOWN_MENU
+box: 20 10 70 20
+boxtype: FL_FRAME_BOX
+colors: FL_COL1 FL_MCOL
+alignment: FL_ALIGN_CENTER
+style: FL_BOLD_STYLE
+size: FL_DEFAULT_SIZE
+lcol: FL_BLACK
+label: File
+shortcut: 
+resize: FL_RESIZE_ALL
+gravity: FL_NoGravity FL_NoGravity
+name: file_menu
+callback: 
+argument: 
+
+--------------------
+class: FL_BROWSER
+type: SELECT_BROWSER
+box: 20 60 160 220
+boxtype: FL_DOWN_BOX
+colors: FL_COL1 FL_YELLOW
+alignment: FL_ALIGN_TOP_LEFT
+style: FL_NORMAL_STYLE
+size: FL_DEFAULT_SIZE
+lcol: FL_BLACK
+label: GameList
+shortcut: 
+resize: FL_RESIZE_ALL
+gravity: FL_NoGravity FL_NoGravity
+name: gamlist_browser
+callback: 
+argument: 
+
+--------------------
+class: FL_LABELFRAME
+type: ENGRAVED_FRAME
+box: 190 110 160 170
+boxtype: FL_NO_BOX
+colors: FL_BLACK FL_COL1
+alignment: FL_ALIGN_TOP_LEFT
+style: FL_NORMAL_STYLE
+size: FL_DEFAULT_SIZE
+lcol: FL_BLACK
+label: Video Options
+shortcut: 
+resize: FL_RESIZE_ALL
+gravity: FL_NoGravity FL_NoGravity
+name: video_atributes
+callback: 
+argument: 
+
+--------------------
+class: FL_LABELFRAME
+type: ENGRAVED_FRAME
+box: 360 130 130 150
+boxtype: FL_NO_BOX
+colors: FL_BLACK FL_COL1
+alignment: FL_ALIGN_TOP_LEFT
+style: FL_NORMAL_STYLE
+size: FL_DEFAULT_SIZE
+lcol: FL_BLACK
+label: Audio Options
+shortcut: 
+resize: FL_RESIZE_ALL
+gravity: FL_NoGravity FL_NoGravity
+name: audio_options
+callback: 
+argument: 
+
+--------------------
+class: FL_LABELFRAME
+type: ENGRAVED_FRAME
+box: 500 130 150 150
+boxtype: FL_NO_BOX
+colors: FL_BLACK FL_COL1
+alignment: FL_ALIGN_TOP_LEFT
+style: FL_NORMAL_STYLE
+size: FL_DEFAULT_SIZE
+lcol: FL_BLACK
+label: Input/Output
+shortcut: 
+resize: FL_RESIZE_ALL
+gravity: FL_NoGravity FL_NoGravity
+name: io_options
+callback: 
+argument: 
+
+--------------------
+class: FL_INPUT
+type: NORMAL_INPUT
+box: 250 40 240 20
+boxtype: FL_DOWN_BOX
+colors: FL_COL1 FL_MCOL
+alignment: FL_ALIGN_LEFT
+style: FL_NORMAL_STYLE
+size: FL_DEFAULT_SIZE
+lcol: FL_BLACK
+label: ROMs Dir
+shortcut: 
+resize: FL_RESIZE_ALL
+gravity: FL_NoGravity FL_NoGravity
+name: mamedir_input
+callback: 
+argument: 
+
+--------------------
+class: FL_INPUT
+type: NORMAL_INPUT
+box: 250 70 240 20
+boxtype: FL_DOWN_BOX
+colors: FL_COL1 FL_MCOL
+alignment: FL_ALIGN_LEFT
+style: FL_NORMAL_STYLE
+size: FL_DEFAULT_SIZE
+lcol: FL_BLACK
+label: HIScores Dir
+shortcut: 
+resize: FL_RESIZE_ALL
+gravity: FL_NoGravity FL_NoGravity
+name: spooldir_input
+callback: 
+argument: 
+
+--------------------
+class: FL_INPUT
+type: NORMAL_INPUT
+box: 240 120 90 20
+boxtype: FL_DOWN_BOX
+colors: FL_COL1 FL_MCOL
+alignment: FL_ALIGN_LEFT
+style: FL_NORMAL_STYLE
+size: FL_DEFAULT_SIZE
+lcol: FL_BLACK
+label: Display
+shortcut: 
+resize: FL_RESIZE_ALL
+gravity: FL_NoGravity FL_NoGravity
+name: dsiplayname_input
+callback: 
+argument: 
+
+--------------------
+class: FL_COUNTER
+type: SIMPLE_COUNTER
+box: 200 160 60 20
+boxtype: FL_UP_BOX
+colors: FL_COL1 FL_BLUE
+alignment: FL_ALIGN_BOTTOM
+style: FL_NORMAL_STYLE
+size: FL_DEFAULT_SIZE
+lcol: FL_BLACK
+label: X-Scale
+shortcut: 
+resize: FL_RESIZE_ALL
+gravity: FL_NoGravity FL_NoGravity
+name: xscale_input
+callback: 
+argument: 
+
+--------------------
+class: FL_COUNTER
+type: SIMPLE_COUNTER
+box: 200 200 60 20
+boxtype: FL_UP_BOX
+colors: FL_COL1 FL_BLUE
+alignment: FL_ALIGN_BOTTOM
+style: FL_NORMAL_STYLE
+size: FL_DEFAULT_SIZE
+lcol: FL_BLACK
+label: Y-Scale
+shortcut: 
+resize: FL_RESIZE_ALL
+gravity: FL_NoGravity FL_NoGravity
+name: yscale_input
+callback: 
+argument: 
+
+--------------------
+class: FL_COUNTER
+type: SIMPLE_COUNTER
+box: 200 240 60 20
+boxtype: FL_UP_BOX
+colors: FL_COL1 FL_BLUE
+alignment: FL_ALIGN_BOTTOM
+style: FL_NORMAL_STYLE
+size: FL_DEFAULT_SIZE
+lcol: FL_BLACK
+label: Skip Frames
+shortcut: 
+resize: FL_RESIZE_ALL
+gravity: FL_NoGravity FL_NoGravity
+name: frameskip_input
+callback: 
+argument: 
+
+--------------------
+class: FL_ROUND3DBUTTON
+type: PUSH_BUTTON
+box: 320 150 30 30
+boxtype: FL_NO_BOX
+colors: FL_COL1 FL_BLACK
+alignment: FL_ALIGN_LEFT
+style: FL_NORMAL_STYLE
+size: FL_DEFAULT_SIZE
+lcol: FL_BLACK
+label: DoXSync
+shortcut: 
+resize: FL_RESIZE_ALL
+gravity: FL_NoGravity FL_NoGravity
+name: use_xsync_input
+callback: 
+argument: 
+
+--------------------
+class: FL_ROUND3DBUTTON
+type: PUSH_BUTTON
+box: 320 180 30 30
+boxtype: FL_NO_BOX
+colors: FL_COL1 FL_BLACK
+alignment: FL_ALIGN_LEFT
+style: FL_NORMAL_STYLE
+size: FL_DEFAULT_SIZE
+lcol: FL_BLACK
+label: MitShmem
+shortcut: 
+resize: FL_RESIZE_ALL
+gravity: FL_NoGravity FL_NoGravity
+name: use_mitshm_input
+callback: 
+argument: 
+
+--------------------
+class: FL_ROUND3DBUTTON
+type: PUSH_BUTTON
+box: 320 210 30 30
+boxtype: FL_NO_BOX
+colors: FL_COL1 FL_BLACK
+alignment: FL_ALIGN_LEFT
+style: FL_NORMAL_STYLE
+size: FL_DEFAULT_SIZE
+lcol: FL_BLACK
+label: PrivCmap
+shortcut: 
+resize: FL_RESIZE_ALL
+gravity: FL_NoGravity FL_NoGravity
+name: use_private_cmap_input
+callback: 
+argument: 
+
+--------------------
+class: FL_ROUND3DBUTTON
+type: PUSH_BUTTON
+box: 320 240 30 30
+boxtype: FL_NO_BOX
+colors: FL_COL1 FL_BLACK
+alignment: FL_ALIGN_LEFT
+style: FL_NORMAL_STYLE
+size: FL_DEFAULT_SIZE
+lcol: FL_BLACK
+label: TrueColor
+shortcut: 
+resize: FL_RESIZE_ALL
+gravity: FL_NoGravity FL_NoGravity
+name: use_truecolor_input
+callback: 
+argument: 
+
+--------------------
+class: FL_ROUND3DBUTTON
+type: PUSH_BUTTON
+box: 510 140 30 30
+boxtype: FL_NO_BOX
+colors: FL_COL1 FL_BLACK
+alignment: FL_ALIGN_BOTTOM
+style: FL_NORMAL_STYLE
+size: FL_DEFAULT_SIZE
+lcol: FL_BLACK
+label: Mouse
+shortcut: 
+resize: FL_RESIZE_ALL
+gravity: FL_NoGravity FL_NoGravity
+name: use_mouse_input
+callback: 
+argument: 
+
+--------------------
+class: FL_ROUND3DBUTTON
+type: PUSH_BUTTON
+box: 560 140 30 30
+boxtype: FL_NO_BOX
+colors: FL_COL1 FL_BLACK
+alignment: FL_ALIGN_BOTTOM
+style: FL_NORMAL_STYLE
+size: FL_DEFAULT_SIZE
+lcol: FL_BLACK
+label: JoyStick
+shortcut: 
+resize: FL_RESIZE_ALL
+gravity: FL_NoGravity FL_NoGravity
+name: use_joystick_input
+callback: 
+argument: 
+
+--------------------
+class: FL_ROUND3DBUTTON
+type: PUSH_BUTTON
+box: 610 140 30 30
+boxtype: FL_NO_BOX
+colors: FL_COL1 FL_BLACK
+alignment: FL_ALIGN_BOTTOM
+style: FL_NORMAL_STYLE
+size: FL_DEFAULT_SIZE
+lcol: FL_BLACK
+label: TrakBall
+shortcut: 
+resize: FL_RESIZE_ALL
+gravity: FL_NoGravity FL_NoGravity
+name: use_trakball_input
+callback: 
+argument: 
+
+--------------------
+class: FL_COUNTER
+type: SIMPLE_COUNTER
+box: 590 220 50 20
+boxtype: FL_UP_BOX
+colors: FL_COL1 FL_BLUE
+alignment: FL_ALIGN_LEFT
+style: FL_NORMAL_STYLE
+size: FL_DEFAULT_SIZE
+lcol: FL_BLACK
+label: Joy Filter
+shortcut: 
+resize: FL_RESIZE_ALL
+gravity: FL_NoGravity FL_NoGravity
+name: joyfilter_input
+callback: 
+argument: 
+
+--------------------
+class: FL_INPUT
+type: NORMAL_INPUT
+box: 570 250 70 20
+boxtype: FL_DOWN_BOX
+colors: FL_COL1 FL_MCOL
+alignment: FL_ALIGN_LEFT
+style: FL_NORMAL_STYLE
+size: FL_DEFAULT_SIZE
+lcol: FL_BLACK
+label: X11 JoyName
+shortcut: 
+resize: FL_RESIZE_ALL
+gravity: FL_NoGravity FL_NoGravity
+name: x11_joyname_input
+callback: 
+argument: 
+
+--------------------
+class: FL_ROUND3DBUTTON
+type: PUSH_BUTTON
+box: 460 130 30 30
+boxtype: FL_NO_BOX
+colors: FL_COL1 FL_BLACK
+alignment: FL_ALIGN_LEFT
+style: FL_NORMAL_STYLE
+size: FL_DEFAULT_SIZE
+lcol: FL_BLACK
+label: Use Audio
+shortcut: 
+resize: FL_RESIZE_ALL
+gravity: FL_NoGravity FL_NoGravity
+name: use_audio_input
+callback: 
+argument: 
+
+--------------------
+class: FL_ROUND3DBUTTON
+type: PUSH_BUTTON
+box: 460 160 30 30
+boxtype: FL_NO_BOX
+colors: FL_COL1 FL_BLACK
+alignment: FL_ALIGN_LEFT
+style: FL_NORMAL_STYLE
+size: FL_DEFAULT_SIZE
+lcol: FL_BLACK
+label: Use FM
+shortcut: 
+resize: FL_RESIZE_ALL
+gravity: FL_NoGravity FL_NoGravity
+name: use_fm_input
+callback: 
+argument: 
+
+--------------------
+class: FL_MENU
+type: PULLDOWN_MENU
+box: 120 10 70 20
+boxtype: FL_FRAME_BOX
+colors: FL_COL1 FL_MCOL
+alignment: FL_ALIGN_CENTER
+style: FL_BOLD_STYLE
+size: FL_DEFAULT_SIZE
+lcol: FL_BLACK
+label: Video
+shortcut: 
+resize: FL_RESIZE_ALL
+gravity: FL_NoGravity FL_NoGravity
+name: video_menu
+callback: 
+argument: 
+
+--------------------
+class: FL_MENU
+type: PULLDOWN_MENU
+box: 220 10 70 20
+boxtype: FL_FRAME_BOX
+colors: FL_COL1 FL_MCOL
+alignment: FL_ALIGN_CENTER
+style: FL_BOLD_STYLE
+size: FL_DEFAULT_SIZE
+lcol: FL_BLACK
+label: Audio
+shortcut: 
+resize: FL_RESIZE_ALL
+gravity: FL_NoGravity FL_NoGravity
+name: audio_menu
+callback: 
+argument: 
+
+--------------------
+class: FL_MENU
+type: PULLDOWN_MENU
+box: 320 10 70 20
+boxtype: FL_FRAME_BOX
+colors: FL_COL1 FL_MCOL
+alignment: FL_ALIGN_CENTER
+style: FL_BOLD_STYLE
+size: FL_DEFAULT_SIZE
+lcol: FL_BLACK
+label: Devices
+shortcut: 
+resize: FL_RESIZE_ALL
+gravity: FL_NoGravity FL_NoGravity
+name: io_menu
+callback: 
+argument: 
+
+--------------------
+class: FL_INPUT
+type: NORMAL_INPUT
+box: 410 250 70 20
+boxtype: FL_DOWN_BOX
+colors: FL_COL1 FL_MCOL
+alignment: FL_ALIGN_LEFT
+style: FL_NORMAL_STYLE
+size: FL_DEFAULT_SIZE
+lcol: FL_BLACK
+label: AudioDev
+shortcut: 
+resize: FL_RESIZE_ALL
+gravity: FL_NoGravity FL_NoGravity
+name: audio_device_input
+callback: 
+argument: 
+
+--------------------
+class: FL_COUNTER
+type: SIMPLE_COUNTER
+box: 420 190 60 20
+boxtype: FL_UP_BOX
+colors: FL_COL1 FL_BLUE
+alignment: FL_ALIGN_LEFT
+style: FL_NORMAL_STYLE
+size: FL_DEFAULT_SIZE
+lcol: FL_BLACK
+label: SampleFreq
+shortcut: 
+resize: FL_RESIZE_ALL
+gravity: FL_NoGravity FL_NoGravity
+name: sample_freq_input
+callback: 
+argument: 
+
+--------------------
+class: FL_COUNTER
+type: SIMPLE_COUNTER
+box: 420 220 60 20
+boxtype: FL_UP_BOX
+colors: FL_COL1 FL_BLUE
+alignment: FL_ALIGN_LEFT
+style: FL_NORMAL_STYLE
+size: FL_DEFAULT_SIZE
+lcol: FL_BLACK
+label: TimerFreq
+shortcut: 
+resize: FL_RESIZE_ALL
+gravity: FL_NoGravity FL_NoGravity
+name: timer_freq_input
+callback: 
+argument: 
+
+--------------------
+class: FL_MENU
+type: PULLDOWN_MENU
+box: 420 10 70 20
+boxtype: FL_FRAME_BOX
+colors: FL_COL1 FL_MCOL
+alignment: FL_ALIGN_CENTER
+style: FL_BOLD_STYLE
+size: FL_DEFAULT_SIZE
+lcol: FL_BLACK
+label: Execute
+shortcut: 
+resize: FL_RESIZE_ALL
+gravity: FL_NoGravity FL_NoGravity
+name: exe_menu
+callback: 
+argument: 
+
+==============================
+create_the_forms
diff --git a/src/unix/contrib/frontends/xmameload/xmameload.h b/src/unix/contrib/frontends/xmameload/xmameload.h
new file mode 100644
index 0000000..d8b8c8d
--- /dev/null
+++ b/src/unix/contrib/frontends/xmameload/xmameload.h
@@ -0,0 +1,48 @@
+#ifndef FD_xmame_main_form_h_
+#define FD_xmame_main_form_h_
+/* Header file generated with fdesign. */
+
+/**** Callback routines ****/
+
+
+
+/**** Forms and Objects ****/
+
+typedef struct {
+	FL_FORM *xmame_main_form;
+	void *vdata;
+	long ldata;
+	FL_OBJECT *file_menu;
+	FL_OBJECT *gamlist_browser;
+	FL_OBJECT *video_atributes;
+	FL_OBJECT *audio_options;
+	FL_OBJECT *io_options;
+	FL_OBJECT *mamedir_input;
+	FL_OBJECT *spooldir_input;
+	FL_OBJECT *dsiplayname_input;
+	FL_OBJECT *xscale_input;
+	FL_OBJECT *yscale_input;
+	FL_OBJECT *frameskip_input;
+	FL_OBJECT *use_xsync_input;
+	FL_OBJECT *use_mitshm_input;
+	FL_OBJECT *use_private_cmap_input;
+	FL_OBJECT *use_truecolor_input;
+	FL_OBJECT *use_mouse_input;
+	FL_OBJECT *use_joystick_input;
+	FL_OBJECT *use_trakball_input;
+	FL_OBJECT *joyfilter_input;
+	FL_OBJECT *x11_joyname_input;
+	FL_OBJECT *use_audio_input;
+	FL_OBJECT *use_fm_input;
+	FL_OBJECT *video_menu;
+	FL_OBJECT *audio_menu;
+	FL_OBJECT *io_menu;
+	FL_OBJECT *audio_device_input;
+	FL_OBJECT *sample_freq_input;
+	FL_OBJECT *timer_freq_input;
+	FL_OBJECT *exe_menu;
+} FD_xmame_main_form;
+
+extern FD_xmame_main_form * create_form_xmame_main_form(void);
+
+#endif /* FD_xmame_main_form_h_ */
diff --git a/src/unix/contrib/kxmame b/src/unix/contrib/kxmame
new file mode 100755
index 0000000..6d63cf1
--- /dev/null
+++ b/src/unix/contrib/kxmame
@@ -0,0 +1,2 @@
+#!/usr/bin/perl                                                                 #                                                                               # freeware!                                                                     #                                                                               use strict;                                                                     my $cmd= `which xmame.x11`;                                                     chop $cmd ? $cmd : $cmd='./xmame.x11';                                          unless (defined $ARGV[0]){                                                        print "                                                                         kxmame: xmame kicker for kde xmame usage                                      
+  ./kxmame GAMENAME OPTIONS                                                                                                                                       this script must be executable (chmod 755 kxmame)                               run xmame.x11 to see all possible xmame command line arguments                                                                                                  ";                                                                              exit;                                                                         }                                                                               $cmd="$cmd -rid `xwininfo -root | grep xwininfo: | awk '{print \$4}'`";         foreach (@ARGV){ $cmd .= " $_";}                                                print "Executing $cmd\n\n";                                                     system $cmd;                                                                    
diff --git a/src/unix/contrib/patches/alsa.c b/src/unix/contrib/patches/alsa.c
new file mode 100644
index 0000000..937d76d
--- /dev/null
+++ b/src/unix/contrib/patches/alsa.c
@@ -0,0 +1,413 @@
+/*
+ * ALSA Sound Driver for xMAME
+ */
+
+/* Written by an anonymous programmer at wwtk@mail.com
+   and based on the OSS sound driver for xMAME written
+   by Mike Oliphant (oliphant@ling.ed.ac.uk) */
+
+/* CURRENT PROGRESS
+
+   10/22/1999 - v.0.1.1 for xMAME released.
+                The soundcard scanner and initialization has been improved
+                considerably with the addition of soundcard prioritization
+                and automatic scaling.  It works like this.  When a PCM
+                channel is found, it compares its abilities with the ones you
+                want.  The lower the priority number, the closer a fit you
+                have (0 means perfect fit).  Naturally, the list is now ordered
+                by priority first and then card/channel order.
+
+                When the initialization begins, it runs down the list in
+                order of priority, first trying the perfect fits, then the ones
+                with different bits, then the ones with different rates, then the
+                mono ones if stereo is desired, finishing the job if it can.
+
+                Hans de Goede has accepted my work and is adding it to the
+                contrib section of the xMAME source.  Whether it will make it to
+                the actual source tree will depend on the progress of xMAME itself.
+                In the meantime, you can still use this as a replacement oss.c.
+                Just remember to add -lasound to the linker when you do that!
+
+                Pending word on how override options can be added, I'm seeing if
+                there are advantages in ALSA's non-block mode.  If there are, I
+                may try to include them in here and provide something better than
+                the basic code I started out with.
+
+   10/19/1999 - v.0.0.1 for xMAME released.  INITIAL RELEASE
+                After examining the relatively simple OSS code,
+                I decided to see if I could convert the routines
+                to use ALSA instead.  This is the result.
+
+                Functionality is pretty much similar.  Nothing is lost
+                by using the ALSA driver in Linux instead of OSS.
+                Whether this ALSA driver gives a performance boost or
+                not remains to be seen.
+
+                Though I have no way of proving it, any sound card
+                supported by ALSA and capable of PCM output should run
+                this driver without any trouble.  My own system, a K6-2/300
+                with an SB AWE64, runs fine.
+
+                Because of the ALSA implementation, I have included an
+                autoscanner that scans the system for ALSA PCM channels.
+                Once it finds an open one, it will open the channel and set
+                it up for output.  Once that's done, it acts just like the OSS
+                driver with the exception of using ALSA calls.
+
+                Currently, automatic sample and bitrate scaledown are not
+                incorporated.  These will be added once I can figure out a
+                way to take them into account in the autoscan while prioritizing
+                better cards.  An autoscan override also needs to be included.
+                However, this would require additional changes beyond this code
+                piece.
+
+                Some users may experience unusual sound quality.  This is because
+                my approach to finding the right frag_size and num_frags is very
+                experimental.  The formulae I'm using work for my machine, but
+                your performance may vary.
+*/
+
+#include "xmame.h"           /* xMAME common header */
+#include "sound.h"           /* xMAME sound header */
+#include "devices.h"         /* xMAME device header */
+#include <sys/ioctl.h>       /* System and I/O control */
+#include <sys/asoundlib.h>   /* ALSA sound library header */
+
+/* SCANNING CONSTANTS */
+#define MAX_CARDS 8          /* Maximum number of cards to detect */
+#define MAX_PCMS  8          /* Maximum number of PCM channels per card to detect */
+#define MAX_CHOICES 16       /* Maximum number of choices to queue */
+
+
+/* ERROR CHECKING MACROS */
+#define ALSA_SCAN_CHECK(f) alsa_stat=f;if (alsa_stat) {ALSA_error(alsa_stat);return 0;}
+#define ALSA_INIT_CHECK(f) alsa_stat=f;if (alsa_stat) return ALSA_error(alsa_stat);
+
+/* PRIORITIZING MACROS */
+#define RANGE(x,y,z) ((x<y) ? (x-y) : (x>z) ? (x-z) : 0)
+
+/* TYPE DEFINITIONS */
+typedef struct
+{
+    int card,pcm,priority,rate,bits,channels;
+} choice;
+
+/* GLOBAL VARIABLES */
+int alsa_stat;                     /* ALSA error status */
+static snd_pcm_t * handle_pcm;     /* ALSA sound PCM handler */
+
+/* ALSA ERROR HANDLER */
+int ALSA_error(int a)
+{
+    fprintf(stderr_file,"\nALSA system error: %s\nALSA sound disabled.\n",snd_strerror(a));
+    play_sound=FALSE;
+    return 0;
+}
+
+/* PRIORITIZATION FUNCTIONS */
+
+int prioritize_level3(int *bits,const int b_flags)
+{
+    /* Check if correct bits are specified */
+    if (!(*bits & b_flags))
+    {
+        *bits=b_flags;                     /* Change bits to correct */
+        return 1;                          /* Bits had to be corrected */
+    }
+    return 0;                              /* Bits are already correct */
+}
+
+int prioritize_level2(int *rate,int *bits, const int min,const int max,const int b_flags)
+{
+    /* Given rate is in range */
+    if (!RANGE(*rate,min,max))
+        return prioritize_level3(bits,b_flags);
+
+    /* Given rate is too high.  Must reduce. */
+    if (RANGE(*rate,min,max)>0)
+    {
+        *rate = max;
+        return 2+prioritize_level3(bits,b_flags);
+    }
+
+    /* Given rate is too small.  Must increase. */
+    *rate = min;
+    return 4+prioritize_level3(bits,b_flags);
+}
+
+int prioritize(int *rate,int *bits,int *channels,
+               const int min,const int max,const int b_flags,const int max_chan)
+{
+    /* Not enough channels supported (ie mono device, stereo option). */
+    /* Must adjust. */
+    if (max_chan<(*channels))
+    {
+        *channels=max_chan;
+        return 6+prioritize_level2(rate,bits,min,max,b_flags);
+    }
+
+    /* Otherwise, device is capable of handling channels */
+    return prioritize_level2(rate,bits,min,max,b_flags);
+}
+
+int insert(choice list[],int *list_max,int card,int pcm,int rate,int bits,int channels,
+           const int min,const int max,const int b_flags,const int max_chan)
+{
+    choice temp;
+    /* Obtain priority and correct if necessary */
+    int priority=prioritize(&rate,&bits,&channels,min,max,b_flags,max_chan);
+    int i=0,j,lmax=*list_max;
+    
+    while ((i<lmax) && (list[i++].priority<=priority))
+	;
+
+    /* If i is at MAX_CHOICES, the list is full of channels with higher or equal priority. */
+    /* Ignore addition and return. */
+    if (i==MAX_CHOICES)
+        return lmax;
+
+    /* At this point, an addition WILL be made, so fill in the necessary information for the */
+    /* new entry. */
+    
+    temp.card=card;
+    temp.pcm=pcm;
+    temp.priority=priority;
+    temp.rate=rate;
+    temp.bits=bits;
+    temp.channels=channels;
+
+    /* If i is between lmax and MAX_CHOICES, there is room at the end of the list */
+    /* for the new entry.  Add the entry and return adjusted values. */
+    if (i==lmax)
+    {
+        list[i]=temp;
+	(*list_max)++;
+        return lmax+1;
+    }
+    
+    /* If i is less than lmax, then the entry supercedes others in the list. */
+    /* They'll have to be bumped down so the new entry can be inserted. */
+    j=(lmax==MAX_CHOICES) ? lmax : lmax+1;
+    while (j>i)
+    {
+        list[j]=list[j-1];j--;
+    }
+    list[j]=temp;
+    if (lmax==MAX_CHOICES)
+        return lmax;
+    (*list_max)++;
+    return lmax+1;
+}
+
+/* ALSA sound channel scanner */
+int scan_cards(choice list[])
+{
+
+    /* ALSA Control Handle */
+    static snd_ctl_t * handle_ctl;       /* ALSA sound control handler */
+
+    /* ALSA information variables */
+    snd_ctl_hw_info_t info;              /* Holds current card settings */ 
+    snd_pcm_info_t id;                   /* Holds current PCM ID */ 
+    snd_pcm_playback_info_t temp;        /* Holds current PCM settings */ 
+
+    /* Detection counters */
+    int max_cards;                       /* Maximum ALSA cards detected */
+    int cur_card;                        /* Current ALSA card in use */
+    int cur_pcm;                         /* Current ALSA PCM channel in use */
+    int num_choices=0;                   /* Number of valid choices found */
+    int bit_mask;                        /* Mask for available bitwidth */
+
+    /* Modified option specifiers */
+    int voices = (sound_stereo) ? 2 : 1; /* Is stereo or mono desired? */
+    int bits = (sound_8bit)
+     ? SND_PCM_PINFO_8BITONLY
+     : SND_PCM_PINFO_16BITONLY;          /* Are 8 or 16 bits desired? */
+
+    /* STEP 1: DETERMINE # OF CARDS AVAILABLE */
+
+    fprintf(stderr_file,"Detecting ALSA sound cards... ");
+    alsa_stat=snd_cards();
+    /* If no sound is found, disable sound */
+    if (!alsa_stat)
+    {
+        fprintf(stderr_file,"No cards detected.\nALSA sound disabled.\n");
+        play_sound = FALSE;
+        return OSD_OK;
+    }
+    if (alsa_stat<0)
+    {
+        ALSA_error(alsa_stat);return 0;
+    }
+    fprintf(stderr_file,"%d detected OK.\n",alsa_stat);
+
+    /* Cards above 8 ignored */
+    max_cards=(alsa_stat>8) ? 8 : alsa_stat;
+
+    /* STEP 2: GATHER PCM INFORMATION ABOUT DETECTED CARDS */
+    for (cur_card=0;cur_card<max_cards;cur_card++)
+    {
+        /* Open control handle to soundcard for information gathering */
+        ALSA_SCAN_CHECK(snd_ctl_open(&handle_ctl,cur_card));
+
+        /* Obtain card info (particularly number of PCM channels) */
+        ALSA_SCAN_CHECK(snd_ctl_hw_info(handle_ctl,&info));
+
+        /* Scan PCM channels for capabilities */
+        for (cur_pcm=0;cur_pcm<info.pcmdevs;cur_pcm++)
+        {
+            ALSA_SCAN_CHECK(snd_ctl_pcm_info(handle_ctl,cur_pcm,&id));
+            ALSA_SCAN_CHECK(snd_ctl_pcm_playback_info(handle_ctl,cur_pcm,0,&temp));
+
+            /* Is the channel capable of playback? */
+            if (id.flags & SND_PCM_INFO_PLAYBACK)
+            {
+                /* Adjust flags */
+                bit_mask = temp.flags & (SND_PCM_PINFO_8BITONLY | SND_PCM_PINFO_16BITONLY);
+                if (!bit_mask)
+                    bit_mask = (SND_PCM_PINFO_8BITONLY | SND_PCM_PINFO_16BITONLY);
+                
+                /* Insert item into list via prioritizing insertion function. */
+                insert(list,&num_choices,cur_card,cur_pcm,options.samplerate,
+                       bits,voices,temp.min_rate,temp.max_rate,bit_mask,temp.max_channels);
+
+                /* Relay information to console */
+                fprintf(stderr_file,"%s detected, %d-%dHz, ",id.name,temp.min_rate,temp.max_rate);
+                switch (temp.flags)
+                {
+                    case SND_PCM_PINFO_8BITONLY:  fprintf(stderr_file,"8 bit ");break;
+                    case SND_PCM_PINFO_16BITONLY: fprintf(stderr_file,"16 bit ");break;
+                    default:                      fprintf(stderr_file,"8/16 bit ");
+                 };
+                fprintf(stderr_file,"%s.\n",(temp.max_channels==1) ? "mono" : "stereo");
+            }
+        } /* End PCM for */
+        
+        /* Close handle to prepare for next iteration */
+        ALSA_SCAN_CHECK(snd_ctl_close(handle_ctl));
+
+    } /* End card for */
+
+    /* Check to see if a usable channel WAS found */
+    if (!num_choices)
+    {
+        fprintf(stderr_file,"No usable PCM channels found for your settings.");
+        fprintf(stderr_file,"\nALSA sound disabled.\n");
+        return 0;
+    }
+
+    return num_choices;
+}
+
+/* Initialize audio system */
+int sysdep_audio_init(void)
+{
+    /* Initialization variables */
+    choice list[MAX_CHOICES];            /* Holds list of channels to try */
+    int num_choices;                     /* Amount of elements in list */
+    snd_pcm_playback_info_t temp;        /* Holds current PCM settings */ 
+    snd_pcm_playback_params_t par;       /* Holds current PCM parameters */ 
+    snd_pcm_format_t fmt;                /* Sound format structure */
+    int i;                               /* Index counter */
+
+    /* Variables held from OSS driver */
+    int corrected_frag_size;
+
+    /* Check if sound is enabled */
+    if (!play_sound) return OSD_OK;
+
+    /* Prior to initializing, obtain corrected numbers */
+    corrected_frag_size = (options.samplerate * frag_size) / 22050;
+    if (!sound_8bit) corrected_frag_size += corrected_frag_size;
+    if (sound_stereo) corrected_frag_size += corrected_frag_size;
+
+    /* Inform user of ALSA initialization */
+    fprintf(stderr_file,"ALSA Sound initialization...\n");
+
+    /* Transfer control to card scanner */
+    num_choices=scan_cards(list);
+    if (!num_choices)
+        return OSD_OK;
+
+
+    /* Begin sound initialization */
+    fprintf(stderr_file,"Opening PCM channel... ");
+    i=-1;num_choices--;
+    do	
+    {
+        i++;
+        /* Open handle to PCM channel */
+        alsa_stat=snd_pcm_open(&handle_pcm,list[i].card,list[i].pcm,SND_PCM_OPEN_PLAYBACK);
+    } while (alsa_stat && i<num_choices);
+
+    /* Failed to open ANY channel? */
+    if (alsa_stat)
+    {
+        fprintf(stderr_file,"FAILED.");
+        return ALSA_error(alsa_stat);
+    }
+
+    /* Initialize sound format structure */
+    fmt.format=(list[i].bits==SND_PCM_PINFO_8BITONLY)
+               ? SND_PCM_SFMT_U8 : SND_PCM_SFMT_S16_LE;
+    fmt.rate=list[i].rate;
+    fmt.channels=list[i].channels;
+
+    fprintf(stderr_file,"OK.\nObtaining parameters... ");
+
+    /* Prepare sound parameters */
+    /* NOTE: Setting frag_size and num_frags NOT REALLY WORKING YET. */
+    /* Attemtping to discover better algorithm given ALSA stats. */
+    memset(&par,0,sizeof(par));
+    ALSA_INIT_CHECK(snd_pcm_playback_info(handle_pcm,&temp));
+    frag_size = (temp.max_fragment_size<corrected_frag_size)
+                ? temp.max_fragment_size : corrected_frag_size;
+/*    frag_size = 2048; */
+
+    /* EXPERIMENTAL.  Basically dividing buffer capacity by 8. */
+    num_frags = (temp.buffer_size/frag_size)>>3;
+/*    num_frags = 4;  */
+
+    /* Set parameters and pass onto PCM channel */
+    par.fragment_size=frag_size;
+    par.fragments_max=num_frags;
+    par.fragments_room=1;
+    ALSA_INIT_CHECK(snd_pcm_playback_params(handle_pcm,&par));
+    fprintf(stderr_file,"%d fragments of size %d... ",
+            num_frags,frag_size);
+
+    fprintf(stderr_file,"OK.\nSetting sound format... %dHz, %s %s... ",
+            fmt.rate,(sound_8bit) ? "8-bit" : "16-bit",
+            (fmt.channels>1) ? "stereo" : "mono");
+    ALSA_INIT_CHECK(snd_pcm_playback_format(handle_pcm,&fmt));
+    fprintf(stderr_file,"OK.\nALSA initialization complete.\n");
+    return OSD_OK;
+    
+} /* End sysdep_audio_init() */
+
+void sysdep_audio_close(void)
+{
+    if (play_sound)
+    {
+        snd_pcm_drain_playback(handle_pcm);
+        snd_pcm_close(handle_pcm);
+    }
+}
+
+long sysdep_audio_get_freespace()
+{	
+    int test;
+    snd_pcm_playback_status_t stats;
+
+    test=snd_pcm_playback_status(handle_pcm,&stats);
+
+    if (test)
+        return -1;
+    else
+        return stats.count;
+}
+
+int sysdep_audio_play(unsigned char *buf,int bufsize)
+{
+    return (int) snd_pcm_write(handle_pcm,(const void *)buf,(size_t)bufsize);
+}
diff --git a/src/unix/contrib/patches/boundary-check-patch b/src/unix/contrib/patches/boundary-check-patch
new file mode 100644
index 0000000..fb92263
--- /dev/null
+++ b/src/unix/contrib/patches/boundary-check-patch
@@ -0,0 +1,155 @@
+Only in xmame-0.35b13.1/: cab
+Only in xmame-0.35b13.1/: contrib
+Only in xmame-0.35b13.1/doc: Changes
+Only in xmame-0.35b13.1/doc: LEEME.unix
+Only in xmame-0.35b13.1/doc: MailList.notes
+Only in xmame-0.35b13.1/doc: README.fx
+Only in xmame-0.35b13.1/doc: README.unix
+Only in xmame-0.35b13.1/doc: README.xgl
+Only in xmame-0.35b13.1/doc: TODO
+Only in xmame-0.35b13.1/doc: cheat.dat
+Only in xmame-0.35b13.1/doc: cheat.doc
+Only in xmame-0.35b13.1/doc: credits.unix
+Only in xmame-0.35b13.1/doc: history.dat
+Only in xmame-0.35b13.1/doc: liesmich.unix
+Only in xmame-0.35b13.1/doc: multiplayer-readme.txt
+Only in xmame-0.35b13.1/doc: xmame.man
+Only in xmame-0.35b13.1/doc: xmamerc.dist
+Only in xmame-0.35b13.1/: makefile.objs
+Only in xmame-0.35b13.1/: makefile.unix
+Only in xmame-0.35b13.1/: makefile.x11
+Only in xmame-0.35b13.1/: obj
+diff -ur mame-0.35b13.orig.fixed/src/cheat.c xmame-0.35b13.1/src/cheat.c
+--- mame-0.35b13.orig.fixed/src/cheat.c	Sat May 29 13:19:54 1999
++++ xmame-0.35b13.1/src/cheat.c	Thu Jun 10 14:24:11 1999
+@@ -2342,7 +2342,7 @@
+ {
+   char *ptr;
+   char str[128];
+-  char filename[16];
++  char filename[CHEAT_FILENAME_MAXLEN];
+ 
+   int pos1, pos2;
+ 
+diff -ur mame-0.35b13.orig.fixed/src/sound/adpcm.c xmame-0.35b13.1/src/sound/adpcm.c
+--- mame-0.35b13.orig.fixed/src/sound/adpcm.c	Sat May 29 13:19:54 1999
++++ xmame-0.35b13.1/src/sound/adpcm.c	Thu Jun 10 14:27:06 1999
+@@ -402,16 +402,21 @@
+ 			/* update the ADPCM voice */
+ 			ADPCM_update (voice, cpu_scalebyfcount (buffer_len));
+ 
+-			/* set up the voice to play this sample */
+-			voice->playing = 1;
+-			voice->base = &Machine->memory_region[adpcm_intf->region][sample->offset];
+-			voice->sample = 0;
+-			voice->count = sample->length;
+-
+-			/* also reset the ADPCM parameters */
+-			voice->signal = -2;
+-			voice->step = 0;
++			/* sometimes we get a wrong offset resulting in a crash
++			   so check that first and only play the smaple if we
++			   have a valid offset */
++			if (sample->offset < Machine->memory_region_length[adpcm_intf->region])
++			{
++				/* set up the voice to play this sample */
++				voice->playing = 1;
++				voice->base = &Machine->memory_region[adpcm_intf->region][sample->offset];
++				voice->sample = 0;
++				voice->count = sample->length;
+ 
++				/* also reset the ADPCM parameters */
++				voice->signal = -2;
++				voice->step = 0;
++			}
+ 			return;
+ 		}
+ 	}
+@@ -440,15 +445,21 @@
+ 	/* update the ADPCM voice */
+ 	ADPCM_update (voice, cpu_scalebyfcount (buffer_len));
+ 
+-	/* set up the voice to play this sample */
+-	voice->playing = 1;
+-	voice->base = &Machine->memory_region[adpcm_intf->region][offset];
+-	voice->sample = 0;
+-	voice->count = length;
+-
+-	/* also reset the ADPCM parameters */
+-	voice->signal = -2;
+-	voice->step = 0;
++	/* sometimes we get a wrong offset resulting in a crash
++	   so check that first and only play the sample if we
++	   have a valid offset */
++	if (offset < Machine->memory_region_length[adpcm_intf->region])
++	{
++		/* set up the voice to play this sample */
++		voice->playing = 1;
++		voice->base = &Machine->memory_region[adpcm_intf->region][offset];
++		voice->sample = 0;
++		voice->count = length;
++
++		/* also reset the ADPCM parameters */
++		voice->signal = -2;
++		voice->step = 0;
++	}
+ }
+ 
+ 
+@@ -697,15 +708,21 @@
+ 				/* update the ADPCM voice */
+ 				ADPCM_update (voice, buffer_end);
+ 
+-				/* set up the voice to play this sample */
+-				voice->playing = 1;
+-				voice->base = &Machine->memory_region[okim6295_interface->region[num]][start];
+-				voice->sample = 0;
+-				voice->count = 2 * (stop - start + 1);
+-
+-				/* also reset the ADPCM parameters */
+-				voice->signal = -2;
+-				voice->step = 0;
++				/* sometimes we get a wrong offset resulting in a crash
++				   so check that first and only play the sample if we
++				   have a valid offset */
++				if (start < Machine->memory_region_length[okim6295_interface->region[num]])
++				{
++					/* set up the voice to play this sample */
++					voice->playing = 1;
++					voice->base = &Machine->memory_region[okim6295_interface->region[num]][start];
++					voice->sample = 0;
++					voice->count = 2 * (stop - start + 1);
++
++					/* also reset the ADPCM parameters */
++					voice->signal = -2;
++					voice->step = 0;
++				}
+ 
+ 				/* volume control is entirely guesswork */
+ 				{
+Only in xmame-0.35b13.1/src: unix
+diff -ur mame-0.35b13.orig.fixed/src/vidhrdw/megasys1.c xmame-0.35b13.1/src/vidhrdw/megasys1.c
+--- mame-0.35b13.orig.fixed/src/vidhrdw/megasys1.c	Sat May 29 13:19:55 1999
++++ xmame-0.35b13.1/src/vidhrdw/megasys1.c	Thu Jun 10 14:27:06 1999
+@@ -472,11 +472,18 @@
+ 			code  =   READ_WORD(&scrollram[j][offs]) & mask[j];
+ 
+ 			if (scrollflag[j] & 0x10)
++				/* some boundary checking dunno why we needs this
++				   but other wise real os's kill mame */
++				if (code < Machine->gfx[j]->total_elements)
+ 					colmask[color] |= pen_usage[code];
+-			else{	colmask[color] |= pen_usage[code*4+0];
++			else
++				if ((code*4+3) < Machine->gfx[j]->total_elements)
++				{
++					colmask[color] |= pen_usage[code*4+0];
+ 					colmask[color] |= pen_usage[code*4+1];
+ 					colmask[color] |= pen_usage[code*4+2];
+-					colmask[color] |= pen_usage[code*4+3];}
++					colmask[color] |= pen_usage[code*4+3];
++				}
+ 		}
+ 
+ 		for (color = 0; color < 16; color++)
+Only in xmame-0.35b13.1/: xmame.x11
diff --git a/src/unix/contrib/patches/configure.in b/src/unix/contrib/patches/configure.in
new file mode 100644
index 0000000..7f7533e
--- /dev/null
+++ b/src/unix/contrib/patches/configure.in
@@ -0,0 +1,158 @@
+----------snip---------
+dnl Process this file with autoconf to produce a configure script.
+dnl *** todo: check against bashisms
+AC_INIT(src/unix/FREEBSD.c)
+
+dnl Find what type of system we are
+AC_CANONICAL_HOST
+
+dnl Checks for programs.
+AC_PROG_CC
+AC_PROG_INSTALL
+
+dnl Checks for header files.
+AC_PATH_XTRA
+AC_HEADER_DIRENT
+AC_HEADER_STDC
+AC_CHECK_HEADERS(fcntl.h sys/ioctl.h sys/time.h unistd.h)
+
+dnl Checks for typedefs, structures, and compiler characteristics.
+AC_C_CONST
+AC_HEADER_TIME
+
+dnl Checks for library functions.
+AC_TYPE_SIGNAL
+AC_FUNC_VPRINTF
+AC_CHECK_FUNCS(gettimeofday socket)
+
+
+dnl ***********************
+dnl ***  Check for sound capabilities
+dnl ***********************
+dnl check for FANCY_SOUND
+dnl    todo: evaluate --- any way to autosense?
+AC_ARG_ENABLE(fancysound,
+[  --enable-fancysound     use linear interpolation (default if supported)
+  --disable-fancysound    audio does not use linear interpolation],
+[enable_fancysound="$enable_fancysound"], [enable_fancysound="yes"])
+AC_MSG_CHECKING(for fancy sound)
+if test "$enable_fancysound" = "no"; then
+  AC_MSG_RESULT(no)
+else
+  case "$host" in
+    *-aix-* | *-sun-*)
+      AC_MSG_RESULT(not on this platform)
+      ;;
+    *)
+      AC_MSG_RESULT(yes)
+      AC_DEFINE(FANCY_SOUND)
+      ;;
+  esac
+fi
+dnl check for USE_TIMER (default unless linux or sgi)
+dnl       NB: don't bother setting DONTUSER_TIMER, it is never
+dnl           referenced by the source!
+dnl       NB: any interdependancy between USE_TIMER and FANCY_SOUND ?
+AC_ARG_ENABLE(audiotimer,
+[  --enable-audiotimer     audio uses a fixed timer
+  --disable-audiotimer    audio queries audio buffer (default if supported)],
+[enable_audiotimer="$enable_audiotimer"], [enable_audiotimer="no"])
+AC_MSG_CHECKING(for audio fixed timer)
+if test "$enable_audiotimer" = "yes"; then
+  AC_MSG_RESULT([yes, too bad])
+  AC_DEFINE(USE_TIMER)
+else
+  case "$host" in
+    *-linux-* | *-sgi-*)
+      AC_MSG_RESULT([no, will query audio buffer instead])
+      ;;
+    *)
+      AC_MSG_RESULT([yes, too bad])
+      AC_DEFINE(USE_TIMER)
+      enable_audiotimer="yes"
+      ;;
+  esac
+fi
+dnl *** todo: allow define of AUDIO_TIMER_FREQ
+dnl ***	  NB: no need to set it necessarily, allow src/unix/sound.h do that
+dnl           however, in ideal world, derive as some whole divider of the 
+dnl           system timer
+dnl *** todo: allow turning off all audio capabilities (?)
+
+dnl ***********************
+dnl ***  Check for svgalib
+dnl ***********************
+AC_ARG_ENABLE(svgalib,
+[  --enable-svgalib        SVGAlib will be used
+  --disable-svgalib       SVGAlib will not be used (default)],
+[enable_svgalib="$enableval"], [enable_svgalib="no"])
+AC_MSG_CHECKING(for SVGAlib build)
+if test "$enable_svgalib" = "no"; then
+  AC_MSG_RESULT(no)
+else
+  AC_MSG_RESULT(yes)
+  if test "$enable_audiotimer" = "yes"; then
+    AC_MSG_ERROR([SVGAlib build requested, but fixed audio timer conflicts])
+  fi
+  AC_CHECK_LIB(vga,vga_hasmode)
+  if test "$ac_cv_lib_vga_vga_hasmode" = "no"; then
+    AC_MSG_ERROR([SVGAlib build requested, but libvga cannot be found])
+  fi
+fi
+
+dnl ***********************
+dnl ***  Check for Xpm
+dnl ***********************
+AC_ARG_ENABLE(xpm,
+[  --enable-xpm            libXpm used if found (default)
+  --disable-xpm           libXpm will not be used],
+[enable_xpm="$enableval"], [enable_xpm="yes"])
+if test "$enable_xpm" = "yes" -a "$ac_cv_lib_vga_vga_hasmode" = "no"; then
+  save_cflags="$CFLAGS"
+  CFLAGS="$CFLAGS $X_CFLAGS"
+  CPPFLAGS="$CPPFLAGS $X_CFLAGS"
+  AC_CHECK_HEADERS(X11/xpm.h)
+  CFLAGS="$save_cflags"
+  if test "$ac_cv_header_X11_xpm_h" = "yes"; then
+    save_ldflags="$LDFLAGS"
+    LDFLAGS="$LDFLAGS $X_LIBS"
+    AC_CHECK_LIB(Xpm, XpmReadFileToPixmap,
+                 [X_PRE_LIBS="-lXpm $X_PRE_LIBS"; AC_DEFINE(HAVE_LIBXPM)], [], 
+                 [$X_PRE_LIBS -lX11 $X_EXTRA_LIBS])
+    LDFLAGS="$save_ldflags"
+  fi
+fi 
+
+dnl ***********************
+dnl ***  Check for mitshm
+dnl ***********************
+dnl APH TOCHECK:  is disable overriding a cache which is already there?
+AC_ARG_ENABLE(mitshm,
+[  --enable-mitshm         MIT-Shared Memory X extension used if found (default)
+  --disable-mitshm        MIT-Shared Memory X extension will not be used],
+[enable_mitshm="$enableval"], [enable_mitshm="yes"])
+if test "$enable_mitshm" = "yes" -a "$ac_cv_lib_vga_vga_hasmode" = "no"; then
+  save_ldflags="$LDFLAGS"
+  LDFLAGS="$LDFLAGS $X_LIBS -lX11"
+  AC_CACHE_CHECK(for MIT-Shared Memory X extension, mame_cv_sys_mitshm, [AC_TRY_RUN([#if STDC_HEADERS
+# include <stdlib.h>
+#endif
+#include <X11/Xlib.h>
+#include <sys/ipc.h>
+#include <sys/shm.h>
+#include <X11/extensions/XShm.h>
+main() {
+   Display *display;
+   int result;
+   int i,j,k;
+   display = XOpenDisplay(":0");
+   result = XQueryExtension(display,"MIT-SHM",&i,&j,&k);
+   if ( ! result ) exit(1);
+   exit(0);
+}
+	],mame_cv_sys_mitshm=yes,mame_cv_sys_mitshm=no,mame_cv_sys_mitshm=yes)])
+  LDFLAGS="$save_ldflags"
+fi
+
+AC_OUTPUT(Makefile)
+
diff --git a/src/unix/contrib/patches/esound.diff b/src/unix/contrib/patches/esound.diff
new file mode 100644
index 0000000..96da537
--- /dev/null
+++ b/src/unix/contrib/patches/esound.diff
@@ -0,0 +1,977 @@
+diff -ruN xmame-esd/Makefile xmame-0.33b7.1/Makefile
+--- xmame-esd/Makefile	Thu Jan  1 01:00:00 1970
++++ xmame-0.33b7.1/Makefile	Sun Aug  2 21:02:44 1998
+@@ -0,0 +1,757 @@
++##############################################################################
++#
++# Makefile for X-Mame-0.33b7.1
++#
++# by Juan Antonio Martinez
++# http:/www.dit.upm.es/~jantonio/mame/
++# mailto:mame@drake.dit.upm.es
++#
++##############################################################################
++
++VERSION = 0.33b7.1
++DATE = 24-July-1998
++
++#########################################################################
++#									#
++# READ COMMENTS AND MODIFY CONFIGURABLE OPTIONS WITH CARE...		#
++#									#
++# Members of Mame and X-Mame project assumes no responsability  	#
++# implicit or explicit about illegal or incorrect use of this   	#
++# sofware and about possible hard/soft damage derived of it   	  	#
++#									#
++# THIS SOFTWARE IS DISTRIBUTED "AS IS" . USE AT YOUR OWN RISK		#
++#									#
++# Mame and X-Mame are Copyright of Nicola Salmoria and Mirko buffoni	#
++# and distributed under terms of the GNU General Public License         #
++#									#
++# Arcade ROM images are copyright of their authors. DISTRIBUTING MAME   #
++# OR X-MAME INCLUDING ROM IMAGES IN THE SAME PACKAGE IS ILLEGAL AND	#
++# CONSTITUTES A VIOLATION OF TERMS OF COPYRIGHT				#
++#									#
++#########################################################################
++
++##############################################################################
++# *** general options
++###############################################################################
++# GNU MAKE is MANDATORY !!!
++# so please give me the path...
++# if GNU make is "native" use this
++MAKE	= make
++# else ...
++# MAKE=/usr/people/jantonio/bin/gmake
++
++# *** Choose your compiler
++CC	= gcc
++# for IRIX systems seems that DCC gets better code than GNU. so use it:
++# CC	= DCC
++#
++# Use of `c89' is recommend for ultrix as it generates faster code (which
++# means less frames to be skipped and better graphics) but `gcc' works just
++# as well. However, stay away from the `cc' ultrix compiler if possible.
++# CC	= c89
++# for ansi compliance testing, only for developers !!
++# CC	= gcc -ansi -pedantic -D_XOPEN_SOURCE -DM_PI=3.141592 -DPEDANTIC
++
++# *** Choose your linker ( some OS's needs native linker instead GNU one )
++# normal
++LD	= $(CC) -s
++# to profile with gcc and gprof
++# LD	= $(CC) -pg
++# no profiling (less strace output), but with debug info
++# LD	= $(CC)
++# for debugging only, only works with gnu-binutils !!
++# LD	= $(CC) -Wl,-warn-common
++
++# *** How to install executable? ( some OS's doesn't support install command )
++INSTALL = cp
++
++# *** set to aproppiate flag if want to debug/optimize
++# normal
++DBGFLAGS =
++# with debug info 
++# DBGFLAGS    = -ggdb
++
++### normal optimization flags
++OPTFLAGS    = -O -Wall
++
++# use these for debugging on x86-gcc
++# OPTFLAGS    = -O2 -m486 -Wall
++### to get full optimization under gcc/x Intel based OS's.. ( !!else comment!! )
++# OPTFLAGS     = -O3 -m486 -Wall -Wno-parentheses -funroll-loops \
++#   -fstrength-reduce -fomit-frame-pointer -ffast-math -malign-functions=2 \
++#   -malign-jumps=2 -malign-loops=2
++### for Linux/X11/PowerPC use following opts
++# OPTFLAGS     = -O3 -Wall -Wno-parentheses -funroll-loops \
++#  -fstrength-reduce -fomit-frame-pointer -ffast-math -fsigned-char
++
++# *** Does your compiler supports inline funcs?. use appropiate item:
++# do not use IL = inline : wont work due to Z80 and 6809 stuffs
++# if strict ansi used set IL to "static"
++# IL	= '-DINLINE=static inline'
++IL     = -DINLINE=static
++
++##############################################################################
++# *** Capabilities
++##############################################################################
++
++# *** To disable joystick support comment next line
++# JOY		= -DUSE_JOYSTICK
++
++# *** To disable  mouse support comment next line
++MOUSE		= -DUSE_MOUSE
++
++# if you have selected joystick support , select your preferences:
++#
++# *** for using X Input Extensions based joystick
++# ( Recommended if available. Of course: doesn't work in SVGALib arch ...)
++# You should also declare a default name for input device.
++# and choose polling method ( event processing or device polling )
++# use provided program "xlistdev" to now available ones
++# and dont forget to include library in linker definition !!
++# JS	= -DX11_JOYSTICK
++# JSNAME = \"Joystick\"
++# JSPOLL  = -DUSE_X11_JOYEVENTS
++# JSLIB   = -lXi
++
++# On iX86 based OS's, if supported, you can use standard joystick driver
++# JS	= -DI386_JOYSTICK
++
++# Linux FM-TOWNS game PAD joystick emulation support
++# Thanks to Osamu Kurati for provided patch
++# JS	= -DLIN_FM_TOWNS
++
++# *** X-Mame uses the XPM library to make snapshots. If you want to, uncomment
++# following section to support them ( you should have libxpm available :-) )
++# COMMENT IT if your are compiling for Linux's SVGALIB arch
++#XPM	= -DHAS_XPM
++#XPMLIB	= -lXpm -L/usr/X11R6/lib
++ 
++# *** If you haven't  the MIT-Shared Memory X Extensions, comment the following:
++# ( Test if available by mean of xdpyinfo command )
++# Comment it if compiling to svgalib xmame
++# MSHM	= -DUSE_MITSHM
++
++# *** Does your system support gettimeofday() function? If do, we encourage you
++# to enable this feature . Else .... comment it :-(
++TD	= -DHAVE_GETTIMEOFDAY
++
++# do not edit next line !! ( note that XPM options are not included )
++CAPABILITIES = $(MSHM) $(MOUSE) $(JOY) $(JS) "-DX11_JOYNAME='$(JSNAME)'" $(JSPOLL) $(TD) 
++
++##############################################################################
++# *** Configuration files and directories
++##############################################################################
++
++# *** where does your X11 source tree resides ?? use aproppiate switch 
++
++# standard location for X11 
++# X11INC		= -I/usr/include/X11
++# X11LIB		= -L/usr/lib/X11
++# standard location for XFree86
++X11INC		= -I/usr/X11R6/include
++X11LIB		= -L/usr/X11R6/lib
++# for Sun systems 
++# X11INC		= -I/usr/openwin/include
++# X11LIB		= -L/usr/openwin/lib
++# for non-standard locations
++# X11INC		= -I/usr/local/include/X11
++# X11LIB		= -L/usr/local/lib
++
++# *** If you want esound support you need to tell where to find lib and 
++# include files. Next two lines should be very common locations.
++ESDINC		= -I/usr/local/include
++ESDLIB		= -L/usr/local/lib -lesd
++
++# These options defines default location for roms and configuration files
++# also, your default X display is defined here
++#
++
++# *** Select destination directory for your compiled program , manual page
++# and binary distribution ( if you want to... )
++# ( only needed to install, not to compile... )
++DESTDIR = /usr/games
++MANDIR = /usr/local/man/man6
++DISTDIR = /home/ftp/pub/emulators/mame
++
++# *** Where the ROM source tree ?
++MDIR = \"/usr/games/lib/mame\"
++
++# *** Where to store high scores ?
++SDIR = \"/usr/games/lib/mame\"
++
++# *** Where resides global configuration file ?
++MRC = \"/usr/games/lib/mame/xmamerc\"
++
++# *** Use this definition as default X Display
++DP = \":0.0\"
++
++# Dont modify next line !!
++CONF = -DMAMEDIR='$(MDIR)' -DSPOOLDIR='$(SDIR)' -DMAMERC='$(MRC)' -DDISPLAY='$(DP)'
++
++##############################################################################
++# *** Audio features
++# ( only used if audio is available and enabled at compile-time )
++##############################################################################
++
++# *** Do you want linear interpolation in mixer? Uncomment following line
++# Some OS's ( AIX and Solaris ) makes terrible noise if these feature is set
++# so you can test it and decide....
++S_LIN = -DFANCY_SOUND
++
++# *** If your system supports query audio buffer size (like IRIX or Linux )
++# you might decide to use these feature. Otherwise, you should use a 
++# timer based audio code and ajust in src/unix/sound.h AUDIO_TIMER_FREQ item
++# Note: esound support needs timer ON to output sound right
++#
++# S_TIM = -DDONTUSE_TIMER
++S_TIM = -DUSE_TIMER
++
++# *** When using timer, you should provide the frequency to generate audio sample
++# frames in your system. See readme.unix notes about these item
++#
++S_AFR =	-DAUDIO_TIMER_FREQ=50
++
++# *** For EsounD support uncomment the next line. Linux ONLY for the moment! 
++S_ESD = -DUSE_EsounD
++
++# Dont modify next line !!
++SOUND_OPTS = $(S_LIN) $(S_TIM) $(S_AFR) $(S_ESD)
++
++##############################################################################
++# *** architecture.
++##############################################################################
++
++# *** Choose your OS (!!only one!!) 
++#  you can also try make -f makefile.unix ARCH=<your_unix_arch>
++
++######## PowerPC/Linux/X11
++# ARCH  = linux_powerpc
++######## Alpha/Linux/X11
++# ARCH  = linux_alpha
++######## ix86/Linux/X11
++ARCH  = linux
++######## ix86/Linux/SVGALIB
++# ARCH	= svgalib
++######## ix86/Linux/GGI *New* *New* *New* Please test - no mouse or joy yet
++# ARCH  = ggi
++######## ix86/FreeBSD/X11 and ix86/BSDi/X11
++# ARCH  = FREEBSD
++######## ix86/NetBSD/X11
++# ARCH  = netbsd_i386
++######## Sparc/SunOS/X11 ( no sound )
++# ARCH  = sunos
++######## ix86/Solaris/X11
++# ARCH  = solaris_i386
++######## Sparc/Solaris/X11 ( horrible sound :-( )
++# ARCH  = solaris
++######## Mips/IRIX/X11 ( sound selectable: see arch-dependent options )
++# ARCH  = irix
++######## HP-PA/hpux/X11 ( no sound )
++# ARCH  = hpux
++######## IBM/aix/X11 ( sound selectable: see arch-dependent options )
++# ARCH  = aix
++######## RISC/ultrix/X11 ( no sound )
++# ARCH  = ultrix
++
++##############################################################################
++# **** Architecture dependent defs. Only change if you know what're you doing...
++##############################################################################
++
++# Linux PowerPC + X-Windows
++#####################
++DEFS.linux_powerpc   = -DUNIX -Dlinux -Dlinux_powerpc -DACORN -DSIGNED_SAMPLES
++LIBS.linux_powerpc   = $(X11LIB) -lX11 -lXext -lm
++CFLAGS.linux_powerpc = $(X11INC) -fstrength-reduce -funroll-loops \
++                -fomit-frame-pointer -fsigned-char -Wall
++# for debbuging disable all opts...
++# CFLAGS.linux_powerpc = $(X11INC) -Wall
++INST.linux_powerpc   = doinstall
++
++# Linux Alpha + X-Windows
++#####################
++DEFS.linux_alpha   = -DLSB_FIRST -DUNIX -Dlinux -DAXP_ASM -Dlinux_alpha -DACORN -DSIGNED_SAMPLES
++LIBS.linux_alpha   = $(X11LIB) -lX11 -lXext -lm
++CFLAGS.linux_alpha = $(X11INC) -fstrength-reduce -funroll-loops \
++		-fomit-frame-pointer -Wall
++# for debbuging disable all opts...
++# CFLAGS.linux_alpha = $(X11INC) -Wall
++INST.linux_alpha   = doinstall
++
++# Linux Intelx86 + X-Windows
++#####################
++# to debug you'll have to exclude -DX86_ASM
++DEFS.linux   = -DLSB_FIRST -DUNIX -Dlinux -DX86_ASM -DSIGNED_SAMPLES
++LIBS.linux   = $(X11LIB) $(ESDLIB) -lX11 -lXext -lm
++# CFLAGS.linux = $(X11INC) -m486 -fstrength-reduce -funroll-loops \
++#   		-fomit-frame-pointer -Wall
++# for debbuging disable all opts...
++CFLAGS.linux = $(X11INC) $(ESDINC) -m486 -Wall -g 
++INST.linux   = doinstall
++
++# Linux + Svgalib
++#####################
++DEFS.svgalib   = -DLSB_FIRST -DUNIX -Dsvgalib -Dlinux -DX86_ASM -DSIGNED_SAMPLES
++LIBS.svgalib   = -lm -lvga -lvgagl
++CFLAGS.svgalib = 
++INST.svgalib   = doinstallsvgalib
++
++# Linux + libGGI *definitely maybe*
++#####################
++DEFS.ggi       = -DLSB_FIRST -DUNIX -Dggi -Dlinux -DX86_ASM -DSIGNED_SAMPLES
++LIBS.ggi       = -lm -lggi
++CFLAGS.ggi     = -I/usr/local/include #I'd put a '-g' here...
++INST.ggi       = doinstall
++
++# FreeBSD and BSDi
++#####################
++# to compile under BSDI add "-DBSDi" to DEFS.FREEBSD
++#
++DEFS.FREEBSD   = -DX86_ASM -DLSB_FIRST -DUNIX -Dlinux -DFREEBSD \
++		-DFREEBSD_SOUND_WORKAROUND -DSIGNED_SAMPLES
++LIBS.FREEBSD   = $(X11LIB) -lX11 -lXext -lm
++CFLAGS.FREEBSD = $(X11INC) -m486 -fstrength-reduce -funroll-loops \
++		-fomit-frame-pointer -Wall
++INST.FREEBSD   = doinstall
++
++# netbsd_i386
++#####################
++#If you want sound add to DEFS.netbsd_i386  "-DUSE_AUDIO" and 
++#set STIM=-DUSE_TIMER above
++#
++DEFS.netbsd_i386   = -DX86_ASM -DLSB_FIRST -DUNIX -Dnetbsd_i386 -DNETBSD \
++		-DHAVE_GETTIMEOFDAY -DUSE_AUDIO -DSIGNED_SAMPLES
++LIBS.netbsd_i386   = $(X11LIB) -lX11 -lXext -lm
++CFLAGS.netbsd_i386 = $(X11INC) -m486 -fstrength-reduce -funroll-loops \
++		-fomit-frame-pointer -Wall
++INST.netbsd_i386   = doinstall
++
++# SunOS
++#####################
++DEFS.sunos	 = -DUNIX -Dsun -Dsunos -DCLOCKS_PER_SEC=1000000 \
++		-DACORN -DSIGNED_SAMPLES
++LIBS.sunos       = $(X11LIB) -lX11 -lXext -lm
++CFLAGS.sunos	 = $(X11INC)
++INST.sunos      = doinstall
++
++# Solaris
++#####################
++DEFS.solaris	 = -DUNIX -Dsun -Dsolaris -DACORN -DSIGNED_SAMPLES
++LIBS.solaris     = $(X11LIB) -lX11 -lXext -lnsl -lsocket -lm
++CFLAGS.solaris   = $(X11INC)
++INST.solaris     = doinstall
++
++# Solaris_i386
++#####################
++DEFS.solaris_i386     = -DUNIX -DLSB_FIRST -Dsun -Dsolaris -DSIGNED_SAMPLES
++LIBS.solaris_i386     = $(X11LIB) -lX11 -lXext -lnsl -lsocket -lm
++CFLAGS.solaris_i386   = $(X11INC) 
++INST.solaris_i386     = doinstall
++
++# IRIX + Sound
++#####################
++# configurable sound support thanks to entropy@zippy.bernstein.com
++# if your IRIX system has the dmedia package installed use following defs
++DEFS.irix	 = -DUNIX -Dsgi -DACORN -DSIGNED_SAMPLES
++LIBS.irix        = $(X11LIB) -lX11 -lXext -lm -laudio
++CFLAGS.irix      = $(X11INC)
++INST.irix        = doinstall
++
++# IRIX without sound support
++######################
++# If you have no sound support ( dmedia package not installed )
++# or you don't want sound, use these definitions instead of above
++# DEFS.irix	 = -DUNIX -Dsgi -DIRIX_NOSOUND -DACORN -DSIGNED_SAMPLES
++# LIBS.irix        = $(X11LIB) -lX11 -lXext -lm
++# CFLAGS.irix      = $(X11INC)
++# INST.irix        = doinstall
++
++
++# AIX + Sound
++#####################
++# Thanks to Chris Sharp for writing sound driver and sending patches
++# you'll need the UMS and SOM lpp's installed ( under AIX4 )
++DEFS.aix	 = -DUNIX -Daix -DUSE_AUDIO -DACORN -DSIGNED_SAMPLES
++LIBS.aix         = $(X11LIB) -lX11 -lXext -lm -lUMSobj
++CFLAGS.aix	 = $(X11INC) -O2 -I/usr/include/UMS -I/usr/lpp/som/include 
++INST.aix         = doinstall
++
++# AIX Without Sound support
++############################
++# If you have no sound libs availables in AIX, you should disable audio
++# so use these definitions instead of above ones
++# DEFS.aix	 = -DUNIX -Daix -DACORN -DSIGNED_SAMPLES
++# LIBS.aix       = $(X11LIB) -lX11 -lXext -lm
++# CFLAGS.aix	 = $(X11INC)
++# INST.aix         = doinstall
++
++# HP-UX
++#####################
++# you MUST use GNU compiler and GNU make to get it run
++# no sound support (yet)
++DEFS.hpux	 = -DUNIX -Dhpux -DACORN -DSIGNED_SAMPLES
++LIBS.hpux        = $(X11LIB) -lX11 -lXext -lm
++CFLAGS.hpux 	 = $(X11INC)
++INST.hpux        = doinstall
++
++# RISC/Ultrix
++#####################
++# Use c89 as compiler ( see above ) 
++# no sound support (yet)
++DEFS.ultrix	 = -DLSB_FIRST -DUNIX -Dultrix -DACORN -DSIGNED_SAMPLES
++LIBS.ultrix      = $(X11LIB) -lX11 -lXext -lm
++CFLAGS.ultrix 	 = $(X11INC)
++INST.ultrix      = doinstall
++
++###########################################################################
++# No configurable options below this line....
++###########################################################################
++
++INCDIRS	= -Isrc -Isrc/unix -Isrc/Z80 -Isrc/M6502 -Isrc/M6808 -Isrc/M6809\
++ -Isrc/M68000 -Isrc/I8039 -Isrc/I86
++
++# Perhaps one day original mame sources will use POSIX strcasecmp and M_PI
++# instead MS-DOS counterparts... ( a long and sad history ...)
++CFLAGS	= $(CAPABILITIES) $(SOUND_OPTS) $(DBGFLAGS) $(OPTFLAGS) \
++	  $(XPM) $(IL) $(INCDIRS) $(CFLAGS.$(ARCH)) -Dstricmp=strcasecmp -DPI=M_PI
++
++OBJOSDEP = obj/unix/osdepend.a
++
++OBJMAME= obj/mame.o obj/common.o obj/usrintrf.o obj/driver.o \
++         obj/cpuintrf.o obj/memory.o obj/timer.o obj/palette.o obj/gfxlayer.o \
++         obj/inptport.o obj/cheat.o obj/unzip.o obj/inflate.o \
++         obj/audit.o \
++         obj/sndhrdw/adpcm.o \
++         obj/sndhrdw/psg.o obj/sndhrdw/psgintf.o \
++         obj/sndhrdw/2151intf.o obj/sndhrdw/fm.o \
++         obj/sndhrdw/ym2151.o obj/sndhrdw/ym3812.o \
++	 obj/sndhrdw/tms5220.o obj/sndhrdw/5220intf.o obj/sndhrdw/vlm5030.o \
++	 obj/sndhrdw/pokey.o obj/sndhrdw/pokyintf.o obj/sndhrdw/sn76496.o \
++	 obj/sndhrdw/nes.o obj/sndhrdw/nesintf.o \
++	 obj/sndhrdw/votrax.o obj/sndhrdw/dac.o obj/sndhrdw/samples.o \
++         obj/machine/Z80fmly.o obj/machine/6821pia.o \
++         obj/vidhrdw/generic.o obj/sndhrdw/generic.o \
++         obj/vidhrdw/vector.o obj/vidhrdw/avgdvg.o obj/machine/mathbox.o \
++         obj/sndhrdw/namco.o \
++         obj/machine/pacman.o obj/drivers/pacman.o \
++         obj/machine/theglob.o \
++         obj/drivers/maketrax.o \
++         obj/machine/jrpacman.o obj/drivers/jrpacman.o obj/vidhrdw/jrpacman.o \
++         obj/vidhrdw/pengo.o obj/drivers/pengo.o \
++         obj/vidhrdw/ladybug.o obj/drivers/ladybug.o \
++         obj/vidhrdw/mrdo.o obj/drivers/mrdo.o \
++         obj/machine/docastle.o obj/vidhrdw/docastle.o obj/drivers/docastle.o \
++         obj/drivers/dowild.o \
++         obj/vidhrdw/nova2001.o obj/drivers/nova2001.o \
++         obj/vidhrdw/cclimber.o obj/sndhrdw/cclimber.o obj/drivers/cclimber.o \
++         obj/drivers/ckongs.o \
++         obj/vidhrdw/seicross.o obj/drivers/seicross.o \
++         obj/vidhrdw/dkong.o obj/sndhrdw/dkong.o obj/drivers/dkong.o \
++         obj/machine/bagman.o obj/vidhrdw/bagman.o obj/drivers/bagman.o \
++         obj/machine/wow.o obj/vidhrdw/wow.o obj/sndhrdw/wow.o obj/drivers/wow.o \
++         obj/sndhrdw/gorf.o \
++         obj/vidhrdw/galaxian.o obj/drivers/galaxian.o \
++         obj/sndhrdw/mooncrst.o obj/drivers/mooncrst.o \
++         obj/vidhrdw/frogger.o obj/sndhrdw/frogger.o obj/drivers/frogger.o \
++         obj/machine/scramble.o obj/sndhrdw/scramble.o obj/drivers/scramble.o \
++         obj/drivers/scobra.o \
++         obj/vidhrdw/amidar.o obj/drivers/amidar.o \
++         obj/vidhrdw/warpwarp.o obj/drivers/warpwarp.o \
++         obj/vidhrdw/popeye.o obj/drivers/popeye.o \
++         obj/vidhrdw/rallyx.o obj/drivers/rallyx.o \
++         obj/drivers/locomotn.o \
++         obj/vidhrdw/pooyan.o obj/drivers/pooyan.o \
++         obj/vidhrdw/timeplt.o obj/drivers/timeplt.o \
++         obj/vidhrdw/phoenix.o obj/sndhrdw/phoenix.o obj/drivers/phoenix.o \
++         obj/sndhrdw/pleiads.o \
++         obj/vidhrdw/vicdual.o obj/sndhrdw/vicdual.o obj/drivers/vicdual.o \
++         obj/machine/8080bw.o obj/vidhrdw/8080bw.o obj/sndhrdw/8080bw.o obj/drivers/8080bw.o \
++         obj/machine/Z80bw.o obj/vidhrdw/Z80bw.o obj/sndhrdw/Z80bw.o obj/drivers/Z80bw.o \
++         obj/vidhrdw/mario.o obj/sndhrdw/mario.o obj/drivers/mario.o \
++         obj/vidhrdw/zaxxon.o obj/sndhrdw/zaxxon.o obj/drivers/zaxxon.o \
++         obj/vidhrdw/congo.o obj/sndhrdw/congo.o obj/drivers/congo.o \
++         obj/vidhrdw/bombjack.o obj/drivers/bombjack.o \
++         obj/machine/centiped.o obj/vidhrdw/centiped.o obj/drivers/centiped.o \
++         obj/machine/milliped.o obj/vidhrdw/milliped.o obj/drivers/milliped.o \
++         obj/vidhrdw/warlord.o obj/drivers/warlord.o \
++         obj/vidhrdw/rockola.o obj/sndhrdw/rockola.o obj/drivers/rockola.o \
++         obj/vidhrdw/mpatrol.o  obj/sndhrdw/mpatrol.o obj/drivers/mpatrol.o \
++         obj/vidhrdw/travrusa.o obj/drivers/travrusa.o \
++         obj/vidhrdw/btime.o obj/drivers/btime.o \
++         obj/vidhrdw/jumpbug.o obj/drivers/jumpbug.o \
++         obj/vidhrdw/gberet.o obj/drivers/gberet.o \
++         obj/machine/exidy.o obj/vidhrdw/exidy.o obj/drivers/exidy.o \
++	 obj/sndhrdw/targ.o \
++         obj/vidhrdw/gottlieb.o obj/sndhrdw/gottlieb.o obj/drivers/gottlieb.o \
++         obj/vidhrdw/bking2.o obj/drivers/bking2.o \
++         obj/machine/taito.o obj/vidhrdw/taito.o obj/drivers/taito.o \
++         obj/machine/panic.o obj/vidhrdw/panic.o obj/drivers/panic.o \
++         obj/machine/arabian.o obj/vidhrdw/arabian.o obj/drivers/arabian.o \
++         obj/vidhrdw/1942.o obj/drivers/1942.o \
++         obj/vidhrdw/vulgus.o obj/drivers/vulgus.o \
++         obj/vidhrdw/commando.o obj/drivers/commando.o \
++         obj/vidhrdw/gng.o obj/drivers/gng.o \
++         obj/vidhrdw/sonson.o obj/drivers/sonson.o \
++         obj/vidhrdw/exedexes.o obj/drivers/exedexes.o \
++         obj/sndhrdw/gyruss.o obj/vidhrdw/gyruss.o obj/drivers/gyruss.o \
++         obj/machine/superpac.o obj/vidhrdw/superpac.o obj/drivers/superpac.o \
++         obj/machine/galaga.o obj/vidhrdw/galaga.o obj/drivers/galaga.o \
++         obj/machine/kangaroo.o obj/vidhrdw/kangaroo.o obj/drivers/kangaroo.o \
++         obj/vidhrdw/kungfum.o obj/drivers/kungfum.o \
++         obj/machine/qix.o obj/vidhrdw/qix.o obj/drivers/qix.o \
++         obj/machine/williams.o obj/vidhrdw/williams.o obj/drivers/williams.o \
++         obj/machine/ticket.o \
++         obj/sndhrdw/starforc.o obj/vidhrdw/starforc.o obj/drivers/starforc.o \
++         obj/vidhrdw/naughtyb.o obj/drivers/naughtyb.o \
++         obj/machine/mystston.o obj/vidhrdw/mystston.o obj/drivers/mystston.o \
++         obj/vidhrdw/matmania.o obj/drivers/matmania.o \
++         obj/vidhrdw/tutankhm.o obj/drivers/tutankhm.o \
++         obj/drivers/junofrst.o \
++         obj/machine/spacefb.o obj/vidhrdw/spacefb.o obj/sndhrdw/spacefb.o obj/drivers/spacefb.o \
++         obj/machine/mappy.o obj/vidhrdw/mappy.o obj/drivers/mappy.o \
++         obj/vidhrdw/ccastles.o obj/drivers/ccastles.o \
++         obj/vidhrdw/yiear.o obj/drivers/yiear.o \
++         obj/machine/digdug.o obj/vidhrdw/digdug.o obj/drivers/digdug.o \
++         obj/machine/asteroid.o obj/sndhrdw/asteroid.o \
++	 obj/machine/atari_vg.o obj/drivers/asteroid.o \
++         obj/drivers/bwidow.o \
++         obj/sndhrdw/bzone.o  obj/drivers/bzone.o \
++         obj/sndhrdw/redbaron.o \
++         obj/drivers/tempest.o \
++         obj/machine/starwars.o obj/machine/swmathbx.o obj/drivers/starwars.o obj/sndhrdw/starwars.o \
++         obj/machine/mhavoc.o obj/drivers/mhavoc.o \
++         obj/machine/quantum.o obj/drivers/quantum.o \
++         obj/machine/missile.o obj/vidhrdw/missile.o obj/drivers/missile.o \
++         obj/machine/bublbobl.o obj/vidhrdw/bublbobl.o obj/drivers/bublbobl.o \
++         obj/machine/bosco.o obj/sndhrdw/bosco.o obj/vidhrdw/bosco.o obj/drivers/bosco.o \
++         obj/vidhrdw/yard.o obj/drivers/yard.o \
++         obj/vidhrdw/blueprnt.o obj/drivers/blueprnt.o \
++         obj/vidhrdw/sega.o obj/sndhrdw/sega.o obj/machine/sega.o obj/drivers/sega.o \
++         obj/vidhrdw/segar.o obj/sndhrdw/segar.o obj/machine/segar.o obj/drivers/segar.o \
++         obj/sndhrdw/monsterb.o \
++         obj/drivers/omegrace.o \
++         obj/vidhrdw/xevious.o obj/machine/xevious.o obj/drivers/xevious.o \
++         obj/vidhrdw/bankp.o obj/drivers/bankp.o \
++         obj/vidhrdw/sbasketb.o obj/drivers/sbasketb.o \
++         obj/machine/mcr.o \
++         obj/vidhrdw/mcr1.o obj/vidhrdw/mcr2.o obj/vidhrdw/mcr3.o \
++         obj/drivers/mcr1.o obj/drivers/mcr2.o obj/drivers/mcr3.o \
++         obj/machine/mcr68.o obj/vidhrdw/mcr68.o obj/drivers/mcr68.o \
++         obj/machine/espial.o obj/vidhrdw/espial.o obj/drivers/espial.o \
++         obj/machine/tp84.o obj/vidhrdw/tp84.o obj/drivers/tp84.o \
++         obj/vidhrdw/mikie.o obj/drivers/mikie.o \
++         obj/vidhrdw/ironhors.o obj/drivers/ironhors.o \
++         obj/vidhrdw/shaolins.o obj/drivers/shaolins.o \
++         obj/machine/rastan.o obj/vidhrdw/rastan.o obj/sndhrdw/rastan.o obj/drivers/rastan.o \
++         obj/machine/cloak.o obj/vidhrdw/cloak.o obj/drivers/cloak.o \
++         obj/machine/lwings.o obj/vidhrdw/lwings.o obj/drivers/lwings.o \
++         obj/machine/berzerk.o obj/vidhrdw/berzerk.o obj/sndhrdw/berzerk.o obj/drivers/berzerk.o \
++         obj/machine/capbowl.o obj/vidhrdw/capbowl.o obj/vidhrdw/tms34061.o obj/drivers/capbowl.o \
++         obj/vidhrdw/1943.o obj/drivers/1943.o \
++         obj/vidhrdw/gunsmoke.o obj/drivers/gunsmoke.o \
++         obj/vidhrdw/blktiger.o obj/drivers/blktiger.o \
++         obj/vidhrdw/tecmo.o obj/drivers/tecmo.o \
++         obj/vidhrdw/gaiden.o obj/drivers/gaiden.o \
++         obj/vidhrdw/sidearms.o obj/drivers/sidearms.o \
++         obj/vidhrdw/srumbler.o obj/drivers/srumbler.o \
++         obj/vidhrdw/champbas.o obj/drivers/champbas.o \
++         obj/vidhrdw/pbaction.o obj/drivers/pbaction.o \
++         obj/vidhrdw/exerion.o obj/drivers/exerion.o \
++         obj/machine/arkanoid.o obj/vidhrdw/arkanoid.o obj/drivers/arkanoid.o \
++         obj/machine/slapstic.o \
++         obj/machine/gauntlet.o obj/vidhrdw/gauntlet.o obj/drivers/gauntlet.o \
++         obj/vidhrdw/klax.o obj/drivers/klax.o \
++         obj/machine/blstroid.o obj/vidhrdw/blstroid.o obj/drivers/blstroid.o \
++         obj/vidhrdw/eprom.o obj/drivers/eprom.o \
++         obj/vidhrdw/xybots.o obj/drivers/xybots.o \
++         obj/machine/atarisy1.o obj/vidhrdw/atarisy1.o obj/drivers/atarisy1.o \
++         obj/machine/atarisy2.o obj/vidhrdw/atarisy2.o obj/drivers/atarisy2.o \
++	 obj/machine/atarigen.o \
++         obj/machine/foodf.o obj/vidhrdw/foodf.o obj/drivers/foodf.o \
++         obj/vidhrdw/circus.o obj/drivers/circus.o \
++         obj/machine/konami.o obj/vidhrdw/trackfld.o obj/sndhrdw/trackfld.o obj/drivers/trackfld.o \
++         obj/vidhrdw/hyperspt.o obj/drivers/hyperspt.o \
++         obj/vidhrdw/rocnrope.o obj/drivers/rocnrope.o \
++         obj/vidhrdw/circusc.o obj/drivers/circusc.o \
++         obj/vidhrdw/pingpong.o obj/drivers/pingpong.o \
++         obj/vidhrdw/astrof.o obj/drivers/astrof.o \
++         obj/machine/sprint2.o obj/vidhrdw/sprint2.o obj/drivers/sprint2.o \
++         obj/vidhrdw/punchout.o obj/sndhrdw/punchout.o obj/drivers/punchout.o \
++         obj/vidhrdw/firetrap.o obj/drivers/firetrap.o \
++         obj/vidhrdw/jack.o obj/drivers/jack.o \
++         obj/machine/vastar.o obj/vidhrdw/vastar.o obj/drivers/vastar.o \
++         obj/vidhrdw/brkthru.o obj/drivers/brkthru.o \
++         obj/vidhrdw/citycon.o obj/drivers/citycon.o \
++         obj/machine/starfire.o obj/vidhrdw/starfire.o obj/drivers/starfire.o \
++         obj/machine/sbrkout.o obj/vidhrdw/sbrkout.o obj/drivers/sbrkout.o \
++         obj/vidhrdw/superqix.o obj/drivers/superqix.o \
++         obj/machine/jedi.o obj/vidhrdw/jedi.o obj/sndhrdw/jedi.o obj/drivers/jedi.o \
++         obj/vidhrdw/gameplan.o obj/drivers/gameplan.o \
++         obj/machine/dominos.o obj/vidhrdw/dominos.o obj/drivers/dominos.o \
++         obj/vidhrdw/tankbatt.o obj/drivers/tankbatt.o \
++         obj/machine/rainbow.o obj/drivers/rainbow.o \
++         obj/vidhrdw/nitedrvr.o obj/machine/nitedrvr.o obj/drivers/nitedrvr.o \
++         obj/vidhrdw/lrunner.o obj/drivers/lrunner.o \
++         obj/vidhrdw/liberatr.o obj/machine/liberatr.o obj/drivers/liberatr.o \
++         obj/vidhrdw/wiz.o obj/drivers/wiz.o \
++         obj/vidhrdw/blockout.o obj/drivers/blockout.o \
++         obj/vidhrdw/fastfred.o obj/drivers/fastfred.o \
++         obj/vidhrdw/thepit.o obj/drivers/thepit.o \
++         obj/vidhrdw/bsktball.o obj/machine/bsktball.o obj/drivers/bsktball.o \
++         obj/vidhrdw/copsnrob.o obj/machine/copsnrob.o obj/drivers/copsnrob.o \
++         obj/vidhrdw/toki.o obj/drivers/toki.o \
++         obj/vidhrdw/snowbros.o obj/drivers/snowbros.o \
++         obj/machine/cps1.o obj/vidhrdw/cps1.o obj/drivers/cps1.o \
++         obj/vidhrdw/gundealr.o obj/drivers/gundealr.o \
++         obj/machine/tnzs.o obj/vidhrdw/tnzs.o obj/drivers/tnzs.o \
++         obj/vidhrdw/route16.o obj/drivers/route16.o \
++         obj/vidhrdw/wc90.o obj/drivers/wc90.o \
++         obj/vidhrdw/wc90b.o obj/drivers/wc90b.o \
++         obj/drivers/twincobr.o \
++         obj/machine/dec0.o obj/vidhrdw/dec0.o obj/drivers/dec0.o \
++         obj/vidhrdw/dec8.o obj/drivers/dec8.o \
++         obj/vidhrdw/karnov.o obj/drivers/karnov.o \
++         obj/machine/toobin.o obj/vidhrdw/toobin.o obj/drivers/toobin.o \
++         obj/vidhrdw/tigeroad.o obj/drivers/tigeroad.o \
++         obj/vidhrdw/blockade.o obj/drivers/blockade.o \
++         obj/machine/leprechn.o obj/vidhrdw/leprechn.o obj/drivers/leprechn.o \
++         obj/vidhrdw/atetris.o obj/drivers/atetris.o \
++         obj/vidhrdw/dday.o obj/sndhrdw/dday.o obj/drivers/dday.o \
++         obj/vidhrdw/system8.o obj/drivers/system8.o \
++         obj/vidhrdw/pacland.o obj/drivers/pacland.o \
++         obj/vidhrdw/tmnt.o obj/drivers/tmnt.o \
++         obj/vidhrdw/sidepckt.o obj/drivers/sidepckt.o \
++         obj/vidhrdw/xain.o obj/drivers/xain.o \
++         obj/machine/slapfght.o obj/vidhrdw/slapfght.o obj/drivers/slapfght.o \
++         obj/vidhrdw/hexa.o obj/drivers/hexa.o \
++         obj/vidhrdw/shootout.o obj/drivers/shootout.o \
++         obj/vidhrdw/ddragon.o obj/drivers/ddragon.o \
++         obj/vidhrdw/aeroboto.o obj/drivers/aeroboto.o \
++         obj/machine/system16.o obj/vidhrdw/shinobi.o \
++         obj/drivers/shinobi.o obj/drivers/altbeast.o obj/drivers/goldnaxe.o \
++         obj/vidhrdw/redalert.o obj/sndhrdw/redalert.o obj/drivers/redalert.o \
++         obj/machine/irobot.o obj/vidhrdw/irobot.o obj/drivers/irobot.o \
++         obj/vidhrdw/crbaloon.o obj/drivers/crbaloon.o \
++         obj/vidhrdw/zaccaria.o obj/drivers/zaccaria.o \
++         obj/vidhrdw/ssi.o obj/drivers/ssi.o \
++         obj/vidhrdw/nemesis.o obj/drivers/nemesis.o \
++         obj/vidhrdw/cosmica.o obj/drivers/cosmica.o \
++         obj/machine/spiders.o obj/vidhrdw/crtc6845.o obj/vidhrdw/spiders.o obj/drivers/spiders.o \
++         obj/vidhrdw/lastduel.o obj/drivers/lastduel.o \
++         obj/machine/avalnche.o obj/vidhrdw/avalnche.o obj/drivers/avalnche.o \
++         obj/machine/gladiatr.o obj/vidhrdw/gladiatr.o obj/drivers/gladiatr.o \
++         obj/drivers/lazercmd.o obj/vidhrdw/lazercmd.o \
++         obj/drivers/meadows.o obj/sndhrdw/meadows.o obj/vidhrdw/meadows.o \
++         obj/machine/jackal.o obj/vidhrdw/jackal.o obj/drivers/jackal.o \
++         obj/vidhrdw/contra.o obj/drivers/contra.o \
++         obj/vidhrdw/solomon.o obj/drivers/solomon.o \
++         obj/vidhrdw/tehkanwc.o obj/drivers/tehkanwc.o \
++         obj/vidhrdw/vindictr.o obj/drivers/vindictr.o \
++         obj/machine/stactics.o obj/vidhrdw/stactics.o obj/drivers/stactics.o \
++         obj/vidhrdw/mainevt.o obj/drivers/mainevt.o \
++         obj/vidhrdw/darkseal.o obj/drivers/darkseal.o \
++         obj/vidhrdw/goldstar.o obj/drivers/goldstar.o \
++         obj/vidhrdw/ninjakd2.o obj/drivers/ninjakd2.o \
++         obj/Z80/Z80.o obj/M6502/M6502.o obj/I86/I86.o obj/I8039/I8039.o obj/I8085/I8085.o \
++	 obj/M6809/M6809.o obj/M6805/M6805.o \
++         obj/S2650/S2650.o obj/T11/t11.o \
++         obj/M6808/M6808.o obj/M6808/6808dasm.o \
++	 obj/M68000/opcode0.o obj/M68000/opcode1.o obj/M68000/opcode2.o obj/M68000/opcode3.o \
++	 obj/M68000/opcode4.o obj/M68000/opcode5.o obj/M68000/opcode6.o obj/M68000/opcode7.o \
++	 obj/M68000/opcode8.o obj/M68000/opcode9.o obj/M68000/opcodeb.o obj/M68000/opcodec.o \
++	 obj/M68000/opcoded.o obj/M68000/opcodee.o obj/M68000/mc68kmem.o obj/M68000/cpufunc.o \
++         obj/mamedbg.o obj/asg.o obj/M6502/6502dasm.o obj/I8085/8085dasm.o \
++         obj/M6809/6809dasm.o obj/M6805/6805dasm.o  obj/I8039/8039dasm.o \
++         obj/S2650/2650dasm.o obj/T11/t11dasm.o obj/M68000/M68kdasm.o
++
++OBJS = $(OBJMAME) $(OBJOSDEP)
++
++# not sure why, but was in original xmame makefile long time ago...
++VPATH = src src/Z80 src/M6502 src/I86 src/M6809 src/M68000 src/unix
++
++all: objdirs osdepend xmame.$(ARCH)
++
++OBJDIRS= obj.$(ARCH) obj.$(ARCH)/msdos obj.$(ARCH)/unix obj.$(ARCH)/T11 \
++	 obj.$(ARCH)/I86 obj.$(ARCH)/I8039 obj.$(ARCH)/I8085 obj.$(ARCH)/Z80 \
++ 	 obj.$(ARCH)/M6502 obj.$(ARCH)/M6805 obj.$(ARCH)/M6808 \
++	 obj.$(ARCH)/M6809 obj.$(ARCH)/M68000 obj.$(ARCH)/S2650 \
++	 obj.$(ARCH)/drivers obj.$(ARCH)/machine \
++	 obj.$(ARCH)/vidhrdw obj.$(ARCH)/sndhrdw
++
++$(OBJDIRS):
++	-mkdir $@
++
++objdirs: $(OBJDIRS) objlnk
++
++objlnk:
++	-rm -fR obj
++	 ln -s obj.$(ARCH) obj
++
++xmame.$(ARCH):	$(OBJS)
++	$(LD) -g3 -o xmame.$(ARCH) $(OBJS) $(JSLIB) $(XPMLIB) $(LIBS.$(ARCH))
++
++xlistdev: xlistdev.c
++	$(CC) $(X11INC) xlistdev.c -o xlistdev $(JSLIB) $(LIBS.$(ARCH))
++
++# obj/unix/osdepend.a:
++
++osdepend:
++	 ( \
++	 cd src/unix; \
++	  $(MAKE) CC="$(CC)" ARCH="$(ARCH)" DEFS="$(CONF) $(DEFS.$(ARCH))" CFLAGS="$(CFLAGS)" \
++	 )
++
++sndserver.$(ARCH): obj/unix/sndserver.o obj/unix/osdepend.a 
++	$(LD) -g3 -o  sndserver.$(ARCH) obj/unix/sndserver.o $(LIBS.$(ARCH))
++
++obj/%.o: src/%.c
++	$(CC) $(DEFS.$(ARCH)) $(CFLAGS) -o $@ -c $<
++
++sndtest: sndtest.c
++	gcc -o sndtest sndtest.c
++
++# dependencies
++
++obj/sndhrdw/cclimber.o:	src/sndhrdw/psg.c src/sndhrdw/psg.h
++
++obj/Z80/Z80.o:		src/Z80/Z80.c src/Z80/Z80.h src/Z80/Z80Codes.h \
++	        	src/Z80/Z80IO.h src/Z80/Z80DAA.h src/Z80/Z80CDx86.h
++obj/M6502/M6502.o:	src/M6502/M6502.c src/M6502/M6502.h \
++		        src/M6502/Tables.h src/M6502/Codes.h
++obj/M6809/M6809.o:	src/M6809/M6809.c src/M6809/M6809.h
++obj/I86/I86.o:		src/I86/I86.c src/I86/I86.h \
++			src/I86/instr.h
++
++install: install-bin install-man
++	@echo X-Mame $(VERSION) for $(ARCH) installation completed
++
++install-bin: $(INST.$(ARCH)) xmame.$(ARCH)
++
++install-man:
++	@echo installing manual pages under $(MANDIR) ...
++	$(INSTALL) doc/xmame.man $(MANDIR)/xmame.6
++
++doinstall:
++	@echo installing binaries under $(DESTDIR)...
++	$(INSTALL) xmame.$(ARCH) $(DESTDIR)/xmame
++
++# Every SVGALIB-based software must be run setuid. Beware security !!!
++doinstallsvgalib:
++	@echo installing binaries under $(DESTDIR)...
++	$(INSTALL) xmame.$(ARCH) $(DESTDIR)/mame
++	chmod 4755 $(DESTDIR)/mame	
++
++#clean now depends on objdirs, cause otherwise it just might rm the wrong ARCH
++clean: objdirs
++	rm -f $(OBJS) xmame.$(ARCH) xlistdev sndserver.* sndtest
++	( cd src/unix; $(MAKE) ARCH="$(ARCH)" clean; )
++
++bindist: 
++	tar zcvf $(DISTDIR)/xmame.$(ARCH)_bin.tgz xmame.$(ARCH) doc
++
++srcdist: pristine
++	( cd ..; tar zcvf $(DISTDIR)/xmame-$(VERSION)_src.tgz xmame-$(VERSION) )
++
++pristine:
++	rm -rf *.o */*.o */*/*.o
++	rm -rf obj.*
++	rm -f xmame.* xlistdev sndserver.* Makefile
+diff -ruN xmame-esd/README.esd xmame-0.33b7.1/README.esd
+--- xmame-esd/README.esd	Thu Jan  1 01:00:00 1970
++++ xmame-0.33b7.1/README.esd	Sun Aug  2 21:08:39 1998
+@@ -0,0 +1,13 @@
++To get esound support in xmame you need:
++
++- enable USE_TIMER in line 207 of Makefile. 
++- uncomment line 215 in Makefile (S_ESD)
++- uncomment and set the right path lines 162 and 163 (ESDINC and ESDLIB)
++
++Furthermore you will also need to set the timerfreq setting in xmamerc to
++a apropriate value, 100 did the trick for me.
++
++
++- Blaze (goofy@neptun.hib.no)
++
++With thanks to Chutt for pointing out some important stuff!
+diff -ruN xmame-esd/README.esd~ xmame-0.33b7.1/README.esd~
+--- xmame-esd/README.esd~	Thu Jan  1 01:00:00 1970
++++ xmame-0.33b7.1/README.esd~	Sun Aug  2 21:06:00 1998
+@@ -0,0 +1,7 @@
++To get esound support in xmame you need to enable USE_TIMER in line 207 of
++the Makefile. You will also need to set the timerfreq setting in xmamerc to
++a apropriate value, 100 did the trick for me.
++
++Blaze (goofy@neptun.hib.no)
++
++With thanks to Chutt for pointing out some important stuff!
+diff -ruN xmame-esd/makefile.unix xmame-0.33b7.1/makefile.unix
+--- xmame-esd/makefile.unix	Fri Jul 24 16:41:16 1998
++++ xmame-0.33b7.1/makefile.unix	Sun Aug  2 21:03:45 1998
+@@ -123,8 +123,8 @@
+ # *** X-Mame uses the XPM library to make snapshots. If you want to, uncomment
+ # following section to support them ( you should have libxpm available :-) )
+ # COMMENT IT if your are compiling for Linux's SVGALIB arch
+-# XPM	= -DHAS_XPM
+-# XPMLIB	= -lXpm -L/usr/X11R6/lib
++#XPM	= -DHAS_XPM
++#XPMLIB	= -lXpm -L/usr/X11R6/lib
+  
+ # *** If you haven't  the MIT-Shared Memory X Extensions, comment the following:
+ # ( Test if available by mean of xdpyinfo command )
+@@ -157,6 +157,11 @@
+ # X11INC		= -I/usr/local/include/X11
+ # X11LIB		= -L/usr/local/lib
+ 
++# *** If you want esound support you need to tell where to find lib and 
++# include files. Next two lines should be very common locations.
++ESDINC		= -I/usr/local/include
++ESDLIB		= -L/usr/local/lib -lesd
++
+ # These options defines default location for roms and configuration files
+ # also, your default X display is defined here
+ #
+@@ -196,17 +201,21 @@
+ # *** If your system supports query audio buffer size (like IRIX or Linux )
+ # you might decide to use these feature. Otherwise, you should use a 
+ # timer based audio code and ajust in src/unix/sound.h AUDIO_TIMER_FREQ item
++# Note: esound support needs timer ON to output sound right
+ #
+-S_TIM = -DDONTUSE_TIMER
+-# S_TIM = -DUSE_TIMER
++# S_TIM = -DDONTUSE_TIMER
++S_TIM = -DUSE_TIMER
+ 
+ # *** When using timer, you should provide the frequency to generate audio sample
+ # frames in your system. See readme.unix notes about these item
+ #
+ S_AFR =	-DAUDIO_TIMER_FREQ=50
+ 
++# *** For EsounD support uncomment the next line. Linux ONLY for the moment! 
++S_ESD = -DUSE_EsounD
++
+ # Dont modify next line !!
+-SOUND_OPTS = $(S_LIN) $(S_TIM) $(S_AFR)
++SOUND_OPTS = $(S_LIN) $(S_TIM) $(S_AFR) $(S_ESD)
+ 
+ ##############################################################################
+ # *** architecture.
+@@ -272,11 +281,11 @@
+ #####################
+ # to debug you'll have to exclude -DX86_ASM
+ DEFS.linux   = -DLSB_FIRST -DUNIX -Dlinux -DX86_ASM -DSIGNED_SAMPLES
+-LIBS.linux   = $(X11LIB) -lX11 -lXext -lm 
++LIBS.linux   = $(X11LIB) $(ESDLIB) -lX11 -lXext -lm
+ # CFLAGS.linux = $(X11INC) -m486 -fstrength-reduce -funroll-loops \
+ #   		-fomit-frame-pointer -Wall
+ # for debbuging disable all opts...
+-CFLAGS.linux = $(X11INC) -m486 -Wall -g
++CFLAGS.linux = $(X11INC) $(ESDINC) -m486 -Wall -g 
+ INST.linux   = doinstall
+ 
+ # Linux + Svgalib
+diff -ruN xmame-esd/src/unix/linux.c xmame-0.33b7.1/src/unix/linux.c
+--- xmame-esd/src/unix/linux.c	Fri Jun  5 13:00:43 1998
++++ xmame-0.33b7.1/src/unix/linux.c	Sun Aug  2 21:03:02 1998
+@@ -1,3 +1,4 @@
++
+ /*
+  * Linux Dependent system file 
+ */
+@@ -6,6 +7,15 @@
+ 
+ #define __LINUX_C
+ 
++#ifdef USE_EsounD
++#include <sys/types.h>
++#include <sys/stat.h>
++#include <sys/ioctl.h>
++#include <fcntl.h>
++#include <stdio.h>
++#include <esd.h>
++#endif
++
+ #include <sys/time.h>
+ #include <unistd.h>
+ #include <math.h>
+@@ -22,6 +32,12 @@
+ #define USE_AUDIO 0
+ #define USE_DSP   1
+ 
++#ifdef USE_EsounD
++#define USE_ESD   2
++#endif
++
++int esd_write (char *buf,int bytes);
++
+ static int linux_sound_device;
+ /*
+  * Put anything here you need to do when the program is started.
+@@ -60,10 +76,17 @@
+     	if (play_sound) {
+ 	    int linux_sound_init(void);
+ 	    int linux_audio_init(void);
++#ifdef USE_EsounD
++            int linux_esd_init(void);
++#endif
+ 	    linux_sound_device=USE_DSP;
+ 	    result = -1;
+ 	    if ( !strcmp(audiodevice,"/dev/dsp") ) result=linux_sound_init();
+ 	    if ( !strcmp(audiodevice,"/dev/audio") ) result=linux_audio_init();
++#ifdef USE_EsounD
++	    if ( !strcmp(audiodevice,"esound") ) result=linux_esd_init();
++#endif
++
+ 	    if(result<0) fprintf(stderr,"Sound device init failed. Sound disabled\n");	
+ 	}
+ 	return (TRUE);
+@@ -152,6 +175,39 @@
+ 	       audiodevice, options.samplerate);
+        return 0;   
+ }
++
++#ifdef USE_EsounD
++int linux_esd_init(void) {
++   esd_format_t flags = ESD_STREAM | ESD_PLAY;
++ 
++       fprintf(stderr,"EsounD initialization... \n");
++
++   flags = (ESD_MONO | ESD_BITS8 | ESD_STREAM | ESD_PLAY);
++
++   audio_fd = esd_play_stream(flags, options.samplerate, NULL, NULL);
++   if (audio_fd <= 0) {
++      fprintf(stderr,"EsounD wasn't running, attempting to exec it.\n");
++      if (!fork()) {  /* child */
++         if (execl("/bin/sh", "/bin/sh", "-c","esd", NULL) == -1) 
++            fprintf(stderr,"Couldn't execute 'esd'... please get and install EsounD..\n");
++         exit(0);
++      }
++      sleep(2);
++      audio_fd = esd_play_stream(flags, options.samplerate, NULL, NULL);
++      if (audio_fd <= 0) {
++         fprintf(stderr,"EsounD could not be started properly.. help, help, i'll just fallback instead\n");
++         audio_fd = esd_play_stream_fallback(flags, options.samplerate, NULL, NULL);
++	 if (audio_fd <= 0) {
++            fprintf(stderr,"Couldn't even open audio normally.. Kill whatever's taking over /dev/dsp and\nlet me use it..\n");
++	    exit(-1);
++	 }
++      }
++   }
++       linux_sound_device=USE_ESD;
++       fprintf(stderr,"EsounD socket opened and set to 8bit mono %dHz\n", options.samplerate);
++       return 0;
++}
++#endif
+   
+ /*
+  * Cleanup routines to be executed when the program is terminated.
+@@ -195,7 +251,12 @@
+            if (run_n < 0 || run_n > AUDIO_BUFF_SIZE) run_n = 0;
+            tv1 = tv2;
+            return(run_n);
+-	   break;
++	   break; 
++#ifdef USE_EsounD
++        case USE_ESD:
++	   return 257 /* FIXME */;
++	   break; 
++#endif
+        }
+        return 0; /* should not occurs */
+ }
+@@ -218,7 +279,12 @@
+          p++;
+        }
+        return write(audio_fd,buf, bufsize);
+-       break;
++       break; 
++#ifdef USE_EsounD
++    case USE_ESD:
++       return write(audio_fd, buf, bufsize);
++       break; 
++#endif
+    }
+    return 0; /* should never occur */
+ }
diff --git a/src/unix/contrib/patches/readme b/src/unix/contrib/patches/readme
new file mode 100644
index 0000000..c702363
--- /dev/null
+++ b/src/unix/contrib/patches/readme
@@ -0,0 +1,45 @@
+Contents of directory contrib/patches
+==========================================
+
+1)      Name:		alsa.c
+	Author:		An anonymous programmer at wwtk@mail.com
+	Description:   	Alsa sound support
+	Usage:		Copy over src/unix/sound-drivers/oss.c and
+			compile xmame as documented.
+	Notes:		Currently you can either use this, or the oss
+			driver not both. One day in the near future
+			this will be merged in and you can use both.
+
+2)	Name:		boundary-check-patch
+	Author:		Hans de Goede <hans@highrise.nl>
+	Description:	A patch for an older xmame version which adds
+			certain bufferoverflow checks, this could help
+			to get some buggy games to run.
+	Notes:		This patch is probably obsolete.
+
+3)	Name:		configure.in
+	Author:		??
+	Description:	A first attempt at an autoconfigure script for xmame
+	Notes:		This is obsolote, there is currently someone working
+			on a much newer version which should eventually make
+			it into xmame. If your interested please check the
+			xmame mailinglist, for more info on the list see
+			doc/readme.unix
+
+4)	Name:		esound.diff
+	Author:		??
+	Description:	A patch to use esound for sound output
+	Notes:		This is very old patch, and currently doesn't
+			apply any more.
+
+5)	Name:		readme
+	Author:		Hans de Goede <hans@highrise.nl>
+	Description:	This file
+
+6)	Name:		word-align-patch
+	Description:	In the past the cpu-cores of mame used todo some
+			unaligned word accesses making risc cpu's very
+			unhappy. This patch used to correct this, but the
+			cpu-cores have been fixed now. It might be worth
+			trying this patch if you experience problems on a 
+			risc machine (sparc/alpha etc)
diff --git a/src/unix/contrib/patches/word-align-patch b/src/unix/contrib/patches/word-align-patch
new file mode 100644
index 0000000..5fffe63
--- /dev/null
+++ b/src/unix/contrib/patches/word-align-patch
@@ -0,0 +1,91 @@
+diff -ur mame-0.35.orig.fixed/src/memory.c xmame-0.35.4/src/memory.c
+--- mame-0.35.orig.fixed/src/memory.c	Sat Jul 10 13:49:25 1999
++++ xmame-0.35.4/src/memory.c	Sat Jul 10 14:33:20 1999
+@@ -130,6 +130,58 @@
+ 
+ ***************************************************************************/
+ 
++#ifdef ALIGN_SHORTS
++/*
++ * Previously READ_WORD and WRITE_WORDS were implemented as macros.
++ * However they assumed that unaligned loads are legal, which is not
++ * true on most non-x86 hardware.  Even on a Pentium, unaligned loads are
++ * slower than aligned loads.
++ */
++
++#ifdef LSB_FIRST
++#ifndef __GNUC__
++/* don't include it for gcc, gcc has a way to tell the compiler
++   to generate a unaligned access sequence (see memory.h) */
++
++int
++READ_WORD(void *dst)
++{
++  unsigned char *p = (unsigned char *) dst;
++  return (p[1] << 8) | p[0];
++}
++
++int
++WRITE_WORD(void *dst, int val)
++
++{
++  unsigned char *p = (unsigned char *) dst;
++  p[0] = val & 0xff;
++  p[1] = (val >> 8) & 0xff;
++  return val;
++}
++
++#endif /* #ifndef __GNUC__ */
++#else
++
++int
++READ_WORD(void *dst)
++{
++  unsigned char *p = (unsigned char *) dst;
++  return (p[0] << 8) | p[1];
++}
++
++int
++WRITE_WORD(void *dst, int val)
++
++{
++  unsigned char *p = (unsigned char *) dst;
++  p[1] = val & 0xff;
++  p[0] = (val >> 8) & 0xff;
++  return val;
++}
++#endif
++#endif
++
+ int mrh_ram(int address){return RAM[address];}
+ int mrh_bank1(int address){return cpu_bankbase[1][address];}
+ int mrh_bank2(int address){return cpu_bankbase[2][address];}
+diff -ur mame-0.35.orig.fixed/src/memory.h xmame-0.35.4/src/memory.h
+--- mame-0.35.orig.fixed/src/memory.h	Sat Jul 10 13:49:46 1999
++++ xmame-0.35.4/src/memory.h	Sat Jul 10 14:33:20 1999
+@@ -211,8 +211,25 @@
+ 
+ /* ----- 16-bit memory access macros ----- */
+ 
++#ifdef ALIGN_SHORTS
++#if defined(LSB_FIRST) && defined(__GNUC__)
++
++/* special way for gcc to tell it to create unaliged access sequence */
++typedef struct {
++  unsigned short __x __attribute__((packed));
++} packed_word;
++#define READ_WORD(a)    (((packed_word *)(a))->__x)
++#define WRITE_WORD(a,d) ((((packed_word *)(a))->__x) = (d))
++
++#else
++/* Use these to avoid alignment problems on non-x86 hardware. */
++extern int READ_WORD(void *dst);
++extern int WRITE_WORD(void *dst, int d);
++#endif
++#else
+ #define READ_WORD(a)          (*(unsigned short *)(a))
+ #define WRITE_WORD(a,d)       (*(unsigned short *)(a) = (d))
++#endif
+ 
+ #define COMBINE_WORD(w,d)     (((w) & ((d) >> 16)) | ((d) & 0xffff))
+ #define COMBINE_WORD_MEM(a,d) (WRITE_WORD ((a), (READ_WORD (a) & ((d) >> 16)) | (d)))
diff --git a/src/unix/contrib/porting/fix-comments.c b/src/unix/contrib/porting/fix-comments.c
new file mode 100644
index 0000000..e1b473d
--- /dev/null
+++ b/src/unix/contrib/porting/fix-comments.c
@@ -0,0 +1,249 @@
+#include <stdio.h>
+#include <string.h>
+#include <errno.h>
+#include <ctype.h>
+
+#if 0
+#define DEBUG_OUT(s)    printf(s)
+#define DEBUG_OUT1(s,a) printf(s,a)
+#else
+#define DEBUG_OUT(s)
+#define DEBUG_OUT1(s,a)
+#endif
+
+int main (int argc, char **argv)
+{
+   int n, i, len;
+   int status, line;
+   FILE *fpin, *fpout;
+   char input_filename[BUFSIZ], output_filename[BUFSIZ];
+   char buffer[BUFSIZ];
+
+   if (argc < 2)
+   {
+      printf ("Usage: fix [sourcefilenames]\n");
+      return 1;
+   }
+
+   /* multiple argument */
+   for (n = 1; n < argc; n++)
+   {
+      strcpy (output_filename, argv[n]);  /* filename to write */
+      strcpy (input_filename, argv[n]);
+
+      if ((fpin = fopen (input_filename, "r")) == NULL)
+      {
+         printf ("Error opening input file %s\n", input_filename);
+         printf ("Continuing with next file\n");
+         continue;
+      }
+
+      strcat (input_filename, ".orig");  /* filename to backup */
+
+      if (rename (output_filename, input_filename) == -1)
+      {
+         printf ("Error renaming %s to %s\n", output_filename, input_filename);
+         printf ("Continuing with next file\n");
+         continue;
+      }
+
+      if ((fpout = fopen (output_filename, "w")) == NULL)
+      {
+         printf ("Error opening output file %s\n", output_filename);
+         printf ("Continuing with next file\n");
+         continue;
+      }
+
+      status = 0;
+      line = 1;
+      
+      DEBUG_OUT1("Processing File: %s\n", output_filename);
+
+      while (fgets (buffer, BUFSIZ, fpin) != NULL)
+      {
+         DEBUG_OUT1("  Line: %d\n", line);
+         len = strlen (buffer);
+         /* strip newline */
+         if (buffer[len - 1] == '\n')
+            len--;
+         /* if dos format and len > 0, strip cariage return(s) and EOF */
+         while (len && (buffer[len - 1] == 0x0D || buffer[len - 1] == 0x1A))
+               len--;
+
+         /* search and lowercase #include's */
+         if (strncmp (buffer, "#include", 8) == 0)
+         {
+            DEBUG_OUT("Lowercasing #include\n");
+            for (i = 8; i < len && buffer[i] != '<' && buffer[i] != '\"'; i++)
+            {
+            }
+            for (i++; i < len && buffer[i] != '>' && buffer[i] != '\"'; i++)
+               if (buffer[i] == '\\')
+                  buffer[i] = '/';
+               else
+                  buffer[i] = tolower (buffer[i]);
+
+            if (i >= len)
+            {
+               fprintf (stderr, "File: %s, Malformed #include at line %d, aborting\n",
+                        output_filename, line);
+               exit (1);
+            }
+         }
+
+         /* search and transform // comments to /* */
+         for (i = 0; i < len; i++)
+         {
+            switch (status)
+            {
+
+               case 0:         /* nothing found sofar */
+                  switch (buffer[i])
+                  {
+                     case '/':
+                        DEBUG_OUT1("Found a / at: %d\n", i+1);
+                        status = 1;
+                        break;
+                     case '\"':
+                     case '\'':
+                     {
+                        int escapes=0;
+                        /* to avoid constructs like "\\" and or "\\\"" we have
+                           to count the number of backslashes */
+                        while (i && buffer[i-1]=='\\')
+                        {
+                           escapes++;
+                           i--;
+                        }
+                        /* restore i */
+                        i += escapes;
+                        /* if the number of \ is odd the " or ' is escaped ;) */
+                        if (escapes&0x01) break;
+                        DEBUG_OUT1("Found an unescaped \" or ' at: %d, entering string\n", i+1);
+                        if (buffer[i] == '\"')
+                           status = 7;
+                        else
+                           status = 8;
+                        break;
+                     }
+                  }
+                  break;
+               case 1:         /* found a / */
+                  switch (buffer[i])
+                  {
+                     case '*':
+                        DEBUG_OUT1("Found a * at: %d, entering old style comment\n", i+1);
+                        status = 2;
+                        break;
+                     case '/': /* found cpp-style comment bah */
+                        DEBUG_OUT1("Found a / at: %d, entering cpp style comment\n", i+1);
+                        buffer[i] = '*';
+                        buffer[len] = ' ';
+                        buffer[len + 1] = '*';
+                        buffer[len + 2] = '/';
+                        len += 3;
+                        status = 4;
+                        break;
+                     default:
+                        status = 0;
+                        break;
+                  }
+                  break;
+               case 2:         /* currently in old-style commented  text */
+                  if (buffer[i] == '*')
+                  {
+                     DEBUG_OUT1("Found a * at: %d\n", i+1);
+                     status = 3;
+                  }
+                  break;
+               case 3:         /* in old-style comment, found * */
+                  switch (buffer[i])
+                  {
+                     case '/':
+                        DEBUG_OUT1("Found a / at: %d, leaving old style comment\n", i);
+                        status = 0;
+                        break;
+                     case '*':
+                        DEBUG_OUT1("Found a * at: %d\n", i+1);
+                        break;
+                     default:
+                        status = 2;
+                  }
+                  break;
+               case 4:         /* in cpp-style comment */
+                  if (buffer[i] == '/')
+                  {
+                     DEBUG_OUT1("Found a / at: %d\n", i+1);
+                     status = 5;
+                  }
+                  if (buffer[i] == '*')
+                  {
+                     DEBUG_OUT1("Found a * at: %d\n", i+1);
+                     status = 6;
+                  }
+                  break;
+               case 5:         /* in cpp-style comment, found / */
+                  if (buffer[i] == '*')
+                  {
+                     DEBUG_OUT1("Found a * at: %d, removing old style comment start\n", i+1);
+                     buffer[i - 1] = ' ';
+                     buffer[i] = ' ';
+                     status = 4;
+                  }
+                  else if (buffer[i] != '/')
+                     status = 4;
+                  break;
+               case 6:         /* in cpp-style comment, found * */
+                  if (buffer[i] == '/' && i < (len - 1))
+                  {
+                     DEBUG_OUT1("Found a / at: %d, removing old style comment end\n", i+1);
+                     buffer[i - 1] = ' ';
+                     buffer[i] = ' ';
+                     status = 4;
+                  }
+                  else if (buffer[i] == '/' && i == (len - 1))
+                  {
+                     DEBUG_OUT1("Found a / at: %d, end of line\n", i+1);
+                     status = 0;
+                  }
+                  else if (buffer[i] != '*')
+                     status = 4;
+                  break;
+               case 7: /* in a string ("string") */
+               case 8: /* in a string ('string') */
+                  if ((status == 7 && buffer[i] == '\"') ||
+                      (status == 8 && buffer[i] == '\''))
+                  {
+                     int escapes=0;
+                     /* to avoid constructs like "\\" and or "\\\"" we have
+                        to count the number of backslashes */
+                     while (i && buffer[i-1]=='\\')
+                     {
+                        escapes++;
+                        i--;
+                     }
+                     /* restore i */
+                     i += escapes;
+                     /* if the number of \ is odd the " is escaped ;) */
+                     if (escapes&0x01) break;
+                     DEBUG_OUT1("Found an unescaped \" or ' at: %d, leaving string\n", i+1);
+                     status = 0;
+                  }
+                  break;
+            }
+         }
+         /* add newline */
+         buffer[len] = '\n';
+         buffer[len + 1] = 0;
+         fputs (buffer, fpout);
+         line++;
+      }
+      if(status)
+         printf("Warning, file ends abnormally: %s\n", output_filename);
+
+      fclose (fpout);
+      fclose (fpin);
+   }
+
+   return 0;
+}
diff --git a/src/unix/contrib/porting/porting.txt b/src/unix/contrib/porting/porting.txt
new file mode 100644
index 0000000..0e3d8c5
--- /dev/null
+++ b/src/unix/contrib/porting/porting.txt
@@ -0,0 +1,66 @@
+This file describes the process for getting new MAME and MESS releases working
+as xmame/xmess.  It is heavily adapted from documentation originally written by
+Hans de Goede.
+
+In Hans's words:
+
+"It is meant for those who want to have the latest and hottest version even
+before your xmame-maintainer finds the time to release it.  And to stop them
+from porting mistakes and thus reporting unjustified bugs ;)
+
+"I also wrote this so that I don't leave a big void if anything might happen
+to me, I know this is a bit doomsday thinking, but i have seen too many young
+people die around me not to take this precaution. ;(,
+Don't worry though I'm planning on staying around for a while."
+
+Lawrence Gold
+<gold@aros.net>
+
+Preparation 
+===========
+- Unpack the latest xmame release.  You'll need fix-comments.c and
+  prep-new-mame from its contrib dir.
+- Compile fix-comments.c: gcc -o fix-comments fix-comments.c
+- Put fix-comments and prep-new-mame somewhere in your PATH (e.g.,
+  /usr/local/bin).
+
+Porting MAME
+============
+- Make a new directory called xmame-newversionnumber.1 (e.g., xmame-0.37b14.1).
+- cd to this directory.
+- Run unzip -L on the DOS source .zip file.  The -L makes all of the filenames
+  lowercase.
+- Run prep-new-mame from within this directory, providing the path to a previous
+  xmame release's directory.  For example:
+
+	prep-new-mame ~/emulators/xmame-0.37b13.2
+
+  This will copy over src/unix and makefile.unix from the previous release;
+  create symlinks to some of the directories in there; rename/move doc files;
+  fix the line endings of source, text, and makefiles; and fix the comments in
+  source files.
+- Run diff -uBbr <old-xmame>/src/windows <new-xmame>/src/windows > win-changes 
+- Look in the win-changes file to see if anything on the OSD side has
+  changed--things like different return/call value, new functions altogether,
+  different prototypes, etc.
+- Make the necessary changes to <new-xmame>/src/unix/*
+- Do a diff -uBbr <old-xmame>/src/unix <new-xmame>/src/unix > unix-changes
+- Look in unix-changes and make sure you didn't break anything.
+- If you want to distribute this port, it's best to leave the defaults in
+  makefile.unix alone since they're pretty sane.  So copy makefile.unix to
+  Makefile.
+- Edit Makefile to suit your needs; if possible, force ANSI compliance on your
+  compiler to test the new version's compliance.
+- make -f makefile.bla 2> stderrlog (remember use GNU-make)
+- If something goes wrong, see stderrlog.  If everything goes well, see
+  stderrlog for non-ANSI warnings and fix them unless they are about unused
+  vars or trigraphs.
+- All done!  Enjoy your new xmame.  Now you just need to 'make clean' and bundle
+  it up in a tarball to distribute to friends.  If you followed this step by
+  step, you should have an xmame of the same quality as the official
+  distributions.
+
+Porting MESS
+============
+- See the prep-new-mess script.  I'll fill this section in later, when my
+  fingers aren't so tired.  ;-)
diff --git a/src/unix/contrib/porting/prep-new-mame b/src/unix/contrib/porting/prep-new-mame
new file mode 100755
index 0000000..374f0f3
--- /dev/null
+++ b/src/unix/contrib/porting/prep-new-mame
@@ -0,0 +1,73 @@
+#!/bin/bash
+# This is a script which automates some of the operations needed for porting DOS
+# MAME to Un*x.  Run it in a directory containing the latest MAME sources,
+# unzipped with the -L option to make all the filenames lower case.  Also, you
+# must specify a previous xmame release's source directory.  For example, here's
+# what I would do in my ~/emulators directory to port 0.37b14:
+#           mkdir xmame-0.37b14.1
+#           cd xmame-0.37b14.1
+#           unzip -L ../M37B14.ZIP
+#           prep-new-mame ../xmame-0.37b13.2
+#
+# Lawrence Gold <gold@aros.net>
+# Last modified on 11 April 2001.
+
+# Fix the line endings of the included text files, makefiles, and sources.
+if [ -x "`which d2u 2> /dev/null`" ]; then
+  d2u `find . -name "*.txt" -print` 2> /dev/null
+  d2u `find . -name "*.htm" -print` 2> /dev/null
+  d2u `find . -name "*.html" -print` 2> /dev/null
+  d2u `find . -name "*.mak" -print` 2> /dev/null
+  d2u `find . -name "*.ini" -print` 2> /dev/null
+  d2u `find . -name "*.pl" -print` 2> /dev/null
+  d2u `find . -name "*.[ch]" -print` 2> /dev/null
+else
+  echo "Unable to run d2u.  This may cause build problems on some platforms."
+fi
+
+
+# Change // comments to /* */ pairs.  Some C compilers don't like //.
+fix-comments `find . -name "*.[ch]" -print`
+
+# Copy over the src/unix folder from a previous release.
+if [ -d $1/src/unix ]; then
+  cp -R $1/src/unix src
+else
+  echo "Cannot find src/unix in old xmame directory, exiting..."
+  exit 1
+fi
+
+# Make some symlinks.
+ln -s src/unix/cab .
+ln -s src/unix/contrib .
+ln -s src/unix/doc .
+ln -s src/unix/install-sh .
+
+# Move the MAME text files to the doc directory.
+if [ -f whatsnew.txt ]; then
+  mv whatsnew.txt doc/mame/
+fi
+
+if [ -f whatsold.txt ]; then
+  mv whatsold.txt doc/mame/
+fi
+
+if [ -d docs ]; then
+  mv docs/* doc/mame/
+  rm -r docs
+fi
+
+# Rename the MAME makefile and fix its line endings.
+mv makefile makefile.mame
+d2u makefile.mame 2> /dev/null
+
+# Copy makefile.unix from the old xmame directory.
+cp $1/makefile.unix .
+
+# Copy README and todo from the old xmame directory.
+cp $1/README .
+cp $1/todo .
+
+# Clean up the files left over from d2u and fix-comments.
+rm -f `find . -name "*~" -print`
+rm -f `find . -name "*.orig" -print`
diff --git a/src/unix/contrib/porting/prep-new-mess b/src/unix/contrib/porting/prep-new-mess
new file mode 100755
index 0000000..6f5cfb6
--- /dev/null
+++ b/src/unix/contrib/porting/prep-new-mess
@@ -0,0 +1,73 @@
+#!/bin/bash
+# This is a script which automates some of the operations needed for porting DOS
+# MESS to UN*X.  Run it in a directory containing the latest xmame sources.  You
+# must specify a path to the latest MESS sources, which were unzipped with -L to
+# force filenames to lower case.  For example, here's what I would do in my
+# ~/emulators directory to port 0.37b14:
+#           mkdir mess-0.37b14
+#           cd mess-0.37b14
+#           unzip -L ../ms37b14s.zip
+#           cd ../xmame-0.37b14.1
+#           prep-new-mess ../mess-0.37b14
+#
+# Lawrence Gold <gold@aros.net>
+# Last modified on 11 April 2001.
+
+# Copy the MESS files over.
+if [ -d "$1" ]; then
+  cp -R $1/* .
+else
+  echo "Cannot find MESS source directory, exiting..."
+  exit 1
+fi
+
+# Fix the line endings of the included text files, makefiles, and sources.
+if [ -x "`which d2u 2> /dev/null`" ]; then
+  d2u `find . -name "*.txt" -print` 2> /dev/null
+  d2u `find . -name "*.htm" -print` 2> /dev/null
+  d2u `find . -name "*.html" -print` 2> /dev/null
+  d2u `find . -name "*.mak" -print` 2> /dev/null
+  d2u `find . -name "*.crc" -print` 2> /dev/null
+  d2u `find . -name "*.vc" -print` 2> /dev/null
+  d2u `find . -name "*.wce" -print` 2> /dev/null
+  d2u `find . -path './src/unix' -prune -o -name "*.[ch]" -print` 2> /dev/null
+  d2u makefile.mes 2> /dev/null
+  d2u makefile.vc 2> /dev/null
+  d2u sysinfo.dat 2> /dev/null
+else
+  echo "Unable to run d2u.  This may cause build problems on some platforms."
+fi
+
+# Change // comments to /* */ pairs.  Some C compilers don't like //.  We skip
+# the src/unix directory, though, since fix-comments mangles some of the files.
+# Besides, they should already be fine.
+fix-comments `find . -path './src/unix' -prune -o -name "*.[ch]" -print`
+
+# Do some cleanup.
+rm -rf artwork bios cfg cheat memcard nvram snap software
+
+# Rename some files.
+if [ -f messnew.txt ]; then
+  mv messnew.txt doc/mess/
+fi
+
+if [ -f sysinfo.dat ]; then
+  mv sysinfo.dat doc/mess/
+fi
+
+if [ -f tools/imgtool.txt ]; then
+  mv tools/imgtool.txt doc/mess/
+fi
+
+if [ -f tools/messroms.txt ]; then
+  mv tools/messroms.txt doc/mess/
+fi
+
+if [ -d docs ]; then
+  mv docs/* doc/mess/
+  rm -r docs
+fi
+
+# Clean up the files left over from d2u and fix-comments.
+rm -f `find . -name "*~" -print`
+rm -f `find . -name "*.orig" -print`
diff --git a/src/unix/contrib/porting/readme b/src/unix/contrib/porting/readme
new file mode 100644
index 0000000..3a33704
--- /dev/null
+++ b/src/unix/contrib/porting/readme
@@ -0,0 +1,35 @@
+Contents of directory contrib/porting
+==========================================
+
+1)      Name:		fix-comments.c
+	Author:		Hans De Goede <hans@highrise.nl> 
+	Description:   	A utility to patch original mame sources to xmame 
+	Notes:		Convert c++ style comments to std-c style,
+                        dos2unix text conversion, eof character
+                        removal and lowercase #include's and fix \ to /.
+
+2)	Name:		prep-new-mame
+	Author:		Lawrence Gold <gold@aros.net>
+			Hans de Goede <hans@highrise.nl>
+	Description:	A script which should be run from the root of a just
+			unpacked MS-DOS MAME source tree, and carries out most
+			of the nescessary porting steps.
+	Notes:		See also porting.txt for a full description on how to
+			port an MS-DOS tree to UN*X.
+
+3)	Name:		porting.txt
+	Author:		Lawrence Gold <gold@aros.net>	
+	Description:	A text file describing how to port the MS-DOS source  
+			tree to UN*X.  Heavily based on the original by Hans de
+			Goede.
+
+4)	Name:		readme
+	Author:		Lawrence Gold <gold@aros.net>	
+			Hans de Goede <hans@highrise.nl>
+	Description:	This file
+
+5)	Name:		strip_
+	Author:		jer johnson (jer@gweep.net)
+	Description:	A perl script which remove the leading _ in front of
+			symbols in nasm files, so that they work with ELF-based 
+			systems which don't use leading underscores.
diff --git a/src/unix/contrib/porting/strip_ b/src/unix/contrib/porting/strip_
new file mode 100755
index 0000000..bff4622
--- /dev/null
+++ b/src/unix/contrib/porting/strip_
@@ -0,0 +1,16 @@
+#!/usr/bin/perl -pi.bak
+
+#  Strip Underscores , written by jer johnson (jer@gweep.net) (k) 1998
+#
+# DELIM is the list of special characters that separate
+# variables ..  \s is Perl for "all whitespace characters"
+#  special characters need to be escaped with \'s so that
+# they don't cause trouble in the 1st pattern match
+#
+# if I missed some delimitting characters, add them to the $DELIM variable
+
+
+$DELIM = '\s\+\-\*\:\[\]/';
+
+s/([$DELIM]+)_/\1/g;            # remove the _ , leave the delimiter
+s/^_//;                         # remove _ 's at the beginning of the line
diff --git a/src/unix/contrib/readme b/src/unix/contrib/readme
new file mode 100644
index 0000000..3b4cb0a
--- /dev/null
+++ b/src/unix/contrib/readme
@@ -0,0 +1,37 @@
+This directory contains contributed material, and various tidbits which
+don't fit elsewhere.
+
+Contents of directory contrib
+==========================================
+
+1)	Name:		cutzlib-1.1.4
+	Description:	A cutdown version of zlib for compiling xmame on
+			systems without zlib.
+	Notes:		See doc/readme.unix, makefile.unix and
+			contrib/cutzlib-1.1.4/README.mame
+
+2)      Name:		frontends
+	Description:    Various frontends
+	Notes:		See contrib/frontends/readme
+
+3)	Name:		kxmame
+	Description:	A script for running xmame.x11 in older versions of KDE
+			which had a problem with the window not opening.
+	Author:		Sylvain Trosset and Hoonis
+
+4)      Name:           patches
+	Description:    Various patches
+	Notes:          See contrib/patches/readme
+
+5)	Name:		porting
+	Description:	Various tools and scripts used in porting
+			the dos mame version to unix.
+	Notes:		See contrib/porting/readme
+
+6)	Name:		readme
+	Author:		Hans de Goede <hans@highrise.nl>
+	Description:	This file
+
+7)	Name:		tools
+	Description:	Various xmame / xmess related tools and stuff
+	Notes:		See contrib/tools/readme
diff --git a/src/unix/contrib/tools/Sample_Intel_Compiler_Wrapper_Script b/src/unix/contrib/tools/Sample_Intel_Compiler_Wrapper_Script
new file mode 100644
index 0000000..aa9de1c
--- /dev/null
+++ b/src/unix/contrib/tools/Sample_Intel_Compiler_Wrapper_Script
@@ -0,0 +1,6 @@
+#!/bin/tcsh
+# This is a sample wrapper script for the Intel C++ compiler.  You may need to
+# adjust this for your system.
+exec /usr/opt/intel/compiler50/ia32/bin/icc ${*:q}
+-I/opt/intel/compiler50/ia32/include -I/usr/include
+-I/usr/local/lib/gcc-lib/i686-pc-linux-gnu/2.95.3/include/
diff --git a/src/unix/contrib/tools/makecd_mame2.pl b/src/unix/contrib/tools/makecd_mame2.pl
new file mode 100644
index 0000000..fbb7707
--- /dev/null
+++ b/src/unix/contrib/tools/makecd_mame2.pl
@@ -0,0 +1,190 @@
+#!/usr/bin/perl -w
+# makecd_mame2.pl
+#
+# This is a little script to burms roms mame. On each cd, you will have
+# the roms, the cabinet, and the flyer. If a game needs another rom like neogeo game,
+# the script will put this rom to on the cd, so you lost some space ~300Mo for
+# complete mame romset 0.62.
+# If you have an 650MB cdr (or better a dvd), you need to change the value
+# 700*1024*1024 in the script.
+#
+# You need to have a roms dir like this:
+#   /mnt/bigdur/jeux/arcade>ll
+#   total 340
+#   drwxr-xr-x   10 luc      luc          4096 2002-11-24 01:20 .
+#   drwxr-xr-x    8 luc      luc          4096 2002-11-20 12:03 ..
+#   drwxr-xr-x    2 luc      luc         20480 2002-05-03 10:59 cabinets
+#   drwxr-xr-x    2 luc      luc         36864 2002-05-03 09:56 flyers
+#   drwxr-xr-x    2 luc      luc         73728 2002-11-22 09:21 roms
+#   drwxr-xr-x    2 luc      luc          4096 2002-11-24 01:53 samples
+#
+#  The file gamelist is the output of the last xmame release (xmame -li). If
+#  you don't want to put additional rom to play a game, please replace the file
+#  by /dev/null
+# 
+#  Created: Thu, 28 Nov 2002 00:21:29 +0100
+#  Last modified: Thu, 28 Nov 2002 00:21:29 +0100
+#  Changelog:
+#    v0.1: first version
+#    v0.1a: oops i forgot to put samples on the cd
+#    v0.1b: put rom required on the cd.
+#
+#  Copyright (C) 2002 Luc Saillard <luc at saillard.org>
+#
+#   This program is free software; you can redistribute it and/or modify
+#   it under the terms of the GNU General Public License as published by
+#   the Free Software Foundation; either version 2 of the License, or
+#   (at your option) any later version.
+#
+#   This program is distributed in the hope that it will be useful,
+#   but WITHOUT ANY WARRANTY; without even the implied warranty of
+#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+#   GNU General Public License for more details.
+#
+#   You should have received a copy of the GNU General Public License
+#   along with this program; if not, write to the Free Software
+#   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+use strict;
+use POSIX qw(getcwd);
+
+die "Usage: makecd_mame.pl gamedir burndir gameslist\n" if (@ARGV!=3);
+
+my $gamedir=$ARGV[0];
+my $burndir=$ARGV[1];
+my $romsinfo=$ARGV[2];
+
+my %roms=();
+my %cabinets=();
+my %flyers=();
+my %samples=();
+my %romsinfo=();
+
+#
+## Read roms size from $gamedir
+##
+my $oldcwd=getcwd();
+chdir ("$gamedir/roms") || die "Can't change directory $gamedir/roms: $!\n";
+opendir(DIR, ".") || die "Can't opendir $gamedir/roms: $!";
+foreach (readdir(DIR))
+{
+  next if (/^\./);
+  next unless (/\.zip$/);
+  $roms{$_}=(stat($_))[7];
+}
+closedir DIR;
+chdir ("$gamedir/samples") || die "Can't change directory $gamedir/samples $!\n";
+opendir(DIR, ".") || die "Can't opendir $gamedir/samples $!";
+foreach (readdir(DIR))
+{
+  next if (/^\./);
+  next unless (/\.zip$/);
+  $samples{$_}=(stat($_))[7];
+}
+closedir DIR;
+chdir ("$gamedir/cabinets") || die "Can't change directory $gamedir/cabinets: $!\n";
+opendir(DIR, ".") || die "Can't opendir $gamedir/cabinets: $!";
+foreach (readdir(DIR))
+{
+  next if (/^\./);
+  $cabinets{$_}=(stat($_))[7];
+}
+closedir DIR;
+chdir ("$gamedir/flyers") || die "Can't change directory $gamedir/flyers $!\n";
+opendir(DIR, ".") || die "Can't opendir $gamedir/flyers: $!";
+foreach (readdir(DIR))
+{
+  next if (/^\./);
+  $flyers{$_}=(stat($_))[7];
+}
+closedir DIR;
+
+chdir($oldcwd);
+
+
+#
+# Read roms infos (xmame -li ouputs)
+#
+my $currentrom_name="";
+my $currentrom_need;
+my $total_games=0;
+my $line=0;
+open(F,$romsinfo) || die "Can't open file $romsinfo: $!\n";
+while(<F>)
+{
+  chomp;
+  # This is very simply parser
+  if (/^game \($/) {
+    $total_games++;
+    undef($currentrom_name);
+    undef($currentrom_need);
+  } elsif (/^\tromof (\w+)$/) {
+    $currentrom_need=$1;
+  } elsif (/^\tname (\w+)$/) {
+    $currentrom_name=$1;
+  } elsif (/^\)$/) {
+    print "In the previous block at line $line we haven't found a valid rom name\n" unless (defined($currentrom_name));
+    $romsinfo{"$currentrom_name.zip"}="$currentrom_need.zip" if (defined($currentrom_need));
+  }
+  $line++;
+}
+close(F);
+print "Total games: $total_games\n";
+
+
+#
+# Calculate size on each cd, and create links
+#
+my $currentcd_size=0;
+my $currentcd_idx=1;
+my $currentcd_nam="$burndir/Mame-cd 1";
+mkdir ($burndir) unless (-d $burndir);
+mkdir("$currentcd_nam") unless (-d "$currentcd_nam");
+mkdir("$currentcd_nam/roms") unless (-d "$currentcd_nam/roms");
+mkdir("$currentcd_nam/cabinets") unless (-d "$currentcd_nam/cabinets");
+mkdir("$currentcd_nam/flyers") unless (-d "$currentcd_nam/flyers");
+mkdir("$currentcd_nam/samples") unless (-d "$currentcd_nam/samples");
+
+foreach (sort keys %roms)
+{
+  my $imagename = $_;
+  $imagename =~ s/\.zip$/.png/;
+
+  # Try to put the next rom of the cd
+  my $size=0;
+  $size+=$roms{$_} unless (-l "$currentcd_nam/roms/$_"); 
+  $size+=$roms{$romsinfo{$_}} if (defined($romsinfo{$_}) && (! -l "$currentcd_nam/roms/$romsinfo{$_}"));
+  $size+=$samples{$_} if (defined($samples{$_}) && (! -l "$currentcd_nam/samples/$_"));
+  $size+=$cabinets{$imagename} if (defined($cabinets{$imagename}) && (! -l "$currentcd_nam/cabinets/$imagename"));
+  $size+=$flyers{$imagename} if (defined($flyers{$imagename}) && (! -l "$currentcd_nam/flyers/$imagename"));
+
+  # Check if the file can be put on the cd
+  if ($currentcd_size+$size>680*1024*1024) {
+    $currentcd_size=0;
+    $currentcd_idx++;
+    $currentcd_nam="$burndir/Mame-cd $currentcd_idx";
+    mkdir("$currentcd_nam") unless (-d "$currentcd_nam");
+    mkdir("$currentcd_nam/roms") unless (-d "$currentcd_nam/roms");
+    mkdir("$currentcd_nam/cabinets") unless (-d "$currentcd_nam/cabinets");
+    mkdir("$currentcd_nam/flyers") unless (-d "$currentcd_nam/flyers");
+    mkdir("$currentcd_nam/samples") unless (-d "$currentcd_nam/samples");
+
+  }
+  $currentcd_size+=$size;
+
+  symlink("$gamedir/roms/$_","$currentcd_nam/roms/$_") unless (-l "$currentcd_nam/roms/$_");
+  symlink("$gamedir/roms/$romsinfo{$_}","$currentcd_nam/roms/$romsinfo{$_}") if (defined($romsinfo{$_}) && (! -l "$currentcd_nam/roms/$romsinfo{$_}"));
+  symlink("$gamedir/samples/$_","$currentcd_nam/samples/$_") if (defined($samples{$_}) && (! -l "$currentcd_nam/samples/$_"));
+  symlink("$gamedir/cabinets/$imagename","$currentcd_nam/cabinets/$imagename") if (defined($cabinets{$imagename}) && (! -l "$currentcd_nam/cabinets/$imagename"));
+  symlink("$gamedir/flyers/$imagename","$currentcd_nam/flyers/$imagename") if (defined($flyers{$imagename}) && (! -l "$currentcd_nam/flyers/$imagename"));
+}
+
+
+print "Generate iso with:\n";
+print "cd $burndir ; for i in " . join(" ",1 ... $currentcd_idx) . "; do \n";
+print "mkisofs -J -r -f -v -V \"Mame cd \$i\" -o mamecd\$i.iso \"Mame-cd \$i\" \n";
+print "done\n";
+
+
+
+
diff --git a/src/unix/contrib/tools/mame-cd b/src/unix/contrib/tools/mame-cd
new file mode 100644
index 0000000..e44823f
--- /dev/null
+++ b/src/unix/contrib/tools/mame-cd
@@ -0,0 +1,240 @@
+#!/usr/bin/perl
+
+#############################################################################
+# MAME-CD v0.1  This is BETA QUALITY ...or worse ;) 
+#
+# Copyright (C) 2001  Mario J. Barchein Molina <mbarchein@yahoo.es>
+# 
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+# 
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+# 
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+#############################################################################
+
+
+#
+# CONFIGURATION OPTIONS. Modify them to suit your system
+#
+
+# The xmame executable (needed to read game info). 
+# MUST _NOT_ BE ROOT SETUID!!!
+$XMAME = "/usr/local/bin/xmame.x11";
+
+# Your rompath. Separate components with ':'. List paths with more recent
+# roms before paths with older ones.
+# eg: $ROMPATH = /stuff/mame-54-roms:/stuff/mame-all-other-roms
+$ROMPATH = "/your/mame/roms";
+
+# The output dir where structure will be created
+$CDROM_DIR = "/tmp/mame-cd";
+
+# Max size (in bytes) of each CD. This is aprox 650MB. You can reduce if
+# you want to include other files in the CDs.
+$CDROM_SIZE = 678602880;
+
+#
+# ----- END OF CONFIGURATION -------
+#
+
+#-----------------------------------------------------------------------------
+
+print "Reading game info. Please wait...\n";
+open (XMAME, "$XMAME -listinfo 2>/dev/null |");
+
+# process each info block
+@block = ();
+foreach (<XMAME>){
+    
+    # add line to block (game, resource,...)
+    $block[$#block+1]=$_ if not $_ =~ /^\s*$/;
+    
+    # end of block
+    if ($_ =~ /^\)$/){
+	
+	# get the name of the block
+	$block[1] =~ /name ([^\s]+)/;
+	$blockname = $1;
+	
+	#initialize variables
+	$year = "19xx-unknown";
+
+	# process block
+	if ($block[0] =~ /^game/ ){ #block is game
+	    
+	    # search for clone of another game or use roms of another game
+	    for ($i=0, $cloneof="", $romof=""; $i < $#block; $i++){
+		if ($block[$i]=~/^\s*cloneof ([^\s]+)/){
+		    $cloneof=$1; 
+		    
+		    #add game to the list of clones of a game
+		    $clone_of{$cloneof} .= "$blockname ";
+		} 
+		
+		if ($block[$i]=~/^\s*romof ([^\s]+)/){
+		    $romof=$1; 
+		    
+		    #add game to $game_uses_roms_of{}
+		    $game_uses_roms_of{$blockname}.= "$romof ";
+		} 
+		
+		# get the year of a game
+		if ($block[$i]=~/^\s*year ([^\s]+)/){
+		    $year = $1;
+		} 
+	    }
+	    
+	    # add to the list of non-clones (if ok) and year
+	    if ($cloneof eq ""){
+		$non_clones{$blockname}=1;
+		$games_in_year{$year} .= "$blockname ";
+	    }
+	    
+	} elsif ($block[0] =~ /^resource/ ){ #block is resource
+	}
+
+
+	# reset block
+	@block = ();
+    }
+    
+}
+close (XMAME);
+
+# calculate size of each game and its clones.
+foreach (sort keys %non_clones){
+    $current_non_clone = $_;
+    #print "No clone: $current_non_clone\n";
+    
+    # foreach non-clone, process itself and all ist clones
+    foreach ($current_non_clone, split(/\s+/,$clone_of{$current_non_clone})){
+	$romset = $_;
+	$found = 0;
+	
+	# search file in each component of the ROMPATH
+	foreach (split(/:/,$ROMPATH)){
+	    s#/$##;
+	    $filepath = $_."/".$romset.".zip";	    
+	    
+	    if ( !$found && -f $filepath){
+		$found=1;
+		$romset_filepath{$romset}=$filepath;
+		
+		# stat the file
+		($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$size,
+		     $atime,$mtime,$ctime,$blksize,$blocks) = stat($filepath);
+		
+		$romset_size{$romset} = $size;
+
+		# add the size of this romset to the total of the clones of
+		# the non-clone game. The size is calculated in the way
+		# each file use a complete CDROM sector for the last one.
+		$sectors = $size / 2048;
+		$sectors =~ s/\..+//;
+		$cdrom_size = ($sectors*2048) + ( (($size%2048)!=0) ? 2048:0);
+		$non_clone_plus_clones_size{$current_non_clone} += $cdrom_size;
+		
+		#print "$romset ocupa $cdrom_size\n";
+		#print "clones de $current_non_clone ocupan $non_clone_plus_clones_size{$current_non_clone}\n";
+	    }
+	}
+	
+	# show warning if the romset isn't found in the ROMPATH
+	print "Romset for $romset not found. Skipping\n" if !$found;
+    }
+}
+
+
+# Look for other resources the games might need and locate them in the disk
+# (like NEOGEO games that need neogeo.zip)
+foreach (sort values %game_uses_roms_of){
+    $resource = $_;
+    $resource =~ s#\s+$##;
+    
+    # search file in each component of the ROMPATH (only if not found
+    # previously)
+    if ($romset_filepath{$resource} eq "" && 
+	$resource_filepath{$resource} eq "")
+    {
+	$found = 0;
+	
+	foreach (split(/:/,$ROMPATH)){
+	    s#/$##;
+	    $filepath = $_."/".$resource.".zip";
+	
+	    if ( !$found && -f $filepath){
+		$found=1;
+		$resource_filepath{$resource}=$filepath;
+	    }
+	}
+    }
+}
+
+### FILE OPERATIONS
+
+# create output dir
+mkdir ($CDROM_DIR,0755);
+
+# initialize CDROM count and create dir
+$current_cd = 1;
+$remaining_size = $CDROM_SIZE;
+
+$current_output_dir = $CDROM_DIR."/cd".$current_cd."/";
+mkdir ($current_output_dir,0755);
+mkdir ($current_output_dir."allroms/",0755);
+
+# distribute the games in the cd's (ordered by year)
+foreach (sort keys %games_in_year){
+    $current_year = $_;
+    mkdir ($current_output_dir."$current_year/",0755);
+	
+    # foreach set + clones, symlink them to the output directory
+    foreach (sort split(/\s+/, $games_in_year{$current_year})){
+	$current_non_clone = $_;
+	
+	# if there is no more space, advance to the next CD
+	if ($remaining_size - $non_clone_plus_clones_size{$current_non_clone} < 0){
+	    $current_cd++;
+	    $remaining_size = $CDROM_SIZE;
+	    
+	    #create CDROM dir
+	    $current_output_dir = $CDROM_DIR."/cd".$current_cd."/";
+	    mkdir ($current_output_dir,0755);
+	    mkdir ($current_output_dir."allroms/",0755);
+	    mkdir ($current_output_dir."$current_year/",0755);
+	}
+	
+	# adjust new remaining size for the CD
+	$remaining_size -= $non_clone_plus_clones_size{$current_non_clone};
+	
+	# foreach romset, link it to the output directories.
+	foreach ($current_non_clone,split(/\s+/,$clone_of{$current_non_clone})){
+	    $romset=$_;
+	    
+	    symlink ($romset_filepath{$romset}, $current_output_dir."allroms/".$romset.".zip");
+	    symlink ("../allroms/".$romset.".zip", $current_output_dir."$current_year/".$romset.".zip");
+	    
+	    #link any other resource the game might need
+	    $resource = $game_uses_roms_of{$romset};
+	    $resource =~ s#\s+$##;
+	    
+	    if ($resource_filepath{$resource} ne ""){
+		symlink ($resource_filepath{$resource}, $current_output_dir."allroms/".$resource.".zip");
+		symlink ("../allroms/".$resource.".zip", $current_output_dir."$current_year/".$resource.".zip");
+	    }
+	    
+	}
+    }
+}
+
+
+
+
diff --git a/src/unix/contrib/tools/mame-listmissing b/src/unix/contrib/tools/mame-listmissing
new file mode 100644
index 0000000..5eb4d61
--- /dev/null
+++ b/src/unix/contrib/tools/mame-listmissing
@@ -0,0 +1,264 @@
+#!/usr/bin/perl -w
+
+use strict;
+
+#############################################################################
+#
+# mame-listmissing v1.2
+#
+# Copyright (C) 2001 David Griffith <dgriffi@cs.csubak.edu>
+#
+#  This program is intended to used with Xmame (http://x.mame.net) and is
+#  distributed under the same terms.  Nothing in this program is terribly
+#  original, so feel free to help yourselves to the algorithms.
+#
+#  The latest version of this script can be found in the latest release
+#  of Xmame or at http://www.cs.csubak.edu/~dgriffi/proj/mame
+#
+#
+#  Use at your own risk.
+#
+#
+# Requirements:
+#	1) A Unix machine of some sort.
+#		(duh)
+#	2) Perl 5 or higher.
+#		(duh)
+#	2) Xmame correctly installed.
+#		(to get all supported rom names)
+#	3) Contents of your roms directory is visible.
+#		(so we can see what you have)
+#
+#############################################################################
+#
+# List which supported roms are missing from your collection.
+# Version 1.2
+#
+# usage: mame-listmissing [<options>] [<path>]
+#
+#	<path>	Override whatever default path you've set for where you 
+#		keep your roms.  Must be a colon-seperated path.
+#
+#	-e	Extension.  If your rom files are contained in something 
+#		other than .zip files, specify here or modify the 
+#		default.  This option will go away if/when I decide to use 
+#		a hash to handle extensions automatically.
+#
+#	-h	Help.  You're reading it now.
+#
+#	-v	Invert.  Cause listmissing to report roms that you
+#		have installed.
+#
+#############################################################################
+
+# ChangeLog
+
+# 1.2 A '$' was not properly escaped in verify_path().
+#
+# 1.1 Added checking of multiple directories.
+# 
+# 1.0 Initial release.
+
+
+
+# CONFIGURATION OPTIONS.  Modify them to suit your system.
+#
+my $MAMEBIN = "xmame";
+my $def_rompath = "/usr/local/share/mame/roms";
+my $def_ext = ".zip";
+
+
+
+#
+# ----- END OF CONFIGURATION SECTION -------
+#
+#############################################################################
+#############################################################################
+
+use File::Basename;	# I assume we'll use this only on Unix.
+use vars qw($opt_e $opt_h $opt_v);
+use Getopt::Std;
+
+my ($extension, $invert, $rompath);
+my $binname = "mame-listmissing";
+
+getopts("e:hp:v");
+
+if ($opt_e) {
+	$extension = $opt_e;
+}
+else {
+	$extension = $def_ext;
+}
+
+if ($opt_h) {
+	print_help();
+	exit 0;
+}
+
+if ($opt_v) {
+	$invert = 1;
+}
+else {
+	$invert = 0;
+}
+
+if ($ARGV[0]) {
+	$rompath = $ARGV[0];
+}
+else {
+	$rompath = $def_rompath;
+}
+
+verify_path();
+
+# This is taken directly from 4.7 in the Perl Cookbook 
+#   What is in $supported_roms but not in $installed_roms?
+#
+my @supported_roms = get_supported_roms();
+my @installed_roms = get_installed_roms();
+
+my @missing_roms = ();	# answer
+
+unless ($invert) {
+	my %seen = ();		# lookup table to test membership of @B;
+
+	# build lookup table
+	foreach my $i (@installed_roms) {
+		$seen{$i} = 1; 
+	}
+
+	# find only elements in @supported_roms and not in @installed_roms
+	foreach my $i (@supported_roms) {
+		unless ($seen{$i}) {
+			# it's not in %seen, so add to @aonly
+			push(@missing_roms, $i);
+		}
+	}
+}
+else {
+	@missing_roms = @installed_roms;
+}
+
+@missing_roms = sort(@missing_roms);
+
+foreach my $i (@missing_roms) {
+	print "$i\n";
+}
+
+
+# Returns array minus all blank elements.
+#
+sub noblank (\@) {
+	my @out;
+	foreach my $i (@{$_[0]}) {
+		if ($i =~ /^\S.*$/) {
+			push(@out, $i);
+		}
+	}
+	@{$_[0]} = @out;
+	return wantarray ? @out : $out[0];
+}
+
+
+# Get a list of all files in $rompath which have the standard extension.
+# Strip the extension then return the list, which is the list of roms 
+# currently installed.
+#
+sub get_installed_roms {
+	my ($filename, $junk);
+	my (@paths, @roms);
+
+	foreach my $i (split(/:/, $rompath)) {
+		foreach my $j (glob("$i/*$extension")) {
+			($filename, $junk, $junk) = basename($j, "$extension");
+			push(@roms, $filename);
+		}
+	}
+	return @roms;
+}
+
+
+# Check $rompath to make sure all directories listed are valid.
+#
+sub verify_path {
+	foreach my $i (split(/:/, $rompath)) {
+		unless (-d $i) {
+			print STDERR "$binname: $i is not a directory!\n";
+			if ($rompath eq $def_rompath) {
+				print STDERR
+"    Make sure the variable ``\$def_rompath''\n".
+"    in $binname\'s configuration section is set correctly.\n";
+			}
+			else {
+				print STDERR  
+"    Make sure you enter a valid path on the command line.\n";
+			}
+			exit 1;
+		}
+		else {
+			unless (-x $i) {
+				print STDERR "$binname: $i cannot be searched!\n";
+				exit 2;
+			}
+		}
+	}
+}
+
+
+# Digest `$MAMEBIN -l` into an array in which each element contains a 
+# single rom name.
+#
+sub get_supported_roms {
+	my (@preout, @roms_supp);
+	my ($total_sup, $junk);
+
+	@preout = `$MAMEBIN -l 2> /dev/null`;
+
+	# This splice() call depends on xmame returning something like:
+	# "xmame currently supports:" stuff at the top which we can
+	# safely throw away.
+	#
+	splice(@preout, 0, 1);
+
+	# End of output should look something like this:
+	# "Total Supported: 3123".  We're not interested in that number.
+	# lc(1) is your friend.
+	#
+	pop(@preout);
+	noblank(@preout);
+	chomp(@preout);
+
+	foreach my $i (@preout) {
+		push(@roms_supp, split(/ /, $i));
+	}
+
+	noblank(@roms_supp);
+
+	return @roms_supp;
+}
+
+
+sub print_help {
+print <<EOF;
+
+List which roms are missing from your collection.
+Version 1.2
+
+usage: mame-listmissing [<options>] [<path>]
+
+	<path>	Override whatever default path you've set for where you 
+		keep your roms.  Must be a colon-seperated path.
+
+	-e	Extension.  If your rom files are contained in something 
+		other than a .zip file, specify it here or modify the 
+		default.  This option will go away if/when I decide to use 
+		a hash to handle extensions automatically.
+
+	-h	Help.  You're reading it now.
+
+	-v	Invert.  Cause listmissing to report roms that you
+		have installed.
+
+EOF
+}
diff --git a/src/unix/contrib/tools/mame_perl-1.3/README b/src/unix/contrib/tools/mame_perl-1.3/README
new file mode 100644
index 0000000..ef72297
--- /dev/null
+++ b/src/unix/contrib/tools/mame_perl-1.3/README
@@ -0,0 +1,188 @@
+MAME/Raine ROM sets manager Perl scripts 1.3                       21-Feb-2001
+
+(c) 2000 - 2001  Stefan Becker
+
+THE AUTHOR GIVES NO WARRANTY - USE AT YOUR OWN RISK!
+
+Release history:
+
+21-Feb-2000 1.3   Reads BIOS ROMs from "resource" entries (MAME 0.37 Beta 12)
+                  Created alternative parser with Parse::RecDescent (not used)
+                  Handles clones of clones correctly now, except for
+                  full-merge (see "Problems")
+07-Dec-2000 1.2   Made Perl 5.0005_03 mandatory
+                  Handles BIOS ROMs for CVS & PlayChoice-10 correctly now
+                  Replaced --clean-neogeo with the generic --clean=<parent>
+                  Corrected several errors in mame_sets
+17-May-2000 1.1   Updated for -listinfo syntax changes in MAME 0.37 Beta 2
+25-Jan-2000 1.0   Initial version
+
+I. "What - another ROM set manager???"
+======================================
+
+Yep, yet another one. Why? Because I couldn't use all those non-portable
+Win32-only ROM set managers on my UNIX boxes where I manage my ROM set 
+collection. So I started to write some small hacks to ease the work. The
+current version was developed with two goals in mind: portability and speed.
+
+Portability: I have tested these scripts with Perl installations on HP-UX,
+Solaris and Windows 95 (ActiveState). They should probably work on all
+platforms with a decent Perl installation.
+
+Speed: All ROM sets managers I have seen up to now always unzip all files and
+zip them to the new set. When I looked at the structure of a ZIP archive I
+noticed that this is totally unecessary: You can just copy the information
+from the old ZIP archive to the new one. By using this strategy these scripts
+are blazingly fast (as fast as your OS can read & write the data from/to the
+disk) although they are written in a script language :-)
+
+
+II. Usage
+=========
+
+There are five scripts included in this package:
+
+ mame_parse - Read output MAME -listinfo/ RAINE -gameinfo command from STDIN
+              and parse it
+	      Usage: see "mame_parse --help"
+
+ mame_merge - MAME/Raine ROM set manager
+	      Usage: see "mame_merge --help"
+
+ mame_sets  - Check for missing, deleted, new and changed MAME ROM sets
+	      Usage: see "mame_sets --help"
+
+ zipcmp     - Compare ZIP archives (used by mame_sets)
+
+ zipfix     - Salvage truncated zip archives
+
+Just copy the scripts into a directory which is in your $PATH. On Unix systems
+you should check if the first line (#!/usr/bin/perl) points to your perl
+executable. On Win32 systems you have to call perl with the script's name to
+execute it.
+
+To use the ROM set manager you first have to create the database from MAME or
+Raine with the one of the following commands:
+
+  > xmame -listinfo | mame_parse
+  > mame -listinfo  | perl mame_parse
+  > raine -gameinfo | perl mame_parse
+
+After that you can use the ROM set manager, e.g.
+
+  > mame_merge --full-merge          (Create fully merged ROM set collection)
+  > mame_merge --split-merge pacman  (Create a splitted merged set for PacMan)
+
+or you can check the completeness of your collection with mame_sets. I use the
+following directory structure in my home directory:
+
+ > cd $HOME/mame
+ > ls
+ artwork/             mame.exe             newroms/
+ beta/                mameinfo.db          roms/
+ mame.cfg             mameinfo.txt         samples/
+ > cd beta
+ > ls
+ artwork/  roms/     samples/
+
+In the subdirectories under "mame" I have all the files required for the
+latest official MAME release (at the time of this writing: 0.35). In the
+subdirectories under "beta" I have all the new and changed files for the
+latest MAME beta version (currently 0.36b15). mame_sets can now analyze the
+differences:
+
+ > mame_sets
+ Missing sets         :
+ Deleted non-beta sets: 3wonderj boscomd2 frogger2 frogsega gryzorb hbarrelj
+ invdelux lomakaj neogeo robocopp ropeman rthundrb stratgyb
+ Deleted beta sets    :
+ New sets             : 2020bbh 64streej 88games 99lstwar 99lstwra ...
+ Modified sets        : 2020bb 64street alexkidd alpham2 alpine ...
+ 653 changed sets = 509 new + 144 modified
+
+Please check use the "--help" option for information about all the available
+options. All of the above applies of course also to Raine ROM sets.
+
+The last two scripts are some small helpers for ZIP archives. The first one
+compares the contents of two archives and prints out any differences. Note:
+It only compares the file lengths and CRCs, not the actual file contents!
+Use it like this:
+
+ > zipcmp roms/2020bb.zip beta/roms/2020bb.zip
+ Only in roms/2020bb.zip: n046001a.1fc n046001a.538 n046001b.538 ...
+ Only in beta/roms/2020bb.zip: 2020_m1.rom 2020_c1.rom 2020_p1.rom ...
+
+Your last download aborted and your are left with a truncated ZIP archive that
+zip doesn't want to touch? Let zipfix help you! It tries to salvage as much
+information from the truncated archive as possible:
+
+ > zipfix 64streej.zip
+ Size       Compr.     CRC-32   File Name
+ --------------------------------------------------------------------
+     262144      71511 27c1f436 91105-2.bin
+     262144      36364 a211a83b 91105-3.bin
+ Next entry is not a local directory.
+ Found 2 file(s), regenerating central directory structure.
+ Zip archive salvaged!
+
+Now you can use zip/unzip on the salvaged ZIP archive. Last, but not least, 
+here is a small alias to create dummy files for those "NO GOOD DUMP KNOWN"
+ROMs:
+
+ alias create_dummy_rom='perl -e "print \$ARGV[0] x \$ARGV[1];"'
+
+Use it like this:
+
+ > create_dummy_rom a 1024 >prom1
+ > create_dummy_rom b 1024 >prom2
+ > zip -9 -m -X romxyz.zip prom?
+
+if the two 1024 byte long files "prom1" and "prom2" are missing in ROM set
+"romxyz". After that you'll never get "NOT FOUND" messages during ROM verify.
+
+
+III. Requirements
+=================
+
+You need at least Perl 5.005_03. You also need to install the following
+Perl modules
+
+ DB_File      - standard if BerkeleyDB is installed before Perl
+ MLDBM        - CPAN
+ Parse::Lex   - CPAN, at least version 2.07 required
+ Parse::Yapp  - CPAN, at least version 0.31 required       
+
+ActiveState's Perl users can install them via the ActiveState web page.
+
+
+IV. Problems
+============
+
+If a clone ROM set has clones, e.g. CVS "radarzon", then "--full-merge" will
+generate a fully merged set for the clone and its clones. This ROM set has to
+be manually merged with the parent ROM set.
+
+
+V. Thanks to...
+===============
+
+I would really like to thank all the emulator authors and web site admins for
+all their terrific work. So: DON'T FORGET TO CLICK THOSE BANNERS, it's the
+least we can do!
+
+Franky and soulman, I hope you are happy now :-)
+
+
+VI. References
+==============
+
+       MAME home page		http://www.mame.net/
+       X MAME home page		http://x.mame.net/
+       MAMEWorld page		http://www.mameworld.net/
+       Raine home page		http://www.rainemu.com/
+       Retrogames		http://www.retrogames.com/
+       Arcade ROM Heaven	http://www.arcadeheaven.com/
+       EmuViews			http://www.emuviews.com/
+       MAME DK			http://www.mame.dk/
+       Perl			http://www.perl.com/
+       CPAN			http://www.cpan.org/
diff --git a/src/unix/contrib/tools/mame_perl-1.3/mame_merge b/src/unix/contrib/tools/mame_perl-1.3/mame_merge
new file mode 100755
index 0000000..3d189ef
--- /dev/null
+++ b/src/unix/contrib/tools/mame_perl-1.3/mame_merge
@@ -0,0 +1,774 @@
+#!/usr/bin/perl -w
+#
+# mame_merge - MAME/Raine ROM set manager
+#
+# (c) 2000 - 2001  Stefan Becker
+#
+# The ROM set information is read from the database file 'mameinfo.db' which
+# is generated by mame_parse.
+#
+# PROBLEMS: If a clone has clones, e.g. CVS "radarzon", then "--full-merge"
+#           will generate a fully merged set for the clone and its clones.
+#           This ROM set has to be manually merged with the parent ROM set.
+#
+#-----------------------------------------------------------------------------
+#
+# REQUIRED PERL PACKAGES
+#
+#-----------------------------------------------------------------------------
+require 5.005_03;
+use     strict;
+use     Getopt::Long;
+use     Fcntl;
+use     IO::File;
+use     File::Spec;
+use     MLDBM qw(DB_File); # CPAN, requires
+                           #   Data::Dumper standard
+                           #   DB_File      standard if BerkeleyDB exists
+#-----------------------------------------------------------------------------
+
+#-----------------------------------------------------------------------------
+#
+# DATASTRUCTURES
+#
+#-----------------------------------------------------------------------------
+#
+# Hash with all available games
+#
+# %DB = ( Name of game1 => Hash with game information
+#          { roms   => Hash with ROMs for this game 
+#             { Key of ROM1 => Hash with ROM data, key = crc . size
+#                { name => File name
+#                  size => Size in bytes
+#                  crc  => CRC32 checksum
+#                },
+#               ... next ROM
+#             }
+#            clones => Hash with clones for this game
+#             { Name of Clone1 => Hash with ROMs for this clone
+#                { (see above)
+#                },
+#               ... next clone
+#             }
+#          },
+#         ... next game
+#       );
+#
+#-----------------------------------------------------------------------------
+#
+# Hash with ZIP archive data
+#
+# $zipdata = { Key of file1 => Hash with ZIP data, key same as above
+#               { dir    => Array with ZIP directory data
+#                  [ 0 ZIP magic identifier string
+#                    1 ZIP version number required to uncompress the data
+#                    2 Flags
+#                    3 Compression method number
+#                    4 Time stamp
+#                    5 CRC32 value of original file
+#                    6 Compressed data size
+#                    7 Original file size
+#                  ],
+#                 data   => String with compressed data
+#                 name   => File name
+#               },
+#              ... next file
+#            };
+#
+#-----------------------------------------------------------------------------
+#
+# Hash with new ZIP archive data
+#
+# $archivedata = { name   => File name
+#                  handle => File handle opened for writing
+#                  offset => File offset during writing
+#                  dir    => Array with central directory information in binary
+#                   [ string1, ... ]
+#                };
+#
+#-----------------------------------------------------------------------------
+
+#-----------------------------------------------------------------------------
+#
+# SUB ROUTINES
+#
+#-----------------------------------------------------------------------------
+#
+#-----------------------------------------------------------------------------
+#
+# READ FROM ZIP ARCHIVES
+#
+#-----------------------------------------------------------------------------
+# Read data from one ZIP archive
+sub ReadZipData($$$) {
+  my($romdir, $name, $zipdata) = @_;
+  my $handle                   = new IO::File;
+
+  #print "Reading from ", File::Spec->catfile($romdir, $name), ".zip\n";
+
+  # Open file for reading
+  if ($handle->open("< " . File::Spec->catfile($romdir, $name) . ".zip")) {
+
+    # Make sure we read in binary mode
+    binmode $handle;
+
+    # For each local directory in file
+    while (1) {
+      my $ok;
+      my $data;
+
+      # Read local directory file
+      if ($handle->read($data, 30) == 30) {
+
+	#
+	# ZIP archive: Local directory structure
+	#
+	# All data is little endian and unsigned
+	#
+	#   0  char  magic[4]               "PK\x03\x04"
+	#   4  short version required
+	#   6  short flags
+	#   8  short compression method
+	#  10  long  time
+	#  14  long  CRC32 checksum of original file
+	#  18  long  compressed data size
+	#  22  long  original file size
+	#  26  short length of file name
+	#  28  short length of extension field
+	# ---
+	#  30  <local directory structure>
+	#      <file name>
+	#      <extension>
+	#      <compressed data>
+	#
+	my ($magic, $ver, $flags, $method, $time, $crc32,
+	    $compsize, $origsize, $namelen, $extlen) =
+	      unpack("a4vvvVVVVvv", $data);
+
+	# Check magic for local directory
+	if ($magic eq "PK\x03\x04") {
+
+	  # Read name from file
+	  if ($handle->read($data, $namelen) == $namelen) {
+	    my $name = unpack("a*", $data);
+
+	    # Skip extension field
+	    if ($handle->read($data, $extlen) == $extlen) {
+
+	      # Read compressed data
+	      if ($handle->read($data, $compsize) == $compsize) {
+
+		# Add data to hash
+		$zipdata->{sprintf("%08x$;%u$;", $crc32, $origsize)} = 
+		  {
+		   dir  => [$magic, $ver, $flags, $method, $time, $crc32,
+			    $compsize, $origsize],
+		   data => $data,
+		   name => $name
+		  };
+
+		# No errors
+		$ok = 1;
+
+		# Print progress information
+		print ".";
+	      }
+	    }
+	  }
+	}
+      }
+      
+      # EOF in data or no local directory found
+      last unless $ok;
+    }
+
+    # Close file
+    $handle->close;
+  }
+}
+
+# Read all related ZIP archives
+sub ReadAllZipData($$$) {
+  my($romdir, $parentname, $game) = @_;
+  my $zipdata                     = {};
+
+  # Read parent ROM set
+  ReadZipData($romdir, $parentname, $zipdata);
+
+  # For each clone set
+  if (exists $game->{clones}) {
+    foreach (keys % {$game->{clones}}) {
+
+      # Read clone ROM set
+      ReadZipData($romdir, $_, $zipdata);
+    }
+  }
+
+#  foreach (keys %$zipdata) {
+#    my $dir = $zipdata->{$_}->{dir};
+#    printf "Read %-20s: %8u %08x\n", $_, $dir->[7], $dir->[5];
+#  }
+
+  return $zipdata;
+}
+
+#-----------------------------------------------------------------------------
+#
+# WRITE TO ZIP ARCHIVES
+#
+#-----------------------------------------------------------------------------
+# Create ZIP archive
+sub CreateZipFile($$) {
+  my($romdir, $name) = @_;
+  my $archivedata;
+  my $rc;
+
+  # Initialize hash
+  $archivedata->{name}   = File::Spec->catfile($romdir, $name) . ".zip";
+  $archivedata->{handle} = new IO::File;
+  $archivedata->{dir}    = [];
+  $archivedata->{offset} = 0;
+  #print "Writing to $archivedata->{name}\n";
+
+  # Open file for writing
+  if ($archivedata->{handle}->open("> $archivedata->{name}")) {
+
+    # Make sure we write in binary mode
+    binmode $archivedata->{handle};
+
+    # All OK.
+    $rc = $archivedata;
+
+  } else {
+
+    # Error
+    print " Couldn't open file '$archivedata->{name}' for writing!\n";
+  }
+
+  return $rc;
+}
+
+# Add data to ZIP archive
+sub AddDataToZipFile($$$) {
+  my($archivedata, $name, $data) = @_;
+  my $handle                     = $archivedata->{handle};
+  my $dir                        = $data->{dir};
+  my $rc;
+
+  #print "Writing $name (", length($name), ")\n";
+
+  # Write local directory, name and compressed data to file
+  if ($handle->write(pack("a4vvvVVVVvv", @$dir, length($name), 0),
+                                    30)            and
+      $handle->write($name,         length($name)) and
+      $handle->write($data->{data}, $dir->[6]   )) {
+
+    #
+    # ZIP archive: Central directory structure
+    #
+    # All data is little endian and unsigned
+    #
+    #   0  char  magic[4]               "PK\x01\x02"
+    #   4  short version made
+    #   6  short version required
+    #   8  short flags
+    #  10  short compression method
+    #  12  long  time
+    #  16  long  CRC32 checksum of original file
+    #  20  long  compressed data size
+    #  24  long  original file size
+    #  28  short length of file name
+    #  30  short length of extension field
+    #  32  short file comment length
+    #  34  short disk number start
+    #  36  short internal file attributes
+    #  38  long  external file attributes
+    #  42  long  offset of local directory from file start
+    # ---
+    #  46  <central directory structure>
+    #      <file name>
+    #      <extension>
+    #      <file comment ???>
+    #
+    # Append entry to central directory array
+    push(@{$archivedata->{dir}},
+	 "PK\x01\x02" .
+	 pack("vvvvVVVVvvvvvVV",
+	      $dir->[1], $dir->[1], $dir->[2], $dir->[3], $dir->[4],
+              $dir->[5], $dir->[6], $dir->[7], length($name),
+              0, 0, 0, 0, 0, $archivedata->{offset}) .
+	 $name);
+
+    # Calculate new offset
+    $archivedata->{offset} += 30 + length($name) + $dir->[6];
+
+    # No errors
+    $rc = 1;
+
+    # Print progress information
+    print ".";
+  }
+
+  # Error?
+  if (not $rc) {
+
+    # Close and delete file
+    $archivedata->{handle}->close;
+    unlink($archivedata->{name});
+
+    # Print error message
+    print " Couldn't write to file '$archivedata->{name}'!\n";
+  }
+
+  return $rc;
+}
+
+# Finish ZIP archive
+sub FinishZipFile($) {
+  my($archivedata) = @_;
+  my $handle       = $archivedata->{handle};
+  my $dir          = $archivedata->{dir};
+  my $dirlength    = 0;
+  my $rc;
+
+  # For each entry in central directory array
+  foreach (@$dir) {
+
+    # Write data to file
+    if (not $handle->write($_, length($_))) {
+
+      # Error
+      $dirlength = -1;
+      last;
+    }
+
+    # Add to directory length
+    $dirlength += length($_);
+  }
+
+  # All entries written?
+  if ($dirlength > 0) {
+
+    #
+    # ZIP archive: End of archive structure
+    #
+    # All data is little endian and unsigned
+    #
+    #   0  char  magic[4]               "PK\x05\x06"
+    #   4  short disk number
+    #   6  short disk number where central directory starts ???
+    #   8  short number of entries in the current central directory
+    #  10  short total number of entries in all directories ???
+    #  12  long  size of current central directory
+    #  16  long  offset of central directory from file start
+    #  20  short archive comment length
+    # ---
+    #  22  <end of archive structure>
+    #      <ZIP archive comment ???>
+    #
+    # Write end of archive structure to the new file
+    if ($handle->write("PK\x05\x06" .
+		       pack("vvvvVVv",
+			    0, 0, $#$dir + 1, $#$dir + 1, $dirlength,
+			    $archivedata->{offset}, 0),
+		       22)) {
+
+      # No errors
+      $rc = 1;
+    }
+  }
+
+  # Close file
+  $archivedata->{handle}->close;
+
+  # Error?
+  if (not $rc) {
+
+    # Delete file
+    unlink($archivedata->{name});
+
+    # Print error message
+    print " Couldn't finish ZIP archive '$archivedata->{name}'!\n";
+  }
+
+  return $rc;
+}
+
+#-----------------------------------------------------------------------------
+#
+# ROM SET MANIPULATION
+#
+#-----------------------------------------------------------------------------
+# Print missing ROM information
+sub PrintMissingROMInfo($$) {
+  my($name, $missingroms) = @_;
+
+  # For each ROM
+  foreach (@$missingroms) {
+    printf "Missing ROM in %-8s: %-12s %8u %s\n", $name, $_->{name},
+                                                  $_->{size}, $_->{crc};
+  }
+}
+
+# Retrieve one ROM from ZIP data
+sub RetrieveROM($$$) {
+  my($zipdata, $key, $name) = @_;
+  my $data;
+
+  # Find ZIP data for ROM via CRC and length
+  if (not ($data = $zipdata->{$key})) {
+
+    # Handle special case CRC32 = 0x00000000 (NO GOOD DUMP KNOWN)
+    if ($key =~ /^0{8}/) {
+
+      # Convert to lower case
+      $name = lc($name);
+
+      # For each ZIP archive entry
+      foreach (values %$zipdata) {
+
+	# Does file name match?
+	if (lc($_->{name}) eq $name) {
+
+	  # File found
+	  $data = $_;
+	  last;
+	}
+      }
+    } else {
+
+      # Otherwise try inverted CRC32 (ROM NEEDS REDUMP)
+      $key =~ s/^(.{8})/sprintf "%08x", ~hex($1)/e;
+      $data = $zipdata->{$key};
+    }
+  }
+
+  return $data;
+}
+
+# Create one set per game (full split or splitted merge)
+sub DoOneSetPerGame($$$$$$) {
+  my($zipdata, $romdir, $name, $roms, $parentroms, $missingroms) = @_;
+
+  # Create ZIP archive
+  my $archivedata = CreateZipFile($romdir, $name);
+  if ($archivedata) {
+    my $mroms = [];
+
+    # For each ROM in game
+    foreach (keys %$roms) {
+
+      # Parent set not specified or ROM not in parent set?
+      if (not ($parentroms and (exists $parentroms->{$_}))) {
+	my $rom = $roms->{$_};
+	my $data;
+
+	# Find ZIP data for ROM
+	if ($data = RetrieveROM($zipdata, $_, $rom->{name})) {
+
+	  # Add data to ZIP archive
+	  last unless AddDataToZipFile($archivedata, $rom->{name}, $data);
+
+	} else {
+
+	  # ROM not found
+	  push(@$mroms, $rom);
+	}
+      }
+    }
+
+    # Finish ZIP archive
+    if (FinishZipFile($archivedata)) {
+
+      # Append missing ROMs
+      $missingroms->{$name} = $mroms;
+    }
+  }
+}
+
+# Create one set for master and all clone games (full merge)
+sub DoFullMerge($$$$$$) {
+  my($zipdata, $romdir, $name, $parentroms, $clones, $missingroms) = @_;
+  my $hashref;
+
+  # Create ZIP archive
+  my $archivedata = CreateZipFile($romdir, $name);
+  if ($archivedata) {
+    my $parentmroms = [];
+
+    # For each ROM in parent set
+    foreach (keys %$parentroms) {
+      my $rom  = $parentroms->{$_};
+      my $data;
+
+      # Find ZIP data for ROM
+      if ($data = RetrieveROM($zipdata, $_, $rom->{name})) {
+
+	# Add data to ZIP archive
+	last unless AddDataToZipFile($archivedata, $rom->{name}, $data);
+
+      } else {
+
+	# ROM not found
+	push(@$parentmroms, $rom);
+      }
+    }
+
+    # For each clone ROM set
+    foreach (keys %$clones) {
+      my $roms  = $clones->{$_};
+      my $mroms = [];
+
+      # For each ROM in game
+      foreach (keys %$roms) {
+
+	# Not in parent set?
+	if (not exists $parentroms->{$_}) {
+	  my $rom = $roms->{$_};
+	  my $data;
+
+	  # No, find ZIP data for ROM
+	  if ($data = RetrieveROM($zipdata, $_, $rom->{name})) {
+
+	    # Add data to ZIP archive
+	    last unless AddDataToZipFile($archivedata, $rom->{name}, $data);
+
+	  } else {
+
+	    # ROM not found
+	    push(@$mroms, $rom);
+	  }
+	}
+      }
+
+      # Add missing ROMs
+      $hashref->{$_} = $mroms;
+    }
+
+    # Finish ZIP archive
+    if (FinishZipFile($archivedata)) {
+
+      # Append missing ROMs
+      $missingroms->{$name} = $parentmroms;
+      foreach (keys %$hashref) {
+	$missingroms->{$_} = $hashref->{$_};
+      }
+    }
+  }
+}
+
+#-----------------------------------------------------------------------------
+#
+# COMMAND LINE OPTIONS
+#
+#-----------------------------------------------------------------------------
+# Default values
+my $mamedir = File::Spec->catdir($ENV{HOME}, 'mame');
+my %Options = (
+	       'mame-dir'    => $mamedir,
+	       'db-file'     => 'mameinfo.db',
+	      );
+
+# Parse command line options
+if (GetOptions(\%Options,
+	       'mame-dir=s', 'db-file=s', 'rom-dir=s', 'new-rom-dir=s',
+	       'full-split', 'split-merge', 'full-merge', 'clean=s',
+	       'help|h'
+	      )) {
+
+  if ($Options{help}) {
+
+    # Print usage
+    print "Usage: $0 <options> [ROM sets]\n\n";
+    print " --mame-dir <dir>    MAME directory         (Default: $mamedir)\n";
+    print " --db-file <file>    Database file          (Default: ",
+    File::Spec->catfile($mamedir, 'mameinfo.db'), ")\n";
+    print " --rom-dir <dir>     ROM sets directory     (Default: ",
+    File::Spec->catdir($mamedir, 'roms'), ")\n";
+    print " --new-rom-dir <dir> New ROM sets directory (Default: ",
+    File::Spec->catdir($mamedir, ,'newroms'), ")\n\n";
+    print "Actions:\n";
+    print " --full-split        One complete ROM set per game\n";
+    print " --split-merge       One ROM set per game, clones need parents' ROM set\n";
+    print " --full-merge        All clones in parents' ROM set\n";
+    print " --clean <parent>    Remove parent ROM files from ROM set\n\n";
+    print " --help | -h         This help page\n";
+
+  } else {
+    
+#-----------------------------------------------------------------------------
+#
+# MAIN PROGRAM
+#
+#-----------------------------------------------------------------------------
+
+    # Activate autoflush on STDOUT
+    STDOUT->autoflush(1);
+
+    # Tie DB file to hash
+    my $dbname = File::Spec->catfile($Options{'mame-dir'},
+				     $Options{'db-file'});
+    print "Opening database '$dbname'...";
+    if (tie(my %DB, 'MLDBM', $dbname, O_RDONLY)) {
+
+      print " DONE\n";
+
+      # Path to ROM set directory
+      my $romdir = $Options{'rom-dir'} ||       
+	File::Spec->catdir($Options{'mame-dir'}, 'roms');
+
+      # Path to new ROM set directory
+      my $newromdir = $Options{'new-rom-dir'} ||       
+	File::Spec->catdir($Options{'mame-dir'}, 'newroms');
+
+      # Clean operation?
+      if (my $parentname = $Options{clean}) {
+
+	# Check that parent ROM set is known
+	if (exists $DB{$parentname}) {
+	  my $parentroms = $DB{$parentname}->{roms};
+	  my $games      = $DB{$parentname}->{clones};
+
+	  print "Cleaning ROM sets with the parent ROM set $parentname.\n";
+
+	  # Select sets to process
+	  my @sets = @ARGV ? @ARGV : sort keys %$games;
+	  print scalar(@sets), " ROM set(s) to process.\n";
+
+	  # For each ROM set
+	  foreach (@sets) {
+
+	    # Does set exist?
+	    if (exists $games->{$_}) {
+	      my $game        = $games->{$_};
+	      my $missingroms;
+
+	      # Print progress information
+	      print "Reading ROM set for $_";
+
+	      # Read ZIP archive
+	      my $zipdata = ReadAllZipData($romdir, $_, $game);
+	      print " DONE\nCreating new ROM set for $_";
+
+	      DoOneSetPerGame($zipdata, $newromdir, $_, $game, $parentroms,
+			      $missingroms);
+	      print " DONE\n";
+
+	      # Print missing ROM information
+	      PrintMissingROMInfo($_, $missingroms->{$_});
+
+	    } else {
+	      print STDERR "ROM set $_ not found!\n";
+	    }
+	  }
+
+	} else {
+	  print STDERR "Parent ROM set $parentname not found!\n";
+	}
+
+      } else {
+
+	print "Splitting/Merging ROM sets.\n";
+
+	# Select sets to process
+	my @sets  = @ARGV ? @ARGV : sort keys %DB;
+	print scalar(@sets), " ROM set(s) to process.\n";
+
+	foreach (@sets) {
+
+	  # Does set exist?
+	  if (exists $DB{$_}) {
+	    my $game        = $DB{$_};
+	    my $grandparent = $game->{clone};
+	    my $clones      = $game->{clones};
+	    my $parentroms  = $game->{roms};
+	    my $missingroms = {};
+
+	    # Print progress information
+	    print "Reading ROM set(s) for $_";
+
+	    # Read all ZIP archives
+	    my $zipdata = ReadAllZipData($romdir, $_, $game);
+
+	    # Is parent itself a clone?
+	    if ($grandparent) {
+
+	      # Print special message
+	      print " Parent is a clone of ROM set $grandparent, continue reading";
+
+	      # Read grandparent ZIP archive
+	      ReadZipData($romdir, $grandparent, $zipdata);
+	    }
+
+	    print " DONE\nCreating ROM set(s) for $_";
+
+	    # Full split
+	    if ($Options{'full-split'}) {
+
+	      # Parent ROM set
+	      DoOneSetPerGame($zipdata, $newromdir, $_, $parentroms, undef,
+			      $missingroms);
+
+	      # For each clone set
+	      foreach (keys %$clones) {
+		DoOneSetPerGame($zipdata, $newromdir, $_, $clones->{$_}, undef,
+				$missingroms);
+	      }
+
+	      # Splitted merge
+	    } elsif ($Options{'split-merge'}) {
+
+	      # Parent ROM set, but not if parent is itself a clone. In this
+	      # case the parent ROM set is generated from the grandparent.
+	      unless ($grandparent) {
+		DoOneSetPerGame($zipdata, $newromdir, $_, $parentroms, undef,
+				$missingroms);
+	      }
+
+	      # For each clone set
+	      foreach (keys %$clones) {
+		DoOneSetPerGame($zipdata, $newromdir, $_, $clones->{$_},
+				$parentroms, $missingroms);
+	      }
+
+	      # Full merge
+	    } elsif ($Options{'full-merge'}) {
+	      my $file = $grandparent ? "${grandparent}_$_" : $_;
+
+	      DoFullMerge($zipdata, $newromdir, $file, $parentroms, $clones,
+			  $missingroms);
+
+	      # There is no other way to handle this special case :-(
+	      print " Please merge $file.zip with $grandparent.zip manually!" if $grandparent;
+	    }
+
+	    # Finish progress information
+	    print " DONE\n";
+
+	    # Print missing ROM information for each game
+	    foreach (keys %$missingroms) {
+	      PrintMissingROMInfo($_, $missingroms->{$_});
+
+	    }
+	  } else {
+	    print STDERR "ROM set $_ not found!\n";
+	  }
+
+	}
+      }
+
+      # All done
+      print "FINISHED.\n";
+
+      # Close DB file
+      untie %DB;
+
+    } else {
+      print STDERR "Can't open DB file '", $dbname, "'!\n";
+    }
+  }
+} else {
+  print STDERR "Error on command line!\n";
+}
+
+exit 0;
diff --git a/src/unix/contrib/tools/mame_perl-1.3/mame_parse b/src/unix/contrib/tools/mame_perl-1.3/mame_parse
new file mode 100755
index 0000000..7ae5f15
--- /dev/null
+++ b/src/unix/contrib/tools/mame_perl-1.3/mame_parse
@@ -0,0 +1,460 @@
+#!/usr/bin/perl -w
+#
+# mame_parse - Read output MAME -listinfo/ RAINE -gameinfo command from STDIN
+#              and parse it
+#
+# (c) 2000 - 2001 Stefan Becker
+#
+# It generates the following files
+#
+#  mameinfo.db  - A Berkeley DB file with all information about the ROMs
+#  mameinfo.txt - A text file with information about the supported ROMS sets
+#
+#-----------------------------------------------------------------------------
+#
+# REQUIRED PERL PACKAGES
+#
+#-----------------------------------------------------------------------------
+require 5.005_03;
+use     strict;
+use     Getopt::Long;
+use     Fcntl;
+use     IO::File;
+use     File::Spec;
+use     MLDBM qw(DB_File); # CPAN, requires
+                           #   Data::Dumper standard
+                           #   DB_File      standard if BerkeleyDB exists
+use     Parse::Lex 2.07;   # CPAN
+use     Parse::Yapp;       # CPAN, at least version 0.31 required
+#use     Parse::RecDescent  # CPAN (for alternative parser)
+#-----------------------------------------------------------------------------
+
+#-----------------------------------------------------------------------------
+#
+# GLOBAL VARIABLES
+#
+#-----------------------------------------------------------------------------
+use vars qw(%Games); # Accessed by the parser package
+
+#-----------------------------------------------------------------------------
+#
+# DATASTRUCTURES
+#
+#-----------------------------------------------------------------------------
+#
+# Hash with all available games (stored in DB_File using MLDBM)
+#
+# %Games = ( Name of game1 => Hash with game information
+#             { roms   => Hash with ROMs for this game 
+#                { Key of ROM1 => Hash with ROM data, key = crc . size
+#                   { name => File name
+#                     size => Size in bytes
+#                     crc  => CRC32 checksum
+#                   },
+#                  ... next ROM
+#                }
+#               clones => Hash with clones for this game
+#                { Name of Clone1 => Hash with ROMs for this clone
+#                   { (see above)
+#                   },
+#                  ... next clone
+#                }
+#             },
+#            ... next game
+#          );
+#
+#-----------------------------------------------------------------------------
+
+#-----------------------------------------------------------------------------
+#
+# COMMAND LINE OPTIONS
+#
+#-----------------------------------------------------------------------------
+# Default values
+my $mamedir = File::Spec->catdir($ENV{HOME}, 'mame');
+my %Options = (
+	       'mame-dir'  => $mamedir,
+	       'db-file'   => 'mameinfo.db',
+	       'text-file' => 'mameinfo.txt'
+	      );
+
+# Parse command line options
+if (GetOptions(\%Options,
+	       'mame-dir=s', 'db-file=s', 'text-file=s', 'help|h')) {
+
+  # Help requested?
+  if ($Options{help}) {
+
+    # Print usage
+    print "Usage: $0 <options>\n\n";
+    print " --mame-dir <dir>   MAME directory (Default: $mamedir)\n";
+    print " --db-file <file>   Database file  (Default: ",
+    File::Spec->catfile($mamedir, 'mameinfo.db'), ")\n";
+    print " --text-file <file> Text file      (Default: ",
+    File::Spec->catfile($mamedir, 'mameinfo.txt'), ")\n\n";
+    print " --help | -h        This help page\n\n";
+    print "The data is read from STDIN.\n"
+
+  } else {
+
+#-----------------------------------------------------------------------------
+#
+# MAIN PROGRAM
+#
+#-----------------------------------------------------------------------------
+
+    # Activate autoflush on STDOUT
+    STDOUT->autoflush(1);
+
+    # Tie DB file to hash
+    my $dbname = File::Spec->catfile($Options{'mame-dir'},
+				     $Options{'db-file'});
+    print "Creating database '$dbname'...";
+    if (tie(my %DB, 'MLDBM', $dbname, O_CREAT | O_RDWR | O_TRUNC, 0644)) {
+
+      # Open text file
+      my $txtname = File::Spec->catfile($Options{'mame-dir'},
+					$Options{'text-file'});
+      print " DONE\nCreating text file '$txtname'...";
+      if (open(FH, "> $txtname")) {
+
+	print " DONE\n";
+
+#
+# Alternative lexer/parser using Parse::RecDescent
+#
+# It takes about twice as long as the Parse::Lex/Yapp combination,
+# but as you can see it is much more concise. Once an optimizing
+# Parse::RecDescent is available this parser should be re-evaluated
+#
+# FIXME: Not checked against Raine output
+#
+# PROBLEMS: - Line numbers in error messages not correct,
+#             because of paragraph input mode
+#           - paragraph input mode requires native text format
+# 
+# Create parser
+#my $parser = Parse::RecDescent->new(<<'END_OF_SYNTAX'
+#
+#{
+#  my $name;
+#  my $ref;
+#  my $count;
+#
+#  sub AddROM($@) {
+#    my($ref, $name, $size, $crc) = @_;
+#
+#    # Create key from CRC, size and name (if CRC = 0 [NO GOOD DUMP KNOWN])
+#    $ref->{roms}->{$crc, $size, $crc =~ m/0{8}/ ? $name : ''} =
+#      {
+#        name => $name,
+#        size => $size,
+#        crc  => $crc
+#      };
+#  }
+#
+#  sub AddGame() {
+#    # Don't replace existing game!
+#    if (exists $main::Games{$name}) {
+#      print "WARNING: Duplicate ROM set '$name'!\n";
+#    } else {
+#      $main::Games{$name} = $ref;
+#    }
+#
+#    # Progress report
+#    if (($count++ % 10) == 0) {
+#      print ".";
+#
+#    }
+#  }
+#}
+#
+#start: 'game'     <commit> { undef $name; $ref = {}; } '(' info(s) ')' { AddGame(); }
+# |     'resource' <commit> { undef $name; $ref = {}; } '(' info(s) ')' { AddGame(); }
+# |     'total'    <commit>
+# |     <error>
+#
+#info: 'name'        <commit> anystring                                                                    { $name         = $item{anystring}; }
+# |    'romof'       <commit> anystring                                                                    { $ref->{clone} = $item{anystring}; }
+# |    'rom'     '(' <commit> 'name' anystring merge(?) 'size' /\d+/ 'crc' /[\da-f]{8}/ anystring(s?)  ')' { AddROM($ref, @item[5, 8, 10]); }
+# |    anystring '(' <commit> ignorestring(s) ')'
+# |    anystring ignorestring
+#
+#merge: 'merge' <commit> anystring
+#
+#ignorestring: /\"[^\\\"]*(?:\\.[^\\\"]*)*\"/
+# |            anystring
+#
+#anystring: /[\w\-\/._!]+/
+#
+#END_OF_SYNTAX
+#);
+#
+## Use paragraph mode
+#$/ = '';
+#
+## Parse input, use paragraph mode
+#my $success = 1;
+#while (<STDIN>) {
+#  $success = 0, last unless defined $parser->start($_);
+#}
+#if ($success) {
+#  # All done, free resources
+#  print " DONE\n", scalar(keys %Games), " ROM set(s) found.\n";
+#  undef $parser;
+#
+#  ... The rest is the same as for the other lexer/parser
+
+	# Create lexer which reads information from STDIN
+	# Parse::Lex->trace;
+	my $lexer = Parse::Lex->new(#
+				    # Lexer token list for the
+				    # current ambigous syntax
+				    #
+				    # Single character tokens
+				    LEFTPAREN  => '\(',
+				    RIGHTPAREN => '\)',
+
+				    # Keyword tokens
+				    CRC        => 'crc(32)?(?=[ \t\r\n])',
+				    EMULATOR   => 'emulator(?=[ \t\r\n])',
+				    GAME       => 'game(?=[ \t\r\n])',
+				    MERGE      => 'merge(?=[ \t\r\n])',
+				    NAME       => 'name(?=[ \t\r\n])',
+				    RESOURCE   => 'resource(?=[ \t\r\n])',
+				    ROMOF      => 'romof(?=[ \t\r\n])',
+				    ROM        => 'rom(?=[ \t\r\n])',
+				    SIZE       => 'size(?=[ \t\r\n])',
+				    TOTAL      => 'Total(?=[ \t\r\n])',
+
+				    # String & number tokens
+				    INTEGER    => '[0-9][0-9]*(?=[ \t\r\n])',
+				    CRC32      => '[0-9a-f]{8}(?=[ \t\r\n])',
+				    IDENTIFIER => '\w[\S]*(?=[ \t\r\n])',
+				    STRING     => '\".*\"',
+
+				    # Everything else is an error
+				    ERROR      => '.*'
+				   );
+	$lexer->skip('[ \t\n\r]+');
+	$lexer->from(\*STDIN);
+
+	# Compile syntax description
+	my $parser = Parse::Yapp->new(input => <<'END_OF_SYNTAX'
+%{
+  my $name;
+  my $ref;
+  my $count;
+
+  sub CreateROM(@) {
+    return({name => $_[0], size => $_[1], crc => $_[2]});
+  }
+
+  sub AddROM($$) {
+    my($ref, $rom) = @_;
+
+    # Create key from CRC, size and name (if CRC = 0 [NO GOOD DUMP KNOWN])
+    $ref->{roms}->{$rom->{crc}, $rom->{size},
+                   ($rom->{crc} =~ /0{8}/) ? $rom->{name} : ''} = $rom;
+  }
+
+  sub AddGame() {
+    # Don't replace existing game!
+    if (exists $main::Games{$name}) {
+      print "WARNING: Duplicate ROM set '$name'!\n";
+    } else {
+      $main::Games{$name} = $ref;
+    }
+
+    # Progress report
+    if (($count++ % 10) == 0) {
+      print ".";
+    }
+  }
+
+%}
+%%
+#
+# Parser description for current ambigous syntax
+#
+mame_info_sequence: mame_info
+  |                 mame_info_sequence mame_info
+  |                 EMULATOR LEFTPAREN raine_info_sequence RIGHTPAREN;
+
+mame_info: GAME { undef $name; $ref = {}; } LEFTPAREN info_sequence RIGHTPAREN { AddGame(); }
+  |        RESOURCE { undef $name; $ref = {}; } LEFTPAREN info_sequence RIGHTPAREN { AddGame(); }
+  |        TOTAL { $_[0]->YYAccept; };
+
+info_sequence: info
+  |            info_sequence info;
+
+info: NAME game_name                            { $name = $_[2]; }
+  |   ROMOF game_name                           { $ref->{clone} = $_[2]; }
+  |   ROM LEFTPAREN rom_info RIGHTPAREN         { AddROM($ref, $_[3]); }
+  |   ROM LEFTPAREN merge_info RIGHTPAREN       { AddROM($ref, $_[3]); }
+  |   IDENTIFIER IDENTIFIER
+  |   IDENTIFIER INTEGER
+  |   IDENTIFIER STRING
+  |   IDENTIFIER LEFTPAREN any_sequence RIGHTPAREN;
+
+game_name: IDENTIFIER
+  |        INTEGER;
+
+rom_info: NAME rom_name SIZE INTEGER CRC crc_value any_sequence { CreateROM(@_[2,4,6]); };
+
+merge_info: NAME rom_name MERGE rom_name SIZE INTEGER CRC crc_value any_sequence { CreateROM(@_[2,6,8]); };
+
+# This is what happens when the syntax is so ambigous :-(
+rom_name: IDENTIFIER
+  |       SOUND
+  |       INTEGER
+  |       CRC32;
+
+# Same here...
+crc_value: CRC32
+  |        INTEGER;
+
+any_sequence: # EMPTY
+  |           any_sequence any_element;
+
+any_element: NAME
+  |          IDENTIFIER
+  |          INTEGER
+  |          STRING;
+
+# Ignore raine info file information 
+raine_info_sequence: raine_info
+  |                  raine_info_sequence raine_info;
+
+raine_info: NAME STRING
+  |         IDENTIFIER STRING
+  |         IDENTIFIER INTEGER;
+%%
+END_OF_SYNTAX
+				     );
+        #print "Parser WARNINGS:\n", $parser->Warnings, "\n";
+	#print "Parser CONFLICTS:\n", $parser->Conflicts, "\n";
+	#print "Parser RULES:\n", $parser->ShowRules, "\n";
+	#print "Parser STATES:\n", $parser->ShowDfa, "\n";
+	#print "Parser Summary:\n", $parser->Summary, "\n";
+	$parser = $parser->Output(classname => 'MAMEInfoParser');
+	#print "$parser";
+	eval $parser;
+
+	# Create parser
+	$parser = MAMEInfoParser->new(yylex => sub {
+					# Wrapper for lexer
+					my $token = $lexer->next;
+
+					return($lexer->eoi ? '' :
+					       $token->name, $token->text);
+				      },
+				      yyerror => sub {
+					# Print better error message
+					my $parser = shift;
+
+					print "Parse error in line $.: Expected: ",
+					$parser->YYExpect,
+					" Token: ", $parser->YYCurtok,
+					" Value: ", $parser->YYCurval, "\n";
+				      });
+
+	# Execute arser
+	print "Parsing MAME ROM set information";
+	$parser->YYParse();
+
+	# Parser successful?
+	if ($parser->YYNberr() == 0) {
+	  my $count;
+
+	  # All done, free resources
+	  print " DONE\n", scalar(keys %Games), " ROM set(s) found.\n";
+	  undef $parser;
+	  undef $lexer;
+
+	  # Write list of supported sets to text file
+	  print FH scalar(keys %Games), " supported sets: ",
+	  join(' ', sort keys %Games), "\n";
+
+	  # Sort the data
+	  print "Adding clones to parent";
+	  foreach (keys %Games) {
+	    my $game = $Games{$_};
+
+	    # Is it a clone?
+	    if (exists $game->{clone}) {
+
+	      # Add it to its parent
+	      $Games{$game->{clone}}->{clones}->{$_} = $game->{roms};
+	    }
+
+	    # Progress report
+	    if (($count++ % 10) == 0) {
+	      print ".";
+	    }
+	  }
+
+	  # Remove pure clones
+	  print " DONE\nRemoving clones";
+	  foreach (keys %Games) {
+	    my $game = $Games{$_};
+
+	    # Is it a clone without any clones?
+	    if (exists $game->{clone} && not exists $game->{clones}) {
+
+	      # Yes, remove it from list
+	      delete $Games{$_};
+	    }
+
+	    # Progress report
+	    if (($count++ % 10) == 0) {
+	      print ".";
+	    }
+	  }
+	  print " DONE\n", scalar(keys %Games), " parent ROM set(s) found.\n";
+
+	  # Write master/clone games to text file
+	  foreach (sort keys %Games) {
+	    my $game   = $Games{$_};
+	    my $clones = exists $game->{clones} ? $game->{clones} : undef;
+	    print FH "Clones for $_: ", join(' ', sort keys %$clones), "\n";
+	  }
+
+	  # Move data to DB
+	  print "Moving data to database";
+	  $count = 0;
+	  foreach (sort keys %Games) {
+
+	    # Move one entry to DB
+	    $DB{$_} = $Games{$_};
+	    delete $Games{$_};
+
+	    # Progress report
+	    if (($count++ % 10) == 0) {
+	      print ".";
+	    }
+	  }
+	  print " DONE\n";
+	}
+
+	# Close text file
+	close(FH) or die "$!";
+	print "Text file closed.\n";
+
+      } else {
+	print STDERR "Can't open text file '$txtname'!\n";
+      }
+
+      # Close DB
+      untie %DB or die "$!";
+      print "Database closed.\n";
+
+    } else {
+      print STDERR "Can't open DB file $dbname!\n";
+    }
+  }
+} else {
+  print STDERR "Error on command line!\n";
+}
+
+exit 0;
diff --git a/src/unix/contrib/tools/mame_perl-1.3/mame_sets b/src/unix/contrib/tools/mame_perl-1.3/mame_sets
new file mode 100755
index 0000000..8b898ce
--- /dev/null
+++ b/src/unix/contrib/tools/mame_perl-1.3/mame_sets
@@ -0,0 +1,158 @@
+#!/usr/bin/perl -w
+#
+# mame_sets - Check for missing, deleted, new and changed MAME ROM sets
+#
+# (c) 2000  Stefan Becker
+#
+# It reads the information from the text file 'mameinfo.txt' which is
+# generated by mame_parse. It uses the ROM directory as reference and
+# the beta ROM directory for the changes. 
+#
+#-----------------------------------------------------------------------------
+#
+# REQUIRED PERL PACKAGES
+#
+#-----------------------------------------------------------------------------
+require 5.005_03;
+use     strict;
+use     Getopt::Long;
+use     IO::Handle;
+use     File::Spec;
+#-----------------------------------------------------------------------------
+
+#-----------------------------------------------------------------------------
+#
+# COMMAND LINE OPTIONS
+#
+#-----------------------------------------------------------------------------
+# Default values
+my $mamedir = File::Spec->catdir(exists $ENV{HOME} ? $ENV{HOME} : '.', 'mame');
+my %Options = (
+	       'mame-dir'  => $mamedir,
+	       'text-file' => 'mameinfo.txt',
+	       'compare'   => 'zipcmp >/dev/null'
+	      );
+
+# Parse command line options
+if (GetOptions(\%Options,
+	       'mame-dir=s', 'text-file=s', 'rom-dir=s', 'beta-rom-dir=s',
+	       'compare=s', 'help|h')) {
+
+  # Help requested?
+  if ($Options{help}) {
+
+    # Print usage
+    print "Usage: $0 <options>\n\n";
+    print " --mame-dir <dir>     MAME directory          (Default: $mamedir)\n";
+    print " --text-file <file>   Text file               (Default: ",
+    File::Spec->catfile($mamedir, 'mameinfo.txt'), ")\n";
+    print " --rom-dir <dir>      ROM sets directory      (Default: ",
+    File::Spec->catdir($mamedir, 'roms'), ")\n";
+    print " --beta-rom-dir <dir> Beta ROM sets directory (Default: ",
+    File::Spec->catdir($mamedir, ,'beta', 'roms'), ")\n";
+    print " --compare <command>  ZIP compare command     (Default: zipcmp >/dev/null)\n\n";
+    print " --help | -h          This help page\n";
+
+  } else {
+
+#-----------------------------------------------------------------------------
+#
+# MAIN PROGRAM
+#
+#-----------------------------------------------------------------------------
+
+    # Activate autoflush on STDOUT
+    STDOUT->autoflush(1);
+
+    # Path to ROM set directory
+    my $nonbetapath = $Options{'rom-dir'} ||
+      File::Spec->catdir($Options{'mame-dir'}, 'roms');
+
+    # Path to Beta ROM set directory
+    my $betapath = $Options{'beta-rom-dir'} ||
+      File::Spec->catdir($Options{'mame-dir'}, 'beta', 'roms');
+
+    # Hashes
+    my %supported;
+    my %nonbeta;
+    my %beta;
+
+    # Read supported sets list from text file
+    open(FH, "< " . File::Spec->catfile($Options{'mame-dir'},
+					$Options{'text-file'})) or die $!;
+    while (<FH>) {
+      if (/supported sets: (.*)$/) {
+
+	# Perform Schwartzian Transformation on string
+	grep { $supported{$_}++ } split(' ', $1);
+
+	# Ignore the rest of the file
+	last;
+      }
+    }
+    close(FH) or die $!;
+    #print scalar(keys %supported), ": ", join(' ', keys %supported), "\n";
+
+    # Scan the ROM sets directory for currently existing sets
+    opendir(DIR, $nonbetapath) or die $!;
+    grep { $nonbeta{$_}++ } map { /(.*)\.zip$/ } grep { /^[^.]/ } readdir(DIR);
+    closedir DIR or die $!;
+    #print scalar(keys %nonbeta), ": ", join(' ', keys %nonbeta), "\n";
+
+    # Scan the Beta ROM sets directory for currently existing sets
+    opendir(DIR, $betapath) or die $!;
+    grep { $beta{$_}++ } map { /(.*)\.zip$/ } grep { /^[^.]/ } readdir(DIR);
+    closedir DIR or die $!;
+    #print scalar(keys %beta), ": ", join(' ', keys %beta), "\n";
+
+    # What sets are missing?
+    print "Missing sets         : ", join(' ',
+					  sort
+					  grep { not (exists $nonbeta{$_} or
+						      exists $beta{$_}) }
+					  keys %supported), "\n";
+
+    # What sets from the last non-beta were deleted ?
+    print "Deleted non-beta sets: ", join(' ',
+					  sort
+					  grep { not exists $supported{$_} }
+					  keys %nonbeta), "\n";
+
+    # What sets from older beta were deleted?
+    print "Deleted beta sets    : ", join(' ',
+					  sort
+					  grep { not exists $supported{$_} }
+					  keys %beta), "\n";
+
+    # What sets are new in this beta?
+    my $new = 0;
+    print "New sets             : ", join(' ',
+					  sort
+					  grep { exists $supported{$_}   and
+						 not exists $nonbeta{$_} and
+						 ++$new }
+					  keys %beta), "\n";
+
+    # What sets were modified from the last non-beta?
+    my $modified = 0;
+    print "Modified sets        :";
+    foreach (sort
+	     grep { exists $supported{$_} and exists $nonbeta{$_} }
+	     keys %beta) {
+      if (system($Options{compare}                     . " " .
+		 File::Spec->catfile($nonbetapath, $_) . ".zip " .
+		 File::Spec->catfile($betapath, $_)    . ".zip") != 0) {
+	print " $_";
+	$modified++;
+      }
+    }
+    print "\n";
+
+    # Print summary info
+    print $new + $modified, " changed sets = $new new + $modified modified\n";
+  }
+} else {
+  print STDERR "Error on command line!\n";
+}
+
+exit 0;
diff --git a/src/unix/contrib/tools/mame_perl-1.3/zipcmp b/src/unix/contrib/tools/mame_perl-1.3/zipcmp
new file mode 100755
index 0000000..be21a60
--- /dev/null
+++ b/src/unix/contrib/tools/mame_perl-1.3/zipcmp
@@ -0,0 +1,166 @@
+#!/usr/bin/perl -w
+#
+# zipcmp - Compare ZIP archives
+#
+# (c) 2000  Stefan Becker
+#
+# Compare the two ZIP archives specified on the command line. The two
+# archives are considered equal if each entry (= CRC + filesize) exists
+# in both archives.
+#
+# Returns 0 on equality, >0 (plus differences on STDOUT) otherwise
+#
+#-----------------------------------------------------------------------------
+#
+# REQUIRED PERL PACKAGES
+#
+#-----------------------------------------------------------------------------
+require 5.004;
+use     strict;
+use     IO::File;
+#-----------------------------------------------------------------------------
+
+#-----------------------------------------------------------------------------
+#
+# DATA STRUCTURES
+#
+#-----------------------------------------------------------------------------
+#
+# Hash with ZIP archive data
+#
+# $zipdata = { Key of file1 (key = crc . size) => Name
+#              ... next file
+#            };
+#
+#-----------------------------------------------------------------------------
+
+#-----------------------------------------------------------------------------
+#
+# SUB ROUTINES
+#
+#-----------------------------------------------------------------------------
+# Read data from one ZIP archive
+sub ReadZipData($$) {
+  my($name, $zipdata) = @_;
+  my $handle          = new IO::File;
+
+#  print "Reading from $name\n";
+
+  # Open file for reading
+  if ($handle->open("< $name")) {
+
+    # Make sure we read in binary mode
+    binmode $handle;
+
+    # For each local directory in file
+    while (1) {
+      my $ok;
+      my $data;
+
+      # Read local directory file
+      if ($handle->read($data, 30) == 30) {
+
+        #
+	# ZIP archive: Local directory structure
+	#
+	# All data is little endian and unsigned
+	#
+	#   0  char  magic[4]               "PK\x03\x04"
+	#   4  short version required
+	#   6  short flags
+	#   8  short compression method
+	#  10  long  time
+	#  14  long  CRC32 checksum of original file
+	#  18  long  compressed data size
+	#  22  long  original file size
+	#  26  short length of file name
+	#  28  short length of extension field
+	# ---
+	#  30  <local directory structure>
+	#      <file name>
+	#      <extension>
+	#      <compressed data>
+        #
+	my ($magic, $ver, $flags, $method, $time, $crc32,
+	    $compsize, $origsize, $namelen, $extlen) =
+	      unpack("a4vvvVVVVvv", $data);
+
+	# Check magic for local directory
+	if ($magic eq "PK\x03\x04") {
+
+	  # Read name from file
+	  if ($handle->read($data, $namelen) == $namelen) {
+	    my $name = unpack("a*", $data);
+
+	    # Skip extension field and compressed data
+	    $handle->seek($extlen + $compsize, SEEK_CUR);
+
+	    # Add data to hash
+	    $zipdata->{sprintf("%08x%u", $crc32, $origsize)} = $name;
+
+	    # No errors
+	    $ok = 1;
+	  }
+	}
+      }
+      
+      # EOF in data or no local directory found
+      last unless $ok;
+    }
+
+    # Close file
+    $handle->close;
+
+  } else {
+    die "Can't open ZIP file: $!";
+  }
+}
+
+# Compare two archives
+sub Compare($$$) {
+  my($name, $ref1, $ref2) = @_;
+  my $rc                  = 0;
+
+  # Find those files which are only in archive 1 but not in archive 2
+  my $string = join(' ',
+		    map  { $ref1->{$_} }
+		    grep { not exists $ref2->{$_} }
+		    keys %$ref1);
+
+  # Are there any differences?
+  if (length($string)) {
+    print "Only in $name: $string\n";
+    $rc = 1;
+  }
+
+  return($rc);
+}
+
+#-----------------------------------------------------------------------------
+#
+# MAIN PROGRAM
+#
+#-----------------------------------------------------------------------------
+
+my $rc = 10;
+
+# Check command line
+if (@ARGV == 2) {
+  my $ref1 = {};
+  my $ref2 = {};
+
+  # Read ZIP archives
+  ReadZipData($ARGV[0], $ref1);
+  ReadZipData($ARGV[1], $ref2);
+
+#  print join(' ', sort keys %$ref1), "\n";
+#  print join(' ', sort keys %$ref2), "\n";
+
+  # Compare archives
+  $rc = Compare($ARGV[0], $ref1, $ref2) + Compare($ARGV[1], $ref2, $ref1);
+
+} else {
+  print STDERR "Usage: $0 <ZIP archive 1> <ZIP archive 2>\n";
+}
+
+exit $rc;
diff --git a/src/unix/contrib/tools/mame_perl-1.3/zipfix b/src/unix/contrib/tools/mame_perl-1.3/zipfix
new file mode 100755
index 0000000..758e748
--- /dev/null
+++ b/src/unix/contrib/tools/mame_perl-1.3/zipfix
@@ -0,0 +1,333 @@
+#!/usr/bin/perl -w
+#
+# zipfix - Salvage truncated zip archives
+#
+# (c) 2000  Stefan Becker
+#
+# Try to salvage as much data as possible from a ZIP archive and create
+# a new correct ZIP archive from it. The original ZIP archive X is renamed
+# to X.orig.
+#
+#-----------------------------------------------------------------------------
+#
+# REQUIRED PERL PACKAGES
+#
+#-----------------------------------------------------------------------------
+require 5.0004;
+use     strict;
+use     English;
+use     FileHandle;
+#-----------------------------------------------------------------------------
+
+#-----------------------------------------------------------------------------
+#
+# Salvage procedure
+#
+#-----------------------------------------------------------------------------
+# Read one compressed file plus information from the old ZIP archive
+# and copy it to the new ZIP archuve. Create an entry to the central
+# directory from the discovered information and add it to the list.
+sub CopyOneCompressedFile($$$$)
+  {
+    my ($oldfile, $newfile, $offset, $dirref) = @_;
+    my $data;
+    my $length = 0;
+
+    # Read local dir from old file
+    if ($oldfile->read($data, 30) == 30) {
+
+      #
+      # ZIP archive: Local directory structure
+      #
+      # All data is little endian and unsigned
+      #
+      #   0  char  magic[4]               "PK\x03\x04"
+      #   4  short version required
+      #   6  short flags
+      #   8  short compression method
+      #  10  long  time
+      #  14  long  CRC32 checksum of original file
+      #  18  long  compressed data size
+      #  22  long  original file size
+      #  26  short length of file name
+      #  28  short length of extension field
+      # ---
+      #  30  <local directory structure>
+      #      <file name>
+      #      <extension>
+      #      <compressed data>
+      #
+      my ($magic, $ver, $flags, $method, $time, $crc32,
+          $compsize, $origsize, $namelen, $extlen) =
+            unpack("a4vvvVVVVvv", $data);
+
+      # Check magic for local directory
+      if ($magic eq "PK\x03\x04") {
+
+        # Copy it to new file
+        if ($newfile->write($data, 30)) {
+
+          # Read name from old file
+          if ($oldfile->read($data, $namelen) == $namelen) {
+
+            # Copy it to new file
+            if ($newfile->write($data, $namelen)) {
+              my $vardata  = $data;
+              my $filename = unpack("a*", $data);
+
+              # Read extension from old file
+              if ($oldfile->read($data, $extlen) == $extlen) {
+
+                # Copy it to new file
+                if ($newfile->write($data, $extlen)) {
+
+                  # Add extension to variable data
+                  $vardata .= $data;
+
+                  # Read compressed data
+                  if ($oldfile->read($data, $compsize) == $compsize) {
+
+                    # Write it to new file
+                    if ($newfile->write($data, $compsize)) {
+
+                      # Data copied, print progress report
+                      write;
+
+                      # File table header
+                      format STDOUT_TOP =
+Size       Compr.     CRC-32   File Name
+--------------------------------------------------------------------
+.
+
+                      # File table entry
+                      format STDOUT =
+@>>>>>>>>> @>>>>>>>>> @>>>>>>> @<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
+$origsize, $compsize,unpack("H8", pack("N", $crc32)),$filename
+.
+
+                      #
+                      # ZIP archive: Central directory structure
+                      #
+                      # All data is little endian and unsigned
+                      #
+                      #   0  char  magic[4]               "PK\x01\x02"
+                      #   4  short version made
+                      #   6  short version required
+                      #   8  short flags
+                      #  10  short compression method
+                      #  12  long  time
+                      #  16  long  CRC32 checksum of original file
+                      #  20  long  compressed data size
+                      #  24  long  original file size
+                      #  28  short length of file name
+                      #  30  short length of extension field
+                      #  32  short file comment length
+                      #  34  short disk number start
+                      #  36  short internal file attributes
+                      #  38  long  external file attributes
+                      #  42  long  offset of local directory from file start
+                      # ---
+                      #  46  <central directory structure>
+                      #      <file name>
+                      #      <extension>
+                      #      <file comment ???>
+                      #
+                      # Append entry to central directory array
+                      push(@$dirref,
+			   "PK\x01\x02" .
+			   pack("vvvvVVVVvvvvvVV",
+				$ver, $ver, $flags, $method, $time,
+				$crc32, $compsize, $origsize,
+				$namelen, $extlen,
+				0, 0, 0, 0, $offset) .
+			   $vardata);
+		
+                      # Return length of zip file part
+                      $length = 30 + $namelen + $extlen + $compsize;
+
+                    } else {
+                      print "Can't write compressed data!";
+                      $length = -1;
+                    }
+                  } else {
+                    print "EOF in compressed data (File: $filename [$compsize bytes]).\n";
+                  }
+                } else {
+                  print "Can't write extension field!";
+                  $length = -1;
+                }
+              } else {
+                print "EOF in extension field (File: $filename [$extlen bytes]).\n";
+              }
+            } else {
+              print "Can't write file name!";
+              $length = -1;
+            }
+          } else {
+            print "EOF in file name [$namelen bytes].\n";
+          }
+        } else {
+          print "Can't write local dir!";
+          $length = -1;
+        }
+      } else {
+        print "Next entry is not a local directory.\n";
+      }
+    } else {
+      print "EOF in local directory.\n";
+    }
+
+    return $length;
+  }
+
+#-----------------------------------------------------------------------------
+#
+# MAIN PROGRAM
+#
+#-----------------------------------------------------------------------------
+my $oldname;
+
+# For each file on the command line
+foreach $oldname (@ARGV) {
+  my $oldfile = new FileHandle;
+
+  # Open old file
+  if ($oldfile->open($oldname, "r")) {
+    my $newfile = new FileHandle;
+    my $newname = $oldname . $PID;
+
+    # Make sure we read in binary mode
+    binmode $oldfile;
+
+    # Open new file
+    if ($newfile->open($newname, "w")) {
+      my $offset   = 0;
+      my @dir;
+      my $position;
+
+      # Make sure we write in binary mode
+      binmode $newfile;
+
+      # Copy compressed files
+      while (1) {
+
+        # Get current file position
+        $position = $newfile->getpos();
+
+        # Copy one compressed file
+        my $newlength = CopyOneCompressedFile($oldfile, $newfile,
+                                              $offset, \@dir);
+
+        # Write error?
+        if ($newlength < 0) {
+          $offset = -1;
+          last;
+        }
+
+        # EOF reached?
+        if ($newlength == 0) {
+          last;
+        }
+
+        # Next compressed file
+        $offset += $newlength;
+      }
+
+      # No write error?
+      if ($offset > 0) {
+        my $files     = $#dir + 1;
+        my $dirlength;
+
+        # Progress report
+        print "Found $files file(s), regenerating central directory structure.\n";
+
+        # Move file pointer to end of valid data
+        $newfile->setpos($position);
+
+        # For each entry in the central directory
+        while ($#dir >= 0) {
+
+          # Get next entry from array
+          my $data = shift(@dir);
+          my $elen = length($data);
+
+          # Write entry to new file
+          if ($newfile->write($data, $elen) == 0) {
+            print "Can't write central directory entry!";
+            $offset = -1;
+            last;
+          }
+
+          # Add to directory length
+          $dirlength += $elen;
+        }
+
+        # Write error?
+        if ($offset > 0) {
+
+	  #
+	  # ZIP archive: End of archive structure
+	  #
+	  # All data is little endian and unsigned
+	  #
+	  #   0  char  magic[4]               "PK\x05\x06"
+	  #   4  short disk number
+	  #   6  short disk number where central directory starts ???
+	  #   8  short number of entries in the current central directory
+	  #  10  short total number of entries in all directories ???
+	  #  12  long  size of current central directory
+	  #  16  long  offset of central directory from file start
+	  #  20  short archive comment length
+	  # ---
+	  #  22  <end of archive structure>
+	  #      <zip file comment ???>
+	  #
+          # Write end of archive structure to the new file
+	  if ($newfile->write("PK\x05\x06" .
+			      pack("vvvvVVv",
+				   0, 0,
+				   $files, $files, $dirlength, $offset,
+				   0),
+			      22)) {
+
+            # Close files
+            $newfile->close();
+            $oldfile->close();
+
+            # Rename files
+	    unlink("$oldname.orig");
+            rename($oldname, "$oldname.orig");
+            rename($newname, $oldname);
+
+            # We did it!
+            print "Zip archive salvaged!\n";
+
+          } else {
+            print "Couldn't write end of zip file structure!";
+            $offset = -1;
+          }
+        }
+      }
+
+      # Write error?
+      if ($offset < 0) {
+
+        # Remove new file
+        print " ABORTING\n";
+        $newfile->close();
+        unlink($newname);
+      }
+
+    } else {
+      print "Can't open file $newname for writing!\n";
+    }
+
+    # Close old file
+    $oldfile->close();
+
+  } else {
+    print "Can't open file $oldname for reading!\n";
+  }
+}
+
+exit 0;
diff --git a/src/unix/contrib/tools/mamecds-1.0/Makefile b/src/unix/contrib/tools/mamecds-1.0/Makefile
new file mode 100644
index 0000000..49d0a14
--- /dev/null
+++ b/src/unix/contrib/tools/mamecds-1.0/Makefile
@@ -0,0 +1,36 @@
+# Edited for Debian GNU/Linux
+DESTDIR =
+
+# Where to put binary on 'make install'
+BIN = $(DESTDIR)/usr/bin
+
+CFLAGS = -g -Wall -Wshadow -Wpointer-arith -Wcast-qual -Wcast-align -Wstrict-prototypes -I./include
+OBJECTS = $(BINDIR)/gamelist.o $(BINDIR)/mamecds.o $(BINDIR)/html.o $(BINDIR)/main.o
+SRCDIR = src
+INCDIR = include
+BINDIR = bin
+
+
+all: $(BINDIR)/mamecds
+
+clean:
+	rm -f $(BINDIR)/mamecds $(BINDIR)/*.o
+
+install:
+	install $(BINDIR)/mamecds $(BIN)
+
+$(BINDIR)/gamelist.o: $(SRCDIR)/gamelist.c $(INCDIR)/gamelist.h
+	gcc ${CFLAGS} -c $(SRCDIR)/gamelist.c -o $(BINDIR)/gamelist.o
+	
+$(BINDIR)/mamecds.o: $(SRCDIR)/mamecds.c $(INCDIR)/mamecds.h
+	gcc ${CFLAGS} -c $(SRCDIR)/mamecds.c -o $(BINDIR)/mamecds.o
+	
+$(BINDIR)/html.o: $(SRCDIR)/html.c $(INCDIR)/html.h
+	gcc ${CFLAGS} -c $(SRCDIR)/html.c -o $(BINDIR)/html.o
+	
+$(BINDIR)/main.o: $(SRCDIR)/main.c
+	gcc ${CFLAGS} -c $(SRCDIR)/main.c -o $(BINDIR)/main.o
+	
+$(BINDIR)/mamecds: ${OBJECTS}
+	gcc ${CFLAGS} ${OBJECTS} -o $(BINDIR)/mamecds
+	
diff --git a/src/unix/contrib/tools/mamecds-1.0/build-stamp b/src/unix/contrib/tools/mamecds-1.0/build-stamp
new file mode 100644
index 0000000..e69de29
diff --git a/src/unix/contrib/tools/mamecds-1.0/configure-stamp b/src/unix/contrib/tools/mamecds-1.0/configure-stamp
new file mode 100644
index 0000000..e69de29
diff --git a/src/unix/contrib/tools/mamecds-1.0/include/gamelist.h b/src/unix/contrib/tools/mamecds-1.0/include/gamelist.h
new file mode 100644
index 0000000..7f1fa32
--- /dev/null
+++ b/src/unix/contrib/tools/mamecds-1.0/include/gamelist.h
@@ -0,0 +1,81 @@
+#ifndef __MAMELIST_H__
+#define __MAMELIST_H__
+
+#include <sys/stat.h>
+#include <sys/types.h>
+#include <fcntl.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include "utils.h"
+
+#define GAME_1      0
+#define GAME_A      1
+#define GAME_B      2
+#define GAME_C      3
+#define GAME_D      4
+#define GAME_E      5
+#define GAME_F      6
+#define GAME_G      7
+#define GAME_H      8
+#define GAME_I      9
+#define GAME_J      10
+#define GAME_K      11
+#define GAME_L      12
+#define GAME_M      13
+#define GAME_N      14
+#define GAME_O      15
+#define GAME_P      16
+#define GAME_Q      17
+#define GAME_R      18
+#define GAME_S      19
+#define GAME_T      20
+#define GAME_U      21
+#define GAME_V      22
+#define GAME_W      23
+#define GAME_X      24
+#define GAME_Y      25
+#define GAME_Z      26
+#define GAME_NEOGEO 27
+
+typedef struct mamegame
+{
+	char base[8+1];				/* Base del juego (para .zip, .jpg)		*/
+	char nombre[MAXCAD];		/* Nombre real del juego				*/
+	char anyo[5+1];				/* Ao del juego						*/
+	char fabricante[MAXCAD];	/* Fabricante del juego					*/
+
+	char cloneof[8+1];			/* "base" es clonico de "clone"			*/
+	char clones[50][8+1];		/* clonicos de "base"					*/
+	char samplesrom[MAXCAD];	/* Fichero con los samples del juego	*/
+	char artwork[MAXCAD];		/* Fichero con el artwork del juego		*/
+	char titleimage[MAXCAD];	/* Fichero con la imagen del titulo		*/
+	char gameimage[MAXCAD];		/* Fichero con la imagen del juego		*/
+
+	int hasgame;				/* Existe el fichero de roms?			*/
+	int isclone;				/* Es un clonico?						*/
+	int hasclones;				/* Tiene juegos clonicos?				*/
+	int hastitle;				/* Tiene imagen del titulo?			*/
+	int hasimage;				/* Tiene imagen del juego?				*/
+	int hassamples;				/* Tiene fichero de samples?			*/
+	int hasartwork;				/* Tiene fichero de artwork?			*/
+
+	int tipo;					/* MAME, NEOGEO, ...					*/
+	int tamanyo;				/* Tamao en bytes rom+samples+artwork+html+imagen+titulo */
+	int tamanyorom;				/* Tamao en bytes rom */
+	int tamanyosamples;			/* Tamao en bytes samples */
+	int tamanyoartwork;			/* Tamao en bytes artwork */
+	int numerocd;				/* Numero de CD en el que esta incluido	*/
+
+	struct mamegame *next;
+} MAMEGAME;
+
+int njuegos_letra[GAME_NEOGEO+1]; /* GAME_NEOGEO=27 */
+int njuegos_mame;
+int njuegos_neogeo;
+
+struct mamegame *MakeGameList(char *mame);
+int PrintGameList(struct mamegame *lista);
+int cuenta_juegos(struct mamegame *lista, int tipo, int ncd);
+
+#endif
diff --git a/src/unix/contrib/tools/mamecds-1.0/include/html.h b/src/unix/contrib/tools/mamecds-1.0/include/html.h
new file mode 100644
index 0000000..f976049
--- /dev/null
+++ b/src/unix/contrib/tools/mamecds-1.0/include/html.h
@@ -0,0 +1,12 @@
+#ifndef __HTML_H__
+#define __HTML_H__
+
+#include "utils.h"
+#include "gamelist.h"
+
+#define JUEGOS_PAGINA	25
+/*#define ANCHO_IMAGEN	304*/
+
+int MakeHTML (struct mamegame *lista, int tipo, int ncd);
+
+#endif
diff --git a/src/unix/contrib/tools/mamecds-1.0/include/mamecds.h b/src/unix/contrib/tools/mamecds-1.0/include/mamecds.h
new file mode 100644
index 0000000..2086a0b
--- /dev/null
+++ b/src/unix/contrib/tools/mamecds-1.0/include/mamecds.h
@@ -0,0 +1,31 @@
+#ifndef __MAMECDS_H__
+#define __MAMECDS_H__
+
+#include "utils.h"
+#include "gamelist.h"
+
+/* 60 minutos, 75 bloques por segundo, 2048 bytes por bloque */
+#define MULTIPLIERB     1
+#define MULTIPLIERK     1024
+#define MULTIPLIERM     (1024*1024)
+#define MULTIPLIERm     (60*75*2048)
+
+/* Para el retorno de MakeCD */
+#define LASTCD			0
+#define MORECDS			1
+
+
+unsigned long	tamanyocd;		/* Tamanyo de la imagen ISO a generar 	*/
+int	neogeocd;		/* Flag de creacion de CD's de neogeo	*/
+int	mamecd;			/* Flag de creacion de CD's de mame		*/
+int generatecds;	/* Flag para generar las ISOS 1 si 0 no	*/
+int generatelist;	/* Flag para generar la lista de juegos	*/
+int generatefulllist;	/* Flag para generar la lista completa de juegos	*/
+
+char mamebin[MAXCAD];
+char listgamesarg[MAXCAD];
+char listclonesarg[MAXCAD];
+
+int CreateCDS (struct mamegame *lista, int tipo);
+
+#endif
diff --git a/src/unix/contrib/tools/mamecds-1.0/include/utils.h b/src/unix/contrib/tools/mamecds-1.0/include/utils.h
new file mode 100644
index 0000000..7f3c6d9
--- /dev/null
+++ b/src/unix/contrib/tools/mamecds-1.0/include/utils.h
@@ -0,0 +1,50 @@
+#ifndef __UTILS_H__
+#define __UTILS_H__
+
+#define	OK		0
+#define ERROR	-1
+
+#define MAXCAD		128
+#define MAXJUEGOS	5000
+
+#define MAME	1
+#define NEOGEO	2
+#define FULL	4
+
+/****************************************/
+/*										*/
+/*	basedir								*/
+/*		tmpdir							*/
+/*			cddir						*/
+/*				romsdir					*/
+/*					neogeodir			*/
+/*					mamedir				*/
+/*					samplesdir			*/
+/*					artworkdir			*/
+/*				listadir				*/
+/*					imagesdir			*/
+/*					titlesdir			*/
+/*										*/
+/****************************************/
+char srcbasedir[MAXCAD];	/* Directorio roms:				"/home/carlitos/roms"		*/
+
+char srcromsdir[MAXCAD];	/* Directorio neogeo/mame):		"/home/carlitos/roms"		*/
+char srclistdir[MAXCAD];	/* Directorio con la lista:		"/home/lista"				*/
+char dstromsdir[MAXCAD];	/* Directorio completo roms:	"./tmp/mame-01/roms"		*/
+char dstlistdir[MAXCAD];	/* Directorio completo lista:	"./tmp/mame-01/lista"		*/
+
+char basedir[MAXCAD];		/* Directorio base:				"."							*/
+char tmpdir[MAXCAD];		/* Directorio temporal:			"tmp"						*/
+char cddir[MAXCAD];			/* Directorio del cd:			"neogeo-01"					*/
+char romsdir[MAXCAD];		/* Directorio de roms general: 	"roms" 						*/
+char neogeodir[MAXCAD];		/* Directorio de roms neogeo:	"neogeo"					*/
+char mamedir[MAXCAD];		/* Directorio de roms mame:		"mame"						*/
+char samplesdir[MAXCAD];	/* Directorio de samples:		"samples"					*/
+char artworkdir[MAXCAD];	/* Directorio de artwork:		"artwork"					*/
+char listdir[MAXCAD];		/* Directorio con la lista:		"lista"						*/
+char imagesdir[MAXCAD];		/* Directorio de imagenes:		"images"					*/
+char titlesdir[MAXCAD];		/* Directorio de imagenes:		"titulos"					*/
+
+char versionmame[MAXCAD];	/* Version del mame */
+
+#endif
diff --git a/src/unix/contrib/tools/mamecds-1.0/src/gamelist.c b/src/unix/contrib/tools/mamecds-1.0/src/gamelist.c
new file mode 100644
index 0000000..6be0efa
--- /dev/null
+++ b/src/unix/contrib/tools/mamecds-1.0/src/gamelist.c
@@ -0,0 +1,479 @@
+#include <stdio.h>
+
+#include "utils.h"
+#include "mamecds.h"
+#include "gamelist.h"
+
+int cuenta_juegos (struct mamegame *lista, int tipo, int ncd)
+{   
+	int i;
+	struct mamegame *juego;
+
+	njuegos_mame=0;
+	njuegos_neogeo=0;
+
+	for(i=GAME_1; i<=GAME_Z; i++) 
+	{
+		njuegos_letra[i]=0;
+	}
+	njuegos_letra[GAME_NEOGEO]=0;
+
+	if ((tipo==MAME)||(tipo==FULL))
+	{
+		juego=lista;
+		while(juego!=NULL)
+		{
+			if (tipo==FULL) juego->numerocd=ncd;
+
+			if (((juego->tipo==MAME) || (juego->tipo==FULL)) && (juego->numerocd==ncd))
+			{
+				if  ( (juego->nombre[0]=='0') || (juego->nombre[0]=='1') || (juego->nombre[0]=='2')
+						||(juego->nombre[0]=='3') || (juego->nombre[0]=='4') || (juego->nombre[0]=='5')
+						||(juego->nombre[0]=='6') || (juego->nombre[0]=='7') || (juego->nombre[0]=='8')
+						||(juego->nombre[0]=='9') || (juego->nombre[0]=='\''))
+					njuegos_letra[GAME_1]++;
+
+				if (juego->nombre[0]=='A') njuegos_letra[GAME_A]++;
+				if (juego->nombre[0]=='B') njuegos_letra[GAME_B]++;
+				if (juego->nombre[0]=='C') njuegos_letra[GAME_C]++;
+				if (juego->nombre[0]=='D') njuegos_letra[GAME_D]++;
+				if (juego->nombre[0]=='E') njuegos_letra[GAME_E]++;
+				if (juego->nombre[0]=='F') njuegos_letra[GAME_F]++;
+				if (juego->nombre[0]=='G') njuegos_letra[GAME_G]++;
+				if (juego->nombre[0]=='H') njuegos_letra[GAME_H]++;
+				if (juego->nombre[0]=='I') njuegos_letra[GAME_I]++;
+				if (juego->nombre[0]=='J') njuegos_letra[GAME_J]++;
+				if (juego->nombre[0]=='K') njuegos_letra[GAME_K]++;
+				if (juego->nombre[0]=='L') njuegos_letra[GAME_L]++;
+				if (juego->nombre[0]=='M') njuegos_letra[GAME_M]++;
+				if (juego->nombre[0]=='N') njuegos_letra[GAME_N]++;
+				if (juego->nombre[0]=='O') njuegos_letra[GAME_O]++;
+				if (juego->nombre[0]=='P') njuegos_letra[GAME_P]++;
+				if (juego->nombre[0]=='Q') njuegos_letra[GAME_Q]++;
+				if (juego->nombre[0]=='R') njuegos_letra[GAME_R]++;
+				if (juego->nombre[0]=='S') njuegos_letra[GAME_S]++;
+				if (juego->nombre[0]=='T') njuegos_letra[GAME_T]++;
+				if (juego->nombre[0]=='U') njuegos_letra[GAME_U]++;
+				if (juego->nombre[0]=='V') njuegos_letra[GAME_V]++;
+				if (juego->nombre[0]=='W') njuegos_letra[GAME_W]++;
+				if (juego->nombre[0]=='X') njuegos_letra[GAME_X]++;
+				if (juego->nombre[0]=='Y') njuegos_letra[GAME_Y]++;
+				if (juego->nombre[0]=='Z') njuegos_letra[GAME_Z]++;
+
+				njuegos_mame++;
+			}
+			juego=juego->next;
+		}
+#ifdef DEBUG_COUNT
+		printf("Mame %i\n",njuegos_mame);
+#endif
+	}
+
+	if ((tipo==NEOGEO)||(tipo==FULL))
+	{
+		juego=lista;
+		while(juego!=NULL)
+		{
+			if (tipo==FULL) juego->numerocd=ncd;
+
+			if (((juego->tipo==NEOGEO) || (juego->tipo==FULL)) && (juego->numerocd==ncd))
+			{
+				njuegos_letra[GAME_NEOGEO]++;
+				njuegos_neogeo++;
+			}
+			juego=juego->next;
+		}
+#ifdef DEBUG_COUNT
+		printf("Neogeo %i\n",njuegos_neogeo);
+#endif
+	}
+
+	if (tipo==MAME)
+	{	
+#ifdef DEBUG_COUNT
+		for(i=GAME_1; i<=GAME_Z; i++) 
+		{
+			if (i==GAME_1) printf("Numero de juegos 1-9 \t%i\n",njuegos_letra[i]);
+			else printf("Numero de juegos %c \t%i\n",i+0x60,njuegos_letra[i]);
+		}
+#endif
+		return(njuegos_mame);
+	}
+	if (tipo==NEOGEO)
+	{	
+#ifdef DEBUG_COUNT
+		printf("Numero de juegos neogeo \t%i\n",njuegos_letra[GAME_NEOGEO]);
+#endif
+		return(njuegos_neogeo);
+	}
+
+	if (tipo==FULL)
+	{	
+#ifdef DEBUG_COUNT
+		for(i=GAME_1; i<=GAME_Z; i++) 
+		{
+			if (i==GAME_1) printf("Numero de juegos 1-9 \t%i\n",njuegos_letra[i]);
+			else printf("Numero de juegos %c \t%i\n",i+0x60,njuegos_letra[i]);
+		}
+		printf("Numero de juegos neogeo \t%i\n",njuegos_letra[GAME_NEOGEO]);
+#endif
+		return(njuegos_neogeo+njuegos_mame);
+	}
+
+	return(OK);
+}
+
+/************************************************************/
+/* 															*/
+/* Funcion de ordenacion para el qsort						*/
+/* 															*/
+/************************************************************/
+int ComparaJuegos(struct mamegame *game1, struct mamegame *game2)
+{
+	return(strcmp(game1->nombre, game2->nombre));
+}
+
+/************************************************************/
+/* 															*/
+/* Generamos la lista de juegos a partir del ejecutable		*/
+/* Retorno:													*/
+/* 			OK -----> La lista se genera correctamente		*/
+/* 			ERROR --> Error, el ejecuatable no es valido	*/
+/* 					  o error inesperado					*/
+/* 															*/
+/************************************************************/
+struct mamegame *MakeGameList(char *mame)
+{
+	int retclone, i, k;
+	int njuegos=0;
+	int clonecount;
+	struct mamegame *lista, *anterior, *actual, *todos;
+	char comando[MAXCAD];
+	char basura[MAXCAD];
+	char linea[MAXCAD];
+	FILE *pmame, *pclones;
+	struct stat buff;
+
+	char base[MAXCAD];
+	char filename[MAXCAD];
+	char aux1[MAXCAD], aux2[MAXCAD], aux3[MAXCAD], aux4[MAXCAD];
+
+	int rline=0;
+	int nozip=0;
+	int notitle=0;
+
+
+	todos=(struct mamegame *)calloc(MAXJUEGOS,sizeof(struct mamegame));
+
+	/* Ejecutamos el mame para conseguir la version */
+	sprintf(comando,"%s --version 2>/dev/null", mame);
+	pmame=popen(comando,"r");
+
+	fscanf(pmame,"%s %s %s %s %s %s\n", aux1, basura, basura, aux2, aux3, aux4); /* xmame (SDL) version 0.37 BETA 13 (Mar 31 2001) */
+	sprintf(versionmame,"%s %s %s %s",aux1, aux2, aux3, aux4);
+	printf("%s\n",versionmame);
+
+	lista=NULL;
+	/* Ejecutamos el mame para conseguir la lista de juegos */
+	sprintf(comando,"%s --listfull 2>/dev/null", mame);
+	pmame=popen(comando,"r");
+
+	fscanf(pmame,"%s %s\n", basura, basura); /* name      description */
+	fscanf(pmame,"%s %s\n", basura, basura); /* --------  -----------*/
+	
+	i=0;
+	/*fprintf(stderr,"Scanning games: ");*/
+	while (1)
+	{
+		fgets(linea,MAXCAD,pmame);
+
+		/* La ultima linea esta en blanco */
+		if (linea[0]=='\n') break;
+
+		sscanf(linea, "%s", todos[i].base);
+		fprintf(stderr,"Scanning game: (%5i) %8s ", i+1, todos[i].base);
+		rline=0;
+		nozip=0;
+		notitle=0;
+
+		linea[strlen(linea)-2]='\0';
+		strcpy(todos[i].nombre, &linea[11]);
+
+		/*********************************/		
+		/*********************************/		
+		/*********************************/		
+		/*if (i==99) break;*/
+		/*********************************/		
+		/*********************************/		
+		/*********************************/		
+
+		if (strcmp(todos[i].base,"Total")==0) break;
+
+		/* Existe el fichero .zip? Es de NEOGEO o de MAME? */
+		sprintf(filename,"%s/%s/%s.zip",srcbasedir,neogeodir,todos[i].base);
+		if (stat(filename,&buff)==-1)
+		{
+			sprintf(filename,"%s/%s/%s.zip",srcbasedir,mamedir,todos[i].base);
+			if (stat(filename,&buff)==-1)
+			{
+				fprintf(stderr, "\t!roms");
+				todos[i].tipo=MAME;
+				todos[i].tamanyo=0;
+				todos[i].tamanyorom=0;
+				todos[i].tamanyosamples=0;
+				todos[i].tamanyoartwork=0;
+				todos[i].hasgame=0;
+				rline=1;
+				nozip=1;
+			}
+			else
+				{
+					/* Es de mame */
+					todos[i].tipo=MAME;
+					todos[i].tamanyo=buff.st_size;
+					todos[i].tamanyorom=buff.st_size;
+					todos[i].hasgame=1;
+				}
+		}
+		else
+			{
+				/* Es de neogeo */
+				todos[i].tipo=NEOGEO;
+				todos[i].tamanyo=buff.st_size;
+				todos[i].tamanyorom=buff.st_size;
+				todos[i].hasgame=1;
+			}
+
+		/* Existen las imagenes del titulo y del juego? */
+		sprintf(todos[i].titleimage,"%s/%s/%s.gif",srclistdir,titlesdir,todos[i].base);
+		if (stat(todos[i].titleimage,&buff)==-1)
+		{
+			if (!nozip) 
+			{
+				fprintf(stderr,"\t");
+				nozip=1;
+			}
+			fprintf(stderr, "\t!title");
+			todos[i].hastitle=0;
+			rline=1;
+			notitle=1;
+		}
+		else
+		{
+			todos[i].tamanyo+=buff.st_size;
+			todos[i].hastitle=1;
+		}
+		sprintf(todos[i].gameimage,"%s/%s/%s.gif",srclistdir,imagesdir,todos[i].base);
+		if (stat(todos[i].gameimage,&buff)==-1)
+		{
+			if (!nozip) fprintf(stderr,"\t");
+			if (!notitle) fprintf(stderr,"\t");
+
+			fprintf(stderr, "\t!image");
+			todos[i].hasimage=0;
+			rline=1;
+		}
+		else
+		{
+			todos[i].tamanyo+=buff.st_size;
+			todos[i].hasimage=1;
+		}
+
+		/* Existe el fichero de samples? */
+		sprintf(todos[i].samplesrom,"%s/%s/%s.zip",srcbasedir,samplesdir,todos[i].base);
+		if (stat(todos[i].samplesrom,&buff)==-1)
+		{
+			/*fprintf(stderr, "\nERROR: %s/%s/%s.zip no existe\n",srcromsdir,samplesdir,todos[i].base);*/
+			todos[i].hassamples=0;
+		}
+		else
+			{
+				todos[i].tamanyo+=buff.st_size;
+				todos[i].tamanyosamples=buff.st_size;
+				todos[i].hassamples=1;
+			}
+		/* Existe el fichero de artwork? */
+		sprintf(todos[i].artwork,"%s/%s/%s.zip",srcbasedir,artworkdir,todos[i].base);
+		if (stat(todos[i].artwork,&buff)==-1)
+		{
+			/*fprintf(stderr, "\nERROR: %s/%s/%s.zip no existe\n",srcromsdir,artworkdir,todos[i].base);*/
+			todos[i].hasartwork=0;
+		}
+		else
+			{
+				todos[i].tamanyo+=buff.st_size;
+				todos[i].tamanyoartwork=buff.st_size;
+				todos[i].hasartwork=1;
+			}
+	
+		todos[i].numerocd=0;	/* No esta en ningun CD de momento */
+		/* Es un clonico? */
+		sprintf(comando,"%s --listclones %s 2>/dev/null", mame, todos[i].base);
+		pclones=popen(comando,"r");
+		if (fscanf(pclones, "%s %s %s\n", basura, basura, basura)!= EOF)	/* Name: 	Clone of: 	*/
+		{
+			retclone=0;
+			clonecount=0;
+			k=0;
+			while (retclone!=EOF)
+			{
+				basura[0]='\0';
+				base[0]='\0';
+				retclone=fscanf(pclones, "%s %s\n", base, basura);			/* ........ ........	*/ 
+				if (strcmp(base,todos[i].base)==0)
+				{
+					/* Si esta el primero es que es clonico de basura */
+					sprintf(todos[i].cloneof,"%s",basura);
+					todos[i].isclone=1;
+					todos[i].hasclones=0;
+				}
+				else
+					{
+						/* Si esta el segundo es que tiene clonicos */
+						if (strcmp(basura,todos[i].base)==0)
+						{
+							strcpy(todos[i].clones[k],base);
+							k++;
+							todos[i].isclone=0;
+							todos[i].hasclones=1;
+						}
+					}
+			}
+		}
+		else
+			{
+				todos[i].isclone=0;
+			}
+
+		pclose(pclones);
+
+		/* Un poquito de verbose */		
+		/*
+		if (todos[i].tipo==NEOGEO) 	printf(" neogeo");
+		if (todos[i].tipo==MAME) 	printf("   mame");
+		printf(" %10i  %02i  %i%i%i%i%i%i %5s %50s %8s %8s %s\n",	todos[i].tamanyorom,
+																		todos[i].numerocd, 
+																		todos[i].hasgame,
+																		todos[i].isclone,
+																		todos[i].hastitle,
+																		todos[i].hasimage,
+																		todos[i].hassamples,
+																		todos[i].hasartwork,
+																		todos[i].anyo,
+																		todos[i].fabricante,
+																		todos[i].base, 
+																		todos[i].cloneof, 
+																		todos[i].nombre);
+
+		k=0;
+		while (todos[i].clones[k][0]!='\0')
+		{
+			printf("                                                                                                 %8s\n",todos[i].clones[k++]);
+		}
+		*/
+
+		i++;
+		njuegos++;
+
+		if (rline) fprintf(stderr,"\n");
+			else fprintf(stderr,"\r");
+	}
+	fprintf(stderr,"\n");
+
+	/* Cerramos el fichero con la lista de juegos */
+	pclose(pmame);	
+
+	/* Ordenamos la lista */
+	qsort(todos, njuegos, sizeof(struct mamegame), (const void *)ComparaJuegos);
+
+	/* rellenamos ls lista enlazada */
+	for (i=0; i<njuegos;i++)
+	{
+		actual=(struct mamegame *)calloc(1, sizeof(struct mamegame));
+		actual->next=NULL;
+
+		strcpy(actual->base, todos[i].base);
+		strcpy(actual->nombre, todos[i].nombre);
+		strcpy(actual->anyo, todos[i].anyo);
+		strcpy(actual->fabricante, todos[i].fabricante);
+		strcpy(actual->cloneof, todos[i].cloneof);
+		strcpy(actual->samplesrom, todos[i].samplesrom);
+		strcpy(actual->artwork, todos[i].artwork);
+		strcpy(actual->titleimage, todos[i].titleimage);
+		strcpy(actual->gameimage, todos[i].gameimage);
+		actual->tipo=todos[i].tipo;
+		actual->tamanyo=todos[i].tamanyo;
+		actual->tamanyorom=todos[i].tamanyorom;
+		actual->tamanyosamples=todos[i].tamanyosamples;
+		actual->tamanyoartwork=todos[i].tamanyoartwork;
+		actual->numerocd=todos[i].numerocd;
+		actual->hasgame=todos[i].hasgame;
+		actual->isclone=todos[i].isclone;
+		actual->hasclones=todos[i].hasclones;
+		actual->hastitle=todos[i].hastitle;
+		actual->hasimage=todos[i].hasimage;
+		actual->hassamples=todos[i].hassamples;
+		actual->hasartwork=todos[i].hasartwork;
+		k=0;
+		while (todos[i].clones[k][0]!='\0')
+		{
+			strcpy(actual->clones[k],todos[i].clones[k]);
+			k++;
+		}
+
+		if (i==0) lista=actual;
+			else anterior->next=actual;
+
+		anterior=actual;
+	}
+
+	free(todos);
+	return(lista);
+}
+
+/************************************************************/
+/* 															*/
+/* Imprime la lista de juegos (para debug)					*/
+/* 															*/
+/************************************************************/
+int PrintGameList(struct mamegame *lista)
+{
+	int i;
+	struct mamegame *actual;
+
+	actual=lista;
+
+	printf("\n");
+	printf("Type          Size  CD  RCCTISA Base     Clone of year  Game\n");
+	printf("------- ----------  --  ------- -------- -------- ----- -------------------------------------------------------\n");
+
+	while(actual!=NULL)
+	{
+		if (actual->tipo==NEOGEO) 	printf(" Neogeo");
+		if (actual->tipo==MAME) 	printf("   Mame");
+		printf(" %10i  %02i  %i%i%i%i%i%i%i %8s %8s %5s %s %s\n",	actual->tamanyorom,
+																	actual->numerocd, 
+																	actual->hasgame,
+																	actual->isclone,
+																	actual->hasclones,
+																	actual->hastitle,
+																	actual->hasimage,
+																	actual->hassamples,
+																	actual->hasartwork,
+																	actual->base, 
+																	actual->cloneof, 
+																	actual->anyo,
+																	actual->nombre,
+																	actual->fabricante);
+
+		i=0;
+		while (actual->clones[i][0]!='\0')
+		{
+			printf("                                         %8s\n",actual->clones[i++]);
+		}
+		
+		actual=actual->next;
+	}
+	printf("\n");
+	return(OK);
+}
diff --git a/src/unix/contrib/tools/mamecds-1.0/src/html.c b/src/unix/contrib/tools/mamecds-1.0/src/html.c
new file mode 100644
index 0000000..153ece6
--- /dev/null
+++ b/src/unix/contrib/tools/mamecds-1.0/src/html.c
@@ -0,0 +1,734 @@
+#include <stdio.h>
+#include "utils.h"
+#include "html.h"
+#include "gamelist.h"
+#include "mamecds.h"
+
+char version_linux[]="Linux version 2.4.3";
+
+/************************************************************/
+/* 															*/
+/* Generacion de la lista de juegos del CD en cuestion		*/
+/* en html...												*/
+/* 															*/
+/************************************************************/
+int escribe_individual(struct mamegame *juego, int tipo, int ncd)
+{   
+	FILE *fd;
+	char individual[MAXCAD];
+	char directorio[MAXCAD];
+	float kbytes;
+
+	kbytes=(float)juego->tamanyorom/1024.0;
+
+	if (tipo==NEOGEO)
+	{
+		sprintf(directorio,"../%s/%s",romsdir,neogeodir);
+		sprintf(individual,"%s/neogeo-%02i/%s/%s.html",tmpdir,ncd,listdir,juego->base);
+	}
+	if (tipo==MAME)
+	{
+		sprintf(directorio,"../%s/%s",romsdir,mamedir);
+		sprintf(individual,"%s/mame-%02i/%s/%s.html",tmpdir,ncd,listdir,juego->base);
+	}
+
+	fd=fopen(individual,"w");
+
+	fprintf(fd,"<HTML>\n");
+	fprintf(fd,"<HEAD>\n");
+	fprintf(fd,"<META HTTP-EQUIV=\"Content-Type\" CONTENT=\"text/html; charset=iso-8859-1\">\n");
+	fprintf(fd,"<META NAME=\"Author\" CONTENT=\"Monigot\">   <META NAME=\"GENERATOR\" CONTENT=\"carlitos (%s)\">\n",version_linux);
+	if (tipo==NEOGEO)
+		fprintf(fd,"<TITLE>Lista de juegos (%s) NeogeoCD %02i</TITLE>\n", versionmame, ncd);
+	if (tipo==MAME)
+		fprintf(fd,"<TITLE>Lista de juegos (%s) MameCD %02i</TITLE>\n", versionmame, ncd);
+	fprintf(fd,"</HEAD>\n");
+	fprintf(fd,"<BODY TEXT=\"#FFFFFF\" BGCOLOR=\"#000000\" LINK=\"#33CCFF\" VLINK=\"#CC66CC\" ALINK=\"#FF6666\">\n");
+	fprintf(fd,"<P>\n");
+	fprintf(fd,"<CENTER>\n");
+	if (tipo==MAME)
+	{
+		/*fprintf(fd,"<IMG SRC=\"%s/mame.jpg\" HEIGHT=297 WIDTH=600></CENTER>\n",imagesdir);*/
+		fprintf(fd,"<IMG SRC=\"%s/mame.jpg\" HEIGHT=148 WIDTH=300></CENTER>\n",imagesdir);
+	}
+	if (tipo==NEOGEO)
+	{
+		/*fprintf(fd,"<IMG SRC=\"%s/neogeo.jpg\" HEIGHT=224 WIDTH=304></CENTER>\n", imagesdir);*/
+		fprintf(fd,"<IMG SRC=\"%s/neogeo.jpg\" HEIGHT=112 WIDTH=152></CENTER>\n", imagesdir);
+	}
+	fprintf(fd,"<P>\n");
+
+	fprintf(fd,"<CENTER><P>\n");
+#ifdef ANCHO_IMAGEN
+	fprintf(fd,"<TABLE border=\"5\" width=\"%i\">\n",ANCHO_IMAGEN);
+#else
+	fprintf(fd,"<TABLE border=\"5\">\n");
+#endif
+	fprintf(fd,"<COLGROUP><COL ALIGN=\"center\">\n");
+
+	fprintf(fd,"<TR><TH rowspan=\"2\"><TH colspan=\"2\"><CENTER><B>%s</B><P><FONT COLOR=\"#00ff00\"><A HREF=\"%s/%s.zip\">%s</A></FONT>",juego->nombre, directorio, juego->base, juego->base);
+	fprintf(fd,"&nbsp &nbsp<FONT COLOR=\"#ff0000\">%.2f Kbytes</FONT></CENTER>\n",kbytes);
+
+#ifdef ANCHO_IMAGEN
+	if (juego->hastitle) fprintf(fd,"<TR><TH><CENTER> <IMG SRC=\"%s/%s.gif\" ALIGN=\"center\" WIDTH=\"%i\"> </CENTER>\n",titlesdir, juego->base, ANCHO_IMAGEN);
+		else fprintf(fd,"<TR><TH><CENTER> <IMG SRC=\"%s/notitle.gif\" ALIGN=\"center\" WIDTH=\"%i\"> </CENTER>\n",titlesdir, ANCHO_IMAGEN);
+	if (juego->hasimage) fprintf(fd,"    <TH><CENTER> <IMG SRC=\"%s/%s.gif\" ALIGN=\"center\" WIDTH=\"%i\"> </CENTER>\n",imagesdir, juego->base, ANCHO_IMAGEN);
+		else fprintf(fd,"    <TH><CENTER> <IMG SRC=\"%s/noimage.gif\" ALIGN=\"center\" WIDTH=\"%i\"> </CENTER>\n",imagesdir, ANCHO_IMAGEN);
+#else
+	if (juego->hastitle) fprintf(fd,"<TR><TH><CENTER> <IMG SRC=\"%s/%s.gif\" ALIGN=\"center\"> </CENTER>\n",titlesdir, juego->base);
+		else fprintf(fd,"<TR><TH><CENTER> <IMG SRC=\"%s/notitle.gif\" ALIGN=\"center\"> </CENTER>\n",titlesdir);
+	if (juego->hasimage) fprintf(fd,"    <TH><CENTER> <IMG SRC=\"%s/%s.gif\" ALIGN=\"center\"> </CENTER>\n",imagesdir, juego->base);
+		else fprintf(fd,"    <TH><CENTER> <IMG SRC=\"%s/noimage.gif\" ALIGN=\"center\"> </CENTER>\n",imagesdir);
+#endif
+
+	fprintf(fd,"</TABLE><P>\n");
+
+	fprintf(fd,"</CENTER><P>\n");
+	fprintf(fd,"</HTML><P>\n");
+
+	fclose(fd);
+
+	return(0);
+}
+
+int MakeAll (struct mamegame *lista, int tipo, int ncd)
+{
+	FILE *fdall;
+	struct mamegame *juego;
+	
+	char allfilename[MAXCAD];
+	char pathlista[MAXCAD];
+	char pathroms[MAXCAD];
+	char pathsamples[MAXCAD];
+	char pathartwork[MAXCAD];
+
+	float kbytes;
+	char color1[]="#000070";
+	char color2[]="#0000A0";
+	char color[]="#000000";
+	int flag=0;
+
+	if (!generatelist) return(OK);
+
+	if (tipo==NEOGEO)
+	{
+		sprintf(pathlista,"%s/neogeo-%02i/%s", tmpdir, ncd, listdir);
+		sprintf(pathroms,"../%s/%s",romsdir,neogeodir);
+		sprintf(pathsamples,".");
+		sprintf(pathartwork,".");
+	}
+
+	if (tipo==MAME)
+	{
+		sprintf(pathlista,"%s/mame-%02i/%s", tmpdir, ncd, listdir);
+		sprintf(pathroms,"../%s/%s",romsdir,mamedir);
+		sprintf(pathsamples,"../%s/%s",romsdir,samplesdir);
+		sprintf(pathartwork,"../%s/%s",romsdir,artworkdir);
+	}
+
+	sprintf(allfilename,"%s/all.html",pathlista);
+	fdall=fopen(allfilename,"w");
+
+	fprintf(fdall,"<HTML>\n");
+	fprintf(fdall,"<HEAD>\n");
+	fprintf(fdall,"<META HTTP-EQUIV=\"Content-Type\" CONTENT=\"text/html; charset=iso-8859-1\">\n");
+	fprintf(fdall,"<META NAME=\"Author\" CONTENT=\"Monigot\">   <META NAME=\"GENERATOR\" CONTENT=\"carlitos (Linux 2.4.3)\">\n");
+	if (tipo==NEOGEO)
+		fprintf(fdall,"<TITLE>Lista de juegos (%s) NeogeoCD %02i (all CD games)</TITLE>\n", versionmame, ncd);
+	if (tipo==MAME)
+		fprintf(fdall,"<TITLE>Lista de juegos (%s) MameCD %02i (all CD games)</TITLE>\n", versionmame, ncd);
+	fprintf(fdall,"</HEAD>\n");
+	fprintf(fdall,"<BODY TEXT=\"#FFFFFF\" BGCOLOR=\"#000000\" LINK=\"#33CCFF\" VLINK=\"#CC66CC\" ALINK=\"#FF6666\">\n");
+	fprintf(fdall,"<P>\n");
+	fprintf(fdall,"<CENTER>\n");
+	if (tipo==MAME)
+		fprintf(fdall,"<IMG SRC=\"%s/mame.jpg\" HEIGHT=297 WIDTH=600></CENTER>\n",imagesdir);
+	if (tipo==NEOGEO)
+		fprintf(fdall,"<IMG SRC=\"%s/neogeo.jpg\" HEIGHT=224 WIDTH=304></CENTER>\n", imagesdir);
+	fprintf(fdall,"<P>\n");
+	fprintf(fdall,"<CENTER>\n");
+	fprintf(fdall,"<TABLE>\n");
+	fprintf(fdall,"<COLGROUP>\n");
+	fprintf(fdall,"<COL><COL><COL ALIGN=\"right\">\n");
+	fprintf(fdall,"<THEAD>\n");
+	fprintf(fdall,"<TR><TH ALIGN=\"left\">Titles<TH>Download<TH>Size\n");
+	fprintf(fdall,"</THEAD>\n");
+	fprintf(fdall,"<TBODY>\n");
+
+	juego=lista;
+	while(juego!=NULL)
+	{
+		if ((juego->numerocd==ncd)&&(juego->tipo==tipo))
+		{
+			if (flag==0)
+			{
+				strcpy(color,color1);
+				flag=1;
+			}
+			else
+			{
+				strcpy(color,color2);
+				flag=0;
+			}
+			kbytes=(float)juego->tamanyorom/1024.0;
+			fprintf(fdall,"<TR><TD bgcolor=\"%s\">",color);
+			fprintf(fdall,"<A HREF=\"%s.html\"><IMG SRC=\"%s/limage.gif\" BORDER=0></A> ",juego->base, imagesdir);
+			fprintf(fdall,"%s",juego->nombre);
+			fprintf(fdall,"<TD bgcolor=\"%s\">",color);
+			fprintf(fdall,"<A HREF=\"%s/%s.zip\">%s.zip</A></FONT>",pathroms,juego->base, juego->base);
+			fprintf(fdall,"<TD ALIGN=\"right\" bgcolor=\"%s\">%.2f Kb\n",color,kbytes);
+
+			escribe_individual(juego, tipo, ncd);
+		}
+		juego=juego->next;
+	}
+
+	fprintf(fdall,"</CENTER>\n");
+	fprintf(fdall,"</TABLE>\n");
+	fprintf(fdall,"</CENTER>\n");
+	fprintf(fdall,"</HTML>\n");
+	fclose(fdall);
+
+	return(OK);
+}
+
+int escribe_index (struct mamegame *lista, int tipo, int ncd)
+{
+	FILE *fdindex;
+	char indexfilename[MAXCAD];
+	char pathlista[MAXCAD];
+	int i;
+
+	if (tipo==NEOGEO)
+	{
+		sprintf(pathlista,"%s/neogeo-%02i/%s", tmpdir, ncd, listdir);
+	}
+
+	if (tipo==MAME)
+	{
+		sprintf(pathlista,"%s/mame-%02i/%s", tmpdir, ncd, listdir);
+	}
+
+	if (tipo==FULL)
+	{
+		sprintf(pathlista,"%s", srclistdir);
+	}
+
+	sprintf(indexfilename,"%s/index.html",pathlista);
+	fdindex=fopen(indexfilename,"w");
+
+#ifdef DEBUG_HTML
+	printf("Escribiendo %s\n",indexfilename);
+#endif
+
+	i=0;
+	fprintf(fdindex,"<HTML>\n");
+	fprintf(fdindex,"<HEAD>\n");
+	fprintf(fdindex,"<META HTTP-EQUIV=\"Content-Type\" CONTENT=\"text/html; charset=iso-8859-1\">\n");
+	fprintf(fdindex,"<META NAME=\"Author\" CONTENT=\"Monigot\">   <META NAME=\"GENERATOR\" CONTENT=\"carlitos (Linux 2.2.14)\">\n");
+	if (tipo==NEOGEO)
+		fprintf(fdindex,"<TITLE>Lista de juegos (%s) NeogeoCD %02i</TITLE>\n", versionmame, ncd);
+	if ((tipo==MAME)||(tipo==FULL))
+		fprintf(fdindex,"<TITLE>Lista de juegos (%s) MameCD %02i</TITLE>\n", versionmame, ncd);
+	fprintf(fdindex,"</HEAD>\n");
+	fprintf(fdindex,"<BODY TEXT=\"#FFFFFF\" BGCOLOR=\"#000000\" LINK=\"#33CCFF\" VLINK=\"#CC66CC\" ALINK=\"#FF6666\">\n");
+	fprintf(fdindex,"<P>\n");
+	fprintf(fdindex,"<CENTER>\n");
+	if (tipo==NEOGEO)
+		fprintf(fdindex,"<IMG SRC=\"%s/neogeo.jpg\" HEIGHT=224 WIDTH=304></CENTER>\n", imagesdir);
+	if ((tipo==MAME)||(tipo==FULL))
+		fprintf(fdindex,"<IMG SRC=\"%s/mame.jpg\" HEIGHT=297 WIDTH=600></CENTER>\n",imagesdir);
+	fprintf(fdindex,"<P>\n");
+	fprintf(fdindex,"<CENTER>\n");
+	fprintf(fdindex,"<TABLE>\n");
+	fprintf(fdindex,"<TABLE border=\"5\">\n");
+	fprintf(fdindex,"<COLGROUP><COL ALIGN=\"center\">\n");
+	fprintf(fdindex,"<TR><TD><FONT SIZE=+2><CENTER><FONT COLOR=\"#00ff00\" SIZE=+4>Indice de juegos </FONT></CENTER></FONT><TD><FONT SIZE=+2><CENTER><FONT COLOR=\"#00ff00\" SIZE=+4>N de juegos</FONT></CENTER></FONT><P>\n");
+	if (njuegos_letra[GAME_NEOGEO]!=0)
+		fprintf(fdindex,"<TR><TD><A HREF=\"neogeo_1.html\"><FONT SIZE=+2><CENTER> NeoGeo</CENTER></FONT></A><P>\n<TD><FONT SIZE=+2><CENTER> %i</CENTER></FONT>\n",njuegos_letra[GAME_NEOGEO]);
+	else
+		fprintf(fdindex,"<TR><TD><FONT SIZE=+2><CENTER> NeoGeo</CENTER></FONT><P>\n<TD><FONT SIZE=+2><CENTER> %i</CENTER></FONT>\n",njuegos_letra[GAME_NEOGEO]);
+
+	if (njuegos_letra[GAME_1]!=0)
+		fprintf(fdindex,"<TR><TD><A HREF=\"1_1.html\"><FONT SIZE=+2><CENTER> 0..9</CENTER></FONT></A><P>\n<TD><FONT SIZE=+2><CENTER> %i</CENTER></FONT>\n",njuegos_letra[GAME_1]);
+	else
+		fprintf(fdindex,"<TR><TD><FONT SIZE=+2><CENTER> 0..9</CENTER></FONT><P>\n<TD><FONT SIZE=+2><CENTER> %i</CENTER></FONT>\n",njuegos_letra[GAME_1]);
+
+	if (njuegos_letra[GAME_A]!=0)
+		fprintf(fdindex,"<TR><TD><A HREF=\"a_1.html\"><FONT SIZE=+2><CENTER> A</CENTER></FONT></A><P>\n<TD><FONT SIZE=+2><CENTER> %i</CENTER></FONT>\n",njuegos_letra[GAME_A]);
+	else
+		fprintf(fdindex,"<TR><TD><FONT SIZE=+2><CENTER> A</CENTER></FONT><P>\n<TD><FONT SIZE=+2><CENTER> %i</CENTER></FONT>\n",njuegos_letra[GAME_A]);
+
+	if (njuegos_letra[GAME_B]!=0)
+		fprintf(fdindex,"<TR><TD><A HREF=\"b_1.html\"><FONT SIZE=+2><CENTER> B</CENTER></FONT></A><P>\n<TD><FONT SIZE=+2><CENTER> %i</CENTER></FONT>\n",njuegos_letra[GAME_B]);
+	else
+		fprintf(fdindex,"<TR><TD><FONT SIZE=+2><CENTER> B</CENTER></FONT><P>\n<TD><FONT SIZE=+2><CENTER> %i</CENTER></FONT>\n",njuegos_letra[GAME_B]);
+
+	if (njuegos_letra[GAME_C]!=0)
+		fprintf(fdindex,"<TR><TD><A HREF=\"c_1.html\"><FONT SIZE=+2><CENTER> C</CENTER></FONT></A><P>\n<TD><FONT SIZE=+2><CENTER> %i</CENTER></FONT>\n",njuegos_letra[GAME_C]);
+	else
+		fprintf(fdindex,"<TR><TD><FONT SIZE=+2><CENTER> C</CENTER></FONT><P>\n<TD><FONT SIZE=+2><CENTER> %i</CENTER></FONT>\n",njuegos_letra[GAME_C]);
+
+	if (njuegos_letra[GAME_D]!=0)
+		fprintf(fdindex,"<TR><TD><A HREF=\"d_1.html\"><FONT SIZE=+2><CENTER> D</CENTER></FONT></A><P>\n<TD><FONT SIZE=+2><CENTER> %i</CENTER></FONT>\n",njuegos_letra[GAME_D]);
+	else
+		fprintf(fdindex,"<TR><TD><FONT SIZE=+2><CENTER> D</CENTER></FONT><P>\n<TD><FONT SIZE=+2><CENTER> %i</CENTER></FONT>\n",njuegos_letra[GAME_D]);
+
+	if (njuegos_letra[GAME_E]!=0)
+		fprintf(fdindex,"<TR><TD><A HREF=\"e_1.html\"><FONT SIZE=+2><CENTER> E</CENTER></FONT></A><P>\n<TD><FONT SIZE=+2><CENTER> %i</CENTER></FONT>\n",njuegos_letra[GAME_E]);
+	else
+		fprintf(fdindex,"<TR><TD><FONT SIZE=+2><CENTER> E</CENTER></FONT><P>\n<TD><FONT SIZE=+2><CENTER> %i</CENTER></FONT>\n",njuegos_letra[GAME_E]);
+
+	if (njuegos_letra[GAME_F]!=0)
+		fprintf(fdindex,"<TR><TD><A HREF=\"f_1.html\"><FONT SIZE=+2><CENTER> F</CENTER></FONT></A><P>\n<TD><FONT SIZE=+2><CENTER> %i</CENTER></FONT>\n",njuegos_letra[GAME_F]);
+	else
+		fprintf(fdindex,"<TR><TD><FONT SIZE=+2><CENTER> F</CENTER></FONT><P>\n<TD><FONT SIZE=+2><CENTER> %i</CENTER></FONT>\n",njuegos_letra[GAME_F]);
+
+	if (njuegos_letra[GAME_G]!=0)
+		fprintf(fdindex,"<TR><TD><A HREF=\"g_1.html\"><FONT SIZE=+2><CENTER> G</CENTER></FONT></A><P>\n<TD><FONT SIZE=+2><CENTER> %i</CENTER></FONT>\n",njuegos_letra[GAME_G]);
+	else
+		fprintf(fdindex,"<TR><TD><FONT SIZE=+2><CENTER> G</CENTER></FONT><P>\n<TD><FONT SIZE=+2><CENTER> %i</CENTER></FONT>\n",njuegos_letra[GAME_G]);
+
+	if (njuegos_letra[GAME_H]!=0)
+		fprintf(fdindex,"<TR><TD><A HREF=\"h_1.html\"><FONT SIZE=+2><CENTER> H</CENTER></FONT></A><P>\n<TD><FONT SIZE=+2><CENTER> %i</CENTER></FONT>\n",njuegos_letra[GAME_H]);
+	else
+		fprintf(fdindex,"<TR><TD><FONT SIZE=+2><CENTER> H</CENTER></FONT><P>\n<TD><FONT SIZE=+2><CENTER> %i</CENTER></FONT>\n",njuegos_letra[GAME_H]);
+
+	if (njuegos_letra[GAME_I]!=0)
+		fprintf(fdindex,"<TR><TD><A HREF=\"i_1.html\"><FONT SIZE=+2><CENTER> I</CENTER></FONT></A><P>\n<TD><FONT SIZE=+2><CENTER> %i</CENTER></FONT>\n",njuegos_letra[GAME_I]);
+	else
+		fprintf(fdindex,"<TR><TD><FONT SIZE=+2><CENTER> I</CENTER></FONT><P>\n<TD><FONT SIZE=+2><CENTER> %i</CENTER></FONT>\n",njuegos_letra[GAME_I]);
+
+	if (njuegos_letra[GAME_J]!=0)
+		fprintf(fdindex,"<TR><TD><A HREF=\"j_1.html\"><FONT SIZE=+2><CENTER> J</CENTER></FONT></A><P>\n<TD><FONT SIZE=+2><CENTER> %i</CENTER></FONT>\n",njuegos_letra[GAME_J]);
+	else
+		fprintf(fdindex,"<TR><TD><FONT SIZE=+2><CENTER> J</CENTER></FONT><P>\n<TD><FONT SIZE=+2><CENTER> %i</CENTER></FONT>\n",njuegos_letra[GAME_J]);
+
+	if (njuegos_letra[GAME_K]!=0)
+		fprintf(fdindex,"<TR><TD><A HREF=\"k_1.html\"><FONT SIZE=+2><CENTER> K</CENTER></FONT></A><P>\n<TD><FONT SIZE=+2><CENTER> %i</CENTER></FONT>\n",njuegos_letra[GAME_K]);
+	else
+		fprintf(fdindex,"<TR><TD><FONT SIZE=+2><CENTER> K</CENTER></FONT><P>\n<TD><FONT SIZE=+2><CENTER> %i</CENTER></FONT>\n",njuegos_letra[GAME_K]);
+
+	if (njuegos_letra[GAME_L]!=0)
+		fprintf(fdindex,"<TR><TD><A HREF=\"l_1.html\"><FONT SIZE=+2><CENTER> L</CENTER></FONT></A><P>\n<TD><FONT SIZE=+2><CENTER> %i</CENTER></FONT>\n",njuegos_letra[GAME_L]);
+	else
+		fprintf(fdindex,"<TR><TD><FONT SIZE=+2><CENTER> L</CENTER></FONT><P>\n<TD><FONT SIZE=+2><CENTER> %i</CENTER></FONT>\n",njuegos_letra[GAME_L]);
+
+	if (njuegos_letra[GAME_M]!=0)
+		fprintf(fdindex,"<TR><TD><A HREF=\"m_1.html\"><FONT SIZE=+2><CENTER> M</CENTER></FONT></A><P>\n<TD><FONT SIZE=+2><CENTER> %i</CENTER></FONT>\n",njuegos_letra[GAME_M]);
+	else
+		fprintf(fdindex,"<TR><TD><FONT SIZE=+2><CENTER> M</CENTER></FONT><P>\n<TD><FONT SIZE=+2><CENTER> %i</CENTER></FONT>\n",njuegos_letra[GAME_M]);
+
+	if (njuegos_letra[GAME_N]!=0)
+		fprintf(fdindex,"<TR><TD><A HREF=\"n_1.html\"><FONT SIZE=+2><CENTER> N</CENTER></FONT></A><P>\n<TD><FONT SIZE=+2><CENTER> %i</CENTER></FONT>\n",njuegos_letra[GAME_N]);
+	else
+		fprintf(fdindex,"<TR><TD><FONT SIZE=+2><CENTER> N</CENTER></FONT><P>\n<TD><FONT SIZE=+2><CENTER> %i</CENTER></FONT>\n",njuegos_letra[GAME_N]);
+
+	if (njuegos_letra[GAME_O]!=0)
+		fprintf(fdindex,"<TR><TD><A HREF=\"o_1.html\"><FONT SIZE=+2><CENTER> O</CENTER></FONT></A><P>\n<TD><FONT SIZE=+2><CENTER> %i</CENTER></FONT>\n",njuegos_letra[GAME_O]);
+	else
+		fprintf(fdindex,"<TR><TD><FONT SIZE=+2><CENTER> O</CENTER></FONT><P>\n<TD><FONT SIZE=+2><CENTER> %i</CENTER></FONT>\n",njuegos_letra[GAME_O]);
+
+	if (njuegos_letra[GAME_P]!=0)
+		fprintf(fdindex,"<TR><TD><A HREF=\"p_1.html\"><FONT SIZE=+2><CENTER> P</CENTER></FONT></A><P>\n<TD><FONT SIZE=+2><CENTER> %i</CENTER></FONT>\n",njuegos_letra[GAME_P]);
+	else
+		fprintf(fdindex,"<TR><TD><FONT SIZE=+2><CENTER> P</CENTER></FONT><P>\n<TD><FONT SIZE=+2><CENTER> %i</CENTER></FONT>\n",njuegos_letra[GAME_P]);
+
+	if (njuegos_letra[GAME_Q]!=0)
+		fprintf(fdindex,"<TR><TD><A HREF=\"q_1.html\"><FONT SIZE=+2><CENTER> Q</CENTER></FONT></A><P>\n<TD><FONT SIZE=+2><CENTER> %i</CENTER></FONT>\n",njuegos_letra[GAME_Q]);
+	else
+		fprintf(fdindex,"<TR><TD><FONT SIZE=+2><CENTER> Q</CENTER></FONT><P>\n<TD><FONT SIZE=+2><CENTER> %i</CENTER></FONT>\n",njuegos_letra[GAME_Q]);
+
+	if (njuegos_letra[GAME_R]!=0)
+		fprintf(fdindex,"<TR><TD><A HREF=\"r_1.html\"><FONT SIZE=+2><CENTER> R</CENTER></FONT></A><P>\n<TD><FONT SIZE=+2><CENTER> %i</CENTER></FONT>\n",njuegos_letra[GAME_R]);
+	else
+		fprintf(fdindex,"<TR><TD><FONT SIZE=+2><CENTER> R</CENTER></FONT><P>\n<TD><FONT SIZE=+2><CENTER> %i</CENTER></FONT>\n",njuegos_letra[GAME_R]);
+
+	if (njuegos_letra[GAME_S]!=0)
+		fprintf(fdindex,"<TR><TD><A HREF=\"s_1.html\"><FONT SIZE=+2><CENTER> S</CENTER></FONT></A><P>\n<TD><FONT SIZE=+2><CENTER> %i</CENTER></FONT>\n",njuegos_letra[GAME_S]);
+	else
+		fprintf(fdindex,"<TR><TD><FONT SIZE=+2><CENTER> S</CENTER></FONT><P>\n<TD><FONT SIZE=+2><CENTER> %i</CENTER></FONT>\n",njuegos_letra[GAME_S]);
+
+	if (njuegos_letra[GAME_T]!=0)
+		fprintf(fdindex,"<TR><TD><A HREF=\"t_1.html\"><FONT SIZE=+2><CENTER> T</CENTER></FONT></A><P>\n<TD><FONT SIZE=+2><CENTER> %i</CENTER></FONT>\n",njuegos_letra[GAME_T]);
+	else
+		fprintf(fdindex,"<TR><TD><FONT SIZE=+2><CENTER> T</CENTER></FONT><P>\n<TD><FONT SIZE=+2><CENTER> %i</CENTER></FONT>\n",njuegos_letra[GAME_T]);
+
+	if (njuegos_letra[GAME_U]!=0)
+		fprintf(fdindex,"<TR><TD><A HREF=\"u_1.html\"><FONT SIZE=+2><CENTER> U</CENTER></FONT></A><P>\n<TD><FONT SIZE=+2><CENTER> %i</CENTER></FONT>\n",njuegos_letra[GAME_U]);
+	else
+		fprintf(fdindex,"<TR><TD><FONT SIZE=+2><CENTER> U</CENTER></FONT><P>\n<TD><FONT SIZE=+2><CENTER> %i</CENTER></FONT>\n",njuegos_letra[GAME_U]);
+
+	if (njuegos_letra[GAME_V]!=0)
+		fprintf(fdindex,"<TR><TD><A HREF=\"v_1.html\"><FONT SIZE=+2><CENTER> V</CENTER></FONT></A><P>\n<TD><FONT SIZE=+2><CENTER> %i</CENTER></FONT>\n",njuegos_letra[GAME_V]);
+	else
+		fprintf(fdindex,"<TR><TD><FONT SIZE=+2><CENTER> V</CENTER></FONT><P>\n<TD><FONT SIZE=+2><CENTER> %i</CENTER></FONT>\n",njuegos_letra[GAME_V]);
+
+	if (njuegos_letra[GAME_W]!=0)
+		fprintf(fdindex,"<TR><TD><A HREF=\"w_1.html\"><FONT SIZE=+2><CENTER> W</CENTER></FONT></A><P>\n<TD><FONT SIZE=+2><CENTER> %i</CENTER></FONT>\n",njuegos_letra[GAME_W]);
+	else
+		fprintf(fdindex,"<TR><TD><FONT SIZE=+2><CENTER> W</CENTER></FONT><P>\n<TD><FONT SIZE=+2><CENTER> %i</CENTER></FONT>\n",njuegos_letra[GAME_W]);
+
+	if (njuegos_letra[GAME_X]!=0)
+		fprintf(fdindex,"<TR><TD><A HREF=\"x_1.html\"><FONT SIZE=+2><CENTER> X</CENTER></FONT></A><P>\n<TD><FONT SIZE=+2><CENTER> %i</CENTER></FONT>\n",njuegos_letra[GAME_X]);
+	else
+		fprintf(fdindex,"<TR><TD><FONT SIZE=+2><CENTER> X</CENTER></FONT><P>\n<TD><FONT SIZE=+2><CENTER> %i</CENTER></FONT>\n",njuegos_letra[GAME_X]);
+
+	if (njuegos_letra[GAME_Y]!=0)
+		fprintf(fdindex,"<TR><TD><A HREF=\"y_1.html\"><FONT SIZE=+2><CENTER> Y</CENTER></FONT></A><P>\n<TD><FONT SIZE=+2><CENTER> %i</CENTER></FONT>\n",njuegos_letra[GAME_Y]);
+	else
+		fprintf(fdindex,"<TR><TD><FONT SIZE=+2><CENTER> Y</CENTER></FONT><P>\n<TD><FONT SIZE=+2><CENTER> %i</CENTER></FONT>\n",njuegos_letra[GAME_Y]);
+
+	if (njuegos_letra[GAME_Z]!=0)
+		fprintf(fdindex,"<TR><TD><A HREF=\"z_1.html\"><FONT SIZE=+2><CENTER> Z</CENTER></FONT></A><P>\n<TD><FONT SIZE=+2><CENTER> %i</CENTER></FONT>\n",njuegos_letra[GAME_Z]);
+	else
+		fprintf(fdindex,"<TR><TD><FONT SIZE=+2><CENTER> Z</CENTER></FONT><P>\n<TD><FONT SIZE=+2><CENTER> %i</CENTER></FONT>\n",njuegos_letra[GAME_Z]);
+
+
+	/*fprintf(fdindex,"<TR><TD><A HREF=\"all.html\"><FONT SIZE=+2><CENTER> All</CENTER></FONT></A><P>\n<TD><FONT SIZE=+2><CENTER> %i</CENTER></FONT>\n",njuegos_neogeo + njuegos_mame);*/
+	fprintf(fdindex,"<TR><TD><CENTER><FONT SIZE=+3 COLOR=\"ff0000\"> Total</FONT><CENTER>\n<TD><CENTER><FONT SIZE=+3 COLOR=\"ff0000\"> %i</FONT><CENTER>\n", njuegos_neogeo + njuegos_mame);
+	fprintf(fdindex,"</TABLE>\n");
+	fprintf(fdindex,"</CENTER>\n");
+	fprintf(fdindex,"<P>\n");
+
+	fclose(fdindex);
+	return(0);
+}
+
+int escribe_cabecera(FILE *fd, int tipo)
+{
+	fprintf(fd,"<HTML>\n");
+	fprintf(fd,"<HEAD>\n");
+	fprintf(fd,"<META HTTP-EQUIV=\"Content-Type\" CONTENT=\"text/html; charset=iso-8859-1\">\n");
+	fprintf(fd,"<META NAME=\"Author\" CONTENT=\"Monigot\">   <META NAME=\"GENERATOR\" CONTENT=\"carlitos (Linux %s)\">\n",version_linux);
+	fprintf(fd,"<TITLE>Lista de juegos (Mame %s)</TITLE>\n",versionmame);
+	fprintf(fd,"</HEAD>\n");
+	fprintf(fd,"<BODY TEXT=\"#FFFFFF\" BGCOLOR=\"#000000\" LINK=\"#33CCFF\" VLINK=\"#CC66CC\" ALINK=\"#FF6666\">\n");
+	fprintf(fd,"<P>\n");
+	fprintf(fd,"<CENTER>\n");
+	if (tipo==MAME)
+		fprintf(fd,"<IMG SRC=\"%s/mame.jpg\" HEIGHT=148 WIDTH=300></CENTER>\n",imagesdir);
+	else if (tipo==NEOGEO)
+		fprintf(fd,"<IMG SRC=\"%s/neogeo.jpg\" HEIGHT=224 WIDTH=304></CENTER>\n",imagesdir);
+
+	fprintf(fd,"<P>\n");
+
+	return(0);
+}
+
+int escribe_flechas(FILE *fd, int letra, int pagina)
+{
+	int paginamas, paginamenos;
+	float otra;
+	char ltr[256];
+
+	if (letra==GAME_NEOGEO) sprintf(ltr,"neogeo");
+	else if (letra==GAME_1) sprintf(ltr,"1");
+	else sprintf(ltr,"%c",letra+0x60);
+
+	paginamas=pagina+1;
+	paginamenos=pagina-1;
+
+	fprintf(fd,"<CENTER>\n");
+
+	/* ANTERIOR */
+	if (pagina > 1)
+	{
+		fprintf(fd,"<A HREF=\"%s_%i.html\">",ltr, paginamenos);
+		fprintf(fd,"<IMG SRC=\"%s/anterior.jpg\" BORDER=0> </A>",imagesdir);
+	}
+	else
+	{
+		/*fprintf(fd,"<IMG SRC=\"%s/anterior.jpg\"> ",imagesdir);*/
+	}
+
+	/* CENTRO */
+	fprintf(fd,"<IMG SRC=\"%s/centro.jpg\" BORDER=0>",imagesdir);
+
+	/* SIGUIENTE */
+	if (letra==GAME_NEOGEO)
+		otra=(float)njuegos_neogeo/(float)pagina;
+	else
+		otra=(float)njuegos_letra[letra]/(float)pagina;
+
+	if (otra > JUEGOS_PAGINA)
+	{
+		fprintf(fd,"<A HREF=\"%s_%i.html\">",ltr, paginamas);
+		fprintf(fd,"<IMG SRC=\"%s/siguiente.jpg\" BORDER=0></A>\n",imagesdir);
+	}
+	else
+	{
+		/*fprintf(fd,"<IMG SRC=\"%s/siguiente.jpg\" BORDER=0>\n",imagesdir);*/
+	}
+
+	fprintf(fd,"</CENTER>\n");
+	return(0);
+}
+
+int escribe_barra(FILE *fd, int letra)
+{
+
+	fprintf(fd,"<CENTER>\n");
+	fprintf(fd,"<B><H3>\n");
+	if ((letra == GAME_NEOGEO ) || (njuegos_letra[GAME_NEOGEO]==0)) { fprintf(fd,"<B><FONT COLOR=\"#FF0000\">NeoGeo</FONT></B>\n"); } else { fprintf(fd,"<A HREF=\"neogeo_1.html\">NeoGeo</A>\n"); }
+	if ((letra == GAME_1 ) || (njuegos_letra[GAME_1]==0)) { fprintf(fd,"<B><FONT COLOR=\"#FF0000\">0..9</FONT></B>\n"); }   else { fprintf(fd,"<A HREF=\"1_1.html\">0..9</A>\n"); }
+	if ((letra == GAME_A ) || (njuegos_letra[GAME_A]==0)) { fprintf(fd,"<B><FONT COLOR=\"#FF0000\">A</FONT></B>\n"); }  else {fprintf(fd,"<A HREF=\"a_1.html\">A</A>\n");}
+	if ((letra == GAME_B ) || (njuegos_letra[GAME_B]==0)) { fprintf(fd,"<B><FONT COLOR=\"#FF0000\">B</FONT></B>\n"); }  else {fprintf(fd,"<A HREF=\"b_1.html\">B</A>\n");}
+	if ((letra == GAME_C ) || (njuegos_letra[GAME_C]==0)) { fprintf(fd,"<B><FONT COLOR=\"#FF0000\">C</FONT></B>\n"); }  else {fprintf(fd,"<A HREF=\"c_1.html\">C</A>\n");}
+	if ((letra == GAME_D ) || (njuegos_letra[GAME_D]==0)) { fprintf(fd,"<B><FONT COLOR=\"#FF0000\">D</FONT></B>\n"); }  else {fprintf(fd,"<A HREF=\"d_1.html\">D</A>\n");}
+	if ((letra == GAME_E ) || (njuegos_letra[GAME_E]==0)) { fprintf(fd,"<B><FONT COLOR=\"#FF0000\">E</FONT></B>\n"); }  else {fprintf(fd,"<A HREF=\"e_1.html\">E</A>\n");}
+	if ((letra == GAME_F ) || (njuegos_letra[GAME_F]==0)) { fprintf(fd,"<B><FONT COLOR=\"#FF0000\">F</FONT></B>\n"); }  else {fprintf(fd,"<A HREF=\"f_1.html\">F</A>\n");}
+	if ((letra == GAME_G ) || (njuegos_letra[GAME_G]==0)) { fprintf(fd,"<B><FONT COLOR=\"#FF0000\">G</FONT></B>\n"); }  else {fprintf(fd,"<A HREF=\"g_1.html\">G</A>\n");}
+	if ((letra == GAME_H ) || (njuegos_letra[GAME_H]==0)) { fprintf(fd,"<B><FONT COLOR=\"#FF0000\">H</FONT></B>\n"); }  else {fprintf(fd,"<A HREF=\"h_1.html\">H</A>\n");}
+	if ((letra == GAME_I ) || (njuegos_letra[GAME_I]==0)) { fprintf(fd,"<B><FONT COLOR=\"#FF0000\">I</FONT></B>\n"); }  else {fprintf(fd,"<A HREF=\"i_1.html\">I</A>\n");}
+	if ((letra == GAME_J ) || (njuegos_letra[GAME_J]==0)) { fprintf(fd,"<B><FONT COLOR=\"#FF0000\">J</FONT></B>\n"); }  else {fprintf(fd,"<A HREF=\"j_1.html\">J</A>\n");}
+	if ((letra == GAME_K ) || (njuegos_letra[GAME_K]==0)) { fprintf(fd,"<B><FONT COLOR=\"#FF0000\">K</FONT></B>\n"); }  else {fprintf(fd,"<A HREF=\"k_1.html\">K</A>\n");}
+	if ((letra == GAME_L ) || (njuegos_letra[GAME_L]==0)) { fprintf(fd,"<B><FONT COLOR=\"#FF0000\">L</FONT></B>\n"); }  else {fprintf(fd,"<A HREF=\"l_1.html\">L</A>\n");}
+	if ((letra == GAME_M ) || (njuegos_letra[GAME_M]==0)) { fprintf(fd,"<B><FONT COLOR=\"#FF0000\">M</FONT></B>\n"); }  else {fprintf(fd,"<A HREF=\"m_1.html\">M</A>\n");}
+	if ((letra == GAME_N ) || (njuegos_letra[GAME_N]==0)) { fprintf(fd,"<B><FONT COLOR=\"#FF0000\">N</FONT></B>\n"); }  else {fprintf(fd,"<A HREF=\"n_1.html\">N</A>\n");}
+	if ((letra == GAME_O ) || (njuegos_letra[GAME_O]==0)) { fprintf(fd,"<B><FONT COLOR=\"#FF0000\">O</FONT></B>\n"); }  else {fprintf(fd,"<A HREF=\"o_1.html\">O</A>\n");}
+	if ((letra == GAME_P ) || (njuegos_letra[GAME_P]==0)) { fprintf(fd,"<B><FONT COLOR=\"#FF0000\">P</FONT></B>\n"); }  else {fprintf(fd,"<A HREF=\"p_1.html\">P</A>\n");}
+	if ((letra == GAME_Q ) || (njuegos_letra[GAME_Q]==0)) { fprintf(fd,"<B><FONT COLOR=\"#FF0000\">Q</FONT></B>\n"); }  else {fprintf(fd,"<A HREF=\"q_1.html\">Q</A>\n");}
+	if ((letra == GAME_R ) || (njuegos_letra[GAME_R]==0)) { fprintf(fd,"<B><FONT COLOR=\"#FF0000\">R</FONT></B>\n"); }  else {fprintf(fd,"<A HREF=\"r_1.html\">R</A>\n");}
+	if ((letra == GAME_S ) || (njuegos_letra[GAME_S]==0)) { fprintf(fd,"<B><FONT COLOR=\"#FF0000\">S</FONT></B>\n"); }  else {fprintf(fd,"<A HREF=\"s_1.html\">S</A>\n");}
+	if ((letra == GAME_T ) || (njuegos_letra[GAME_T]==0)) { fprintf(fd,"<B><FONT COLOR=\"#FF0000\">T</FONT></B>\n"); }  else {fprintf(fd,"<A HREF=\"t_1.html\">T</A>\n");}
+	if ((letra == GAME_U ) || (njuegos_letra[GAME_U]==0)) { fprintf(fd,"<B><FONT COLOR=\"#FF0000\">U</FONT></B>\n"); }  else {fprintf(fd,"<A HREF=\"u_1.html\">U</A>\n");}
+	if ((letra == GAME_V ) || (njuegos_letra[GAME_V]==0)) { fprintf(fd,"<B><FONT COLOR=\"#FF0000\">V</FONT></B>\n"); }  else {fprintf(fd,"<A HREF=\"v_1.html\">V</A>\n");}
+	if ((letra == GAME_W ) || (njuegos_letra[GAME_W]==0)) { fprintf(fd,"<B><FONT COLOR=\"#FF0000\">W</FONT></B>\n"); }  else {fprintf(fd,"<A HREF=\"w_1.html\">W</A>\n");}
+	if ((letra == GAME_X ) || (njuegos_letra[GAME_X]==0)) { fprintf(fd,"<B><FONT COLOR=\"#FF0000\">X</FONT></B>\n"); }  else {fprintf(fd,"<A HREF=\"x_1.html\">X</A>\n");}
+	if ((letra == GAME_Y ) || (njuegos_letra[GAME_Y]==0)) { fprintf(fd,"<B><FONT COLOR=\"#FF0000\">Y</FONT></B>\n"); }  else {fprintf(fd,"<A HREF=\"y_1.html\">Y</A>\n");}
+	if ((letra == GAME_Z ) || (njuegos_letra[GAME_Z]==0)) { fprintf(fd,"<B><FONT COLOR=\"#FF0000\">Z</FONT></B>\n"); }  else {fprintf(fd,"<A HREF=\"z_1.html\">Z</A>\n");}
+	/*if (letra == ALL ) { fprintf(fd,"<B><FONT COLOR=\"#FF0000\">All</FONT></B>\n"); } else {fprintf(fd,"<A HREF=\"all.html\">All</A>\n");}*/
+	fprintf(fd,"</H3></B>\n");
+	fprintf(fd,"</CENTER>\n");
+	fprintf(fd,"<P>\n");
+
+	return(0);
+}
+
+int escribe_juego (FILE *fd, int tipo, struct mamegame *juego)
+{   
+	char directorio[MAXCAD];
+	char directoriosamples[MAXCAD];
+	char directorioartwork[MAXCAD];
+	float kbytes;
+	float kbytessamples;
+	float kbytesartwork;
+
+	kbytes=(float)juego->tamanyorom/1024.0;
+	if (juego->hassamples) kbytessamples=(float)juego->tamanyosamples/1024.0;
+	if (juego->hasartwork) kbytesartwork=(float)juego->tamanyoartwork/1024.0;
+
+#ifdef ANCHO_IMAGEN
+	fprintf(fd,"<TABLE border=\"5\" width=\"%i\">\n",ANCHO_IMAGEN);
+#else
+	fprintf(fd,"<TABLE border=\"5\">\n");
+#endif
+	fprintf(fd,"<COLGROUP><COL ALIGN=\"center\">\n");
+	if (tipo==GAME_NEOGEO)
+		sprintf(directorio,"../%s/%s",romsdir,neogeodir);
+	else
+	{
+		sprintf(directorio,"../%s/%s",romsdir,mamedir);
+		sprintf(directoriosamples,"../%s/%s",romsdir,samplesdir);
+		sprintf(directorioartwork,"../%s/%s",romsdir,artworkdir);
+	}
+
+	fprintf(fd,"<TR><TH rowspan=\"2\"><TH colspan=\"2\"><CENTER><B>%s</B><P><FONT COLOR=\"#00ff00\"><A HREF=\"%s/%s.zip\">%s.zip</A></FONT>",juego->nombre, directorio, juego->base, juego->base);
+	fprintf(fd,"&nbsp &nbsp<FONT COLOR=\"#ff0000\">%5.2f Kbytes</FONT></CENTER>\n",kbytes);
+	if (juego->hassamples) 
+	{
+		fprintf(fd,"<FONT COLOR=\"#00ff00\">samples: <A HREF=\"%s/%s.zip\">%s.zip</A></FONT>", directoriosamples, juego->base, juego->base);
+		fprintf(fd,"&nbsp &nbsp<FONT COLOR=\"#ff0000\">%5.2f Kbytes</FONT></CENTER>\n",kbytessamples);
+	}
+	if (juego->hasartwork) 
+	{
+		fprintf(fd,"<FONT COLOR=\"#00ff00\">artwork: <A HREF=\"%s/%s.zip\">%s.zip</A></FONT>", directorioartwork, juego->base, juego->base);
+		fprintf(fd,"&nbsp &nbsp<FONT COLOR=\"#ff0000\">%5.2f Kbytes</FONT></CENTER>\n",kbytesartwork);
+	}
+
+#ifdef ANCHO_IMAGEN
+	if (juego->hastitle) fprintf(fd,"<TR><TH><CENTER> <IMG SRC=\"%s/%s.gif\" ALIGN=\"center\" WIDTH=\"%i\"> </CENTER>\n",titlesdir, juego->base, ANCHO_IMAGEN);
+		else fprintf(fd,"<TR><TH><CENTER> <IMG SRC=\"%s/notitle.gif\" ALIGN=\"center\" WIDTH=\"%i\"> </CENTER>\n",titlesdir, ANCHO_IMAGEN);
+	if (juego->hasimage) fprintf(fd,"    <TH><CENTER> <IMG SRC=\"%s/%s.gif\" ALIGN=\"center\" WIDTH=\"%i\"> </CENTER>\n",imagesdir, juego->base, ANCHO_IMAGEN);
+		else fprintf(fd,"    <TH><CENTER> <IMG SRC=\"%s/noimage.gif\" ALIGN=\"center\" WIDTH=\"%i\"> </CENTER>\n",imagesdir, ANCHO_IMAGEN);
+#else
+	if (juego->hastitle) fprintf(fd,"<TR><TH><CENTER> <IMG SRC=\"%s/%s.gif\" ALIGN=\"center\"> </CENTER>\n",titlesdir, juego->base);
+		else fprintf(fd,"<TR><TH><CENTER> <IMG SRC=\"%s/notitle.gif\" ALIGN=\"center\"> </CENTER>\n",titlesdir);
+	if (juego->hasimage) fprintf(fd,"    <TH><CENTER> <IMG SRC=\"%s/%s.gif\" ALIGN=\"center\"> </CENTER>\n",imagesdir, juego->base);
+		else fprintf(fd,"    <TH><CENTER> <IMG SRC=\"%s/noimage.gif\" ALIGN=\"center\"> </CENTER>\n",imagesdir);
+#endif
+		
+	fprintf(fd,"</TABLE><P>\n");
+
+	return(0);
+}   
+
+int escribe_mame(struct mamegame *lista, int tipo, int ncd)
+{
+	FILE *fd;
+	int pagina, contador;
+	char nombre[256];
+	char ltr;
+	int letra_ok;
+	int letra;
+	struct mamegame *juego;
+
+	for (letra=GAME_1;letra<=GAME_Z;letra++)
+	{
+		if (letra==GAME_1) ltr='1';
+		else ltr=letra+0x60;
+
+		pagina=1;
+		juego=lista;
+		/*printf("\tWriting \"%c\" \t(%i)\n",ltr,njuegos_letra[letra]);*/
+		while(juego!=NULL)
+		{
+			/* Abrimos el fichero */
+			if (tipo==FULL) sprintf(nombre,"%s/%c_%i.html", srclistdir, (char)ltr, pagina);
+			else sprintf(nombre,"%s/mame-%02i/%s/%c_%i.html", tmpdir, ncd, listdir, (char)ltr, pagina);
+			fd=fopen(nombre,"w");
+
+			escribe_cabecera(fd, MAME);
+			escribe_barra(fd, letra);
+			escribe_flechas(fd, letra, pagina);
+			fprintf(fd,"<CENTER>\n");
+
+			contador=0;
+			while ((contador<JUEGOS_PAGINA)&&(juego!=NULL))
+			{
+				if (((juego->tipo==MAME) || (juego->tipo==FULL)) && (juego->numerocd==ncd))
+				{
+					letra_ok=0;
+					/* Empieza por la letra adecuada? */
+					if (letra==GAME_1)
+					{
+						if ((juego->nombre[0]=='0')|| (juego->nombre[0]=='1')|| (juego->nombre[0]=='2')|| (juego->nombre[0]=='3')||
+								(juego->nombre[0]=='4')|| (juego->nombre[0]=='5')|| (juego->nombre[0]=='6')|| (juego->nombre[0]=='7')||
+								(juego->nombre[0]=='8')|| (juego->nombre[0]=='9')|| (juego->nombre[0]=='\''))
+							letra_ok=1;
+					}
+					if ((letra==GAME_A)&&(juego->nombre[0]=='A')) letra_ok=1;
+					if ((letra==GAME_B)&&(juego->nombre[0]=='B')) letra_ok=1;
+					if ((letra==GAME_C)&&(juego->nombre[0]=='C')) letra_ok=1;
+					if ((letra==GAME_D)&&(juego->nombre[0]=='D')) letra_ok=1;
+					if ((letra==GAME_E)&&(juego->nombre[0]=='E')) letra_ok=1;
+					if ((letra==GAME_F)&&(juego->nombre[0]=='F')) letra_ok=1;
+					if ((letra==GAME_G)&&(juego->nombre[0]=='G')) letra_ok=1;
+					if ((letra==GAME_H)&&(juego->nombre[0]=='H')) letra_ok=1;
+					if ((letra==GAME_I)&&(juego->nombre[0]=='I')) letra_ok=1;
+					if ((letra==GAME_J)&&(juego->nombre[0]=='J')) letra_ok=1;
+					if ((letra==GAME_K)&&(juego->nombre[0]=='K')) letra_ok=1;
+					if ((letra==GAME_L)&&(juego->nombre[0]=='L')) letra_ok=1;
+					if ((letra==GAME_M)&&(juego->nombre[0]=='M')) letra_ok=1;
+					if ((letra==GAME_N)&&(juego->nombre[0]=='N')) letra_ok=1;
+					if ((letra==GAME_O)&&(juego->nombre[0]=='O')) letra_ok=1;
+					if ((letra==GAME_P)&&(juego->nombre[0]=='P')) letra_ok=1;
+					if ((letra==GAME_Q)&&(juego->nombre[0]=='Q')) letra_ok=1;
+					if ((letra==GAME_R)&&(juego->nombre[0]=='R')) letra_ok=1;
+					if ((letra==GAME_S)&&(juego->nombre[0]=='S')) letra_ok=1;
+					if ((letra==GAME_T)&&(juego->nombre[0]=='T')) letra_ok=1;
+					if ((letra==GAME_U)&&(juego->nombre[0]=='U')) letra_ok=1;
+					if ((letra==GAME_V)&&(juego->nombre[0]=='V')) letra_ok=1;
+					if ((letra==GAME_W)&&(juego->nombre[0]=='W')) letra_ok=1;
+					if ((letra==GAME_X)&&(juego->nombre[0]=='X')) letra_ok=1;
+					if ((letra==GAME_Y)&&(juego->nombre[0]=='Y')) letra_ok=1;
+					if ((letra==GAME_Z)&&(juego->nombre[0]=='Z')) letra_ok=1;
+
+					if(letra_ok==1)
+					{
+						escribe_juego(fd, letra, juego);
+						contador++;
+					}
+				}
+				juego=juego->next;
+			}
+
+			escribe_flechas(fd, letra, pagina);
+			escribe_barra(fd, letra);
+			fclose(fd);
+
+			pagina++;
+		}
+	}
+
+	return(0);
+}
+
+
+int escribe_neogeo (struct mamegame *lista, int tipo, int ncd)
+{
+	FILE *fd;
+	int pagina, contador;
+	char nombre[MAXCAD];
+	struct mamegame *juego;
+
+	/*printf("\tWriting \"neogeo\" (%i)\n", njuegos_neogeo);*/
+
+	pagina=1;
+	juego=lista;
+	while (juego!=NULL)
+	{
+		/* Abrimos el fichero */
+		if (tipo==FULL) sprintf(nombre,"%s/neogeo_%i.html", srclistdir, pagina);
+		else sprintf(nombre,"%s/neogeo-%02i/%s/neogeo_%i.html", tmpdir, ncd, listdir, pagina);
+		fd=fopen(nombre,"w");
+
+		escribe_cabecera(fd, NEOGEO);
+		escribe_barra(fd, GAME_NEOGEO);
+		escribe_flechas(fd, GAME_NEOGEO, pagina);
+
+		fprintf(fd,"<CENTER>\n");
+
+		contador=0;
+		while ((contador<JUEGOS_PAGINA)&&(juego!=NULL))
+		{
+			if (((juego->tipo==NEOGEO) || (juego->tipo==FULL)) && (juego->numerocd==ncd))
+			{
+				escribe_juego(fd, GAME_NEOGEO, juego);
+				contador++;
+			}
+			juego=juego->next;
+		}
+		/*printf("(%i)\n",contador);*/
+
+		escribe_flechas(fd, GAME_NEOGEO, pagina);
+		escribe_barra(fd,GAME_NEOGEO);
+		fclose(fd);
+
+		pagina++;
+	}
+	
+	return(0);
+}
+
+
+int MakeHTML (struct mamegame *lista, int tipo, int ncd)
+{
+	
+	if (generatelist)
+	{
+		if (tipo==FULL) escribe_index(lista,FULL,0);
+		else escribe_index(lista,tipo,ncd);
+		/*MakeAll(lista,tipo,ncd);*/
+
+		if (tipo==NEOGEO)
+		{
+			escribe_neogeo(lista,tipo,ncd);
+		}
+
+		if (tipo==MAME)
+		{
+			escribe_mame(lista,tipo,ncd);
+		}
+
+		if (tipo==FULL)
+		{
+			escribe_neogeo(lista,FULL,0);
+			escribe_mame(lista,FULL,0);
+		}
+	}
+
+	return(0);
+}
+
diff --git a/src/unix/contrib/tools/mamecds-1.0/src/main.c b/src/unix/contrib/tools/mamecds-1.0/src/main.c
new file mode 100644
index 0000000..bd02c62
--- /dev/null
+++ b/src/unix/contrib/tools/mamecds-1.0/src/main.c
@@ -0,0 +1,331 @@
+#include <unistd.h>
+#include <pwd.h>
+#include <sys/types.h>
+#include <ctype.h>
+#include "gamelist.h"
+#include "mamecds.h"
+#include "html.h"
+
+/************************************************************/
+/*															*/
+/* Imprime la ayuda del programa							*/
+/*															*/
+/************************************************************/
+int Ayuda(char *progname)
+{
+	printf("\nUsage: %s [-n | --neogeo] [-m | --mame]\n",progname);
+	printf("\t\t[-v | --version]\n");
+	printf("\t\t[-s size | --size=size]\n");
+	printf("\t\t[--nocd | -c]\n");
+	printf("\t\t[--nolist | -l]\n");
+	printf("\t\t[--fulllist | -f]\n");
+	printf("\t\t[--help | -h]\n\n");
+
+	printf("\t-h --help\tThis help screen\n");
+	/*printf("\t-f --file\tUse file instead of ~/.mamecdsrc\n");*/
+	printf("\t-v --version\tShow version information\n");
+	printf("\t-n --neogeo\tMake neogeo CD's\n");
+	printf("\t-m --mame\tMake mame CD's\n");
+	printf("\t-c --nocd\tDon't generate the ISOs\n");
+	printf("\t-l --nolist\tDon't generate the game list\n");
+	printf("\t-f --fulllist\tCreates a full list in the 'srclistdir'\n");
+	printf("\t-s --size\tSize of the ISO CD's (default 640Mb)\n");
+	printf("\t\t\tYou can append B for bytes, K for kbytes,\n");
+	printf("\t\t\tM for megabytes and m for minutes (default in Mb).\n");
+
+	printf("\n");
+	return(ERROR);
+}
+
+/************************************************************/
+/*															*/
+/* Saca una linea del fichero								*/
+/*															*/
+/************************************************************/
+int ReadLine(FILE *fd, char *line)
+{
+	char c;
+	int count,i;
+
+	i=0;
+	count=fread(&c,1,1,fd);
+	while ((count==1) && (c!='\n'))
+	{
+		line[i++]=c;
+		count=fread(&c,1,1,fd);
+	}
+	line[i]='\0';
+
+	if (count==0) return(EOF);	
+	return(OK);
+}
+
+/************************************************************/
+/*															*/
+/* Parsea los argumentos del fichero rc						*/
+/*															*/
+/************************************************************/
+int Parserc(FILE *fd)
+{
+	char aux[MAXCAD];
+	char iden[MAXCAD], value[MAXCAD];
+
+	while (ReadLine(fd, aux)!=EOF)
+	{
+		/* comment */
+		if (aux[0]=='#') continue;
+		/* void line */
+		if (aux[0]=='\0') continue;
+		sscanf(aux,"%s %s",iden,value);
+
+		/* CAMBIAR!!! */
+		if (strcmp(iden,"mamebin")		== 0) strcpy(mamebin,value);
+
+		if (strcmp(iden,"srcromsdir")	== 0) strcpy(srcbasedir,value);
+		if (strcmp(iden,"srclistdir")	== 0) strcpy(srclistdir,value);
+
+		if (strcmp(iden,"tmpdir")		== 0) strcpy(tmpdir,value);
+		if (strcmp(iden,"romsdir")		== 0) strcpy(romsdir,value);
+		if (strcmp(iden,"mamedir")		== 0) strcpy(mamedir,value);
+		if (strcmp(iden,"neogeodir")	== 0) strcpy(neogeodir,value);
+		if (strcmp(iden,"samplesdir")	== 0) strcpy(samplesdir,value);
+		if (strcmp(iden,"artworkdir")	== 0) strcpy(artworkdir,value);
+		if (strcmp(iden,"listdir")		== 0) strcpy(listdir,value);
+		if (strcmp(iden,"imagesdir")	== 0) strcpy(imagesdir,value);
+		if (strcmp(iden,"titlesdir")	== 0) strcpy(titlesdir,value);
+	}
+
+	
+	return(OK);
+}
+
+/************************************************************/
+/*															*/
+/* Parsea los argumentos de la linea de comandos			*/
+/*															*/
+/************************************************************/
+int ParseArgs(int argc, char **argv)
+{
+	int i, j;
+	unsigned long multiplier=1024*1024;
+	FILE *mamecdsrc;
+	struct passwd *user;
+	char aux[MAXCAD];
+
+	/* CAMBIAR!!!!! */
+	sprintf(mamebin,	"xmame");
+
+	sprintf(srcbasedir, "/home/carlitos/roms");
+	sprintf(srclistdir, "/home/carlitos/lista");	
+
+	sprintf(basedir,	".");
+	sprintf(cddir,		".");
+	sprintf(tmpdir,		"tmp");
+	sprintf(romsdir,	"roms");
+	sprintf(mamedir,	"mame");
+	sprintf(neogeodir,	"neogeo");
+	sprintf(samplesdir,	"samples");
+	sprintf(artworkdir,	"artwork");
+	sprintf(listdir,	"lista");
+	sprintf(imagesdir,	"images");
+	sprintf(titlesdir,	"titulos");
+
+	generatecds=1;
+	generatelist=1;
+	generatefulllist=0;
+
+	/* Primero miramos si existe ~/.mamecdsrc */
+	user=getpwuid(getuid());
+	sprintf(aux,"%s/.mamecdsrc",user->pw_dir);
+
+	mamecdsrc=fopen(aux,"r");
+	if (mamecdsrc!=NULL) 
+	{
+		if (Parserc(mamecdsrc)==ERROR) 
+		{
+			fclose(mamecdsrc);
+			return ERROR;
+		}
+		fclose(mamecdsrc);
+	}
+	else
+	{
+		printf("Generating %s\n",aux);
+		/* Generamos el fichero con los valores por defecto */
+		mamecdsrc=fopen(aux,"w");
+		
+		fprintf(mamecdsrc,"# Xmame binary\n");
+		fprintf(mamecdsrc,"mamebin\txmame\n");
+		fprintf(mamecdsrc,"# Base directory where the roms are\n");
+		fprintf(mamecdsrc,"srcromsdir\t%s/roms\n",user->pw_dir);
+		fprintf(mamecdsrc,"# Base directory where the images and titles images are\n");
+		fprintf(mamecdsrc,"srclistdir\t%s/list\n",user->pw_dir);
+		fprintf(mamecdsrc,"# Temporary directory\n");
+		fprintf(mamecdsrc,"tmpdir\ttmp\n");
+		fprintf(mamecdsrc,"# Subdirectory where the roms are (and there be)\n");
+		fprintf(mamecdsrc,"romsdir\troms\n");
+		fprintf(mamecdsrc,"# Subdirectory where the mame-only roms are (and there be)\n");
+		fprintf(mamecdsrc,"mamedir\tmame\n");
+		fprintf(mamecdsrc,"# Subdirectory where the neogeo-only roms are (and there be)\n");
+		fprintf(mamecdsrc,"neogeodir\tneogeo\n");
+		fprintf(mamecdsrc,"# Subdirectory where the samples roms are (and there be)\n");
+		fprintf(mamecdsrc,"samplesdir\tsamples\n");
+		fprintf(mamecdsrc,"# Subdirectory where the artwork roms are (and there be)\n");
+		fprintf(mamecdsrc,"artworkdir\tartwork\n");
+		fprintf(mamecdsrc,"# Subdirectory where the list there be\n");
+		fprintf(mamecdsrc,"listdir\tlist\n");
+		fprintf(mamecdsrc,"# Subdirectory where the game images are (and there be)\n");
+		fprintf(mamecdsrc,"imegesdir\timages\n");
+		fprintf(mamecdsrc,"# Subdirectory where the title images roms are (and there be)\n");
+		fprintf(mamecdsrc,"titlesdir\ttitles\n");
+		
+		fclose(mamecdsrc);
+	}
+
+	if (argc>1)
+	{
+		for (i=1; i<argc;i++)
+		{
+			if ( (strcmp(argv[i],"--help")==0) || (strcmp(argv[i],"-h")==0) )
+			{
+				return(Ayuda(argv[0]));
+			}
+
+			if ( (strcmp(argv[i],"--version")==0) || (strcmp(argv[i],"-v")==0) )
+			{
+				printf("%s version 1.0\n", argv[0]);
+				return(ERROR);
+			}
+
+			if ( (strcmp(argv[i],"--neogeo")==0) || (strcmp(argv[i],"-n")==0) )
+			{
+				neogeocd=1;
+			}
+
+			if ( (strcmp(argv[i],"--mame")==0) || (strcmp(argv[i],"-m")==0) )
+			{
+				mamecd=1;
+			}
+
+			if ( (strcmp(argv[i],"--nocd")==0) || (strcmp(argv[i],"-c")==0) )
+			{
+				generatecds=0;
+			}
+
+			if ( (strcmp(argv[i],"--nolist")==0) || (strcmp(argv[i],"-l")==0) )
+			{
+				generatelist=0;
+			}
+
+			if ( (strcmp(argv[i],"--fulllist")==0) || (strcmp(argv[i],"-f")==0) )
+			{
+				generatefulllist=1;
+			}
+
+			if ( (strcmp(argv[i],"--size")==0) || (strcmp(argv[i],"-s")==0) )
+			{
+				i++;
+				if (i==argc)
+				{
+					printf("Unreconigzed size: 0\n");
+					return(ERROR);
+				}
+				
+				if (isdigit(argv[i][0]))
+				{
+					tamanyocd=atol(argv[i]);
+				}
+				else
+					{
+						printf("Unreconigzed size: %s\n",argv[i]);
+						return(ERROR);
+					}
+
+				j=0;
+				while (argv[i][j]!='\0')
+				{
+					if (isalpha(argv[i][j]))
+					{
+						if (argv[i][j]=='B') multiplier=MULTIPLIERB;
+						if (argv[i][j]=='K') multiplier=MULTIPLIERK;
+						if (argv[i][j]=='M') multiplier=MULTIPLIERM;
+						if (argv[i][j]=='m') multiplier=MULTIPLIERm;
+						break;
+					}
+					else
+						{
+							j++;
+						}
+					
+				}
+
+				tamanyocd*=multiplier;
+			}
+		}
+	}
+ 	return(OK);
+}
+
+/************************************************************/
+/*															*/
+/* Programa principal										*/
+/*															*/
+/************************************************************/
+int main(int argc, char **argv)
+{
+	struct mamegame *lista;
+
+	tamanyocd=74*MULTIPLIERm;
+	/*tamanyocd=10*MULTIPLIERM;*/
+	neogeocd=0;
+	mamecd=0;
+
+	lista=NULL;
+
+	/* Parseamos los argumentos de la linea de comandos */
+	if (ParseArgs(argc, argv)==ERROR) return(ERROR);
+
+	/* Si no decimos nada hay que hacer todos los CDs */
+	if (!neogeocd && !mamecd)
+	{
+		neogeocd=1;
+		mamecd=1;
+	}
+
+	/* Imprimimos un poco de informacion */	
+	printf("\n");
+	printf("Make NEOGEO CD's ");
+	if (neogeocd) printf("yes\n");
+		else printf("no\n");
+	
+	printf("Make MAME CD's   ");
+	if (mamecd) printf("yes\n");
+		else printf("no\n");
+
+	if (!generatecds) printf("Don't generate ISO CDs\n");
+	if (!generatelist) printf("Don't generate game list\n");
+	if (generatefulllist) printf("Create full game list\n");
+
+	printf("Size of CD's     %lu bytes (%lu Kb, %lu Mb, %lu')\n\n", tamanyocd/MULTIPLIERB, tamanyocd/MULTIPLIERK, tamanyocd/MULTIPLIERM, tamanyocd/MULTIPLIERm);
+
+	/* Creamos la lista de juegos */
+	lista=MakeGameList(mamebin);
+	printf("\n");
+
+	/* Creamos los CD's que toquen */
+	if (mamecd)
+		CreateCDS(lista, MAME);
+
+	if (neogeocd)
+		CreateCDS(lista, NEOGEO);
+
+	if (generatefulllist) 
+	{
+		printf("Making full list      (%4i games)\n", cuenta_juegos(lista,FULL,0));
+		MakeHTML(lista,FULL,0);
+	}
+
+	printf("\n");
+
+	return(0);
+}
diff --git a/src/unix/contrib/tools/mamecds-1.0/src/mamecds.c b/src/unix/contrib/tools/mamecds-1.0/src/mamecds.c
new file mode 100644
index 0000000..0ba029c
--- /dev/null
+++ b/src/unix/contrib/tools/mamecds-1.0/src/mamecds.c
@@ -0,0 +1,477 @@
+#include <sys/stat.h>
+#include <sys/types.h>
+#include <unistd.h>
+#include "utils.h"
+#include "gamelist.h"
+#include "mamecds.h"
+#include "html.h"
+
+int MakeIso (void)
+{
+	char command[MAXCAD];
+	char srcdir[MAXCAD];
+	char image[MAXCAD];
+
+	if (!generatecds) return(OK);
+
+	sprintf(srcdir,"%s/%s/%s/",basedir,tmpdir,cddir);
+	sprintf(image,"%s/%s/%s.iso",basedir,tmpdir,cddir);
+
+	sprintf(command,"mkisofs -r -R -J -o %s %s",image,srcdir);
+	printf("Generating %s\n", image);
+
+	system(command);
+
+	return(OK);
+}
+
+
+int CreateLinks (struct mamegame *juego, int tipo, int ncd)
+{
+	char src[MAXCAD];
+	char dst[MAXCAD];
+
+	sprintf(dstromsdir,"%s/%s/%s/%s", basedir, tmpdir, cddir, romsdir);
+	sprintf(dstlistdir,"%s/%s/%s/%s", basedir, tmpdir, cddir, listdir);
+
+	/* Link de la rom */
+	if (tipo==NEOGEO)
+	{
+		sprintf(src, "%s/%s/%s.zip", srcbasedir, neogeodir, juego->base);
+		sprintf(dst, "%s/%s/%s.zip", dstromsdir, neogeodir, juego->base);
+		if (link(src,dst)==-1)
+		{
+			printf("Can't link %s %s\n", src, dst);	
+		}
+	}
+	else if (tipo==MAME)
+	{
+		if (juego->hasgame)
+		{
+			sprintf(src, "%s/%s/%s.zip", srcbasedir, mamedir, juego->base);
+			sprintf(dst, "%s/%s/%s.zip", dstromsdir, mamedir, juego->base);
+			if (link(src,dst)==-1)
+			{
+				printf("Can't link %s %s\n", src, dst);	
+			}
+		}
+
+		/* Link de los samples */
+		if (juego->hassamples)
+		{
+			sprintf(src,"%s/%s/%s.zip", srcbasedir, samplesdir, juego->base);
+			sprintf(dst,"%s/%s/%s.zip", dstromsdir, samplesdir, juego->base);
+			if (link(src,dst)==-1)
+			{
+				printf("Can't link %s %s\n", src, dst);	
+			}
+		}
+
+		/* Link del artwork */
+		if (juego->hasartwork)
+		{
+			sprintf(src,"%s/%s/%s.zip", srcbasedir, artworkdir, juego->base);
+			sprintf(dst,"%s/%s/%s.zip", dstromsdir, artworkdir, juego->base);
+			if (link(src,dst)==-1)
+			{
+				printf("Can't link %s %s\n", src, dst);	
+			}
+		}
+
+	}
+
+	if (generatelist)
+	{
+		/* Link del titulo */
+		if (juego->hastitle)
+		{
+			sprintf(src,"%s/%s/%s.gif", srclistdir, titlesdir, juego->base);
+			sprintf(dst,"%s/%s/%s.gif", dstlistdir, titlesdir, juego->base);
+			if (link(src,dst)==-1)
+			{
+				printf("Can't link %s %s\n", src, dst);	
+			}
+		}
+
+		/* Link de la imagen */
+		if (juego->hasimage)
+		{
+			sprintf(src,"%s/%s/%s.gif", srclistdir, imagesdir, juego->base);
+			sprintf(dst,"%s/%s/%s.gif", dstlistdir, imagesdir, juego->base);
+			if (link(src,dst)==-1)
+			{
+				printf("Can't link %s %s\n", src, dst);	
+			}
+		}
+	}
+
+	return(OK);
+}
+
+int InsertGame (struct mamegame *lista, struct mamegame *juego, int tipo, int ncd, int tamanyoparcial)
+{
+	int tamanyo, i;
+	struct mamegame *clon;
+
+#ifdef DEBUG_CD
+	printf("\tInserting %8s in CD %02i (%i %i)\n",juego->base, ncd, juego->tamanyo, tamanyoparcial);
+#endif
+
+	/* cabe el juego y los clones? (imagenes, html, artwork y samples estan incluidos en el tamao) */
+	tamanyo=juego->tamanyo;
+	juego->numerocd=ncd;	
+
+	i=0;
+	if (juego->hasclones)
+	{
+		while (strcmp(juego->clones[i],"")!=0)
+		{
+			clon=lista;
+			while (clon!=NULL)
+			{
+				if (strcmp(clon->base, juego->clones[i])==0)
+				{
+#ifdef DEBUG_CD
+					printf("\t    Clone %8s in CD %02i (%i %i)\n",clon->base, ncd, clon->tamanyo, tamanyoparcial);
+#endif
+					/* Clon encontrado */
+					tamanyo+=clon->tamanyo;
+					clon->numerocd=ncd;	
+					i++;
+				}
+				else
+				{
+					clon=clon->next;
+				}
+			}
+		}
+	}
+
+	if ((tamanyo+tamanyoparcial) > tamanyocd) 
+	{
+#ifdef DEBUG_CD
+		printf("\tRemoving  %8s in CD %02i (%i %i)\n",juego->base, ncd, juego->tamanyo, tamanyoparcial);
+#endif
+		juego->numerocd=0;	
+
+		i=0;
+		if (juego->hasclones)
+		{
+			while (strcmp(juego->clones[i],"")!=0)
+			{
+				clon=lista;
+				while (clon!=NULL)
+				{
+					if (strcmp(clon->base, juego->clones[i])==0)
+					{
+						/* Clon encontrado */
+						clon->numerocd=0;	
+						i++;
+					}
+					else
+					{
+						clon=clon->next;
+					}
+				}
+			}
+		}
+		return ERROR;
+	}
+	else
+	{
+		juego->numerocd=ncd;
+
+		/* Creamos todos los links correspondientes */
+
+		CreateLinks(juego,tipo,ncd);
+
+		i=0;
+		if (juego->hasclones)
+		{
+			while (strcmp(juego->clones[i],"")!=0)
+			{
+				clon=lista;
+				while (clon!=NULL)
+				{
+					if (strcmp(clon->base, juego->clones[i])==0)
+					{
+						/* Clon encontrado */
+						CreateLinks(clon,tipo,ncd);
+						i++;
+					}
+					else
+					{
+						clon=clon->next;
+					}
+				}
+			}
+		}
+
+		return(tamanyo);
+	}
+}
+
+/* Retorna numoero de cd + 1 o LASTCD si ya no quedan mas juegos */ 
+int MakeCD (struct mamegame *lista, int tipo, int ncd)
+{
+	char aux[MAXCAD];
+	char src[MAXCAD];
+	char basecd[MAXCAD];		/* Directorio base del CD 			*/
+	char baseroms[MAXCAD];		/* Directorio base de las roms 		*/
+	char basesamples[MAXCAD];	/* Directorio base de los samples 	*/
+	char baseartwork[MAXCAD];	/* Directorio base del artwork	 	*/
+	char baselista[MAXCAD];		/* Directorio base de la lista 	 	*/
+	char basetitles[MAXCAD];	/* Directorio de titulos 			*/
+	char baseimages[MAXCAD];	/* Directorio de imagenes 		 	*/
+
+	char srcroms[MAXCAD];		/* Directorio con las roms 			*/
+	char neogeozip[MAXCAD];		/* Path completo de la bios de neogeo */
+	char cvszip[MAXCAD];		/* Path completo de la bios de cvs 	*/
+	char playchzip[MAXCAD];		/* Path completo de la bios de playchoice */
+	char decocasszip[MAXCAD];	/* Path completo de la bios de decocass */
+	char srcimages[MAXCAD];		/* Directorio con las imagenes		*/
+	char srctitles[MAXCAD];		/* Directorio con los titulos		*/
+	char srcsamples[MAXCAD];	/* Directorio con los samples		*/
+	char srcartwork[MAXCAD];	/* Directorio con el artwork		*/
+
+	int tamanyo, tamanyototal;
+	struct mamegame *actual;
+	struct stat buff;
+
+	/* Creamos los directorios */
+	sprintf(basecd,"%s/%s/%s", basedir, tmpdir, cddir);
+	mkdir(basecd,S_IRWXU|S_IRWXG|S_IRWXO);									/* ./tmp/cddir-ncd 						*/
+
+	sprintf(baseroms,"%s/%s",basecd,romsdir);
+	mkdir(baseroms,S_IRWXU|S_IRWXG|S_IRWXO);								/* ./tmp/cddir-ncd/roms					*/
+
+	if (tipo==NEOGEO) 	
+	{
+		sprintf(baseroms,"%s/%s/%s",basecd,romsdir,neogeodir);
+		mkdir(baseroms,S_IRWXU|S_IRWXG|S_IRWXO);							/* ./tmp/cddir-ncd/roms/neogeo			*/
+
+		sprintf(srcroms,"%s/%s", srcbasedir, neogeodir);					/* /home/carlitos/roms/neogeo			*/
+		sprintf(neogeozip,"%s/neogeo.zip", srcroms);
+	}
+	if (tipo==MAME) 	
+	{
+		sprintf(baseroms,"%s/%s/%s",basecd,romsdir,mamedir);				/* ./tmp/cddir-ncd/roms/mame			*/
+		mkdir(baseroms,S_IRWXU|S_IRWXG|S_IRWXO);
+
+		sprintf(srcroms,"%s/%s", srcbasedir, mamedir);						/* /home/carlitos/roms/mame				*/
+		sprintf(cvszip,"%s/cvs.zip", srcroms);
+		sprintf(playchzip,"%s/playch10.zip", srcroms);
+		sprintf(decocasszip,"%s/decocass.zip", srcroms);
+
+		/* Los juegos de MAME pueden tener samples y artwork */
+		sprintf(basesamples,"%s/%s/%s",basecd,romsdir,samplesdir);
+		mkdir(basesamples,S_IRWXU|S_IRWXG|S_IRWXO);							/* ./tmp/cddir-ncd/roms/samples			*/
+
+		sprintf(baseartwork,"%s/%s/%s",basecd,romsdir,artworkdir);
+		mkdir(baseartwork,S_IRWXU|S_IRWXG|S_IRWXO);							/* ./tmp/cddir-ncd/roms/artwork			*/
+
+		sprintf(srcroms,"%s/%s", srcbasedir, mamedir);						/* /home/carlitos/roms/mame				*/
+		sprintf(srcsamples,"%s/%s/%s", srcbasedir, romsdir, samplesdir);	/* /home/carlitos/roms/samples			*/
+		sprintf(srcartwork,"%s/%s/%s", srcbasedir, romsdir, artworkdir);	/* /home/carlitos/roms/artwork			*/
+	}
+
+	if (generatelist)
+	{
+		sprintf(baselista,"%s/%s",basecd,listdir);
+		mkdir(baselista,S_IRWXU|S_IRWXG|S_IRWXO);								/* ./tmp/cddir.ncd/lista				*/
+
+		sprintf(basetitles,"%s/%s",baselista,titlesdir);
+		mkdir(basetitles,S_IRWXU|S_IRWXG|S_IRWXO);								/* ./tmp/cddir.ncd/lista/titulos		*/
+
+		sprintf(baseimages,"%s/%s",baselista,imagesdir);
+		mkdir(baseimages,S_IRWXU|S_IRWXG|S_IRWXO);;								/* ./tmp/cddir.ncd/lista/images			*/
+
+
+		sprintf(srcimages,"%s/%s", srclistdir, imagesdir);						/* /home/lista/images					*/
+		sprintf(srctitles,"%s/%s", srclistdir, titlesdir);						/* /home/lista/titulos					*/
+	}
+
+	/* Reservamos 7 Mb para los ficheros html */
+	tamanyototal=7*1024*1024;
+
+	if (tipo==NEOGEO) 	
+	{
+		/* Si son de neogeo necesitamos la BIOS */	
+		/* Creamos el link a neogeo.zip */
+		sprintf(aux,"%s/neogeo.zip",baseroms);
+		link(neogeozip,aux);
+		stat(neogeozip,&buff);
+		tamanyototal+=buff.st_size;
+
+		if (generatelist)
+		{
+			sprintf(src,"%s/neogeo.jpg",srcimages);
+			sprintf(aux,"%s/neogeo.jpg",baseimages);
+			link(src,aux);
+			stat(aux,&buff);
+			tamanyototal+=buff.st_size;
+		}
+	}
+	if (tipo==MAME) 	
+	{
+		/* Creamos el link a cvs.zip */
+		sprintf(aux,"%s/cvs.zip",baseroms);
+		link(cvszip,aux);
+		stat(cvszip,&buff);
+		tamanyototal+=buff.st_size;
+
+		/* Creamos el link a playch10.zip */
+		sprintf(aux,"%s/playch10.zip",baseroms);
+		link(playchzip,aux);
+		stat(playchzip,&buff);
+		tamanyototal+=buff.st_size;
+
+		/* Creamos el link a decocass.zip */
+		sprintf(aux,"%s/decocass.zip",baseroms);
+		link(decocasszip,aux);
+		stat(decocasszip,&buff);
+		tamanyototal+=buff.st_size;
+
+		if (generatelist)
+		{
+			sprintf(src,"%s/mame.jpg",srcimages);
+			sprintf(aux,"%s/mame.jpg",baseimages);
+			link(src,aux);
+			stat(aux,&buff);
+			tamanyototal+=buff.st_size;
+		}
+	}
+
+	if (generatelist)
+	{
+		sprintf(src,"%s/limage.gif",srcimages);
+		sprintf(aux,"%s/limage.gif",baseimages);
+		link(src,aux);
+		stat(aux,&buff);
+		tamanyototal+=buff.st_size;
+
+		sprintf(src,"%s/anterior.jpg",srcimages);
+		sprintf(aux,"%s/anterior.jpg",baseimages);
+		link(src,aux);
+		stat(aux,&buff);
+		tamanyototal+=buff.st_size;
+
+		sprintf(src,"%s/centro.jpg",srcimages);
+		sprintf(aux,"%s/centro.jpg",baseimages);
+		link(src,aux);
+		stat(aux,&buff);
+		tamanyototal+=buff.st_size;
+
+		sprintf(src,"%s/siguiente.jpg",srcimages);
+		sprintf(aux,"%s/siguiente.jpg",baseimages);
+		link(src,aux);
+		stat(aux,&buff);
+		tamanyototal+=buff.st_size;
+
+		sprintf(src,"%s/noimage.gif",srcimages);
+		sprintf(aux,"%s/noimage.gif",baseimages);
+		link(src,aux);
+		stat(aux,&buff);
+		tamanyototal+=buff.st_size;
+
+		sprintf(src,"%s/notitle.gif",srctitles);
+		sprintf(aux,"%s/notitle.gif",basetitles);
+		link(src,aux);
+		stat(aux,&buff);
+		tamanyototal+=buff.st_size;
+	}
+
+	actual=lista;
+	while (1)
+	{
+		/* El juego pertenece a algun CD? */
+		if (actual->numerocd==0)
+		{
+			/* Es del tipo que le hemos dicho? */
+			if (actual->tipo==tipo)
+			{
+				/* Si es un clonico se insertara con su original */
+				if (!actual->isclone)
+				{
+					tamanyo=InsertGame(lista, actual, tipo, ncd, tamanyototal);
+					if (tamanyo==ERROR)
+					{
+#ifdef DEBUG_CD
+						printf("Size of CD %02i %i\n", ncd, tamanyototal);
+#endif
+						/* El juego no ha cabido en el CD */
+						return ncd+1;
+					}
+					else
+					{
+						tamanyototal+=tamanyo;
+					}
+				}
+			}
+			else	
+			{
+#ifdef DEBUG_CD_WARNINGS
+				printf("%8s (%i) is not of type %i\n",actual->base, actual->tipo, tipo);
+#endif
+			}
+		}
+		else
+		{
+#ifdef DEBUG_CD_WARNINGS
+			if (!actual->isclone) printf("%8s is in CD %02i\n",actual->base, actual->numerocd);
+#endif
+		}
+
+		if (actual->next==NULL) 
+		{
+#ifdef DEBUG_CD
+			printf("Size of CD %02i %i\n", ncd, tamanyototal);
+#endif
+			return LASTCD;
+		}
+		actual=actual->next;
+	}
+
+	return ncd+1;
+}
+
+int CreateCDS (struct mamegame *lista, int tipo)
+{
+	int ncd;	/* CD number */
+	int ret;
+
+	/* Creamos el direcrotio temporal */
+	mkdir(tmpdir,S_IRWXU|S_IRWXG|S_IRWXO);
+
+	ncd=1;	
+	ret=MORECDS;
+	if (tipo==MAME)
+	{
+		while(ret!=LASTCD)
+		{
+			sprintf(cddir,"mame-%02i",ncd);
+			ret=MakeCD(lista,tipo,ncd);
+			printf("Making MAME\tCD %02i (%4i games)\n",ncd, cuenta_juegos(lista,tipo,ncd));
+			MakeHTML(lista,tipo,ncd);
+			MakeIso();
+			ncd++;
+		}
+	}
+
+	ncd=1;	
+	ret=MORECDS;
+	if (tipo==NEOGEO)
+	{
+		while(ret!=LASTCD)
+		{
+			sprintf(cddir,"neogeo-%02i",ncd);
+			ret=MakeCD(lista,tipo,ncd);
+			printf("Making NEOGEO\tCD %02i (%4i games)\n",ncd, cuenta_juegos(lista,tipo,ncd));
+			MakeHTML(lista,tipo,ncd);
+			MakeIso();
+			ncd++;
+		}
+	}
+
+	return 0;
+}
diff --git a/src/unix/contrib/tools/modelines b/src/unix/contrib/tools/modelines
new file mode 100644
index 0000000..e59c41e
--- /dev/null
+++ b/src/unix/contrib/tools/modelines
@@ -0,0 +1,58 @@
+# Wil's xmame.x11 dga fullscreen modelines list
+#
+# most recent version can be had at http://victoria.tc.ca/~wi534/modelines
+#
+# A small warning: many of these modelines really push my hardware.  I
+# have some of them at 110Hz vertical synch rates and others at 30 and
+# 62KHz horizontal synch rates.  If you have configured your XF86Config
+# file's display section correctly then modes outside the safe operating
+# range for your monitor will be skipped.  Otherwise, well, I can't be
+# responsible for you blowing up your display hardware.  
+#
+# Use at your own risk!
+#
+# Feel free to offer suggestions and ask for new resolutions.  I'm not
+# sure which ones I may have missed.
+#
+# mailto://wi534@victoria.tc.ca with 'Modelines' in the subject heading.
+
+# vertical orientation screens:
+
+Modeline "224x256"  22.0  224 318 416 460  256 260 266 270 doublescan
+Modeline "240x256"  24.0  240 318 396 468  256 260 266 270 doublescan
+Modeline "256x256"  26.0  256 340 412 504  256 260 266 270 doublescan
+Modeline "256x304"  19.00  256 336 400 496  304 307 310 321
+
+# above modelines are perfect
+
+Modeline "248x320"  16.75  248 332 396 484  320 323 326 337
+Modeline "248x368"  16.75  248 332 396 484  368 371 374 385
+Modeline "248x384"  16.75  248 332 396 484  384 387 390 401
+# above modelines are 5% thin for 224,
+# 2% fat for 240, and 5% fat for 248
+
+# "256x480" is handled by 640x480 modeline
+# "480x480" is handled by 640x480 modeline
+
+# horizontal orientation screens (except as noted)
+
+Modeline "320x200"     12.75  320 324 372 388  200 204 206 210 doublescan
+Modeline "224x224"     12.75  224 228 276 288  224 228 230 236 doublescan
+Modeline "256x224"     12.75  256 260 308 320  224 228 230 236 doublescan
+Modeline "288x224"     12.75  288 292 340 352  224 228 230 236 doublescan
+Modeline "320x224"     12.75  320 324 372 388  224 228 230 236 doublescan
+Modeline "256x240"     15.00  256 260 308 320  240 244 246 254 doublescan
+Modeline "292x240"     16.75  292 296 344 356  240 244 246 254 doublescan
+Modeline "320x240"     16.75  320 324 372 388  240 244 246 254 doublescan
+Modeline "336x240"     18.00  336 344 392 417  240 244 246 254 doublescan
+Modeline "384x224"     20.00  384 388 436 480  224 228 230 236 doublescan
+Modeline "384x240"     20.00  384 388 436 480  240 244 246 254 doublescan
+Modeline "360x288"     20.00  360 364 412 444  288 292 298 302 doublescan
+Modeline "360x256"     18.00  360 364 412 444  256 260 266 270 doublescan
+Modeline "400x300"     19.00  400 412 476 500  300 303 306 317
+Modeline "400x256"     22.00  400 416 480 504  256 259 262 269 doublescan
+Modeline "400x224"     20.00  400 416 480 500  224 228 230 234 doublescan
+Modeline "512x384"     25.00  512 516 580 632  384 385 388 400
+ModeLine "640x240"     31.50  640 644 708 788  240 244 246 254 doublescan
+ModeLine "672x240"     31.50  672 676 740 820  240 244 246 254 doublescan
+
diff --git a/src/unix/contrib/tools/readme b/src/unix/contrib/tools/readme
new file mode 100644
index 0000000..70585e9
--- /dev/null
+++ b/src/unix/contrib/tools/readme
@@ -0,0 +1,108 @@
+Contents of directory contrib/tools
+==========================================
+
+1)      Name:		mame_perl-1.3
+	Author:		Stefan Becker
+	Description:	MAME/Raine ROM sets manager Perl scripts 1.3
+	Notes:		see contrib/tool/mame_perl-1.3/README
+
+2)      Name:		modelines
+	Author:		William A. Barath
+	Description:	XFree 86 modelines defining special resolutions
+			for use with xmame and DGA
+
+3)	Name:		readme
+	Author:		Hans de Goede <hans@highrise.nl>
+	Description:	This file
+
+4)	Name:		romalizer
+	Author:		Christopher Stone <tkmame@ztnet.com>
+	Description:	a rom cleaner/sorting tcl script
+	Notes:		see the contents of the script, or run it with -help
+			for more info
+
+5)	Name:		romulan.pl
+	Author:		Nathan Hand <nathanh@chirp.com.au>
+	Description:	Perl script I've been working on to keep track of
+                        split romsets. Relies on xmame + unzip binaries being
+                        available, doesn't support merged sets, doesn't
+                        support unzipped sets, doesn't examine ~/.xmamerc,
+                        doesn't do a lot really. I use it personally though,
+                        and I find it useful.
+                        
+                        Has some neat routines (in perl) to get romset info
+                        out of xmame or the zipfile. Might be useful to other
+                        romset analyzer developers.
+
+6)	Name:		xlistdev.c
+	Author:		??
+	Description:	This program lists all X Input extension devices
+
+7)	Name:		xmame-screensaver
+	Author:		Hans de Goede <hans@highrise.nl>
+	Description:	A little script to run a random game in the root
+			window for 2 minutes and then run another random game
+			etc. Use this as the extern command for xscreensaver.
+	Usage:		- compile the x11 version of xmame
+			- install it somewhere in your path
+			- copy xmame-screensaver to /usr/games
+			- edit ~/.xscreensaver , and add a line:
+			  /usr/games/xmame-screensaver
+
+8)	Name:		mame-cd
+	Author:		Mario J.Barchin Molina <mbarchein@yahoo.es>
+	Description:	A perl script which sorts MAME roms onto CDs by year and
+			puts all clones on the same CD as the parent.
+	Usage:		See the mame-cd file.  Mario also has this to add:
+			* I don't know if it will do a good job if you don't
+			  have all the roms.
+			* Edit it and configure the parameters in the beginning
+			  of the file.
+			* It's not only for .54.  I've used it from 0.37b11 and
+			  it has worked ok, but YMMV.
+			* Make your CD images  with the "Symlink farm" option or
+			  they will be 1.3 GB instead of 650 MB.
+			* It's a beta program.  Don't blame me too much if it
+			  doesn't work.
+			* Of course is GPL.
+			* I'd love feedback. :)    
+
+9)	Name:		mamecds
+	Author:		Carlos Calzada Grau
+	Description:	Another tool for sorting roms onto CDs.
+	Usage:		mamecds [-n | --neogeo] [-m | --mame]
+				 [-v | --version]
+				 [-s size | --size=size]
+				 [--nocd | -c]
+				 [--nolist | -l]
+				 [--fulllist | -f]
+				 [--help | -h]    
+
+10)     Name:		mame-listmissing
+        Author:		David Griffith
+        Description:	Lists which supported roms are missing from your 
+			collection.
+	Usage:		mame-listmissing [<options>] [<path>]
+
+			<path>	Override whatever default path you've set for 
+				where you keep your roms.  Must be a 
+				colon-seperated path.
+
+			-e	Extension.  If your rom files are contained in
+				something other than .zip files, specify here or
+				modify the default.  This option will go away
+				if/when I decide to use a hash to handle
+				extensions automatically.
+
+			-h	Help.  You're reading it now.
+
+			-v	Invert.  Cause listmissing to report roms that
+				you have installed.
+
+11)	Name:		makecd_mame2.pl
+	Author:		Luc Saillard
+	Description:	This script helps with burning ROMs, flyers, cabinets 
+			onto CDs.  All games on a CD can be played without 
+			requiring ROMs from other CDs.
+	Usage:		makecd_mame.pl gamedir burndir gameslist
+			See script for more information.
diff --git a/src/unix/contrib/tools/romalizer/romalizer b/src/unix/contrib/tools/romalizer/romalizer
new file mode 100755
index 0000000..28814a2
--- /dev/null
+++ b/src/unix/contrib/tools/romalizer/romalizer
@@ -0,0 +1,2059 @@
+#!/usr/bin/tclsh
+#!/home/chris/work/romalizer/MAMELang-lib_0.9.5-tcl/tclang
+#   ^-- This must point to where your tclsh command is located. In order for
+#       translations to work, you must use tclang instead of tclsh.  tclang
+#       is available at http://emuhq.com/mamelang
+
+set version 0.7pre3
+
+# Changes to this version include:
+#   * Fixed a bug that would cause romalizer to crash if it was trying to
+#     rename a ROM that is zipped with a directory, and is not located in the
+#     current working zip file.  For example, a ROM found in chelnov.zip which
+#     is needed for chelnovu.zip and the ROM in chelnov.zip is zipped inside
+#     a directory.  Thanks to David Heremans for the bug report.
+#   * Changed my e-mail address in the source code from ztnet.com to
+#     retrogames.com
+#   * Added a check to see if xmame-0.56 or greater is used.
+#   * Do not prompt for next ROM set if -f is used.
+#   * Added a clarification in the help text to ensure you provide a space
+#     between an option and its value.
+#   * In verbose mode, you are now forced to type / to continue onto the next
+#     ROMset.  Let me know if you don't like this feature and I will make it
+#     optional.  It is designed to prevent you from pressing return too many
+#     times.  Use -v option if you don't like this.
+#   * Added -A option to append all ROMs found in the current working
+#     directory to the parameter list bypassing bash.  This is useful if
+#     your bash command line becomes too long for bash to handle.
+#
+# BUGS:
+#   * theend, fshark, omega:  don't seem to rename the internal ROMs correctly
+#   * darius2:  says ROM names are incorrect when checking all ROMs at once
+#
+# TODO for 0.7:
+#   * create NO GOOD DUMP KNOWN ROMs with dd if=/dev/urandom 
+#   * finish off new fix_roms routines
+#       - for romdirs that have multiple directories, the first directory
+#         is assumed to be the main ROMs directory, subsequent directories
+#         are assumed to be unnecessary.  For example, if you have multiple
+#         ROMs and the set in the main directory is valid, then the solution
+#         is to remove the set from the secondary directory.
+#   * fix known bugs
+#   * massive testing!
+
+# set default values for command line options
+
+set xmame [auto_execok xmame.x11]       ;  # default xmame executable
+set zip   [auto_execok zip]             ;  # location of zip command
+set unzip [auto_execok unzip]           ;  # location of unzip command
+set workd [file join / tmp romalizer]   ;  # working directory
+set verbose no                          ;  # sets verbosity (yes/no)
+set verbose_status yes                  ;  # sets status report verbosity
+set force   no                          ;  # autocreate new ROMs? (yes/no)
+set noex    no                          ;  # do not execute commands
+set logfile ""                          ;  # log file ("" == no logging)
+set c_level 6                           ;  # default compression level
+set cutoff  150                         ;  # cutoff value (see help file)
+set check_names yes                     ;  # check file names too?
+set merged 0                            ;  # merge clones (changed with -g/-G)
+set move_zips no                        ;  # move zips after fixing them
+set zip_empty no                        ;  # create zip files for clones w/-g
+set ignorebios yes                      ;  # ignore crcs matching bios roms
+
+##########################################################################
+#
+#  Please do not modify anything below this point unless you really know
+#  what you are doing!
+#
+##########################################################################
+
+set help "
+  romalizer(1)                                               romalizer(1)
+
+
+  NAME
+         romalizer - analyze and fix ROMs used for xmame
+
+  SYNOPSIS
+         romalizer \[-f\] \[-g\] \[-h\] \[-i\] \[-m\] \[-n\] \[-v\] \[-s\] \[-G\] \[-V\]
+         \[-c level\] \[-d workdir\] \[-l logfile\] \[-r rompath\] \[-x xmame\]
+         \[-A directory\] \[-C cutoff\] ROM ...
+
+  DESCRIPTION
+         romalizer will examine the  ROM(s) specified on the command line
+         as well as all the  clones for each ROM.  If ROM is a clone then
+         the   associated parent   ROM is used   instead, any   resulting
+         duplicate ROMs  will be ignored, thus using  wildcards such as *
+         will not result in reexamining the same ROM twice.  The ROM that
+         is specified  may be the short name  recognized by xmame, or the
+         full path name to the zip file.
+
+         During the examination process, romlizer compares the CRCs found
+         in xmame with  those in your zip files.  If any extra  files are
+         stored  in your zip files,  romalizer detects them  and issues a
+         report.  romalizer is  also capable  of  building  new zip files
+         from your existing zip files if any discrepancies are found.
+
+         romalizer  assumes that   files belonging  solely to  a clone be
+         placed in a  separate zip file with that clones name.  romalizer
+         will  not merge two  zip files,  it only analyzes  the first zip
+         file found in the rompath specified.
+
+         When specifying  options with romalizer  please always provide a
+         space between the option and it's value.   For example, use -c 9
+         instead of -c9.
+
+  OPTIONS
+         -c  level
+                This specifies the compression level  you want to use for
+                your  zip files.  0 indicates  no compression,  1 is  the
+                fastest compression,  and 9 is the  slowest.  The default
+                is 6.
+
+         -d  workdir
+                This  specifies  the  directory  where  romalizer  places
+                temporary  working files, and backs up your old ROMs when
+                building new  ones if the -M option is used.  The default,
+                if not specified, is set to /tmp/romalizer.
+
+         -l  logfile
+                This will send  output which is sent to  the console when
+                the -v option is used to a file specified by logfile.  If
+                both the -l and -v options are used, then  output will be
+                sent to both the console and the logfile specified.
+
+         -r  rompath
+                Specifies  the rompath  to use when looking  for your zip
+                files.  If  not  specified,  romalizer  uses the  rompath
+                specified in your ~/.xmamerc file.
+
+         -x  xmame
+                Specifies the location of the xmame executable to use for
+                checking  CRC values.  The default,  if not specified, is
+                xmame.x11.
+
+         -A  directory
+                Add all  ROMs found  in directory  to the parameter list.
+                This  is useful  if your list  of ROMs  specified on  the
+                parameter  list  is  too  long for  bash to  handle.  For
+                example:   -A /mylongpathtoroms  and  /mylongpathtoroms/*
+                are functionally  equilivalent,  except the -A version is 
+                not expanded by bash.
+
+         -C  cutoff
+                Specifies the  cutoff value for the  number of ROMs which
+                have to be specified on the command line before romalizer
+                checks all CRCs at once instead of one ROM at a time. The
+                default is 150.
+
+         -f     Force  creation  of  new  ROMs.  With  this  option  set,
+                romalizer will  automatically create new ROMs for you and
+                delete  your old ROMs.  This option is useful if you want
+                to automatically fix a  large number  of ROMs, and you do
+                not want  to backup your old  ROMs.  This option  is also
+                used frequently with the -n option.
+
+         -g     Tells romalizer you want  to merge your clone ROMs into a
+                single file rather than one file for each clone.
+
+         -h     Prints out this descriptive help file.
+
+         -i     Do  not ignore  bios ROMS.  The  default  behavior is  to
+                ignore CRCs which match  those of neogeo or playchoice-10
+                bios ROMs.  If you are  verifying a set  of ROMs which do
+                not  include these  bios ROMs,  you may want to  use this
+                option.
+
+         -m     Do not check file names as well as CRC values in your zip
+                files.
+
+         -n     Do not  execute commands,  but  instead just  print  what
+                commands romalizer would execute if -n option is not used.
+
+         -s     Verbose mode.  This  option  will  print  all  the  shell
+                commands it is trying to execute to stdout.
+
+         -v     Verbose mode  (status mode).  The default is to print the
+                extra verbosity  in the status reports,  use -v option to
+                lower the verbosity of the status reports.
+
+         -z     When used with the -g option,  romalizer will build empty
+                zip files  for the clone roms.  This is useful for front-
+                ends to easily  identify which clone ROMs you have.  This
+                option has no effect if the -g option is not used.
+
+         -G     Tells romalizer  that you want to have a  complete set of
+                ROMs in each zip file so that a clone may run independent
+                of the parent zip file.
+
+         -M     Move fixed  ROMs into  ROM path and  backup the  old ROMs
+                into the working directory.
+
+         -V     Prints version number and exits.
+
+  EXAMPLES
+         To verify all your ROMs that start with the letter `a' use:
+
+                romalizer /usr/local/share/xmame/roms/a*
+
+         To verify all roms in the current directory use:
+
+                romalizer -A .
+
+         To see what romalizer would do without doing anything use:
+
+                romalizer -v -n pacman
+
+         To automatically fix any ROMs that romalizer sees problems with:
+
+                romalizer -f pacman galaga joust
+
+         Here is an example I use when a new version of xmame comes out:
+
+                romalizer -f -v -n -x ~/xmame.x11 -r ~/old:~/new ~/new/roms/*
+
+         My  ~/old/roms  directory contains my old xmame ROMs, and the
+         ~/new/roms directory contains the new ROMs
+
+         In  your directory  of fixed ROMs,  you can use  this command to
+         verify that romalizer has worked properly:
+
+                for i in *;do xmame -verifyroms `basename \$i .zip`>>outf;done
+
+         Then, you can examine the file 'outf' for any errors. 
+
+  ENVIRONMENT
+         MAMELANG
+                Specify the translation file to use if you are running
+                this script with a modified version of Tcl that supports
+                MAMELANG.  (See: http://www.emuhq.com/mamelang/)
+
+         ROMPATH
+                Overrides the  rompath specified  in the ~/.xmamerc file.
+                If a rompath is  specified on the command line, then that
+                is used instead of the environment setting.
+
+         PATH
+                Used to locate zip, unzip, and xmame commands.
+
+  SEE ALSO
+         xmame(6)
+
+  AUTHOR
+         romalizer  is written by  Christopher Stone  <tkmame@retrogames.com>.
+         If you have any ideas or  suggestions on improving this software
+         please let me know.
+
+  BUGS
+         NeoGeo bios ROMs are assumed to be in neogeo.zip and will not be
+         included in NeoGeo zip files when using the -G option.
+"
+
+# create a 'fake' mamelang command if mamelang is not compiled into tcl
+# this will allow your script to work even if the user doesnt want to use
+# tclang.
+if { [lsearch [info commands] "mamelang"] == -1 } {
+    proc mamelang args {
+        foreach value $args {
+            append return_value $value
+        }
+        return $return_value
+    }
+}
+
+
+# this function is used to allow mamelang to translate the help file.
+proc print_help {} {
+    global help
+
+    catch {
+	foreach line [split $help \n] {
+	    puts [mamelang $line]
+	}
+    }
+}
+
+# procedure to print fatal errors to stdout and exit
+proc fatal_error error_text {
+    global argv0
+    set lines [split $error_text \n]
+    for { set lineno 0 } { $lineno < [llength $lines] } { incr lineno } {
+	set line [lindex $lines $lineno]
+	puts stderr "$argv0: $line"
+    }
+    exit
+}
+
+# parse command line
+if { $argc } { 
+    for { set i 0 } { $i < $argc } { incr i } {
+	set opt [lindex $argv $i]
+	switch -exact -- $opt {
+	    -h { print_help ; exit }
+	    -? { print_help ; exit }
+	    -V { puts [mamelang "$argv0" ": " "version" " $version"] ; exit }
+	    -i { global ignorebios; set ignorebios no }
+	    -s { global verbose ; set verbose yes }
+	    -v { global verbose_status ; set verbose_status no }
+	    -f { global force ; set force yes }
+            -m { global check_names ; set check_names no }
+	    -M { global move_zips ; set move_zips yes }
+	    -n { global noex ; set noex yes }
+	    -g { global merged ; set merged 1 }
+	    -G { global merged ; set merged 2 }
+	    -z { global zip_empty ; set zip_empty yes }
+	    -c { incr i ; set c_level [lindex $argv $i] }
+	    -d { incr i ; set workd [lindex $argv $i] }
+	    -l { incr i ; set logfile [lindex $argv $i] }
+	    -r { incr i ; set path  [lindex $argv $i] }
+            -x { incr i ; set xmame [lindex $argv $i] }
+	    -C { incr i ; set cutoff [lindex $argv $i] }
+	    -A { incr i ; set globpath [lindex $argv $i]
+		lappend roms [lsort [glob -directory $globpath *]] }
+	    default { lappend roms [lrange $argv $i end] ; break }
+	}
+    }
+}
+
+# check if any roms were specified on the command line
+proc printhelp {} {
+    global argv0 env
+
+    if { [info exists env(PAGER)] } {
+	set pager $env(PAGER)
+    } else {
+	set pager "more"
+    }
+    fatal_error [mamelang "Missing ROM!" "  " "Try" " `$argv0 -h | $pager' " \
+		     "for more options."]
+}
+if { ![info exists roms] || !$argc } {
+    printhelp
+}
+
+# This function is now used to replace the previous remove_zip function
+proc basename { path extension } {
+    return [eval exec basename $path $extension]
+}
+
+# convert any zipfiles on command line to romnames
+foreach romgroup $roms {
+    foreach rom [split $romgroup] {
+        lappend newroms [basename $rom .zip]
+    }
+}
+set roms [lsort $newroms]
+
+# create logfile is logging was specified
+if { $logfile != "" } { 
+    set logfiled [open $logfile w]
+}
+
+# logging routine
+proc myputs data {
+    global logfile logfiled verbose
+
+    if { $logfile != "" } {
+	puts $logfiled $data
+    }
+
+    if { $verbose } { 
+	puts $data
+    }
+}
+
+# check compression level
+if { $c_level < 0 || $c_level > 9 } {
+    puts stderr [mamelang "$argv0: " "Invalid compression level specified" \
+		     ": $c_level"]
+    exit
+}
+
+# check to see if you have zip and unzip commands
+if { $zip == "" || $unzip == "" } {
+    puts stderr [mamelang "$argv0: " \
+		     "Unable to locate zip and/or unzip commands."]
+    exit
+}
+
+# procedure to read the output of a command
+set failure_okay 0
+proc read_command command {
+    global argv0 failure_okay
+
+    set fileid ""
+    set rc [catch { set fileid [open |$command r] }]
+    if { $failure_okay != 1 && $rc == 1 } {
+	fatal_error [mamelang "Unable to execute command" ":\n$command\n" \
+			 "Please send a bug report to" " tkmame@retrogames.com"]
+    } elseif { $rc == 1 } {
+	set failure_okay 0
+	return ""
+    } else {
+	set failure_okay 0
+	if { $fileid != "" } {
+	    set data [read $fileid]
+	    catch {
+		close $fileid
+	    }
+	}
+	return $data
+    }
+}
+
+# procedure to evaluate commands which are supposed to work
+proc evalcmd { command } {
+    if { [catch { eval exec $command }] == 1 } {
+	fatal_error [mamelang "Unable to execute command" ":\n$command\n" \
+			 "Please send a bug report to" " tkmame@retrogames.com"]
+    }
+}
+
+# make sure unzip is version 5.41 or greater (y2k bug)
+set unzip_version [lindex [split [read_command "\"$unzip\" -v"] \ ] 1]
+if { $unzip_version < 5.41 } {
+    fatal_error [mamelang "Please upgrade to UnZip version 5.41 or greater" \
+		     ".\nftp://ftp.info-zip.org/pub/infozip/"]
+}
+
+# make sure we are using a recent xmame
+set version [read_command "\"$xmame\" -version"]
+set ver_index [string first "0." $version]
+set xmame_version [string range $version $ver_index [expr $ver_index + 4]]
+if { $xmame_version < 0.56 } {
+    fatal_error [mamelang "Please use xmame-0.56.2 or greater (-x option)."]
+}
+
+# create working directory
+if { ![file isdirectory $workd] } {
+    file mkdir $workd
+}
+
+# get all the clones for each rom first find the masters for each clone
+if { $verbose == "no" } {
+    puts -nonewline [mamelang "Obtaining clone information" "\t"]
+    flush stdout
+}
+set command "\"$xmame\" -listclones"
+myputs $command
+set lines [split [read_command $command] \n]
+foreach line $lines {
+    # get name of the clone
+    set clone [string trimright [string range $line 0 7]]
+    # skip header crap
+    if { [string match "Name*" $clone] || $clone == "" } {
+	continue
+    }
+    # get rom name
+    set rom [string trimright [string range $line 9 end]]
+    # make a list of non-clones that have clones (i'll call these masters)
+    if { ![info exists masters] || [lsearch $masters $rom] == -1 } {
+	lappend masters $rom
+    }
+    # make a list of clones for each master
+    lappend clones($rom) $clone
+    # create an associatve array of clones and masters
+    set master_of($clone) $rom
+}
+if { $verbose == "no" } {
+    puts [mamelang "Done"]
+}
+
+# get all non-clones
+if { $verbose == "no" } {
+    puts -nonewline [mamelang "Obtaining list of ROMs" "\t\t"]
+    flush stdout
+}
+set command "\"$xmame\" -list -noclones"
+myputs $command
+set lines [split [read_command $command] \n]
+foreach line $lines {
+    # skip header crap
+    if { [string match "xmame*" $line] } { 
+	continue
+    }
+    # blank line means we are done
+    if { $line == "" } {
+	break
+    }
+    for { set indx 0 } { $indx < 72 } { incr indx 10 } {
+	# get rom names
+	set endindx [expr $indx + 8]
+	set rom [string trimright [string range $line $indx $endindx]]
+	if { $rom != "" } {
+	    # create list of nonclones, check masters to weed out neogeos
+	    if { ![info exists master_of($rom)] } {
+		lappend nonclones $rom
+	    }
+	}
+    }
+}
+if { $verbose == "no" } { 
+    puts [mamelang "Done"] 
+}
+# remove any duplicate roms specified on command line
+for { set i 0 } { $i < [llength $roms] } { incr i } {
+    set rom [lindex $roms $i]
+    if { [lsearch -exact $nonclones $rom] == -1 } {
+        set roms [lreplace $roms $i $i]
+	if { [info exists master_of($rom)] && 
+	     [lsearch $roms $master_of($rom)] == -1 } {
+	    lappend roms $master_of($rom)
+	}
+        incr i -1
+    }
+}
+# exit if no valid roms were specified on the command line
+if { $roms == "" } {
+    puts stderr [mamelang "$argv0: " "No valid ROMs specified."]
+    printhelp
+}
+# if no path was specified on command line get it from xmame
+if { ![info exists path] } {
+    if { $verbose == "no" } {
+	puts -nonewline [mamelang "Obtaining ROM path" "\t\t"]
+	flush stdout
+    }
+    set command "\"$xmame\" -showconfig"
+    myputs $command
+    set lines [split [read_command $command] \n]
+    foreach line $lines {
+	set line [string trim $line]
+	if { [string compare [string range $line 0 6] "rompath"] == 0 } {
+	    set path [string trim [string range $line 7 end]]
+	    break
+	}
+    }
+    foreach path_element [split $path :] {
+	if { [string compare [basename $path_element ""] samples] &&
+	     [string compare [basename $path_element ""] artwork] } {
+	    append newpath "$path_element:"
+	}
+    }
+    set path $newpath
+    if { $verbose == "no" } {
+	puts [mamelang "Done"]
+    }
+}
+
+# create lookup table for short names and long names
+if { $verbose == "no" } {
+    puts -nonewline [mamelang "Obtaining game descriptions" "\t"]
+    flush stdout
+}
+set command "\"$xmame\" -listfull"
+myputs $command
+set lines [split [read_command $command] \n]
+foreach line $lines {
+    set s_name [string trimright [string range $line 0 7]]
+    if { $s_name == "name" || $s_name == "" || $s_name == "Total Su" ||
+	 $s_name == "--------" } {
+	continue
+    }
+    set l_name [string range $line 10 end]
+    # remove end-quotes from the long name if they exist
+    set l_name [string trim $l_name \"]
+
+    # Rearrange the ,The and ,Le cases
+    set index [string first ", The" $l_name]
+    if { $index != -1 } {
+	set index2 [expr $index + 5]
+        incr index -1
+	set l_name "The [string range $l_name 0 $index][string range $l_name $index2 end]"
+    }
+    set index [string first ", Le" $l_name]
+    if { $index != -1 } {
+	set index2 [expr $index + 4]
+        incr index -1
+	set l_name "Le [string range $l_name 0 $index][string range $l_name $index2 end]"
+    }
+    set name_lookup("$l_name") $s_name 
+}
+if { $verbose == "no" } {
+    puts [mamelang "Done"]
+}
+
+# As of xmame 0.37b9 we have to use -listroms for obtaining
+# crcs for individual roms, and -listcrc for a full crc list
+
+# This function removes CRCs for neogeo and playchoice bios roms
+proc remove_neopc crc {
+    # remove neogeo bios roms to support neogeos
+    # ng-sfix.rom
+    if { [string compare $crc "354029fc"] == 0 } { return 0 }
+    # neo-geo.rom
+    if { [string compare $crc "9036d879"] == 0 } { return 0 }
+    # ng-sm1.rom
+    if { [string compare $crc "97cf998b"] == 0 } { return 0 }
+    # ng-lo.rom
+    if { [string compare $crc "e09e253c"] == 0 } { return 0 }
+    # remove playch10 roms to support play choice 10 roms
+    # pch1-c.8k
+    if { [string compare $crc "9acffb30"] == 0 } { return 0 }
+    # pch1-c.8m
+    if { [string compare $crc "c1232eee"] == 0 } { return 0 }
+    # pch1-c.8p
+    if { [string compare $crc "30c15e23"] == 0 } { return 0 }
+    # pch1-c.8t
+    if { [string compare $crc "d52fa07a"] == 0 } { return 0 }
+    # 82s129.6f
+    if { [string compare $crc "e5414ca3"] == 0 } { return 0 }
+    # 82s129.6e
+    if { [string compare $crc "a2625c6e"] == 0 } { return 0 }
+    # 82s129.6d
+    if { [string compare $crc "1213ebd4"] == 0 } { return 0 }
+    return 1
+}
+
+# This procedure will return 1 if the crc is a NODUMP
+proc crc_nodump crc {
+    return [expr [string compare $crc "00000000"] ? 0 : 1]
+}
+
+# This function is used for getting crc data for a single rom
+proc getsinglecrcdata rom {
+    global xmame crcs name_indx ignorebios NODUMP
+
+    # execute xmame -listroms
+    set command "\"$xmame\" -listroms $rom"
+    myputs $command
+    set lines [split [read_command $command] \n]
+
+    # parse the output of the command
+    foreach line $lines {
+
+	# name is in first 12 chars
+	set name [string trimright [string range $line 0 12]]
+
+	# skip all junk
+	if { [string match "Name*" $line] || [string match "This*" $line] ||
+	     [string match "Total*" $line] || $line == "" } {
+	    continue
+	}
+
+	# crc is at pos. 29 to end
+	set crc [string range $line 29 end]
+
+	# handle NODUMP crcs
+	if { [string match "NO*" $crc] } {
+	    # add name to list of NODUMP names
+	    set crc "00000000"
+	    append NODUMP($rom) "$name "
+	}
+
+	# remove any neogeo or playchoice 10 bios roms
+	if { $ignorebios } {
+	    if { [remove_neopc $crc] == 0 } {
+		continue
+	    }
+	}
+
+	# add this crc to the list of crcs for this rom (we only need 1
+	# instance of a nodump crc to let us know if one exists.)
+	if { ![info exists crcs($rom)] || [lsearch $crcs($rom) $crc] == -1 } {
+	    lappend crcs($rom) $crc
+	}
+
+	# create associative array of crc's and names
+	set name_indx($rom,$crc) $name
+	set name_indx($crc) $name
+    }
+
+    # remove the tailing space from NODUMP roms list
+    if { [info exists NODUMP($rom)] } {
+	set NODUMP($rom) [string trim $NODUMP($rom)]
+    }
+}
+
+# This function is used to get CRC data for all ROMs at once.
+# place CRC information for all roms into data structures
+proc getcrcdata {} {
+    global xmame crcs name_indx name_lookup ignorebios NODUMP roms clones
+
+    # execute the xmame -listcrc command
+    set command "\"$xmame\" -listcrc"
+    myputs $command
+    set lines [split [read_command $command] \n]
+
+    # parse the output of the command
+    foreach line $lines {
+
+	# extract the romname, crc and longname from the output
+	set name [string trimright [string range $line 9 21]]
+	set crc  [string range $line 0 7]
+	set l_name [string range $line 22 end]
+
+	# ignore any header crap
+	if { $line == "" || [string match "CRC*" $line] ||
+	     [string match "Total*" $line] || [string match "--*" $line] ||
+	     [string match "Displ*" $line] } {
+	    continue
+	}
+
+	# make sure we are using a recent mame version.
+	if { ! [info exists name_lookup("$l_name")] } {
+	    fatal_error [mamelang "There seems to be a parsing error with"
+			 "xmame -listfull.  Please make sure romalizer is"
+			 "using the very latest version of xmame (see the"
+			 "-x option."]
+	}
+
+	# lookup the shortname from the longname table
+	set rom $name_lookup("$l_name")
+
+	# add romnames to the list of NODUMP rom names
+	if { [crc_nodump $crc] } {
+	    append NODUMP($rom) "$name "
+	}
+
+	# remove any neogeo or playchoice 10 bios roms
+	if { $ignorebios } {
+	    if { [remove_neopc $crc] == 0 } {
+		continue
+	    }
+	}
+
+	# Add this crc to the list of crcs for this rom (if it doesnt already
+	# exist)
+	if { ![info exists crcs($rom)] || [lsearch $crcs($rom) $crc] == -1 } {
+	    lappend crcs($rom) $crc
+	}
+
+	# create associative array of crc's and names
+	set name_indx($rom,$crc) $name
+    }
+    
+    # remove the tailing space from NODUMP roms list
+    foreach rom [split $roms] {
+	if { [info exists NODUMP($rom)] } {
+	    set NODUMP($rom) [string trim $NODUMP($rom)]
+	}
+	if { [info exists clones($rom)] } {
+	    foreach clone [split $clones($rom)] {
+		if { [info exists NODUMP($clone)] } {
+		    set NODUMP($clone) [string trim $NODUMP($clone)]
+		}
+	    }
+        }
+    }
+}
+
+if { $verbose == "no" } {
+    puts -nonewline [mamelang "Obtaining CRC information" "\t"]
+    flush stdout
+}
+# determine if we should get CRCs one at a time or all at once
+set numofroms 0
+foreach rom [split $roms] {
+    incr numofroms
+    # we need to include clones too
+    if { [info exists clones($rom)] } {
+	foreach clone [split $clones($rom)] {
+	    incr numofroms
+	}
+    }
+}
+if { $numofroms < $cutoff } {
+    set processroms [llength $roms]
+} else {
+    set processroms 0
+}
+# get the necessary CRC data
+if { $processroms == 0 } {
+    getcrcdata
+} else {
+    for { set i 0 } { $i < $processroms } { incr i } {
+	set currentrom [lindex $roms $i]
+	getsinglecrcdata $currentrom
+	if { [info exists clones($currentrom)] } {
+	    foreach clone [split $clones($currentrom)] {
+		getsinglecrcdata $clone
+	    }
+	}
+    }
+}
+if { $verbose == "no" } { puts [mamelang "Done"] }
+
+proc examine_zip { rompath rom } {
+    global unzip argv0 zip_crcs zip_name_indx zip_indx failure_okay
+    global zip_paths zip_crc_indx
+    
+    lappend zip_paths($rom) $rompath
+    set zipname [file join / $rompath ${rom}.zip]
+
+    # use -qv option to look at contents of zip file
+    set command "\"$unzip\" -qv \"$zipname\""
+    myputs "$command"
+    set failure_okay 1
+    set lines [split [read_command $command] \n]
+    if { $lines == "" } {
+	puts stderr [mamelang "$argv0: " "WARNING: " "Unable to read" \
+			 " ${rom}.zip:\t" "skipping."]
+	return -1
+    }
+    set linecount 0
+    foreach line $lines {
+	# skip the first two lines of output
+	if { [incr linecount] <= 2 } { continue }
+	# extract the CRC
+	set crc [string trim [string range $line 47 55]]
+	# ignore blank lines
+	if { $crc == "" } { continue }
+	# extract the name
+	set name [string trim [string range $line 57 end]]
+	# ignore dummy files made by romalizer
+	if { [string compare $name "dummy"   ] && [crc_nodump $crc] } {
+	    continue
+	}
+
+	# build a list of CRCs found in this zipfile
+	lappend zip_crcs($rom,$rompath) $crc
+
+	# locate the zipfile while contains a given crc and name
+	set zip_indx($rom,$crc,$name) $zipname
+	# locate the zipfile which contains a given crc
+	set zip_indx($rom,$crc) $zipname
+	# locate the zipfile if all we have is a crc
+	set zip_indx($crc) $zipname
+
+	# zip file filenames lookup table 
+	set zip_name_indx($rom,$crc) $name
+	set zip_crc_indx($rom,$name) $crc
+    }
+    return 0
+}
+
+proc examine_zips rom {
+    global path zip_paths
+
+    # rc value of -1 means no working zip file has yet been found
+    set rc -1
+    foreach rompath [split $path :] {
+	set zipname [file join / $rompath ${rom}.zip]
+	if { [file exists $zipname] } {
+	    set rc1 [examine_zip $rompath $rom]
+	    # if working zip file not yet found, and this file is read
+	    # properly, then mark rc as working zipfile found
+	    if { ($rc == -1) && ($rc1 != -1) } { set rc 0 }
+	} else {
+	    # check alternate xmame rompath
+	    set altpath [file join / $rompath roms]
+	    set zipname [file join / $altpath ${rom}.zip]
+	    if { [file exists $zipname] } {
+		set rc1 [examine_zip $altpath $rom]
+		if { ($rc == -1) && ($rc1 != -1) } { set rc 0 }
+	    }
+	}
+    }
+    return $rc
+}
+
+# this procedure will remove all CRCs found in the clones and add them to
+# the master CRC list if they do not already exist there
+proc merge_clones master {
+    global crcs clones
+
+    for { set i 0 } { $i < [llength $clones($master)] } { incr i } {
+	set clone [lindex $clones($master) $i]
+	# foreach clone in master, if crc does not exist in master add crc
+	# to master.  all crcs in the clones are removed
+	if { [info exists crcs($clone)] && [info exists crcs($master)] } {
+	    foreach clone_crc [split $crcs($clone)] {
+		set match_found 0
+		foreach master_crc [split $crcs($master)] {
+		    if { $clone_crc == $master_crc } {
+			set match_found 1
+		    }
+		}
+		if { $match_found == 0 } {
+		    # no match was found so add crc to master
+		    lappend crcs($master) $clone_crc
+		}
+		# remove crc from clone
+		set index [lsearch $crcs($clone) $clone_crc]
+		set crcs($clone) \
+		    [lreplace $crcs($clone) $index $index]
+	    }
+	}
+    }
+}
+
+# this procedure will remove the duplicate CRCs found in all the clones
+# and add them to the required CRCs for the master
+proc examine_clones master {
+    global crcs clones
+    # remove CRCs that are duplicated in clones and add them to master
+    # if master doesnt already have that CRC in its list
+    for { set i 0 } { $i < [llength $clones($master)] } { incr i } {
+	set clone [lindex $clones($master) $i]
+	# compare this one with the rest in the list
+	set j [expr $i + 1]
+	set other_clones [lrange $clones($master) $j end]
+	if { $other_clones == $clone } { continue } ; # fail safe
+	foreach other_clone [split $other_clones] {
+	    foreach clone_crc [split $crcs($clone)] {
+		foreach other_clone_crc [split $crcs($other_clone)] {
+		    if { [string compare $clone_crc "00000000"] != 0 &&
+			 $clone_crc == $other_clone_crc } {
+			# remove crc from crcs list for both clones
+			set index [lsearch $crcs($clone) $clone_crc]
+			set crcs($clone) \
+			    [lreplace $crcs($clone) $index $index]
+			set index [lsearch $crcs($other_clone) $clone_crc]
+			set crcs($other_clone) \
+			    [lreplace $crcs($other_clone) $index $index]
+			# now check if crc is also in the master
+			set match_found 0
+			foreach crc [split $crcs($master)] {
+			    if { $crc == $clone_crc } {
+				set match_found 1
+				break
+			    }
+			}
+			# if crc is not found in master, then add it!
+			if { !$match_found } {
+			    lappend crcs($master) $clone_crc
+			}
+		    }
+		}
+	    }
+	}
+    }
+    # remove CRCs in clones that are already in master
+    if { [info exists crcs($clone)] && [info exists crcs($master)] } {
+	foreach clone [split $clones($master)] {
+	    foreach clone_crc [split $crcs($clone)] {
+		foreach master_crc [split $crcs($master)] {
+		    if { [string compare $clone_crc "00000000"] != 0 &&
+			  $clone_crc == $master_crc } {
+			# remove the crc from the crcs list
+			set index [lsearch $crcs($clone) $clone_crc]
+			set crcs($clone) \
+			    [lreplace $crcs($clone) $index $index]
+			break
+		    }
+		}
+	    }
+	}
+    }
+}
+
+# now lets get all the CRC information in the user's zip files for each
+# rom specified on the command line
+if { $verbose == "no" } { puts [mamelang "Obtaining zipfile information"] }
+foreach current_rom [split $roms] {
+    if { [examine_zips $current_rom] == -1 } {
+	# the zip file was not found, so do not give a report for it
+	puts stderr [format "[mamelang "$argv0: " "WARNING: " "Unable to find"] %-13s [mamelang "skipping."]" "${current_rom}.zip:"]
+	set i [lsearch $roms $current_rom]
+        set roms [lreplace $roms $i $i]
+    }
+    # if a rom has a clone we need to get the CRCs for those too
+    if { [info exists clones($current_rom)] } {
+	foreach clone [split $clones($current_rom)] {
+	    if { [examine_zips $clone] == -1 } {
+		# the zip file was not found, so do not give a report for it
+		puts stderr [format "[mamelang "$argv0: " "WARNING: " "Unable to find"] %-13s [mamelang "skipping."]" "${clone}.zip:"]
+		set i [lsearch $roms $clone]
+		if { $i != -1 } {
+		    set roms [lreplace $roms $i $i]
+		}
+	    }
+	}
+	# here we make sure that any crcs which are required for both the
+	# clone and master are removed from the clone's required crc list.
+	# we also removed crcs duplicated across clones and add them to the
+	# required list of crcs to the master if not already present. Skip
+	# this step if you want each zip to be able to run independantly
+	# of its master.
+	if { $merged == 0 } {
+	    examine_clones $current_rom
+	}
+	# if merge type 1 is selected we want to move all the unique crcs
+	# in the clones and place them in the master.  The clones should
+	# then be removed since they have no CRCs
+	if { $merged == 1 } {
+	    merge_clones $current_rom
+	}
+	if { $merged == 2 } {
+	    ; # nothing to do
+	}
+    }
+}
+
+proc aok { rom item } {
+    puts [format "%10s: ${item}s [mamelang "GOOD"]" $rom] ; flush stdout
+}
+proc notok { rom item } {
+    puts [format "%10s: ${item}s [mamelang "BAD"]!" $rom] ; flush stdout
+}
+
+proc check_names rom {
+return
+    global crcs2 zip_crcs2 name_indx zip_name_indx imperfections_exist
+    global clones argv0
+
+    foreach crc [split $crcs2($rom)] {
+	foreach zip_crc [split $zip_crcs2($rom)] {
+	    if { $zip_crc == $crc } {
+		set a ""
+		if { [info exists name_indx($rom,$crc)] } {
+		    set a $name_indx($rom,$crc)
+		} else {
+		    foreach clone [split $clones($rom)] {
+			if { [info exists name_indx($clone,$crc)] } {
+			    set a $name_indx($clone,$crc)
+			    break
+			}
+		    }
+		}
+		set b $zip_name_indx($rom,$zip_crc)
+		if { [string compare $a $b] } {
+		    puts [mamelang "zip name" " $b " "does not match" " $a"]
+		    set imperfections_exist 1
+		}
+	    }
+	}
+    }
+    if { $imperfections_exist } {
+	notok $rom NAME 
+    } else { 
+	aok $rom NAME
+    }
+}
+
+proc remove_crc { rom crc zip_crc } {
+    global crcs2 zip_crcs2
+    set indx [lsearch $crcs2($rom) $crc]
+    set crcs2($rom) [lreplace $crcs2($rom) $indx $indx]
+    set indx [lsearch $zip_crcs2($rom) $zip_crc]
+    set zip_crcs2($rom) [lreplace $zip_crcs2($rom) $indx $indx]
+}
+
+proc show_missing_files { rom crc inverted_crc } {
+    global zip_indx name_indx title clones
+    if { $inverted_crc != 0 } {
+	set zname [basename $zip_indx($inverted_crc) .zip]
+    } else {
+	set zname [basename $zip_indx($crc) .zip]
+    }
+    if { [string compare $zname $rom] == 0 } {
+	return 
+    }
+    if { $title == 0 } {
+	puts [mamelang "The following files are missing in" " $rom"]
+	set title 1
+    }
+    if { [info exists name_indx($rom,$crc)] } {
+	puts -nonewline "$name_indx($rom,$crc) "
+    } else {
+	foreach clone [split $clones($rom)] {
+	    if { [info exists name_indx($clone,$crc)] } {
+		puts -nonewline "$name_indx($clone,$crc) "
+		break;
+	    }
+	}
+    }
+    if { $inverted_crc != 0 } {
+	puts [mamelang "(" "Found in" ": $zip_indx($inverted_crc))"]
+    } else {
+	puts [mamelang "(" "Found in" ": $zip_indx($crc))"]
+    }
+}
+
+# This procedure will return the inverse of a CRC value
+proc invert_crc crc {
+    return [format "%08x" [expr 0xFFFFFFFF - 0x$crc]]
+}
+
+proc has_clones rom {
+    global clones
+
+    return [info exists clones($rom)]
+}
+
+proc sr_puts { data newline } {
+    global verbose_status
+
+    if { $verbose_status } {
+	if { $newline } {
+	    puts $data
+	} else {
+	    puts -nonewline $data
+	    flush stdout
+	}
+    }
+}
+
+proc sr_print_header rom {
+    sr_puts "\nStatus report for $rom" yes
+    sr_puts "==================" no
+    for { set c [string length $rom] } { $c != 0 } { incr c -1 } {
+	sr_puts "=" no
+    }
+    sr_puts "\n" yes
+}
+
+proc sr_print_footer {} {
+    global force verbose_status
+
+    sr_puts "     " no
+    for { set c 0 } { $c < 7 } { incr c } {
+	sr_puts __________ no
+    }
+    if { $force == "no" && $verbose_status } {
+	flush stdout
+	gets stdin keypress
+    } else {
+	sr_puts "" yes
+    }
+}
+
+proc sr_print_master_status rom {
+    global master_of clones
+
+    if { [info exists master_of($rom)] } {
+	sr_puts "$rom is a clone of $master_of($rom)" yes
+    } else {
+	sr_puts "$rom is the master rom" no
+	if { [info exists clones($rom)] } {
+	    sr_puts ", clones for this romset are:" yes
+	    foreach clone [split $clones($rom)] {
+		sr_puts "\t$clone" yes
+	    }
+	} else {
+	    sr_puts ", there are no clones for this rom." yes
+	}
+    }
+    sr_puts "" yes
+}
+
+proc sr_print_rom_occurrances rom {
+    global zip_paths imperfections merged master_of
+
+    sr_puts "Number of occurrances of $rom.zip: " no
+    if { [info exists zip_paths($rom)] } {
+	sr_puts "[llength $zip_paths($rom)]" yes
+	foreach path [split $zip_paths($rom)] {
+	    sr_puts "\t[file join / $path $rom.zip]" yes
+	}
+	if { [llength $zip_paths($rom)] > 1 } {
+	    append imperfections "multiple_romsets "
+	}
+	if { ( $merged == 1 ) && [info exists master_of($rom)] == 1 } {
+	    if { [string match *multiple_romsets* $imperfections] == 0 } {
+		append imperfections "multiple_romsets "
+	    }
+	}
+    } else {
+	sr_puts "0" yes
+	if { $merged != 1 } {
+	    append imperfections "no_zip_file "
+	}
+    }
+}
+
+proc sr_print_crcs_raw { crc current_count } {
+    upvar 1 $current_count counter
+    if { $counter == 8 } {
+	sr_puts "\n\t" no
+	set counter 0
+    }
+    incr counter
+    sr_puts "$crc " no
+}
+
+proc sr_print_crcs rom {
+    global crcs NODUMP
+
+    sr_puts "\nList of CRCs required for $rom:" yes
+    sr_puts "\t" no
+    set counter 0
+    foreach crc [split $crcs($rom)] {
+	if { [crc_nodump $crc] } {
+	    foreach nodump [split $NODUMP($rom)] {
+		sr_print_crcs_raw $crc counter
+	    }
+	} else {
+	    sr_print_crcs_raw $crc counter
+	}
+    }
+    if { $counter != 0 } {
+	sr_puts "" yes
+    }
+}
+
+proc sr_print_crc_loc_raw { rom crc data } {
+    global imperfections
+
+    sr_puts "\t$crc: $data" yes
+    if { [string match "Not Found*" $data] == 0 } {
+	if { [basename \"$data\" .zip] != $rom } {
+	    if { [string match *roms_found* $imperfections] == 0 } {
+		append imperfections "roms_found_elsewhere "
+	    }
+	}
+    }
+}
+
+proc sr_print_crc_loc_sub { rom crc newcrc } {
+    global zip_indx imperfections
+
+    if { [info exists zip_indx($rom,$newcrc)] } {
+	sr_print_crc_loc_raw $rom $crc $zip_indx($rom,$newcrc)
+    } elseif { [info exists zip_indx($newcrc)] } {
+	sr_print_crc_loc_raw $rom $crc $zip_indx($newcrc)
+    } else {
+	set newcrc [invert_crc $crc]
+	if { [info exists zip_indx($rom,$newcrc)] } {
+	    sr_print_crc_loc_raw $rom $crc $zip_indx($rom,$newcrc)
+	} elseif { [info exists zip_indx($newcrc)] } {
+	    sr_print_crc_loc_raw $rom $crc $zip_indx($newcrc)
+	} else {
+	    sr_print_crc_loc_raw $rom $crc "Not Found in any zip file!"
+	    if { [string match *missing_roms* $imperfections] == 0 } {
+		append imperfections "missing_roms "
+	    }
+	}
+    }
+}
+
+proc sr_print_crc_loc rom {
+    global crcs zip_crc_indx NODUMP imperfections master_of clones
+
+    sr_puts "\nLocation of each CRC found:" yes
+    foreach crc [split $crcs($rom)] {
+	if { [crc_nodump $crc] } {
+	    foreach name [split $NODUMP($rom)] {
+		if { [info exists zip_crc_indx($rom,$name)] } {
+		    sr_print_crc_loc_sub $rom $crc $zip_crc_indx($rom,$name)
+		} else {
+		    if { [info exists master_of($rom)] } {
+			set master $master_of($rom)
+		    } else {
+			set master $rom
+		    }
+		    if { [info exists zip_crc_indx($master,$name)] } {
+			sr_print_crc_loc_sub $rom $crc $zip_crc_indx($master,$name)
+		    } elseif { [info exists clones($master)] } {
+			set nodump_found 0
+			foreach clone [split $clones($master)] {
+			    if { [info exists zip_crc_indx($clone,$name)] } {
+				sr_print_crc_loc_sub $rom $crc $zip_crc_indx($clone,$name)
+				set nodump_found 1
+				break
+			    }
+			}
+			if { $nodump_found == 0 } {
+			    sr_print_crc_loc_raw $rom $crc "Not Found in any zip file!!"
+			    if { [string match *missing_roms* $imperfections] == 0 } {
+				append imperfections "missing_roms "
+			    }
+			}
+		    } else {
+			sr_print_crc_loc_raw $rom $crc "Not Found in any zip file!"
+			if { [string match *missing_roms* $imperfections] == 0 } {
+			    append imperfections "missing_roms "
+			}
+		    }
+		}
+	    }
+	} else {
+	    sr_print_crc_loc_sub $rom $crc $crc
+	}
+
+    }
+}
+
+proc sr_cn_print_header {} {
+    set nz "Name in Zipfile"
+    sr_puts "\nNames for each CRC:" yes
+    sr_puts "\t[format "%-8s %-12s %-15.15s %-10s" CRC Name $nz Status]" yes
+    sr_puts "\t-------- ------------ --------------- ----------" yes
+}
+
+proc sr_cn_print_crc crc {
+    sr_puts "\t[format "%-8s " $crc]" no
+}
+
+proc zip_base crc {
+    global zip_indx
+
+    if { [info exists zip_indx($crc)] } {
+	set zipbase [basename $zip_indx($crc) .zip]
+    } else {
+	set zipbase ""
+    }
+    return $zipbase
+}
+
+proc sr_cn_print_name_data data {
+    sr_puts [format "%-12s " $data] no
+}
+
+proc sr_cn_print_name_raw data {
+    global name_indx
+
+    if { [info exists name_indx($data)] } {
+	sr_cn_print_name_data $name_indx($data)
+	return 1
+    } else {
+	return 0
+    }
+}
+
+proc sr_cn_print_name { rom crc } {
+    global clones
+
+    if { [sr_cn_print_name_raw $rom,$crc] == 0 &&
+	 [sr_cn_print_name_raw [zip_base $crc],$crc] == 0 &&
+	 [sr_cn_print_name_raw $crc] == 0 } {
+	if { [info exists clones($rom)] } {
+	    foreach clone $clones($rom) {
+		if { [sr_cn_print_name_raw $clone,$crc] } {
+		    return;
+		}
+	    }
+	    sr_cn_print_name_data N/A
+	} else {
+	    sr_cn_print_name_data N/A
+	}
+    }
+}
+
+proc sr_cn_print_zipname_data data {
+    sr_puts [format "%-15.15s " $data] no
+}
+
+proc sr_cn_print_zipname_raw { rom crc } {
+    global zip_name_indx
+
+    if { [info exists zip_name_indx($rom,$crc)] } {
+	sr_cn_print_zipname_data $zip_name_indx($rom,$crc)
+    } elseif { [info exists zip_name_indx([zip_base $crc],$crc)] } {
+	sr_cn_print_zipname_data $zip_name_indx([zip_base $crc],$crc)
+	return 1
+    } else {
+	return 0
+    }
+}
+
+proc sr_cn_print_zipname_NODUMP { rom name } {
+    global zip_crc_indx master_of clones
+
+    if { [info exists zip_crc_indx($rom,$name)] } {
+	set NODUMPcrc $zip_crc_indx($rom,$name)
+	if { [sr_cn_print_zipname_raw $rom $NODUMPcrc] == 0 } {
+	    sr_cn_print_zipname_data N/A
+	}
+    } else {
+	if { [info exists master_of($rom)] } {
+	    set master $master_of($rom)
+	} else {
+	    set master $rom
+	}
+	if { [info exists zip_crc_indx($master,$name)] } {
+	    set NODUMPcrc $zip_crc_indx($master,$name)
+	    if { [sr_cn_print_zipname_raw $rom $NODUMPcrc] == 0 } {
+		sr_cn_print_zipname_data N/A
+	    }
+	} elseif { [info exists clones($master)] } {
+	    set nodump_found 0
+	    foreach clone [split $clones($master)] {
+		if { [info exists zip_crc_indx($clone,$name)] } {
+		    set NODUMPcrc $zip_crc_indx($clone,$name)
+		    if { [sr_cn_print_zipname_raw $rom $NODUMPcrc] == 0 } {
+			sr_cn_print_zipname_data N/A
+		    }
+		    set nodump_found 1
+		    break
+		}
+	    }
+	    if { $nodump_found == 0 } {
+		sr_cn_print_zipname_data N/A
+	    }
+	} else {
+	    sr_cn_print_zipname_data N/A
+	}
+    }
+}
+
+proc sr_cn_print_zipname { rom crc } {
+    if { [sr_cn_print_zipname_raw $rom $crc] == 0 } {
+	set newcrc [invert_crc $crc]
+	if { [sr_cn_print_zipname_raw $rom $newcrc] == 0 } {
+	    sr_cn_print_zipname_data N/A
+	}
+    }
+}
+
+proc sr_cn_print_status_data status {
+    global imperfections
+
+    if { $status == "good" } {
+	sr_puts [format "%-10s" CORRECT] yes
+    } else {
+	sr_puts [format "%-10s" INCORRECT] yes
+	if { [string match *names_* $imperfections] == 0 } {
+	    append imperfections "names_incorrect "
+	}
+    }
+}
+
+proc sr_cn_print_status_raw { rom crc name } {
+    global zip_indx zip_name_indx
+
+    if { [info exists zip_name_indx($rom,$crc)] } {
+	set zipname $zip_name_indx($rom,$crc)
+    } elseif { [info exists zip_name_indx([zip_base $crc],$crc)] } {
+	set zipname $zip_name_indx([zip_base $crc],$crc)
+    } else {
+	set crc [invert_crc $crc]
+	if { [info exists zip_name_indx($rom,$crc)] } {
+	    set zipname $zip_name_indx($rom,$crc)
+	} elseif { [info exists zip_name_indx([zip_base $crc],$crc)] } {
+	    set zipname $zip_name_indx([zip_base $crc],$crc)
+	} else {
+	    sr_cn_print_status_data bad
+	    return
+	}
+    }
+    if { [string compare $zipname $name] == 0 } {
+	sr_cn_print_status_data good
+    } else {
+	sr_cn_print_status_data bad
+    }
+}
+
+proc sr_cn_print_status_sub { rom crc newcrc } {
+    global name_indx clones
+
+    if { [info exists name_indx($rom,$crc)] } {
+	sr_cn_print_status_raw $rom $newcrc $name_indx($rom,$crc)
+    } elseif { [info exists name_indx([zip_base $crc],$crc)] } {
+	sr_cn_print_status_raw $rom $newcrc $name_indx([zip_base $crc],$crc)
+    } elseif { [info exists name_indx($crc)] } {
+	sr_cn_print_status_raw $rom $newcrc $name_indx($crc)
+    } elseif { [info exists clones($rom)] } {
+	foreach clone $clones($rom) {
+	    if { [info exists name_indx($clone,$crc)] } {
+		sr_cn_print_status_raw $clone $newcrc $name_indx($clone,$crc)
+		return 0
+	    }
+	}
+	return -1
+    }
+    return 0
+}
+
+proc sr_cn_print_status_NODUMP { rom name } {
+    global zip_name_indx zip_crc_indx master_of clones
+
+    if { [info exists zip_crc_indx($rom,$name)] } {
+	set crc $zip_crc_indx($rom,$name)
+	if { [info exists zip_name_indx($rom,$crc)] } {
+	    if { [string compare $name $zip_name_indx($rom,$crc)] == 0 } {
+		sr_cn_print_status_data good
+	    } else {
+		sr_cn_print_status_data bad
+	    }
+	} else {
+	    sr_cn_print_status_data bad
+	}
+    } else {
+	if { [info exists master_of($rom)] } {
+	    set master $master_of($rom)
+	} else {
+	    set master $rom
+	}
+	if { [info exists zip_crc_indx($master,$name)] } {
+	    set crc $zip_crc_indx($master,$name)
+	    if { [info exists zip_name_indx($master,$crc)] } {
+		if { [string compare $name $zip_name_indx($master,$crc)] == 0 } {
+		    sr_cn_print_status_data good
+		}
+		set nodump_found 1
+	    }
+	} else {
+	    sr_cn_print_status_data bad
+	}
+    }
+}
+
+proc sr_cn_print_status { rom crc } {
+    if { [sr_cn_print_status_sub $rom $crc $crc] == -1 } {
+	sr_cn_print_status_data bad
+    }
+}
+
+proc sr_check_names rom {
+    global crcs NODUMP
+
+    sr_cn_print_header
+    foreach crc [split $crcs($rom)] {
+	if { [crc_nodump $crc] } {
+	    foreach nodump [split $NODUMP($rom)] {
+		sr_cn_print_crc $crc
+		sr_cn_print_name_data $nodump
+		sr_cn_print_zipname_NODUMP $rom $nodump
+		sr_cn_print_status_NODUMP $rom $nodump
+	    }
+	} else {
+	    sr_cn_print_crc $crc
+	    sr_cn_print_name $rom $crc
+	    sr_cn_print_zipname $rom $crc
+	    sr_cn_print_status $rom $crc
+	}
+    }
+}
+
+proc sr_print_imperfections {} {
+    global imperfections
+
+    if { $imperfections == "" } {
+	set imperfections none
+    }
+    sr_puts "\nImperfections found:" yes
+    foreach imperfection [split $imperfections] {
+	sr_puts "\t$imperfection" yes
+    }
+}
+
+proc sr_print_extra_files_raw { rom crc } {
+    global crcs NODUMP zip_name_indx imperfections
+
+    set match_found 0
+    set eff 0
+    foreach goodcrc [split $crcs($rom)] {
+	if { [info exists NODUMP($rom)] } {
+	    if { [string match "*$zip_name_indx($rom,$crc)*" $NODUMP($rom)] ==
+		 1 } {
+		set match_found 1
+		break
+	    }
+	} 
+	if { [string compare $crc $goodcrc] == 0 } {
+	    set match_found 1
+	    break
+	} elseif { [string compare [invert_crc $crc] $goodcrc] == 0 } {
+	    set match_found 1
+	    break
+	}
+    }
+    if { $match_found == 0 && ![crc_nodump $crc] } {
+	set eff 1
+	sr_puts "\t$crc " no
+	if { [info exists zip_name_indx($rom,$crc)] } {
+	    sr_puts $zip_name_indx($rom,$crc) yes
+	    if { [string match *extra_* $imperfections] == 0 } {
+		append imperfections "extra_files_in_zip "
+	    }
+	} else {
+	    sr_puts "" yes
+	}
+    }
+    return $eff
+}
+
+proc sr_print_extra_files rom {
+    global zip_crcs crcs zip_paths zip_name_indx NODUMP imperfections
+
+    sr_puts "\nList of extra files in zip:" yes
+    set eff 0;   # eff=extra files found
+    if { [info exists zip_paths($rom)] } {
+	foreach path [split $zip_paths($rom)] {
+	    if { [info exists zip_crcs($rom,$path)] } {
+		foreach crc [split $zip_crcs($rom,$path)] {
+		    set rc [sr_print_extra_files_raw $rom $crc]
+		    if { $eff == 0 } {
+			set eff $rc
+		    }
+		}
+	    }
+	}
+    }
+    if { $eff == 0 } {
+	sr_puts "\tNone" yes
+    }
+}
+
+proc new_status_report rom {
+    global imperfections crcs check_names
+
+    set imperfections ""
+
+    sr_print_header $rom
+    sr_print_master_status $rom
+    sr_print_rom_occurrances $rom
+    if { $crcs($rom) != "" } {
+	sr_print_crcs $rom
+	sr_print_crc_loc $rom
+	if { $check_names } {
+	    sr_check_names $rom
+	}
+    }
+    sr_print_extra_files $rom
+    sr_print_imperfections
+    sr_print_footer
+}
+
+proc fr_imperfect_raw rom {
+    global imperfect
+
+    if { [string compare $imperfect($rom) none] } {
+	return 1
+    } else {
+	return 0
+    }
+}
+
+proc fr_imperfect rom {
+    global clones
+
+    if { [fr_imperfect_raw $rom] } {
+	return 1
+    } elseif { [has_clones $rom]] } {
+	foreach clone [split $clones($rom)] {
+	    if { [fr_imperfect_raw $clone] } {
+		return 1
+	    }
+	}
+    }
+    return 0
+}
+
+proc fr_prompt_yes {} {
+    global force
+
+    if { $force == "no" } {
+	puts ""
+	puts -nonewline [mamelang "Would you like me to fix your ROMs" \
+			     " \[Y/n\] ?"]
+	flush stdout
+	if { [gets stdin resp] == 0 } {
+		set resp y
+	}
+    } else {
+	return 1
+    }
+    if { $resp == "y" || $resp == "Y" || $resp == "yes" || $resp == "Yes" } {
+	return 1
+    } else {
+	return 0
+    }
+}
+
+proc fr_create_workdir rom {
+}
+
+proc new_fix_roms_raw rom {
+    # No complex AI used in these functions
+    fr_create_workdir $rom
+}
+
+proc new_fix_roms rom {
+    global clones
+
+    if { [fr_imperfect $rom] && [fr_prompt_yes] } {
+	new_fix_roms_raw $rom
+	if { [has_clones $rom] } {
+	    foreach clone [split $clones($rom)] {
+		new_fix_roms_raw $rom
+	    }
+	}
+    }
+}
+
+
+
+
+
+# old code below this point to fix roms
+
+
+
+set title 0
+# this procedure needs comments
+proc status_report rom {
+    global crcs2 zip_crcs2 zip_name_indx zip_indx name_indx title
+    global imperfections_exist clones
+    if { [lsort $crcs2($rom)] == [lsort $zip_crcs2($rom)] } {
+	aok $rom CRC
+    } else {
+	foreach crc [split $crcs2($rom)] {
+	    foreach zip_crc [split $zip_crcs2($rom)] {
+		set inverted_crc [format "%08x" [expr 0xffffffff - 0x$crc]]
+		if { $zip_crc == $crc } {
+		    remove_crc $rom $crc $crc
+		    break
+		}
+		if { $zip_crc == $inverted_crc } {
+		    remove_crc $rom $crc $zip_crc
+		    break
+		}
+	    }
+	}
+	if { ![llength $crcs2($rom)] && ![llength $zip_crcs2($rom)]} {
+	    aok $rom CRC
+	} else {
+	    if { [llength $crcs2($rom)] } {
+		set imperfections_exist 1
+		notok $rom CRC
+		set title 0
+		foreach crc [split $crcs2($rom)] {
+		    set inverted_crc [format "%08x" [expr 0xffffffff - 0x$crc]]
+		    if { [info exists zip_indx($crc)] } {
+			show_missing_files $rom $crc 0
+		    } elseif { [info exists zip_indx($inverted_crc)] } {
+			show_missing_files $rom $crc $inverted_crc
+		    } else {
+			if { [info exists name_indx($rom,$crc)] } {
+			    puts -nonewline "$name_indx($rom,$crc) "
+			} else {
+			    foreach clone [split $clones($rom)] {
+				if { [info exists name_indx($clone,$crc)] } {
+				    puts -nonewline "$name_indx($clone,$crc) "
+				    break;
+				}
+			    }
+			}
+			puts [mamelang "Not found in any other zips!" \
+				  " (CRC:$crc)"]
+		    }
+		}
+	    }
+	    if { [llength $zip_crcs2($rom)] } {
+		set imperfections_exist 1
+		notok $rom CRC
+		puts [mamelang "The following extranous files were found in" \
+			  " $rom:"]
+		foreach crc [split $zip_crcs2($rom)] {
+		    puts "$zip_name_indx($rom,$crc) (CRC = $crc)"
+		}
+	    }
+	}
+    }
+}
+
+proc unzipem { zip_filename file_to_unzip mame_name workdir } {
+    global noex verbose workd check_names unzip
+    set command "\"$unzip\" -j -o \"$zip_filename\" \"$file_to_unzip\" -d \"$workdir\""
+    if { $noex } {
+	puts $command 
+    } else {
+	myputs $command
+	evalcmd $command
+	if { $verbose == "no" } {
+	    puts -nonewline .
+	    flush stdout
+	}
+    }
+    if { $check_names } {
+	set indx [string last / $file_to_unzip]
+	incr indx
+	set trimmed_file [string range $file_to_unzip $indx end]
+	if { $mame_name != $trimmed_file } {
+	    set file1 [file join / $workdir $trimmed_file]
+	    set file2 [file join / $workdir $mame_name]
+	    set command "mv \"$file1\" \"$file2\""
+	    if { $noex } {
+		puts $command 
+	    } else {
+		myputs $command
+		evalcmd $command
+	    }
+	}
+    }
+}
+
+# this procedure attempts to fix your ROMs
+proc fix_roms rom {
+    global workd path crcs zip_name_indx zip_indx unzip zip noex
+    global c_level verbose name_indx clones merged zip_empty
+    # this directory should not exist, if it does it means an error occurred
+    # when trying to fix the roms the last time romalizer was run.  If it 
+    # does exist, just remove the contents of directory, other
+    set romdir [file join / $workd $rom]
+    if { [file exists $romdir] } {
+	set command "rm -rf \"$romdir\""
+	if { $noex } {
+	    puts $command
+	} else { 
+	    myputs $command
+	    evalcmd $command
+	}
+    }
+    # make a directory to place roms into
+    if { $noex } {
+	puts "mkdir $romdir"
+    } else {
+	myputs "mkdir $romdir"
+	file mkdir $romdir
+    }
+    # find the zip file 
+    foreach rompath [split $path :] {
+	set zipname [file join / $rompath $rom.zip]
+	if { [file exists $zipname] } {
+	    break
+	}
+	set zipname [file join / $rompath roms $rom.zip]
+	if { [file exists $zipname] } {
+	    break
+	}
+    }
+    # this foreach loop needs comments
+    foreach crc [split $crcs($rom)] {
+	if { [crc_nodump $crc] } {
+	    continue
+	}
+	set inverted_crc [format "%08x" [expr 0xffffffff - 0x$crc]]
+	if { [info exists zip_indx($rom,$crc)] } {
+	    set b $zip_name_indx($rom,$crc)
+	    if { [info exists name_indx($rom,$crc)] } {
+		set a $name_indx($rom,$crc)
+	    } else {
+		foreach clone [split $clones($rom)] {
+		    if { [info exists name_indx($clone,$crc)] } {
+			set a $name_indx($clone,$crc)
+			break
+		    }
+		}
+	    }
+	    unzipem $zip_indx($rom,$crc) $b $a $romdir
+	} elseif { [info exists zip_indx($rom,$inverted_crc)] } {
+	    set b $zip_name_indx($rom,$inverted_crc)
+	    if { [info exists name_indx($rom,$crc)] } {
+		set a $name_indx($rom,$crc)
+	    } else {
+		foreach clone [split $clones($rom)] {
+		    if { [info exists name_indx($clone,$crc)] } {
+			set a $name_indx($clone,$crc)
+			break
+		    }
+		}
+	    }
+	    unzipem $zip_indx($rom,$inverted_crc) $b $a $romdir
+	} elseif { [info exists zip_indx($crc)] } {
+            set a [basename $zip_indx($crc) .zip]
+	    if { [info exists zip_name_indx($a,$crc)] } {
+		set b $zip_name_indx($a,$crc)
+		set indx [string last / $b]
+		incr indx
+		set trimmed_file [string range $b $indx end]
+		unzipem $zip_indx($crc) $b $trimmed_file $romdir
+	    }
+	} elseif { [info exists zip_indx($inverted_crc)] } {
+	    set a [basename $zip_indx($inverted_crc) .zip]
+	    if { [info exists zip_name_indx($a,$inverted_crc)] } {
+		set b $zip_name_indx($a,$inverted_crc)
+		set indx [string last / $b]
+		incr indx
+		set trimmed_file [string range $b $indx end]
+		unzipem $zip_indx($inverted_crc) $b $trimmed_file $romdir
+	    }
+	}
+    }
+    set zipname [file join / $workd $rom.zip]
+    set zipdir  [file join / $workd $rom]
+    # this rom needs no files, so create a dummy file to build a zip with
+    if { [catch { glob $zipdir/* }] } {
+	set dummyfile [file join / $zipdir dummy]
+	set command "touch \"$dummyfile\""
+	if { $noex == "no" } {
+	    myputs $command
+	    evalcmd $command
+	}
+    }
+    # build the zip
+    set command "\"$zip\" -mrjD -$c_level \"$zipname\" \"$zipdir\""
+    if { $noex } {
+	puts $command
+    } else {
+	myputs $command
+	evalcmd $command
+    }
+    # cleanup
+    if { $noex } {
+	puts "rmdir $zipdir"
+    } else {
+	myputs "rmdir $zipdir"
+	file delete $zipdir
+    }
+}
+
+# this makes a backup copy of your original roms and installs the new
+# roms that romalizer built
+proc move_zipfiles rom {
+    global workd path noex
+    foreach rompath [split $path :] {
+	set zipname [file join / $rompath $rom.zip]
+	if { [file exists $zipname] } {
+	    break
+	}
+	set zipname [file join / $rompath roms $rom.zip]
+	if { [file exists $zipname] } { 
+	    set rompath [file join / $rompath roms]
+	    break
+	}
+    }
+    set oldromsdir [file join / $workd oldroms]
+    if { ![file isdirectory $oldromsdir] } {
+	file delete $oldromsdir
+    }
+    if { ![file exists $oldromsdir] } {
+	if { $noex } {
+	    puts "mkdir $oldromsdir"
+	} else {
+	    myputs "mkdir $oldromsdir"
+	    file mkdir $oldromsdir
+	}
+    }
+    set command "mv \"$zipname\" \"$oldromsdir\""
+    if { $noex } {
+	puts $command
+    } else {
+	myputs $command
+	catch { eval exec $command }
+    }
+    set zipname [file join / $workd $rom.zip]
+    set command "mv \"$zipname\" \"$rompath\""
+    if { $noex } {
+	puts $command
+    } else {
+	myputs $command
+	evalcmd $command
+    }
+}
+
+# make a copy of the crcs array to use with generating a status report
+# the original copy we use for fixing the roms
+array set crcs2 [array get crcs]
+array set zip_crcs2 [array get zip_crcs]
+
+# generate a status report for each rom and fix them if something is wrong
+set title 0
+foreach rom [split $roms] {
+    set imperfections_exist 0
+    if { [info exists crcs2($rom)] } {
+	new_status_report $rom
+	set imperfect($rom) $imperfections
+    }
+    if { [info exists clones($rom)] } {
+	foreach clone [split $clones($rom)] {
+	    if { [info exists crcs2($clone)] } {
+		new_status_report $clone
+		set imperfect($clone) $imperfections
+	    }
+	}
+    }
+    if { $verbose_status == "yes" || $title == 0 } {
+	puts \n
+	puts "                         SUMMARY OF IMPERFECTIONS FOUND"
+	puts ""
+	puts [format "%-8s  %s" "Rom Name" "Imperfections Found"]
+	puts [format "%-8s  %s" "--------" "-------------------"]
+	if { $verbose_status == "no" } {
+	    set title 1
+	}
+    }
+    puts [format "%-8s  %s" $rom $imperfect($rom)]
+    if { [info exists clones($rom)] } {
+	foreach clone [split $clones($rom)] {
+	    puts [format "%-8s  %s" $clone $imperfect($clone)]
+	}
+    }
+    sr_puts "" yes
+#    new_fix_roms $rom
+    if { $force == "no" } {
+	if { $verbose_status } {
+            set keypress ""
+            while { [string compare $keypress "\\"] != 0 } {
+		sr_puts "Press \\ and Enter to continue on to the next romset:" no
+		gets stdin keypress
+	    }
+	}
+    }
+
+
+
+
+
+
+# imprefections_exist is from the old status report subroutine, you can
+# compare $imperfect($rom) with "none" and if there is a difference,
+# you can set $imperfections_exist to 1 and the old fix roms routine will
+# kick in place (as in code below):
+    
+    if { [string compare $imperfect($rom) "none"] != 0 } {
+	set imperfections_exist 1
+    } elseif { [info exists clones($rom)] } {
+	foreach clone [split $clones($rom)] {
+	    if { [string compare $imperfect($clone) "none"] != 0 } {
+		set imperfections_exist 1
+	    }
+	}
+    }
+
+
+
+
+
+
+# This is continuation of old code...
+
+
+
+    if { $imperfections_exist == 0 && $check_names } {
+	if { [info exists crcs2($rom)] } {
+	    check_names $rom
+	}
+	if { [info exists clones($rom)] } {
+	    foreach clone [split $clones($rom)] {
+		if { [info exists crcs2($clone)] } { 
+		    check_names $clone 
+		}
+	    }
+	}
+    }
+    if { $imperfections_exist } {
+	if { $force == "no" } {
+	    puts -nonewline [mamelang "Would you like me to fix your ROMs" \
+				 " \[Y/n\] ?"]
+	    flush stdout
+	    if { [gets stdin resp] == 0 } {
+		set resp y
+	    }
+	} else {
+	    set resp y
+	}
+	if { $resp == "y" || $resp == "Y" } {
+	    puts -nonewline [mamelang "fixing" "..."] ; flush stdout
+	    fix_roms $rom
+	    if { [info exists clones($rom)] } {
+		foreach clone [split $clones($rom)] { fix_roms $clone }
+	    }
+	    # make a backup copy of your old roms and install the new roms
+	    if { $move_zips } {
+		move_zipfiles $rom
+		if { [info exists clones($rom)] } {
+		    foreach clone [split $clones($rom)] {
+			move_zipfiles $clone
+		    }
+		}
+		set oldromsdir [file join / $workd oldroms]
+		puts [mamelang "\n" "Your old ROMs have been moved to" \
+			  " $oldromsdir"]
+	    } else {
+		puts [mamelang "\n" "The fixed ROMs have been placed in" \
+			  " $workd"]
+	    }
+	}
+    }
+}
+
+puts ""
+
+# cleanup before exiting
+if { $logfile != "" } {
+    close $logfiled
+}
diff --git a/src/unix/contrib/tools/romalizer/romalizer.eng b/src/unix/contrib/tools/romalizer/romalizer.eng
new file mode 100644
index 0000000..61f51f8
--- /dev/null
+++ b/src/unix/contrib/tools/romalizer/romalizer.eng
@@ -0,0 +1,163 @@
+##########################################################################
+#
+#  romalizer translation file from ENGLISH --- to ---> SPANISH by:
+#
+#     Vicente Aguilar <vaguilar@linuxfreak.com>
+#     http://emuhq.com/mamelang, http://pagina.de/bisente
+#
+#  The Romalizer, by Christopher Stone (tkmame@ztnet.com)
+#  http://tkmame.retrogames.com
+#
+##########################################################################
+"The Romalizer 0.62 (May 27, 2000)\nChristopher Stone (tkmame@ztnet.com)\nhttp://tkmame.retrogames.com\n"
+"  NAME"
+"         romalizer - analyze and fix ROMs used for xmame"
+"  SYNOPSIS"
+"         romalizer [-f] [-g] [-h] [-m] [-n] [-v] [-G] [-V] [-c level]"
+"         [-d workdir] [-l logfile] [-r rompath] [-x xmame] [-C cutoff]"
+"         rom ..."
+"  DESCRIPTION"
+"         romalizer will examine the  rom(s) specified on the command line"
+"         as well as all the  clones for each rom.  If rom is a clone then"
+"         the   associated parent   rom is used   instead, any   resulting"
+"         duplicate roms  will be ignored, thus using  wildcards such as *"
+"         will not result in reexamining the same rom twice.  The rom that"
+"         is specified  may be the short name  recognized by xmame, or the"
+"         full path name to the zip file."
+"         During the examination process, romlizer compares the CRCs found"
+"         in xmame with  those in your zip files.  If any extra  files are"
+"         stored  in your zip files,  romalizer detects them  and issues a"
+"         report.  romalizer is  also capable  of  building  new zip files"
+"         from your existing zip files if any discrepancies are found."
+
+"         ROM sets are  typically divided into a parent  ROM and its clone"
+"         ROM(s).  The default  method of  storing a ROM  set is to  place"
+"         all duplicate  ROMs from the  parent and  clone ROMs into  a zip"
+"         file with the name  of the parent ROM and  place those ROMs that"
+"         are unique to a clone in a zip file with the name of that clone."
+"         However,  romalizer also  supports ROM sets  which have  all the"
+"         parent ROMs and clone ROMs stored  in a single zip file with the"
+"         name of the parent ROM.  In addition, romalizer  is also capable"
+"         of building  ROM sets such  that each zip  file be it  parent or"
+"         clone is  capable of running  on its own.  For more  information"
+"         on using  romalizer with  different ROM  set storing  techniques"
+"         read about the -G, -g, and -z options."
+"  OPTIONS"
+"         -c  level"
+"                This specifies the compression level  you want to use for"
+"                your  zip files.  0 indicates  no compression,  1 is  the"
+"                fastest compression,  and 9 is the  slowest.  The default"
+"                is 6."
+"         -d  workdir"
+"                This  specifies  the  directory  where  romalizer  places"
+"                temporary  working files, and backs up your old ROMs when"
+"                building new  ones if the -M option is used.  The default,"
+"                if not specified, is set to /tmp/romalizer."
+"         -l  logfile"
+"                This will send  output which is sent to  the console when"
+"                the -v option is used to a file specified by logfile.  If"
+"                both the -l and -v options are used, then  output will be"
+"                sent to both the console and the logfile specified."
+"         -r  rompath"
+"                Specifies  the rompath  to use when looking  for your zip"
+"                files.  If  not  specified,  romalizer  uses the rom path"
+"                specified in your ~/.xmamerc file."
+"         -x  xmame"
+"                Specifies the location of the xmame executable to use for"
+"                checking  CRC values.  The default,  if not specified, is"
+"                xmame.x11."
+"         -C  cutoff"
+"                Specifies the  cutoff value for the  number of roms which"
+"                have to be specified on the command line before romalizer"
+"                checks all CRCs at once instead of one rom at a time. The"
+"                default is 150."
+"         -f     Force  creation  of  new  roms.  With  this  option  set,"
+"                romalizer  will  automatically  create  new  ROMs without"
+"                prompting you.  This  option is  useful  if you  want  to"
+"                automatically fix a  large number of ROMs, and you do not"
+"                want to answer a lot of prompts. This option is also used"
+"                frequently with the -n option."
+"         -g     Tells romalizer you want  to merge your clone ROMs into a"
+"                single file  with  the name  of the clone's  parent  ROM, "
+"                rather than one file for each clone."
+"         -h     Prints out this descriptive help file."
+"         -m     Check file names as well as CRC values in your zip files."
+"         -n     Do not  execute commands,  but  instead just  print  what"
+"                commands romalizer would execute if the -n option was not"
+"                used."
+"         -v     Verbose mode.  This  option  will  print  all  the  shell"
+"                commands it is trying to execute to stdout."
+"         -z     When used with the -g option,  romalizer will build empty"
+"                zip files  for the clone roms.  This is useful for front-"
+"                ends to easily  identify which clone ROMs you have.  This"
+"                option has no effect if the -g option is not used."
+"         -G     Tells romalizer  that you want to have a  complete set of"
+"                roms in each zip file so that a clone may run independent"
+"                of the parent zip file."
+"         -M     Move fixed  roms into  rom path and  backup the  old roms"
+"                into the working directory."
+"         -V     Prints version number and exits."
+"  EXAMPLES"
+"         To verify all your roms that start with the letter `a' use:"
+"                romalizer /usr/local/share/xmame/roms/a*"
+"         To see what romalizer would do without doing anything use:"
+"                romalizer -v -n pacman"
+"         To automatically fix any roms that romalizer sees problems with:"
+"                romalizer -f pacman galaga joust"
+"         Here is an example I use when a new version of xmame comes out:"
+"                romalizer -f -v -n -x ~/xmame.x11 -r ~/old:~/new ~/new/roms/*"
+"         My  ~/old/roms  directory contains my old xmame ROMs, and the"
+"         ~/new/roms directory contains the new ROMs"
+"         In  your directory  of fixed ROMs,  you can use  this command to"
+"         verify that romalizer has worked properly:"
+"                for i in *;do xmame -verifyroms `basename $i .zip`>>outf;done"
+"         Then, you can examine the file 'outf' for any errors. "
+"  ENVIRONMENT"
+"         MAMELANG"
+"                Specify the translation file to use if you are running"
+"                this script with a modified version of Tcl that supports"
+"                MAMELANG.  (See: http://www.emuhq.com/mamelang/)"
+"         ROMPATH"
+"                Overrides the  rompath specified  in the ~/.xmamerc file."
+"                If a rompath is  specified on the command line, then that"
+"                is used instead of the environment setting."
+"         PATH"
+"                Used to locate zip, unzip, and xmame commands."
+"  SEE ALSO"
+"  AUTHOR"
+"         romalizer  is written by  Christopher Stone  <tkmame@ztnet.com>."
+"         If you have any ideas or  suggestions on improving this software"
+"         please let me know."
+"  BUGS"
+"         NeoGeo BIOS ROMs are assumed to be in neogeo.zip and will not be"
+"         included in NeoGeo zip files when using the -G option."
+"Missing ROM!"
+"Try"
+"for more options."
+"Invalid compression level specified"
+"Unable to locate zip and/or unzip commands."
+"Unable to execute command"
+"Please send a bug report to"
+"Please upgrade to UnZip version 5.41 or greater"
+"Obtaining clone information"
+"Done"
+"Obtaining list of ROMs"
+"No valid ROMs specified."
+"Obtaining ROM path"
+"Obtaining game descriptions"
+"Obtaining CRC information"
+"Unable to find"
+"skipping."
+"Obtaining zipfile information"
+"GOOD"
+"BAD"
+"zip name"
+"does not match"
+"The following files are missing in"
+"Found in"
+"Not found in any other zips!"
+"The following extranous files were found in"
+"Would you like me to fix your ROMs"
+"fixing"
+"Your old ROMs have been moved to"
+"The fixed ROMs have been placed in"
diff --git a/src/unix/contrib/tools/romalizer/romalizer.es b/src/unix/contrib/tools/romalizer/romalizer.es
new file mode 100644
index 0000000..6c983b6
--- /dev/null
+++ b/src/unix/contrib/tools/romalizer/romalizer.es
@@ -0,0 +1,317 @@
+##########################################################################
+#
+#  romalizer translation file from ENGLISH --- to ---> SPANISH by:
+#  traduccin del romalizer de INGLS --- a ---> ESPAOL por:
+#
+#     Vicente Aguilar <vaguilar@linuxfreak.com>
+#     http://emuhq.com/mamelang, http://pagina.de/bisente
+#
+#  The Romalizer, by Christopher Stone (tkmame@ztnet.com)
+#  http://tkmame.retrogames.com
+#
+##########################################################################
+"The Romalizer 0.62 (May 27, 2000)\nChristopher Stone (tkmame@ztnet.com)\nhttp://tkmame.retrogames.com\n"
+"The Romalizer 0.62 (May 27, 2000)\nChristopher Stone (tkmame@ztnet.com)\nhttp://tkmame.retrogames.com\n"
+"  NAME"
+"  NOMBRE"
+"         romalizer - analyze and fix ROMs used for xmame"
+"         romalizer - analiza y corrige las ROMs del xmame"
+"  SYNOPSIS"
+"  SINOPSIS"
+"         romalizer [-f] [-g] [-h] [-m] [-n] [-v] [-G] [-V] [-c level]"
+"         romalizer [-f] [-g] [-h] [-m] [-n] [-v] [-G] [-V] [-c nivel]"
+"         [-d workdir] [-l logfile] [-r rompath] [-x xmame] [-C cutoff]"
+"         [-d dir_trabajo] [-l bitcora] [-r dir_roms] [-x xmame] [-C mnimo]"
+"         ROM ..."
+"         ROM ..."
+"  DESCRIPTION"
+"  DESCRIPCIN"
+"         romalizer will examine the  ROM(s) specified on the command line"
+"         romalizer examinar la(s)  ROM(s) especificadas en lnea de comandos"
+"         as well as all the  clones for each ROM.  If ROM is a clone then"
+"         as como todos los clones de cada una de ellas. Si la ROM es un clon"
+"         the   associated parent   ROM is used   instead, any   resulting"
+"         se  utilizar  en  su lugar  la  ROM  original  asociada,  ignorando"
+"         duplicate ROMs  will be ignored, thus using  wildcards such as *"
+"         cualquier duplicado resultante de forma que al usar comodines como *"
+"         will not result in reexamining the same ROM twice.  The ROM that"
+"         no se reexamine  la misma ROM dos veces.  El nombre de la ROM que se"
+"         is specified  may be the short name  recognized by xmame, or the"
+"         especifica puede  ser el nombre corto reconocide por el xmame,  o el"
+"         full path name to the zip file."
+"         camino completo hasta el archivo zip."
+"         During the examination process, romlizer compares the CRCs found"
+"         Durante  el proceso  de  anlisis,  romalizer compara  los  CRCs que"
+"         in xmame with  those in your zip files.  If any extra  files are"
+"         necesita el xmame con  los de sus archivos zip.  Si hubiera ficheros"
+"         stored  in your zip files,  romalizer detects them  and issues a"
+"         de ms en  los archivos zip,  romalizer los detectar y generar  un"
+"         report.  romalizer is  also capable  of  building  new zip files"
+"         informe.  Romalizer tambin  es capaz de crear  nuevos archivos  zip"
+"         from your existing zip files if any discrepancies are found."
+"         a partir de los que ya tiene si encuentra alguna discrepancia."
+
+"         ROM sets are  typically divided into a parent  ROM and its clone"
+"         Los conjuntos  de ROMs se dividen  generalmente en una  ROM original"
+"         ROM(s).  The default  method of  storing a ROM  set is to  place"
+"         y sus ROM(s) clnicas.  La forma por defecto  de almacenar las  ROMs"
+"         all duplicate  ROMs from the  parent and  clone ROMs into  a zip"
+"         consiste en  colocar todas las  ROMs duplicadas en la original y sus"
+"         file with the name  of the parent ROM and  place those ROMs that"
+"         clones en un fichero zip  con el nombre de la ROM original,  y dejar"
+"         are unique to a clone in a zip file with the name of that clone."
+"         las ROMs propias  de cada clon  en un zip  con el  nombre del  clon."
+"         However,  romalizer also  supports ROM sets  which have  all the"
+"         Sin embargo,  romalizer tambin soporta conjuntos de ROMs que tengan"
+"         parent ROMs and clone ROMs stored  in a single zip file with the"
+"         almacenadas todas las  ROMs de la original  y los clones en  un solo"
+"         name of the parent ROM.  In addition, romalizer  is also capable"
+"         fichero zip con  el nombre de la ROM original.  Adems, romalizer es"
+"         of building  ROM sets such  that each zip  file be it  parent or"
+"         capaz de construir conjuntos de  ROMs que sean capaces de ejecutarse"
+"         clone is  capable of running  on its own.  For more  information"
+"         por  si  mismos,  ya  sea una  ROM original  o  un  clon.  Para  ms"
+"         on using  romalizer with  different ROM  set storing  techniques"
+"         informacin sobre  cmo utilizar  romalizer con  cada una  de  estas"
+"         read about the -G, -g, and -z options."
+"         tcnicas de almacenamiento, vea las opciones -G, -g y -z."
+"  OPTIONS"
+"  OCIONES"
+"         -c  level"
+"         -c  nivel"
+"                This specifies the compression level  you want to use for"
+"                Especifica el nivel  de compresin  que quiere utilizar  para"
+"                your  zip files.  0 indicates  no compression,  1 is  the"
+"                los archivos zip.  0 indica sin compresin,  1 es el nivel de"
+"                fastest compression,  and 9 is the  slowest.  The default"
+"                compresin  ms rpido,  y 9 es el  ms lento.  El nivel  por"
+"                is 6."
+"                defecto es el 6."
+"         -d  workdir"
+"         -d  dir_trabajo"
+"                This  specifies  the  directory  where  romalizer  places"
+"                Especifica  el   directorio  que  romalizer   utilizar  para"
+"                temporary  working files, and backs up your old ROMs when"
+"                trabajar con  ficheros  temporales,  y para salvaguardar  sus"
+"                building new  ones if the -M option is used.  The default,"
+"                ROMs viejas cuando  est construyendo  nuevos archivos si  se"
+"                if not specified, is set to /tmp/romalizer."
+"                us la opcin -M. Por defecto, usar /tmp/romalizer."
+"         -l  logfile"
+"         -l  bitcora"
+"                This will send  output which is sent to  the console when"
+"                Enviar toda la salida que normalmente va a la consola cuando"
+"                the -v option is used to a file specified by logfile.  If"
+"                se indica la opcin  -v al fichero  especificado.  Si se usan"
+"                both the -l and -v options are used, then  output will be"
+"                tanto la opcin  -l como -v,  entonces la salida  se  enviar"
+"                sent to both the console and the logfile specified."
+"                a la consola y al fichero de bitcora especificado."
+"         -r  rompath"
+"         -r  dir_roms"
+"                Specifies  the rompath  to use when looking  for your zip"
+"                Especifica  el camino  o caminos en  los que buscar  archivos"
+"                files.  If  not  specified,  romalizer  uses the  rompath"
+"                zip con  las ROMs.  Si no se especifica,  romalizer utilizar"
+"                specified in your ~/.xmamerc file."
+"                el que est configurado en su fichero ~/.xmamerc."
+"         -x  xmame"
+"         -x  xmame"
+"                Specifies the location of the xmame executable to use for"
+"                Especifica el  camino  hasta el  ejecutable del xmame  que se"
+"                checking  CRC values.  The default,  if not specified, is"
+"                usar para comprobar los CRCs.  Por defecto, si no se indica,"
+"                xmame.x11."
+"                es xmame.x11."
+"         -C  cutoff"
+"         -C  mnimo"
+"                Specifies the  cutoff value for the  number of ROMs which"
+"                Especifica  el mnimo  nmero de ROMs  indicadas en  lnea de"
+"                have to be specified on the command line before romalizer"
+"                comandos a  partir  del  cul romalizer  comprobar sus  CRCs"
+"                checks all CRCs at once instead of one ROM at a time. The"
+"                todos  a la vez en lugar de  comprobarlos de uno en uno.  Por"
+"                default is 150."
+"                defecto se necesitan 150 ROMs."
+"         -f     Force  creation  of  new  ROMs.  With  this  option  set,"
+"         -f     Fuerza  la creacin de  nuevos archivos  de ROMs.  Al activar"
+"                romalizer  will  automatically  create  new  ROMs without"
+"                esta   opcin,  romalizer   automticamente   crear   nuevos"
+"                prompting you.  This  option is  useful  if you  want  to"
+"                archivos  sin  preguntarle.  Esta opcin  es til  si  quiere"
+"                automatically fix a  large number of ROMs, and you do not"
+"                reparar  automticamente  un  nmero  elevado de  ROMs,  y no"
+"                want to answer a lot of prompts. This option is also used"
+"                quiere responder a todas las confirmaciones de creacin. Esta"
+"                frequently with the -n option."
+"                opcin se usa frecuentemente acompaada de -n."
+"         -g     Tells romalizer you want  to merge your clone ROMs into a"
+"         -g     Configura romalizer para unir  todos los clones  de una misma"
+"                single file  with  the name  of the clone's  parent  ROM, "
+"                ROM  en un  nico archivo  con el nombre  de la ROM original,"
+"                rather than one file for each clone."
+"                en lugar de tener un archivo para cada clon."
+"         -h     Prints out this descriptive help file."
+"         -h     Muestra esta ayuda."
+"         -m     Check file names as well as CRC values in your zip files."
+"         -m     Comprobar los nombres de los ficheros en los archivos zip."
+"         -n     Do not  execute commands,  but  instead just  print  what"
+"         -n     No  ejecutar  ningn  comando,  si no  mostrar  qu  comandos"
+"                commands romalizer would execute if the -n option was not"
+"                ejecutara  romalizer si  no se  hubiera  indicado  la opcin"
+"                used."
+"                -n."
+"         -v     Verbose mode.  This  option  will  print  all  the  shell"
+"         -v     Modo  detallado.  Con  esta opcin,  romalizer ir  mostrando"
+"                commands it is trying to execute to stdout."
+"                por stdout todos los comandos que trata de ejecutar."
+"         -z     When used with the -g option,  romalizer will build empty"
+"         -z     Cuando se usa junto con la opcin -g, romalizer generar zips"
+"                zip files  for the clone roms.  This is useful for front-"
+"                vacos para  las  ROMs clnicas.  Esto  es til para  que los"
+"                ends to easily  identify which clone ROMs you have.  This"
+"                interfaces  grficos puedan  identificar fcilmente  qu ROMs"
+"                option has no effect if the -g option is not used."
+"                tiene. Esta opcin no tiene efecto si no se usa -g."
+"         -G     Tells romalizer  that you want to have a  complete set of"
+"         -G     Indica a romalizer  que usted quiere tener un  juego completo"
+"                ROMs in each zip file so that a clone may run independent"
+"                de  ROMs  en  cada  zip,  de forma  que cada  clon pueda  ser"
+"                of the parent zip file."
+"                ejecutado independientemente sin su ROM original."
+"         -M     Move fixed  ROMs into  ROM path and  backup the  old ROMs"
+"         -M     Mover las ROMs reparadas al directorio de ROMs y salvaguardar"
+"                into the working directory."
+"                las viejas en el directorio de trabajo."
+"         -V     Prints version number and exits."
+"         -V     Mostrar el nmero de versin y salir."
+"  EXAMPLES"
+"  EJEMPLOS"
+"         To verify all your ROMs that start with the letter `a' use:"
+"         Para verificar todas las ROMs que comiencen con la letra 'a', use:"
+"                romalizer /usr/local/share/xmame/roms/a*"
+"                romalizer /usr/local/share/xmame/roms/a*"
+"         To see what romalizer would do without doing anything use:"
+"         Para ver qu hara romalizer sin hacer realmente nada, use:"
+"                romalizer -v -n pacman"
+"                romalizer -v -n pacman"
+"         To automatically fix any ROMs that romalizer sees problems with:"
+"         Para reparar automticamente cualquier ROM con problemas:"
+"                romalizer -f pacman galaga joust"
+"                romalizer -f pacman galaga joust"
+"         Here is an example I use when a new version of xmame comes out:"
+"         He aqu un ejemplo que yo uso con cada versin nueva de xmame:"
+"                romalizer -f -v -n -x ~/xmame.x11 -r ~/old:~/new ~/new/roms/*"
+"                romalizer -f -v -n -x ~/xmame.x11 -r ~/old:~/new ~/new/roms/*"
+"         My  ~/old/roms  directory contains my old xmame ROMs, and the"
+"         Mi directorio ~/old/roms contiene las ROMs viejas del xmame, y el"
+"         ~/new/roms directory contains the new ROMs"
+"         directorio ~/new/roms las nuevas."
+"         In  your directory  of fixed ROMs,  you can use  this command to"
+"         En el directorio de ROMs reparadas, puede usar este comando para"
+"         verify that romalizer has worked properly:"
+"         verificar que romalizer funcion correctamente:"
+"                for i in *;do xmame -verifyroms `basename $i .zip`>>outf;done"
+"                for i in *;do xmame -verifyroms `basename $i .zip`>>outf;done"
+"         Then, you can examine the file 'outf' for any errors. "
+"         Y puede examinar el fichero 'outf' para buscar cualquier error"
+"  ENVIRONMENT"
+"  ENTORNO"
+"         MAMELANG"
+"         MAMELANG"
+"                Specify the translation file to use if you are running"
+"                Indica el  fichero de  traduccin a  utilizar si  ejecuta  el"
+"                this script with a modified version of Tcl that supports"
+"                programa  con  una  versin  modificada  de  Tcl que  soporte"
+"                MAMELANG.  (See: http://www.emuhq.com/mamelang/)"
+"                MAMELANG.  (Vea: http://www.emuhq.com/mamelang/)"
+"         ROMPATH"
+"         ROMPATH"
+"                Overrides the  rompath specified  in the ~/.xmamerc file."
+"                Sobreescribe  el camino  de ROMs  especificado  en el fichero"
+"                If a rompath is  specified on the command line, then that"
+"                ~/.xmamerc.  Si se  indica otro camino en lnea  de comandos,"
+"                is used instead of the environment setting."
+"                entonces se usar ese en lugar del de la variable de entorno."
+"         PATH"
+"         PATH"
+"                Used to locate zip, unzip, and xmame commands."
+"                Se utiliza para localizar los comandos zip, unzip y xmame."
+"  SEE ALSO"
+"  VASE TAMBIN"
+"  AUTHOR"
+"  AUTOR"
+"         romalizer  is written by  Christopher Stone  <tkmame@ztnet.com>."
+"         romalizer ha sido escrito por Christopher Stone <tkmame@ztnet.com>."
+"         If you have any ideas or  suggestions on improving this software"
+"         Si tiene alguna  idea o sugerencia para  mejorar este programa, por"
+"         please let me know."
+"         favor hgamelo saber."
+"  BUGS"
+"  PROBLEMAS"
+"         NeoGeo BIOS ROMs are assumed to be in neogeo.zip and will not be"
+"         Las ROMs de la  BIOS de NeoGeo se  asume que estn  en neogeo.zip y"
+"         included in NeoGeo zip files when using the -G option."
+"         no se inluirn en los archivos de ROMs NeoGeo al usar la opcin -G."
+"version"
+"versin"
+"Missing ROM!"
+"ROM no encontrada!"
+"Try"
+"Pruebe"
+"for more options."
+"para ms opciones."
+"Invalid compression level specified"
+"Especificado nivel de compresin incorrecto"
+"Unable to locate zip and/or unzip commands."
+"No se pudo encontrar los comandos zip y/o unzip."
+"Unable to execute command"
+"No se pudo ejecutar el comando"
+"Please send a bug report to"
+"Por favor enve un informe sobre el error a"
+"Please upgrade to UnZip version 5.41 or greater"
+"Por favor actualice su sistema con UnZip versin 5.41 o superior"
+"Obtaining clone information"
+"Obteniendo informacin de clones\t"
+"Done"
+"Hecho"
+"Obtaining list of ROMs"
+"Obteniendo lista de ROMs\t"
+"No valid ROMs specified."
+"No se especificaron ROMs vlidas."
+"Obtaining ROM path"
+"Obteniendo camino de bsqueda de ROMs"
+"Obtaining game descriptions"
+"Obteniendo descripciones de los juegos\t"
+"Obtaining CRC information"
+"Obteniendo informacin de CRC\t\t"
+"Unable to find"
+"No se pudo encontrar"
+"skipping."
+"ignorndolo."
+"Obtaining zipfile information"
+"Obteniendo informacin del archivo zip"
+"GOOD"
+"BIEN"
+"BAD"
+"MAL"
+"zip name"
+"el nombre del zip"
+"does not match"
+"no coincide"
+"The following files are missing in"
+"Faltan los siguientes ficheros en"
+"Found in"
+"Encontrado(s) en"
+"Not found in any other zips!"
+"No encontrado(s) en ningn otro zip!"
+"The following extranous files were found in"
+"Se encontraron los siguientes ficheros innecesarios"
+"Would you like me to fix your ROMs"
+"Quiere que repare sus ROMs"
+"fixing"
+"reparando"
+"Your old ROMs have been moved to"
+"Sus ROMs viejas han sido movidas a"
+"The fixed ROMs have been placed in"
+"Las ROMs reparadas han sido colocadas en"
diff --git a/src/unix/contrib/tools/romulan.pl b/src/unix/contrib/tools/romulan.pl
new file mode 100644
index 0000000..abdffb9
--- /dev/null
+++ b/src/unix/contrib/tools/romulan.pl
@@ -0,0 +1,266 @@
+#!/usr/bin/perl
+#
+# romulan.pl - Nathan Hand (nathanh@manu.com.au)
+#
+# MAME rom analyser. Needs a merged set in /usr/local/share/xmame/roms
+# and the xmame + unzip binaries in your PATH. Romulan will detect &
+# report problems that commonly occur with merged sets, eg.
+#
+#   - missing sets
+#   - missing roms from a set
+#   - extra files in a set
+#   - roms with the wrong crc
+#   - roms with the wrong name
+#   - roms in the wrong set
+#
+# Revision History
+#   13 May 2000 - nathanh - initial release, detects bad crcs
+#   19 Apr 2001 - nathanh - detects misnamed roms
+#    9 Mar 2002 - nathanh - detects misplaced roms
+#   10 Mar 2002 - nathanh - added command line options
+#
+# ****
+# This script is free software; you can redistribute it and/or
+# modify it under the terms of the GNU Library General Public
+# License as published by the Free Software Foundation; either
+# version 2 of the License, or any later version.
+#
+# This script is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+# Library General Public License for more details.
+# ****
+# 
+
+require 5.000;
+use Data::Dumper;
+use Getopt::Long;
+
+# config options, nothing fancy
+
+$zipdir = "/usr/local/share/xmame/roms";
+$unzip_binary = "unzip";
+$xmame_binary = "xmame";
+$merged = 1;
+$strict = 0;
+$help = 0;
+
+# read user options
+
+$result = GetOptions('merged!' => \$merged, 'strict!' => \$strict, 'help' => \$help);
+
+if (!$result || $help) {
+    print stderr "usage: romulan.pl [options]\n\n";
+    print stderr "\t--merged     merged sets [default]\n";
+    print stderr "\t--nomerged   unmerged sets\n";
+    print stderr "\t--strict     strict merged sets\n";
+    print stderr "\t--nostrict   non-strict merged sets [default]\n";
+    print stderr "\t--help       this help screen\n\n";
+    print stderr "Merged means roms in a master set are not duplicated in\n";
+    print stderr "the clone set. For example, roms in pacman would not be\n";
+    print stderr "duplicated in pacmanbl.\n\n";
+    print stderr "Strict merged means that clones with common masters are\n";
+    print stderr "further consolidated: roms common to two or more clones\n";
+    print stderr "are moved from the clones to the master.\n\n";
+    print stderr "This script doesn't do anything itself. It just reports\n";
+    print stderr "on what needs to be done.\n";
+    exit(1);
+}
+
+if (!$merged && $strict) {
+    print stderr "error: you can't have strict sets that aren't merged!\n";
+    print stderr "(hint: try 'romulan.pl --merged --strict' instead)\n";
+    exit(1);
+}
+
+# useful things
+
+sub array_subtract {
+    my($ref1, $ref2, %mark) = @_;
+    grep $mark{$_}++, @{$ref2};
+    return grep !$mark{$_}, @{$ref1};
+}
+
+sub array_intersect {
+    my($ref1, $ref2, %mark) = @_;
+    grep $mark{$_}++, @{$ref2};
+    return grep $mark{$_}, @{$ref1};
+}
+
+# examine files, extract fileinfo
+
+opendir(DIR, $zipdir) || die "cannont opendir $zipdir: $!";
+@files = grep { -f "$zipdir/$_" } readdir(DIR);
+closedir(DIR);
+
+foreach $file (@files) {
+    foreach $line (`$unzip_binary -v -qq $zipdir/$file`) {
+        $line =~ tr/A-Z/a-z/;
+        @line = split /\s+/, $line;
+        ($dum, $len, $met, $siz, $rat, $dat, $tim, $crc, $nam) = @line;
+
+        $file =~ tr/A-Z/a-z/;
+        $file =~ s/\.zip$//;
+        $info = "name $nam size $len crc $crc";
+
+        push @{$zips{$file}}, $info;
+    }
+}
+
+# examine listinfo, extract listinfo
+
+foreach $line (`$xmame_binary -listinfo 2>/dev/null`) {
+    chop $line;
+
+    $name = $1             if ($line =~ /^\s+name\s(.*)$/);
+    $description{$name} = $1       if ($line =~ /^\s+description\s(.*)$/);
+    $year{$name} = $1          if ($line =~ /^\s+year\s(.*)$/);
+    $manufacturer{$name} = $1      if ($line =~ /^\s+manufacturer\s(.*)$/);
+    $history{$name} = $1       if ($line =~ /^\s+history\s(.*)$/);
+    $video{$name} = $1         if ($line =~ /^\s+video\s(.*)$/);
+    $sound{$name} = $1         if ($line =~ /^\s+sound\s(.*)$/);
+    $input{$name} = $1         if ($line =~ /^\s+input\s(.*)$/);
+    $driver{$name} = $1        if ($line =~ /^\s+driver\s(.*)$/);
+    $master{$name} = $1        if ($line =~ /^\s+cloneof\s(.*)$/);
+    $master{$name} = $1        if ($line =~ /^\s+romof\s(.*)$/);
+
+    if ($line =~ /^\s+rom\s\(\s(.*)\s\)$/) {
+        %info = split /\s+/, $1;
+        push @{$roms{$name}}, "name $info{name} size $info{size} crc $info{crc}";
+    }
+
+    if ($line =~ /^\s+chip\s\(\s(.*)\s\)$/) {
+        push @{$chips{$name}}, $1;
+    }
+
+    if ($line =~ /^\s+dipswitch\s\(\s(.*)\s\)$/) {
+        push @{$dipswitches{$name}}, $1;
+    }
+
+    if ($line eq "game (" || $line eq "resource (") {
+        undef $rom;
+    }
+}
+
+# strip master roms from clone sets
+
+if ($merged) {
+    foreach $clone (keys %master) {
+        @{$roms{$clone}} = &array_subtract($roms{$clone}, $roms{$master{$clone}});
+    }
+}
+
+# move shared roms from clones to master
+#
+#   step 1 - find cousins of clone, build list of common roms
+#   step 2 - strip common roms from cousins and clone
+#   step 3 - add common roms to master
+
+if ($strict) {
+    foreach $clone (keys %master) {
+        local(@common_roms);
+
+        foreach $cousin (keys %description) {
+            next if $clone eq $cousin;
+            next if $master{$clone} ne $master{$cousin};
+            push @common_roms, &array_intersect($roms{$cousin}, $roms{$clone});
+        }
+
+        foreach $cousin (keys %description) {
+            next if $master{$clone} ne $master{$cousin};
+            @{$roms{$cousin}} = &array_subtract($roms{$cousin}, \@common_roms);
+        }
+
+        local(%mark);
+        grep $mark{$_}++, @common_roms;
+        push @{$roms{$master{$clone}}}, keys %mark;
+    }
+}
+
+# find sets without a corresponding zip, and vice versa
+
+@zipkeys = keys %zips;
+@romkeys = keys %roms;
+
+foreach $zip (&array_subtract(\@romkeys, \@zipkeys)) {
+    print "file for $zip is missing!\n";
+}
+
+foreach $zip (&array_subtract(\@zipkeys, \@romkeys)) {
+    print "what is file $zip for?\n";
+}
+
+# find roms that are missing, extra, misnamed or wrongcrc
+
+foreach $set (keys %description) {
+    @{$missing_roms{$set}} = &array_subtract($roms{$set}, $zips{$set});
+    @{$extra_roms{$set}} = &array_subtract($zips{$set}, $roms{$set});
+
+    @{$misnamed_roms{$set}} = grep {
+        %info = split /\s+/, $rom=$_;
+        push @{$notmissing_roms{$set}}, grep {
+            ${$misnamed_be{$set}}{$rom} = $1 if /name (.*) size $info{size} crc $info{crc}/;
+        } @{$missing_roms{$set}};
+        ${$misnamed_be{$set}}{$rom};
+    } @{$extra_roms{$set}};
+
+    @{$wrongcrc_roms{$set}} = grep {
+        %info = split /\s+/, $rom=$_;
+        push @{$notmissing_roms{$set}}, grep {
+            ${$wrongcrc_be{$set}}{$rom} = $1 if /name $info{name} size $info{size} crc (.*)/;
+        } @{$missing_roms{$set}};
+        ${$wrongcrc_be{$set}}{$rom};
+    } @{$extra_roms{$set}};
+
+    foreach $rom (@{$extra_roms{$set}}) { $extra_roms_all{$rom} = $set; }
+    foreach $rom (@{$missing_roms{$set}}) { $missing_roms_all{$rom} = $set; }
+}
+
+# find roms that are in wrong sets
+
+foreach $set (keys %description) {
+    foreach $rom (@{$extra_roms{$set}}) {
+        if ($otherset = $missing_roms_all{$rom}) {
+            push @{$otherset_roms{$otherset}}, $rom;
+            ${$otherset_be{$otherset}}{$rom} = $set;
+        }
+    }
+
+    foreach $rom (@{$missing_roms{$set}}) {
+        if ($otherset = $extra_roms_all{$rom}) {
+            push @{$wrongset_roms{$otherset}}, $rom;
+            ${$wrongset_be{$otherset}}{$rom} = $set;
+        }
+    }
+}
+
+# consolidate the discoveries
+
+foreach $set (keys %description) {
+    @{$extra_roms{$set}} = &array_subtract($extra_roms{$set}, $misnamed_roms{$set});
+    @{$extra_roms{$set}} = &array_subtract($extra_roms{$set}, $wrongcrc_roms{$set});
+    @{$extra_roms{$set}} = &array_subtract($extra_roms{$set}, $wrongset_roms{$set});
+    @{$missing_roms{$set}} = &array_subtract($missing_roms{$set}, $otherset_roms{$set});
+    @{$missing_roms{$set}} = &array_subtract($missing_roms{$set}, $notmissing_roms{$set});
+}
+
+# report the discoveries
+
+foreach $set (keys %description) {
+    print "examining $set... ";
+    print "broken!\n" if @{$missing_roms{$set}} || @{$extra_roms{$set}} || @{$misnamed_roms{$set}} || @{$wrongcrc_roms{$set}} || @{$wrongset_roms{$set}} || @{$otherset_roms{$set}};
+    print "perfect!\n" unless @{$missing_roms{$set}} || @{$extra_roms{$set}} || @{$misnamed_roms{$set}} || @{$wrongcrc_roms{$set}} || @{$wrongset_roms{$set}} || @{$otherset_roms{$set}};
+
+    foreach $rom (@{$missing_roms{$set}})    { print "\tmissing:   $rom\n"; }
+    foreach $rom (@{$extra_roms{$set}})      { print "\textra:     $rom\n"; }
+    foreach $rom (@{$otherset_roms{$set}})   { print "\tmissing:   $rom (found in other set ${$otherset_be{$set}}{$rom})\n"; }
+    foreach $rom (@{$wrongset_roms{$set}})   { print "\textra:     $rom (should be in set ${$wrongset_be{$set}}{$rom})\n"; }
+    foreach $rom (@{$misnamed_roms{$set}})   { print "\tmisnamed:  $rom should be ${$misnamed_be{$set}}{$rom}\n"; }
+    foreach $rom (@{$wrongcrc_roms{$set}})   {
+        if (${$wrongcrc_be{$set}}{$rom} eq "00000000") {
+            print "\twrongcrc:  $rom BEST DUMP KNOWN\n";
+        } else {
+            print "\twrongcrc:  $rom should be ${$wrongcrc_be{$set}}{$rom}\n"
+        }
+    }
+}
diff --git a/src/unix/contrib/tools/xlistdev.c b/src/unix/contrib/tools/xlistdev.c
new file mode 100644
index 0000000..94905c6
--- /dev/null
+++ b/src/unix/contrib/tools/xlistdev.c
@@ -0,0 +1,106 @@
+/************************************************************************
+ *
+ * XList.c
+ * This program lists all available input devices.
+ *
+ */
+
+#include <X11/Xlib.h>
+#include <X11/Xutil.h>
+#include <X11/extensions/XInput.h>
+#include <stdio.h>
+
+int	Dflag = 1;
+
+main(argc,argv)
+    int argc;
+    char *argv[];
+{
+    int 		ndevices;
+    Display		*display;
+    XDeviceInfoPtr 	list_input_devices ();
+    XDeviceInfoPtr	list, slist;
+
+    display = XOpenDisplay ("");
+    if (display == NULL) {
+	printf ("No connection to server - aborting test.\n");
+	exit(1);
+    }
+
+    slist = list_input_devices (display, &ndevices);
+    XFreeDeviceList (slist);
+}
+
+/******************************************************************
+ *
+ * This function lists all available input devices.
+ *
+ */
+
+XDeviceInfoPtr
+list_input_devices (display, ndevices)
+    Display *display;
+    int	    *ndevices;
+{
+    int			i,j,k;
+    XDeviceInfoPtr	list, slist;
+    XAnyClassPtr	any;
+    XKeyInfoPtr		K;
+    XButtonInfoPtr	b;
+    XValuatorInfoPtr	v;
+    XAxisInfoPtr	a;
+
+    list = (XDeviceInfoPtr) XListInputDevices (display, ndevices);
+    slist = list;
+    if (Dflag)
+	printf ("The number of available input devices is %d\n",*ndevices);
+    for (i=0; i<*ndevices; i++, list++) {
+	if (Dflag) {
+	    printf ("\nDevice id is %d\n",list->id);
+	    printf ("Device type is %d\n",list->type);
+	    printf ("Device name is %s\n",list->name);
+	    printf ("Num_classes is %d\n",list->num_classes);
+	}
+	if (list->num_classes > 0) {
+	    any = (XAnyClassPtr) (list->inputclassinfo);
+	    for (j=0; j<list->num_classes; j++) {
+		if (Dflag) {
+		    printf ("\tInput class is %d\n", any->class);
+		    printf ("\tLength is %d\n", any->length);
+		}
+		switch (any->class) {
+		    case KeyClass:
+			K = (XKeyInfoPtr) any;
+			if (Dflag) {
+			    printf ("\tNum_keys is %d\n",K->num_keys);
+			    printf ("\tMin_keycode is %d\n",K->min_keycode);
+			    printf ("\tMax_keycode is %d\n",K->max_keycode);
+			}
+			break;
+		    case ButtonClass:
+			b = (XButtonInfoPtr) any;
+			if (Dflag)
+			    printf ("\tNum_buttons is %d\n",b->num_buttons);
+			break;
+		    case ValuatorClass:
+			v = (XValuatorInfoPtr) any;
+			a = v->axes;
+			if (Dflag)
+			    printf ("\tNum_axes is %d\n\n",v->num_axes);
+			for (k=0; k<v->num_axes; k++,a++) {
+			    if (Dflag) {
+				printf ("\t\tMin_value is %d\n",a->min_value);
+				printf ("\t\tMax_value is %d\n",a->max_value);
+				printf ("\t\tResolution is %d\n\n",a->resolution);
+			    }
+			}
+			break;
+		    default:
+			printf ("unknown class\n");
+		}
+		any = (XAnyClassPtr) ((char *) any + any->length);
+	    }
+	}
+    }
+    return (slist);
+}
diff --git a/src/unix/contrib/tools/xmame-screensaver b/src/unix/contrib/tools/xmame-screensaver
new file mode 100755
index 0000000..a283ecd
--- /dev/null
+++ b/src/unix/contrib/tools/xmame-screensaver
@@ -0,0 +1,16 @@
+#!/bin/bash
+
+trap "killall xmame.x11" EXIT
+ulimit -c 0
+
+while true; do
+   xmame.x11 random -run-in-root-window -scale 2 2> /dev/null &
+   sleep 120
+   killall xmame.x11
+   sleep 2
+   i=100
+   while [ "$i" -gt 0 ]; do
+      echo
+      i=$(($i-1))
+   done
+done
diff --git a/src/unix/devices.c b/src/unix/devices.c
new file mode 100644
index 0000000..446f3f6
--- /dev/null
+++ b/src/unix/devices.c
@@ -0,0 +1,1299 @@
+/*
+ * file devices.c
+ *
+ * Routines for Pointers device processing
+ *
+ * Joystick and Mouse
+ *
+ * original idea from Chris Sharp <sharp@uk.ibm.com>
+ *
+ */
+
+/*
+ * updates by sdevaux <sebastien.devaux@laposte.net>
+ */
+
+#define __DEVICES_C_
+
+#ifdef UGCICOIN
+#include <ugci.h>
+#endif
+
+#include "xmame.h"
+#include "devices.h"
+#include "input.h"
+#include "keyboard.h"
+#include "driver.h"
+#include "ui_text.h"
+
+/* local variables */
+static struct JoystickInfo joy_list[JOY_LIST_LEN + MOUSE_LIST_LEN + 1];
+/* will be used to store names for the above */
+static char joy_list_names[JOY_LIST_LEN + MOUSE_LIST_LEN][JOY_NAME_LEN];
+static int analogstick = 0;
+static int ugcicoin;
+static const char *ctrlrtype;
+static const char *ctrlrname;
+static const char *trackball_ini;
+static const char *paddle_ini;
+static const char *dial_ini;
+static const char *ad_stick_ini;
+static const char *pedal_ini;
+static const char *lightgun_ini;
+
+/* this is used for the ipdef_custom_rc_func */
+static struct ipd *ipddef_ptr = NULL;
+
+static int num_osd_ik = 0;
+static int size_osd_ik = 0;
+
+void process_ctrlr_file(struct rc_struct *iptrc, const char *ctype, 
+		const char *filename);
+
+/* input relelated options */
+struct rc_option input_opts[] =
+{
+	/* name, shortname, type, dest, deflt, min, max, func, help */
+	{ "Input Related", NULL, rc_seperator, NULL, NULL, 0, 0, NULL, NULL },
+	{ "joytype", "jt", rc_int, &joytype, "0", 0, 7, NULL, "Select type of joystick support to use:\n"
+		"0 No joystick\n"
+		"1 i386 style joystick driver (if compiled in)\n"
+		"2 Fm Town Pad support (if compiled in)\n"
+		"3 X11 input extension joystick (if compiled in)\n"
+		"4 new i386 linux 1.x.x joystick driver(if compiled in)\n"
+		"5 NetBSD USB joystick driver (if compiled in)\n"
+		"6 PS2-Linux native pad (if compiled in)\n"
+		"7 SDL joystick driver" },
+	{ "analogstick", "as", rc_bool, &analogstick, "0", 0, 0, NULL, "Use Joystick as analog for analog controls" },
+	{ NULL, NULL, rc_link, joy_i386_opts, NULL, 0, 0, NULL, NULL },
+	{ NULL, NULL, rc_link, joy_pad_opts, NULL, 0, 0, NULL, NULL },
+	{ NULL, NULL, rc_link, joy_x11_opts, NULL, 0, 0, NULL, NULL },
+	{ NULL, NULL, rc_link, joy_usb_opts, NULL, 0, 0, NULL, NULL },
+#ifdef PS2_JOYSTICK
+	{ NULL, NULL, rc_link, joy_ps2_opts, NULL, 0, 0, NULL, NULL },
+#endif
+#ifdef USE_XINPUT_DEVICES
+	{ NULL, NULL, rc_link, XInputDevices_opts, NULL, 0, 0, NULL, NULL },
+#endif
+	{ "mouse", "m", rc_bool, &use_mouse, "1", 0, 0, NULL, "Enable/disable mouse (if supported)" },
+	{ "ugcicoin", NULL, rc_bool, &ugcicoin, "0", 0, 0, NULL, "Enable/disable UGCI(tm) Coin/Play support" },
+	{ "usbpspad", "pspad", rc_bool, &is_usb_ps_gamepad, "0", 0, 0, NULL, "The Joystick(s) are USB PS Game Pads" },
+	{ "rapidfire", "rapidf", rc_bool, &rapidfire_enable, "0", 0, 0, NULL, "Enable rapid-fire support for joysticks" },
+	{ "ctrlr", NULL, rc_string, &ctrlrtype, 0, 0, 0, NULL, "Preconfigure for specified controller" },
+	{ NULL, NULL, rc_end, NULL, NULL, 0, 0, NULL, NULL }
+};
+
+struct rc_option *ctrlr_input_opts = NULL;
+
+struct rc_option ctrlr_input_opts2[] =
+{
+	/* name, shortname, type, dest, deflt, min, max, func, help */
+	{ "ctrlrname", NULL, rc_string, &ctrlrname, 0, 0, 0, NULL, "name of controller" },
+	{ "trackball_ini", NULL, rc_string, &trackball_ini, 0, 0, 0, NULL, "ctrlr opts if game has TRACKBALL input" },
+	{ "paddle_ini", NULL, rc_string, &paddle_ini, 0, 0, 0, NULL, "ctrlr opts if game has PADDLE input" },
+	{ "dial_ini", NULL, rc_string, &dial_ini, 0, 0, 0, NULL, "ctrlr opts if game has DIAL input" },
+	{ "ad_stick_ini", NULL, rc_string, &ad_stick_ini, 0, 0, 0, NULL, "ctrlr opts if game has AD STICK input" },
+	{ "lightgun_ini", NULL, rc_string, &lightgun_ini, 0, 0, 0, NULL, "ctrlr opts if game has LIGHTGUN input" },
+	{ "pedal_ini", NULL, rc_string, &pedal_ini, 0, 0, 0, NULL, "ctrlr opts if game has PEDAL input" },
+	{ NULL,	NULL, rc_end, NULL, NULL, 0, 0,	NULL, NULL }
+};
+
+static int joy_list_equiv[][2] =
+{
+	{ JOY_AXIS_CODE(0,0,0), JOYCODE_1_LEFT },
+	{ JOY_AXIS_CODE(0,0,1), JOYCODE_1_RIGHT },
+	{ JOY_AXIS_CODE(0,1,0), JOYCODE_1_UP },
+	{ JOY_AXIS_CODE(0,1,1), JOYCODE_1_DOWN },
+	{ JOY_BUTTON_CODE(0,0), JOYCODE_1_BUTTON1 },
+	{ JOY_BUTTON_CODE(0,1), JOYCODE_1_BUTTON2 },
+	{ JOY_BUTTON_CODE(0,2), JOYCODE_1_BUTTON3 },
+	{ JOY_BUTTON_CODE(0,3), JOYCODE_1_BUTTON4 },
+	{ JOY_BUTTON_CODE(0,4), JOYCODE_1_BUTTON5 },
+	{ JOY_BUTTON_CODE(0,5), JOYCODE_1_BUTTON6 },
+	{ JOY_BUTTON_CODE(0,6), JOYCODE_1_BUTTON7 },
+	{ JOY_BUTTON_CODE(0,7), JOYCODE_1_BUTTON8 },
+	{ JOY_BUTTON_CODE(0,8), JOYCODE_1_BUTTON9 },
+	{ JOY_BUTTON_CODE(0,9), JOYCODE_1_BUTTON10 },
+	{ JOY_AXIS_CODE(1,0,0), JOYCODE_2_LEFT },
+	{ JOY_AXIS_CODE(1,0,1), JOYCODE_2_RIGHT },
+	{ JOY_AXIS_CODE(1,1,0), JOYCODE_2_UP },
+	{ JOY_AXIS_CODE(1,1,1), JOYCODE_2_DOWN },
+	{ JOY_BUTTON_CODE(1,0), JOYCODE_2_BUTTON1 },
+	{ JOY_BUTTON_CODE(1,1), JOYCODE_2_BUTTON2 },
+	{ JOY_BUTTON_CODE(1,2), JOYCODE_2_BUTTON3 },
+	{ JOY_BUTTON_CODE(1,3), JOYCODE_2_BUTTON4 },
+	{ JOY_BUTTON_CODE(1,4), JOYCODE_2_BUTTON5 },
+	{ JOY_BUTTON_CODE(1,5), JOYCODE_2_BUTTON6 },
+	{ JOY_BUTTON_CODE(1,6), JOYCODE_2_BUTTON7 },
+	{ JOY_BUTTON_CODE(1,7), JOYCODE_2_BUTTON8 },
+	{ JOY_BUTTON_CODE(1,8), JOYCODE_2_BUTTON9 },
+	{ JOY_BUTTON_CODE(1,9), JOYCODE_2_BUTTON10 },
+	{ JOY_AXIS_CODE(2,0,0), JOYCODE_3_LEFT },
+	{ JOY_AXIS_CODE(2,0,1), JOYCODE_3_RIGHT },
+	{ JOY_AXIS_CODE(2,1,0), JOYCODE_3_UP },
+	{ JOY_AXIS_CODE(2,1,1), JOYCODE_3_DOWN },
+	{ JOY_BUTTON_CODE(2,0), JOYCODE_3_BUTTON1 },
+	{ JOY_BUTTON_CODE(2,1), JOYCODE_3_BUTTON2 },
+	{ JOY_BUTTON_CODE(2,2), JOYCODE_3_BUTTON3 },
+	{ JOY_BUTTON_CODE(2,3), JOYCODE_3_BUTTON4 },
+	{ JOY_BUTTON_CODE(2,4), JOYCODE_3_BUTTON5 },
+	{ JOY_BUTTON_CODE(2,5), JOYCODE_3_BUTTON6 },
+	{ JOY_BUTTON_CODE(2,6), JOYCODE_3_BUTTON7 },
+	{ JOY_BUTTON_CODE(2,7), JOYCODE_3_BUTTON8 },
+	{ JOY_BUTTON_CODE(2,8), JOYCODE_3_BUTTON9 },
+	{ JOY_BUTTON_CODE(2,9), JOYCODE_3_BUTTON10 },
+	{ JOY_AXIS_CODE(3,0,0), JOYCODE_4_LEFT },
+	{ JOY_AXIS_CODE(3,0,1), JOYCODE_4_RIGHT },
+	{ JOY_AXIS_CODE(3,1,0), JOYCODE_4_UP },
+	{ JOY_AXIS_CODE(3,1,1), JOYCODE_4_DOWN },
+	{ JOY_BUTTON_CODE(3,0), JOYCODE_4_BUTTON1 },
+	{ JOY_BUTTON_CODE(3,1), JOYCODE_4_BUTTON2 },
+	{ JOY_BUTTON_CODE(3,2), JOYCODE_4_BUTTON3 },
+	{ JOY_BUTTON_CODE(3,3), JOYCODE_4_BUTTON4 },
+	{ JOY_BUTTON_CODE(3,4), JOYCODE_4_BUTTON5 },
+	{ JOY_BUTTON_CODE(3,5), JOYCODE_4_BUTTON6 },
+	{ JOY_BUTTON_CODE(3,6), JOYCODE_4_BUTTON7 },
+	{ JOY_BUTTON_CODE(3,7), JOYCODE_4_BUTTON8 },
+	{ JOY_BUTTON_CODE(3,8), JOYCODE_4_BUTTON9 },
+	{ JOY_BUTTON_CODE(3,9), JOYCODE_4_BUTTON10 },
+	{ 0,0 }
+};
+
+#ifdef UGCICOIN
+
+#define PLAY_KEYCODE_BASE     KEY_1
+#define COIN_KEYCODE_BASE     KEY_3
+#define MAX_PLAYERS           2
+#define MIN_COIN_WAIT         3
+
+static int coin_pressed[MAX_PLAYERS];
+
+static void ugci_callback(int id, enum ugci_event_type type, int value)
+{
+	struct xmame_keyboard_event event;
+
+	if (id >= MAX_PLAYERS)
+		return;
+
+	switch (type)
+	{
+		case UGCI_EVENT_PLAY:
+			event.press = value;
+			event.scancode = PLAY_KEYCODE_BASE + id;
+			xmame_keyboard_register_event(&event);
+			break;
+
+		case UGCI_EVENT_COIN:
+			if (coin_pressed[id])
+				return;
+			event.press = coin_pressed[id] = 1;
+			event.scancode = COIN_KEYCODE_BASE + id;
+			xmame_keyboard_register_event(&event);
+			break;
+
+		default:
+			break;
+	}
+}
+#endif
+
+void load_rapidfire_settings(void)
+{
+	FILE *fp;
+	char name[BUF_SIZE];
+
+	if (!rapidfire_enable)
+		return;
+
+	snprintf(name, BUF_SIZE, "%s/.%s/cfg/%s.rpf", home_dir, NAME, Machine->gamedrv->name);
+	fp = fopen(name, "rb");
+	if (fp)
+	{
+		int i,j;
+
+		for (i=0; i<4; i++)
+		{
+			fread(&rapidfire_data[i].ctrl_button, sizeof(rapidfire_data[0].ctrl_button), 1, fp);
+			for (j=0; j<10; j++)
+			{
+				fread(&rapidfire_data[i].setting[j], sizeof(rapidfire_data[0].setting[0]), 1, fp);
+			}
+		}
+		fclose(fp);
+	}
+}
+
+void save_rapidfire_settings(void)
+{
+	FILE *fp;
+	char name[BUF_SIZE];
+
+	if (!rapidfire_enable)
+		return;
+
+	snprintf(name, BUF_SIZE, "%s/.%s/cfg/%s.rpf", home_dir, NAME, Machine->gamedrv->name);
+	fp = fopen(name, "wb");
+	if (fp)
+	{
+		int i,j;
+		for (i=0; i<4; i++)
+		{
+			fwrite(&rapidfire_data[i].ctrl_button, sizeof(rapidfire_data[0].ctrl_button), 1, fp);
+			for (j=0; j<10; j++)
+			{
+				fwrite(&rapidfire_data[i].setting[j], sizeof(rapidfire_data[0].setting[0]), 1, fp);
+			}
+		}
+		fclose(fp);
+	}
+}
+
+/* 2 init routines one for creating the display and one after that, since some
+   (most) init stuff needs a display */
+
+int osd_input_initpre(void)
+{
+	int i, j, k, joy_list_count = 0;
+
+	joy_poll_func = NULL;
+
+	memset(joy_data,   0, sizeof(joy_data));
+	memset(mouse_data, 0, sizeof(mouse_data));
+
+	if(rapidfire_enable)
+	{
+		memset(rapidfire_data, 0, sizeof(rapidfire_data));
+
+		for(i=0; i<4; i++)
+		{
+			rapidfire_data[i].enable = 1;
+			rapidfire_data[i].ctrl_button = -1;
+			rapidfire_data[i].ctrl_prev_status = 0;
+			for(j=0; j<10; j++)
+			{
+				rapidfire_data[i].setting[j] = 64;
+				rapidfire_data[i].status[j] = 0;
+			}
+		}
+		load_rapidfire_settings();
+	}
+
+	for(i=0; i<JOY; i++)
+	{
+		joy_data[i].fd = -1;
+		for(j=0; j<JOY_AXIS; j++)
+		{
+			joy_data[i].axis[j].min = -10;
+			joy_data[i].axis[j].max =  10;
+			for(k=0; k<JOY_DIRS; k++)
+			{
+				snprintf(joy_list_names[joy_list_count], JOY_NAME_LEN,
+						"Joy %d axis %d %s", i+1, j+1, (k)? "pos":"neg");
+				joy_list_count++;
+			}
+		}
+		for(j=0; j<JOY_BUTTONS; j++)
+		{
+			snprintf(joy_list_names[joy_list_count], JOY_NAME_LEN,
+					"Joy %d button %d", i+1 ,j+1);
+			joy_list_count++;
+		}
+	}
+
+	for(i=0; i<MOUSE; i++)
+	{
+		for(j=0; j<MOUSE_BUTTONS; j++)
+		{
+			snprintf(joy_list_names[joy_list_count], JOY_NAME_LEN,
+					"Mouse %d button %d", i+1, j+1);
+			joy_list_count++;
+		}
+	}
+
+	/* terminate array */
+	joy_list[joy_list_count].name = 0;
+	joy_list[joy_list_count].code = 0;
+	joy_list[joy_list_count].standardcode = 0;
+
+	/* fill in codes */
+	for (i=0; i<joy_list_count; i++)
+	{
+		joy_list[i].code = i;
+		joy_list[i].name = joy_list_names[i];
+		joy_list[i].standardcode = JOYCODE_OTHER;
+
+		for(j=0; joy_list_equiv[j][1]; j++)
+		{
+			if (joy_list_equiv[j][0] == joy_list[i].code)
+			{
+				joy_list[i].standardcode = joy_list_equiv[j][1];
+				break;
+			}
+		}
+	}
+
+	if (use_mouse)
+		fprintf (stderr_file, "Mouse/Trakball selected.\n");
+
+#ifdef UGCICOIN
+	if (ugcicoin) {
+		if (ugci_init(ugci_callback, UGCI_EVENT_MASK_COIN | UGCI_EVENT_MASK_PLAY, 1) <= 0)
+			ugcicoin = 0;
+	}
+#endif
+
+#ifdef JOY_PS2
+	/* Special mapping for PlayStation2 -- to be removed when 0.60 patch done */
+	/* Add mappings for P1 SELECT, START, P2 SELECT, START */
+	joy_list[JOY_BUTTON_CODE(0,6)] = JOYCODE_1_SELECT;
+	joy_list[JOY_BUTTON_CODE(0,7)] = JOYCODE_1_START;
+	joy_list[JOY_BUTTON_CODE(1,6)] = JOYCODE_2_SELECT;
+	joy_list[JOY_BUTTON_CODE(1,7)] = JOYCODE_2_START;
+	/* For now, L2 is equivalent of TAB, and R2 is equivalent of ESC */
+	joy_list[JOY_BUTTON_CODE(0,8)] = KEYCODE_TAB;
+	joy_list[JOY_BUTTON_CODE(0,9)] = KEYCODE_ESC;
+	/* Remap L3 and R3 to BUTTON7 and BUTTON8 */
+	joy_list[JOY_BUTTON_CODE(0,10)] = JOYCODE_1_BUTTON7;
+	joy_list[JOY_BUTTON_CODE(0,11)] = JOYCODE_1_BUTTON8;
+	joy_list[JOY_BUTTON_CODE(1,10)] = JOYCODE_2_BUTTON7;
+	joy_list[JOY_BUTTON_CODE(1,11)] = JOYCODE_2_BUTTON8;
+	/* Map the 4 directional buttons to the four axes. */
+	joy_list[JOY_BUTTON_CODE(0,12)] = JOYCODE_1_LEFT;
+	joy_list[JOY_BUTTON_CODE(0,13)] = JOYCODE_1_RIGHT;
+	joy_list[JOY_BUTTON_CODE(0,14)] = JOYCODE_1_UP;
+	joy_list[JOY_BUTTON_CODE(0,15)] = JOYCODE_1_DOWN;
+	joy_list[JOY_BUTTON_CODE(1,12)] = JOYCODE_2_LEFT;
+	joy_list[JOY_BUTTON_CODE(1,13)] = JOYCODE_2_RIGHT;
+	joy_list[JOY_BUTTON_CODE(1,14)] = JOYCODE_2_UP;
+	joy_list[JOY_BUTTON_CODE(1,15)] = JOYCODE_2_DOWN;
+#endif
+
+	return OSD_OK;
+}
+
+int osd_input_initpost(void)
+{
+	int i;
+
+#ifdef USE_XINPUT_DEVICES
+	XInputDevices_init();
+#endif
+
+	/* init the keyboard */
+	if (xmame_keyboard_init())
+		return OSD_NOT_OK;
+
+	/* joysticks */
+	switch (joytype)
+	{
+		case JOY_NONE:
+			break;
+#ifdef I386_JOYSTICK
+		case JOY_I386NEW:
+		case JOY_I386:
+			joy_i386_init();
+			break;
+#endif
+#ifdef LIN_FM_TOWNS
+		case JOY_PAD:
+			joy_pad_init ();
+			break;
+#endif
+#ifdef X11_JOYSTICK
+		case JOY_X11:
+			joy_x11_init();
+			break;
+#endif
+#ifdef USB_JOYSTICK
+		case JOY_USB:
+			joy_usb_init();
+			break;
+#endif
+#ifdef PS2_JOYSTICK
+		case JOY_PS2:
+			joy_ps2_init();
+			break;
+#endif
+#ifdef SDL
+		case JOY_SDL:
+			joy_SDL_init();
+			break;
+#endif
+		default:
+			fprintf (stderr_file, "OSD: Warning: unknown joytype: %d, or joytype not compiled in.\n"
+					"   Disabling joystick support.\n", joytype);
+			joytype = JOY_NONE;
+	}
+
+	if(joytype != JOY_NONE)
+	{
+		int found = FALSE;
+
+		for (i=0; i<JOY; i++)
+		{
+			if(joy_data[i].num_axis || joy_data[i].num_buttons)
+			{
+				fprintf(stderr_file, "OSD: Info: Joystick %d, %d axis, %d buttons\n",
+						i, joy_data[i].num_axis, joy_data[i].num_buttons);
+				found = TRUE;
+			}
+		}
+
+		if (!found)
+		{
+			fprintf(stderr_file, "OSD: Warning: No joysticks found disabling joystick support\n");
+			joytype = JOY_NONE;
+		}
+	}
+
+	return OSD_OK;
+}
+
+void osd_input_close(void)
+{
+	int i;
+
+	xmame_keyboard_exit();
+
+	switch(joytype)
+	{
+#ifdef PS2_JOYSTICK
+		case JOY_PS2:
+			joy_ps2_exit();
+			break;
+#endif
+		default:
+			break;
+	}
+
+	for(i=0;i<JOY;i++)
+		if(joy_data[i].fd >= 0)
+			close(joy_data[i].fd);
+
+	if(rapidfire_enable)
+		save_rapidfire_settings();
+}
+
+/* return a list of all available joys */
+const struct JoystickInfo *osd_get_joy_list(void)
+{
+	return joy_list;
+}
+
+/* <jake> */
+void osd_trak_read(int player,int *deltax,int *deltay)
+{
+#ifdef USE_XINPUT_DEVICES
+	if (player < XINPUT_JOYSTICK_1)
+	{
+		XInputPollDevices(player,deltax,deltay);
+	}
+	else
+	{
+		*deltax = 0;
+		*deltay = 0;
+	}
+#else
+	if (player < MOUSE)
+	{
+		*deltax = mouse_data[player].deltas[0];
+		*deltay = mouse_data[player].deltas[1];
+	}
+	else
+	{
+		*deltax = 0;
+		*deltay = 0;
+	}
+#endif
+}
+/* </jake> */
+
+int get_rapidfire_speed(int joy_num, int button_num)
+{
+	if (joy_num < 0 || 3 < joy_num)
+		return 0;
+	if (button_num < 0 || 9 < button_num)
+		return 0;
+
+	return rapidfire_data[joy_num].setting[button_num];
+}
+
+void set_rapidfire_speed(int joy_num, int button_num, int speed)
+{
+	if (joy_num < 0 || 3 < joy_num)
+		return;
+	if (button_num < 0 || 9 < button_num)
+		return;
+
+	rapidfire_data[joy_num].setting[button_num] = speed;
+	rapidfire_data[joy_num].status[button_num] = 0;
+}
+
+int is_rapidfire_ctrl_button(int joy_num, int button_num)
+{
+	if (joy_num < 0 || 3 < joy_num)
+		return 0;
+	if (button_num < 0 || 9 < button_num)
+		return 0;
+
+	if (button_num == rapidfire_data[joy_num].ctrl_button)
+		return 1;
+	else
+		return 0;
+}
+
+int no_rapidfire_ctrl_button(int joy_num)
+{
+	if (joy_num < 0 || 3 < joy_num)
+		return 0;
+
+	if (rapidfire_data[joy_num].ctrl_button < 0 ||
+			rapidfire_data[joy_num].ctrl_button > 9)
+		return 1;
+	else
+		return 0;
+}
+
+void set_rapidfire_ctrl_button(int joy_num, int button_num)
+{
+	if (joy_num < 0 || 3 < joy_num)
+		return;
+	if (button_num < 0 || 9 < button_num)
+		return;
+
+	rapidfire_data[joy_num].ctrl_button = button_num;
+}
+
+void unset_rapidfire_ctrl_button(int joy_num)
+{
+	if (joy_num < 0 || 3 < joy_num)
+		return;
+
+	rapidfire_data[joy_num].ctrl_button = -1;
+}
+
+int setrapidfire(struct mame_bitmap *bitmap, int selected)
+{
+	const char *menu_item[42] = {
+		"Joy1Button 1",
+		"Joy1Button 2",
+		"Joy1Button 3",
+		"Joy1Button 4",
+		"Joy1Button 5",
+		"Joy1Button 6",
+		"Joy1Button 7",
+		"Joy1Button 8",
+		"Joy1Button 9",
+		"Joy1Button10",
+		"Joy2Button 1",
+		"Joy2Button 2",
+		"Joy2Button 3",
+		"Joy2Button 4",
+		"Joy2Button 5",
+		"Joy2Button 6",
+		"Joy2Button 7",
+		"Joy2Button 8",
+		"Joy2Button 9",
+		"Joy2Button10",
+		"Joy3Button 1",
+		"Joy3Button 2",
+		"Joy3Button 3",
+		"Joy3Button 4",
+		"Joy3Button 5",
+		"Joy3Button 6",
+		"Joy3Button 7",
+		"Joy3Button 8",
+		"Joy3Button 9",
+		"Joy3Button10",
+		"Joy4Button 1",
+		"Joy4Button 2",
+		"Joy4Button 3",
+		"Joy4Button 4",
+		"Joy4Button 5",
+		"Joy4Button 6",
+		"Joy4Button 7",
+		"Joy4Button 8",
+		"Joy4Button 9",
+		"Joy4Button10",
+		0,
+		0              /* terminate array */
+	};
+	const char *menu_subitem[42];
+	char sub[42][16];
+	int sel;
+	int arrowize;
+	int items = 41;
+	int joy;
+	int button;
+	int d0,flag;
+
+	menu_subitem[40] = 0;
+	menu_item[40] = ui_getstring (UI_returntomain);
+
+	sel = selected - 1;
+
+	for (joy = 0; joy < 4; joy += 1)
+	{
+		for (button = 0; button < 10; button += 1)
+		{
+			if (is_rapidfire_ctrl_button(joy, button))
+			{
+				sprintf(&sub[ (joy*10) + button ][0], "    SWITCH");
+			}
+			else
+			{
+				int speed = get_rapidfire_speed(joy, button);
+				if (speed & 0x0100)
+					sprintf(&sub[ (joy*10) + button ][0], "RAPID %3d", speed & 0xFF);
+				else if(speed & 0x0200)
+					sprintf(&sub[ (joy*10) + button ][0], "CHARGE %3d", speed & 0xFF);
+				else
+					sprintf(&sub[ (joy*10) + button ][0], "     OFF");
+			}
+			menu_subitem[ (joy*10) + button ] = &sub[ (joy*10) + button ][0];
+		}
+	}
+	arrowize = 0;
+	ui_displaymenu(bitmap, menu_item, menu_subitem, 0, sel, arrowize);
+
+	if (input_ui_pressed_repeat(IPT_UI_DOWN,8))
+		sel = (sel + 1) % items;
+
+	if (input_ui_pressed_repeat(IPT_UI_UP,8))
+		sel = (sel + items - 1) % items;
+
+	if (input_ui_pressed_repeat(IPT_UI_LEFT,8))
+	{
+		if (sel < items - 1)
+		{
+			joy    = sel / 10;
+			button = sel % 10;
+			d0 = get_rapidfire_speed(joy, button);
+			flag = d0 & 0xff00;
+			if((flag & 0x300)&&(!is_rapidfire_ctrl_button(joy, button)))
+			{
+				d0 &= 0xff;
+				if              (d0 <= 32){
+					d0 = 128;
+				}else if(d0 <= 64){
+					d0 = 32;
+				}else if(d0 <= 96){
+					d0 = 64;
+				}else if(d0 <= 128){
+					d0 = 96;
+				}else{
+					d0 = 128;
+				}
+				d0 |= flag;
+				set_rapidfire_speed(joy, button, d0);
+				/* tell updatescreen() to clean after us (in case the window changes size) */
+				schedule_full_refresh();
+			}
+		}
+	}
+
+	if (input_ui_pressed_repeat(IPT_UI_RIGHT,8))
+	{
+		if (sel < items - 1)
+		{
+			joy    = sel / 10;
+			button = sel % 10;
+			d0 = get_rapidfire_speed(joy, button);
+			flag = d0 & 0xff00;
+			if((flag & 0x300)&&(is_rapidfire_ctrl_button(joy, button)))
+			{
+				d0 &= 0xff;
+				if (d0 <= 32)
+					d0 = 64;
+				else if (d0 <= 64)
+					d0 = 96;
+				else if (d0 <= 96)
+					d0 = 128;
+				else if (d0 <= 128)
+					d0 = 32;
+				else
+					d0 = 128;
+
+				d0 |= flag;
+				set_rapidfire_speed(joy, button, d0);
+				/* tell updatescreen() to clean after us (in case the window changes size) */
+				schedule_full_refresh();
+			}
+		}
+	}
+
+	if (input_ui_pressed(IPT_UI_SELECT))
+	{
+		if (sel == items - 1) sel = -1;         /* cancel */
+		else if (sel < items - 1)
+		{
+			joy    = sel / 10;
+			button = sel % 10;
+			d0 = get_rapidfire_speed(joy, button);
+			flag = d0 & 0xff00;
+			d0 &= 0xff;
+			if (is_rapidfire_ctrl_button(joy, button))
+			{
+				/* off */
+				flag = 0;
+				unset_rapidfire_ctrl_button(joy);
+			}
+			else if(flag & 0x100)
+			{
+				flag = 0x200; /* rapid */
+			}
+			else if(flag & 0x200)
+			{
+				/* switch */
+				if(no_rapidfire_ctrl_button(joy))
+				{
+					set_rapidfire_ctrl_button(joy, button);
+				}
+				flag = 0;
+			}
+			else
+			{
+				flag = 0x100; /* charge */
+			}
+			d0 |= flag;
+			set_rapidfire_speed(joy, button, d0);
+			/* tell updatescreen() to clean after us (in case the window changes size) */
+			schedule_full_refresh();
+		}
+	}
+
+	if (input_ui_pressed(IPT_UI_CANCEL))
+		sel = -1;                                                       
+	/* cancel */
+
+	if (input_ui_pressed(IPT_UI_CONFIGURE))
+		sel = -2;
+
+	if (sel == -1 || sel == -2)
+	{
+		schedule_full_refresh();
+	}
+
+	return sel + 1;
+}
+
+void joystick_rapidfire(void)
+{
+	int joy_num;
+	int button_num;
+	int ctrl;
+
+	if (setup_active())
+		return;
+
+	for (joy_num=0; joy_num<4 && joy_data[joy_num].fd>=0; joy_num++)
+	{
+		ctrl = rapidfire_data[joy_num].ctrl_button;
+		if (ctrl >= 0 && ctrl < 10 && ctrl < joy_data[joy_num].num_buttons)
+		{
+			if (joy_data[joy_num].buttons[ctrl] &&
+					rapidfire_data[joy_num].ctrl_prev_status == 0)
+			{
+				rapidfire_data[joy_num].enable = 1 - rapidfire_data[joy_num].enable;
+			}
+			rapidfire_data[joy_num].ctrl_prev_status = joy_data[joy_num].buttons[ctrl];
+		}
+		if (rapidfire_data[joy_num].enable)
+		{
+			for (button_num = 0;
+					button_num < 10 && button_num < joy_data[joy_num].num_buttons;
+					button_num++)
+			{
+				if (rapidfire_data[joy_num].setting[button_num] & 0xff &&
+						rapidfire_data[joy_num].setting[button_num] & 0x300)
+				{
+					if (joy_data[joy_num].buttons[button_num] != 0)
+					{
+						joy_data[joy_num].buttons[button_num] &=
+							(rapidfire_data[joy_num].status[button_num] >> 7) ? 0xFFFF : 0;
+						rapidfire_data[joy_num].status[button_num] +=
+							rapidfire_data[joy_num].setting[button_num];
+						rapidfire_data[joy_num].status[button_num] &= 0xFF;
+					}else{
+						rapidfire_data[joy_num].status[button_num] = 0xFF;
+
+						/* charge */
+						if ((rapidfire_data[joy_num].setting[button_num] & 0x300) == 0x200)
+							joy_data[joy_num].buttons[button_num] = 0xFFFF;
+					}
+				}
+			}
+		}
+	}
+}
+
+static struct joydata_struct prev_joy_data[JOY];
+
+void store_button_state(void)
+{
+	int i;
+
+	for (i=0; i<JOY; i++)
+		prev_joy_data[i] = joy_data[i];
+}
+
+void restore_button_state(void)
+{
+	int i, j;
+
+	for (i=0; i<JOY; i++)
+		for (j=0; j<JOY_BUTTONS; j++)
+			joy_data[i].buttons[j] = prev_joy_data[i].buttons[j];
+}
+
+void osd_poll_joysticks(void)
+{
+	if (use_mouse)
+		sysdep_mouse_poll ();
+	if (joy_poll_func)
+	{
+		if (rapidfire_enable)
+			restore_button_state();
+
+		(*joy_poll_func) ();
+
+		if (rapidfire_enable)
+		{
+			store_button_state();
+			joystick_rapidfire();
+		}
+	}
+#ifdef UGCICOIN
+	if (ugcicoin)
+	{
+		int id;
+
+		ugci_poll(0);
+
+		/* Check coin-pressed. Simulate a release event */
+		for (id = 0; id < MAX_PLAYERS; id++)
+		{
+			if (coin_pressed[id] && coin_pressed[id]++ > MIN_COIN_WAIT)
+			{
+				struct xmame_keyboard_event event;
+
+				event.press = coin_pressed[id] = 0;
+				event.scancode = COIN_KEYCODE_BASE + id;
+				xmame_keyboard_register_event(&event);
+			}
+		}
+	}
+#endif
+}
+
+int osd_is_joy_pressed (int joycode)
+{
+	if (joycode >= (JOY_LIST_LEN+MOUSE_LIST_LEN))
+		return FALSE;
+
+	if (MOUSE_IS_BUTTON(joycode))
+	{
+		int mouse  = MOUSE_GET_MOUSE(joycode);
+		int button = MOUSE_GET_BUTTON(joycode);
+		return mouse_data[mouse].buttons[button];
+	}
+	else
+	{
+		int joy = JOY_GET_JOY(joycode);
+
+		if (JOY_IS_AXIS(joycode))
+		{
+			int axis = JOY_GET_AXIS(joycode);
+			int dir  = JOY_GET_DIR(joycode);
+			return joy_data[joy].axis[axis].dirs[dir];
+		}
+		else
+		{
+			int button = JOY_GET_BUTTON(joycode);
+			return joy_data[joy].buttons[button];
+		}
+	}
+}
+
+/*
+ * given a new x an y joystick axis value convert it to a move definition
+ */
+
+void joy_evaluate_moves(void)
+{
+	int i, j, threshold;
+
+	if( is_usb_ps_gamepad )
+	{
+		for (i=0; i<JOY; i++)
+		{
+			joy_data[i].axis[0].dirs[0] = joy_data[i].buttons[15] == 1 ? TRUE : FALSE;
+			joy_data[i].axis[0].dirs[1] = joy_data[i].buttons[13] == 1 ? TRUE : FALSE;
+			joy_data[i].axis[1].dirs[0] = joy_data[i].buttons[12] == 1 ? TRUE : FALSE;
+			joy_data[i].axis[1].dirs[1] = joy_data[i].buttons[14] == 1 ? TRUE : FALSE;
+		}
+	} 
+	else 
+	{
+		for (i=0; i<JOY; i++)
+		{
+			for (j=0; j<joy_data[i].num_axis; j++)
+			{
+				memset(joy_data[i].axis[j].dirs, FALSE, JOY_DIRS*sizeof(int));
+
+				/* auto calibrate */
+				/* sdevaux 04/2003 : update middle when autocalibrate */
+				if (joy_data[i].axis[j].val > joy_data[i].axis[j].max)
+				{
+					joy_data[i].axis[j].max = joy_data[i].axis[j].val;
+					joy_data[i].axis[j].center = (joy_data[i].axis[j].max + joy_data[i].axis[j].min)/2;
+				}
+				else if (joy_data[i].axis[j].val < joy_data[i].axis[j].min)
+				{
+					joy_data[i].axis[j].min = joy_data[i].axis[j].val;
+					joy_data[i].axis[j].center = (joy_data[i].axis[j].max + joy_data[i].axis[j].min)/2;
+				}
+
+				threshold = (joy_data[i].axis[j].max - joy_data[i].axis[j].center) >> 1;
+
+				if (joy_data[i].axis[j].val < (joy_data[i].axis[j].center - threshold))
+					joy_data[i].axis[j].dirs[0] = TRUE;
+				else if (joy_data[i].axis[j].val > (joy_data[i].axis[j].center + threshold))
+					joy_data[i].axis[j].dirs[1] = TRUE;
+			}
+		}
+	}
+}
+
+/* 
+ * return a value in the range -128 .. 128 (yes, 128, not 127)
+ * sdevaux 02/2003 : Updated from windows code.
+ * sdevaux 04/2003 : fix y-axis not seen as analog (reported by Paul Rahme)
+ */
+void osd_analogjoy_read(int player, int analog_axis[],
+		InputCode analogjoy_input[])
+{
+	int i, j;
+	/* is player var enough to select joystick : what if joystick 2 is mapped to
+	   player 1 ? */
+	int max_axes=joy_data[player].num_axis;
+	if (max_axes>MAX_ANALOG_AXES)
+		max_axes=MAX_ANALOG_AXES;
+	for (i=0; analogstick && i<max_axes ; i++)
+	{
+		struct axisdata_struct * axis;
+		axis=&(joy_data[player].axis[i]);
+		analog_axis[i] = (axis->val - axis->center) * 257 / (axis->max - axis->min);
+		/* Does overflow can really happen, since axis->max and axis->min are updated
+		   when val is outside [min;max] (cf void joy_evaluate_moves(void) ) ? */
+		if (analog_axis[i] < -128)
+			analog_axis[i] = -128;
+		if (analog_axis[i] >  128)
+			analog_axis[i] =  128;
+		if (JOYTYPE( analogjoy_input[i] ) == JOYTYPE_AXIS_POS)
+			analog_axis[i] = -analog_axis[i];
+	}
+
+	/* set remaining axes to MAX_ANALOG_AXES to 0 */
+	for (j=i;j<MAX_ANALOG_AXES;j++)
+		analog_axis[j]=0;
+}
+
+/*
+ * sdevaux 02/2003 : Updated from windows code.
+ */
+int osd_is_joystick_axis_code(int joycode)
+{
+	switch (JOYTYPE(joycode))
+	{
+		case JOYTYPE_AXIS_POS:
+		case JOYTYPE_AXIS_NEG:
+			return 1;
+		default:
+			return 0;
+	}
+}
+
+void osd_lightgun_read(int player, int *deltax, int *deltay)
+{
+	/* NEED TO FILL THIS IN */
+}
+
+int osd_joystick_needs_calibration(void)
+{
+	/* 
+	 * xmame uses the kernel's joystick drivers calibration, or 
+	 * autocalibration and thus never needs this
+	 */
+	return 0;
+}
+
+void osd_joystick_start_calibration(void)
+{
+}
+
+const char *osd_joystick_calibrate_next(void)
+{
+	return NULL;
+}
+
+void osd_joystick_calibrate(void)
+{
+}
+
+void osd_joystick_end_calibration(void)
+{
+}
+
+
+extern struct rc_struct *rc;
+
+void process_ctrlr_file(struct rc_struct *iptrc, const char *ctype, 
+		const char *filename)
+{
+	mame_file *f;
+
+	/* open the specified controller type/filename */
+	f = mame_fopen (ctype, filename, FILETYPE_CTRLR, 0);
+
+	if (f)
+	{
+		if (ctype)
+			fprintf (stderr_file, "trying to parse ctrlr file %s/%s.ini\n", ctype, filename);
+		else
+			fprintf (stderr_file, "trying to parse ctrlr file %s.ini\n", filename);
+
+		/* process this file */
+		if (osd_rc_read(iptrc, f, filename, 1, 1))
+		{
+			if (ctype)
+				fprintf (stderr_file, "problem parsing ctrlr file %s/%s.ini\n", ctype, filename);
+			else
+				fprintf (stderr_file, "problem parsing ctrlr file %s.ini\n", filename);
+		}
+	}
+
+	/* close the file */
+	if (f)
+		mame_fclose (f);
+}
+
+void process_ctrlr_game(struct rc_struct *iptrc, const char *ctype, 
+		const struct GameDriver *drv)
+{
+	/* recursive call to process parents first */
+	if (drv->clone_of)
+		process_ctrlr_game (iptrc, ctype, drv->clone_of);
+
+	/* now process this game */
+	if (drv->name && *(drv->name) != 0)
+		process_ctrlr_file (iptrc, ctype, drv->name);
+}
+
+/* nice hack: load source_file.ini (omit if referenced later any) */
+void process_ctrlr_system(struct rc_struct *iptrc, const char *ctype, 
+		const struct GameDriver *drv)
+{
+	char buffer[128];
+	const struct GameDriver *tmp_gd;
+
+	sprintf(buffer, "%s", drv->source_file+12);
+	buffer[strlen(buffer) - 2] = 0;
+
+	tmp_gd = drv;
+	while (tmp_gd != NULL)
+	{
+		if (strcmp(tmp_gd->name, buffer) == 0) break;
+		tmp_gd = tmp_gd->clone_of;
+	}
+
+	/* not referenced later, so load it here */
+	if (tmp_gd == NULL)
+		/* now process this system */
+		process_ctrlr_file (iptrc, ctype, buffer);
+}
+
+static int ipdef_custom_rc_func(struct rc_option *option, const char *arg, 
+		int priority)
+{
+	struct ik *pinput_keywords = (struct ik *)option->dest;
+	struct ipd *idef = ipddef_ptr;
+
+	/* only process the default definitions if the input port definitions */
+	/* pointer has been defined */
+	if (idef)
+	{
+		/* if a keycode was re-assigned */
+		if (pinput_keywords->type == IKT_STD)
+		{
+			InputSeq is;
+
+			/* get the new keycode */
+			seq_set_string (&is, arg);
+
+			/* was a sequence was assigned to a keycode? - not valid! */
+			if (is[1] != CODE_NONE)
+			{
+				fprintf(stderr_file, "error: can't map \"%s\" to \"%s\"\n",pinput_keywords->name,arg);
+			}
+
+			/* for all definitions */
+			while (idef->type != IPT_END)
+			{
+				int j;
+
+				/* reassign all matching keystrokes to the given argument */
+				for (j = 0; j < SEQ_MAX; j++)
+				{
+					/* if the keystroke matches */
+					if (idef->seq[j] == pinput_keywords->val)
+					{
+						/* re-assign */
+						idef->seq[j] = is[0];
+					}
+				}
+				/* move to the next definition */
+				idef++;
+			}
+		}
+
+		/* if an input definition was re-defined */
+		else if (pinput_keywords->type == IKT_IPT ||
+                 pinput_keywords->type == IKT_IPT_EXT)
+		{
+			/* loop through all definitions */
+			while (idef->type != IPT_END)
+			{
+				/* if the definition matches */
+				if (idef->type == pinput_keywords->val)
+				{
+                    if (pinput_keywords->type == IKT_IPT_EXT)
+                        idef++;
+					seq_set_string(&idef->seq, arg);
+					/* and abort (there shouldn't be duplicate definitions) */
+					break;
+				}
+
+				/* move to the next definition */
+				idef++;
+			}
+		}
+	}
+
+	return 0;
+}
+
+
+/*============================================================ */
+/*	osd_customize_inputport_defaults */
+/*============================================================ */
+
+void osd_customize_inputport_defaults(struct ipd *defaults)
+{
+	static InputSeq no_alt_tab_seq = SEQ_DEF_5(KEYCODE_TAB, CODE_NOT, KEYCODE_LALT, CODE_NOT, KEYCODE_RALT);
+	UINT32 next_reserved = IPT_OSD_1;
+	struct ipd *idef = defaults;
+	int i;
+
+	/* loop over all the defaults */
+	while (idef->type != IPT_END)
+	{
+		/* if the type is OSD reserved */
+		if (idef->type == IPT_OSD_RESERVED)
+		{
+			/* process the next reserved entry */
+			switch (next_reserved)
+			{
+				/* OSD_1 is alt-enter for fullscreen */
+				case IPT_OSD_1:
+					idef->type = next_reserved;
+					idef->name = "Toggle fullscreen";
+					seq_set_2 (&idef->seq, KEYCODE_LALT, KEYCODE_ENTER);
+				break;
+
+				default:
+				break;
+			}
+			next_reserved++;
+		}
+
+		/* disable the config menu if the ALT key is down */
+		/* (allows ALT-TAB to switch between windows apps) */
+		if (idef->type == IPT_UI_CONFIGURE)
+		{
+			seq_copy(&idef->seq, &no_alt_tab_seq);
+		}
+
+		/* find the next one */
+		idef++;
+	}
+
+	/* create a structure for the input port options */
+	if (!(ctrlr_input_opts = calloc (num_ik+num_osd_ik+1, sizeof(struct rc_option))))
+	{
+		fprintf(stderr, "error on ctrlr_input_opts creation\n");
+		exit(1);
+	}
+
+	/* Populate the structure with the input_keywords. */
+	/* For all, use the ipdef_custom_rc_func callback. */
+	/* Also, reference the original ik structure. */
+	for (i=0; i<num_ik+num_osd_ik; i++)
+	{
+		if (i < num_ik)
+		{
+	   		ctrlr_input_opts[i].name = input_keywords[i].name;
+			ctrlr_input_opts[i].dest = (void *)&input_keywords[i];
+		}
+		else
+		{
+	   		ctrlr_input_opts[i].name = osd_input_keywords[i-num_ik].name;
+			ctrlr_input_opts[i].dest = (void *)&osd_input_keywords[i-num_ik];
+		}
+		ctrlr_input_opts[i].shortname = NULL;
+		ctrlr_input_opts[i].type = rc_use_function;
+		ctrlr_input_opts[i].deflt = NULL;
+		ctrlr_input_opts[i].min = 0.0;
+		ctrlr_input_opts[i].max = 0.0;
+		ctrlr_input_opts[i].func = ipdef_custom_rc_func;
+		ctrlr_input_opts[i].help = NULL;
+		ctrlr_input_opts[i].priority = 0;
+	}
+
+	/* add an end-of-opts indicator */
+	ctrlr_input_opts[i].type = rc_end;
+
+	if (rc_register(rc, ctrlr_input_opts))
+	{
+		fprintf (stderr, "error on registering ctrlr_input_opts\n");
+		exit(1);
+	}
+
+	if (rc_register(rc, ctrlr_input_opts2))
+	{
+		fprintf (stderr, "error on registering ctrlr_input_opts2\n");
+		exit(1);
+	}
+
+	/* set a static variable for the ipdef_custom_rc_func callback */
+	ipddef_ptr = defaults;
+
+	/* process the main platform-specific default file */
+	process_ctrlr_file (rc, NULL, "default");
+
+	/* if a custom controller has been selected */
+	if (ctrlrtype && *ctrlrtype != 0 && (stricmp(ctrlrtype,"Standard") != 0))
+	{
+		const struct InputPortTiny* input = Machine->gamedrv->input_ports;
+		int paddle = 0, dial = 0, trackball = 0, adstick = 0, pedal = 0, lightgun = 0;
+
+		/* process the controller-specific default file */
+		process_ctrlr_file (rc, ctrlrtype, "default");
+
+		/* process the system-specific files for this controller */
+		process_ctrlr_system (rc, ctrlrtype, Machine->gamedrv);
+
+		/* process the game-specific files for this controller */
+		process_ctrlr_game (rc, ctrlrtype, Machine->gamedrv);
+	}
+}
diff --git a/src/unix/devices.h b/src/unix/devices.h
new file mode 100644
index 0000000..5461e2c
--- /dev/null
+++ b/src/unix/devices.h
@@ -0,0 +1,172 @@
+#ifndef __DEVICES_H_
+#define __DEVICES_H_
+
+#ifdef __DEVICES_C_
+#define EXTERN
+#else
+#define EXTERN extern
+#endif
+
+#define JOY 6
+#define JOY_BUTTONS 16
+#define JOY_AXIS 8
+#define JOY_DIRS 2
+#define JOY_LIST_AXIS_ENTRIES (JOY_AXIS * JOY_DIRS)
+#define JOY_LIST_TOTAL_ENTRIES (JOY_LIST_AXIS_ENTRIES + JOY_BUTTONS)
+#define JOY_LIST_LEN (JOY * JOY_LIST_TOTAL_ENTRIES)
+#define JOY_NAME_LEN 20
+
+#ifndef USE_XINPUT_DEVICES
+  /* only one mouse for now */
+  #define MOUSE 1
+#else
+  /* now we have 4 */
+  #define MOUSE 4
+#endif
+#define MOUSE_BUTTONS 8
+#define MOUSE_AXIS 8
+
+/* now axis entries in the mouse_list, these are get through another way,
+   like the analog joy-values */
+#define MOUSE_LIST_TOTAL_ENTRIES MOUSE_BUTTONS
+#define MOUSE_LIST_LEN (MOUSE * MOUSE_LIST_TOTAL_ENTRIES)
+
+
+#define JOY_BUTTON_CODE(joy, button) \
+ (joy * JOY_LIST_TOTAL_ENTRIES + JOY_LIST_AXIS_ENTRIES + button)
+
+#define MOUSE_BUTTON_CODE(mouse, button) \
+ (JOY_LIST_LEN + mouse * MOUSE_LIST_TOTAL_ENTRIES + button)
+  
+#define JOY_AXIS_CODE(joy, axis, dir) \
+ (joy * JOY_LIST_TOTAL_ENTRIES + JOY_DIRS * axis + dir)
+
+/* mouse doesn't support axis this way */
+ 
+#define JOY_GET_JOY(code) \
+ (code / JOY_LIST_TOTAL_ENTRIES)
+
+#define MOUSE_GET_MOUSE(code) \
+ ((code - JOY_LIST_LEN) / MOUSE_LIST_TOTAL_ENTRIES)
+ 
+#define JOY_IS_AXIS(code) \
+ ((code < JOY_LIST_LEN) && \
+  ((code % JOY_LIST_TOTAL_ENTRIES) <  JOY_LIST_AXIS_ENTRIES))
+
+
+  
+/* mouse doesn't support axis */
+
+#define JOY_IS_BUTTON(code) \
+ ((code < JOY_LIST_LEN) && \
+  (((code % JOY_LIST_TOTAL_ENTRIES) >= JOY_LIST_AXIS_ENTRIES))
+
+#define MOUSE_IS_BUTTON(code) \
+ (code >= JOY_LIST_LEN) 
+
+#define JOY_GET_AXIS(code) \
+ ((code % JOY_LIST_TOTAL_ENTRIES) / JOY_DIRS)
+ 
+/* mouse doesn't support axis this way */
+ 
+#define JOY_GET_DIR(code) \
+ ((code % JOY_LIST_TOTAL_ENTRIES) % JOY_DIRS)
+ 
+/* mouse doesn't support axis this way */
+
+#define JOY_GET_BUTTON(code) \
+ ((code % JOY_LIST_TOTAL_ENTRIES) -  JOY_LIST_AXIS_ENTRIES)
+
+#define MOUSE_GET_BUTTON(code) \
+ ((code - JOY_LIST_LEN) % MOUSE_LIST_TOTAL_ENTRIES)
+
+enum { JOY_NONE, JOY_I386, JOY_PAD, JOY_X11, JOY_I386NEW, JOY_USB, JOY_PS2, JOY_SDL };
+
+/*** variables ***/
+
+struct axisdata_struct
+{
+   /* current value */
+   int val;
+   /* calibration data */
+   int min;
+   int center;
+   int max;
+   /* boolean values */
+   int dirs[JOY_DIRS];
+};
+
+struct joydata_struct
+{
+   int fd;
+   int num_axis;
+   int num_buttons;
+   struct axisdata_struct axis[JOY_AXIS];
+   int buttons[JOY_BUTTONS];
+};
+
+struct mousedata_struct
+{
+   int buttons[MOUSE_BUTTONS];
+   int deltas[MOUSE_AXIS];
+};
+
+struct rapidfire_struct
+{
+   int setting[10];
+   int status[10];
+   int enable;
+   int ctrl_button;
+   int ctrl_prev_status;
+};
+
+EXTERN struct joydata_struct joy_data[JOY];
+EXTERN struct mousedata_struct mouse_data[MOUSE];
+EXTERN struct rapidfire_struct rapidfire_data[4];
+EXTERN void (*joy_poll_func) (void);
+EXTERN int joytype;
+EXTERN int is_usb_ps_gamepad;
+EXTERN int rapidfire_enable;
+
+extern struct rc_option joy_i386_opts[];
+extern struct rc_option joy_pad_opts[];
+extern struct rc_option joy_x11_opts[];
+extern struct rc_option joy_usb_opts[];
+extern struct rc_option joy_ps2_opts[];
+
+#ifdef USE_XINPUT_DEVICES
+#include "joystick-drivers/XInputDevices.h"
+#endif
+
+/*** prototypes ***/
+void joy_evaluate_moves(void);
+void joy_i386_init(void);
+void joy_pad_init(void);
+void joy_x11_init(void);
+void joy_usb_init(void);
+void joy_ps2_init(void);
+void joy_ps2_exit(void);
+void joy_SDL_init(void);
+#undef EXTERN
+
+/*
+ * sdevaux 02/2003 : JOY macros copied from windows mame source code
+ *          but don't know if InputCode data type is strictely equivalent
+ */ 
+/* macros for building/mapping keycodes */
+#define JOYCODE(joy, type, index)	((index) | ((type) << 8) | ((joy) << 12))
+#define JOYINDEX(joycode)			((joycode) & 0xff)
+#define JOYTYPE(joycode)			(((joycode) >> 8) & 0xf)
+#define JOYNUM(joycode)				(((joycode) >> 12) & 0xf)
+
+/* joystick types */
+#define JOYTYPE_AXIS_NEG			0
+#define JOYTYPE_AXIS_POS			1
+#define JOYTYPE_POV_UP				2
+#define JOYTYPE_POV_DOWN			3
+#define JOYTYPE_POV_LEFT			4
+#define JOYTYPE_POV_RIGHT			5
+#define JOYTYPE_BUTTON				6
+#define JOYTYPE_MOUSEBUTTON			7
+
+#endif
diff --git a/src/unix/dirio.c b/src/unix/dirio.c
new file mode 100644
index 0000000..a7c12ec
--- /dev/null
+++ b/src/unix/dirio.c
@@ -0,0 +1,268 @@
+#include "xmame.h"
+#include <stdarg.h>
+#include <unistd.h>
+#include <dirent.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+#include <zlib.h>
+
+#ifdef BSD43 /* old style directory handling */
+#include <sys/types.h>
+#include <sys/dir.h>
+#define dirent direct
+#endif
+
+/* #define FILEIO_DEBUG */
+#define MAXPATHC 20 /* at most 20 path entries */
+#define MAXPATHL BUF_SIZE /* at most BUF_SIZE-1 character path length */
+ 
+#ifdef MESS
+int osd_num_devices(void)
+{
+   return 0; /* unix doesn't have devices ( a device = a: b: etc) */
+}
+
+void osd_change_device(const char *device)
+{
+}
+
+const char *osd_get_device_name(int idx)
+{
+   return "";
+}
+
+
+struct osd_dir {
+   DIR *dir;
+   char dirname[MAXPATHL];
+   char filemask[MAXPATHL];
+};
+
+void *osd_dir_open(const char *dirname, const char *filemask)
+{
+  struct osd_dir *dir = NULL;
+  
+  if(!(dir = calloc(1, sizeof(struct osd_dir))))
+     return NULL;
+  
+  if(!(dir->dir = opendir(dirname)))
+  {
+     osd_dir_close(dir);
+     return NULL;
+  }
+  
+  strncpy(dir->dirname,  dirname,  MAXPATHL-1);
+  strncpy(dir->filemask, filemask, MAXPATHL-1);
+  
+  return dir;
+}
+
+void osd_dir_close(void *dir)
+{
+  struct osd_dir *my_dir = dir;
+  
+  if(my_dir->dir)
+    closedir(my_dir->dir);
+  
+  free(my_dir);
+}
+
+#ifndef __QNXNTO__
+static int fnmatch(const char *f1, const char *f2)
+{
+	while (*f1 && *f2)
+	{
+		if (*f1 == '*')
+		{
+			/* asterisk is not the last character? */
+			if (f1[1])
+			{
+				/* skip until first occurance of the character after the asterisk */
+                while (*f2 && toupper(f1[1]) != toupper(*f2))
+					f2++;
+				/* skip repetitions of the character after the asterisk */
+				while (*f2 && toupper(f1[1]) == toupper(f2[1]))
+					f2++;
+			}
+			else
+			{
+				/* skip until end of string */
+                while (*f2)
+					f2++;
+			}
+        }
+		else
+		if (*f1 == '?')
+		{
+			/* skip one character */
+            f2++;
+		}
+		else
+		{
+			/* mismatch? */
+            if (toupper(*f1) != toupper(*f2))
+				return 0;
+            /* skip one character */
+			f2++;
+		}
+		/* skip mask */
+        f1++;
+	}
+	/* no match if anything is left */
+	if (*f1 || *f2)
+		return 0;
+    return 1;
+}
+#endif
+
+int osd_dir_get_entry(void *dir, char *name, int namelength, int *is_dir)
+{
+   struct osd_dir *my_dir = dir;
+   struct dirent *d = NULL;
+   struct stat stat_buf;
+   char buf[MAXPATHL];
+    
+   *is_dir = 0;
+  
+   while((d = readdir(my_dir->dir)))
+   {
+      snprintf(buf, MAXPATHL, "%s/%s", my_dir->dirname, d->d_name);
+      
+      /* stat it */
+      if(stat(buf, &stat_buf))
+         continue;
+         
+      /* check that it is a dir or matches our filemask */
+#ifdef BSD43
+      if(S_IFDIR & stat_buf.st_mode)
+#else
+      if(S_ISDIR(stat_buf.st_mode))
+#endif
+      {
+         *is_dir = 1;
+      }
+#ifndef __QNXNTO__
+      else if (!fnmatch(my_dir->filemask, d->d_name))
+#else
+      else if (!fnmatch(my_dir->filemask, d->d_name,0))   
+#endif
+         continue;
+      
+      strncpy(name, d->d_name, namelength-1);
+      name[namelength-1] = 0;
+      return strlen(name);
+  }
+  
+  return 0;
+}
+
+void osd_change_directory(const char *directory)
+{
+   chdir(directory);
+}
+
+const char *osd_get_cwd(void)
+{
+   static char cwd[MAXPATHL + 1];
+   
+#ifdef BSD43
+   getwd(cwd);
+#else
+   getcwd(cwd, MAXPATHL);
+#endif
+   strcat(cwd, "/");
+   return cwd;
+}
+
+/*============================================================ */
+/*	osd_dirname */
+/*============================================================ */
+
+char *osd_dirname(const char *filename)
+{
+	char *dirname;
+	char *c;
+
+	/* NULL begets NULL */
+	if (!filename)
+		return NULL;
+
+	/* allocate space for it */
+	dirname = malloc(strlen(filename) + 1);
+	if (!dirname)
+	{
+		fprintf(stderr_file, "error: malloc failed in osd_dirname\n");
+		return NULL;
+	}
+
+	/* copy in the name */
+	strcpy(dirname, filename);
+
+	/* search backward for a slash */
+	for (c = dirname + strlen(dirname) - 1; c >= dirname; c--)
+		if (*c == '\\' || *c == '/')
+		{
+			/* found it: NULL terminate and return */
+			*(c + 1) = 0;
+			return dirname;
+		}
+
+	/* otherwise, return an empty string */
+	dirname[0] = 0;
+	return dirname;
+}
+
+/*============================================================ */
+/*	osd_basename */
+/*============================================================ */
+
+char *osd_basename(char *filename)
+{
+	char *c;
+
+	/* NULL begets NULL */
+	if (!filename)
+		return NULL;
+
+	/* start at the end and return when we hit a slash */
+	for (c = filename + strlen(filename) - 1; c >= filename; c--)
+		if (*c == '\\' || *c == '/')
+			return c + 1;
+
+	/* otherwise, return the whole thing */
+	return filename;
+}
+
+/*============================================================ */
+/*	osd_path_separator */
+/*============================================================ */
+
+const char *osd_path_separator(void)
+{
+	return "/";
+}
+
+/*============================================================ */
+/*	osd_is_path_separator */
+/*============================================================ */
+
+int osd_is_path_separator(char ch)
+{
+	return (ch == '\\') || (ch == '/');
+}
+
+/*============================================================ */
+/*	osd_is_absolute_path */
+/*============================================================ */
+int osd_is_absolute_path(const char *path)
+{
+	int result;
+
+	if ((path[0] == '/') || (path[0] == '/'))
+		result = 1;
+	else
+		result = 0;
+	return result;
+}
+
+#endif
diff --git a/src/unix/dirty.c b/src/unix/dirty.c
new file mode 100644
index 0000000..4a4c550
--- /dev/null
+++ b/src/unix/dirty.c
@@ -0,0 +1,107 @@
+#include "xmame.h"
+#include "driver.h"
+
+#ifdef xgl
+        extern void gl_dirty_init(void);
+        extern void gl_dirty_close(void);
+	extern void gl_mark_dirty(int x1, int y1, int x2, int y2);
+#endif
+
+/* hmm no more way to find out what the width and height of the screenbitmap
+   are, so just define WIDTH and HEIGHT to be 2048 */
+
+#define WIDTH  (2048 / 8)
+#define HEIGHT (2048 / 8)
+
+int osd_dirty_init(void)
+{
+   dirty_lines      = NULL;
+   dirty_blocks     = NULL;
+   
+   /* vector games always need a dirty array */
+   if (use_dirty || (Machine->drv->video_attributes & VIDEO_TYPE_VECTOR))
+   {
+      int i;
+      
+      dirty_lines = malloc(HEIGHT);
+      if (!dirty_lines)
+      {
+         fprintf(stderr_file, "Error: couldn't allocate mem\n");
+         return OSD_NOT_OK;
+      }
+      memset(dirty_lines, 0, HEIGHT);
+   	
+      dirty_blocks = malloc(HEIGHT * sizeof(char *));
+      if (!dirty_blocks)
+      {
+         free(dirty_lines); dirty_lines = NULL;
+         fprintf(stderr_file, "Error: couldn't allocate mem\n");
+         return OSD_NOT_OK;
+      }
+   	   
+      for (i=0; i< HEIGHT; i++)
+      {
+         dirty_blocks[i] = malloc(WIDTH);
+         if (!dirty_blocks[i]) break;
+         memset(dirty_blocks[i], 0, WIDTH);
+      }
+      if (i!=HEIGHT)
+      { 
+         fprintf(stderr_file, "Error: couldn't allocate mem\n");
+         for(;i>=0;i--) free(dirty_blocks[i]);
+         free(dirty_blocks); dirty_blocks = NULL;
+         free(dirty_lines);  dirty_lines  = NULL;
+         return OSD_NOT_OK;
+      }
+   }
+   #ifdef xgl
+      if(use_dirty) gl_dirty_init();
+   #endif
+   
+   return OSD_OK;
+}
+
+void osd_dirty_close(void)
+{
+   /* vector games always need a dirty array */
+   if (use_dirty || (Machine->drv->video_attributes & VIDEO_TYPE_VECTOR))
+   {
+      int i;
+      
+      if (!dirty_blocks) return;
+      
+      for (i=0; i< HEIGHT; i++) free(dirty_blocks[i]);
+      free (dirty_blocks);
+      free (dirty_lines);
+   }
+   #ifdef xgl
+      if(use_dirty) gl_dirty_close();
+   #endif
+}
+
+void osd_mark_dirty(int x1, int y1, int x2, int y2)
+{
+	int y,x;
+	if (use_dirty)
+	{
+	   if (x1 < visual.min_x) x1=visual.min_x;
+	   if (y1 < visual.min_y) y1=visual.min_y;
+	   if (x2 > visual.max_x) x2=visual.max_x;
+	   if (y2 > visual.max_y) y2=visual.max_y;
+	   x1 >>= 3;
+	   y1 >>= 3;
+	   x2 = (x2 + 8) >> 3;
+	   y2 = (y2 + 8) >> 3;
+ 	   for (y=y1; y<y2; y++)
+	   {
+	      dirty_lines[y] = 1;
+	      for(x=x1; x<x2; x++)
+              {
+	         dirty_blocks[y][x] = 1;
+	      }
+	   }
+           #ifdef xgl
+	       gl_mark_dirty(x1, y1, x2, y2);
+           #endif
+	}
+}
diff --git a/src/unix/doc/AIX-install-notes b/src/unix/doc/AIX-install-notes
new file mode 100644
index 0000000..4ff55e3
--- /dev/null
+++ b/src/unix/doc/AIX-install-notes
@@ -0,0 +1,49 @@
+Install Notes for AIX
+===========================================
+
+I started out with a bare machine and this is what I had to do to get it
+running:
+
+1.) Installed AIX 4.3.3 on a 7043-150 Model Machine
+
+    It should work on most machines without a problem
+
+2.) Installed all the bos.adt filesets from the operating system cd's
+
+   I was missing the 'as' function and this cleared it up.
+
+3.) Installed gcc 2.95.3.0 (Available from http://www.bull.de/pub/)
+
+   It unpacks as a installp package so you can install from 'smit'
+
+4.) Installed gnu-make 3.79.1.0  (Available from http://www.bull.de/pub/)
+
+   Make sure you are running this make and not the AIX one! (Maybe call it
+gmake?)
+
+5.) Added  /usr/include to my path directory to help find files
+
+6.) Installed the X11.adt filesets from the operating system cd's
+
+7.) Installed the X11.compat filesets from the operating system cd's
+
+8.) Installed the UMS filesets from the 4.3.3 Bonus Pack Cd's
+
+9). Had to use these lines in the makefile:
+
+     changed 'CFLAGS    = -O -Wall'    into  ' CFLAGS    = -O -Wall
+-mminimal-toc'
+     to kill off a TOC error when linking
+     used the available 'MY_CPU = risc' line
+     used the available 'ARCH  = aix' line
+     the X11 libraries are here for AIX:
+     X11INC                = -I/usr/include/X11
+            X11LIB                = -L/usr/lib/X11
+
+9) For some reason I had to edit the nes_def.h file and commented out the
+INT=8, INT=16 and INT=32
+    lines because it would cough up when compiling.
+
+10) Used  make -f makefile.unix to compile it up.
+
+11) Followed the rest of the readme for setup info
diff --git a/src/unix/doc/changes.opengl b/src/unix/doc/changes.opengl
new file mode 100644
index 0000000..73757bd
--- /dev/null
+++ b/src/unix/doc/changes.opengl
@@ -0,0 +1,558 @@
+GLMame v 0.94 - the_peace_version - Mame Display Driver
+=======================================================
+
+Sven Goethel
+http://www.jausoft.com
+sgoethel@jausoft.com
+
+MAME License
+
+Based upon GLmame v0.6 driver for xmame, written by Mike Oliphant
+
+peace, sven
+
+  22/January/2003 GLMame OpenGL-Display-Driver Version 0.94
+  ==========================================================
+  	o affects xmame 0.65.1 + Sugitani's Blit-Patch !
+		- so patch after you have patched the blit-patch on 0.65.1 !
+	
+	o all rotations are done within opengl, 
+	  disabled them in unix/video.c (-> unix/video-drivers/blit*.h)
+	  	- via "#ifndef xgl"
+		- via "int blit_hardware_rotation=1" 
+
+	o all rotations does work now, even in cabinet mode ;-)
+
+	o cabinet screen vector specification:
+		the <model>.cab file contains the screen section for the mame
+		gameplane !
+
+		the vectrices must follow the following order:
+			1.) left  - top
+			2.) right - top
+			3.) right - bottom
+			4.) left  - bottom
+		where:
+			left   < right
+			bottom < top
+
+		this order is because of historical reason,
+		and is reordered, i.e. reversed, within the glcab.c code.
+
+	o complete rearranged cabinet screen calculations
+		- fixes game screen offset and aspect-ratio
+		- float -> double
+		- much better documentation !
+
+	o some cabinet bugfixes ..
+
+	o some other bugfixes ;-)
+
+	o todo:
+		- fix fullscreen bug, while toggling cabinet mode
+
+		- try to find a 16bpp solution for opengl color tables,
+		  so no more blit's are needed ... (nvidia does not allow ..)
+
+
+  01/December/2001 GLMame OpenGL-Display-Driver Version 0.92
+  =================================================================
+  	o clean up: glvec.c again 
+
+	o added 2 new options for vector games:
+
+	  -[no]glantialiasvec, -[no]glaav , default true !
+	   Enable/disable vector antialiasing
+	   (otherwise 16bpp opengl displays looks kinda bad ..)
+
+	  -[no]gldrawbitmapvec, -[no]glbitmapv, default true
+	   Enable/Disable the drawing of the bitmap only for vector games - speedup
+	   
+	   (remember, you can also toggle this via RALT-O)
+
+	o  added vector flickering ;-)
+
+	o because of the buggy dirty-code,
+	  i recommend you use -nodirty for opengl as default ..
+
+
+  27/November/2001 GLMame OpenGL-Display-Driver Version 0.91
+  =================================================================
+  	o clean up: glvec.c, glgen.c 
+
+	o removed gldirty.[ch]
+	  added functionality to glgen.c
+
+	o added new dirty strategie to glgen's texture handling ..
+	  as for mplayer ;-)
+	  
+	  WARNING: still needs -nodirty flag for some games,
+	  like atetris !
+
+	o still don't know how to handle effect's .. ! HELP !
+
+	o WARNING: modified src/cpu/v60/v60.c to being compiled
+	  under PPC architecture !
+
+  18/November/2001 GLMame OpenGL-Display-Driver Version 0.90
+  =================================================================
+        - true color vector game bug (all vector game colors are true since 0.5x.y)
+
+        - using blit.h for 16bpp colorIndex mapping only,
+          e.g. true color games don't need it .. (xexex, shocking, ..)
+          -> useColorBlitter !
+
+        - added an own texture memory with BITMAP_SAFETY's,
+          if using useColorBlitter !
+
+        - removed color bpp "guessing" - this fixes some neogeo problems ..
+
+  20/August/2001 GLMame OpenGL-Display-Driver Version 0.88
+  =================================================================
+  	o changed to the new png usage
+
+	o INFO: I kept the 8bpp color-table stuff for now,
+	        but the base mame 0.53 does not support it anymore !
+
+  13/July/2001 GLMame   OpenGL-Display-Driver Version 0.87
+  =================================================================
+	o tested xmam.xgl with LinuxPPC 
+         (Powerbook) + ATI-Rage128 + XFree86 4.1 + DRI 
+	  ! SUCCESS !
+
+	  Use options: "-noglext78 -noglaa" or "-bpp 16 -noglaa",
+	  where the latter is a bit slower for me (about 5fps)
+
+	o changed GLboolean -> int,
+	  because of Linux-PPC problems ..
+
+  05/May/2001 GLMame   OpenGL-Display-Driver Version 0.86
+  =================================================================
+  	o Added option:
+		- glres <Xres>x<Yres>
+
+          Always scale games to XresxYres, 
+	  keeping their aspect ratio. This overrides the scale options.
+
+	  This is e.g. necessary, if you run xmame.xgl under 
+	  a Vodoo1 gfx card, which only allows you a 640x480 fullscreen
+	  "window" ;-) - but your desktop runs under a different resolution.
+
+  04/April/2001 GLMame   OpenGL-Display-Driver Version 0.85
+  =================================================================
+  	o recreated general purpose opengl modules:
+		- gltool.[ch]
+		- glxtool.[ch]
+		- glcaps.[ch]
+	  these are now licensed under the LGPL _and_ the MAME license !
+	  (I am the creator and copyright holder .. so ..)
+
+	o fixed glxtool modules
+		- segmentation fault, due to NULL pix pointer
+		- bug fixed fall back method ..
+		- extended finding appropiate visual, falling back ..
+
+        o Last but not least, you can use gltool's feature of
+          specifying the GL/GLU library names by the systems
+          environment variables:
+                GLTOOL_USE_GLLIB        - OpenGL library name
+                GLTOOL_USE_GLULIB       - GLU    library name
+          these environment variables does _always_ overrides
+          any given ones !
+
+  01/April/2001 GLMame   OpenGL-Display-Driver Version 0.84
+  =================================================================
+	o fixed vector module
+		- flickering and "now show" is now avoided,
+		  e.g. in mhavoc (flicker), warrior(no show), 
+		          spacewar(no show), ...
+
+  29/March/2001 GLMame   OpenGL-Display-Driver Version 0.83
+  =================================================================
+	o fixed cmdline options ..
+
+	o fixed documentation
+
+	o fixed info printouts (-DGLDEBUG)
+
+  28/March/2001 GLMame   OpenGL-Display-Driver Version 0.82
+  =================================================================
+  	o Fixed vector module
+	  - resize, and a little new arrangement to fix begin/end
+	    problems
+
+	o new cmdline options ..
+
+  28/March/2001 GLMame   OpenGL-Display-Driver Version 0.81
+  =================================================================
+  	o Fixed vector module
+
+	  - now you can play vector games with 16bpp either,
+	    but do not complain the speed ;-)
+
+	    You can toggle drawing the overlayed bitmaps, 
+	    while pressing "RALT-O"
+	  
+
+  27/March/2001 GLMame   OpenGL-Display-Driver Version 0.80
+  =================================================================
+  	o Added 15bpp & 32bpp true color support
+		- Both modes uses std. opengl direct texture mapping
+		- You can additionally add a blitter run for nonsense,
+		  Via cmdline option "-glblit"
+
+	  Let me say: "Yeahh... "
+	  This easy solution you can follow in glgen.c costs me nerves ..
+	  But you need OpenGL >= 1.2, well .. of course ..
+
+	o Added 16bpp color index mode
+		- This modes uses a blitter run, to 
+		  exchange the indices <-> colors from lookup table
+		  within the opengl texture.
+		  We only need it at the original size.
+
+		- If your graphic's card opengl colortable mapping
+		  does not work nice,
+		  you can now call xgl with "-bpp 16", and the blitter
+		  code is used for color mapping !
+
+		  Everything else (zoom, filter, cabinet) is still
+		  done by opengl.
+
+	  After getting crazy about this color mode
+	  (mk ran without indices lookup .. with _nearly_ correct colors),
+	  i looked at SDL.c and took the blitter :-), for the conversion.
+
+	  By the way, .. it was impossible to use OpenGL's colormapping
+	  for colortables > 256, neither with Mesa 3.4 nor with nvidia.
+	  So this old mode is reserved for the best ever games ;-)
+	  		      pacman, mr do, ..
+
+	o Added opengl snapshoot via std. F12 (-> png)
+	  But be aware, the current window size is being used ;-)
+	  with RGB mode !
+
+	  If you complain on colors now, 
+	  make a screenshot.
+	  But I am a bit colorblind (red/green),
+	  so don't hit me :-))
+	  (yes, i have tested the rgb(a) mapping via the colormaps ..)
+
+	o The fullscreen (R-ALT+F) key does now toggle
+	  between full- and windowscreen.
+
+	o Added a startup "hack" within unix/main.c,
+	  where i try to find the games nicest 
+	  full color - low color depth size.
+	  Be aware, the games do not start at 8bpp now,
+	  if they are colorfull.
+
+	  This only works, if you do not use the "-bpp" cmdline option
+
+	o Many bugfixes and cleanup,
+	  so new bugs are in :-))
+
+
+  23/March/2001 GLMame   OpenGL-Display-Driver Version 0.74
+  =================================================================
+  	o Bugfixed the cmdline argument handling "-cabinet"
+		- previously, the argument was simply ignored ..
+		- misc cabinet bugfixes ..
+
+	o Added new elements for the cabinet syntax (cabv1.1): 
+		- pointsize <float> (-> glPointSize(<float>) )
+		- begin points      (-> glBegin(GL_POINTS) )
+
+	o Created and added my cabinet (glmamejau) and 
+	  use it as the default ..
+
+	  You can now simply add your 256x64 jpeg banner
+	  to your mame cabinet :-)
+	
+	o updated sgml documentation ..
+
+	o switched back frm "glColorSubTableEXT" to "glColorTableEXT",
+	  may be this can help somebody .. (i do not think so)
+
+  22/March/2001 GLMame   OpenGL-Display-Driver Version 0.73
+  =================================================================
+  	o Updated the doc/xmame-doc.sgml root documentation,
+	  to respect the new xmame.xgl
+
+	  Added a little script, named makedoc.sh, to produce
+	  all the destination documentation !
+
+  	o Added runtime toggle's for opengl options with keyboard input
+
+	  KEYCODE_RALT + KEYCODE_A        := toggle antialias       (vector)
+	  KEYCODE_RALT + KEYCODE_B        := toggle bilinear        (raster)
+	  KEYCODE_RALT + KEYCODE_C        := toggle cabinet mode    (both)
+	  KEYCODE_RALT + KEYCODE_F        := switch to fullscreen   (both)
+	  KEYCODE_RALT + KEYCODE_O        := toggle draw-bitmap     (both)
+	  KEYCODE_RALT + KEYCODE_T        := toggle phosphor trails (vector)
+	  KEYCODE_RALT + KEYCODE_PLUS_PAD := incr. beam size        (vector)
+	  KEYCODE_RALT + KEYCODE_MINUS_PAD:= decr. beam size        (vector)
+
+	o The OpenGL (xgl) cmdline options are (unchanged since 0.71):
+
+  *** OpenGL Related ***
+  -[no]fullscreen                Start fullscreen
+  -[no]gldblbuffer               Enable/disable double buffering
+  -gltexture_size <int>          Force the max width and height of one texture
+                                 segment (default: autosize)
+  -[no]glext                     Force the usage of gl extensions (default:
+                                 auto)
+  -[no]glbilinear / -[no]glbilin Enable/disable bilinear filtering
+  -glbeam <float>                Set the beam size for vector games
+  -[no]glalphablending /         Enable/disable alphablending (default: try
+  -[no]glalpha                   alphablending)
+  -[no]glantialias / -[no]glaa   Enable/disable antialiasing
+  -gllod <int>                   level of bitmap-texture detail
+  -gllibname / -gllib <string>   Choose the dynamically loaded OpenGL Library
+                                 (default libGL.so)
+  -glulibname / -glulib <string> Choose the dynamically loaded GLU Library
+                                 (default libGLU.so)
+  -[no]cabview                   Start/ don't start in cabinet view mode
+  -cabinet <string>              Specify which cabinet model to use
+
+  22/March/2001 GLMame   OpenGL-Display-Driver Version 0.72
+  =================================================================
+  	o Added a fallback visual attribute fetch algo
+	  this is done with (a modified gl4java module)
+	  the new glxtool.c's functions !
+
+	  This is important to fallback to lower visual capabilites ..
+
+	o Now the glcontext is bound to the window !!
+	  .. not the root window or NULL :-)
+
+
+  21/March/2001 GLMame   OpenGL-Display-Driver Version 0.71
+  =================================================================
+  	o Fetching all GL, GLU and GLX functions dynamically
+	  	- I use a compiler for these stubs, 
+		  which I have implemented for the project 
+		  "OpenGL for Java" (gl4java)
+
+	o Choosing the GL and GLU library at runtime (commandline argument)
+
+	o Some misc. bugfixes ..
+
+  	o Changed this file from 
+	  "doc/ChangeLog-GLMame.txt" to "doc/changes.opengl"
+
+  	o Alpha is used for default
+
+	o Alpha & db-buffer is checked
+
+	o Split texture work's now,
+	  e.g. you have an vodoo card with max texture size = 256,
+	  so more than one textures must be used, if bitmap > 256 !
+
+	O The non OpenGL Extension Mode works now (is tested) 
+
+	o Changed runtime options
+
+	o Changed compiler options
+		- only if the compiler define 'GLDEBUG'
+		  is set, NDEBUG is not set ;-)
+
+		  if you want to have some opengl related debug output,
+		  recompile with 'GLDEBUG' !
+
+  	o Vector:
+		- onscreen (osd) menu cleanup
+		- fixed LINE_WIDTH == 0 (e.g. tacscan ..)
+		- now using (runtime config)
+			- intensity & gamma
+
+	o Compiler options:
+		No more used:
+			-GLLIBS= -lGL -lGLU  (!! important !!)
+			-DNVIDIA 
+			-DUTAH_GLX
+		New:
+			-GLLIBS= -ldl (!! important !!)
+			-DGLDEBUG
+				Enables (more) OpenGL related (debug) info's,
+				included runtime gl-error check's ..
+
+
+  12/March/2001 GLMame   OpenGL-Display-Driver Version 0.7
+  =================================================================
+
+  General Changes
+  	
+	o Merge back to xmame
+		- is used xmame 0.37b12.1pre3
+
+	o Cleanup
+
+	o All OpenGL specific changes i have done for the GLMame32 version
+	  are present within this version !
+
+	  - no memcpy
+	  - direct mame bitmap usage
+	  - eff. color buffer
+	  - dynamical query of
+	  	- glColorTableEXT
+		- texture size
+	  - many more .. (see below)
+
+  ToDo (?!):
+
+  	o fix vectorgame's gl display
+		- some bitmaps, etc. are not shown
+
+	o if more than one texture is used for the bitmap presentation,
+	  only the very first is rendered ...
+	  i don't now what's the damn problem, i have tested it a long time.
+	  please help ..
+
+	  usually today's gfx cards does support big enough texture sizes
+
+	  you can test this bug e.g. with the option:
+	  	xmame.xgl -gltexture_size 128
+	  where the texture size is forced to 128x128, so more than one
+	  texture is needed ..
+
+	o add png save of the gl rendere frame
+
+	o add mac port ?
+
+	o backport to win32 (partial included -> cleanup) ..
+
+  Info:
+
+  	o for debug purpose, just edit glmame.h and undef NDEBUG
+	  in this case many info printf's are shown up :-)
+
+  20/March/2000 GLMame32 Version 36rc2 OpenGL-Display-AddOn 1.3beta
+  ==================================================================
+
+  General Changes
+
+	o Taken Windows-Source-Base from Mame32-36b16 !
+
+	o Taken MAME Source Mame 36rc2 !
+
+  Mame32 integration
+
+	o Now GLMame32 just adds the OpenGL display driver !
+
+	o Vector Games are support for OpenGL only in this Version !
+
+	o the '#define xgl' exists everywhere in the source,
+	  except of the Ressource Files :-(
+
+  OpenGL Changes
+
+	o Because of the lower changes, 
+          the performance should be increased ...
+
+	o Now useing normal coordinates [0.0-1.0].
+
+	o The vector implementation is bug-fixed,
+          and is able to show the bitmap for options etc.
+	  The artwork bitmap still does not work ... but is coming !
+	  The Fullscreen mode for vectors has the correct aspect-ration now !
+
+	o The color allocation is bug-fixed,
+          so the "disclaimer" where you have to say OK the first time
+	  is viewabel !
+	  Also the color sheme should accept high color games now ...
+
+
+  15/June/1999 GLMame32 Version 35rc1 OpenGL-Display-AddOn 1.2
+  ============================================================
+
+  General Changes
+
+	o Taken Windows-Source-Base from Mame32-35b13 !
+
+	o Taken MAME Source Mame 35rc1
+
+  Mame32 integration
+
+	o Now GLMame32 is compiled with MSVC 6.0
+
+	o Now GLMame32 just adds the OpenGL display driver,
+	  - the others are still available !
+	  - you can choose OpenGL within the properties.advanced dialog-box.
+
+	o The following values are transparent to the main Mame32
+	  and are saved into the config-file:
+		alpha, gamma, OpenGL-Usage, automatic-fps, skip-fps,
+		fullscreen
+
+	o osd_pause is implemented
+
+	o the auto-pause mechanism has changed a bit (implementation).
+
+	o the '#define xgl' exists sometimes in the source,
+          but in a way of hurry - it is not used consitency.
+
+	o the opengl-part supports png-files, but just the
+	  poor mame-bitmap quality :-( yet !
+
+  OpenGL Changes
+
+	o getting PIXELFORMAT with depth 16 bits as default
+
+	o IF alphablending == FALSE
+		- Only RGB rendering is done, the Alpha-Channel is dropped !
+		- Alpha will modify the RGB intensity !
+
+	o The maximal texture-size is tested and used,
+	  so the bitmap may be displayed within more than one
+	  texture.
+	  This is a must for OpenGL hardware with a restricted texture size !
+	  The texture-size of each testure is equal, but only the 
+	  viewable part is watchable.
+	  The width and height is tested in a way, 
+	  so they can be different.
+	  The test algorythm tests till the texture-proxy allows
+	  the settings :-)
+
+	o The maximal texture width and height can be forced to a spec. value !
+	  Of course the used value is adapted to 2**n=size :-) !
+
+	o the opengl-part supports png-files, but just the
+	  poor mame-bitmap quality :-( yet !
+
+	o while setting properties.misc.error_log to true, 
+	  you can read the file 'glmame32_stderr.log' for information
+	  about some opengl-metrics and the opengl-vendor !
+	  The log file catches the info of the last game-run !
+
+
+  15/May/1999 GLMame32 Version 35b12 OpenGL-Display-Only 1.1
+  ===========================================================
+
+	o Using the original bitmap in ONE texture-buffer !
+		- So the *_create_display and *_new_bitmap is patched !
+		- Using the true view size, to update the texture
+
+	o if the EXT functions is not their, the other one works !
+	  - The non EXT function for Color-Index works,
+		but - of course - it is _very_ slow !
+	  - The non EXT function for color index can be used,
+		while toggeling the flag in the GL-status dialog.
+		Be aware of broken OpenGL drivers ...
+		... the ELSA driver for Gloria L/MX frozes my NT-machine :-(,
+		so i use 3DLabs now (faster for Quake2 anyway ...).
+	  - The non EXT support works only from this version on !
+
+	o Using the true color number for the palette
+
+	o Using the right component size of the bitmap
+
+	o using the alpha values for brightness
+
+	o added win32 function to load the EXT functions !
+
+	o added snapshot support for:
+		- BMP (Win32 only)
+		- PPM (Win32 and all the others - now it works :)
+		- JPG (why not - but the quality is poor ..)
+
diff --git a/src/unix/doc/changes.unix b/src/unix/doc/changes.unix
new file mode 100644
index 0000000..6deb9fe
--- /dev/null
+++ b/src/unix/doc/changes.unix
@@ -0,0 +1,2107 @@
+Xmame history:
+
+Last Modified by Lawrence Gold (gold@aros.net)
+
+Release 0.74.1, 15 September 2003
+	- Everything from MAME 0.74 and MESS CVS.
+	- Reapplied David Mitchell's fix for the XInput inertial effect when 
+	  a mouse or spinner is used.  (Jake Stookey)
+	- Added support for controllor setup via "-ctrlr".  Note that "-hotrod"
+	  and "-hotrodse" have been replaced by "-ctrlr HotRod" and "-ctlrlr 
+	  HotRodSE".
+	- Added support for the Sun Forte 7 C compiler.  (Greg Menke)
+	- Added support for Mesa and Sun OpenGL on Solaris.  (Greg Menke)
+
+Release 0.72.1, 15 August 2003
+	- Everything from MAME 0.72 and MESS 0.72.
+	- The various effects enabled by -effect now work with rotation enabled.
+	  (Shyouzou Sugitani)
+	- The Xv target supports more effects.   (Shyouzou Sugitani)
+	- The rc parsing code displays more compact and readable error messages.
+	  (Andre Majorel)
+	- Xv windowed mode is now enabled with "-x11-mode 2" or "-x11 2", and 
+	  Xv fullscreen mode is enabled with "-x11-mode 3" or "-x11 3".  The 
+	  "-[no]xv" and "-fullscreen" switches are no longer available for X11 
+	  builds.
+	- Networking should work again.  I'd forgotten to change instances of 
+	  MAME_NET in src/unix to XMAME_NET in the 0.70.1 release.
+	- Added hotkey switching for Xv windowed mode via ALT + DEL and Xv 
+	  fullscreen mode via ALT + END.
+	- The xfx target should build again.
+	- Added -widescreen for Xv.  This shrinks the width of the output for 
+	  display on a widescreen TV.  (Per Wigren)
+
+Release 0.71.1, 19 July 2003
+	- Everything from MAME 0.71 and MESS 0.71.
+	- The include path for xmess now puts 'mess' before 'src' and 
+	  'src/includes'.  Fixes Bugzilla bug 435.
+	- The man page xmame.6 is much more up-to-date.  (Andrew Burton)
+	- Fixed errors reported for xmame.6 on a Debian Woody system.  (Alex 
+	  Kirk)
+
+Release 0.70.1, 18 June 2003
+	- Almost everything from MAME 0.70 and MESS 0.70.
+	- Changed an instance of MAME_DEBUG to DEBUG in unix.mak.  (Christopher
+	  Stone)
+	- Removed an obsolete (?) #include from osdutils.h that was interfering
+	  with MESS debug and IRIX builds.  Fixes Bugzilla bug #385.  (Frank 
+	  Everdij, Christopher Stone)
+	- Fixed some unused variable warnings when building non-debug versions
+	  of glgen.c and esound.c.
+	- Fixed the default values for -sysinfo_file and -messinfo_file, which
+	  were missing a '/'.
+	- Fixed the handling of leading zeros in the fractional part of a float
+	  in src/unix/snprintf.c.  (Chris Kirmse)
+	- Building 'tools' for xmess works again.
+	- Reduced the core changes needed to support networking, rapidfire, and
+	  IRIX-specific support.  Note that MAME_NET in the makefile has been 
+	  changed to XMAME_NET.
+	- The numeric keypad '*' key is now mapped correctly for SDL builds.
+	- The GLmame version string is now printed to stderr instead of stdout,
+	  as suggested by Matthias Saou.
+
+Release 0.69.1, 26 May 2003
+	- Almost everything from MAME 0.69.  The included MESS is version 0.68.
+	- Re-added Ben Collins' core change that adds support for extra mice.
+	- Rearranged the doc directory so that MAME- and MESS-specific files are
+	  in their own subdirectories.
+	- Reverted to using the original fronthlp.c (from 0.67.2) modified to 
+	  work with the 0.69 core.
+	- Building with the debugger enabled now works.  Note that in the 
+	  makefile, MAME_DEBUG is now just DEBUG.  (Christopher Stone)
+	- Fixed a logic bug in the XInput devices button-handling.  (Ben 
+	  Collins)
+	- Added UGCI coin/play support based on the libugci library for Linux's
+	  HIDDevice layer.  See http://www.phunnypharm.org/ugci/  (Ben Collins)
+	- Building the neomame target works again.  (Steve Behling)
+	- Made a tiny fix in fileio.c that allows specifying direct paths to 
+	  roms to work again; e.g., ./xmame.x11 ./moo.zip
+
+Release 0.68.1, 22 May 2003
+	- Almost everything from MAME 0.68 and MESS 0.68.
+	- Fixed the analog joystick support so that the Y-axis is recognized as
+	  analog.  (Sebastien Devaux)
+	- The command line is now parsed even if the display cannot be opened.
+	  (Christopher Stone, David Mitchell)
+	- Added support to the core for 4-button mice and 10-button joysticks.
+	  (Ben Collins)
+	- Removed superfluous checks for use_mouse in the OpenStep and SVGA 
+	  targets.  (Ben Collins)
+	- Fixed several problems and did a lot of cleanup in the XInput code, 
+	  especially for the output (e.g., showing detection status).  (Ben 
+	  Collins)
+	- Made a less intrusive change to fm.c which removes LFO support in 
+	  YM2610-only builds.  (Jarek Burczynski)
+	- Fixed a few problems with -listinfo output.  (Andrea Mazzoleni)
+
+Release 0.67.2, 12 April 2003
+	- Fixed a bug in unix.mak that caused libusb to be linked in when the 
+	  USB joystick driver was not enabled.
+	- The makefile should now handle the CC variable correctly if it's some
+	  variation of 'gcc', such as 'gcc-2.95.3'.
+	- The MIPS x86 dynamic recompiling core now builds with GCC 2.95.x.
+	- Fixed several other warnings and errors that occurred when building 
+	  with GCC 2.95.x.
+	- INSTALL_MAN_DIR in the makefile now uses INSTALL_GROUP for the gid 
+	  instead of 0.
+	- Fixed several C++-style comments and a couple of warnings in the 
+	  OpenGL code.
+	- Fixed a build error in the xmess.xgl target.
+	- Merged the latest MESS CVS changes.
+
+Release 0.67.1, 9 April 2003
+	- Almost everything from MAME 0.67 and MESS CVS.
+	- Added support for konamigx to info.c.  (David Haywood) 
+	- Building the neomame target now works.  (Steve Behling)
+	- Using XFree86 3.3.6 fbdev in 32bpp now works.  (Steve Behling)
+	- USB patches to take recent FreeBSD changes into account.  (Matthew 
+	  N. Dodd)
+
+Release 0.66.2, 19 March 2003
+	- Fixed several C89 errors and warnings, mostly caused by C++-style 
+	  comments.
+	- Merged the latest MESS CVS code.
+
+Release 0.66.1, 17 March 2003
+	- Amost everything from MAME 0.66 and MESS CVS.
+	- Enabling X11_DGA in the makefile causes "make install" to set the 
+	  suid bit on the executable.  (Christopher Stone)
+	- The Barath frameskipper is now enabled by default.  (suggested by 
+	  Christopher Stone)
+	- Fixed the use of 'sdl-config' in src/unix/unix.mak on platforms such 
+	  as FreeBSD.  (Stijn Hoop)
+	- Rotation has been moved to the blit core and should be a lot faster. 
+	  (Shyouzou Sugitani)
+	- Updated the GLmame driver to 0.94, which supports hardware bitmap 
+	  rotation and should fix the OpenGL problems that have affected recent
+	  releases.  (Sven Goethel)
+	- Analog controls work again, and the analog code is now synced up with
+	  the Windows code.  (Sebastien Devaux)
+	- The "-joydev" switch now allows a full device name, such as 
+	  /dev/input/js0, to be specified.
+	- Added makecd_mame2.pl to contrib tools; this script aids with burning
+	  CDs with ROMs, flyers, and cabinets.  (Luc Saillard)
+	- Renamed "-gamma-correction" to "-gamma" to be consistent with the 
+	  Win32 version.  It should also work now.
+	- An Xv-enabled build should no longer report 0 bits per pixel and stop
+	  on a display that doesn't support the Xv extension.  (Alexander 
+	  Miller)
+	- The "-brightness" switch now works as in Windows.  Removed obsolete 
+	  brightness and gamma code from sysdep_palette.
+	- Idle sleeping is now disabled while the onscreen configuration menu 
+	  is displayed.  This works around a problem with key and button 
+	  presses not registering when setting input preferences.
+	- The "-record" and "-playback" switches now work as in the Win32 
+	  version.  Also, the "inp" directory is now created on startup if 
+	  it is missing.
+	- MAME's disassemblers are no longer built by default.  This avoids  
+	  having to make some ugly little patches to the core.  (Christopher 
+	  Stone)
+	- Removed the obsolete 8bpp update functions from most of the targets.  
+	  This should speed compilation and produce a smaller binary.
+	- Building on IRIX should again work "out of the box".
+
+Release 0.65.1, 11 February 2003
+	- Almost everything from MAME 0.65 and MESS CVS.
+	- Removed support for the ALSA 0.5 plugin.  (Shyouzou Sugitani)
+	- The default path for data files in the example rc files, docs, and 
+	  several scripts is now more FHS-compliant.  (Reported by anarxia.)
+	- Disabled XScreenSaver support because it can cause the game window to
+	  not open when running in KDE.  (Christopher Stone)
+	- Reworked makefile.unix with the intent of making it a bit cleaner and
+	  easier to tweak.
+	- hdcomp now builds via "make -f makefile.unix tools".
+	- Removed most Windows- and MS-DOS-specific files.
+
+Release 0.62.2, 12 January 2003
+	- Fixed a link error that affected xmame but not xmess.
+
+Release 0.62.1, 12 January 2003
+	- Almost everything from MAME 0.62 and MESS 0.62.1.
+	- The game window should no longer open twice on startup in most cases.
+	  One known exception is Pac-Man with artwork enabled.
+	- Replaced fileio.c with a slightly modified version from the Win32 
+	  codebase.  Be aware that several command line switches have changed 
+	  as a result!
+	- Applied the Xv cleanup patch required for the VIDIX patch.  (Alastair 
+	  Robinson)
+	- The number of games is no longer hard-coded to 3000 in datafile.c.  
+	  This should fix problems with history.dat and "-listinfo".  (Rene 
+	  Single)
+	- Rotation is now handled by the OSD code.  The method used is hardly 
+	  optimal, but it should work for all display targets.  Moving the 
+	  rotation to the blit core is planned for a future release.
+	- The Xv target now uses the game driver's aspect ratio unless the 
+	  "-nokeepaspect" or "-noka" switch is specified.  Inspired by Paul 
+	  Sajecki's patch.
+	- Simplified/unified the FPS on-screen display.  This is now only 
+	  overridden when the Barath frameskipper is in debug mode.
+	- The DGA, GGI, and SVGALIB targets now use the game aspect ratio 
+	  provided by the core rather than a hard-coded 4:3.
+	- Using "-x11-mode" or "-x11" to activate DGA fullscreen mode now 
+	  disables Xv.  Likewise, switching to DGA fullscreen mode via <ALT>-
+	  <HOME> is now disabled while Xv is active.
+	- All path and directory options in fileio.c now support expansion of 
+	  environment variables such as $HOME.
+	- Fixed a warning about snprintf when building for Mac OS X.
+	- Fixed the XInput handling so that spinners no longer show an inertial
+	  effect.  (David Mitchell)
+	- Updated the documentation to include a section about the Xv extension.
+	  (Frank Cox)
+	- Fixed problems in memory.c that could lead to crashes and default.cfg
+	  corruption.  (smf)
+	- Fixed a bunch of ANSI/ISO warnings reported by Stefano Priore.
+	- Aspect and mode switches are now available for the Xv driver even if 
+	  DGA isn't enabled.
+	- Fixed a couple of files so that they include <alsa/asoundlib.h> 
+	  instead of the deprecated <sys/asoundlib.h>.  (Nico)
+	- Changed a net_active() call in src/mame.c to the osd_net_active().  I 
+	  must have messed up my all-in-one core patch at some point.
+	- The 'rc' and 'hi' directories are now created on startup if they're 
+	  missing.  (Gerd Sussner)
+	- Merged NetMAME 0.6rc1, which should allow games to be playable over 
+	  medium-latency connections, DSL, and cable.  It also adds configurable
+	  ports and NVRAM sync.  (Steve Freeland)
+
+Release 0.61.1, 13 November 2002
+	- Almost everything from MAME 0.61 and MESS 0.61.2.
+	- The mouse cursor is now hidden in OpenGL fullscreen mode.  (Craig 
+	  Servin)
+	- Applied a patch for FreeBSD to unix/video-drivers/svgainput.c.  
+	  (Stijn Hoop)
+	- Applied the NetMAME 0.5 patch, which adds a new option, -parallelsync,
+	  which should allow games to work without lag at network latencies of 
+	  up to 16 milliseconds.  (Steve Freeland)
+	- Added support for Linux on the Playstation 2.  (Joan Sarah Touzet)
+	- Fixed a problem in the ALSA 0.9 driver with setting the sample rate 
+	  on SB128 soundcards.  (Stephen Anthony)
+	- Fixed a bug in unix/devices.h that prevented compilation on non-X11 
+	  platforms.
+	- Fixed the register constraints in cpu/i8085/i8085cpu.h so that 
+	  cpu/i8085/i8085.c can build for x86 using gcc-3.1 with -O3.  This 
+	  change was missed in the MAME 0.61 release.
+	- Fixed multiple definition warnings in the psikyosh driver.
+	- Increased the size of the buffer used to display history.  (Steve 
+	  Fewell)
+	- Modified unix/fronthlp.c so that it flushes its output more often to 
+	  aid frontends.  (Shadow Walker)
+	- Changed unix/video-drivers/xfx.c to be more frontend-friendly.  
+	  (Benoit Dumont)
+	- Added support for the SDL joystick driver.  (Yang Hyun)
+	- You can now specify a config subdirectory name using -cfgname/-cn.  
+	  This is useful for creating an alternate configuration.  (Benoit 
+	  Dumont)
+	- Added a "waveout" DSP plugin which redirects sound to a file using 
+	  Microsoft's PCM WAVE format.  The file name can be specified with the 
+	  "-audiodevice" switch and defaults to "xmameout.wav".  (Donald King)
+	- Added support for showing average frames per second when quitting.  
+	  Also added support for the -frames_to_run/-ftr switch.
+	- Added Xv hardware scaling support!  To enable, uncomment the line 
+	  reading "X11_XV = 1" in the makefile and use the -xvext/-xv switches 
+	  (and possibly the -yuv switch).  (Alastair Robinson)
+	- An X11 build can now grab the keyboard to bypass window managers.  
+	  Use -grabkeyboard/-gkb to activate and/or the ALT + PGUP keypress to
+	  toggle it on/off.  (Gerd Sussner)
+	- The code for finding the best X11 visual now checks in descending 
+	  order of bit depth.  This is to work around a bug/feature in the 
+	  latest NVidia drivers.  (Gerd Sussner)
+	- Fixed a problem in the DGA2 driver that could lead to scrambled 
+	  colors with an i830MG video card in 24bpp mode.  (Eric Brunet, 
+	  Shyouzou Sugitani)
+	- The SDL target's -listmodes switch now operates before attempting to 
+	  load a game.  (Shadow Walker)
+	- If xmame is iconified in IRIX, it will automatically pause ("boss 
+	  hanging around mode").  (Andrea Suatoni)
+	- Added a switch to force yv12 mode in the Xv driver; made improvements
+	  to the yv12 code.  (Eric Brunet)
+	- Xmame should now build "out of the box" for FreeBSD.  Note that for 
+	  the SDL target, you may have to set the SDL_CONFIG flag in the 
+	  makefile.  (Stijn Hoop)
+
+Release 0.561.1 (xmess), 16 May 2002
+	- Everything from MESS 0.561.
+	- Fixed the register constraints in cpu/i8085/i8085cpu.h so that 
+	  cpu/i8085/i8085.c can build for x86 using gcc-3.1 with -O3.
+
+Release 0.60.1 (xmame only), 5 May 2002
+	- Everything from MAME 0.60, except for the new special controllers 
+	  support.
+	- Updated the SNK driver to fix sound for games that couldn't use Y8950
+	  together with YM326/YM3812.  (Nicola Salmoria)
+	- Fixed the leg of the tiger in namcos86.  (SUZ of the MAME E2J board)
+	- Updated the Moo Mesa driver to the latest version.  (R. Belmont)
+	- Fixed a stereo output bug in sound/2612intf.c; fixed a sample loop 
+	  timing bug in sound/k007232.c.  (Hiromitsu Shioya)
+	- The '-diffdir' setting might actually work now.
+	- Fixed the Mortal Kombat 3 level select screen.  (Aaron Giles)
+	- Updated the description of the new '-ctrlr' option in changes.mame 
+	  and windows.txt.  (Ron Fries, et al)
+	- Updated the V60 core to handle unaligned memory accesses, which 
+	  should fix some SSV games.  (Nicola Salmoria)
+	- Updated 8080bw to fix the dip switches for Ozma Wars and its clones, 
+	  and to add the offscreen bonus display to 4-Player Bowling.  
+	  (Nephrite, Zsolt Vasvari)
+	- Updated drivers/psikyosh.c and vidhrdw/psikyosh.c to allow Lode 
+	  Runner and Hot Gimmick to run through their attract modes.  (David 
+	  Haywood)
+	- Fixed a crashing bug in vidhrdw/shaolins.c.  (David Haywood)
+	- Modified sound/ay8910.c to fix sound in some M62 games.  (Nicola 
+	  Salmoria)
+	- Updated drivers/wecleman.c to make the car in wecleman controllable.  
+	  (David Haywood)
+	
+Release 0.59.2 (xmame only), 17 April 2002
+	- Updated the included zlib library to 1.1.4, which fixes a "double 
+	  free" security vulnerability.
+	- Applied a fix for the fromance video driver.  (Takahiro Nogi)
+	- Updated romalizer to the latest release, 0.7pre3.  (Christopher 
+	  Stone)
+	- Fixed a potential crash and a linear interpolation bug in the ES550x 
+	  sound driver.  (Aaron Giles)
+	- Fixed a crash in the renegade driver caused by a sound effect reading 
+	  past the end of the ADPCM memory region.  (Phil Stroffolino)
+	- Fixed the following MAME testers bugs: blmbycar059red, uopoko059red,
+	  gcpinbal059red, jitsupro059red, metroc059red, phelios059red, 
+	  paclandc059red, ncv1058red, av2mj059red, fromancec058red.  (Aaron 
+	  Giles)
+
+Release 0.59.1 (xmame only), 25 March 2002
+	- Everything from MAME 0.59.
+	- Set some more sensible defaults for the various path settings in 
+	  fileio.c (e.g., XMAMEROOT/samples for samplepath).
+	- Fixed a segfault in psikyosh games.  (David Haywood)
+	- The NetBSD USB joystick code now compiles on newer NetBSD 
+	  installations.  (Krister Walfridsson)
+	- DGA 2.0 support now works on NetBSD PowerPC machines.  It was broken 
+	  due to an issue with using memset() on mapped video buffers.  
+	  (Charles M. Hannum)
+	- The GLmame driver now compiles and runs on the OpenGL 1.1 shipped 
+	  with IRIX, but still doesn't work as it should.  (Andrea Suatoni)
+
+Release 0.58.3 (xmame only), 17 March 2002
+	- Cleaned up src/unix/effect.c a bit.  It should now be able to compile 
+	  better with non-GCC compilers.  (Inspiration by Marcus Herbert.)
+	- Fixed a memory core bug in drivers/btoads.c.  (Aaron Giles)
+	- Fixed an endian bug in sndhrdw/williams.c that could affect 
+	  big-endian architectures.  (Aaron Giles)
+	- Worked around several warnings about 'PPC' being redefined when 
+	  building under LinuxPPC.
+	- Added support for using multiple mice as trackballs under X11.  (Gerd
+	  Sussner)
+	- Updated NetMAME to 0.4.1, which fixes several problems that prevented 
+	  3+ player sessions from working.  (Steve Freeland)
+	- Changed the XIL support to use 16bpp instead of 8bpp.  (Carson Gaspar)
+	- Applied a fix for a crash in Vulgus.  (Stefan Jokisch)
+	- Added the latest romulan.pl to src/unix/contrib/tools.  This release 
+	  adds support for finding roms that are in the wrong zipfiles and also 
+	  has new options to disable strict merged sets.  (Nathan Hand)
+	- Added a workaround for the XFree86 tdfx DGA2 driver which can prevent 
+	  the original mode from being restored when leaving fullscreen mode.  
+	  To enable, uncomment TDFX_DGA_WORKAROUND = 1 in the makefile.
+	  (Gilles Hamel)
+	- 'make xlistdev' should work again.  (Bugzilla #189)
+
+Release 0.58.2 (xmame only), 10 February 2002
+	- Applied a tilemap fix needed for Numan Athletics.  (Phil Stroffolino)
+	- Fixed a bug that caused the network code to break in FreeBSD.  (Stijn 
+	  Hoop)
+	- The xfx and svgafx targets failed to build in 0.58.1 because of a 
+	  core patch that was inadvertently overwritten.  They now build again.
+	  (Steve Freeland)
+	- Applied sound fix for Final Fight and Truxton 2 and possibly other 
+	  games which use FM timers; applied QSound fix for CPS1; applied sound
+	  fix for Yie Ar Kung-Fu.  (Aaron Giles)
+	- Outrun no longer segfaults on startup.  (Steve Freeland)
+	- Fixed several multiply-defined variables that caused link warnings.
+	- The OSS audio driver no longer automatically falls back on timer-
+	  based audio if the requested fragment size/numfrags cannot be 
+	  obtained from the sound device.
+	- Fixed a few gcc 3.0.x warnings.
+	- The xgl target compiles again, but may have problems with vector 
+	  games.
+
+Release 0.58.1 (xmame only), 5 February 2002
+	- Everything from MAME 0.58.
+	- Fixed several C++-style comments.
+	- The problem with compiling src/cpu/v60/v60.c in LinuxPPC should really
+	  be fixed now.
+	- Updated to GLmame 0.93, which fixes a bug affecting Voodoo cards.  
+	  (Sven Goethel)
+	- Pausing while in fullscreen DGA mode no longer causes the sound to be 
+	  lost.  (Steve Slaven)
+	- The short version of "-loadconfig" is now "-lcf", since "-lc" was 
+	  conflicting with -listcpu.
+	- Corrected a minor error with the help info for "-stdout-file" and 
+	  "-stderr-file".
+	- Added an SDL sound plugin that is enabled by default for the BeOS 
+	  target.  (Jack Burton, Caz Jones)
+	- Updated/cleaned up some bits of the DGA2 code.  (Fernand Albarracin, 
+	  Shyouzou Sugitani)
+	- The xfx target is working again.  (Steve Freeland)
+	- Updated netmame to version 0.4, which should tolerate latency better.
+	  (Steve Freeland)
+
+Release 0.57.1 (xmame only), 5 January 2002
+	- Everything from MAME 0.57.
+	- src/cpu/z80.c now builds with gcc 3.0.x using -O3.  (Andrea Mazzoleni)
+	- Fixed a minor typo in src/cpuintrf.c.  (Quench)
+	- Fixed a bug in src/vidhrdw/nmk16.c that caused bad/leftover sprites 
+	  in gunnail.  (David Haywood)
+	- Added experimental network support.  To enable it, uncomment 
+	  MAME_NET=1 in the makefile.  See src/unix/doc/multiplayer-readme.txt. 
+	  (Steve Freeland)
+
+Release 0.56.2, 1 January 2002
+	- Added the MESS 0.56 core.
+	- Added contrib/kxmame.  This script launches xmame.x11 in builds of KDE
+	  which have problems with the window not opening.  (Sylvain Trosset and
+	  Hoonis)
+	- Updated dga2.txt to mention Radeon DGA2 fixes that are in the XFree86
+	  cvs tree.  (Shyouzou Sugitani)
+	- Updated GLmame to v0.92--see src/unix/doc/changes.opengl.  (Sven
+	  Goethel)
+	- Added extra debugging output to the DGA 2.0 driver.  (Shyouzou
+	  Sugitani)
+	- Fixed a compile error that could occur in blit.h due to a C++-style
+	  comment.  (Artane)
+	- Added the ability for xmame to interpret file names as game names,
+	  e.g., 'xmame.x11 /path/to/mspacman.zip' should now work.  (Peter
+	  Trauner)
+	- Renamed several xmame-specific keyboard functions to prevent a clash 
+	  with svgalib and to avoid future clashes.  (Bugzilla #123)
+        - Added rapid-fire support for joysticks: Use -rapidfire or -rapidf.
+          (Shyouzou Sugitani)
+	- Added an SDL azerty keymap to doc/xmamerc.dist.  (Luc Saillard)
+	- The xfx target can now compile, though it still won't run.  (Viet)
+	- Upgraded to romalizer 0.7pre2; fixed a problem that caused '-listfull 
+	  mokomo' to break romalizer.  (Christopher Stone)
+	- The svgafx target compiles again.
+	- Added some notes to makefile.unix regarding known problems with gcc
+	  optimization flags on IA32 platforms.
+	- Added src/unix/doc/AIX-install-notes.  (Greg Peter)
+
+Release 0.56.1 (xmame only), 21 November 2001
+	- Everything from MAME 0.56.
+	- The svgafx driver is working again--it was broken by the removal of
+	  8bpp support from the core.  (Henri and Jason)
+	- Numeric keypad support is now much better.  (Andre Majorel)	
+	- Added arbitrary height scaling, available via the -arbheight option
+	  and started sanitizing the blit core.  This currently only works with
+	  the X11 (windows, DGA1, DGA2) and svgalib drivers.  (Adam Moss)
+	- Added support in makefile.unix for the Intel C++ compiler, and also a
+	  sample wrapper script in contrib/tools.  (Adam Moss)
+	- Added -usbpspad/-pspad switch for support of the direction buttons on
+	  the Playstation gamepad.  (Bill Adams)
+	- Added support for SDL under BeOS.  Sound is not currently supported,
+	  however.  (Jack Burton)
+	- Fixed a bug that prevented romalizer from working.  (Shyouzou
+	  Sugitani)
+	- The xgl target should work much better.  (Sven Goethel)
+	- The -hotrod/-hr and -hotrodse/-hrse commands should actually work now.
+	- Fixed a bunch of warnings that occurred when linking with GNU binutils
+	  using -warn-common.
+	- Added DGA2 documentation: src/unix/doc/dga2.txt.  (Shyouzou Sugitani)
+
+Release 0.55.2 (xmame only), 4 October 2001
+	- Added special-cased fast 2x1 and 3x1 scaling to the blit core.  (Adam
+	  Moss)
+	- Added several AdvanceMAME effects, available via -effect/-ef.  Note
+	  that these effects are not available for some video drivers, nor do
+	  they work on actual 24-bit (packed) displays yet.  (Ben Saylor)
+	- Added mame-listmissing to contrib/tools.  (David Griffith)
+	- Fixed compilation errors reported in snprintf.c on some platforms,
+	  e.g. HP-UX 10.20 with GCC 3.0.  (Stefan Becker)
+
+Release 0.55.1 (xmame only), 17 September 2001
+        - Everything from MAME 0.55.
+	- Removed the romcheck script until its author considers it far enough
+	  along for public consumption.
+	- Added mamecds to contrib/tools.  (Carlos Calzada Grau)
+	- Updated the ALSA 0.9 support: Added -alsa-buffer; replaced the use of
+	  SND_PCM_FORMAT_S16_{LE,BE} with SND_PCM_FORMAT_S16; changed
+	  -alsapcm(-pcm) to -alsa-pcm(-apcm); changed the default value of
+	  -alsa-pcm.  (Shyouzou Sugitani)
+
+Release 0.54.2 (xmame only), 4 September 2001
+	- Applied a fix for the Bubble Bobble driver.  (Haze)
+	- Added a couple words to the makefile to indicate that the 68020 asm
+	  core is broken.
+	- Added a.out support (e.g. for OpenBSD) to the dlsym calls in several
+	  GLmame files.  (Claudio Castiglia)
+	- Applied a fix for Konami games.  (Aaron Giles)
+	- Using -debug no longer results in a segfault.
+	- Applied a patch for the ES550x that fixes the runaway voices in Puzzle
+	  Bobble 3 and might fix other games with problems.  (Aaron Giles)
+	- Added -samplepath/-sp and -artworkpath/-ap command line options.
+	- Added mame-cd to contrib/tools.  (Mario J.Barchin Molina)
+	- Added romcheck to contrib/tools.  (David Griffith)
+
+Release 0.54.1 (xmame only), 26 August 2001
+	- Everything from MAME 0.54.
+	- Fixed a compile error in the xgl target caused by a change in the
+	  core.  (Sven Goethel)
+	- Applied a patch that fixes CPS2 games.  (Aaron Giles)
+
+Release 0.37b15.2, 26 August 2001
+	- Everything from MESS 0.37b15.  Yay!
+	- Changed the short version of -list-display-plugins from -ldp to
+	  -ldisp.  -ldp was already being used for -list-dsp-plugins.  (Shyouzou
+	  Sugitani)
+	- Fixed prep-new-mess to account for some of the new text file
+	  names/locations.
+
+Release 0.53.1, 18 August 2001
+	- Everything from MAME 0.53 except for what was missing before.
+	- GLmame now supports LinuxPPC.  (Sven Goethel)
+	- Fixed a problem that could cause an xmame.xgl build to fail when
+	  esound is enabled.
+	- Fixed a bug in src/unix/unix.mak that caused builds using the asm 68k
+	  core to fail.
+	- QNX Neutrino/Photon updates: Added extended keyboard support; support
+	  for a wider range of sound cards; swapfile support.  (Travis Coady and
+	  Julian Kinraid)
+	- Fixed a bug in contrib/porting/prep-new-mess that caused fix-comments
+	  to erroneously run on src/unix when processing .h files; made other
+	  cleanups in this script and prep-new-mame.  (Christopher Stone).
+
+Release 0.37b16.1, 7 July 2001
+	- Everything from MAME 0.37b16 except for steadykey support and the new
+	  RGB blitters.  These may be appearing in a later release.  :-)
+	- Added Matt Lowry's latest README, which has been missing from xmame
+	  for several releases.
+	- Fixed the contrib/porting/prep-new-mame script so it doesn't omit the
+	  README file.
+	- QNX Photon2 updates: A fix for dirio.c which allows xmess to compile
+	  under the QNX 6.1 internal beta; audio has better verbosity; fixed a
+	  bug which caused games utilizing a mouse to core dump.  (Travis Coady)
+	- Fixed some ANSI/ISO warnings in the GLmame code.
+	- Changed contrib/porting/prep-new-mame to reflect the new .txt files
+	  bundled with MAME.
+	- Updated contrib/porting/porting.txt to refer to src/windows rather
+	  than src/msdos for diffing between versions, since the Win32 target
+	  is now the primary one.
+	- Updated the docs to mention that KDE 2.2b1 has been reported to fix
+	  the xmame.x11 problem whereby the window never displays without using
+	  a workaround.
+
+Release 0.37b15.1 (xmame only), 26 May 2001
+	- Everything from MAME 0.37b15 except for 'steadykey' support.
+	- Added an aRts sound server driver.  (Manuel Teira)
+	- Added another aRts sound server driver.  It needs reasonable aRts 
+	  server settings, something like artsd -F 6 -S 4096 should be ok to get
+	  near accurate response time.  (Petr Smotek)
+	- ALSA updates: Added preliminary support for ALSA 0.9 API; split the
+	  0.5 and 0.9 API stuff into separate files.  (Shyouzou Sugitani) 
+	- HotRod support is now enabled by either -hotrod or -hotrodse, just
+	  like the DOS/Win32 version.
+	- Added dummy flicker and vector orientation functions to fxvec.c so
+	  that xmame.xfx can link again.
+
+Release 0.37b14.2 (xmame only), 13 May 2001
+-------------------------------------------
+	- Updated the romulan.pl script in contrib/tools.  (Nathan Hand)
+	- The sound device is now released when the emulation is paused.
+	  (Shyouzou Sugitani)
+	- Updated the comment in makefile.unix about nasm to indicate that v0.98
+	  or higher must be used to build the asm 68k cores.
+	- Added -hotrod for HotRod and HotRod SE support.  Set it to 1 for
+	  HotRod, 2 for HotRod SE.
+	- The DGA target now reports whether it's using DGA1 or DGA2.
+	  (Christian Groessler)
+	- Updated GLmame to version 0.62.  (Sven Goethel)
+	- Fixed src/tiny.mak so the tiny build would work.
+	- Added the KDE workaround to the documentation.
+
+Release 0.37b14.1 (xmame only)
+	- Everything from MAME 0.37b14 except for 'steadykey' support.
+	- Major updates to the files in contrib/porting.  Added prep-new-mame
+	  and prep-new-mess scripts for porting from the MS-DOS sources.
+	- Added new CFLAGS to makefile.unix for more optimal builds under IRIX.
+	  (John Gilbert) 
+	- Fixed the files in src/unix for which Per Wigren reported problems
+	  when using the Tru64 compiler.
+	- Incorporated fixes to the core sources for the Tru64 compilation
+	  problems. (Nicola Salmoria)
+	- Audio now works on the released version of Mac OS X.  (Pete French)
+	- Fixed a bug in logerror() that could cause a crash.  (Pete French)
+	- Added the German HTML docs.  (Robert Hamberger)
+	- Added a note to the docs and makefile about adding -DGLU_VERSION_1_2
+	  to the GLCFLAGS when using Mesa's GLU.  (Sven Goethel)
+	- Updates to the ALSA dsp driver: cosmetic changes, suppression of bogus
+	  warnings about underruns.  (Shyouzou Sugitani)
+	- Added new sound driver plugins for IRIX.  (Brandon Corey)
+	- Updated the changelog for the ALSA dsp driver.  (Shyouzou Sugitani)
+
+Release 0.37b13.2
+	- MESS 0.37b13 is now included.
+	- Added an updated romulan.pl to contrib/tools.  (Nathan Hand)
+	- Added an updated romalizer to contrib/tools.  (Christopher Stone)
+	- Adopted the directory layout used in MESS CVS.  Namely, all of the
+	  xmame-specific directories have been moved into src/unix.  Releases
+	  will now have symlinks to these directories in the root.
+	- Updated the docs to reflect the new mailing list address, courtesy of
+	  Pete French.
+	- Fixed an unmatched parenthesis error in src/drawgfx.c that was
+	  affecting non-Intel platforms.
+	- Fixed a bug in mess/cpu/apexc/apexcdsm.c that was causing xmess
+	  linking to fail.
+	- Updates to the QNX target: Added sound support via an ALSA hack, added
+	  fullscreen Photon2 support, and made other miscellaneous Photon2
+	  updates and fixes.  (Travis Coady)
+	- Updated GLMame to v0.85.  (Sven Goethel)
+	- Vector games now work with the SDL target.
+
+Release 0.37b13.1 (xmame only)
+	- Everything from MAME 0.37b13.
+	- Numerous updates to the OpenGL target.  (Sven Goethel)
+	- Added Photon2 display support for the QNX target.  (Travis Coady)
+	- You can now run "make clean68k" before building with a different 68k
+	  core.  (Mike Coates)
+	- Applied a patch from StretchMAME that prevents a bunch of games from
+	  segfaulting on startup.  (Shyouzou Sugitani)
+	- A fix for the sprites in CVS games.  (Nicola Salmoria)
+
+Release 0.37b12.1
+	- Everything from MAME and MESS 0.37b12.
+	- The SDL install no longer sets SUID root on the binary.  (Torbjrn
+	  Andersson)
+	- Updated mame_perl to 1.3.  (Stefan Becker)
+	- Added support for the RGB 555 mode for targets which support 16bpp
+	  displays.
+	- Added support for the RGB 888 mode to the x11_window, DGA, and SDL
+	  targets.  (Shyouzou Sugitani, Lawrence Gold)
+	- Added -sdlmapkey/-sdlmk to the SDL target to allow the remapping of
+	  keys.  This should help users with non-U.S. keyboards.
+	- Revised the example key remappings in doc/xmamerc.dist and
+	  src/unix/xmamerc-keybinding-notes.txt to match the current keycodes.
+	  Also added SDL examples.
+	- Added the beginnings of QNX 6/QNX 4 support.  The X11 display driver
+	  should at least work.  (Travis Coady)
+	- The semicolon/colon and period keys should now work for the SDL target
+	  in xmess (tested with the a800 driver). 
+	- Updated/added a couple of key mappings (\", :, and <) to match the
+	  MS-DOS version.
+	- Improved OpenGL support, including better performance, dynamic
+	  checking of OpenGL extensions, and dynamic fetching of the max texture
+	  size.  (Sven Goethel)
+
+Release 0.37b11.2
+	- MESS 0.37b11 is now included.
+	- Full DGA 2.0 support, with automatic depth-switching.  A build on an
+	  XFree86 4.0.x system will automatically use the DGA 2.0 calls; if the
+	  binary with 2.0 support is run on an XFree86 3.3.x system, it will
+	  fall back on DGA 1.0 calls.  (Shyouzou Sugitani, Stea Greene, Matt
+	  Lowry)
+	- Support for either NetBSD or OSS sound under OpenBSD.  The default is
+	  the NetBSD sound interface, which reportedly works better.  (Claudio
+	  Castiglia)
+	- Cleaner install mechanism in the makefiles; included install-sh script
+	  from X11R5 for platforms which lack the install command; the default
+	  install prefix is now "/usr/local".  (Claudio Castiglia) 
+	- SDL mouse support has been added.  (riq)
+	- SDL target should now have all previously missing update routines.
+	  (riq)
+	- Added -joydevname/-jdev option to select the device prefix for the
+	  i386 joystick.  Defaults to "/dev/js" for Linux and "/dev/joy" *BSD.
+	  (Thanks to Laurent Simon for the suggestion.)
+
+Release 0.37b11.1 (xmame only)
+	- Everything from MAME 0.37b11.
+	- Merged in changes from the src/unix tree that were in the MESS CVS;
+	  one of which is that if MAME_DEBUG is enabled, the binary will be
+	  called xmamed.<target> or xmessd.<target>.  (Christopher Stone)
+	- Commented out the call to osd_dirty_merge() in SDL.c.  The SDL target
+	  has its own dirty handling.  (Hans de Goede)
+	- The menu colors no longer fade when you pause a game.  (Sean Young)
+	- xmess compiles again without having to uncomment VLM5030 in
+	  src/mess.mak. (Christopher Stone, Lawrence Gold)
+	- make -f <makefile> tools should work again for xmess.
+	- Possible fix for a problem with the DGA target on ATI Rage Mobility
+	  which caused a switch to fullscreen mode to not change the resolution.
+	  (Lawrence Gold)
+	- -listgamelist no longer prints the column headers (they are shown by
+	  -listgamelistheader).  (Lawrence Gold)
+
+Release 0.37b10.1
+	- Everything from mame 0.37b10 and mess 0.37b10
+	- ALSA sound driver uses stream mode; this fixes the problem of
+	  continuous static during games.  (Shyouzou Sugitani)
+	- Running with DGA 2.0 no longer causes a blank screen with Matrox
+	  G200/G400.  (Shyouzou Sugitani)
+	- The asm 68k code compiles again.  (Agawa Koji)
+	- Building on older gcc, non-gcc, and FreeBSD 3.3 systems works much
+	  better.  (Pete French, Olivier Galiber)
+	- New unified OpenStep 4.2 Intel/Mac OS X PowerPC code.  (Pete French)
+	- The SDL driver now has video_update for 16bpp_to_16bpp; SDL_HWPALETTE
+	  was added to the flags of SDL_SetVideoMode (Ricardo Quesada)
+	- New version of the mame_perl ROM manager.  (Stefan Becker)
+	- Fixes for getcwd/getwd for BSD43 systems.  (Pete French)
+	- Running with -listsamples no longer causes a core dump.  (me)
+	- Sprite corruption fix for the NES driver.  (Christopher Stone, Sean
+	  Young, Brad Oliver)
+	- The SDL driver now supports 32bpp XFree86 modes.  (Dan Scholnik)
+	- The SDL driver now has fullscreen support.  (Patrice Mandin)
+	- The back-quote/tilde key now toggles the on-screen display when using
+	  the SDL driver.  (me)
+	- Gave credit to Tadeusz Szczyrba for writing the original SDL driver.
+	- Added a needed call to fflush() in the error logging.  (Christopher
+	  Stone).
+	- The frontend code (-list options) should more or less resemble its
+	  MS-DOS counterpart.  Thanks to Christopher Stone for pointing out the
+	  problem areas.
+	- Added an "openbsd" ARCH define.  (Claudio Castiglia)
+	- Fixed some core files to allow building under Solaris 8 using its 
+	  native cc.  (Vincent ^_^)
+	- Changed the optimization flags in the Makefile for the IRIX platform
+	  so that the comment about turning on all optimization holds true.
+	  (Chris McCraw)
+	- The svgafx target should run again; a call to osd_dirty_merge() had to
+	  be commented out.  (henri)
+	- Updated the docs to mention problems using Red Hat 7's latest gcc;
+	  added suggestion for using ALSA with OSS emulation if OSS problems are
+	  experienced.
+	- Added a top-level README; removed old-changes.mess, which was
+	  identical to messold.txt; extended copyright notice to 2001 and listed
+	  Lawrence Gold as maintainer in config.c.  (Matt Lowry)
+
+Last Modified by Hans de Goede (hans@highrise.nl)
+
+Release 0.37b7.1
+	- Everything from mame 0.37b7, no mess yet
+	- Added support for USB joysticks under FreeBSD thanks to:
+	  Christian Weisgerber <naddy@unix-ag.uni-kl.de>
+	- Fixed xmame hanging with the message:
+	  WARNING: the game might not run correctly.
+	  Press any key to continue
+	- Made the debugger always use the aspect ratio of the actual monitor,
+	  instead of the aspect ratio of the emulated game.
+
+Release 0.37b6.1
+	- Everything from mame 0.37b6 & mess 0.37b5 & 0.37b6
+	- Alsa sound driver, thanks to: Luc Saillard <luc@alcove.fr>
+	  also please send any questions in his direction since I don't
+	  have alsa and thus can't test this.
+	- Applied a small fix to src/cpu/adsp2100/adsp2100.c, which
+	  should fix mk3 and friends, thanks to: Frank Cox
+	- Fixed a core bug causing ataxx and brutforc to crash.
+	- Some crc and cheatfile changes for xmess by Christopher Stone
+	  * The crcdir now defaults to XMAMEROOT/crc
+	  * Added a new cheatdir (option -cheatdir) defaulting to
+	    XMAMEROOT/cheat
+	  * Default cheatfile for MESS is now cheat.cdb
+	    (this filename actually gets changed in the core now to
+	     gamename.cdb, if the user wants to use her own filename,
+	     she can just use anything except cheat.cdb or cheat.dat
+	     and it will not be renamed in the core)
+	  * xmess now looks for cheat files in cheatdir/filename
+	- NETbsd USB joystick driver, thanks to: Krister Walfridsson
+	- IA64 support, YEAH, thanks to: Christian Groessler <cpg@aladdin.de>
+	- Made XF86-DGA honer -disablemode
+	- SGML(linuxdoc) based documentation many many thanks to
+	  Rene Herrmann <Rene.Herrmann@gmx.de>
+	  The .lyx file is the master file I use, so please submit either
+	  patches against the .lyx file, or just plain text additions.
+	  Patches against the .sgml file are of no use to me.
+	- Added a doc target to the makefile which generates the docs
+	  from the sgml source and generates gamelist.xxx, xxxxxxrc.dist and
+	  xxxxxx.6 .
+	- Openstep fixes, openstep should work out of the box now, thanks to:
+	  Pete French <pete@toybox.twisted.org.uk>
+	- Fixed crashes in svgafx for games which resize the screen, like
+	  mkla4.
+	- Fixed crashes in 8 bit X-windows with games which resize the screen,
+	  like mkla4.
+	- Fixed crash on exit in svgaXX displaymethods, when using the mouse
+	  and running games which resize the display, like mkla4.
+	- Support for the new "graphical" mame debugger. This uses just one
+	  window resizing it to the debugger or normal size, using seperate
+	  windows for each is something xmame's current architecture is
+	  not designed for. This might still happen in the future but not
+	  before a rewrite of the video subsystem.
+	- Added -debug-size / -ds XXXxYYY, with this you can specify the
+	  width and height of the debug window, please keep in mind that
+	  the minimum size is 640x480.
+	- You can now change the scale of a window on the fly with
+	  leftshift +:
+	  Insert	Increase widthscale
+	  Delete	Decrease widthscale
+	  Home		Increase heightscale
+	  End		Decrease heightscale
+	  Page Up	Increase scale
+	  Page Down	Decrease scale
+	- Added a partly autogenerated manpage, thanks to
+	  Rene Herrmann <Rene.Herrmann@gmx.de>
+	  
+Release 0.37b5.1
+	- Everything from mame 0.37b5, no mess yet!
+	- The asm m68000 core is currently broken, so don't use it! ,
+	  on the brighter side of things, neogeo games seems to
+	  be working with the C-core now.
+	- Fixed the segfault when exiting the xgl version.
+	
+Release 0.37b4.1
+	- Everything from mame & mess 0.37b3 & 0.37b4
+	- Note neogeo games don't seem to work this release with the C 68000
+	  cpu core, use the asm one instead.
+	  (Non x86 users seem to be outa luck, for this release only I hope.)
+	- Changed the makefile to use the new dos makefiles:
+	  -No more makefile editing for each release
+	  -No you can build tinymame / neomame / neofree mame too.
+	   (just set TARGET to neomame / tiny)
+	  -Also much cleaned up
+	- Added support for debugging on b/w xterm's thanks to:
+	  cpg@aladdin.de
+	- Updated romalizer to 0.61, thanks to: 
+	  TKMAME <tkmame@retrogames.com>
+	- Updated opengl support now also works with uthaglx, and vectors
+	  have been fixed for nvidea. Thanks to:
+	  Tony Hoyle <tmh@magenta-logic.com>
+	- Added support for mess snapshots (-snapshot) thanks to:
+	  "Wojciech Walaszkowski" <walaszkowskiw@prokom.pl>
+	- Added -hiscorefile switch to specify the location of highscore.dat
+	  Thanks to: TKMAME <tkmame@retrogames.com>
+	- Added a blurb to readme.unix about needing hiscore.dat to get
+	  highscores to work.
+	- Made svgafx and xfx honor -[no]keepaspect for those who want to fill
+	  the entire screen.
+	- Updated the mame_perl rom tool to 1.1 . Thanks to:
+	  Stefan Becker <Stefan.Becker@nokia.com>
+	- Added tools target to the makefile, to build the platform indepent
+	  tools.
+	- Added gamelist target to the makefile to generate gamelist.<target>
+	- Added SYSDEP_DSP_O_NONBLOCK switch to the sysdep_dsp_create flags,
+	  currently only implemented for esound and OSS. And not guaranteed to
+	  actually work.
+	- Made sound_stream.c check the return value of sysdep_dsp_write,
+	  incase it doesn't succeed / doesn't write all data. This should
+	  fix xmame with alsa's OSS emulation.
+	- Added Dingus Family <ddingus@usewest.net> as irix maintainer to
+	  readme.unix
+	- Added Jacob A. Hart <c9710216@studentmail.newcastle.edu.au> as
+	  freebsd maintainer to readme.unix
+	- If you don't specify a specific cheatfile xmess will now
+	  now uses XMAMEROOT/system.cdb instead of cheat.dat, this
+	  doesn't affect mame thanks to Chris <tkmame@retrogames.com>
+	- Readded openstep soundsupport thanks to:
+	  Pete French <pete@toybox.twisted.org.uk>
+	- Cleaned up src/unix/sysdep/misc.* so that the system headers
+	  are only included in the .c file.
+	- Cleaned up src/unix/osd_cpu.h to mach the above changes.
+	- Added a special case to both osd_cpu.h and misc.c for openstep
+	  since CLOCKS_PER_SEC is not defined and should be 64 on openstep.
+	- Added a blurb to doc/readme.unix about adding modelines to XF86Config
+	  Thanks to: Matt Lowry <mclowry@cs.adelaide.edu.au>
+	- Changed rc.c so that it no auto prepends no for clearing booleans,
+	  allowing for short boolean options.
+	- Added short options for most options thanks to:
+	  Christopher Stone <tkmame@retrogames.com>
+	- Made -help honor the COLUMNS environment variable, thanks to:
+	  Christopher Stone <tkmame@retrogames.com>
+	- Changed the config file parsing order a bit, now also parses global
+	  per game config files, see -help output, thanks to:
+	  Christopher Stone <tkmame@retrogames.com>
+	- Added prelimenary sgml-ised version of xmame-docs, see doc/html.
+	  Many thanks to: Rene Herrmann
+	- Xmame should no longer crash when compiled with DGA and run as root
+	  on a remote display. (Work around for an XFree86 bug)
+	- Xmames frontend code now checks for games which don't use any roms,
+	  yet still have a ROM_REGION defined. Like the "genesis" driver under
+	  xmess.
+
+Release 0.37b2.2
+	- 0.37b2.1 featured a rewrite of the keyboard handling to add unicode
+	  support, unfortunatly I only adopted the x11 based drivers, and
+	  forgot the others, so only the x11 based ones compiled. This release
+	  has much cleaned up and rewritten keyboard support for:
+	  -svgalib
+	  -ggi
+	  -xgl
+	  -xfx
+	  -svgafx
+	- Made the unicode support for X11 actually work (shift and altgr are
+	  now honered)
+	- Corrected a small type in makefile.obj-xmess, thanks to:
+	  Peter Trauner
+	- Fixed the creation of tape images in xmess, thanks to:
+	  Oscar Martn Gonzlez
+	- Updated the romalizer script in contrib to v0.6, thanks to:
+	  tkmame@larry.ztnet.com
+
+Release 0.37b2.1
+	- Everything from mame & mess 0.37b2.
+	- Fixed brightness handling on pause, the brightness no longer
+	  gets darker and darker if you pause/unpause a lot.
+
+Release 0.37b1.2
+	- (Re)added mess 0.37b1, including everything that's new.
+	- The solaris sound drivers now uses AUDIODEV if set thanks to:
+	  Keith Hargrove.
+	- Made sound update synchronious with video update,
+	  this should improve sound quality.
+	- Fixed a crash when running with -nosound -fakesound.
+	- Added detection of buggy FreeBSD newpcm driver, and fallback
+	  to timerbased audio when detected.
+	- Slightly changed the fragsize calculation in the oss dsp plugin,
+	  again, it now uses slightly smaller frags, which should increase
+	  sound quality a bit.
+	- Changed the default soundbufsize to 3.0, this is still smaller as
+	  before the default bufsize before the sound rewrite, and it seems
+	  that the 2.0 was a bit to optimistic.
+
+Release 0.37b1.1
+	- Everything from mame 0.37b1, no mess yet, if you want mess
+	  use 0.36.1 .
+
+Release 0.36.1
+	- Everything from mame & mess 0.36rc2 & 0.36 final.
+	- Fixed a compile error in the solaris dsp-plugin.
+	- Removed cheat,doc, cheat.dat and history.dat as they were out of
+	  date, get the most rescent version from http://www.mame.net.
+	- Slightly changed the fragsize calculation in the oss dsp plugin,
+	  it now takes the samplerate used into account.
+	- Added -verifyromsets and -verifysamplesets, both are less verbose,
+	  more easy parsable versions of -verifyroms resp -verifysamples.
+	- Added a number of hints about compiling for optimal performance
+	  to readme.unix, thanks to: Frank Cox <theatre@spreda.sk.ca>
+	- The i386 joystickdriver now also supports freebsd, thanks to:
+	  Robert Muir <rmuir@looksharp.net>
+	- Fixed (rewrote) the console switch handling for svgalib / svgafx,
+	  it now works with version 1.4.1 and higher compiled without
+	  background support (such as distributed with RedHat 6.2).
+	- Improved ggi mode selection, added -xres, -yres to force a
+	  certain mode, thanks to Christian Groessler.
+	- Openstep support has been updated for the new palette code, so
+	  the openstep version should compile again. Still no sound
+	  though, thanks to: Bat.
+	- Changing the volume under Solaris should no longer cause the
+	  sound to stop working, thanks to Mathis Rosenhauer.
+	- Solaris sound has been reported to work for SunOS too.
+
+Release 0.36rc1.1
+	- Everything from mame & mess msdos 0.36rc1
+	- Cleaned up the -list options output and made it more consistent,
+	  this could cause some slight problems with frontends, but
+	  the changes aren't that big. This should be the last time the
+	  format changes (I hope).
+	- Changed -bufsize to be in frames, so that it automagicly scales
+	  for games which have more / less frames / sec. The default of 2
+	  should be fine for everyone, please lett me know if you need to
+	  change this option, if no-one needs it it will be removed in a
+	  future release.
+	- Added a sound buffering layer on top of the new core sound mixer
+	  code. This is nescesarry, since the new buffering code only allows
+	  very slightly variating the number of samples per frame, and with
+	  OSS for example the number of samples per frame could variate a
+	  lott.
+	- Fixed OSS sound plugin compilation under freebsd.
+
+Release 0.36b16.1
+	- Everything from mame & mess msdos 0.36b16
+	- Fixed error messages for: "error optionx requires an argument".
+	- Fixed --boolean option parsing.
+	- Fixed bools in configfiles overriding commandline.
+	- Fixed printing of NULL strings in -showconfig.
+	- Fixed -vectorres for vertical oriented games.
+	- Reworked and cleaned up the makefile, you can now choose your os
+	  and cpu seperatly. This adds linux-sparc support amongst other
+	  things.
+	- Made oss.c compatible with linux/powerpc giving sound on this
+	  platform thanks to John Cramp.
+	- Wrote a generic plugin system, currently only supporting static
+	  plugins, but prepared for dynamic plugins.
+	- Rewrote the entire sound subsystem, to match a few core changes.
+	  Sound-drivers are now plugins, allowing for example esd support.
+	  All sound drivers need to be converted to this new system.
+	  Platforms which sound-driver(s) haven't been converted, don't
+	  have sound.
+	- Added a sound-mixer (for volume control) subsystem, again plugin
+	  based.
+	- Converted the oss driver to be a dsp plugin.
+	- Added an oss mixer plugin.
+	- Updated (fixed) SDL display driver, thanks to: Ricardo Calixto
+	  Quesada (riq@ciudad.com.ar).
+	- Added an esound dsp plugin.
+	- Fuzzy name matching alla the dos port, thanks to: Andrea Vettorello
+	  <molotov@dei.unipd.it>.
+	- Don't parse the game specific rc file untill the final name lookup
+	  has been done (for fuzzy / random name matching).
+	- Converted the netbsd sounddriver to be a dsp plugin, thanks to:
+	  Krister Walfridsson <cato@df.lth.se>
+	- Removed emulation of analogjoysticks using the mouse, this is now
+	  done by the core.
+	- Converted the solaris sounddriver to be a dsp plugin, added
+	  a mixer plugin thanks to: Mathis Rosenhauer
+
+Release 0.36b15.2
+	- Fixed the X11 target when compiled with XIL but without
+	  MITSHM.
+	- Fixed compiling on machines without DGA (sorry about this one ;)
+	- Added -version / -V to show the version, mainly for frontends.
+	- Fixed -listclones.
+	- Now accepts both -option and --option (--version for example)
+	- -showconfig no longer tries to print string options which are
+	  NULL.
+	- Updated german readme, thanks to: Robert Hamberger
+	- Renamed signal to sound_signal in src/sndhrdw/geebee.c, this
+	  should fix compiling it under HP-UX
+
+Release 0.36b15.1
+	- Everything from mame & mess msdos 0.36b15
+	- Removed the IRIX specific c-compiler entry in the makefile
+	  as this doesn't work on all machines, and shouldn't be needed
+	  on most others. Added hint about adding -DHAVE_SNPRINTF to
+	  CFLAGS for IRIX 6.5 .
+	- Changed all occurences of xmame.retrogames.com to x.mame.net .
+	- Completed contrib dir documentation.
+	- Added nvram file support.
+	- Fixed -gamma-correction and -brightness.
+	- Fixed (worked around) xgl crash with nvidea xgl drivers.
+	- Rewrote the config file susbsytem. It's much more modular now and
+	  can be used for other projects.
+	- Did the rename and move blues to get all the options in the
+	  modules where they belong. Removed a lott of global symbols.
+	- Xmame/xmess now parses all configfiles found starting
+	  with the most global files, and ending with the gamespecific file.
+	  The later parsed files can overwrite options in the previous
+	  parsed files.
+	- Each videomethod compile now only supports it's own options. In order
+	  to get rid of the warnings xmame now also parses a videomethod
+	  specific file, where you can put the videomethod specific config
+	  parameters. Taking the x11 video method as an example the extra
+	  parsed files are:
+	  $XMAMEROOT/xmame-x11rc and
+	  $HOME/.xmame/xmame-x11rc for 
+	  See doc/readme.unix for more info.
+	- Added mame_perl-1.0 to contrib/tools. Yet Another Romsets Manager
+	  by: Stefan Becker
+
+Release 0.36b14.1
+	- Everything from mame-msdos 0.36b14 & mess-msdos 0.36b14.
+	- Fixed make install for xmess
+	- Fixed -ident crash
+	- Fixed a small xmess link error
+	- Sorta fixed galaxian & clones (they run now)
+	- Updated the email adress for the openstep maintainer
+	- Added a suggested set of german keymappings to doc/xmamerc.dist,
+	  thanks to: Peter Trauner
+	- Implemented crc checking for xmess, added -crcdir option.
+	- Added crc database files from the mess dos distribution.
+	- Readded the 16bpp speedup using int copies for DGA, since it is now
+	  in the generic palette system, it is now also used for regular X and
+	  GGI.
+	- Xmame now detects if 16bpp is not available and falls back to 8bpp
+	  automagicly.
+	- Added color approximation in X11-window 8bpp mode, this means
+	  that -privatecmap isn't needed anymore to get a non-black emulation,
+	  -privatecmap is still faster though.
+	- Made the mouse buttons seperate buttons instead of piggy backed upon
+	  the joystick buttons, as the latest dos releases.
+	- Fixed a header conflict with the xgl target
+
+Release 0.36b13.1
+	- Everything from mame-msdos 0.36b12 & mess-msdos 0.36b12 &
+	  mame-msdos 0.36b13 & mess-msdos 0.36b13.
+	- New palette subsystem for the new 16 bpp paletised modes,
+	  making life easier for the display drivers, still room
+	  for improvement but a good start.
+	- Updated german readme thanks to: Robert Hamberger
+	- HP-UX compilation fixes, thanks to: Stefan Becker
+	- Netbsd 8 bit sound fix, thanks to: Krister Walfridsson
+
+Release 0.36b11.1
+	- Everything from mame-msdos 0.36b9 & mess-msdos 0.36b9 &
+	  mame-msdos 0.36b10 & mess-msdos 0.36b10 &
+	  mame-msdos 0.36b11 & mess-msdos 0.36b11.
+	- These changes include a changed output for -verifyroms which could
+	  break some frontends
+	- These changes also include some palette changes: -[no]16bitvideo
+	  has been removed and replaced by -bpp xxx (auto,8 or 16).
+	  If your display can only handle 8 bpp you should specify -bpp 8.
+	  Otherwise the default of auto will do fine.
+	- Fixed the x86-asm m68000 cpu core compile problems.
+	- Fixed problems with mess emulations which use r/w disk images,
+	  note that these don't support gzipped or zipped images.
+	- Fixed possible bufferoveruns with very long rompaths in
+	  fileio.c. This was never a security risk since xmame drops root
+	  rights before doing any fileio.
+        - This also changed the behaviour of -rompath it now longer adds a 
+          path to the rompath but instead replaces the entire rompath.
+	- Added a portable standalone snprintf implementation from mutt,
+	  for those platforms which don't have snprintf. Add
+	  -DHAVE_SNPRINTF -DHAVE_VSNPRINTF to DEFS.arch if your platform
+	  has these functions to use your libc implementation and not the
+	  one shipped with xmame, and please lett me know. This has already
+	  been done for: linux-* netbsd-* freebsd
+	- Fixed problems with -verifyroms failing on zippedroms with
+	  the wrong names but right checksums, while playing the game works
+	  fine.
+	- Added virtual root support to the -run-in-root-window option,
+	  now xmame can be used as a part of xscreensaver ;)
+	- Wrote a little script to run a random game in the root window for 2
+	  minutes and then run another random game etc. Use this as the extern
+	  command for xscreensaver, it is in contrib/tools/xmame-screensaver .
+	  Usage:
+	    - compile the x11 version of xmame
+	    - install it somewhere in your path
+	    - copy xmame-screensaver to /usr/games
+	    - edit ~/.xscreensaver , and add a line:
+	      /usr/games/xmame-screensaver
+	- Really fixed the glide compile problems <sigh>.
+	- Alpha sound fixes, thanks to Christian Groessler.
+	- Rearranged the contrib directory, now everything is devided into
+	  a few subdirs: frontends, patches, porting and tools.
+        - Added / updated a few readme's in the contrib dir (not complete yet).
+	- Fixed timerbased audio in combination with xf86-DGA.
+	- Fixed netbsd joystick support to use the correct device names.
+	- Fixed up the artwork searching method to be a bit more logical,
+	  see readme.unix for a description .
+
+Release 0.36b8.1
+	- Everything from mame-msdos 0.36b7 & mess-msdos 0.36b7 &
+	  mame-msdos 0.36b8 & mess-msdos 0.36b8
+	- Merged in the new 0.36b7 mess release. You can now specify if
+	  you want to build mess or mame at the top of the makefile.
+	  Xmess and xmame are built in a seperate obj dir so you can safely
+	  build both in the same tree, even at the same time if you want to.
+	- Renamed lotts of doc files for the mess merge, see the doc dir.
+	- Replaced all occurances of j.w.r.degoede@et.tudelft.nl with
+	  hans@highrise.nl which is my new email the old one will disappear
+	  soon. Also fixed any url's still referring to the old homepage.
+	- Replaced #include <glide.h> by #include <glide/glide.h>. So you
+	  nolonger have to specify /usr/include/glide as additional include
+	  path.
+	- Fixed xmame setting the root cursor to invisible when switching to
+	  fullscreen with the mouse grabbed.
+	- Fixed xmame forgetting that it had the mouse grabbed when to focus
+	  was switched away with the keyboard under enlightenment.
+	- You can't grab the mouse anymore when you specify -nomouse.
+	- Changes the svgalib tweaked mode code a bit, the 240x272 mode has
+	  been removed since it was broken. Added some more tweaked modes
+	  from the dos team including some planar tweaked modes:
+	  384x256
+          384x240
+          384x224
+          336x240
+          256x240
+          256x256 vertical orientation
+          240x256
+          Note if you use -noplanar you won't get the tweaked planar modes
+          either.
+        - Added -centerx <#> -centery <#> with these you can change
+          the center of all tweaked modes.
+        - Added scanline support to 320x240
+	- Svgalib version now restores textmode when mame exits with:
+	  Error: gfx[0] extends past allocated memory
+	- Changed -list output to seperate the different games with spaces
+	- Added romalizer 0.53 to the contrib dir this is a tcl script
+	  for cleaning up your rom collection by: Christopher Stone
+	  For more info see tkmame.retrogames.com.
+	- The asm68000 core is know to cause problems, and the speed gain is
+	  not impressive. Documented this.
+	- Sunos is now on the supported list, thanks to
+	  Saga <jolletx@cybercable.fr>
+	- Rethinked the way the rompath was handled, if you want the old
+	  behaviour and your rompath was:
+	  rompath /foo:/bar
+	  change it into:
+	  rompath /foo/roms:/foo/samples:/foo/artwork:/bar/roms:/bar/samples:/bar/artwork
+	  For an exact description of the new rompath handling for both
+	  xmame and xmess see readme.unix.
+ 	- Experimental sample synchronysing code in src/unix/sound.c
+	  should decrease the incident of dropped/skipped samples.
+	  This is disabled by default you can enable it with -samplesynch,
+	  see readme.unix for more info.
+	  Please give it a spin and mail your experiences to the xmame-list.
+	  Thanks to William A. Barath.
+	- Updated barath frameskip code with load detection.
+	  Thanks to William A. Barath.
+	- Added a alsa-sound driver to the contrib dir as alsa.c copy it
+	  over src/unix/sound-drivers/oss.c and add -lasound to EXTRA_LIBS
+	  in makefile.unix. Thanks to "Who Wants to Know?"
+	- You can now run xmame / xmess in your root-window as screen-saver
+	  / background. This can be enabled with -run-in-root-window.
+	- Added random game support option, specify random as game to
+	  play a random game ;)
+	- New openstep video code supporting scaling and 16bpp video modes
+	  Thanks to Bat
+	- New openstep makefile entries now with support for:
+	  - OpenStep for Intel
+	  - OpenStep for Motorola
+	  - OpenStep for Sparc
+	  - Mac OS X for Intel
+	  - Mac OS X for PPC
+	  Thanks to Bat
+	- Completly rewritten ggi video code with:
+	  - scaling
+	  - 16bpp support
+	  - works on 8, 16, 24 and 32 bpp X servers
+	  Thanks to Christian <cpg@aladdin.de>
+
+Release 0.36b6.1
+	- Everything from msdos 0.36b4 & b5 & b6
+	- Lotts and lotts of thanks goto William A. Barath for
+	  sorta taking my place while I was busy switching jobs and for a
+	  lotts of the improvements in this release.
+	- After a lott of discussion on the mailinglist about which
+	  frameskipping method is the best, selectable frameskipping methods
+	  have been added. Use -frameskipper # or the frameskipper keyword
+	  in xmamerc to configure this. The frameskipmethod can also be
+	  changed runtime with left-control + key combinations.
+	  Currently available frameskippers are:
+	  0   lctrl+insert   Dos frameskipping code
+	  1   lctrl+home     Improved frameskipping code thanks to  William A.
+	                     Barath
+        - added toggleable idle sleeping "-[no]sleepidle" which can make
+	  xmame run smoothly on a loaded machine as well as freeing the
+	  CPU so we can do more than just play games... :) This defaults
+	  to -nosleepidle. You can see that it is enabled by an 'S' in the
+	  fps display. There also a T there if throttle is enabled. This can
+	  be toggled runtime with shift + F10. Thanks to William A. Barath.
+	- added upper-bound for autoframeskip "-maxautoframeskip <#>" which
+	  assures a playable framerate even if the emulation can't keep up
+	  with real time. Thanks to William A. Barath.
+	- Made -geometry work for fx and gl versions, it can be used to
+	  specify the windowsize / resolution now. Thanks to Nguyen The Toan
+	- Fixed XIL (again) Thanks to Taso N. Devetzis
+	- Fixed screenshots for 16bpp games. Thanks to Mathis Rosenhauer for
+	  the hint where the problem was.
+	- It turn out that xmame compilation breaks when using egcs-1.1.x or
+	  gcc-2.95, added note to use -fno-strict-aliasing to fix it.
+	  gcc-2.95.1 does work with -fstrict-aliasing, and gives a nice
+	  speed increase.
+	- Quieted make output. Thanks to David R. Hampton
+	- Fixed making of obj/cpu/m68000/m68kops.o to not use implicit rules
+	  this was needed for the quieting to work. This should also
+	  make our openstep users very happy.
+	- Preliminary SDL display target. Thanks to: Tadeusz Szczyrba
+	- Fixed the trailing problem in a lott of dirty using games thanks
+	  to William A. Barath for pointing me in the right direction.
+	- This also fixes the > 7 frameskip values to not skip more frames
+	  then asked.
+
+Release 0.36b3.1
+	- Everything from msdos 0.36b3
+	- Fixed a bug in the new svgalib code which caused modes which are
+	  non tweaked, non planar and nonlinear to stay black / crash.
+	  This should also fix the problems people where having with vector
+	  games.
+	- Fixed svgafx compilation, Thanks to: "Chris, Lo Cheuk Kong"
+	- Fixed svgafx running suid root
+	- Added console switching to svgafx
+	- Removed -fxgamma this was not possible with a clean solution to
+	  suid root 3dfx support.
+	- Fixed 16bpp modes on cards which use 65536 colors instead of 32678
+	  with svgalib, thanks to: William Barath
+	- Workaround for a DGA bug on Matrox G100 cards which causes the
+	  display to be corrupted. Thanks to: d.swanson
+	- Made -listroms respect -stdout-file by: Chris from TKMAME
+	- Fixed xgl compilation.
+	- I couldn't find a clean and portable way to tell Mesa to init glide
+	  without switching to 3d mode, which is needed since glide needs to
+	  be initialised before any commandline parsing is done for security
+	  reasons. Thus setuid root support for Mesa on glide is broken.
+	  Use /dev/3dfx instead. Any help appreciated.
+	- Added autoconf to the cutdown zlib instead of the generic unix
+	  makefile.
+	- Added the original copyright notice to the cutdown zlib (oops)
+	- Removed the .o en .a files from contrib-zlib as distributed,
+	  added removing them to make clean (oops 2)
+
+Release 0.36b2.1
+	- Everything from msdos 0.36b2.
+	- Fixed tweaked mode restoration after console switch with svgalib
+	  for the soon to be releases svgalib 1.4.1 thanks to: Matan Ziv-Av
+	- Fixed the pause(BREAK) key. It should have worked from the start,
+	  I don't know how this bug slipped in.
+	- Fixed the cheat menu.
+	- Added auto doubling of width- or heightscale for 1:2 pixel aspect
+	  games (like goldstar). Use -noautodouble to disable.
+	- Added optimsed scaling code for 1x2x scaling for 1:2 pixel aspect
+	  games (like goldstar)
+	- Added new mode selection code for svgalib and DGA which not only
+	  tries to fill the entire screen but also tries to keep the aspect
+	  ratio correct. Use -nokeepaspect to get the old behaviour
+	  of trying to fill as much screen as possible.
+	  Thanks to: William Barath
+	- Implemented 16bpp modes for X11 in a window, DGA and svgalib. Xmame
+	  uses these modes when available and nescesarry. use -no16bitvideo to
+	  disable them.
+        - Enhanced -disablemode now it is either of:
+          -disablemode XresxYres
+          -disablemode XresxYresxDepth
+          Use it with xDepth to disable a mode just for a certain colordepth
+          Accepted depths are: 256, 65536.
+	- Implemented scaling other then 1x1 and 2x2 for 24bpp packed pixel
+	  modes.
+	- Rewrote joystick handling code to match the new core handling code
+	  Xmame now supports upto 8 joysticks with upto 16 axis / stick and 
+          upto 16 buttons / stick. Adding more sticks/axis/buttons is just a
+	  matter of changing a few #define's now. Since xmame now supports 
+          more then 2 axis -[no]swapjoyaxis has been removed.
+	- Fixed saving of more then 1 snapshot.
+	- Fixed -widthscale 2 -heightscale 1 for DGA and svgalib
+	- Added contrib/modelines. This is a file with a bunch of tweaked mode
+	  modelines for XFree86. Kindly contributed by William Barath
+	- Xmame now saves cfg, sta and mem files in seperate dirs in
+	  $(HOME)/.xmame So if you want to keep your old ones move them.
+	  Files:	Go in / become:
+	  XXX.cfg	$(HOME)/.xmame/cfg/XXX.cfg
+	  XXX.mem	$(HOME)/.xmame/mem/XXX.mem
+	  XXX.sta	$(HOME)/.xmame/sta/XXX.sta
+	  And xmame now searches for game specific rc files as:
+	  $(HOME)/.xmame/rc/<gamename>rc
+	  Thanks to: TKMAME
+	- Added a cutdown version of zlib in contrib which can be used
+	  instead of the system wide version (see makefile.unix). For 
+	  systems which have no or a broken zlib. Thanks to: Matt Lowry
+	- Rewrote svgalib mode selection code (again) now it doesn't use
+	  a static list of modes anymore but queries the available modes
+	  from svgalib like DGA does under X11. This means that special
+	  modes in svgalib replacements like scitech display doctor and
+	  ggi can be used.
+
+Release 0.36b1.2
+	- Added emulation of arcade cabinet lights through the keyboard leds
+	  for svgalib. X doesn't seem to support this, help appreciated.
+	- Added -geometry option, to specify the location where
+	  the xmame window appears.
+	- Added -[no]linear to enable/disable linear framebuffer support with
+	  svgalib. It defaults to off since lfb is broken on some cards.
+	  This fixes the black screen problem some people where having.
+	- Added a keymapping for the ^ key on german keyboards so that the
+	  on screen display works under X.
+	- Reordered the output for -help so that it makes more sense.
+	- Added a few accidently ondocumented options to -help
+	- Fixed xgl, xfx, svgafx and openstep compile. Since I don't have
+	  openstep and / or an 3dfx over here this is untested.
+	- Changed -scale, -widthscale & -heightscale so that they do the
+	  logical thing. Meaning that the last one parsed determines
+	  the scales used.
+	- Added -vectorres <XresxYres>, this scales vectorgames to XresxYres,
+	  keeping their aspect ratio. This overrides the scale options.
+
+Release 0.36b1.1
+	- Everything from msdos 0.36b1
+	- With al the testing of the svgalib code, a bug which has been
+          there for ages has been found and fixed. This bug cause a shifted
+	  and cropped screen with games which require a resolution >= 640x480
+	  and visualsize != size
+	- Rewrote the svgalib mode selection code, -videomode was removed.
+	  Use -[no]tweak and -[no]scanlines instead
+	- Added linear framebuffer support to the svgalib code
+	- Added doublebuffer support to svgalib scaled modes
+	- Added -disablemode <XRESxYRES> option for svgalib this can be used
+	  to disable a specific mode when it gives trouble on your system.
+	  So that for example only one troublesome tweaked mode can be disable
+	  instead of disabling all tweaked modes.
+	- Improved doublebuffer alloc code for XF86DGA, don't malloc the
+	  buffer if it isn't used.
+	- Improved doublebuffer avtivation code it is now also used for
+	  2x2 scanlines mode giving a nice speedup.
+	- Removed the unix-only core-patch to align words according to Nicola
+	  this shouldn't be nescesarry anymore. If you have trouble running
+	  z80 (and probably other) games on non intel machine's. Try applying
+	  the patch, it is in contrib/ as word-align-patch
+	- Changed the xkeymappings back so that the winkeys (META) are mapped
+	  to alt. This was nescesarry to support international keyboards.
+	- Added -[no]winkeys to map the winkeys under X (META) to the winkeys
+	  under xmame. Use this if you have a winkeyboard and want to use
+	  your windows keys under xmame. This option doesn't do anything for
+	  non X versions of xmame.
+	- Added -screenshotdir <dir> to specify where xmame saves the png
+	  screenshots made by pressing F12. It defaults to the current
+	  working dir (.) .
+	- Added the IRIX buggy compiler fix for MWA_NOP to MRA_NOP too,
+	  this should fix a load of games on IRIX. You could ofcourse
+	  also use a real compiler, grrr.
+
+Release 0.35.3
+	- Really fixed the bug in the svgalib code, now it's also
+	  fixed for resolutions >= 640x480, and thus for vector games.
+
+Release 0.35.2
+	- Fixed a nasty bug in the svgalib code
+
+Release 0.35.1
+	- Everything from msdos rc2, 0.35 release + fixes
+	- Some alpha compile and alignment fixes (by Christian Groessler)
+	- Added netbsd-alpha as target (by Christian Groessler)
+	- Some powerpc compile fixes
+	- Windows keys are now recognised and can be used, under X
+	  your X needs to be configured properly for this though
+
+Release 0.35rc1.1
+	- Everything from msdos b13 & rc1 highlights:
+	  - Now all display targets do snapshot in png format
+	  - png support needs zlib, since png is in the core zlib is
+	    now mandatory
+	  - history.dat file location can now be specified
+	- Updated German README
+	- Many changes to the blit-core these include:
+          -use memcpy's to speed up where possible
+          -use doublebuffering when doing direct framebuffer access,
+           and scaling.
+          -simulated scanlines when scaling
+          -hand optimised cases for 3x and 4x inproved generic case
+          Overall this should give a nice speedup in a lott of cases.
+          Much of the work and ideas where contributes by a kind soul whos
+          email and name I've lost. If you read this please mail me so you can
+          be given proper credit.
+        - Don't crash on exit when no suitable DGA mode can be found
+	- Made xmame emmit warnings and continue on errors in xmamerc, instead
+          of emmit errors and exit (By TKMAME)
+	- Made xmame except fxmame and glmame options even when not compiled
+          with fx / gl, it just ignores them.
+	- Added some boundary checks in: sound/adpcm.c and vidhrdw/megasys1.c
+	  this fixes edf in b12. I don't know wether it's still nescesarry in
+	  rc1, thus these changes are backed out and are now available in:
+	  contrib/boundary-check-patch
+
+Release 0.35b12.1
+	- Everything from msdos b11 & b12
+	- Changed the way the makefile handles the generated c-files for the
+	  m68000 c-core again. Now openstep should be happy too.
+	- Changed TRUE -> OSD_OK in a number of sounddrivers this should fix
+	  compile problems for: irix, netbsd_i386 and aix.
+	- Added a spanish tranlation of the readme by Vicente Aguilar.
+
+Release 0.35b10.2
+	- Fixed a bug in the config parsing code which caused core dumps at
+	  start on most non x86 platforms.
+	- Changed the way the makefile handles the generated c-files for the
+	  m68000 c-core. Now it also works with compilers which don't like
+	  object files with an unusual suffix (.og instead of .o).
+
+Release 0.35b10.1
+	- Everything from msdos b10
+	- Updated the debuger code, now it should work again and it looks a
+	  lott better as the old code.
+	- GGI support updated for ggi2.0b2 and some other small fixes.
+	  By Christian Groessler
+	- As requested changed the init sequence for x11 so that -list options
+	  can be used even without a display. This only works for binaries
+	  without DGA support due to security reasons.
+
+Release 0.35b9.1 (Never got released the mame team released b10 before)
+	- Everything from msdos b9.
+	- Updated solaris sound-driver which also supports solaris i386.
+	  Thanks to Mathias for this.
+	- Installed solaris x86, Fixed XIL.
+	- Also fixed mitshm on solaris.
+	- Some fixes to fix-comments to handle nice c-code like: '"' and "\\"
+
+Release 0.35b8.1
+	- Everything from msdos b8.
+	- Note about history.dat:
+	  The new dos-release uses a file called history.dat to display some
+	  nice background info on games. Unfortunatly the location of
+	  history.dat is hardcoded into the core as just history.dat in the
+	  current working directory. Thus if you want to use it you need to
+	  start xmame in the dir where history.dat resides or at least create
+	  a shell script which cd's into this dir before executing xmame.
+
+Release 0.35b7.1
+	- Everything from msdos b7.
+	- Added -listinfo option
+	- Did the rename and move blues, lotts of restructering of the unix
+	  code. End users won't notice this except that it probably has
+	  introduced a couple of bugs ;)
+
+Release 0.35b6.1 (Aka naming releases was fun while it lasted)
+	- Everything from msdos b6
+	- Added 24bpp packed pixel support for X11 by Trent Piepho
+	- Added 24bpp packed pixel and 32 bpp support to xf86-dga
+	- Removed the z80 fix. Jurgen, from the dos team, has fixed the z80
+	  core so that it now works with gcc 2.7.2.x too. Please reports
+	  any new problems with z80 games.
+
+Release 0.35b5.1 (Aka yar (yet another release))
+	- Everything from msdos b5
+	- Fixed a vsb (very stupid bug) which caused xmame
+	  to hang on exit sometimes
+	- Reintroduced the z80 fix from 0.35b2, you only need it if
+	  your using gcc, you can disable the fix in the makefile if your
+	  using egcs for a slight performance increase. This only affects
+	  x86 users. Also note that since the dos-team now is using gcc 2.8.1
+	  more of these bugs might popup, so if you have egcs use it.
+
+Release 0.35b4.2 (Aka the brown paperbag release)
+	- Fix a compile bug in src/unix/config.c
+
+Release 0.35b4.1
+	- Everything from msdos b3 & b4.
+	- contrib/fix-comments.c no longer generate: /*/////*/ but instead:
+	  /*///////////// */
+	- Nicola from the dos-port honored my request and in one go all
+	  ACORN and linux_alpha defines have been changed to ALIGN_INTS,
+	  ALIGN_WORDS and LP64, thanks Nicola
+	- Before parsing $HOME/.xmame/xmamerc xmame now first looks if
+	  $HOME/.xmame/<gamename>rc exists and parses that instead if found.
+	  By Chris (from TKmame) 
+
+Release 0.35b2.1
+	- Everything from msdos b2.
+	- An interesting note from whatsnew.txt,
+	  which might be worth repeating:
+	  Note: the configuration save format has changed. You may just as well
+	  delete all of the cfg/*.cfg files, since they won't be loaded. Old
+	  .inp files will not work either. The good news is that the default
+	  key assignments can now be modified, so you don't have to change them
+	  for all the games. The code is a quick hack put together in fifteen
+	  minutes, but it's bettern than nothing. It will be improved
+	  in future versions.
+	- Worked around the compilation of the z80-core with -DX86_ASM, still
+          working on this with Juergen
+	- Added 16 bit & stereo sound-support. Many thanks to Mike Oliphant
+	  For writing this. Use -mono, -8bit to get the old behaviour back.
+	- Added a new blitting macro, now used for svgalib, X en dga.
+	  taking away a lott of old almost the same code. This also means that
+	  X now uses direct image access even in truecolor modes speeding
+	  things up quite a bit. And update_dsp* files were all removed since
+ 	  since they are now unnescesarry.
+	- The above is really all added bonus, the mean reason was to also
+	  write a generic scaling system. So now dga and svgalib also support
+	  scaling.
+	- Removed -forcetrucolor, since it doesn't do anything anymore with
+	  the new blitting macro.
+
+Release 0.35b1.1
+	- Everything from msdos including autoframeskip use:
+	  -autoframeskip / -noautoframeskip to en-/disable.
+	  It's enabled by default.
+	- Bat wrote snapshot support (F12) for openstep.
+
+Release 0.34.2
+	- Fixed a bug which caused:
+	  X Error of failed request:  BadValue
+	  When running in a window under X11 with a game which doesn't
+	  support dirty, and has a visual area which isn't quad-word aligned.
+
+Release 0.34.1 
+	- Everything from dos 0.34 final
+	- The mouse is now ungrabbed when the window looses focus.
+	- Ggi dirty support, tested with ggi 2.0beta1
+
+Release 0.34rc2.1
+	- Everything from dos rc 2
+	- Added mouse grabbing, press left-alt + page-down to grab the mouse
+	  under X, press it again to release it. Use -grabmouse to start
+	  with the mouse grabbed.
+	- Added invisible mousecursor for people using focus follows mouse,
+	  use -nocursor to make the cursor invisible, grabbing the mouse as
+	  above also makes it invisible. This was kindly contributed by:
+	  Dave Dribin
+	- Removed ROMPATH, SPOOLDIR etc defines from makefile.unix and
+	  replaced them with XMAMEROOT by Christian Groessler
+	- Fully intergrated openstep support, it now no longer needs the files
+	  in contrib, see README.unix
+	- Added sound synchronisation for streamed sound, this should fix
+	  the lag in pacman. This only works when throttle is enabled.
+	- Netbsd-i386 audiobuffer querying support by: Tom Spindler
+
+Release 0.34rc1.1
+	- Everything from dos rc 1
+	- Merged in glmame-0.6 and fxmame-0.5
+	- Fixes for ggi to compile with the latest ggi-snapshot
+	- Some fixes to -verifyroms to now use -stdout-file
+	- Added preliminary openstep support, see contrib/openstep/README
+	  Kindly contributed by Bat.
+
+Release 0.34b8.1
+	- Everything from dos beta 8
+	- DGA now is a compile option for x11, just like mitshm,
+	  use -x11-mode (see -help) to choice between normal window and
+	  DGA, or use left-alt + home as a hotkey to jump to fullscreen,
+	  and left-alt + insert to jump to a window.
+	- Rearranged and rewrote most of the joysticks support, upto 4
+          joysticks are now supported. And you can compile in more then 1
+	  one joytype, and select which one will be used runtime with -joytype.
+	- Support for new linux joystick driver interface, use I386JOYSTICK
+	  if the new headers are found they are automaticly used.
+	  By: Luca Montecchiani
+	- Removed -display commandline option as it intervened with DGA,
+	  sorry about that, use $(DISPLAY) instead, or write a wrapper script.
+	- Added support for mame's internal debugger, see makefile.unix
+	  only enable this if you need it! It's slow.
+	- Which obj files are build in the unix dir is now display-method
+	  dependent.
+	- Unixware7 support by: Richard Cohen
+
+Release 0.34b7.1
+	- Everything from dos beta 7
+	- Completly new dirty code speeding up xf86,x11 and svgalib
+	  quite a bit.
+	- -analogmouse options to emulate a analogjostick through the mouse
+	  very nice for starwars and maybe others.
+	- -verifyroms no also tries to load roms by crc matching the actual
+	  loading behaviour.
+
+Release 0.34b6.1
+	- Everything from dos beta 6
+	- Fixed a bug which caused all checksums to be 0 for non-zipped
+	  files.
+	- Fixed unpause bug.
+	- If not shared with the game, the ui colors are no longer
+	  influenced by brightness and gamma settings.
+	- Made -widthscale, -heightscale and -scale work for vector games
+	  on all supported display-methods, using mame's vector engine todo
+	  the scaling. Also for vector games values like 1.5 and even 0.5 are
+	  now supported.
+	- Spend a lott of time on network support, it should now work for
+	  all displaytargets. Exiting one participant no also exits
+	  the others instead of hanging them. Timeouts implement, if one side
+	  is killed/ connection is broken xmame will continue in single player
+	  mode. The network code can now be concidered stable, but still only
+	  supports keyboard.
+	- Merged in fxmame-0.4 and glmame-0.5
+	- Vector.o and inptport.o are compiled in display_method dependend
+	  dirs now.
+	- Solaris XIL support (hardware scaling) by Elias Martenson.
+	- Preliminary Digital Unix support by Leandro Dardini
+	- Added tkmame frontend to contrib
+
+Release 0.34b5.2
+	- Fixed the __extension__ compile bug, I hope
+	- Fixed the segfault when compile without joystick-support &
+	  joy = 1 in xmamerc
+	- Merged in gl-mame code, many thanks to Mike Oliphant for the
+	  excellent and easy to merge patch. see doc/README.xgl
+	- Merged in net-mame code, many thanks to Eric Totel, for the also
+	  excellent and easy to merge patch. see doc/multiplayer-readme.txt
+	- Added a volume xmamerc and commandline option.
+
+Release 0.34b5.1
+	- Everything from dos-0.34b4&b5, including the profiler, romident
+	  asm 68000! and on screen display.
+	- Removed /dev/audio (uLaw) support from linux, since it
+	  was seriously broken en useless anyway. The audiodevice option
+	  is from now on only usefull to use a second soundcard, see
+	  doc/xmamerc.dist.
+	- Rearranged most of the code in src/unix/fronthlp.c it's a lott nicer
+	  now.
+	- Rewrote src/unix/config.c it was nescesarry adding new options is so
+	  much easier now. This also means that for consistency with the
+	  commandline a lot of options in xmamerc have been renamed and/or
+	  added, please copy xmamerc.dist over, and change it as needed.
+	- Added -fragsize & -numfrags, see -help and doc/README.unix. This 
+	  should help people who experience lagged sound. As a side-result of
+	  this all soundbuffers are now dynamicly allocated and thus all OSS
+	  problems should be gone, please report any remaining problems.
+	- Added -stdout-file and -stderr-file to redirect stdout and stderr to
+	  a file at a highlevel so svgalib doesn't bug us. Only usefull for
+	  frontends, and only influences text printed by the osd part of
+	  xmame, so -list and stuff are redirected, -verifyroms only partial,
+	  and mame-core errors and messages are not redirected at all.
+	- Cleaned up stdout/stderr use:
+	  Stdout is used for requested info like -list options, and -help.
+	  Stderr is used for status and error messages.
+	- Partially rewrote palette-handling no brightness and gamma-
+	  correction are supported, see -help, xmamerc and osd.
+	- Robert Hamberger kindly donated a german translation of the readme.
+	- New irix AL sound support by Tristram Scott, added Tristram as sgi/irix
+	  maintainer.
+	- linux-powerpc is now offically supported.
+	- Added Mathis Rosenhau as sun/solaris maintainer.
+
+Release 0.34b3.1
+	- Everything from dos-0.34b3
+	- Fixed the compilation problem on some platforms in config.c
+	  (missing includes for sys/stat.h and unistd.h)
+	- Speeded up palette cycling under xf86_dga with 8bpp
+	- Rewrote X mouse handling now mouse works under xf86_dga
+	- Added support for 15bpp truecolor visuals
+	- Fixed irix_nosound and aix_nosound targets
+	- Fixed a bug in osd_fseek which caused sample loading to fail,
+	  now samples work as advertised.
+	- Fixed a bug in svgalib & ggi palette handling which caused
+	  some strange effects with translucent vectors.
+	- Updated README.unix to contain who maintains which arch/os
+	  combination and which are currently unmaintained,
+	  maintainers wanted!
+	- Added a section to README.unix on howto work around yet another
+	  bug in the irix c-compiler. See the platform specific hints.
+	- Added doc/TODO
+
+Release 0.34b2.2
+	- Fixed a bug: .cfg files where still saved in ${HOME}/xmame
+	  instead of ${HOME}/.xmame.
+	- On startup existence of ${HOME}/.xmame is verified and created
+	  if nescesarry
+	- On startup a check is done to see if compiled- and
+	  runtime-endianess match (actually this has been there for
+	  a few releases now but I forgot to mention it ;)
+	- Some minor updates to README.unix
+	- One note: /usr/games/lib/mame has been changed to
+	  /usr/games/lib/xmame for concistency. So rename it, or use the old
+	  setting in xmamerc.
+
+Release 0.34b2.1
+	- Everything from dos-0.34b2.
+	- Everything unix from xmess-0.2b4.1:
+	  *Fileio no supports gzipped files and a search path, see README.unix
+	   Note: This means that you have to change mamedir to rompath
+	   in your xmamerc.
+	  *Updated README.unix to contain info on both xmess and xmame
+	   not only on xmame.
+	  *The title and other reference to xmame/xmess and version are now no
+	   longer wrapped in ifdef's but instead are taken from defines set by
+	   the makefile so to change the version no, or the name only the 
+	   makefile has to be changed from now on.
+	- Changed ${HOME}/xmame to ${HOME}/.xmame on popular request so
+	  move that dir ;)
+	- Makefile.objs no is no longer autogenerated due to some changes
+	  in the dos makefile. These changes do mean that the number of objs
+	  on the commandline at once have been greatly reduced. So those
+	  who got a cmdline to long error shoould be happy now.
+	- Updated contrib/porting.txt to include the manual creation of
+	  makefile.objs. Added contrib/lowercase which is used for this.
+	- Changed fix.c to fix-comments.c which is a more accurate name.
+	- Removed autogeneration of makefile.objs from make-makefiles.pl
+	  renamed it to fix-includes
+	- Updated fix-mame to match the name changes of fix and
+	  make-makefiles.pl .
+	- General clean-up and restructering of README.unix with much thanks
+	  to: Joseph E. Miele
+	- The x86-asm m6808 core now also works on other i386 unices, thanks
+	  to: Christian Groessler
+
+Release 0.34b1.1
+	- Everything from dos-0.34b1.
+	- Intergrated xf86-dga support.
+	- Hardware palette cycling (as promised way too long ago).
+	  It's enabled automaticly, you'll receive a notice of this.
+	  Under XFree86 it only seems to work on 8-bit displays with
+	  a private colormap (-privatecmap).
+	- Changed makefile so that you now choose:
+	  a) arch
+	  b) display method
+	  So we no longer have linux-svgalib and linux-x and linux-ggi and
+	  linux-xf86-dga. This esp makes sence since ggi and xf86-dga are
+	  also supported on other arch's.
+	- Added soft-klipping to the soundmixer. Actually done in 0.33.1
+	  but I forgot to mention it there.
+
+Release 0.33.3
+	- Again fixed the m6808 asm core, this time a work around for
+	  gnu-make not liking a long dep chain.
+
+Release 0.33.2
+	- Fixed a minor bug which made the compilation of the x86-asm 
+	  m6808 cpucore fail.
+
+Release 0.33.1
+	- All the changes from dos-0.33(final).
+	- Workaround for an of by one bug in newer oss (the linux sound driver)
+	  versions. This caused the big delay for this release and hopefully
+	  is now solved.
+	- Workaround for an obscure irix compiler bug this means irix is
+	  now fully supported, but don't use DCC !
+	- Added contrib/xnetmame.tgz this contains files for (beta) network
+	  play.
+	- Added contrib/esound.diff, apply for sound output to the esound
+	  deamon, this patch will be included in a newer version.
+	- Added contrib/xf86-dga.diff, apply for xfree86 dga support, this
+	  patch will be included in a newer version.
+	- Updated contrib/mamex to work with newer versions of mame.
+	- Added contrib/mamex.new, an enhanced version.
+
+Release 0.33rc1.1
+	- All the changes form dos-0.33rc1
+	- Automated the porting process a bit, changed contrib/make-makefiles.pl
+          not to generate a malloc-lines log. Since this is not nescesarry
+	  anymore. Added contrib/fix-mame. See contrib/porting.txt for
+          a quick description on how to use these porting tools, to get a new
+          dos version ported to unix.
+        - Part of these automation changes it that the objs generated by
+	  make-makefiles are now used in makefile.unix by including
+	  makefile.core.
+        - Due to the above changes also all core-filenames have been made
+	  lowercase, finally bringing unity.
+	- Changed the compiler hints in README.unix not to use DCC,
+	  since that was a bad advice which was causing the malloc trouble in
+          the first place. We still have irix problems when using -n32
+	  which are being looked into. For now use -o32 when compiling.
+	- Added support for the m6808 asm cpu core, it has its own flag in the
+	  makefile and defaults to off, this is only tested for linux-x86-elf
+	  if anyone wants to get it to work on other x86 archs feel free
+	  todo so. And please mail me your results. This requires a copy
+	  of nasm, a free x86-asembler, in your path. 
+	- Added 16 bit sound calls support.
+
+Release 0.33b7.1
+	- All the changes form dos-0.33b7, including a new frontend
+	  option (-listclones).
+	- Fixed the volume after menu setting bug, for real this time
+	- Split update_dsp into true- and pseudo-color specific files,
+	  with the hope to one day add a 16 bit mode truecolor variant
+	- Cleaned up the error handling in the creation of the X display
+	- When running xmame on a remote console mit-shm doesn't only fail
+	  but it even tells you it failed amasing isn't it?
+
+Release 0.33b6.1
+	- All the changes form dos-0.33b6, including some new frontend
+	  options (-listgames, -noclones).
+	- Cleaned up keyboard-handling a bit.
+	- Changed osd_analog_read to match the new syntax.
+	- Added -root_window_id [id] cmdline option to create the window
+	  within an existing window, to be used with frontend's
+	- Added a credits.unix file, if you think you deserve an entry please
+	  remind me, I don't remember all contributers.
+
+Release 0.33b5.1
+	- Just a port of dos-0.33b5, using the unix tree from
+	  0.33b4.1. Nothing new on the unix-end but the main MAME team has
+          added a few new goodies to this release.
+
+Release 0.33b4.1
+	- Basicly a port 0f 0.31.1 to 0.33b4
+	- added 320x240 and 320x400 to svgalib-version
+	- some changes to support the new 0.33 layer code
+
+Release 0.31.1
+	- A lott has happenend since the last release, before this release
+	  there have been a lott of beta's. And I (Hans) have taken over as
+	  main coordinator. This release fixes all known bugs to previous 
+	  release's. And we've done our best to make this the best release
+	  ever. In the switching and the quick beta-period to catch up,
+	  changes have got lost however. The Changes file will be updated from
+	  here on again.
+
+Release 0.30.1
+	- Just a patched Mame-0.30 version
+
+Release 0.29.3
+	- Added GGI ( General Graphics Interface support )
+	- Added zlib support
+	- Preliminary autoconf support
+	- Some minor fixes
+
+Release 0.29.2
+	- Now osd_clearbitmap() uses named pen instead of default 0
+          this solves several color bugs in atari vector games
+	- Added xmame.man manual page. Thanks to Donald Burr
+          Moved src/unix/xmamerc.dist to doc
+	- Added "bindist" and "srcdist" options to makefile, for easy 
+	  making of a source/binary distribution
+	- Fixed missaligned integer pointer bug in src/sndhrdw/pokey.c
+	- Some incongruent items in Copyright license has been changed
+	- Created and moved documentation to doc directory
+	- Intensive work of cleanning non-ansi and warnning items
+	- Added UnZip-on-the-fly support for ROM's and Samples.
+	  Thanks to Tomi Ollila for the unzipper code
+	- Support for dirty lines speedup strategy in X
+	  via -DUSE_DIRTY and -DDIRTY_RFSH makefile.unix options
+	- Added support for Linux/X11/PowerPC. Thanks to Andreas Varga
+	- Now "-list" and "-listfull" options writes to stdout, to 
+	  allow interface with loaders
+	- fixed bug in sndhrdw/starforc.c that makes sound too slow
+	- fixed bug in src/unix/xdep.c that made incorrect graphics and
+	  cores in swaped-xy games when X & Y scale differs
+
+Release 0.29.1
+	- Original Mame-029 sources ported to UNIX by Hans de Goede
+	- Added "-[no]xsync" and "use_xsync" commandline/config option
+	  To select between XFlush() or XSync() screen refresh method
+	- Added "spooldir makefile/config/commandline configurable option
+          to store high scores
+	- Now .xmamerc and per-game user configurations parameters are moved
+	  and stored into ${HOME}/xmame/ directory
+	- New file update_dsp.c to code video update routines
+	- Added -devdsp and -devaudio options to allow selection of audio
+          device in those systems that has no /dev/audio
+	- Added -showconfig cmdline option to display current running parameters
+	  in a xmamerc-like style 
+	- Now -DUSE_TIMER works on svgalib. Thanks Hans
+
+Release 0.28.2
+	- Added Solaris/ix86 support
+	- Added Linux/Alpha support
+	- Fixed several bugs in 8910intf.c to makes core in init sound
+	- Changed Keyboard code to reset key table when entering/leaving
+	  XMame window
+	- Lots of porting errors solved
+	- Solved (again) missalingned int problems in src/common.c:drawgfx()
+	  Blames to Intel for trying to correct programmer errors instead a
+	  clean core
+
+Release 0.28.1
+	- A Mix between official 0.28 Mame and XMame 0.27.2
+	- Changed "static char *single" for "static char *_single" in 
+	  src/sndhrdw/starforc.c due to a solaris varname conflict
+	- Added -ror, -rol -flipx, -flipy, -cheat commandline options
+	- Changed osd_obtain_pen() to use double-indexed color array for
+	  cell allocation. This makes pseudocolor mode as slow than truecolor
+	  but no esay way to bypass problem ( private colorcell is a color
+	  waster strategy )
+	- New fix.c code to make port easy. Thanks Hans
+	- Added ultrix support
+
+Release 0.27.2
+	- Created new directory contrib. Waitting for your works...
+	- Added support for ix86/BSDi. Thanks Tom <tom@toetag.com> for Patches
+	- AUDIO_TIMER_FREQ #define moved to makefile sound options
+	- Finally I got xmame running for 8bpp, 16bpp, 24bpp and 32bpp Xservers
+	  No easy way to get 1 ( monocrhome ) and 4 ( 16 colors ). Sorry
+	- Solved Audio bug in non-i386 machines ( audio buffer mixer works in
+	  unsigned char fashion, and every others audio devices likes signed 
+          ones )
+	- Support for trackball emulation and mouse
+	- Universal Joystick support:
+	    - Patch for FM-TOWN game key pad joystick emulation (Linux)
+	    - i386 joystick driver rewwriten. ( finally does diagonal correctly )
+	    - Joystick support via X11 Input Extensions for "any" XServer that
+	      supports them
+	- Changed common.c to solve unaligment problem that causes SISEGV cores
+	- makefile.unix changes. Lots of new switches ( perhaps it's time to
+	  create a configuration script.. )
+	- Solved bug that make change settings not to work ( TAB key )
+
+Release 0.27.1
+	- Hans de Goede did the work during my little holidays. Every one
+	  thank's him
+	- Linux SVGALIB support
+	- Now osd_play_streamed_sample() works (yes, finally !!! )
+	- src/sndhrdw/starforc.c static char *single changed to _single due
+	  to solaris previous definition
+	- Added samplefreq and videomode command line options ( only have 
+	  sense in linux .... )
+	- Changed (again) every PI items to POSIX M_PI .Mirko, please...
+	
+Release 0.26.3
+	- Changes in makefile.unix and readme.unix. 
+	- src/drivers/digdug.c bug fixed ( but still remain a bug: if
+          no key pressed soundtrack stops.... )
+	- New commandline options
+	- Support sound on netbsd_i386 and freebsd
+	- xdep.c scaling bug fixed
+	- Added missing function in system-dependent code
+	- osd_play_streamed_sample() in src/unix/sound.c improved 
+	  ( needs further work... )
+
+Release 0.26.2
+	- Now timer based audio works again
+	- Fixed several non-linux related audio bugs
+	- Changed src/mame.c to optimize arg search and make unix help
+	  available
+	- readme.unix updated . READ CAREFULLY before trying to compile
+	- X-Events scanning routine changed and optimized 
+	- Several minor bugs and ANSI warnnigs fixed
+
+Release 0.26.1
+	- Original sources from Mame0.26.1 patched for Hans De Goede
+	- Entire code "ANSI'ed" 
+	- Added global xmamerc file parsing
+	- Makefile structure changed. READ AND EDIT CAREFULLY BEFORE COMPILE
+	- New Sound Code!! no more timer in those systems that allows query
+	  free space in sound driver 
+	- Improved mixer. Settable FANCY_SOUND to perform a linear interpolation
+	  Play it!! you'll see the difference
+	- Optimized video code for 2x and 3x scales
+
+Release 0.23.3 
+
+	- Added Joystick support under NetBSD
+	- Fixed bug to bypass upper/lowercase names ROM filenames
+	- Lot of portability bugs fixed
+	- An optional sound.c.new code included. Perhaps you'll want to
+	  test and improve...
+
+Release 0.23.2
+
+	(Thanks to entropy@zippy.bernstein.com for patches)
+	- Fixed stupid bug in src/common.c:readbit();
+	- Added support for i386/NetBSD ( No sound. sorry )
+	- Now MAME-023 new games doesn't core
+
+Release 0.23.1
+
+	- Patched from Official MAME 0.23
+	- Now you can make snapshots ( needed Xpm Library )
+	- MAME-023 FM music synthesis doesn't work (yet)
+	- New makefile.unix to allow enable/disable sound in IRIX and SGI
+	- Lot of improvements and bugfixes
+	- NOTE: some newer games dumps core in fgx routines. still
+	  working on it. sorry :-(
+
+Release 0.22.1
+	
+	- Patched from Official MAME 0.22
+	- Included unix code from 0.21.7
+
+Release 0.21.7
+
+	- Added AIX sound support. Thanks to Chris Sharp
+	- Added "-privatecmap" command line option and "private_colormap"
+	  .xmamerc parameter to enable use of private color maps
+	- Now sounds works again ( more work on sound server included )
+	- Lots of bugs and **IX porting problems solved
+	- New readme.unix with FAQ and installation guide
+
+Release 0.21.6
+
+	- Patched from Official MAME 0.21.5
+	
+Release 0.21.1
+
+	- Mixed 0.20.3 with official MAME 0.21 sources
+	- Makefile.unix changed
+	- UNSTABLE. needs further work
+
+Release 0.20.3
+
+	- Support for HP-UX and AIX
+	- Adecuate use of DISPLAY and MAMEDIR environment variables
+	- Support for -help command line option
+	- Support for ${HOME}/.xmamerc configuration file
+	- Support for keyboard remapping
+
+Release 0.20.2
+
+	- Directory src/unix rewritten. no longer a big unix.c
+	- A src/unix/Makefile is provided to create osdepend.a library 
+	- ( Now I can start doing real work in a clean environment )
+	- File makefile.unix adapted to new src/unix structure
+	- changed macro PI ( non-posix ) for M_PI in some files under
+	  directory src/sndhrdw
+ 
+Release 0.20.1
+
+	- Check for available 8bit depth Visual. if no, warns and quit
+	- Check for available and runable MIT-SHM. 
+	- Added command line -display "displayname"
+	- Added command line -nomitshm to disable use of MIT shared memory
+	- Rewritten most of video code
+	- Several bugs fixed
+
+Release 0.20
+	
+	- Finally Mame and X-Mame converges!!!
+	- osd_update_display() rewritten. Should work at least two times
+	  faster
+	- osd_poll_joystick() patched to allow simultaneous x&y movements
+	  when really desired ( Linux )
+
+Release 0.19.1
+May-2-1997
+	- Corrected 0.19 sources to compile & run unde UNIX
+	- Some POSIX'ing work
+	- Corrected 0.19 bug that makes phoenix and pleiads unrunables if
+	  not sound samples availables
+
+Release 0.19 
+April-29-1997
+
+	- Official 0.19 sources. Due to a bug in building distribution doesn't
+	work neither compile under UNIXes
+
+Release 0.18 patch level 2
+April-25-1997
+
+	- Modify Makefile.UNIX, to support simultaneous multi-architecture
+	  compiling
+	- Set up hierachies obj.arch
+	- Correct source files to support non-gcc ansi compilers
+	- Added -DINLINE=static to specific irix native compiler CFLAGS in 
+	  Makefile.UNIX
+	- Added support for Sparc SUNW,dbri audio chipset
+
+Release 0.18 patch level 1
+April-24-1997
+
+	- Added support for Audio on SGI Irix machines ( tested on a SGI Indy )
+	- Corrected posix undefined PI macro in math.h
+
+Release 0.18
+
+	- Original sources from repository
+
+SOUND TESTED ON:
+	linux (i586/133) sounds acceptable
+	Irix  (SGI Indy ) near nice
+	Solaris ( Sparc5 SUNW,CS4231 ) poor, but usable
+		( Sparc1+ SUNW,am79c30 ) horrible, better dont use
+		( Sparc10 SUNW,dbri ) need more work ( too delayed and tickly )
+	AIX	( Reported by Chris Sharp <sharp@hursley.ibm.com> )
+		
+KNOWN BUGS ( ONLY UNIX SPECIFIC INCLUDED ):
+	- AUDIO_TIMER_FREQ is machine dependent
+	- Cannot correctly control audio channels in Sparc ( doc wrong :-( )
+	- Low quality in audio
+	- Some games send long sound samples ( like soundtracks ) that overruns 
+	  buffers and make core : -( 
+	- Some games dump core when exiting. Don't know why...
+
+TODO:
+	- Make it runnable in servers that has no support for 8-bit depht
+	  Visuals ( Actually warns and exit )
+	- Support for kernel in-built n-channel mixer in Irix
+	- Joystick support under Irix ( using the analog input port )
+	- Rewrite mixer and buffering sound module
+	- Full support of Sparc sound ( lots of bugs in actual one )
+
+Please send patches, bugfixes, suggestions, blames, and money :-) to me,
+hans@highrise.nl
+
+See X-Mame http://x.mame.net
+
+	Enjoy!!!!
diff --git a/src/unix/doc/dga2.txt b/src/unix/doc/dga2.txt
new file mode 100644
index 0000000..16f53ef
--- /dev/null
+++ b/src/unix/doc/dga2.txt
@@ -0,0 +1,34 @@
+Xmame DGA2 Video Driver Documentation
+
+November 27, 2001.
+
+Before reporting a bug, please
+------------------------------
+- Check the blacklist below.
+- Check at the end of this document for known bugs/behaviour.
+
+Blacklist of buggy XFree86(4.1.0) and Non-Free drivers
+------------------------------------------------------
+IMPORTANT: These are not xmame's bugs.
+mga     - DGA does not work with the Matrox HAL module.
+nvidia  - the driver before v0.96 is buggy.
+radeon  - only DGA1 works. (already fixed in XFree86 CVS.)
+s3virge - all DGA support seems broken. (Use XFree86 3.3.x.)
+tdfx    - some people reported DGA does not work with Voodoo3.
+          (fixed in XFree86 CVS?)
+
+Tips - DGA1 under XFree86 4.x
+-----------------------------
+Change the if statement in src/unix/video-drivers/xf86_dga.c at line 62
+
+"else if (i >= 2)" to "else if (0)"
+
+and xmame will now always use DGA1 instead of broken DGA2.
+(This is a kluge. Bugs should be reported to XFree86@XFree86.org.)
+
+Known Bugs/Behaviour
+--------------------
+- Switching to fullscreen DGA mode and then quitting xmame screws up the
+  keyboard.  Apparently this has something to do with xmame losing the ctrl or
+  alt release codes; pressing ctrl or alt a few times should restore the
+  keyboard to a sane state.
diff --git a/src/unix/doc/img/xmame.jpg b/src/unix/doc/img/xmame.jpg
new file mode 100644
index 0000000..3e03aba
Binary files /dev/null and b/src/unix/doc/img/xmame.jpg differ
diff --git a/src/unix/doc/liesmich.unix b/src/unix/doc/liesmich.unix
new file mode 100644
index 0000000..2347953
--- /dev/null
+++ b/src/unix/doc/liesmich.unix
@@ -0,0 +1,1258 @@
+**********************************************************************
+Xmame/Xmess Installationsanleitung (frei bersetzt aus dem Englischen)
+**********************************************************************
+Note: If the rest of this file is incomprehensible to you, that's
+      because it contains the german version of the readme.unix.   
+
+
+Englisches Original:
+====================
+
+Erstmals erstellt:	20. Mai 1997 von Juan Antonio Marmnez
+			(jantonio@dit.upm.es)
+
+Letztes Update:		10. August 1999 von Hans de Goede
+			(hans@highrise.nl)
+
+
+Deutsche bersetzung:
+=====================
+
+Erstmals erstellt:	09. Oktober 1998 von Robert Hamberger
+			(rh474@bingo-ev.de)
+
+Letztes Update:		03. Juli 2000 von Robert Hamberger
+			(rh474@bingo-ev.de) 
+
+
+Anmerkung: 
+Die neueste Version der englischen Anleitung ist immer auf der
+Homepage des xmame-Projekts ( http://x.mame.net) zu finden.
+
+Die neueste Version der deutschen Anleitung findet ihr auf meiner
+Homepage ( http://www.bingo-ev.de/~rh474) und auch auf der neuen
+XMame-Homepage (http://x.mame.net/german.html).
+
+
+Vorbemerkung zur deutschen bersetzung:
+Fr Leute, die englische Texte nicht besonders gut verdauen, habe ich
+das englische readme.unix bersetzt. Die deutsche bersetzung wurde
+nach besten Wissen und Gewissen erstellt.
+Ich hoffe, da alles richtig "rberkommt".
+Eventuelle Rechtschreibfehler sind weder gewollt, noch beabsichtigt,
+deshalb schiebe ich sie einfach auf die Rechtschreibreform ;-).
+
+
+Inhalt:
+*******
+1. Xmame/xmess hufig gestellte Fragen (FAQ)
+2. Compilieren, Einrichten und Starten von Xmame/Xmess
+3. Was noch getan werden mu / Was nicht vorwrts kommt
+4. Mail
+5. Anmerkungen zum Compilieren bei bestimmten Betriebssystemen
+6. Copyright und Legalittsbedingungen
+7. Die "Macher" des Mame- und Mess-Projektes
+
+**********************************************************************
+1. Xmame hufig gestellte Fragen
+**********************************************************************
+
+Was ist Mame ?
+
+	Mame ist ein Emulator fr die Arcade-Maschinen aus den 
+	Spielhallen. Nicola Salmoria begann 1997 mit Mame. Es entstand
+	aus einer ganzen Reihe Emulatoren, die fr jeweils nur ein Spiel 
+	geschrieben worden waren. Diese Einzelemulatoren wurden 
+	kombiniert zu einem "Multispiele Emulatorformat". Dies ist die 
+	aktuelle Form von Mame, kein Projekt eines Einzelnen, sondern
+	es arbeiten ber 100 Personen daran.
+
+	Geschaffen wurde Mame von Nicola Salmoria.
+
+
+Was ist Mess ?
+
+	Mess ist, wie Mame, ein Emulator fr virtuelle Maschinen. 
+	Im Unterschied zu Mame emuliert Mess Computer und Konsolen.
+
+
+Was ist Xmame/Xmess ?
+
+	Xmame/Xmess sind die Unix/X11-Konvertierungen des Mame- und 
+	Messprojektes. Somit sind Mame/Mess verfgbar auf 
+	*ix-Maschinen, die XWindows X11R6 untersttzen 
+	(ebenfalls SVGAlib/ggi/XF86-DGA), also z.B. Linux.
+
+	Die erste Mame-Konvertierung stammt von Allard Van Der Bas, 
+	Dick the Ridder und Juan Antonio Marmnez.
+
+	Xmame/Xmess wird zur Zeit gepflegt von Hans de Goede.
+
+
+Was sind die Unterschiede zwischen Mame/Mess und Xmame/Xmess ?
+
+	Eigentlich keine ;-)
+
+	Xmame/Xmess basieren auf dem Sourcecode von Mame/Mess.
+	Aus technischen Grnden, die den Rahmen dieses Dokuments 
+	sprengen wrden, kann der Mame/Mess-Sourcecode nicht unter 
+	Unix bersetzt werden. 
+	Deshalb existiert das Xmame/Xmess-Projekt. Jedes mal, wenn 
+	Mame/Mess upgedatet wird, wird das Coding unter Unix getestet 
+	(und gepatched, falls dies ntig ist). Somit sind die 
+	Xmame-/Xmess-Releases immer auf dem selben Stand, wie die 
+	Originale.
+
+	Es existieren keinerlei Plne fr eine unabhngige 
+	Entwicklung von Xmame/Xmess.
+
+
+Welche Hardware und welche Betriebssysteme werden untersttzt ?
+
+	XMame luft auf Low-End und auf High-End CPU's, benutzt
+	beschrnkten Integer-Zugriff wenn ntig und ist auch
+	compatibel mit 64-bit CPU's.
+	Die aktuelle Liste der untersttzten CPU's im Makefile ist:
+	- i386 + gnu-asm
+	- i386 no asm
+	- Alpha
+	- m68k
+	- generic risc (PowerPC, Sparc, HPPA, IBM)
+	- generic risc, lsb-fist (RISC (Ultrix Maschinen))
+	- Mips (generi risc + SGI Compiler bug workarounds)
+	
+	Das Hinzufgen von Untersttzung anderer CPU's (falls ntig)
+	sollte einfach sein.
+
+	Die folgenden Unix-Plattformen werden im Speziellen untersttzt:
+	- Linux
+	- FreeBSD
+	- NetBSD
+	- Solaris (SunOS)
+	- OpenStep (Sound funktioniert derzeit nicht)
+	- Mac OS X (Sound funktioniert derzeit nicht)
+	- IRIX mit Sound bei Verwendung des dmedia Paketes oder des
+	  neuen al Paketes (Sound funktionert derzeit noch nicht)
+	- AIX (Sound funktioniert derzeit nicht)
+	- generic Unix, kein Sound
+	
+	Der Eintrag "generic unix" sollte fr jedes Standard Unix 
+	funktionieren, aber kein Sound, da derzeit kein einziger
+	Standard fr Sound unter Unix existiert.	
+
+	Auf allen Plattformen wird nun zlib bentigt, weil die DOS-Version
+	dies nun auch benutzt. Wenn Du die zlib nicht hast, dann kannst Du
+	die mitgelieferte benutzen. Es mssen nur die betreffendende Zeile
+	im Makefile auskommentiert werden.
+
+	Die folgenden Anzeigearten werden untersttzt, wobei X11 als
+	Einzige auf allen Plattformen luft, ausser OpenStep und 
+	Mac OS X, wo nur die OpenStep Bitmaps funktionieren:
+	- X11 (X-Fenster)
+	- SVGALib
+	- GGI (Generic Graphics Interface)
+	- OpenGL mit X11 fr die Eingabe
+	- OpenGL mit SVGALib fr die Eingabe
+	- GLIDE mit X11 fr die Eingabe (3dfx)
+	- GLIDE mit SVGALib fr die Eingabe (3dfx)
+	- OpenStep Bitmaps 
+	- SDL (Simple Direct Medialayer)
+
+	
+	Die folgenden Kombinationen aus Architektur/BS/Anzeige
+	werden derzeit aktiv untersttzt. Bitte an den jeweils
+	Zustndigen Mailen, wenn Problem mit einer bestimmten
+	Kombination aus Architektur/BS/Anzeige beim bersetzten
+	oder anderen Problemen auftreten. Eine Mail ans Hans
+	hans@highrise.nl bei allgemeinen Problemen (z.B. X11).
+
+	Arch./BS/Anzeige		Zustndig
+
+        i386/linux/x11 (+DGA)     Hans <hans@highrise.nl>
+        i386/linux/svgalib        Hans <hans@highrise.nl>
+        i386/linux/xgl            Hans <hans@highrise.nl>
+      	i386/linux/xfx            Hans <hans@highrise.nl>
+     	i386/linux/svgafx         Hans <hans@highrise.nl>
+      	i386/linux/ggi            Christian <cpg@aladdin.de>
+      	alpha/linux/x11           Christian <cpg@aladdin.de>
+      	alpha/digital unix/x11 *  Leandro <ldardini@usl4.toscana.it>
+      	powerpc/linux/x11         Andreas <sid@skater.htu.tuwien.ac.at>
+      	powerpc/linux/svgalib     Andreas <sid@skater.htu.tuwien.ac.at>
+        i386/freebsd/x11          Jacob A. Hart <c9710216@studentmail.newcastle.edu.au> 
+      	i386/netbsd/x11           Dave <dave@dtsp.co.nz>
+      	alpha/netbsd/x11          Christian <cpg@aladdin.de>
+      	Sparc/Solaris/x11         Mathis <rosenhau@mailserv.sm.go.dlr.de>
+      	i386/Unixware7/x11     *  Richard <xmame@frogface.ddns.org>
+      	i386/openstep             Pete French <pete@toybox.twisted.org.uk>
+      	Sparc/SunOs               Saga <jolletx@cybercable.fr> 
+	mips/irix/x11		  Dingus Family <ddingus@usewest.net>
+
+	* Dies wird bei der Benutzung des Eintrages "generic unix" im 
+	  Makefile untersttzt und bietet keinen Sound
+
+	Wir suchen immer nach Leuten, die neue Kombinationen aus
+	Architektur/BS/Anzeigeart testen und auch aufkommende Fragen
+	dazu beantworten knnen. Dies kostet nicht viel Zeit und
+	kann anderen Leute enorm weiterhelfen. Wenn Du Interesse hast,
+	dann eine Mail an hans@highrise.nl .
+
+
+Mein System wird untersttzt aber Xmame/Xmess bricht mit Fehlern ab. Warum ?
+
+	Xmame/Xmess sollten laufen in einem 8bpp Pseudo-Farben-Display 
+	und in einem 16, 24 oder 32bpp True Color Display. 
+	Wenn der X-Server keine dieser "Displays" untersttzt, dann 
+	wird Xmame/Xmess auch nicht funktionieren.
+
+	Um herauszufinden, was der X-Server untersttzt, kann man 
+	das Tool xdpyinfo benutzen. Mehr Info auf der Manpage 
+	von xdpyinfo.
+
+
+Wie aktiviere ich die XinputExtensions fr X11 und Joystick in Xfree86 ?
+
+	Die XF86Config mu editiert werden, um die XInput-Sektion zu 
+	aktivieren. Nheres bietet die Manpage von XF86Config.
+
+
+Wie lese ich denn eine Manpage ?
+
+	Echt einfach. Um beispielsweise die Manpage von XF86Config
+	zu lesen, einfach man XF86Config eintippen. ;)
+
+
+Warum funktionieren bei meinem Joystick die diagonalen Bewegungen 
+nicht richtig ? (nur x86 System)
+
+	Xmame/Xmess benutzt automatische Kalibrierung. Aber man kann
+ 	spezielle Programme zum Kalibrieren benutzen. (jscal - beim 
+	Joystick-Module dabei - funktioniert ausgezeichnet ...)
+
+
+Wozu sind eigentlich die Dateien xmamerc/xmessrc da ?
+
+	Ein Aufruf von Xmame/Xmess kann so aussehen:
+
+		xmame pacman -sound -nojoy -frameskip 2 \
+		-heightscale 3 -widhtscale 2 
+
+	Meist wird man die gleiche Einstellung fr jedes Spiel 
+	nutzen.	Xmame/Xmess liest diese Datei fr die 
+	Grundeinstellungen der Parameter, die gesetzt werden knnen.
+	Auf diese Weise mssen nur die Parameter beim Aufruf
+	angegeben werden, die berschrieben werden sollen.
+
+	Ein anderer Grund fr xmamerc/xmessrc ist die Umbelegung 
+	von Tasten. Einige Unix-Tastaturen weichen stark von 
+	PC-Tastaturen ab. Um dies abzufangen, kann man in 
+	xmamerc/xmessrc Tasten belegen/umbelegen, die auf 
+	Unix-Tastaturen nicht vorhanden sind.
+
+
+Was ist die Syntax der xmamerc/xmessrc-Datei ?
+
+	Die Syntax ist sehr einfach:
+	"Schlsselwort Wert"
+
+	Siehe auch in doc/xmamerc.dist fr die meisten der 
+	Schlsselwrter. Fast alle Kommandozeilen-Optionen
+	knnen als Schlsselwrter (ohne das -) benutzt werden,
+	benutze einfach den Wert 0 oder 1 fr Kommandozeilen-
+	Optionen, die als Gegenstck die verneinende Option
+	(-no(option)) haben.
+	blicherweise beginnen Kommentarzeilen mit einem "#".
+
+	Du kannst natrlich eine Konfigurationsdatei erstellen
+	mit allen Einstellungen. Eine Vorlage kann man mit
+	"xmame -showconfig > ~/.xmame/xmamerc" erzeugen.
+
+
+Wo kommen denn die Roms, Images, Samples, Highscores, Config-Dateien usw. hin ?
+
+      - Roms/Samples
+
+	Xmame/Xmess suchen in einem durch ":" getrennten Pfad 
+	nach Roms/Samples/Artwork. Der Defaultpfad ist XMAMEROOT und wird 
+	whrend des Compilierens gesetzt im Makefile. Dieser Pfad
+	kann durch einen beliebigen Pfad in xmamerc/xmessrc ber-
+	schrieben werden.  Dies kann wiederum durch die Kommando-
+	zeilen-Option -rompath berschrieben werden. 
+
+	Xmame/Xmess durchsuchen jedes Verzeichnis in dieser Pfadangabe 
+	nach Roms/Samples auf folgende Weise:
+	<dir>/spielname.zip		 (enthlt dateiname.ext)
+	<dir>/spielname/dateiname.ext
+	<dir>/spielname/dateiname.ext.gz (enthlt dateiname.ext)
+	<dir>/spielname/dateiname.zip	 (enthlt dateiname.ext)
+
+	Ein Beispiel: es wird nach der Datei rom0001.1 gesucht, die 
+	ein Teil des Spiels Pacman ist. Xmame/Xmess suchen in jedem 
+	Verzeichnis des Suchpfades nach:
+	<dir>/pacman.zip		 (enthlt rom0001.1)
+	<dir>/pacman/rom0001.1
+	<dir>/pacman/rom0001.1.gz	 (enthlt rom0001.1)
+	<dir>/pacman/rom0001.zip	 (enthlt rom0001.1)
+
+	Bemerkung: Wenn Deine NeoGeo-Spiele die Datei neogeo.rom nicht finden,
+	dann kopiere es in ein Verzeichnis namens neogeo im Suchpfad nach Roms
+	oder packe es in die Datei neogeo.zip im Suchpfad nach Roms.
+
+      - Rom Cartridges/Disketten Images
+
+	Xmess beginnt bei der Suche nach Cartridges/Disks vom aktuellen Verzeichnis
+	in folgender Art und Weise:
+
+	<dir>/image.ext
+	<dir>/image.ext.gz 		 (enthlt image.ext)
+	<dir>/image.zip			 (enthlt image.ext)
+
+	Wenn der Pfad der Pfad ist, der mit einem Image auf der Kommandozeile
+	angegeben wurde, dann knnen auf diese weise absolute und relative 
+	Dateinamen direkt von der Kommandozeile aus benutzt werden fr ein
+	Image, selbst wenn es nicht im Suchpfad fr Roms ist.	
+
+	Dann sucht XMess in jedem Verzeichnis dieses Pfades nach Carts/Samples 
+	auf folgende Art und Weise:
+	<dir>/image.ext
+	<dir>/image.ext.gz		 (enthlt image.ext)
+	<dir>/image.zip			 (enthlt image.ext)
+
+	Zu Letzt sucht XMess im Rompfad (wie oben beschrieben) unter Benutzung
+	des Systemtyps (NES, Gameboy, ...) nach dem Spielenamen.
+
+	Ein Beispiel: wir wollen mario.nes spielen mit der 
+	NES-Emulation von Xmess.  
+	Wir wrden nun eingeben: "xmess nes mario.nes". XMess beginnt nun die
+	Suche im aktuellen Verzeichnis nach:
+
+	mario.nes
+	mario.nes.gz			 (enthlt mario.nes)
+	mario.zip			 (enthlt mario.nes)
+
+	Wenn XMess nichts gefunden hat, dann wird jedes Verzeichnis im Suchpfad
+	(gesetzt durch die Umgebungsvariable $PATH) durchsucht nach:
+	<dir>/mario.nes
+	<dir>/mario.nes.gz		 (enthlt mario.nes)
+	<dir>/mario.zip 		 (enthlt mario.nes)
+
+	Wenn immer noch nichts gefunden wurde, dann such XMess in jedem Verzeichnis
+	des Rompfades nach:
+	<dir>/nes.zip			 (enthlt mario.nes)
+	<dir>/nes/mario.nes
+	<dir>/nes/mario.nes.gz		 (enthlt mario.nes)
+	<dir>/nes/mario.zip		 (enthlt mario.nes)
+
+	Da XMess zuerst nach Cartriges/Disks vom aktuellen Verzeichnis aus sucht,
+	kann man auch Cartriges/Disks angeben, die NICHT im Rompfad sind.
+	Ein Beispiel: "xmess nes ../mario.nes"
+	 
+	XMess such dann nach:
+	../mario.nes
+	../mario.nes.gz			 (enthlt mario.nes)
+	../mario.zip			 (enthlt mario.nes)
+
+	Und es wird auch der Rompfad - wie oben beschrieben - nach 
+	../mario.nes als Image-Name durchsucht, was aber nicht
+	ganz sinnvoll ist.
+
+      - Artwork
+	XMame/XMess suchen in jedem Verzeichnis des Suchpfades
+	(rompath) nach Artwork auf folgende Art und Weise:
+	<dir>/artwork.png
+	<dir>/artwork.png.gz		 (enthlt artwork.png)
+	<dir>/artwork.zip		 (enthlt artwork.png)
+
+	Dann durchsuchen XMame/XMess den Rompfad wie bei Roms/Samples.
+	<dir>/bar.png
+	<dir>/bar.png.gz                 (enthlt bar.png)
+	<dir>/bar.zip                    (enthlt bar.png) 
+
+	Und dann durchsuchen XMame/XMess jedes Verzeichnis im 
+	Rompfad nach:
+	<dir>/foo.zip                    (enthlt bar.png)
+	<dir>/foo/bar.png
+	<dir>/foo/bar.png.gz             (enthlt bar.png)
+	<dir>/foo/bar.zip                (enthlt bar.png)  
+
+      - XMame Konfiguration
+	Xmame sucht nach den folgenden Konfigurationsdateien und wertet jede,
+	die gefunden wird, aus. Somit kann eine spter ausgewertete
+	Konfigurationsdatei die Optionen einen frher gelesenen berschreiben:
+	XMAMEROOT/xmamerc
+	XMAMEROOT/xmame-ANZEIGE_METHODErc
+	${HOME}/.xmame/xmamerc
+	${HOME}/.xmame/xmame-ANZEIGE_METHODErc
+        ${HOME}/.xmame/rc/<spielname>rc  
+	- XMAMEROOT wird whrend des Compilierens gesetzt, siehe
+	  dazu im Makefile.
+	- ANZEIGE_METHODE (DISPLAY_METHOD), fr die XMame bersetzt
+	  wurde, dies kann sein: x11, svgalib, ggi, xgl, xfx, svgafx,
+	  openstep oder SDL.
+	- Fr xmess natrlich einfach xmame durch xmess ersetzen ;-)
+
+      - Spiel Konfiguration
+	Die Dateien zur Spiele-Konfiguration werden userabhngig
+	abgelegt in:
+	${HOME}/.xmame/cfg/<game>.cfg bzw. ${HOME}/.xmess/cfg/<game>.cfg
+
+      - Game Status
+	Die Dateien zum Spielestatus werden userabhngig abgelegt in:
+	${HOME}/.xmame/sta/<game>.sta bzw. ${HOME}/.xmess/sta/<game>.sta
+
+      - NVram
+	NVram Dateien werden benutzerabhngig gespeichert unter:
+	${HOME}/.xmame/nvram/<Spiel>.nv bzw. ${HOME}/.xmess/nvram/<Spiel>.nv
+
+      - Memory Cards
+	Memory Cards werden benutzerabhngig gespeichert in
+	${HOME}/.xmame/mem/<Datei>.mem bzw. ${HOME}/.xmess/mem/<Datei>.mem
+
+      - Screenshots
+	Screenshots knnen erzeugt werden durch Drcken von F12 und werden
+	im PNG-Format im aktuellen Arbeitsverzeichnis gespeichert (cwd), also
+	das Verzeichnis, von dem aus XMame/XMess aufgerufen wurde.
+	Dies kann abgendert werden durch den Eintrag screenshotdir in
+	xmamerc/xmessrc. 
+	Dies kann wiederum abgendert werden durch die Kommandozeilen-Option
+	-screenshotdir. Die Bilder werden gespeichert als:
+	<screenshotdir>/<Spiel>xxxx.png
+	Dabei ist xxxx eine Zahl.
+
+      - Highscores
+	Die Highscores werden gespeichert in XMAMEROOT, definiert
+	im Makefile beim Compilieren. Dieses Spooldirectory
+	kann berschrieben werden durch den Eintrag in xmamerc bzw.
+	xmessrc. Dieser Eintrag kann wiederum berschrieben werden
+	durch die Kommandozeilen-Option -spooldir.
+
+	Somit einfach die Berechtigung des Spoolverzeichnisses 
+	setzen auf: drwxrwsr-x root game <spooldir> mittels chown.
+	Dann noch sein setgid xmame/xmess auf game und schon 
+	funktioniert es. (Bei Verstndnisproblemen die Manpage 
+	von chown und setgid lesen !!!!)
+	Man kann auch die Group-ID bei xmame/xmess mittels
+	chgrp game xmame.x11 (fr die X11-Version) setzen.	
+	Dies funktioniert aber NICHT bei der SVGAlib und 
+	XF86-DGA Version. Diese bentigen suid root !!
+	Fr diese Versionen einfach ${HOME}/.xmame oder 
+	${HOME}/.xmess als spooldir in xmamerc/xmessrc angeben.
+
+	Anmerkung: Damit Hiscores funktionieren, muss XMame natrlich
+	die Datei hiscore.dat finden knnen.
+
+      - hiscore.dat
+	Wenn Du die Hiscores nutzen willst, dann muss XMame die Datei
+	hiscore.dat laden knnen, um an die Informationen heranzukommen.
+	Der Standard ist hierbei XMAMEROOT/hiscore.dat . XMAMEROOT wird
+	whrend des Compilieren gesetzt, siehe hierzu im Makefile.
+	Dies kann neu gesetzt werden durch den Eintrag hiscorefile in der
+	Datei xmamerc, falls vorhanden. Dies kann natrlich auch wieder
+	neu gesetzt werden durch die Kommandozeilen-Option -hiscorefile
+	beim Start von XMame.
+
+	Die Datei hiscore.dat ist verfgbar auf der Mame-Homepage:
+	http://www.mame.net
+
+      - cheat.dat
+	Wenn Cheats benutzt werden sollen, dann mu Mame die Datei
+	CHEAT.DAT laden, um die Informationen zu haben. 
+
+	Voreingestellt ist XMAMEROOT/cheat.dat . XMAMEROOT wird
+	whrend des Compilierens gesetzt, siehe Makefile.
+	Diese Einstellung kann berschrieben werden durch den
+	Eintrag cheatfile in xmamerc, wenn vorhanden. Wiederrum
+	kann dies ersetzt werden durch die Kommandozeilen-
+	Option -cheatdat.
+
+	Die Datei cheat.dat ist verfgbar auf der Mame-Homepage:
+	http://www.mame.net
+
+      - history.dat
+	Wenn Du einige nette Hintergrundinformationen zu den Spielen
+	willst, dann mu xmame die Datei history.dat laden.
+	Voreingestellt ist XMAMEROOT/history.dat . XMAMEROOT wird
+	whrend des bersetzens gesetzt, siehe hierzu im Makefile.
+	Dies kann berschrieben werden durch den Eintrag historyfile
+	in der xmamerc. Dieses kann wiederrum berschrieben werden durch
+	den Schalter -historyfile beim Aufruf von Xmame.
+
+        Die Datei history.dat ist verfgbar auf der Mame-Homepage:
+        http://www.mame.net     
+
+      - Aufzeichnen der Eingaben
+	Aufzeichnungen von den Eingaben werden unter dem Dateinamen 
+	gespeichert, der hinter den Schaltern -record / -playback
+	angegeben wird, immer relativ zum aktuellen Pfad
+
+      - Es werden immer noch Dateien nicht gefunden / Highscores 
+	werden nicht abgespeichert ?
+	xmame/xmess -showconfig | more eintippen und prfen, ob 
+	der angezeigte Pfad zu den Roms und der Pfad zum spooldir 
+	korrekt ist und ob dort auch die Berechtigung zum Lesen 
+	und Schreiben vorhanden ist.
+	Andererseits noch einmal xmamerc/xmessrc prfen. 
+	Und nicht vergessen, xmess durchsucht auch das aktuelle 
+	Verzeichnis.
+
+
+Wie starte ich Xmess/Xmame ?
+
+	Um Xmame zu starten:
+	  xmame [Optionen] <spielname> [mehr Optionen]
+	
+	Fr Xmess:
+	  xmess [Optionen] <systemname> [mehr Optionen] 
+	        <disk/romimage(s)> [mehr Optionen]
+
+	Alle Optionen sind sozusagen optional ;-))
+	Xmame/Xmess untersttzt die meisten Commandozeilen-
+	optionen der MSDOS-Version
+	(nheres siehe in readme.mame / readme.mess).
+
+	Bei Xmess bentigen einige Systeme nicht disk/romimage, 
+	die meisten jedoch schon.
+
+
+Warum hat ein Spiel keinen Sound ?
+
+	- Zuerst einmal prfen, ob Sounduntersttzung berhaupt 
+	  funktioniert.
+	- Prfen, ob das gewnschte Spiel berhaupt Soundunter-
+	  sttzung bietet. Nicht alle Spiele haben derzeit Sound.
+
+	  Bei Xmame einen Blick in gameslist.mame werfen. Wird 
+	  Sound fr das Spiel emuliert ?
+
+	  Bei Xmess einen Blick in readme.mess werfen, ob fr das 
+	  System Sound berhaupt emuliert wird.
+
+	- Prfen, ob Xmame/Xmess auf dem verwendeten System 
+	  berhaupt Sounduntersttzung bietet. Siehe dazu weiter
+	  oben in den FAQ's.
+
+
+Eine scheinbar verzgerte Soundausgabe ? Der Sound klingt abgehackt ?
+Was macht der Parameter -bufzize ?
+	
+	Mit dem Parameter -bufsize (als Kommandozeilen-Option) oder
+	als Schlsselwort in der Konfigurationdatei (xmamerc) kann
+	man die Anzahl Frames von Audio zum Buffer angeben. Die
+	Grundeinstellung ist 2 frames.
+
+	Dieser Wert sollte bei Jedem passen, aber wenn immer noch
+	Probleme auftreten, dann weiterlesen.
+
+	Wenn die Puffergre zu klein ist, dann wird der Buffer ge-
+	zwungen, sich zwischen den Frames zu Leeren, wa dann zu
+	verzgerter Soundausgabe oder zu abgehacktem Sound fhren 
+	kann. In diesem Fall kann das Erhhen des Wertes der Buffer-
+	gre auf beispielsweise 2.5 helfen.
+	
+	Wenn jedoch die Buffergre zu gross ist, dann werden so
+	viele Audiodaten gepuffert, dass die Soundausgabe verzgert
+	klingt. Z.B. ist das Einwerfen einer Mnze erst nach 0.5
+	Sekunden zu Hren, nachdem die das "Insert Coin" gedrckt
+	wurde. In diesem Fall verringere den Werte bei der Buffer-
+	gre auf beispielsweise 1.5.
+
+	Bitte lat Hans wissen, wenn ein ndern dieser Werte notwen-
+	dig ist, weil er plant, diesen Parameter in einer zuknftigen
+	Version von XMame wieder zu entfernen.
+		
+
+Warum funktioniert ein Spiel nicht ?
+
+	- Sind die richtigen Roms vorhanden oder treten beim 
+	  Starten Prfsummenfehler auf ?
+	  Xmame Version 0.34 und hher bentigt PROM-Dateien, die 
+	  nicht in den ROM-Files enthalten sind vor der 
+	  Version 0.34. Siehe auch weiter Unten fr Fragen ber 
+	  PROMs.
+	- Bei Xmame in der Datei gamelist.mame nachsehen, ob das 
+	  Spiel berhaupt spielbar ist. Wenn ein Spiel in der 
+	  Liste enthalten ist bedeutet es nicht automatisch, da es 
+	  schon spielbar ist.
+	- Bei Xmess in der Datei readme.mess nachsehen. Vielleicht 
+	  wird das System noch nicht komplett emuliert.
+	- Einige Spiele bentigen Sounduntersttzung. Wenn bei 
+	  Deinem Unix-System keine Sounduntersttzung vorhanden ist 
+	  oder Xmame/Xmess dafr keine Sounduntersttzung bietet, 
+	  dann den Parameter -fakesound benutzen.
+
+
+Was sind PROMs ?
+
+	PROMs enthalten spezielle Informationen fr Spiele. Diese 
+	waren in Mame-Versionen < 0.34 in Mame selbst enthalten. 
+	Diese Informationen wurden wieder aus Mame entfernt und sind
+	in den neueren Versionen der ROM-Files, die so etwas 
+	bentigen, schon enthalten.
+
+	Exzellente Seiten fr aktuelle ROM-Files sind Emuclassics 
+	(http://www.emuclassics.com) oder Emux (http://www.emux.com).
+
+
+Warum ist Xmame/Xmess langsam ?
+
+	Xmame/Xmess ist ein bersetztes C-Programm, das Hardware 
+	emuliert. Software, die Hardware emuliert, ist nun mal nicht
+	so schnell. Auerdem ist Unix - im Gegensatz zu MSDOS - ein 
+	Multitasking-Betriebssystem.
+	Hier sind nun einige Tips fr hhere Geschwindigkeit:
+
+	- den Parameter -frameskip benutzen
+	- whrend des Spieles F8 drcken, um die Framerate zu erhhen
+	- throttle abschalten durch den Parameter -nothrottle oder durch
+	  drcken von F10 whrend Xmame/Xmess schon luft.
+	- wenn Xmame/Xmess luft, dann F11 drcken um die aktuelle 
+	  Geschwindigkeit von Xmame/Xmess zu prfen.
+	Wenn niemals 100% auftauchen, dann mu wohl ein schnellerer 
+	Computer her.
+
+	Du kannst natrlich auch versuchen, XMame/XMess mit mehr optimierten
+	Einstellungen neu zu bersetzen. Die folgenden Ratschlge knnen
+	nicht funktionieren oder knnen auf einigen Maschinen oder einigen
+	Installationen nicht mglich sein. Natrlich kann, in den Fllen wo
+	es funktioniert, eine merkliche Performance in XMame/XMess eintreten.
+
+	Um diese "Verbesserungen" einsetzen zu knnen, muss nur die Datei
+	Makefile editiert werden. Diese Datei ist bei XMame mit dabei.
+	Anschlieend muss der Sourcecode neu bersetzt werden. Wenn der
+	Sourdecode zum zweiten mal bersetzt wird, dann muss nach dem
+	Editieren von makefile.unix
+
+	make clean
+	make 
+	make install
+
+	ausgefhrt werden, um die neuen Einstellungen zu aktivieren.
+
+	SPEEDUP #1 - Compilieren mit Inline
+	-----------------------------------
+	Versuche beim bersetzen inline zu aktivieren und entferne/fge den
+	Kommentar bei diesen beiden Zeilen hinzu:
+
+        # IL    = '-DINLINE=static inline'
+        IL     = -DINLINE=static   	
+	 
+	SPEEDUP # 2 - Direct Graphics Access
+	------------------------------------
+	Fr einen gehrigen "Schub" versuche DGA zu aktivieren und entferne
+	den Kommentar bei folgender Zeile
+
+        DGA     = 1
+
+	Starte dann XMame als Benutzer root und drcke "CursorLinks-ALT-EINFG" 
+	um in den DGA-Modus zu wechseln. Dies sollte um Einiges schneller sein
+	und bentigt/nutzt nicht xsync ;-)
+
+	Der Vorteil von DGA ist, dass es Direct Grafics Access ist und somit
+	direkt in den Framebuffer schreibt (Denke an DircetX und GDI unter 
+	Windows). So sollte es einen Tick schneller sein, unabhngig davon, ob
+	Du einen wirklichen guten beschleunigten X-Server hast, was genauso
+	schnell sein knnte. Drcke F11 um die aktuelle Framerate anzuzeigen,
+	obwohl es meist schwer festzustellen ist (meist nur wahrnehmbar), es
+	sollte doch eine kleine Geschwindigkeitserhhung vorhanden sein.
+
+	Nebenbei schaltet DGA automatisch in den richtigen Modus entfernt
+	jeglichen "Mll" der Fenstermanager, aber das kann auch ohne DGA
+	erreicht werden (es wird ein solches Feature mglicherweise spter
+	geben, weil es ganz leicht Fullscreen erlaubt, ohne dass man dazu
+	root sein muss).
+
+	Fge den Modus 320x240 hinzu, der eine nette Fullscreen-Anzeige beim
+	Scaling scale = 1 mglich macht ;-)
+
+	Nicht vergessen, dass noch die Mode-Lines in der Section "Display"
+	bei "Screen" Deiner X-Config Datei gesetzt werden mssen um im DGA-
+	Modus bildschirmfllend darzustellen. XMame sucht sich den besten
+	Modus heraus, den es finden kann. Du wirst also eine Zeile wie
+	   Modes  "1024x768" "800x600" "640x480" "320x240" "256x224" 
+	haben, denn jedes Spiel, das in bei einer 320x240-Auflsung passt
+	kann in dieser Auflsung dargestellt werden, usw. Nicht vergessen,
+	dass die X-Config Datei mehrere Stellen mit dem Namen "Screen" haben
+	kann. Die Modi mssen dann natrlich bei der Stelle editiert werden,
+	die der X-Server beim Start benutzt. Es ist natrlich nicht ganz so
+	einfach, da man X auch noch mitteilen muss, welche Monitoreinstellungen
+	fr diese Auflsungen bentigt werden. Dies geschieht in den Modeline-
+	Eintrgen im Bereich "Monitor" der X-Config Datei.
+
+	Siehe auch in contrib/tools/modelines fr einen Satz verckter Modis,
+        speziell fr XMame in DGA. Sie sollten auf jedem beliebigen Multi-
+        sync Monitor funktionieren, aber benutze sie NICHT auf einem alten
+        Festfrequenz Monitor (gut, wenn Du es nicht lassen kannst es trotzdem
+        zu versuchen, ich werden NICHT fr einen neuen Monitor zahlen)    
+
+
+	SPEEDUP # 3 - NASM
+	------------------
+	Du kannst auch versuchen, nasm zu installieren und XMame/XMess mit
+	ASM-Core zu bersetzen, dies hilft auch ein wenig.
+	(Bemerkung fr SuSE-Besitzer: das Paket nasm-09x befindet sich in 
+	der Serie d)
+
+
+Warum bekomme ich den Fehler "get gz_open symbol not found" beim Compilieren ?
+	
+	XMame/XMes-Versionen neuer als 0.35 benutzen zlib fr einige
+	Packroutinen. Leider haben viele Linux Distributionen eine
+	veraltete Version von zlib installiert unter
+	/usr/X11R6/lib/libz.a und die neue Version installiert unter
+	/usr/lib/libz.a. Wenn dies bei Dir der Fall ist, dann kann
+	problemlos die Version unter /usr/X11R6/lib/libz.a gelscht
+	werden. Wenn Du Dir da nicht sicher bist, verschiebe einfach
+	/usr/X11R6/lib/libz.a an eine andere Stelle.
+
+	Lschen oder nur Verschieben von /usr/X11R6/lib/libz.a sollte
+	dieses Problem beheben.
+
+	Siehe auch: Warum bekomme ich die Meldung "zlib.h nicht gefunden" ?
+
+
+Warum bekomme ich die Meldung "zlib.h nicht gefunden" ?
+
+	XMame/XMess-Versionen neuer als 0.35 benutzen zlib fr einige
+	Packroutinen.
+
+	Zlib ist Standard auf den meisten Unix-Systemen. Fr Leute, die 
+	sich nicht mit zlib herumrgern wolle, oder keine veraltete Version
+	haben wollen, ist nun bei XMame/XMess eine abgespeckte Version von
+	zlib mit dabei. Entferne die Kommentare bei der betreffenden
+	Stelle im Makefile um dies zu benutzen.
+
+
+Welche Commandozeilen-Parameter gibt es fr Xmame/Xmess ?
+
+	Fr eine Liste der verfgbaren Parameter einfach
+	
+	/usr/games/xmame -help | more eintippen 
+	(falls xmame in /usr/games zu finden ist)
+
+	Xmame/Xmess untersttzt die meisten Parameter der 
+	MSDOS-Version und natrlich ein paar eigene.
+
+	In der Datei readme.mame / readme.mess ist mehr ber die 
+	Parameter nachzulesen.
+
+
+Welche Tasten benutzt Xmame/Xmess ?
+
+	Xmame/Xmess benutzt die selben Tasten wie die DOS-Version:
+	Folgende Tasten funktionieren in allen Emulatoren:
+	` od. ^ 	Einstieg in das OnScreen Display fr Lautstrke-
+			nderungen, Helligkeitsregelung, ...
+	Tab		Einstieg ins Configurationsmen. Tab oder 
+			ESC drcken, um zurck zur Emulation zu gelangen.
+	P		Pause
+	F3		Reset
+	F4		Zeigt einige Grafiken an. Mit den Cursor-Tasten 
+			knnen	die Farben gendert und gesetzt werden.
+			F4 oder ESC um zurck zur Emulation zu gelangen.
+	F8		Frame Skip reduzieren
+	F9		Frame Skip erhhen
+	F10		Throttle an oder aus
+	F10 + Shift	Idle Sleepig an oder aus
+	F11		Anzeige der momentanen Geschwindigkeit
+	F11 + Shift	Profiler Anzeige an oder aus
+	F12		Der aktuelle Bildschirm wird gespeichert 
+	ESC		Emulator verlassen
+
+	XMame hat zwei verschiedene Algorithmen fr auto frameskipping,
+	diese knnen mit der Option -frameskipper ausgewhlt werden,
+	und mit folgenden Tatenkombinationen
+
+	Tastenkombination:	Wirkung:
+	CTRL-Links + Einfgen	Standard DOS Framekipper
+	CTRL-Links + Pos1	Frameskipper von William Barath
+
+	Der Unterschied zwischen diesen beiden ist schwer zu beschreiben,
+	einfach mal selbst ausprobieren. Der Standard ist der DOS
+	Frameskipper.
+
+	Unter X11 kann xmame zwischen verschiedenen Anzeigemodi
+	whrend "des laufenden Betriebes" wechseln:
+	Tastenkombination:	Bringt Dich zu:
+	Alt-links + Einfgen	Normales Fenster
+	Alt-links + Pos1	DGA Fullscreen Modus
+
+	Unter X11 in einem Fenster kann man nun auch die Maus
+	aktivieren, um sie zum Spielen bentzen zu knnen.
+	Drcke dazu Alt-Links und Bild-Ab um die Maus zu aktivieren
+	und drcke die Tastenkombination nochmals, um die Maus
+	wieder zu deaktivieren.
+
+
+Wo bekomme ich die aktuelle Version von Xmame/Xmess her ?
+
+	Auf der Xmame/Xmess-Homepage ist immer die aktuellste 
+	Version verfgbar.
+	Adresse: http://x.mame.net
+
+	Auf meiner Homepage ist ebenfalls der Sourcecode
+	verfgbar (Ausweichadresse, falls x.mame.net berlastet
+	ist). Binaries werde ich nicht mehr zur Verfgung stellen.
+	Adresse: http://www.bingo-ev.de/~rh474
+
+Wo kann ich erstellte Korrekturen, gefundene Fehler, Anregungen, 
+Geld hinschicken ? ;-)
+
+	Siehe Kapitel 4 dieses Dokumentes.
+
+**********************************************************************
+2. Compilieren, Einrichten und Starten von xmame/xmess
+**********************************************************************
+
+Vorbemerkung: 
+Dieses Kapitel soll keine Unix-Anleitung sein  !! 
+Die Kenntnisse grundlegender Unixkommandos zum bersetzen und 
+Installieren von Xmame/Xmess werden vorausgesetzt.
+Ansonsten empfehle ich ein gutes Linux-Buch, wie Michael Kofler,
+"Linux - Installation, Konfiguration, Anwedung", Addison-Wesley.
+
+Voraussetzungen:
+- GNU make ist GRUNDVORAUSSETZUNG auf ALLEN Systemen, auch wenn
+  ein unterschiedlichen Compiler benutzt wird
+- Auf allen Plattformen wird zlib bentigt, da auch die Core-Version
+  (DOS-Version) diese benutzt.
+- Du bist aufgefordert, die GNU Entwicklungsumgebung zu Benutzen, also
+  gcc, gmake und gnu-ar. Viele Probleme sind durch die seltsame Syntax
+  in gcc aufgetreten. Wenn Du also einen strikten ANSI Compiler
+  benutzt, wirst Du jede Menge Warnungen bekommen, und, falls die
+  XMame/XMess-Version noch nicht fehlerfrei ist, auch bersetzungs-
+  fehler. Das bersetzen von XMame bricht ab, wenn egcs-1.1.x oder
+  gcc-2.95 benutzt wird. Benutze hierbei -fno-strict-aliasing um dies
+  zu Umgehen. Gcc-2.95.1 funktioniert mit -fstrict-aliasing und 
+  bringt eine nette Geschwindigkeitserhhung.
+
+Folgende Schritte sollten zum bersetzen von Xmame/Xmess befolgt 
+werden:
+
+1.   Siehe Kapitel 5 fr plattformabhngige Informationen beim 
+     bersetzten.
+2.   Das Archiv mit dem Sourcecode von Xmame/Xmess runterladen.
+3.   Das Archiv mit dem Sourcecode in ein passendes Arbeitsverzeichnis 
+     schieben (z.B. /usr/src). Wenn das Archiv entpackt wird, werden 
+     die Unterverzeichnisse unterhalb des Arbeitsverzeichnisses 
+     automatisch erstellt.
+4.   Benenne das Archiv um, so da die Endung .gz ist. Beispielsweise 
+     sollte xmame-0.34b.1.1.tgz zu xmame-0.34b1.1.tar.gz werden.
+     (Anmerkung von mir: dies ist unter Linux NICHT notwendig. 
+     Das .tgz-Archiv kann ganz einfach mittels 
+     tar xzf xmame-0.34b1.1.tgz entpackt werden)
+5.   Benutze gzip -d um das Archiv zu entpacken.
+     Beispiel: gzip -d xmame-0.34b1.1.tar.gz
+6.   Nun die Datei mit tar extrahieren. 
+     Beispiel: tar xvf xmame-0.34b1.1.tar
+7.   Nach dem Auspacken des Archives in das Unterverzeichnis wechseln, 
+     das whrend des Auspackens angelegt wurde.
+     Beispiel: nach dem extrahieren von xmame-0.34b1.1.tar ist ein 
+     Verzeichnis mit dem Namen xmame-0.34b1.1 vorhanden.
+     Hineinverzweigen (cd xmame-0.34b1.1). Dieses Verzeichnis ist der 
+     Anfang des gesamten Sourcen-Baums.i
+8.   Kopiere makefile.unix nach Makefile, da die mitgelieferte
+     Datei Makefile fr Entwickler benutzt werden sollte und kein
+     guter Anfang fr Benutzer ist. i
+     Die Datei Makefile editieren und die Einstellungen abndern, 
+     die das eigene System betreffen. Die Grundeinstellung im 
+     makefile.unix ist gedacht fr Linux/X11. nderungen bitte
+     mit Vorsicht vornehmen.
+8a.  Wenn beabsichtigt ist, X11 Joystick-Support mit einzucompilieren:
+     Folgendes eintippen, um die vorhandene Xdevice-Liste zu erhalten:
+	make -f Makefile.unix xlistdev
+	./xlistdev
+8b.  Das gewnschte Device auswhlen und Makefile nochmals 
+     editieren.
+     Dabei bei der Option X11_JOYNAME den korrekten Devicenamen setzen.
+9.   Xmame/Xmess bersetzen: make eintippen.
+10.  Wenn das Compilieren abbricht, das Problem an den Author melden.
+11.  Um dann Xmame/Xmess zu installieren: make install 
+     eintippen.
+***  Um Punkt 11 auszufhren bentigt man root-Rechte !!! ***
+11a. Wenn Du auch andere Programme bersetzen willst, wiederhole die
+     Schritte 9 bis 11 und fge einfach TARGET=<Ziel> beim Aufruf von
+     make hinzu, zum Beispiel make TARGET=mess
+11b. Wenn Du fr andere Anzeigearten bersetzen willst, dann wiederhole
+     Schritt 9 bis 11 und fge DISPLAY_METHOD=<Anzeigeart> beim Aufruf
+     von make hinzu, z.B. make DISPLAY_METHOD=svgalib
+11c. Du kannst natrlich 11a und 11b auch kombinieren:
+       make TARGET=mess DISPLAY_METHOD=svgalib
+12.  Im eigenen Homeverzeichnis ein Unterverzeichnis .xmame anlegen
+13.  Aus dem Verzeichnis mit dem Sourcecode /doc/xmamerc.dist nach
+     ${HOME}/.xmame/xmamerc kopieren (bei Xmess natrlich xmessrc).
+14.  Wenn gewnscht, kann man noch xmamerc.dist in einen global 
+     bekannten Platz kopieren unter den Namen "xmamerc" 
+     (bei Xmess xmamerc.dist zu xmessrc).
+     Der global Platz von xmamerc ist im Makefile definiert.
+15.  Die Datei ${HOME}/.xmame/xmamerc fr die eigenen Voreinstellungen 
+     editieren. (bei Xmess ${HOME}/.xmess/xmessrc editieren)
+16.  Sicherstellen, da die Umgebungs-Variablen DISPLAY und PATH 
+     richtig gesetzt sind.
+17.  Sicherstellen, da die ROM-Images installiert sind.
+18.  X-Windows starten (wenn fr eine andere Anzeigemethode bersetzt 
+     wurde, kann dieser Punkt auch bergangen werden)
+19.  Xmame/Xmess starten.
+     Beispiel: /usr/games/xmame.x11 dkong
+
+Wenn Probleme auftreten beim bersetzen, Installieren und 
+Starten von Xmame/Xmess...
+
+    * Wenn Du Fehler bekommst wegen gz_open oder eine Menge anderer
+      Funktionen werden nicht gefunden whrend des bersetzens, dann
+      siehe bitte im Kapitel 1 unter Warum bekomme ich den Fehler 
+      "get gz_open symbol not found" beim Compilieren ?
+    * ist der Pfad zu den ROMs in xmamerc/xmessrc wirklich korrekt ?
+      Siehe auch unter: Wo kommen denn die Roms, Images, 
+                        Samples, Highscores und Config-Dateien hin ?
+    * Prfe xmamerc/xmessrc: ist wirklich alles richtig configuriert ?
+    * ist das Programm im Suchpfad ? (PATH)
+    * die SVGAlib/XF86-DGA Versionen von Xmame/Xmess bentigen 
+      setuid root. Sind die Zugriffsrechte korrekt ? Wirklich ?
+    * Siehe auch Kapitel 5 fr betriebssystemabhngige Bemerkungen.
+    * kommt die Meldung, da eine Datei oder Dateien nicht gefunden 
+      werden ? Vielleicht fehlen die PROMs. Siehe auch dazu im FAQ.
+    * prfe nochmal Kapitel 1.
+    * siehe auch in der Datei known.bugs fr bekannte Probleme nach.
+    * frage erst mal die netten Leute in der Newsgruppe 
+      alt.game.mame um herauszufinden, ob schon jemand so ein Problem 
+      wie Du hatte und es vielleicht schon gelst hat.
+    * Versuche Deine Frage an die XMame-Mailingliste zu Senden.
+
+Wenn dies alles nichts hilft, dann eine E-Mail an den momentanen 
+Entwickler von Xmame/Xmess. Siehe dazu Kapitel 4 fr die Adressen.
+
+
+
+**********************************************************************
+3. Was noch getan werden mu
+**********************************************************************
+
+	* Portierung auf x86 Computer mit SCO Unix als Betriebssystem
+	  Keine Kopie dieses Betriebssystems ist derzeit verfgbar.
+	  Hilfe ist willkommen.
+	* Portierung auf andere nicht-standard Unixe oder Unix basierte
+	  Systeme. Keine Gerte oder Software sind derzeit verfgbar.
+	  Hilfe ist willkommen.
+	* Netzwerkuntersttzung fr zwei Spieler und diverse 
+	  Beobachtungspunkte. X-Windows ist netzwerkbasiert und somit
+	  sollte so eine Implementation nicht zu schwierig sein. Hilfe
+	  ist erwnscht um herauszufinden, welcher Spieler gerade 
+	  dran ist.
+
+Siehe in doc/todo.
+Wenn Du der Meinung bist Du kannst bei einem der Punkte aus der
+Todo-Liste helfen kannst, oder Du etwas anbieten kannst, das 
+in Deinen Augen interessant ist, dann bitte eine E-Mail an den
+derzeitigen XMame/XMess-Koordinator.
+Siehe dazu Kapitel 4 fr mehr Informationen.
+
+
+**********************************************************************
+4. Mail
+**********************************************************************
+
+Es gibt eine offizielle Xmame/Xmess Mailingliste. Alle Zugriffe auf 
+diese Liste geschehen per E-Mail an xmame-request@acm.csres.utexas.edu
+mit einem Schlsselwort im Text (NICHT im Betreff). 
+Derzeit werden folgende Schlsselwrter erkannt:
+	subscribe	- in die Liste eintragen
+	unsubscribe	- aus der Liste austragen
+
+Wenn Du eine persnliche Mail an den Xmame/Xmess-Koordinator senden 
+willst, dann zu der Adresse unten. Jeder Interessierte sollte ich in 
+die Mailingliste von Xmame/Xmess einschreiben.
+
+	Mailingliste:			xmame@acm.csres.utexas.edu
+	XMame/XMess-Koordinator:	hans@highrise.nl
+	Deutsche Anleitung:		prian@bingo-ev.de
+
+
+**********************************************************************
+5. Anmerkungen zum Compilieren auf speziellen Betriebssystemen
+**********************************************************************
+
+Linux i386
+==========
+	
+	Linux ist die Plattform die Hans (und auch Ich) nutze, somit
+	sollte XMame ohne Probleme auf Linux i386 bersetzt werden
+	knnen.
+	
+	Es sind einige Fehler aufgetreten und umgangen worden, wenn als
+	Compiler gcc V2.7.x benutzt wird. Wenn noch mehr Fehler im Zu-
+	sammenhang mit gcc auftreten, dann wird egcs als Compiler Vor-
+	aussetzung sein. Aber ich hoffe, da dies nicht ntig sein wird.
+
+	Es wurde auch berichtet, da einige SoundBlaster AWE32-Karten
+	mit get_freespace() nicht korrekt umgehen knnen. Wenn Du also
+	einige audio_ioctl() Aufruffehler in der Konsole siehst und alles
+	Gut geht, dann sollte eine Meldung auftauchen, dass XMame/XMess
+	auf timerbasierte Sounduntersttzung zurcksetzen. Wenn dies nicht
+	passiert und der Sound nicht korrekt klingt, dann kann die timer-
+	basierte Sounduntersttzung erzwungen werden beim Start von 
+	XMame/XMess mit -timer. 
+
+	SB64/SB128PCI-Karten (Ensoniq 137x basierend) knnen ebenfalls
+	mit get_freespace() nicht richtig umgehen unglcklicher-
+        weise kommen keine Fehler beim ioctl's, sondern die Aufrufe
+        werden einfach ignoriert. XMame versucht dies automatisch zu
+        erkennen und setzt dann auf timerbasierte Audio-Untersttzung
+        zurck. Wenn dies nicht passiert und der Sound ist trotzdem
+        nicht korrekt, dann erzwinge die timerbasiert Audio-Untersttzung
+        beim start von XMame/XMess mit -timer.               
+	 
+	Es ist auch schon das Treibermodul fr den PC-Speaker getestet
+	worden. Es funktioniert. Aber es wird -timer bentigt, nochmals,
+	es sollte automatisch geschen. Wenn nicht, dann weit Du ja nun
+	was zu Tun ist. 
+
+
+	Distributionsabhngige Bemerkungen
+	-----------------------------------
+
+	S.u.S.E. Distribution: Der gcc-Compiler und die libc-Libraries 
+	aus der Serie "d" mssen installiert sein. Einige andere Pakete
+	mssen auch noch installiert werden, oder die bersetzung wird
+	abbrechen. Wenn fer die SVGAlib bersetzt wird, dann bentigt man
+	das svgalib-Paket aus der Serie "d" (ich denke es ist sharedlibs).
+	Wenn fr X-Windows bersetzt wird, dann braucht man das Paket 
+	xdevel aus der Serie "x". Diese Pakete knnen ganz einfach mit
+	"YAST" installiert werden, der ein Bestandteil der S.u.S.E.-
+	Distribution ist.
+	Fr DGA-Untersttzung bei den beliebten Riva128/TNT-Karten bentigt
+	man mindestens XFree86-3.3.3.1 !! Aber auch dann kann DGA nicht 
+	funktionieren !!
+
+	Creative Labs Soundblaster Live!: Wenn die Sounduntersttzung
+	unter Linux generell funktioniert, XMame aber schon bei kleinen
+	Rom-Sets (wie pacman, hexa, ...) nur Frameskip 7 zustandebringt,
+	dann unbedingt das Modul emu10k1 fr die SBLive von der
+	Adresse opensource.creative.com holen und den aktuellen Snapshot
+	anhand der ENGLISCHEN Anleitung installieren.
+
+	Red Hat Linux ist das Betriebssystem des Authors. Xmame/Xmess 
+	sollten	korrekt unter Red Hat Linux bersetzt und installiert
+	werden knnen. :-)
+
+	(Anmerkung von mir: ich benutzte S.u.S.E.-Linux und auch dort 
+	lsst sich Xmame/Xmess problemlos bersetzten und installieren)
+	:-))))
+
+Linux PowerPC
+=============
+
+	Linux PowerPC sollte von nun an funktionieren. Hier ist eine
+	E-Mail von Adreas Varga <sid@skater.htu.tuwien.ac.at>, dem
+	Entwickler fr Linux/PowerPC, der die notwendigen Schritte
+	berschreibt:
+
+--------
+notwendige nderungen um xmame 034b3.1 unter Linux/PowerPC und
+SVGALIB zu bersetzen
+--------
+
+Makefile:
+
+- aktiviere OPTFLAGS fr Linux/PPC
+- aktiviere CFLAGS fr Linux/PPC
+- aktiviere DISPLAY_METHOD = svgalib
+- aktiviere ARCH = linux
+- entferne  -lvgagl von LIBS.svgalib in src/unix/unix.mak (nur -lvga wird bentigt) 
+
+--------
+notwendige nderungen um xmame 034b3.1 unter Linux/PowerPC und
+X11 zu bersetzen
+--------
+
+Makefile:
+
+- aktiviere OPTFLAGS fr Linux/PPC
+- aktiviere CFLAGS fr Linux/PPC 
+- aktiviere DISPLAY_METHOD = x11
+- aktiviere ARCH = linux
+
+-------------------------------------------------------------------------
+
+(Der Rest, da unverndert, wieder im Orginal)
+Another thing... sound is not working, because sound drivers support is
+currently under development in Linux/PPC kernels...there is an old driver
+that is a hacked Soundblaster driver, and newer 2.1.1xx kernels have a
+sound drivers based on Amiga DMA sound drivers... Once this issues are
+settled there should be a full OSS-compatible driver... sound should work
+then...
+
+I can't speak about Joystick support... 
+
+The original Linux/PPC target changes in Makefile were done by me,
+but there are some other changes required to get it to compile...
+Starting from October I will have some more time to work on this, and 
+I'll keep you updated...
+
+Cheers,
+Andreas
+
+
+IRIX
+====
+	Benutze die allgemeine Unix-Architektur (generic unix) fr diese
+	Maschinen, die keine Soundunterstztung installiert haben.
+	(XMame/XMess nutzen das dmedia Paket oder das neuere AL Paket
+	auf den IRIX Systeme)
+
+	Silicon Grahics untersttzt verschiedene Compiler. Xmame/Xmess 
+	wurde bersetzt und getestet mit dem normalen CC. Es gibt aber 
+	einige Probleme	mit CC, wenn -n32 benutzt wird, um den neuen 
+	32bit Code zu bersetzen. 
+	Es funktioniert aber, wenn man -o32 fr den alten 32bit Code 
+	verwendet. Es sollte nun auch funktionieren mit -n32, was 
+	natrlich wesentlich schneller ist.
+
+	Das Benutzen von DCC ist nicht lnger mglich seit es ein 
+	c++ Compiler ist und man kann xmame/xmess damit nicht compilieren.
+	Mame besteht aus reinem C-Code, deshalb bitte einen normalen 
+	C-Compiler verwenden.
+
+	Einige Probleme wurden gemeldet, wenn man den GNU Linker benutzt. 
+	Es ist besser die Native-Version des Betriebssystems zu benutzen.
+
+
+HPUX
+====
+
+	Benutze generic unix. Unter HP-UX sind gcc und Gnu Make VORAUSSETZUNG.
+
+
+ULTRIX
+======
+	Benutze generic unix.
+
+	(Anmerkung stammt von Danny <dboxhoor@iso.vilspa.esa.es> )
+
+	SEHR WICHTIG!!!
+	Die Xmame/Xmess CPU-Emulatoren greifen auf Speicher durch 
+	Zeiger (Pointer) zu, die manchmal einen illegalen Speicherzugriff
+	verursachen - soweit die MIPS CPU davon betroffen ist. Das 
+	Ultrix Betriebssystem behebt diese "unerlaubten Datenzugriffe".
+
+	In Abhngigkeit der Systemeinstellung, werden jede Menge Warnungen
+	ausgegeben bei bestimmten Spielen. Diese Meldungen knnen 
+	abgeschaltet werden, wenn man das Kommando "uac p 0" in der 
+	selben Shell eingibt, von der aus Xmame/Xmess gestartet wird.
+
+	UPDATE: Der neue Schalter -DALIGN_INTS im makefile.unix behebt 
+	diese unerlaubten Zugriffe im Sourcecode was natrlich viel 
+	schneller ist, als diesen Fehler im Kernel segfault handler 
+	per Hotfix zu beheben.
+
+	Benutze GNU make.
+
+	bersetze mit dem 'c89' Compiler. Obwohl gcc keine Probleme beim
+	bersetzen und optimieren von Xmame/Xmess macht, ist die 
+	ausfhrbare Datei mit c89 bersetzt schneller auf einer 
+	unbelasteten Maschine (Xmame kann die ganze CPU und den ganzen
+	Speicher benutzen, ohne mit anderen hochprioren Prozessen zu 
+	kollidieren), somit kann "frameskip 1" gesetzt werden.
+
+	Wenn mit "c89 -O2" bersetzt wird, dann nicht vergessen, 
+	ebenfalls "-Olimit 1000 zu setzen. Wenn 1000 nicht genug ist, 
+	dann teilt der Compiler mit, da der Wert erhht werden mu.
+
+
+SunOS & Solaris
+===============
+
+	Im Makefile sind zwei relevante Optionen fr die verschiedenen 
+	Architekturen vorhanden:
+	ARCH = generic	    dies ist fr das alte SunOS auf den Sparcs, aber 
+			    eine Sparc mit Solaris darauf wird natrlich mit
+			    dieser Option auch umgehen knnen
+	ARCH = solaris	    dies sollte man fr Sparcs mit Solaris benutzen
+
+	Momentan wird kein Sound untersttzt unter SunOS.
+	Die Solaris Architektur untersttzt Sound.
+
+	Wenn Sun's OpenWindows Implementation von X11 benutzt wird, dann
+	mssen die Variablen X11INC und X11LIB in der X11 Options Sektion
+	des Makefiles korrekt gesetzt sein. (Es sind bereits Eintrge fr
+	das Standard OpenWin-Verzeichnis vorhanden. Diese knnen auskom-
+	mentiert werden).
+	Wenn natrlich fr X11 bersetzt wird, dann mssen diese Variablen
+	korrekt gesetzt sein, unabhngig von der X11-Implementation, die 
+	verwendet wird ! :)
+
+	Wenn der SunPro cc Compiler von Sun verwendet wird, dann haben sich
+	folgende Flags zum Optimieren bewhrt:
+	   OPTFLAGS    = -fast -x04 -native
+
+	Es sind Flle aufgetreten, bei denen die bersetzung von Xmame
+	am Program "ar" gescheitert ist. Die meisten Solaris Installationen
+	haben ein Satz Utilities die mit dem XPG4-Standard konform sind,
+	blicherweise im Verzeichins "/usr/xpg4/bin" zu finden. Die XPG4-
+	Version von "ar" sollte wie eine Plage gemieden werden. Es mu
+	sichergestellt werden, da im Suchpfad "/usr/ccs/bin" vor dem
+	Verzeichnis "/usr/xpg4/bin" erscheint und alles sollte sauber laufen.
+
+	BITTE BEACHTEN: Derzeit gibt es nicht sonderlich viel Untersttzung
+	fr SunOS/Solaris. Wenn ein Problem auftritt, versuche es selbst
+	zu lsen. Wenn Du erfolgreich bist, sende eine Mitteilung an die
+	Mailingliste mit den Angaben, was Du dafr getan hast. Wenn Du
+	keinen Erfolg hast, sende trotzdem eine Mitteilung an die Mailing-
+	liste und jemand _knnte_ Dir vielleicht helfen. Trotz alledem,
+	dies ist der einzige Weg, wie Probleme mit Xmame unter SunOS/
+	Solaris behoben werden knnen. 	
+
+
+Openstep
+========
+	
+	Folge den allgemeinen Anweisungen zum bersetzen von xmame. Aber
+	bei Editieren des makefile.unix folgendes beachten:
+	- Benutze NICHT gcc, sondern den CC von Openstep. Gcc kann die
+	  speziellen Openstep-Libraries nicht richtig linken.
+	- Suche nach -lm und entferne es und auch das -s in diesen Zeilen,
+	  Openstep braucht es nicht, aber wenn vorhanden, dann bricht
+	  das Compileren ab
+
+
+***********************************************************************
+6. Legalittsbedingungen und Copyrights, die Mame/Mess betreffen
+***********************************************************************
+
+Die Hauptbedingung betrifft ROM Images. ROM Images unterliegen dem 
+Copyright der jeweiligen Autoren und knnen NICHT im gleichen "Paket"
+wie Xmame/Xmess verbreitet werden. Man kann irgendwelche ROM Images
+runterladen, auf eigenes Risiko und auf eigene Verantwortung.
+
+XMame/XMess sollten verbreitet werden unter den Lizenzbestimmungen
+in doc/readme.mame
+
+Dieser Copyrightverweis sollte in allen Sourcecodearchiven vorhanden sein,
+um die Joystickuntersttzung basierend auf XInpugExtensions benutzen
+zu drfen. Der Sourcecode ist wirklich harte Arbeit. Keine Beispiel-
+programme, keine Informationen waren aufzutreiben (nur ein Referenz-
+handbuch zu den Libraries), und der Sourcecode unterliegt meinem
+Copyright (Juan Antonio Marmnez). Er kann unter den Bestimmungen der GNU 
+General Public License (GPL) genutzt werden.
+
+
+**********************************************************************
+7. Die "Macher" des Mame- und Mess-Projektes (who is who)
+**********************************************************************
+
+Die Vter von Mame:		Nicola Salmoria (General Mantainer)
+				Allard van der Bas
+				Mirko (Mix) Buffoni
+
+Die Vter von Mess:		Brad Oliver
+				Richard Bannister
+				Ben Bruscella (current coordinator)
+
+Original UNIX/X11 Portierung:	Dick the Ridder
+				Juan Antonio Marmnez
+
+Unix maintainer:		Hans de Goede
+
+Viele Leute haben uns untersttzt mit Informationen, ROM Images und
+anderen Dingen.
+Siehe dazu credits.unix. Dort sind einige der Helden genannt, die an der
+Unixportierung mitwirken.
+
diff --git a/src/unix/doc/makedoc.sh b/src/unix/doc/makedoc.sh
new file mode 100644
index 0000000..a67671f
--- /dev/null
+++ b/src/unix/doc/makedoc.sh
@@ -0,0 +1,45 @@
+#! /bin/sh
+
+if [ -z "$1" ] ; then
+	echo makedoc
+	echo 	-all   : make all   docus
+	echo 	-txt   : make txt   docus
+	echo 	-html  : make html  docus
+	echo 	-man   : make groff docus
+	echo 	-ps    : make ps    docus
+	echo 	-clean : clean up all generated docus
+	exit 0
+fi
+
+if [ "$1" = "-txt" -o "$1" = "-all" ] ; then
+	echo sgml2txt -c latin xmame-doc.sgml
+	sgml2txt -c latin xmame-doc.sgml
+fi
+
+if [ "$1" = "-html" -o "$1" = "-all" ] ; then
+	rm -f *.html
+	echo sgml2html -s 1 xmame-doc.sgml
+	sgml2html -s 1 xmame-doc.sgml
+fi
+
+if [ "$1" = "-man" -o "$1" = "-all" ] ; then
+	echo sgml2txt -m -f -c ascii xmame-doc.sgml
+	sgml2txt -m -f -c ascii xmame-doc.sgml
+	cat xmame-doc.man.skel > xmame.6
+	cat xmame-doc.man >> xmame.6
+	rm -f xmame-doc.man
+fi
+
+if [ "$1" = "-ps" ] ; then
+	echo sgml2latex, dvips ...
+	sgml2latex -o ps xmame-doc.sgml
+fi
+
+if [ "$1" = "-clean" ] ; then
+	rm -vf $(find . -name xmame-doc\*.html)
+	rm -vf xmame-doc.dvi
+	rm -vf xmame-doc.man
+	rm -vf xmame-doc.ps
+	rm -vf xmame-doc.txt
+	rm -vf xmame.6
+fi
diff --git a/src/unix/doc/mame/ctrlr.txt b/src/unix/doc/mame/ctrlr.txt
new file mode 100644
index 0000000..1b0063a
--- /dev/null
+++ b/src/unix/doc/mame/ctrlr.txt
@@ -0,0 +1,276 @@
+                 Controller-Specific Input Port Mappings
+                 ---------------------------------------
+
+The main purpose of the controller-specific .ini files is to remap the
+inputs.  This is handled via two mechanisms: key re-mapping and 
+sequence re-mapping.
+
+Key re-mapping occurs at the most basic level.  The specified keycode is
+replaced where ever it occurs (in all sequences) with the specified 
+replacement.  Only single keycodes can be used as a replacement (that is, a 
+single key cannot be replaced with a key sequence).
+
+Sequence mapping occurs at a higher level.  In this case, the entire
+key sequence for the given input is replaced with the specified key
+sequence.
+
+Keycodes are specified as a single keyword.  Key sequences are specified
+as a series of keycodes separated by spaces (the full sequence must be
+enclosed in quotes if spaces exist).  Two special keywords are available
+for defining key sequences, CODE_OR and CODE_NOT (which can abbreviated | 
+and ! respectively).
+
+When two keycodes are specified together (separated by only whitespace),
+the default action is a logical AND, such that both keys must be pressed
+at the same time for the action to occur.  Often it desired that either
+key can be pressed for the action to occur (for example LEFT CTRL and 
+Joystick Button 0), in which case the two keycodes need to be separated
+by a CODE_OR (|) keyword.  Finally, certain combinations may be 
+undesirable and warrant no action by MAME.  For these, the keywords should
+be specified by a CODE_NOT (!) (for example, ALT-TAB on a windows machine).
+
+An example file containing all key sequences and the standard definitions
+can be found in ctrlr\std.ini.  This file is NOT parsed by MAME and is
+only provided for reference.  Lines can be copied from this file to create
+a controller customization file.  When creating a file, keep the number of
+redefinitions to a minimum.  Any input not listed will default to the
+standard sequence.  Note that several files may be parsed for any given
+controller/game combination, so an input may be re-defined in multiple
+places.
+
+For support of controller input customization, two new command-line
+options were added:
+
+-ctrlr_directory "name"
+
+Specifies the directory that contains the controller customization .ini files.
+
+-ctrlr "name"
+
+Specifies a controller name for customization.  The .ini files for the 
+controller are stored in either a directory or a .zip file with the same
+name as the specified controller.  
+
+The first file in the directory/zip to be scanned is the file default.ini.
+From there, game-specific files are scanned starting with the top-most
+parent file and continuing down to the specified game name.
+
+Once the default.ini and all game-specific files are scanned, additional
+files may be scanned depending on the game type.  The files to be scanned
+are specified by the following custom keywords:
+
+dial_ini                "name"
+paddle_ini              "name"
+pedal_ini               "name"
+trackball_ini           "name"
+ad_stick_ini            "name"
+
+Each of these keywords specify the name of an .ini file that will be
+parsed if the game has one of these types of inputs.  For example,
+Tempest, which  has a dial input, will automatically parse the file
+specified by the dial_ini keyword.  Typically, all of the x_ini keywords
+will point to the same file (e.g. mouse.ini) which enables mouse and/or
+joystick support.  In this way, mouse and joystick support will only be
+enabled on those games that require it.  If all games for this controller
+require joystick and/or mouse support, those keywords can be placed in
+the main default.ini file.
+
+All of the options that can be specified on the command-line or in the 
+main mame.ini file can be specified in the controller-specific ini files, 
+though because of when these files are parsed, the specified options may 
+have no effect.  The only two general options guaranteed to be supported
+are mouse and joystick.  Note that command-line specification of these
+options takes precedence.  Since most front-ends, including MAME32, 
+specify these options through the command-line, the mouse and/or joystick
+options specified in the .ini files will be ignored.
+
+Another custom keyword is:
+
+ctrlrname               "name"
+
+This keyword defines a detailed name for the selected controller.  Names 
+that include spaces must be enclosed in quotes.
+
+
+Keywords:
+---------
+
+Keywords are separated into two categories, keycodes and input port
+definitions.  To specify a key re-mapping, specify the keycode as the
+keyword to re-define (that is, on the left-hand side) followed by the 
+replacement code.  To specify a sequence re-map, specify the input port 
+code to be re-defined on the left followed by the sequence.
+
+In addition to the standard codes, additional OSD specific codes may be
+generated.  The keycodes added are typically generated based on connected
+hardware.  For example, in the windows port, direct input is polled to
+determine what inputs are available and assign names.
+
+With respect to the windows port, the generated keycodes are identical
+to those displayed in the configuration menu with all spaces replaced by
+underscores.  For example, the keycodes automatically generated for a
+Wingman Warrior joystick are:
+
+J1_X-axis_+        J1_X-axis_-        J1_Y-axis_+        J1_Y-axis_-
+J1_Z-axis_+        J1_Z-axis_-        J1_Rz-axis_+       J1_Rz-axis_-
+J1_Button_0        J1_Button_1        J1_Button_2        J1_Button_3
+J1_POV_0_U         J1_POV_0_D         J1_POV_0_L         J1_POV_0_R
+
+The names generated will vary with the port to which the joystick is
+connected.  In the codes listed above, the Wingman Warrior was connected as
+the first joystick (J1).  If it had been configured as a different input,
+the generated codes would have a different Jx number.
+
+All keyword matching including the standard keywords is case sensitive.  
+Also, some of the automatically generated OSD codes may be redundant. 
+For example, J1_Button_0 is the same as JOYCODE_1_BUTTON1.  Standard codes
+are preferred over OSD codes.
+
+
+The standard keycodes are:
+--------------------------
+
+KEYCODE_A                KEYCODE_B                KEYCODE_C
+KEYCODE_D                KEYCODE_E                KEYCODE_F
+KEYCODE_G                KEYCODE_H                KEYCODE_I
+KEYCODE_J                KEYCODE_K                KEYCODE_L
+KEYCODE_M                KEYCODE_N                KEYCODE_O
+KEYCODE_P                KEYCODE_Q                KEYCODE_R
+KEYCODE_S                KEYCODE_T                KEYCODE_U
+KEYCODE_V                KEYCODE_W                KEYCODE_X
+KEYCODE_Y                KEYCODE_Z                KEYCODE_0
+KEYCODE_1                KEYCODE_2                KEYCODE_3
+KEYCODE_4                KEYCODE_5                KEYCODE_6
+KEYCODE_7                KEYCODE_8                KEYCODE_9
+KEYCODE_0_PAD            KEYCODE_1_PAD            KEYCODE_2_PAD
+KEYCODE_3_PAD            KEYCODE_4_PAD            KEYCODE_5_PAD
+KEYCODE_6_PAD            KEYCODE_7_PAD            KEYCODE_8_PAD
+KEYCODE_9_PAD            KEYCODE_F1               KEYCODE_F2
+KEYCODE_F3               KEYCODE_F4               KEYCODE_F5
+KEYCODE_F6               KEYCODE_F7               KEYCODE_F8
+KEYCODE_F9               KEYCODE_F10              KEYCODE_F11
+KEYCODE_F12              KEYCODE_ESC              KEYCODE_TILDE
+KEYCODE_MINUS            KEYCODE_EQUALS           KEYCODE_BACKSPACE
+KEYCODE_TAB              KEYCODE_OPENBRACE        KEYCODE_CLOSEBRACE
+KEYCODE_ENTER            KEYCODE_COLON            KEYCODE_QUOTE
+KEYCODE_BACKSLASH        KEYCODE_BACKSLASH2       KEYCODE_COMMA
+KEYCODE_STOP             KEYCODE_SLASH            KEYCODE_SPACE
+KEYCODE_INSERT           KEYCODE_DEL              KEYCODE_HOME
+KEYCODE_END              KEYCODE_PGUP             KEYCODE_PGDN
+KEYCODE_LEFT             KEYCODE_RIGHT            KEYCODE_UP
+KEYCODE_DOWN             KEYCODE_SLASH_PAD        KEYCODE_ASTERISK
+KEYCODE_MINUS_PAD        KEYCODE_PLUS_PAD         KEYCODE_DEL_PAD
+KEYCODE_ENTER_PAD        KEYCODE_PRTSCR           KEYCODE_PAUSE
+KEYCODE_LSHIFT           KEYCODE_RSHIFT           KEYCODE_LCONTROL
+KEYCODE_RCONTROL         KEYCODE_LALT             KEYCODE_RALT
+KEYCODE_SCRLOCK          KEYCODE_NUMLOCK          KEYCODE_CAPSLOCK
+KEYCODE_LWIN             KEYCODE_RWIN             KEYCODE_MENU
+
+JOYCODE_1_LEFT           JOYCODE_1_RIGHT          JOYCODE_1_UP
+JOYCODE_1_DOWN           JOYCODE_1_BUTTON1        JOYCODE_1_BUTTON2
+JOYCODE_1_BUTTON3        JOYCODE_1_BUTTON4        JOYCODE_1_BUTTON5
+JOYCODE_1_BUTTON6        JOYCODE_1_START          JOYCODE_1_SELECT
+JOYCODE_2_LEFT           JOYCODE_2_RIGHT          JOYCODE_2_UP
+JOYCODE_2_DOWN           JOYCODE_2_BUTTON1        JOYCODE_2_BUTTON2
+JOYCODE_2_BUTTON3        JOYCODE_2_BUTTON4        JOYCODE_2_BUTTON5
+JOYCODE_2_BUTTON6        JOYCODE_2_START          JOYCODE_2_SELECT
+JOYCODE_3_LEFT           JOYCODE_3_RIGHT          JOYCODE_3_UP
+JOYCODE_3_DOWN           JOYCODE_3_BUTTON1        JOYCODE_3_BUTTON2
+JOYCODE_3_BUTTON3        JOYCODE_3_BUTTON4        JOYCODE_3_BUTTON5
+JOYCODE_3_BUTTON6        JOYCODE_3_START          JOYCODE_3_SELECT
+JOYCODE_4_LEFT           JOYCODE_4_RIGHT          JOYCODE_4_UP
+JOYCODE_4_DOWN           JOYCODE_4_BUTTON1        JOYCODE_4_BUTTON2
+JOYCODE_4_BUTTON3        JOYCODE_4_BUTTON4        JOYCODE_4_BUTTON5
+JOYCODE_4_BUTTON6        JOYCODE_4_START          JOYCODE_4_SELECT
+
+MOUSECODE_1_BUTTON1      MOUSECODE_1_BUTTON2      MOUSECODE_1_BUTTON3
+
+KEYCODE_NONE             CODE_NONE                CODE_OTHER
+CODE_DEFAULT             CODE_PREVIOUS            CODE_NOT
+CODE_OR                  !                        |
+
+
+
+The input port codes are:
+-------------------------
+
+UI_CONFIGURE             UI_ON_SCREEN_DISPLAY     UI_PAUSE
+UI_RESET_MACHINE         UI_SHOW_GFX              UI_FRAMESKIP_DEC
+UI_FRAMESKIP_INC         UI_THROTTLE              UI_SHOW_FPS
+UI_SHOW_PROFILER         UI_SNAPSHOT              UI_TOGGLE_CHEAT
+UI_UP                    UI_DOWN                  UI_LEFT
+UI_RIGHT                 UI_SELECT                UI_CANCEL
+UI_PAN_UP                UI_PAN_DOWN              UI_PAN_LEFT
+UI_PAN_RIGHT             UI_TOGGLE_DEBUG          UI_SAVE_STATE
+UI_LOAD_STATE            UI_ADD_CHEAT             UI_DELETE_CHEAT
+UI_SAVE_CHEAT            UI_WATCH_VALUE           UI_EDIT_CHEAT
+START1                   START2                   START3
+START4                   COIN1                    COIN2
+COIN3                    COIN4                    SERVICE1
+SERVICE2                 SERVICE3                 SERVICE4
+TILT
+
+P1_JOYSTICK_UP           P1_JOYSTICK_DOWN         P1_JOYSTICK_LEFT
+P1_JOYSTICK_RIGHT        P1_BUTTON1               P1_BUTTON2
+P1_BUTTON3               P1_BUTTON4               P1_BUTTON5
+P1_BUTTON6               P1_BUTTON7               P1_BUTTON8
+P1_BUTTON9               P1_BUTTON10              P1_JOYSTICKRIGHT_UP
+P1_JOYSTICKRIGHT_DOWN    P1_JOYSTICKRIGHT_LEFT    P1_JOYSTICKRIGHT_RIGHT
+P1_JOYSTICKLEFT_UP       P1_JOYSTICKLEFT_DOWN     P1_JOYSTICKLEFT_LEFT
+P1_JOYSTICKLEFT_RIGHT
+
+P2_JOYSTICK_UP           P2_JOYSTICK_DOWN         P2_JOYSTICK_LEFT
+P2_JOYSTICK_RIGHT        P2_BUTTON1               P2_BUTTON2
+P2_BUTTON3               P2_BUTTON4               P2_BUTTON5
+P2_BUTTON6               P2_BUTTON7               P2_BUTTON8
+P2_BUTTON9               P2_BUTTON10              P2_JOYSTICKRIGHT_UP
+P2_JOYSTICKRIGHT_DOWN    P2_JOYSTICKRIGHT_LEFT    P2_JOYSTICKRIGHT_RIGHT
+P2_JOYSTICKLEFT_UP       P2_JOYSTICKLEFT_DOWN     P2_JOYSTICKLEFT_LEFT
+P2_JOYSTICKLEFT_RIGHT
+
+P3_JOYSTICK_UP           P3_JOYSTICK_DOWN         P3_JOYSTICK_LEFT
+P3_JOYSTICK_RIGHT        P3_BUTTON1               P3_BUTTON2
+P3_BUTTON3               P3_BUTTON4               
+
+P4_JOYSTICK_UP           P4_JOYSTICK_DOWN         P4_JOYSTICK_LEFT
+P4_JOYSTICK_RIGHT        P4_BUTTON1               P4_BUTTON2
+P4_BUTTON3               P4_BUTTON4               
+
+P1_PEDAL                 P1_PEDAL_EXT             P2_PEDAL
+P2_PEDAL_EXT             P3_PEDAL                 P3_PEDAL_EXT
+P4_PEDAL                 P4_PEDAL_EXT             
+
+P1_PADDLE                P1_PADDLE_EXT            P2_PADDLE
+P2_PADDLE_EXT            P3_PADDLE                P3_PADDLE_EXT
+P4_PADDLE                P4_PADDLE_EXT            P1_PADDLE_V
+P1_PADDLE_V_EXT          P2_PADDLE_V              P2_PADDLE_V_EXT
+P3_PADDLE_V              P3_PADDLE_V_EXT          P4_PADDLE_V
+P4_PADDLE_V_EXT
+
+P1_DIAL                  P1_DIAL_EXT              P2_DIAL
+P2_DIAL_EXT              P3_DIAL                  P3_DIAL_EXT
+P4_DIAL                  P4_DIAL_EXT              P1_DIAL_V
+P1_DIAL_V_EXT            P2_DIAL_V                P2_DIAL_V_EXT
+P3_DIAL_V                P3_DIAL_V_EXT            P4_DIAL_V
+P4_DIAL_V_EXT
+
+P1_TRACKBALL_X           P1_TRACKBALL_X_EXT       P2_TRACKBALL_X
+P2_TRACKBALL_X_EXT       P3_TRACKBALL_X           P3_TRACKBALL_X_EXT
+P4_TRACKBALL_X           P4_TRACKBALL_X_EXT       
+
+P1_TRACKBALL_Y           P1_TRACKBALL_Y_EXT       P2_TRACKBALL_Y
+P2_TRACKBALL_Y_EXT       P3_TRACKBALL_Y           P3_TRACKBALL_Y_EXT
+P4_TRACKBALL_Y           P4_TRACKBALL_Y_EXT       
+
+P1_AD_STICK_X            P1_AD_STICK_X_EXT        P2_AD_STICK_X
+P2_AD_STICK_X_EXT        P3_AD_STICK_X            P3_AD_STICK_X_EXT
+P4_AD_STICK_X            P4_AD_STICK_X_EXT        
+
+P1_AD_STICK_Y            P1_AD_STICK_Y_EXT        P2_AD_STICK_Y
+P2_AD_STICK_Y_EXT        P3_AD_STICK_Y            P3_AD_STICK_Y_EXT
+P4_AD_STICK_Y            P4_AD_STICK_Y_EXT        
+
+OSD_1                    OSD_2                    OSD_3
+OSD_4
+
+
diff --git a/src/unix/doc/mame/gamelist.txt b/src/unix/doc/mame/gamelist.txt
new file mode 100644
index 0000000..036007c
--- /dev/null
+++ b/src/unix/doc/mame/gamelist.txt
@@ -0,0 +1,2404 @@
+This is the complete list of games supported by MAME 0.74 (Sep 14 2003).
+Variants of the same game are not included, you can use the -listclones command
+to get a list of the alternate versions of a given game.
+
+This list is generated automatically and is not 100% accurate (particularly in
+the Screen Flip column). Please let us know of any errors so we can correct
+them.
+
+Here are the meanings of the columns:
+
+Working
+=======
+  NO: Emulation is still in progress; the game does not work correctly. This
+  means anything from major problems to a black screen.
+
+Correct Colors
+==============
+    YES: Colors should be identical to the original.
+  CLOSE: Colors are nearly correct.
+     NO: Colors are completely wrong. 
+  
+  Note: In some cases, the color PROMs for some games are not yet available.
+  This causes a NO GOOD DUMP KNOWN message on startup (and, of course, the game
+  has wrong colors). The game will still say YES in this column, however,
+  because the code to handle the color PROMs has been added to the driver. When
+  the PROMs are available, the colors will be correct.
+
+Sound
+=====
+  PARTIAL: Sound support is incomplete or not entirely accurate. 
+
+  Note: Some original games contain analog sound circuitry, which is difficult
+  to emulate. Therefore, these emulated sounds may be significantly different.
+
+Screen Flip
+===========
+  Many games were offered in cocktail-table models, allowing two players to sit
+  across from each other; the game's image flips 180 degrees for each player's
+  turn. Some games also have a "Flip Screen" DIP switch setting to turn the
+  picture (particularly useful with vertical games).
+  In many cases, this feature has not yet been emulated.
+
+Internal Name
+=============
+  This is the unique name that must be used when running the game from a
+  command line.
+
+  Note: Each game's ROM set must be placed in the ROM path, either in a .zip
+  file or in a subdirectory with the game's Internal Name. The former is
+  suggested, because the files will be identified by their CRC instead of
+  requiring specific names.
+
++----------------------------------+-------+-------+-------+-------+----------+
+|                                  |       |Correct|       |Screen | Internal |
+| Game Name                        |Working|Colors | Sound | Flip  |   Name   |
++----------------------------------+-------+-------+-------+-------+----------+
+| '88 Games                        |  Yes  |  Yes  |  Yes  |  Yes  | 88games  |
+| (Status) Triv Two                |  Yes  |   No  |  Yes  |  Yes  | statriv2 |
+| 005                              |  Yes  |  Yes  |   No  |  Yes  | 005      |
+| 10 Yard Fight                    |  Yes  |  Yes  |  Yes  |  Yes  | yard     |
+| 1941 - Counter Attack            |  Yes  |  Yes  |  Yes  |  Yes  | 1941     |
+| 1942                             |  Yes  |  Yes  |  Yes  |  Yes  | 1942     |
+| 1943 - The Battle of Midway      |  Yes  |  Yes  |  Yes  |  Yes  | 1943     |
+| 1943 Kai - Midway Kaisen         |  Yes  |  Yes  |  Yes  |  Yes  | 1943kai  |
+| 1944: The Loop Master            |  Yes  |  Yes  |  Yes  |  Yes  | 1944     |
+| 19XX: The War Against Destiny    |  Yes  |  Yes  |  Yes  |  Yes  | 19xx     |
+| 2 On 2 Open Ice Challenge        |  Yes  |  Yes  |  Yes  |  Yes  | openice  |
+| 2020 Super Baseball              |  Yes  |  Yes  |  Yes  |  Yes  | 2020bb   |
+| 3 Count Bout / Fire Suplex       |  Yes  |  Yes  |  Yes  |  Yes  | 3countb  |
+| 4 En Raya                        |  Yes  |  Yes  |  Yes  |  Yes  | 4enraya  |
+| 4 Fun in 1                       |  Yes  |  Yes  |Partial|  Yes  | 4in1     |
+| 4 Player Bowling Alley           |  Yes  |  Yes  |   No  |  Yes  | bowler   |
+| 4-D Warriors                     |  Yes  |  Yes  |  Yes  |  Yes  | 4dwarrio |
+| 64th. Street - A Detective Story |  Yes  |  Yes  |  Yes  |  Yes  | 64street |
+| 720 Degrees                      |  Yes  |  Yes  |  Yes  |  Yes  | 720      |
+| APB - All Points Bulletin        |  Yes  |  Yes  |  Yes  |  Yes  | apb      |
+| ASO - Armored Scrum Object       |  Yes  |  Yes  |  Yes  |   No  | aso      |
+| AV2Mahjong No.1 Bay Bridge no Sei|   No  |  Yes  |  Yes  |  Yes  | av2mj1bb |
+| AV2Mahjong No.2 Rouge no Kaori   |   No  |  Yes  |  Yes  |  Yes  | av2mj2rg |
+| Ace                              |  Yes  | Close |   No  |  Yes  | ace      |
+| Acrobat Mission                  |  Yes  |  Yes  |   No  |  Yes  | acrobatm |
+| Acrobatic Dog-Fight              |  Yes  |  Yes  |  Yes  |  Yes  | dogfgt   |
+| Act-Fancer Cybernetick Hyper Weap|  Yes  |  Yes  |  Yes  |  Yes  | actfancr |
+| Adventure Quiz 2 Hatena Hatena no|  Yes  |  Yes  |  Yes  |  Yes  | hatena   |
+| Aero Fighters                    |  Yes  |  Yes  |  Yes  |   No  | aerofgt  |
+| Aero Fighters 2 / Sonic Wings 2  |  Yes  |  Yes  |  Yes  |  Yes  | sonicwi2 |
+| Aero Fighters 3 / Sonic Wings 3  |  Yes  |  Yes  |  Yes  |  Yes  | sonicwi3 |
+| After Burner II                  |  Yes  |  Yes  |  Yes  |  Yes  | aburner2 |
+| Aggressors of Dark Kombat / Tsuuk|  Yes  |  Yes  |  Yes  |  Yes  | aodk     |
+| Ah Eikou no Koshien              |  Yes  |  Yes  |  Yes  |  Yes  | koshien  |
+| Air Buster                       |  Yes  |  Yes  |  Yes  |  Yes  | airbustr |
+| Air Duel                         |  Yes  |  Yes  |  Yes  |   No  | airduel  |
+| Air Gallet                       |  Yes  |  Yes  |  Yes  |  Yes  | agallet  |
+| Airwolf                          |  Yes  |  Yes  |  Yes  |  Yes  | airwolf  |
+| Ajax                             |  Yes  |  Yes  |  Yes  |  Yes  | ajax     |
+| Alex Kidd: The Lost Stars        | No(1) |  Yes  |  Yes  |  Yes  | alexkidd |
+| Ali Baba and 40 Thieves          |   No  |   No  |  Yes  |  Yes  | alibaba  |
+| Alien 3                          |  Yes  |  Yes  |  Yes  |  Yes  | alien3   |
+| Alien Storm                      | No(1) |  Yes  |  Yes  |  Yes  | astorm   |
+| Alien Syndrome                   |  Yes  |  Yes  |  Yes  |  Yes  | aliensyn |
+| Alien vs. Predator               |  Yes  |  Yes  |  Yes  |  Yes  | avsp     |
+| Aliens                           |  Yes  |  Yes  |  Yes  |  Yes  | aliens   |
+| All American Football            |  Yes  |  Yes  |  Yes  |  Yes  | aafb     |
+| Alley Master                     |  Yes  |  Yes  |  Yes  |  Yes  | alleymas |
+| Alligator Hunt                   | No(1) |  Yes  |  Yes  |  Yes  | aligator |
+| Alpha Fighter / Head On          |  Yes  |   No  | Yes(2)|  Yes  | alphaho  |
+| Alpha Mission II / ASO II - Last |  Yes  |  Yes  |  Yes  |  Yes  | alpham2  |
+| Alpine Ski                       |  Yes  |  Yes  |  Yes  |  Yes  | alpine   |
+| Altered Beast                    |  Yes  |  Yes  |  Yes  |  Yes  | altbeast |
+| Amazing Adventures of Mr. F. Lea,|  Yes  |  Yes  |  Yes  |  Yes  | mrflea   |
+| Amazing Maze                     |  Yes  |  Yes  |   No  |  Yes  | maze     |
+| Ambush                           |  Yes  |  Yes  |  Yes  |  Yes  | ambush   |
+| American Horseshoes              |  Yes  |  Yes  |  Yes  |  Yes  | horshoes |
+| American Speedway                |  Yes  |  Yes  |  Yes  |  Yes  | amspdwy  |
+| Amidar                           |  Yes  |  Yes  |  Yes  |  Yes  | amidar   |
+| Andro Dunos                      |  Yes  |  Yes  |  Yes  |  Yes  | androdun |
+| Angel Kids                       |  Yes  |  Yes  |  Yes  |  Yes  | angelkds |
+| Anteater                         |  Yes  |  Yes  |  Yes  |  Yes  | anteater |
+| Apparel Night                    |  Yes  |  Yes  |  Yes  |  Yes  | apparel  |
+| Appoooh                          |  Yes  |  Yes  |  Yes  |  Yes  | appoooh  |
+| Aqua Jack                        |  Yes  |  Yes  |  Yes  |  Yes  | aquajack |
+| Aquarium                         |  Yes  |  Yes  |Partial|   No  | aquarium |
+| Arabian                          |  Yes  |  Yes  |  Yes  |  Yes  | arabian  |
+| Arabian Fight                    |  Yes  |  Yes  |  Yes  |  Yes  | arabfgt  |
+| Arabian Magic                    |  Yes  |  Yes  |  Yes  |  Yes  | arabianm |
+| Arbalester                       |  Yes  |  Yes  |  Yes  |  Yes  | arbalest |
+| Arcade Classics                  |  Yes  |  Yes  |  Yes  |  Yes  | arcadecl |
+| Arch Rivals                      |  Yes  |  Yes  |  Yes  |  Yes  | archrivl |
+| Area 51                          |  Yes  |  Yes  |  Yes  |  Yes  | area51   |
+| Area 51 / Maximum Force Duo v2.0 |  Yes  |  Yes  |  Yes  |  Yes  | area51mx |
+| Argus                            |  Yes  |  Yes  |  Yes  |  Yes  | argus    |
+| Ark Area                         |  Yes  |  Yes  |  Yes  |  Yes  | arkarea  |
+| Arkanoid                         |  Yes  |  Yes  |  Yes  |  Yes  | arkanoid |
+| Arkanoid - Revenge of DOH        |  Yes  |  Yes  |  Yes  |  Yes  | arknoid2 |
+| Arkanoid Returns                 |  Yes  |  Yes  |  Yes  |  Yes  | arkretrn |
+| Arlington Horse Racing           |  Yes  |  Yes  |  Yes  |  Yes  | arlingtn |
+| Arm Wrestling                    |  Yes  |  Yes  |  Yes  |  Yes  | armwrest |
+| Armed Formation                  |  Yes  |  Yes  |  Yes  |  Yes  | armedf   |
+| Armed Police Batrider            |  Yes  |  Yes  |  Yes  |  Yes  | batrider |
+| Armor Attack                     |  Yes  |  Yes  |   No  |  Yes  | armora   |
+| Armored Car                      |  Yes  |  Yes  |  Yes  |  Yes  | armorcar |
+| Armored Warriors                 |  Yes  |  Yes  |  Yes  |  Yes  | armwar   |
+| Art of Fighting / Ryuuko no Ken  |  Yes  |  Yes  |  Yes  |  Yes  | aof      |
+| Art of Fighting 2 / Ryuuko no Ken|  Yes  |  Yes  |  Yes  |  Yes  | aof2     |
+| Art of Fighting 3 - The Path of t|  Yes  |  Yes  |  Yes  |  Yes  | aof3     |
+| Ashura Blaster                   |  Yes  |  Yes  |  Yes  |  Yes  | ashura   |
+| Assault                          |  Yes  |  Yes  |  Yes  |  Yes  | assault  |
+| Asterix                          |  Yes  |  Yes  |  Yes  |  Yes  | asterix  |
+| Asteroids                        |  Yes  |  Yes  |  Yes  |  Yes  | asteroid |
+| Asteroids Deluxe                 |  Yes  |  Yes  |  Yes  |  Yes  | astdelux |
+| Astro Blaster                    |  Yes  |  Yes  | Yes(2)|  Yes  | astrob   |
+| Astro Fighter                    |  Yes  |  Yes  | Yes(2)|  Yes  | astrof   |
+| Astro Invader                    |  Yes  |  Yes  | Yes(2)|  Yes  | astinvad |
+| Astyanax, The                    |  Yes  |  Yes  |  Yes  |  Yes  | astyanax |
+| Asuka & Asuka                    |  Yes  |  Yes  |  Yes  |  Yes  | asuka    |
+| Asura Blade - Sword of Dynasty   |  Yes  |  Yes  |   No  |  Yes  | asurabld |
+| Asylum                           |  Yes  |  Yes  |  Yes  |  Yes  | asylum   |
+| Atari Baseball                   |  Yes  |  Yes  |  Yes  |  Yes  | abaseb   |
+| Atari Football                   |  Yes  |  Yes  |  Yes  |  Yes  | atarifb  |
+| Atari Soccer                     |  Yes  |  Yes  |  Yes  |  Yes  | soccer   |
+| Ataxx                            |  Yes  |  Yes  |  Yes  |  Yes  | ataxx    |
+| Athena                           |  Yes  |  Yes  |  Yes  |   No  | athena   |
+| Athena no Hatena ?               |  Yes  |  Yes  |  Yes  |  Yes  | atehate  |
+| Atomic Point                     |  Yes  |  Yes  |   No  |  Yes  | atomicp  |
+| Atomic Robo-kid                  |  Yes  |  Yes  |  Yes  |   No  | robokid  |
+| Aurail                           |  Yes  |  Yes  |  Yes  |  Yes  | aurail   |
+| Avalanche                        |  Yes  |  Yes  |  Yes  |  Yes  | avalnche |
+| Avengers                         |  Yes  |  Yes  |  Yes  |  Yes  | avengers |
+| Avenging Spirit                  |  Yes  |  Yes  |  Yes  |  Yes  | avspirit |
+| Aztarac                          |  Yes  |  Yes  |  Yes  |  Yes  | aztarac  |
+| Azurian Attack                   |  Yes  |  Yes  |  Yes  |  Yes  | azurian  |
+| B-Wings                          |  Yes  |  Yes  |  Yes  |  Yes  | bwing    |
+| Back Street Soccer               |  Yes  |  Yes  |  Yes  |  Yes  | bssoccer |
+| Bad Dudes vs. Dragonninja        |  Yes  |  Yes  |  Yes  |  Yes  | baddudes |
+| Bad Lands                        |  Yes  |  Yes  |  Yes  |  Yes  | badlands |
+| Bagman                           |  Yes  |  Yes  |  Yes  |  Yes  | bagman   |
+| Bakatonosama Mahjong Manyuki     |  Yes  |  Yes  |  Yes  |  Yes  | bakatono |
+| Bakuretsu Quiz Ma-Q Dai Bouken   |  Yes  |  Yes  |Partial|  Yes  | bkrtmaq  |
+| Bakutotsu Kijuutei               |  Yes  |  Yes  |  Yes  |  Yes  | bakutotu |
+| Bal Cube                         |  Yes  |  Yes  |  Yes  |  Yes  | balcube  |
+| Balloon Bomber                   |  Yes  |  Yes  |   No  |  Yes  | ballbomb |
+| Balloon Brothers                 |  Yes  |  Yes  |  Yes  |  Yes  | ballbros |
+| Baluba-louk no Densetsu          |  Yes  | Close |  Yes  |  Yes  | baluba   |
+| Bang Bang Ball                   |  Yes  |  Yes  |  Yes  |  Yes  | bangball |
+| Bang Bead                        |  Yes  |  Yes  |  Yes  |  Yes  | bangbead |
+| Bang!                            |  Yes  |  Yes  |  Yes  |  Yes  | bang     |
+| Bank Panic                       |  Yes  |  Yes  |  Yes  |  Yes  | bankp    |
+| Baraduke                         |  Yes  |  Yes  |  Yes  |  Yes  | baraduke |
+| Barricade                        |  Yes  |  Yes  |   No  |  Yes  | barricad |
+| Barrier                          |  Yes  |  Yes  |   No  |  Yes  | barrier  |
+| Baseball Stars 2                 |  Yes  |  Yes  |  Yes  |  Yes  | bstars2  |
+| Baseball Stars Professional      |  Yes  |  Yes  |  Yes  |  Yes  | bstars   |
+| Baseball The Season II           |  Yes  |  Yes  |  Yes  |  Yes  | basebal2 |
+| Basketball                       |  Yes  |  Yes  |  Yes  |  Yes  | bsktball |
+| Batman                           |  Yes  |  Yes  |  Yes  |  Yes  | batman   |
+| Batsugun                         |  Yes  |  Yes  |   No  |  Yes  | batsugun |
+| Battlantis                       |  Yes  |  Yes  |  Yes  |  Yes  | battlnts |
+| Battle Bakraid - unlimited versio|  Yes  |  Yes  |  Yes  |  Yes  | bbakraid |
+| Battle Chopper                   |  Yes  |  Yes  |  Yes  |   No  | bchopper |
+| Battle Circuit                   |  Yes  |  Yes  |  Yes  |  Yes  | batcir   |
+| Battle Cross                     |  Yes  |  Yes  |  Yes  |  Yes  | battlex  |
+| Battle Cruiser M-12              |  Yes  |  Yes  |  Yes  |  Yes  | bcruzm12 |
+| Battle Flip Shot                 |  Yes  |  Yes  |  Yes  |  Yes  | flipshot |
+| Battle Garegga - Type 2          |  Yes  |  Yes  |  Yes  |  Yes  | battleg  |
+| Battle K-Road                    |  Yes  |  Yes  |  Yes  |  Yes  | btlkroad |
+| Battle Lane! Vol. 5              |  Yes  |  Yes  |  Yes  |  Yes  | battlane |
+| Battle Rangers                   |  Yes  |  Yes  |Partial|  Yes  | battlera |
+| Battle Shark                     |  Yes  |  Yes  |  Yes  |  Yes  | bshark   |
+| Battle Toads                     |  Yes  |  Yes  |  Yes  |  Yes  | btoads   |
+| Battle Zone                      |  Yes  |  Yes  |  Yes  |  Yes  | bzone    |
+| Battle of Atlantis               |  Yes  |  Yes  |  Yes  |  Yes  | atlantis |
+| Battle-Road, The                 |  Yes  |  Yes  |  Yes  |  Yes  | battroad |
+| Battlecry                        |  Yes  |  Yes  |  Yes  |  Yes  | battlcry |
+| Bay Route                        |  Yes  |  Yes  |  Yes  |  Yes  | bayroute |
+| Beam Invader                     |  Yes  |  Yes  |   No  |  Yes  | beaminv  |
+| Beast Busters                    |  Yes  |  Yes  |  Yes  |  Yes  | bbusters |
+| BeatHead                         |  Yes  |  Yes  |  Yes  |  Yes  | beathead |
+| Beezer                           |  Yes  |  Yes  |Partial|  Yes  | beezer   |
+| Bells & Whistles                 |  Yes  |  Yes  |  Yes  |  Yes  | blswhstl |
+| Ben Bero Beh                     |  Yes  | Close |  Yes  |  Yes  | benberob |
+| Beraboh Man                      |  Yes  |  Yes  |  Yes  |  Yes  | berabohm |
+| Berlin Wall, The                 |  Yes  |  Yes  |  Yes  |  Yes  | berlwall |
+| Bermuda Triangle                 |  Yes  |  Yes  |  Yes  |   No  | bermudat |
+| Berzerk                          |  Yes  |  Yes  | Yes(2)|  Yes  | berzerk  |
+| Best Bout Boxing                 |  Yes  |  Yes  |   No  |  Yes  | bbbxing  |
+| Big Event Golf                   |  Yes  |  Yes  |  Yes  |  Yes  | bigevglf |
+| Big Karnak                       |  Yes  |  Yes  |  Yes  |  Yes  | bigkarnk |
+| Big Pro Wrestling!, The          |  Yes  |  Yes  |  Yes  |  Yes  | bigprowr |
+| Big Run                          |  Yes  |  Yes  |  Yes  |  Yes  | bigrun   |
+| Big Striker                      |  Yes  |  Yes  |  Yes  |  Yes  | bigstrik |
+| Big Twin                         |  Yes  |  Yes  |  Yes  |   No  | bigtwin  |
+| Bigfoot Bonkers                  |  Yes  |  Yes  |  Yes  |  Yes  | bbonk    |
+| Bijokko Gakuen                   |  Yes  |  Yes  |  Yes  |  Yes  | bijokkog |
+| Bijokko Yume Monogatari          |  Yes  |  Yes  |  Yes  |  Yes  | bijokkoy |
+| Billiard Academy Real Break      |  Yes  |  Yes  |  Yes  |  Yes  | realbrk  |
+| Bio Attack                       |  Yes  |  Yes  |  Yes  |  Yes  | bioatack |
+| Bio-ship Paladin                 |  Yes  |  Yes  |   No  |  Yes  | bioship  |
+| Biomechanical Toy                |  Yes  |  Yes  |  Yes  |  Yes  | biomtoy  |
+| Bionic Commando                  |  Yes  |  Yes  |  Yes  |  Yes  | bionicc  |
+| Birdie King                      |  Yes  |  Yes  |  Yes  |  Yes  | bking    |
+| Birdie King 2                    |  Yes  |  Yes  |  Yes  |  Yes  | bking2   |
+| Birdie King 3                    |  Yes  |  Yes  |  Yes  |  Yes  | bking3   |
+| Birdie Try                       |   No  |  Yes  |  Yes  |  Yes  | birdtry  |
+| Bishoujo Janshi Pretty Sailor 18-|  Yes  |  Yes  |  Yes  |  Yes  | psailor1 |
+| Bishoujo Janshi Pretty Sailor 2  |  Yes  |  Yes  |  Yes  |  Yes  | psailor2 |
+| Black Heart                      |   No  |  Yes  |   No  |  Yes  | blkheart |
+| Black Hole                       |  Yes  |  Yes  |  Yes  |  Yes  | blkhole  |
+| Black Panther                    |  Yes  |  Yes  |  Yes  |   No  | blkpnthr |
+| Black Tiger                      |  Yes  |  Yes  |  Yes  |  Yes  | blktiger |
+| Black Widow                      |  Yes  |  Yes  |  Yes  |  Yes  | bwidow   |
+| Blade Master                     |  Yes  |  Yes  |  Yes  |  Yes  | bmaster  |
+| Blades of Steel                  |  Yes  |  Yes  |  Yes  |  Yes  | bladestl |
+| Blandia                          |  Yes  |  Yes  |  Yes  |  Yes  | blandia  |
+| Blast Off                        |  Yes  |  Yes  |  Yes  |  Yes  | blastoff |
+| Blasted                          |  Yes  |  Yes  |  Yes  |  Yes  | blasted  |
+| Blaster                          |  Yes  |  Yes  |  Yes  |  Yes  | blaster  |
+| Blasteroids                      |  Yes  |  Yes  |  Yes  |  Yes  | blstroid |
+| Blasto                           |  Yes  |  Yes  |Part(2)|  Yes  | blasto   |
+| Blaze On                         |  Yes  |  Yes  |  Yes  |  Yes  | blazeon  |
+| Blazer                           |  Yes  |  Yes  |  Yes  |  Yes  | blazer   |
+| Blazing Star                     |  Yes  |  Yes  |  Yes  |  Yes  | blazstar |
+| Blazing Tornado                  |  Yes  |  Yes  |  Yes  |  Yes  | blzntrnd |
+| Block Block                      |  Yes  |  Yes  |  Yes  |  Yes  | block    |
+| Block Carnival / Thunder & Lightn|  Yes  |  Yes  |  Yes  |  Yes  | blockcar |
+| Block Gal                        | No(1) |  Yes  |  Yes  |   No  | blockgal |
+| Block Hole                       |  Yes  |  Yes  |  Yes  |  Yes  | blockhl  |
+| Block Out                        |  Yes  |  Yes  |  Yes  |  Yes  | blockout |
+| Blockade                         |  Yes  |  Yes  |Part(2)|  Yes  | blockade |
+| Blocken                          |  Yes  |  Yes  |  Yes  |  Yes  | blocken  |
+| Blomby Car                       |  Yes  |  Yes  |  Yes  |  Yes  | blmbycar |
+| Blood Bros.                      |  Yes  |  Yes  |  Yes  |   No  | bloodbro |
+| Blood Storm                      |  Yes  |  Yes  |  Yes  |  Yes  | bloodstm |
+| Bloxeed                          | No(1) |  Yes  |  Yes  |  Yes  | bloxeed  |
+| Blue Hawk                        |  Yes  |  Yes  |  Yes  |  Yes  | bluehawk |
+| Blue Print                       |  Yes  |  Yes  |  Yes  |  Yes  | blueprnt |
+| Blue Shark                       |  Yes  |  Yes  |   No  |  Yes  | blueshrk |
+| Blue's Journey / Raguy           |  Yes  |  Yes  |  Yes  |  Yes  | bjourney |
+| Boardwalk Casino                 |  Yes  |  Yes  |  Yes  |  Yes  | bwcasino |
+| Body Slam                        |  Yes  |  Yes  |  Yes  |  Yes  | bodyslam |
+| Bogey Manor                      |  Yes  | Close |  Yes  |  Yes  | bogeyman |
+| Boggy '84                        |  Yes  |  Yes  |  Yes  |  Yes  | boggy84  |
+| Bomb Bee                         |  Yes  |  Yes  |  Yes  |  Yes  | bombbee  |
+| Bomb Jack                        |  Yes  |  Yes  |  Yes  |  Yes  | bombjack |
+| Bomber Man World                 |  Yes  |  Yes  |Partial|   No  | bbmanw   |
+| Bomberman                        |  Yes  |  Yes  |  Yes  |   No  | bombrman |
+| Bombjack Twin                    |  Yes  |  Yes  |  Yes  |   No  | bjtwin   |
+| Bonze Adventure                  |  Yes  |  Yes  |  Yes  |  Yes  | bonzeadv |
+| Boomer Rang'r / Genesis          |  Yes  |  Yes  |  Yes  |  Yes  | boomrang |
+| Boot Hill                        |  Yes  |  Yes  | Yes(2)|  Yes  | boothill |
+| Borench                          |  Yes  |  Yes  |  Yes  |  Yes  | borench  |
+| Bosconian                        |  Yes  |  Yes  | Yes(2)|  Yes  | bosco    |
+| Bottom of the Ninth              |  Yes  |  Yes  |  Yes  |  Yes  | bottom9  |
+| Boulder Dash / Boulder Dash Part |  Yes  |  Yes  |  Yes  |  Yes  | bouldash |
+| Bouncing Balls                   |  Yes  |  Yes  |  Yes  |  Yes  | bballs   |
+| Bounty, The                      |  Yes  |  Yes  |  Yes  |  Yes  | bounty   |
+| Bowl-O-Rama                      |  Yes  |  Yes  |  Yes  |  Yes  | bowlrama |
+| Boxer                            |  Yes  |  Yes  |   No  |  Yes  | boxer    |
+| Boxing Bugs                      |  Yes  | Close |   No  |  Yes  | boxingb  |
+| Boxy Boy                         |  Yes  |  Yes  |  Yes  |  Yes  | boxyboy  |
+| Bradley Trainer                  |  Yes  |  Yes  |  Yes  |  Yes  | bradley  |
+| Brain                            |  Yes  |  Yes  |  Yes  |  Yes  | brain    |
+| Break Thru                       |  Yes  |  Yes  |  Yes  |  Yes  | brkthru  |
+| Breakers                         |  Yes  |  Yes  |  Yes  |  Yes  | breakers |
+| Brute Force                      |  Yes  |  Yes  |  Yes  |  Yes  | brutforc |
+| Bubble 2000                      |  Yes  |  Yes  |  Yes  |  Yes  | bubl2000 |
+| Bubble Bobble                    |  Yes  |  Yes  |  Yes  |  Yes  | bublbobl |
+| Bubble Bobble 2                  |  Yes  |  Yes  |  Yes  |  Yes  | bublbob2 |
+| Bubble Memories - The Story Of Bu|  Yes  |  Yes  |  Yes  |  Yes  | bubblem  |
+| Bubbles                          |  Yes  |  Yes  |  Yes  |  Yes  | bubbles  |
+| Buck Rogers: Planet of Zoom      |  Yes  |  Yes  | Yes(2)|  Yes  | buckrog  |
+| Bucky O'Hare                     |  Yes  |  Yes  |  Yes  |  Yes  | bucky    |
+| Buggy Challenge                  |  Yes  |  Yes  |Partial|  Yes  | buggychl |
+| Bull Fighter                     |   No  |   No  |  Yes  |  Yes  | bullfgtr |
+| Bullfight                        |  Yes  |  Yes  |  Yes  |  Yes  | bullfgt  |
+| Burger Time                      |  Yes  |  Yes  |  Yes  |  Yes  | btime    |
+| Burglar X                        |  Yes  |  Yes  |  Yes  |  Yes  | burglarx |
+| Burnin' Rubber                   |  Yes  |  Yes  |  Yes  |  Yes  | brubber  |
+| Burning Fight                    |  Yes  |  Yes  |  Yes  |  Yes  | burningf |
+| Burning Force                    |  Yes  |  Yes  |  Yes  |  Yes  | burnforc |
+| Burning Rival                    |  Yes  |  Yes  |  Yes  |  Yes  | brival   |
+| Butasan                          |  Yes  |  Yes  |  Yes  |  Yes  | butasan  |
+| Cabal                            |  Yes  |  Yes  |Partial|  Yes  | cabal    |
+| Cachat                           |  Yes  |  Yes  |  Yes  |  Yes  | cachat   |
+| Cadash                           |  Yes  |  Yes  |  Yes  |  Yes  | cadash   |
+| Cadillacs and Dinosaurs          |  Yes  |  Yes  |  Yes  |  Yes  | dino     |
+| Caliber 50                       |  Yes  |  Yes  |  Yes  |  Yes  | calibr50 |
+| Calipso                          |  Yes  |  Yes  |  Yes  |  Yes  | calipso  |
+| Cameltry                         |  Yes  |  Yes  |  Yes  |  Yes  | cameltry |
+| Cannon Ball                      |  Yes  |  Yes  |  Yes  |  Yes  | cannonb  |
+| Cannon Ball                      |  Yes  |  Yes  |Partial|  Yes  | cannball |
+| Canyon Bomber                    |  Yes  |  Yes  |  Yes  |  Yes  | canyon   |
+| Capcom Baseball                  |  Yes  |  Yes  |  Yes  |  Yes  | cbasebal |
+| Capcom Bowling                   |  Yes  |  Yes  |  Yes  |  Yes  | capbowl  |
+| Capcom Sports Club               |  Yes  |  Yes  |  Yes  |  Yes  | csclub   |
+| Capcom World                     |  Yes  |  Yes  |  Yes  |  Yes  | cworld   |
+| Capcom World 2                   |  Yes  |  Yes  |  Yes  |  Yes  | cworld2j |
+| Captain America and The Avengers |  Yes  |  Yes  |  Yes  |  Yes  | captaven |
+| Captain Commando                 |  Yes  |  Yes  |  Yes  |  Yes  | captcomm |
+| Captain Silver                   |  Yes  |  Yes  |  Yes  |  Yes  | csilver  |
+| Captain Tomaday                  |  Yes  |  Yes  |  Yes  |  Yes  | ctomaday |
+| Car Jamboree                     |  Yes  | Close |  Yes  |  Yes  | carjmbre |
+| Car Polo                         |  Yes  |  Yes  |   No  |  Yes  | carpolo  |
+| Carnival                         |  Yes  |  Yes  | Yes(2)|  Yes  | carnival |
+| Carrier Air Wing                 |  Yes  |  Yes  |  Yes  |  Yes  | cawing   |
+| Cassette: Astro Fantasia         |  Yes  |  Yes  |  Yes  |  Yes  | castfant |
+| Cassette: Boulder Dash           |  Yes  |  Yes  |  Yes  |  Yes  | cbdash   |
+| Cassette: Burger Time            |  Yes  |  Yes  |  Yes  |  Yes  | cbtime   |
+| Cassette: Burnin' Rubber         |  Yes  |  Yes  |  Yes  |  Yes  | cburnrub |
+| Cassette: Disco No.1             |  Yes  |  Yes  |  Yes  |  Yes  | cdiscon1 |
+| Cassette: Explorer               |   No  |  Yes  |  Yes  |  Yes  | cexplore |
+| Cassette: Fighting Ice Hockey    |  Yes  |  Yes  |  Yes  |  Yes  | cfghtice |
+| Cassette: Graplop                |  Yes  |  Yes  |  Yes  |  Yes  | cgraplop |
+| Cassette: Lock'n'Chase           |  Yes  |  Yes  |  Yes  |  Yes  | clocknch |
+| Cassette: Lucky Poker            |  Yes  |  Yes  |  Yes  |  Yes  | cluckypo |
+| Cassette: Mission-X              |  Yes  |  Yes  |  Yes  |  Yes  | cmissnx  |
+| Cassette: Night Star             |  Yes  |  Yes  |  Yes  |  Yes  | cnightst |
+| Cassette: Peter Pepper's Ice Crea|  Yes  |  Yes  |  Yes  |  Yes  | cppicf   |
+| Cassette: Pro Bowling            |  Yes  |  Yes  |  Yes  |  Yes  | cprobowl |
+| Cassette: Pro Golf               |  Yes  |  Yes  |  Yes  |  Yes  | cprogolf |
+| Cassette: Pro Soccer             |  Yes  |  Yes  |  Yes  |  Yes  | cprosocc |
+| Cassette: Pro Tennis             |  Yes  |  Yes  |  Yes  |  Yes  | cptennis |
+| Cassette: Rootin' Tootin'        |  Yes  |  Yes  |  Yes  |  Yes  | clapapa  |
+| Cassette: Scrum Try              |  Yes  |  Yes  |  Yes  |  Yes  | cscrtry  |
+| Cassette: Super Astro Fighter    |  Yes  |  Yes  |  Yes  |  Yes  | csuperas |
+| Cassette: Terranean              |  Yes  |  Yes  |  Yes  |  Yes  | cterrani |
+| Cassette: Test Tape              |  Yes  |  Yes  |  Yes  |  Yes  | ctsttape |
+| Cassette: Tornado                |  Yes  |  Yes  |  Yes  |  Yes  | ctornado |
+| Cassette: Treasure Island        |  Yes  |  Yes  |  Yes  |  Yes  | ctisland |
+| Catapult                         |   No  |  Yes  |  Yes  |  Yes  | catapult |
+| Cavelon                          |  Yes  |  Yes  |  Yes  |  Yes  | cavelon  |
+| Caveman Ninja                    |  Yes  |  Yes  |  Yes  |  Yes  | cninja   |
+| Centipede                        |  Yes  |  Yes  |  Yes  |  Yes  | centiped |
+| Cerberus                         |  Yes  |  Yes  |  Yes  |  Yes  | cerberus |
+| Chack'n Pop                      |  Yes  |  Yes  |  Yes  |  Yes  | chaknpop |
+| Challenger                       |  Yes  |  Yes  |  Yes  |  Yes  | challeng |
+| Chameleon                        |  Yes  |  Yes  |  Yes  |  Yes  | chameleo |
+| Champion Baseball                |  Yes  |  Yes  |  Yes  |  Yes  | champbas |
+| Champion Boxing                  |  Yes  |  Yes  |  Yes  |  Yes  | chboxing |
+| Champion Pro Wrestling           |  Yes  |  Yes  |  Yes  |  Yes  | chwrestl |
+| Champion Wrestler                |  Yes  |  Yes  |  Yes  |  Yes  | champwr  |
+| Championship Sprint              |  Yes  |  Yes  |  Yes  |  Yes  | csprint  |
+| Change Air Blade                 |  Yes  |  Yes  |  Yes  |   No  | cairblad |
+| Changes                          |  Yes  |  Yes  |  Yes  |  Yes  | changes  |
+| Chase H.Q.                       |  Yes  |  Yes  |  Yes  |  Yes  | chasehq  |
+| Check Man                        |  Yes  |  Yes  |  Yes  |  Yes  | checkman |
+| Checkmate                        |  Yes  |  Yes  |   No  |  Yes  | checkmat |
+| Cheeky Mouse                     |  Yes  |   No  |Partial|  Yes  | cheekyms |
+| Cheese Chase                     |  Yes  |  Yes  |  Yes  |  Yes  | cheesech |
+| Chelnov - Atomic Runner          |  Yes  |  Yes  |  Yes  |  Yes  | chelnov  |
+| Chequered Flag                   |   No  |  Yes  |Partial|  Yes  | chqflag  |
+| Cheyenne                         |  Yes  |  Yes  |  Yes  |  Yes  | cheyenne |
+| Chibi Marukochan Deluxe Quiz     |  Yes  |  Yes  |  Yes  |  Yes  | marukodq |
+| Chicken Shift                    |  Yes  |  Yes  |  Yes  |  Yes  | cshift   |
+| Chiller                          |  Yes  |  Yes  |  Yes  |  Yes  | chiller  |
+| Chimera Beast                    |  Yes  |  Yes  |  Yes  |  Yes  | chimerab |
+| China Gate                       |  Yes  |  Yes  |  Yes  |  Yes  | chinagat |
+| China Town                       |  Yes  |  Yes  |  Yes  |  Yes  | chinatwn |
+| Chinese Casino [BET]             |  Yes  |  Yes  |  Yes  |  Yes  | ccasino  |
+| Chinese Hero                     |  Yes  |  Yes  |  Yes  |  Yes  | chinhero |
+| Choplifter                       | No(1) |  Yes  |  Yes  |  Yes  | chplft   |
+| Chopper I                        |  Yes  |  Yes  |  Yes  |   No  | chopper  |
+| Chuka Taisen                     |  Yes  |  Yes  |  Yes  |  Yes  | chukatai |
+| Circus                           |  Yes  |  Yes  | Yes(2)|  Yes  | circus   |
+| Circus Charlie                   |  Yes  |  Yes  |  Yes  |  Yes  | circusc  |
+| Cisco Heat                       |  Yes  |  Yes  |  Yes  |  Yes  | cischeat |
+| City Bomber                      |  Yes  |  Yes  |  Yes  |   No  | citybomb |
+| City Connection                  |  Yes  |  Yes  |  Yes  |  Yes  | citycon  |
+| City Love                        |  Yes  |  Yes  |  Yes  |  Yes  | citylove |
+| Clash-Road                       |  Yes  |  Yes  |  Yes  |  Yes  | clshroad |
+| Clay Pigeon                      |  Yes  |  Yes  |  Yes  |  Yes  | claypign |
+| Clay Shoot                       |  Yes  |  Yes  |   No  |  Yes  | clayshoo |
+| Cleopatra Fortune                |  Yes  |  Yes  |  Yes  |  Yes  | cleopatr |
+| Cliffhanger - Edward Randy, The  |  Yes  |  Yes  |  Yes  |  Yes  | edrandy  |
+| Cloak & Dagger                   |  Yes  |  Yes  |  Yes  |   No  | cloak    |
+| Cloud 9                          |  Yes  |  Yes  |  Yes  |   No  | cloud9   |
+| Clowns                           |  Yes  |  Yes  |Part(2)|  Yes  | clowns   |
+| Cobra-Command                    |  Yes  |  Yes  |  Yes  |  Yes  | cobracom |
+| Colony 7                         |  Yes  |  Yes  |  Yes  |  Yes  | colony7  |
+| Columns                          |  Yes  |  Yes  |  Yes  |  Yes  | columns  |
+| Columns II - The Voyage Through T|  Yes  |  Yes  |  Yes  |  Yes  | columns2 |
+| Combat                           |  Yes  |  Yes  |  Yes  |  Yes  | combat   |
+| Combat School                    |  Yes  |  Yes  |  Yes  |  Yes  | combasc  |
+| Combatribes, The                 |  Yes  |  Yes  |  Yes  |   No  | ctribe   |
+| Commando                         |  Yes  |  Yes  |  Yes  |  Yes  | commsega |
+| Commando                         |  Yes  |  Yes  |  Yes  |  Yes  | commando |
+| Comotion                         |  Yes  |  Yes  |Part(2)|  Yes  | comotion |
+| Complex X                        |  Yes  |  Yes  |  Yes  |  Yes  | complexx |
+| Congo Bongo                      |  Yes  |  Yes  | Yes(2)|  Yes  | congo    |
+| Continental Circus               |  Yes  |  Yes  |  Yes  |  Yes  | contcirc |
+| Contra                           |  Yes  |  Yes  |  Yes  |  Yes  | contra   |
+| Cop 01                           |  Yes  |  Yes  |  Yes  |  Yes  | cop01    |
+| Cops'n Robbers                   |  Yes  |  Yes  |   No  |  Yes  | copsnrob |
+| Cosmic Alien                     |  Yes  |  Yes  |   No  |  Yes  | cosmica  |
+| Cosmic Avenger                   |  Yes  |  Yes  |  Yes  |  Yes  | cavenger |
+| Cosmic Chasm                     |  Yes  |  Yes  |  Yes  |  Yes  | cchasm   |
+| Cosmic Cop                       |  Yes  |  Yes  |  Yes  |   No  | cosmccop |
+| Cosmic Guerilla                  |  Yes  |  Yes  | Yes(2)|   No  | cosmicg  |
+| Cosmo Gang the Puzzle            |  Yes  |  Yes  |Partial|  Yes  | cgangpzl |
+| Cosmo Gang the Video             |  Yes  |  Yes  |  Yes  |  Yes  | cosmogng |
+| Cosmos                           |  Yes  |  Yes  |Partial|   No  | cosmos   |
+| Crackshot                        |  Yes  |  Yes  |  Yes  |  Yes  | cracksht |
+| Crash                            |  Yes  |  Yes  |Partial|  Yes  | crash    |
+| Crater Raider                    |  Yes  |  Yes  |  Yes  |  Yes  | crater   |
+| Crayon Shinchan Orato Asobo      |  Yes  |  Yes  |  Yes  |  Yes  | qcrayon2 |
+| Crazy Balloon                    |  Yes  |  Yes  |Partial|  Yes  | crbaloon |
+| Crazy Climber                    |  Yes  |  Yes  |  Yes  |  Yes  | cclimber |
+| Crazy Climber 2                  |  Yes  |  Yes  |  Yes  |  Yes  | cclimbr2 |
+| Crazy Kong                       |  Yes  |  Yes  |  Yes  |  Yes  | ckong    |
+| Crazy Rally                      |  Yes  |  Yes  |  Yes  |  Yes  | crzrally |
+| Crime City                       |  Yes  |  Yes  |  Yes  |  Yes  | crimec   |
+| Crime Fighters                   |  Yes  |  Yes  |  Yes  |  Yes  | crimfght |
+| Crossbow                         |  Yes  |  Yes  |  Yes  |  Yes  | crossbow |
+| Crossed Swords                   |  Yes  |  Yes  |  Yes  |  Yes  | crsword  |
+| Crowns Golf                      |  Yes  |  Yes  |  Yes  |  Yes  | crgolf   |
+| Crude Buster                     |  Yes  |  Yes  |  Yes  |  Yes  | cbuster  |
+| Cruis'n USA                      |  Yes  |  Yes  |  Yes  |  Yes  | crusnusa |
+| Cruis'n World                    |  Yes  |  Yes  |  Yes  |  Yes  | crusnwld |
+| Crush Roller                     |  Yes  |  Yes  |  Yes  |  Yes  | crush    |
+| Crystal Castles                  |  Yes  |  Yes  |  Yes  |  Yes  | ccastles |
+| Crystal Gal                      |   No  |  Yes  |  Yes  |  Yes  | crystalg |
+| Crystal Gal 2                    |   No  |  Yes  |  Yes  |  Yes  | crystal2 |
+| Cuby Bop                         |  Yes  |  Yes  |  Yes  |  Yes  | cubybop  |
+| CueBrick                         |  Yes  |  Yes  |  Yes  |  Yes  | cuebrick |
+| Curve Ball                       |  Yes  |  Yes  |  Yes  |  Yes  | curvebal |
+| Cutie Q                          |  Yes  |  Yes  |  Yes  |  Yes  | cutieq   |
+| Cybattler                        |  Yes  |  Yes  |  Yes  |  Yes  | cybattlr |
+| Cyber-Lip                        |  Yes  |  Yes  |  Yes  |  Yes  | cyberlip |
+| Cyberball                        |  Yes  |  Yes  |  Yes  |  Yes  | cyberbal |
+| Cyberbots: Fullmetal Madness     |  Yes  |  Yes  |  Yes  |  Yes  | cybots   |
+| Cyvern                           |  Yes  |  Yes  |  Yes  |  Yes  | cyvern   |
+| D-Con                            |  Yes  |  Yes  |  Yes  |   No  | dcon     |
+| D-Day                            |  Yes  | Close |  Yes  |  Yes  | dday     |
+| Daioh                            |  Yes  |  Yes  |  Yes  |  Yes  | daioh    |
+| Daisu-Kiss                       |  Yes  |  Yes  |  Yes  |  Yes  | daiskiss |
+| Daitoride                        |  Yes  |  Yes  |   No  |  Yes  | daitorid |
+| Dancing Eyes                     |   No  |  Yes  |   No  |  Yes  | danceyes |
+| Dangar - Ufo Robo                |  Yes  |  Yes  |  Yes  |  Yes  | dangar   |
+| Danger Zone                      |  Yes  |  Yes  |  Yes  |  Yes  | dangerz  |
+| Dangerous Seed                   |  Yes  |  Yes  |  Yes  |  Yes  | dangseed |
+| Dangun Feveron                   |  Yes  |  Yes  |  Yes  |  Yes  | dfeveron |
+| Danny Sullivan's Indy Heat       |  Yes  |  Yes  |  Yes  |  Yes  | indyheat |
+| Daraku Tenshi - The Fallen Angels|  Yes  |  Yes  |  Yes  |  Yes  | daraku   |
+| Darius                           |  Yes  |  Yes  |  Yes  |  Yes  | darius   |
+| Darius Gaiden - Silver Hawk      |  Yes  |  Yes  |  Yes  |  Yes  | dariusg  |
+| Darius II                        |  Yes  |  Yes  |  Yes  |  Yes  | darius2  |
+| Dark Planet                      |  Yes  |  Yes  |  Yes  |  Yes  | darkplnt |
+| Dark Seal                        |  Yes  |  Yes  |  Yes  |  Yes  | darkseal |
+| Dark Tower                       |  Yes  |  Yes  |  Yes  |   No  | darktowr |
+| Dark Warrior                     |  Yes  |  Yes  |Partial|   No  | darkwar  |
+| Darkstalkers: The Night Warriors |  Yes  |  Yes  |  Yes  |  Yes  | dstlk    |
+| Darwin 4078                      |  Yes  |  Yes  |  Yes  |  Yes  | darwin   |
+| Datsun 280 Zzzap                 |  Yes  |  Yes  |   No  |  Yes  | 280zzzap |
+| Dazzler                          |  Yes  |  Yes  |Partial|   No  | dazzler  |
+| Dead Angle                       |  Yes  |  Yes  |Partial|  Yes  | deadang  |
+| Dead Connection                  |  Yes  |  Yes  |  Yes  |  Yes  | deadconx |
+| Dead Eye                         |  Yes  |  Yes  |  Yes  |  Yes  | deadeye  |
+| Deep, The                        |  Yes  |  Yes  |  Yes  |  Yes  | thedeep  |
+| Defend the Terra Attack on the Re|  Yes  |  Yes  |  Yes  |  Yes  | redufo   |
+| Defender                         |  Yes  |  Yes  |  Yes  |  Yes  | defender |
+| Demolition Derby                 |  Yes  |  Yes  |  Yes  |  Yes  | demoderb |
+| Demon                            |  Yes  |  Yes  |  Yes  |  Yes  | demon    |
+| Demon's World / Horror Story     |  Yes  |  Yes  |  Yes  |  Yes  | demonwld |
+| Depthcharge                      |  Yes  |  Yes  | Yes(2)|  Yes  | depthch  |
+| Desert Gun                       |  Yes  |  Yes  |   No  |  Yes  | desertgu |
+| Desert War / Wangan Sensou       |  Yes  |  Yes  |   No  |  Yes  | desertwr |
+| Destroyer                        |  Yes  |  Yes  |   No  |  Yes  | destroyr |
+| Devastators                      |  Yes  |  Yes  |  Yes  |  Yes  | devstors |
+| Devil Fish                       |  Yes  |  Yes  |  Yes  |  Yes  | devilfsh |
+| Devil World                      |  Yes  |  Yes  |  Yes  |  Yes  | devilw   |
+| Devil Zone                       |  Yes  |  Yes  |Partial|  Yes  | devzone  |
+| Dharma Doujou                    |  Yes  |  Yes  |   No  |  Yes  | dharma   |
+| Diamond Run                      |  Yes  |  Yes  |  Yes  |  Yes  | diamond  |
+| Dig Dug                          |  Yes  |  Yes  |  Yes  |  Yes  | digdug   |
+| Dig Dug II                       |  Yes  |  Yes  |  Yes  |  Yes  | digdug2  |
+| Digger                           |  Yes  |  Yes  |   No  |  Yes  | digger   |
+| Dimahoo                          |  Yes  |  Yes  |  Yes  |  Yes  | dimahoo  |
+| Dingo                            |  Yes  |  Yes  |  Yes  |  Yes  | dingo    |
+| Dino Rex                         |  Yes  |  Yes  |  Yes  |  Yes  | dinorex  |
+| Dirt Fox                         |  Yes  |  Yes  |  Yes  |  Yes  | dirtfoxj |
+| Disco Mahjong Otachidai no Okite |  Yes  |  Yes  |  Yes  |  Yes  | otatidai |
+| Disco No.1                       |  Yes  |  Yes  |  Yes  |  Yes  | disco    |
+| Discs of Tron                    |  Yes  |  Yes  |  Yes  |  Yes  | dotron   |
+| Diver Boy                        |  Yes  |  Yes  |Partial|  Yes  | diverboy |
+| Do! Run Run                      |  Yes  |  Yes  |  Yes  |   No  | dorunrun |
+| DoDonPachi                       |  Yes  |  Yes  |  Yes  |  Yes  | ddonpach |
+| Dock Man                         |  Yes  |  Yes  |  Yes  |  Yes  | dockman  |
+| Dog Fight                        |  Yes  | Close |  Yes  |  Yes  | dogfight |
+| Dog Patch                        |  Yes  |  Yes  |   No  |  Yes  | dogpatch |
+| Dogyuun                          |  Yes  |  Yes  |   No  |  Yes  | dogyuun  |
+| Dokaben                          |  Yes  |  Yes  |  Yes  |  Yes  | dokaben  |
+| Domino Man                       |  Yes  |  Yes  |  Yes  |  Yes  | domino   |
+| Dominos                          |  Yes  |  Yes  |  Yes  |  Yes  | dominos  |
+| Dommy                            |  Yes  |  Yes  |  Yes  |  Yes  | dommy    |
+| Don Den Lover Vol. 1             |  Yes  | Close |  Yes  |   No  | ddenlovr |
+| Don Den Mahjong [BET]            |  Yes  |  Yes  |  Yes  |  Yes  | dondenmj |
+| Don Doko Don                     |  Yes  |  Yes  |  Yes  |  Yes  | dondokod |
+| DonPachi                         |  Yes  |  Yes  |  Yes  |  Yes  | donpachi |
+| Donkey Kong                      |  Yes  |  Yes  | Yes(2)|  Yes  | dkong    |
+| Donkey Kong 3                    |  Yes  |  Yes  |  Yes  |  Yes  | dkong3   |
+| Donkey Kong Junior               |  Yes  |  Yes  | Yes(2)|  Yes  | dkongjr  |
+| Dorodon                          |  Yes  |  Yes  |  Yes  |  Yes  | dorodon  |
+| Dottori Kun                      |  Yes  |  Yes  |   No  |  Yes  | dotrikun |
+| Double Axle                      |  Yes  |  Yes  |  Yes  |  Yes  | dblaxle  |
+| Double Dragon                    |  Yes  |  Yes  |  Yes  |  Yes  | ddragon  |
+| Double Dragon                    |  Yes  |  Yes  |  Yes  |  Yes  | doubledr |
+| Double Dragon 3 - The Rosetta Sto|  Yes  |  Yes  |  Yes  |   No  | ddragon3 |
+| Double Dragon II - The Revenge   |  Yes  |  Yes  |  Yes  |  Yes  | ddragon2 |
+| Double Dribble                   |  Yes  |  Yes  |  Yes  |  Yes  | ddribble |
+| DownTown                         |  Yes  |  Yes  |  Yes  |  Yes  | downtown |
+| Dr. Micro                        |  Yes  |  Yes  |  Yes  |  Yes  | drmicro  |
+| Dr. Toppel's Adventure           |  Yes  |  Yes  |  Yes  |  Yes  | drtoppel |
+| Drag Race                        |  Yes  |  Yes  |  Yes  |  Yes  | dragrace |
+| Dragon Blaze                     |  Yes  |  Yes  |  Yes  |  Yes  | dragnblz |
+| Dragon Breed                     |  Yes  |  Yes  |  Yes  |   No  | dbreed   |
+| Dragon Buster                    |  Yes  |  Yes  |  Yes  |  Yes  | drgnbstr |
+| Dragon Gun                       |  Yes  |  Yes  |  Yes  |  Yes  | dragngun |
+| Dragon Master                    |  Yes  |  Yes  |  Yes  |  Yes  | drgnmst  |
+| Dragon Punch                     |  Yes  |  Yes  |  Yes  |  Yes  | drgpunch |
+| Dragon Saber                     |  Yes  |  Yes  |  Yes  |  Yes  | dsaber   |
+| Dragon Spirit                    |  Yes  |  Yes  |  Yes  |  Yes  | dspirit  |
+| Dragon Unit / Castle of Dragon   |  Yes  |  Yes  |  Yes  |  Yes  | drgnunit |
+| Dragonball Z                     |  Yes  |  Yes  |  Yes  |  Yes  | dbz      |
+| Dragonball Z 2 Super Battle      |  Yes  |  Yes  |  Yes  |  Yes  | dbz2     |
+| Dragoon Might                    |  Yes  |  Yes  |  Yes  |  Yes  | dragoonj |
+| Dramatic Adventure Quiz Keith & L|  Yes  |  Yes  |  Yes  |   No  | keithlcy |
+| Dream Shopper                    |  Yes  |  Yes  |  Yes  |  Yes  | dremshpr |
+| Dream Soccer '94                 |  Yes  |  Yes  |  Yes  |  Yes  | dsoccr94 |
+| Dribbling                        |  Yes  |  Yes  |   No  |  Yes  | dribling |
+| Drift Out                        |  Yes  |  Yes  |  Yes  |  Yes  | driftout |
+| Drift Out '94 - The Hard Order   |  Yes  |  Yes  |  Yes  |   No  | drifto94 |
+| Dungeon Magic                    |  Yes  |  Yes  |  Yes  |  Yes  | dungeonm |
+| Dungeons & Dragons: Shadow over M|  Yes  |  Yes  |  Yes  |  Yes  | ddsom    |
+| Dungeons & Dragons: Tower of Doom|  Yes  |  Yes  |  Yes  |  Yes  | ddtod    |
+| Dyger                            |  Yes  |  Yes  |  Yes  |  Yes  | dyger    |
+| Dynamic Ski                      |  Yes  |  Yes  |  Yes  |   No  | dynamski |
+| Dynamite Duke                    |  Yes  |  Yes  |  Yes  |  Yes  | dynduke  |
+| Dynamite Dux                     |  Yes  |  Yes  |  Yes  |  Yes  | dduxbl   |
+| Dynamite League                  |  Yes  |  Yes  |  Yes  |  Yes  | dleague  |
+| Dynasty Wars                     |  Yes  |  Yes  |  Yes  |  Yes  | dw       |
+| E-Swat - Cyber Police            | No(1) |  Yes  |  Yes  |  Yes  | eswat    |
+| E.D.F. : Earth Defense Force     |  Yes  |  Yes  |  Yes  |  Yes  | edf      |
+| ESP Ra.De.                       |  Yes  |  Yes  |  Yes  |  Yes  | esprade  |
+| Eco Fighters                     |  Yes  |  Yes  |  Yes  |  Yes  | ecofghtr |
+| Egg Venture                      |  Yes  |  Yes  |  Yes  |  Yes  | eggventr |
+| Eggor                            |  Yes  |   No  |Partial|  Yes  | eggor    |
+| Eight Forces                     |  Yes  |  Yes  |  Yes  |  Yes  | eightfrc |
+| Eight Man                        |  Yes  |  Yes  |  Yes  |  Yes  | eightman |
+| Electric Yo-Yo, The              |  Yes  |  Yes  |  Yes  |  Yes  | elecyoyo |
+| Elevator Action                  |  Yes  |  Yes  |  Yes  |  Yes  | elevator |
+| Elevator Action Returns          |  Yes  |  Yes  |  Yes  |  Yes  | elvactr  |
+| Eliminator                       |  Yes  |  Yes  | Yes(2)|  Yes  | elim2    |
+| Emeraldia                        |  Yes  |  Yes  |Partial|  Yes  | emeralda |
+| Empire City: 1931                |  Yes  |  Yes  |  Yes  |  Yes  | empcity  |
+| Empire Strikes Back, The         |  Yes  |  Yes  |  Yes  |  Yes  | esb      |
+| End, The                         |  Yes  |  Yes  |  Yes  |  Yes  | theend   |
+| Enduro Racer                     | No(1) |  Yes  |  Yes  |  Yes  | enduror  |
+| Enforce                          |  Yes  |  Yes  |  Yes  |  Yes  | enforce  |
+| Enigma 2                         |  Yes  |   No  |   No  |  Yes  | enigma2  |
+| Equites                          |   No  |  Yes  |  Yes  |   No  | equites  |
+| Escape Kids                      |  Yes  |  Yes  |  Yes  |  Yes  | esckids  |
+| Escape from the Planet of the Rob|  Yes  |  Yes  |  Yes  |  Yes  | eprom    |
+| Espial                           |  Yes  |  Yes  |  Yes  |  Yes  | espial   |
+| Evil Stone                       |  Yes  |  Yes  |  Yes  |  Yes  | evilston |
+| Exciting Soccer                  |  Yes  |  Yes  |  Yes  |  Yes  | exctsccr |
+| Exed Exes                        |  Yes  |  Yes  |  Yes  |  Yes  | exedexes |
+| Exerion                          |  Yes  |  Yes  |  Yes  |  Yes  | exerion  |
+| Express Raider                   |  Yes  |  Yes  |  Yes  |  Yes  | exprraid |
+| Extermination                    |  Yes  |  Yes  |  Yes  |  Yes  | extrmatn |
+| Exterminator                     |  Yes  |  Yes  |  Yes  |  Yes  | exterm   |
+| Extra Bases                      |  Yes  |  Yes  |  Yes  |  Yes  | ebases   |
+| Extra Inning                     |  Yes  |  Yes  |   No  |  Yes  | einnings |
+| Extreme Downhill                 |  Yes  |  Yes  |  Yes  |  Yes  | extdwnhl |
+| Exvania                          |  Yes  |  Yes  |Partial|  Yes  | exvania  |
+| Exzisus                          |  Yes  |  Yes  |  Yes  |  Yes  | exzisus  |
+| Eyes                             |  Yes  |  Yes  |  Yes  |  Yes  | eyes     |
+| F-1 Dream                        |  Yes  |  Yes  |  Yes  |  Yes  | f1dream  |
+| F-1 Grand Prix                   |  Yes  |  Yes  |  Yes  |   No  | f1gp     |
+| F-1 Grand Prix Part II           |  Yes  |  Yes  |  Yes  |   No  | f1gp2    |
+| F1 Exhaust Note                  |  Yes  |  Yes  |  Yes  |  Yes  | f1en     |
+| Face Off                         |  Yes  |  Yes  |  Yes  |  Yes  | faceoff  |
+| FairyLand Story, The             |  Yes  |  Yes  |Partial|  Yes  | flstory  |
+| Fancy World - Earth of Crisis    |  Yes  |  Yes  |  Yes  |  Yes  | fncywld  |
+| Fantasia                         |  Yes  |  Yes  |  Yes  |   No  | fantasia |
+| Fantasia II                      |  Yes  |  Yes  |  Yes  |   No  | fantsia2 |
+| Fantasy                          |  Yes  |  Yes  |Part(2)|  Yes  | fantasy  |
+| Fantasy '95                      |  Yes  |  Yes  |  Yes  |   No  | fantsy95 |
+| Fantasy Land                     |  Yes  |  Yes  |  Yes  |  Yes  | fantland |
+| Fantasy Zone                     |  Yes  |  Yes  |  Yes  |  Yes  | fantzone |
+| Far East of Eden - Kabuki Klash /|  Yes  |  Yes  |  Yes  |  Yes  | kabukikl |
+| Fast Lane                        |  Yes  | Close |  Yes  |  Yes  | fastlane |
+| Faster, Harder, More Challenging |  Yes  |  Yes  | Yes(2)|  Yes  | sqbert   |
+| Fatal Fury - King of Fighters / G|  Yes  |  Yes  |  Yes  |  Yes  | fatfury1 |
+| Fatal Fury 2 / Garou Densetsu 2 -|  Yes  |  Yes  |  Yes  |  Yes  | fatfury2 |
+| Fatal Fury 3 - Road to the Final |  Yes  |  Yes  |  Yes  |  Yes  | fatfury3 |
+| Fatal Fury Special / Garou Denset|  Yes  |  Yes  |  Yes  |  Yes  | fatfursp |
+| Fax                              |  Yes  |  Yes  |  Yes  |  Yes  | fax      |
+| Field Day                        |  Yes  |  Yes  |  Yes  |  Yes  | fieldday |
+| Fight Fever / Crystal Legacy     |  Yes  |  Yes  |  Yes  |  Yes  | fightfev |
+| Fighter & Attacker               |  Yes  |  Yes  |Partial|  Yes  | fghtatck |
+| Fighting Golf                    |  Yes  |  Yes  |  Yes  |   No  | fitegolf |
+| Fighting Hawk                    |  Yes  |  Yes  |  Yes  |  Yes  | fhawk    |
+| Fighting Roller                  |  Yes  | Close |Partial|  Yes  | fightrol |
+| Fighting Soccer                  |  Yes  |  Yes  |  Yes  |   No  | ftsoccer |
+| Final Blow                       |  Yes  |  Yes  |  Yes  |  Yes  | finalb   |
+| Final Fight                      |  Yes  |  Yes  |  Yes  |  Yes  | ffight   |
+| Final Lap                        |  Yes  |  Yes  |  Yes  |  Yes  | finallap |
+| Final Lap 2                      |   No  |  Yes  |  Yes  |  Yes  | finalap2 |
+| Final Lap 3                      |   No  |  Yes  |  Yes  |  Yes  | finalap3 |
+| Final Round, The                 |  Yes  |  Yes  |  Yes  |  Yes  | fround   |
+| Final Star Force                 |  Yes  |  Yes  |  Yes  |   No  | fstarfrc |
+| Finalizer - Super Transformation |  Yes  |  Yes  |Partial|   No  | finalizr |
+| Find Out                         |  Yes  |   No  |Partial|  Yes  | findout  |
+| Finest Hour                      |  Yes  |  Yes  |  Yes  |  Yes  | finehour |
+| Fire Barrel                      |  Yes  |  Yes  |   No  |  Yes  | firebarr |
+| Fire Battle                      |  Yes  |  Yes  |  Yes  |  Yes  | firebatl |
+| Fire One                         |  Yes  |  Yes  |   No  |  Yes  | fireone  |
+| Fire Shark                       |  Yes  |  Yes  |   No  |  Yes  | fireshrk |
+| Fire Trap                        |  Yes  |  Yes  |  Yes  |  Yes  | firetrap |
+| Fire Truck                       |  Yes  |  Yes  |  Yes  |  Yes  | firetrk  |
+| Fit of Fighting                  |  Yes  |  Yes  |   No  |  Yes  | fitfight |
+| Flash Point                      | No(1) |  Yes  |  Yes  |  Yes  | fpoint   |
+| Flashgal                         |  Yes  |  Yes  |  Yes  |  Yes  | flashgal |
+| Flicky                           |  Yes  |  Yes  |  Yes  |  Yes  | flicky   |
+| Flower                           |  Yes  |   No  |Partial|   No  | flower   |
+| Fly-Boy                          | No(1) |  Yes  |  Yes  |  Yes  | flyboy   |
+| Flyball                          |  Yes  |  Yes  |   No  |  Yes  | flyball  |
+| Flying Shark                     |  Yes  |  Yes  |  Yes  |  Yes  | fshark   |
+| Food Fight                       |  Yes  |  Yes  |  Yes  |  Yes  | foodf    |
+| Football Champ                   |  Yes  |  Yes  |  Yes  |  Yes  | footchmp |
+| Football Frenzy                  |  Yes  |  Yes  |  Yes  |  Yes  | fbfrenzy |
+| Forgotten Worlds                 |  Yes  |  Yes  |  Yes  |  Yes  | forgottn |
+| Formation Z                      |  Yes  |  Yes  |  Yes  |  Yes  | formatz  |
+| Forty-Love                       |  Yes  |  Yes  |  Yes  |  Yes  | 40love   |
+| Four Trax                        |  Yes  |  Yes  |  Yes  |  Yes  | fourtrax |
+| Free Kick                        | No(1) |  Yes  |  Yes  |  Yes  | freekick |
+| Freeze                           |  Yes  |  Yes  |  Yes  |  Yes  | freeze   |
+| Frenzy                           |  Yes  |  Yes  | Yes(2)|  Yes  | frenzy   |
+| Frisky Tom                       |  Yes  |  Yes  |  Yes  |   No  | friskyt  |
+| Frogger                          |  Yes  |  Yes  |  Yes  |  Yes  | frogger  |
+| Frogs                            |  Yes  |  Yes  |   No  |  Yes  | frogs    |
+| Front Line                       |  Yes  |  Yes  |  Yes  |  Yes  | frontlin |
+| Funky Bee                        |  Yes  |  Yes  |  Yes  |  Yes  | funkybee |
+| Funky Fish                       |  Yes  |  Yes  |  Yes  |  Yes  | fnkyfish |
+| Funky Jet                        |  Yes  |  Yes  |  Yes  |  Yes  | funkyjet |
+| Funny Mouse                      |  Yes  |  Yes  |  Yes  |  Yes  | funnymou |
+| Future Spy                       |  Yes  |  Yes  | Yes(2)|  Yes  | futspy   |
+| GI Joe                           |  Yes  |  Yes  |  Yes  |  Yes  | gijoe    |
+| Gaia Crusaders                   |  Yes  |  Yes  |Partial|  Yes  | gaia     |
+| Gaiapolis                        |  Yes  |  Yes  |  Yes  |  Yes  | gaiapols |
+| Galactic Warriors                |  Yes  |  Yes  |  Yes  |  Yes  | gwarrior |
+| Galaga                           |  Yes  |  Yes  | Yes(2)|  Yes  | galaga   |
+| Galaga '88                       |  Yes  |  Yes  |  Yes  |  Yes  | galaga88 |
+| Galaxian                         |  Yes  |  Yes  |  Yes  |  Yes  | galaxian |
+| Galaxy Fight - Universal Warriors|  Yes  |  Yes  |  Yes  |  Yes  | galaxyfg |
+| Galaxy Gunners                   |  Yes  |  Yes  |  Yes  |  Yes  | galaxygn |
+| Galaxy Wars                      |  Yes  |  Yes  | Yes(2)|  Yes  | galxwars |
+| Galivan - Cosmo Police           |  Yes  |  Yes  |  Yes  |  Yes  | galivan  |
+| Galmedes                         |  Yes  |  Yes  |  Yes  |  Yes  | galmedes |
+| Gals Panic                       |  Yes  |  Yes  |  Yes  |   No  | galpanic |
+| Gals Panic 4                     |  Yes  |  Yes  |  Yes  |  Yes  | galpani4 |
+| Gals Panic S - Extra Edition     |  Yes  |  Yes  |  Yes  |  Yes  | galpanis |
+| Gals Panic S2                    |  Yes  |  Yes  |  Yes  |  Yes  | galpans2 |
+| Gals Pinball                     |  Yes  |  Yes  |  Yes  |   No  | galspnbl |
+| Game Paradise - Master of Shootin|  Yes  |  Yes  |   No  |  Yes  | gametngk |
+| Games V18.7C                     |  Yes  |  Yes  |  Yes  |  Yes  | usg185   |
+| Games V25.4X                     |  Yes  |  Yes  |  Yes  |  Yes  | usg252   |
+| Ganbare Ginkun                   |  Yes  |  Yes  |  Yes  |   No  | ginkun   |
+| Gang Busters                     |  Yes  |  Yes  |  Yes  |  Yes  | gbusters |
+| Gang Wars                        |  Yes  |  Yes  |  Yes  |  Yes  | gangwars |
+| Gaplus                           |  Yes  |  Yes  | Yes(2)|  Yes  | gaplus   |
+| Garou - Mark of the Wolves       |  Yes  |  Yes  |  Yes  |  Yes  | garou    |
+| Garyo Retsuden                   |  Yes  |  Yes  |  Yes  |  Yes  | garyoret |
+| Gauntlet                         |  Yes  |  Yes  |  Yes  |  Yes  | gauntlet |
+| Gauntlet II                      |  Yes  |  Yes  |  Yes  |  Yes  | gaunt2   |
+| Gee Bee                          |  Yes  |  Yes  |  Yes  |  Yes  | geebee   |
+| Gekirindan                       |  Yes  |  Yes  |  Yes  |  Yes  | gekirido |
+| Gemini Wing                      |  Yes  |  Yes  |  Yes  |  Yes  | gemini   |
+| Genix Family                     |  Yes  |  Yes  |  Yes  |  Yes  | genix    |
+| Genpei ToumaDen                  |  Yes  |  Yes  |  Yes  |  Yes  | genpeitd |
+| Ghost Pilots                     |  Yes  |  Yes  |  Yes  |  Yes  | gpilots  |
+| Ghostmuncher Galaxian            |  Yes  |  Yes  |  Yes  |  Yes  | gmgalax  |
+| Ghosts'n Goblins                 |  Yes  |  Yes  |  Yes  |  Yes  | gng      |
+| Ghouls'n Ghosts                  |  Yes  |  Yes  |  Yes  |  Yes  | ghouls   |
+| Ghox                             |  Yes  |  Yes  |   No  |  Yes  | ghox     |
+| Giga Wing                        |  Yes  |  Yes  |  Yes  |  Yes  | gigawing |
+| Gigandes                         |  Yes  |  Yes  |  Yes  |  Yes  | gigandes |
+| Gigas                            |  Yes  |  Yes  |  Yes  |   No  | gigasb   |
+| Gigas Mark II                    |  Yes  |  Yes  |  Yes  |   No  | gigasm2b |
+| Gimme A Break                    |  Yes  |  Yes  |  Yes  |  Yes  | gimeabrk |
+| Ginga NinkyouDen                 |  Yes  |  Yes  |  Yes  |  Yes  | ginganin |
+| Gionbana                         |  Yes  |  Yes  |  Yes  |  Yes  | gionbana |
+| Gladiator                        |  Yes  |  Yes  |  Yes  |   No  | gladiatr |
+| Gladiator 1984                   |  Yes  |  Yes  |  Yes  |   No  | sgladiat |
+| Glass                            |   No  |  Yes  |  Yes  |  Yes  | glass    |
+| Go Go Mr. Yamaguchi / Yuke Yuke Y|  Yes  | Close |  Yes  |  Yes  | yamagchi |
+| Go Go! Mile Smile                |  Yes  |  Yes  |Partial|  Yes  | gogomile |
+| Goal! Goal! Goal!                |  Yes  |  Yes  |  Yes  |  Yes  | goalx3   |
+| Goalie Ghost                     |  Yes  |  Yes  |  Yes  |  Yes  | gghost   |
+| Goindol                          | No(1) |  Yes  |  Yes  |  Yes  | goindol  |
+| Gokujyou Parodius                |  Yes  |  Yes  |  Yes  |  Yes  | gokuparo |
+| Gold Bug                         |  Yes  |  Yes  |Partial|   No  | goldbug  |
+| Gold Medalist                    |  Yes  |  Yes  |  Yes  |  Yes  | goldmedl |
+| Golden Axe                       |  Yes  |  Yes  |  Yes  |  Yes  | goldnaxe |
+| Golden Axe - The Revenge of Death|  Yes  |  Yes  |  Yes  |  Yes  | ga2      |
+| Golden Fire II                   |  Yes  |  Yes  |  Yes  |  Yes  | gfire2   |
+| Golden Tee Golf                  |  Yes  |  Yes  |  Yes  |  Yes  | gtg      |
+| Golden Tee Golf II               |  Yes  |  Yes  |  Yes  |  Yes  | gtg2     |
+| Golfing Greats                   |   No  |  Yes  |Partial|  Yes  | glfgreat |
+| Golly! Ghost!                    |  Yes  |  Yes  |  Yes  |  Yes  | gollygho |
+| Gomoku Narabe Renju              |  Yes  |  Yes  |Partial|  Yes  | gomoku   |
+| Gondomania                       |  Yes  |  Yes  |  Yes  |  Yes  | gondo    |
+| Gorf                             |  Yes  |  Yes  | Yes(2)|  Yes  | gorf     |
+| Got-cha                          |  Yes  |  Yes  |  Yes  |  Yes  | gotcha   |
+| Gourmet Battle Quiz Ryohrioh CooK|  Yes  |  Yes  |  Yes  |   No  | ryorioh  |
+| Gradius III                      |  Yes  |  Yes  |  Yes  |  Yes  | gradius3 |
+| Grand Champion                   |  Yes  |  Yes  |Partial|  Yes  | grchamp  |
+| Grand Cross                      |  Yes  |  Yes  |   No  |   No  | gcpinbal |
+| Grand Prix Star                  |  Yes  |  Yes  |  Yes  |  Yes  | f1gpstar |
+| Grand Striker                    |  Yes  |  Yes  |  Yes  |  Yes  | gstriker |
+| Grand Tour                       |  Yes  |  Yes  |  Yes  |  Yes  | grndtour |
+| Gratia - Second Earth            |  Yes  |  Yes  |   No  |  Yes  | gratia   |
+| Gravitar                         |  Yes  |  Yes  |  Yes  |  Yes  | gravitar |
+| Great 1000 Miles Rally           |  Yes  |  Yes  |  Yes  |  Yes  | gtmr     |
+| Great Guns                       |  Yes  |  Yes  |  Yes  |  Yes  | greatgun |
+| Great Sluggers '94               |  Yes  |  Yes  |   No  |  Yes  | gslgr94u |
+| Great Swordsman                  |  Yes  | Close |  Yes  |  Yes  | gsword   |
+| Green Beret                      |  Yes  |  Yes  |  Yes  |  Yes  | gberet   |
+| Green Beret                      |   No  | Close |   No  |   No  | greenber |
+| Grid Seeker: Project Stormhammer |  Yes  |  Yes  |  Yes  |  Yes  | gseeker  |
+| Gridiron Fight                   |  Yes  |  Yes  |  Yes  |  Yes  | gridiron |
+| Gridlee                          |  Yes  |  Yes  |Part(2)|  Yes  | gridlee  |
+| Grobda                           |  Yes  |  Yes  |  Yes  |  Yes  | grobda   |
+| Ground Effects / Super Ground Eff|  Yes  |  Yes  |  Yes  |  Yes  | groundfx |
+| Growl                            |  Yes  |  Yes  |  Yes  |  Yes  | growl    |
+| Grudge Match                     |  Yes  |  Yes  |  Yes  |  Yes  | grudge   |
+| Guardian                         | No(1) |  Yes  |  Yes  |   No  | getstar  |
+| Guardians / Denjin Makai II      |  Yes  |  Yes  |  Yes  |   No  | grdians  |
+| Guerrilla War                    |  Yes  |  Yes  |  Yes  |   No  | gwar     |
+| Guided Missile                   |  Yes  |  Yes  |   No  |  Yes  | gmissile |
+| Gulf Storm                       |  Yes  |  Yes  |  Yes  |  Yes  | gulfstrm |
+| Gulf War II                      |  Yes  |  Yes  |  Yes  |  Yes  | gulfwar2 |
+| Gumbo                            |  Yes  |  Yes  |  Yes  |  Yes  | gumbo    |
+| Gun & Frontier                   |  Yes  |  Yes  |  Yes  |  Yes  | gunfront |
+| Gun Dealer                       |  Yes  |  Yes  |  Yes  |  Yes  | gundealr |
+| Gun Dealer '94                   |  Yes  |  Yes  |  Yes  |  Yes  | gundl94  |
+| Gun Fight                        |  Yes  |  Yes  |   No  |  Yes  | gunfight |
+| Gun.Smoke                        |  Yes  |  Yes  |  Yes  |  Yes  | gunsmoke |
+| GunNail                          |  Yes  |  Yes  |   No  |  Yes  | gunnail  |
+| Gunbird                          |  Yes  |  Yes  |  Yes  |  Yes  | gunbird  |
+| Gunbird 2                        |  Yes  |  Yes  |  Yes  |  Yes  | gunbird2 |
+| Gunbuster                        |  Yes  |  Yes  |  Yes  |  Yes  | gunbustr |
+| Gundhara                         |  Yes  |  Yes  |  Yes  |  Yes  | gundhara |
+| Gunforce - Battle Fire Engulfed T|  Yes  |  Yes  |  Yes  |  Yes  | gunforce |
+| Gunforce 2                       |  Yes  |  Yes  |  Yes  |  Yes  | gunforc2 |
+| Gunlock                          |  Yes  |  Yes  |  Yes  |  Yes  | gunlock  |
+| Gururin                          |  Yes  |  Yes  |  Yes  |  Yes  | gururin  |
+| Guts'n                           |  Yes  |  Yes  |  Yes  |  Yes  | gutsn    |
+| Guwange                          |  Yes  |  Yes  |  Yes  |  Yes  | guwange  |
+| Guzzler                          |  Yes  |  Yes  |  Yes  |  Yes  | guzzler  |
+| Gyakuten!! Puzzle Bancho         |  Yes  |  Yes  |  Yes  |  Yes  | pbancho  |
+| Gypsy Juggler                    |  Yes  |  Yes  |  Yes  |  Yes  | gypsyjug |
+| Gyrodine                         |  Yes  |  Yes  |  Yes  |  Yes  | gyrodine |
+| Gyruss                           |  Yes  |  Yes  |  Yes  |  Yes  | gyruss   |
+| HAL21                            |  Yes  | Close |  Yes  |   No  | hal21    |
+| Hachoo!                          |  Yes  |  Yes  |Partial|  Yes  | hachoo   |
+| Halley's Comet                   |  Yes  |  Yes  |  Yes  |   No  | halleys  |
+| Hammerin' Harry                  |  Yes  |  Yes  |  Yes  |   No  | hharry   |
+| Hana Awase                       |  Yes  |  Yes  |  Yes  |  Yes  | hanaawas |
+| Hana Yayoi                       |  Yes  |  Yes  |  Yes  |  Yes  | hnayayoi |
+| Hana no Mai                      |  Yes  |  Yes  |  Yes  |  Yes  | hanamai  |
+| Hana to Ojisan [BET]             |  Yes  |  Yes  |  Yes  |  Yes  | hanaoji  |
+| Hanagumi Taisen Columns - Sakura |  Yes  |  Yes  |   No  |  Yes  | hanagumi |
+| Hanaroku                         |  Yes  | Close |  Yes  |   No  | hanaroku |
+| Hand, The                        |  Yes  |  Yes  | Yes(2)|  Yes  | thehand  |
+| Hang-On                          |  Yes  |  Yes  |  Yes  |  Yes  | hangon   |
+| Hang-On Jr.                      |  Yes  |  Yes  |  Yes  |  Yes  | hangonjr |
+| Hard Drivin'                     |  Yes  |  Yes  |  Yes  |  Yes  | harddriv |
+| Hard Drivin's Airborne           |  Yes  |  Yes  |   No  |  Yes  | hdrivair |
+| Hard Dunk                        |  Yes  |  Yes  |  Yes  |  Yes  | harddunk |
+| Hard Hat                         |  Yes  |  Yes  |  Yes  |  Yes  | hardhat  |
+| Hard Head                        |  Yes  |  Yes  |Partial|  Yes  | hardhead |
+| Hard Yardage                     |  Yes  |  Yes  |  Yes  |  Yes  | hardyard |
+| Hasamu                           |  Yes  |  Yes  |  Yes  |   No  | hasamu   |
+| Hat Trick                        |  Yes  |  Yes  |  Yes  |  Yes  | hattrick |
+| Hatris                           |  Yes  |  Yes  |  Yes  |  Yes  | hatris   |
+| Haunted Castle                   |  Yes  |  Yes  |  Yes  |  Yes  | hcastle  |
+| Hayaoshi Quiz Ouza Ketteisen     |  Yes  |  Yes  |   No  |  Yes  | hayaosi1 |
+| Head On                          |  Yes  |  Yes  |   No  |  Yes  | headon   |
+| Head On 2                        |  Yes  |  Yes  |   No  |  Yes  | headon2  |
+| Head Panic                       |  Yes  |  Yes  |  Yes  |  Yes  | hedpanic |
+| Heart Attack                     |  Yes  |  Yes  |Partial|   No  | heartatk |
+| Heavy Barrel                     |  Yes  |  Yes  |  Yes  |  Yes  | hbarrel  |
+| Heavy Metal                      |  Yes  |  Yes  |  Yes  |  Yes  | hvymetal |
+| Heavyweight Champ                |  Yes  |  Yes  |  Yes  |  Yes  | hwchamp  |
+| Hebereke no Popoon               |  Yes  |  Yes  |  Yes  |  Yes  | heberpop |
+| Heiankyo Alien                   |  Yes  |  Yes  |   No  |  Yes  | heiankyo |
+| HeliFire                         |  Yes  |  Yes  |   No  |  Yes  | helifire |
+| Hellfire                         |  Yes  |  Yes  |  Yes  |  Yes  | hellfire |
+| Hero                             |  Yes  |  Yes  |Partial|   No  | hero     |
+| Hexa                             |  Yes  |  Yes  |  Yes  |  Yes  | hexa     |
+| Hexion                           |  Yes  |  Yes  |  Yes  |  Yes  | hexion   |
+| High Impact Football             |  Yes  |  Yes  |  Yes  |  Yes  | hiimpact |
+| High Voltage                     |   No  |  Yes  |  Yes  |  Yes  | hvoltage |
+| High Way Race                    |  Yes  |  Yes  |  Yes  |  Yes  | hwrace   |
+| Hippodrome                       |  Yes  |  Yes  |  Yes  |  Yes  | hippodrm |
+| History of Martial Arts, The     |  Yes  |  Yes  |   No  |  Yes  | histryma |
+| Hit 'n Miss                      |  Yes  |  Yes  |  Yes  |  Yes  | hitnmiss |
+| Hit Me                           |  Yes  |  Yes  |   No  |  Yes  | hitme    |
+| Hit the Ice                      |  Yes  |  Yes  |  Yes  |  Yes  | hitice   |
+| Hoccer                           |  Yes  |  Yes  |  Yes  |  Yes  | hoccer   |
+| Hole Land                        |  Yes  |  Yes  |  Yes  |  Yes  | holeland |
+| Holosseum                        |  Yes  |  Yes  |  Yes  |  Yes  | holo     |
+| Hook                             |  Yes  |  Yes  |  Yes  |  Yes  | hook     |
+| Hopper Robo                      |  Yes  |  Yes  |  Yes  |  Yes  | hopprobo |
+| Hopping Mappy                    |  Yes  |  Yes  |  Yes  |  Yes  | hopmappy |
+| Horizon                          |  Yes  |  Yes  |Partial|  Yes  | horizon  |
+| Hot Chase                        |  Yes  |  Yes  |  Yes  |  Yes  | hotchase |
+| Hot Pinball                      |  Yes  |  Yes  |  Yes  |   No  | hotpinbl |
+| Hot Shocker                      |  Yes  |  Yes  |  Yes  |  Yes  | hotshock |
+| Hot Shots Tennis                 |  Yes  |  Yes  |  Yes  |  Yes  | hstennis |
+| Hotdog Storm                     |  Yes  |  Yes  |  Yes  |  Yes  | hotdogst |
+| House Mannequin                  |  Yes  |  Yes  |  Yes  |  Yes  | housemnq |
+| House Mannequin Roppongi Live hen|  Yes  |  Yes  |  Yes  |  Yes  | housemn2 |
+| Hunchback                        |  Yes  |  Yes  |Partial|   No  | hunchbak |
+| Hunchback Olympic                |  Yes  |  Yes  |Partial|   No  | huncholy |
+| Hustle                           |  Yes  |  Yes  |Part(2)|  Yes  | hustle   |
+| Hustler, The                     |  Yes  |  Yes  |  Yes  |   No  | thehustl |
+| Hydra                            |  Yes  |  Yes  |  Yes  |  Yes  | hydra    |
+| Hyper Duel                       | No(1) |  Yes  |  Yes  |  Yes  | hyprduel |
+| Hyper Pacman                     |  Yes  |  Yes  |  Yes  |  Yes  | hyperpac |
+| Hyper Sports                     |  Yes  |  Yes  |  Yes  |  Yes  | hyperspt |
+| I'm Sorry                        |  Yes  |  Yes  |  Yes  |  Yes  | imsorry  |
+| I, Robot                         |  Yes  |  Yes  |  Yes  |  Yes  | irobot   |
+| IGMO                             |  Yes  |   No  |  Yes  |  Yes  | igmo     |
+| IPM Invader                      |  Yes  | Close |   No  |   No  | ipminvad |
+| IQ-Block                         |  Yes  |  Yes  |  Yes  |  Yes  | iqblock  |
+| Ichidant-R                       |  Yes  |  Yes  |  Yes  |  Yes  | ichidant |
+| Idol Janshi Su-Chi-Pie 2         |  Yes  |  Yes  |   No  |  Yes  | 47pie2   |
+| Idol no Himitsu [BET]            |  Yes  |  Yes  |  Yes  |  Yes  | idhimitu |
+| Idol-Mahjong Final Romance       |  Yes  |  Yes  |  Yes  |  Yes  | fromance |
+| Idol-Mahjong Housoukyoku         |  Yes  |  Yes  |  Yes  |  Yes  | idolmj   |
+| Iemoto                           |  Yes  |  Yes  |  Yes  |  Yes  | iemoto   |
+| Iga Ninjyutsuden                 |  Yes  |  Yes  |  Yes  |  Yes  | iganinju |
+| Ikari III - The Rescue           |  Yes  |  Yes  |  Yes  |  Yes  | ikari3   |
+| Ikari Warriors                   |  Yes  |  Yes  |  Yes  |   No  | ikari    |
+| Ikki                             |  Yes  |  Yes  |  Yes  |  Yes  | ikki     |
+| Image Fight                      |  Yes  |  Yes  |  Yes  |   No  | imgfight |
+| Imago                            |  Yes  |   No  |  Yes  |  Yes  | imago    |
+| Imekura Mahjong                  |  Yes  |  Yes  |  Yes  |  Yes  | imekura  |
+| In The Hunt                      |  Yes  |  Yes  |  Yes  |  Yes  | inthunt  |
+| Indiana Jones and the Temple of D|  Yes  |  Yes  |  Yes  |  Yes  | indytemp |
+| Indoor Soccer                    |  Yes  |  Yes  |Partial|  Yes  | idsoccer |
+| Inferno                          |  Yes  |  Yes  |Partial|  Yes  | inferno  |
+| Inferno                          |  Yes  |  Yes  |   No  |  Yes  | minferno |
+| Insector                         |  Yes  |  Yes  |   No  |  Yes  | insector |
+| Insector X                       |  Yes  |  Yes  |  Yes  |  Yes  | insectx  |
+| Intrepid                         |  Yes  |  Yes  |  Yes  |  Yes  | intrepid |
+| Invader's Revenge                |  Yes  |  Yes  |   No  |  Yes  | invrvnge |
+| Invinco                          |  Yes  |  Yes  | Yes(2)|  Yes  | invinco  |
+| Invinco / Deep Scan              |  Yes  |  Yes  |Part(2)|  Yes  | invds    |
+| Invinco / Head On 2              |  Yes  |  Yes  |Part(2)|  Yes  | invho2   |
+| Iron Horse                       |  Yes  |  Yes  |  Yes  |  Yes  | ironhors |
+| Ironman Stewart's Super Off-Road |  Yes  |  Yes  |  Yes  |  Yes  | offroad  |
+| Ironman Stewart's Super Off-Road |  Yes  |  Yes  |  Yes  |  Yes  | offroadt |
+| Irritating Maze / Ultra Denryu Ir|  Yes  |  Yes  |  Yes  |  Yes  | irrmaze  |
+| Ixion                            |  Yes  |  Yes  |   No  |  Yes  | ixion    |
+| J-League Soccer V-Shoot          |  Yes  |  Yes  |   No  |  Yes  | vshoot   |
+| J. J. Squawkers                  |  Yes  |  Yes  |  Yes  |  Yes  | jjsquawk |
+| Jack Rabbit                      |  Yes  |  Yes  |Partial|  Yes  | jackrabt |
+| Jack the Giantkiller             |  Yes  |  Yes  |  Yes  |  Yes  | jack     |
+| Jackal                           |  Yes  | Close |  Yes  |   No  | jackal   |
+| Jail Break                       |  Yes  |  Yes  |  Yes  |  Yes  | jailbrek |
+| Jan Jan Paradise                 |  Yes  |  Yes  |  Yes  |  Yes  | jjparads |
+| Jan Jan Paradise 2               |  Yes  |  Yes  |  Yes  |  Yes  | jjparad2 |
+| Jitsuryoku!! Pro Yakyuu          |  Yes  |  Yes  |  Yes  |  Yes  | jitsupro |
+| John Elway's Team Quarterback    |  Yes  |  Yes  |  Yes  |  Yes  | teamqb   |
+| Journey                          |  Yes  |  Yes  |Partial|  Yes  | journey  |
+| Joust                            |  Yes  |  Yes  |  Yes  |  Yes  | joust    |
+| Joust 2 - Survival of the Fittest|  Yes  |  Yes  |  Yes  |  Yes  | joust2   |
+| Joyful Road                      |  Yes  |  Yes  |Partial|   No  | joyfulr  |
+| Jr. Pac-Man                      |  Yes  |  Yes  |  Yes  |  Yes  | jrpacman |
+| Judge Dredd                      |  Yes  |  Yes  |  Yes  |  Yes  | jdredd   |
+| Jump Bug                         |  Yes  |  Yes  |  Yes  |  Yes  | jumpbug  |
+| Jump Coaster                     |  Yes  |  Yes  |  Yes  |  Yes  | jumpcoas |
+| Jump Kids                        |  Yes  |  Yes  |   No  |  Yes  | jumpkids |
+| Jump Shot                        |  Yes  |  Yes  |  Yes  |  Yes  | jumpshot |
+| Jumping Jack                     |  Yes  |  Yes  |  Yes  |  Yes  | jjack    |
+| Jungle King                      |  Yes  |  Yes  |  Yes  |  Yes  | junglek  |
+| Jungler                          |  Yes  |  Yes  |  Yes  |  Yes  | jungler  |
+| Juno First                       |  Yes  |  Yes  |  Yes  |  Yes  | junofrst |
+| Jurassic Park                    |  Yes  |  Yes  |  Yes  |  Yes  | jpark    |
+| Jyanshin Densetsu - Quest of Jong|  Yes  |  Yes  |  Yes  |  Yes  | janshin  |
+| Kageki                           |  Yes  |  Yes  |  Yes  |  Yes  | kageki   |
+| Kaiser Knuckle                   |  Yes  |  Yes  |  Yes  |  Yes  | kaiserkn |
+| Kaitei Takara Sagashi            |  Yes  |  Yes  |  Yes  |  Yes  | kaitei   |
+| Kamikaze Cabbie                  |  Yes  |  Yes  |  Yes  |  Yes  | kamikcab |
+| Kanatsuen no Onna [BET]          |  Yes  |  Yes  |  Yes  |  Yes  | kanatuen |
+| Kangaroo                         |  Yes  |  Yes  |  Yes  |  Yes  | kangaroo |
+| Kaos                             |  Yes  |  Yes  |  Yes  |  Yes  | kaos     |
+| Karate Blazers                   |  Yes  |  Yes  |  Yes  |   No  | karatblz |
+| Karate Champ                     |  Yes  |  Yes  |  Yes  |  Yes  | kchamp   |
+| Karate Tournament, The           |  Yes  |  Yes  |   No  |  Yes  | karatour |
+| Karian Cross                     |  Yes  |  Yes  |  Yes  |  Yes  | karianx  |
+| Karnov                           |  Yes  |  Yes  |  Yes  |  Yes  | karnov   |
+| Karnov's Revenge / Fighter's Hist|  Yes  |  Yes  |  Yes  |  Yes  | karnovr  |
+| Ken-Go                           |  Yes  |  Yes  |  Yes  |   No  | kengo    |
+| KiKi KaiKai                      |  Yes  |  Yes  |  Yes  |  Yes  | kikikai  |
+| Kick                             |  Yes  |  Yes  |  Yes  |  Yes  | kick     |
+| Kick Goal                        |  Yes  |  Yes  |   No  |  Yes  | kickgoal |
+| Kick Off                         |  Yes  |  Yes  |  Yes  |  Yes  | kickoff  |
+| Kick Rider                       |  Yes  |  Yes  |  Yes  |  Yes  | kickridr |
+| Kick Start Wheelie King          |  Yes  |  Yes  |  Yes  |  Yes  | kikstart |
+| Kick and Run                     |  Yes  |  Yes  |  Yes  |  Yes  | kicknrun |
+| Kicker                           |  Yes  |  Yes  |  Yes  |  Yes  | kicker   |
+| Kid Niki - Radical Ninja         |  Yes  |  Yes  |Partial|  Yes  | kidniki  |
+| Kid no Hore Hore Daisakusen      |  Yes  |  Yes  |  Yes  |  Yes  | horekid  |
+| Kikiippatsu Mayumi-chan          |  Yes  |  Yes  |  Yes  |  Yes  | mayumi   |
+| Killer Comet                     |  Yes  |  Yes  |  Yes  |  Yes  | killcom  |
+| Killer Instinct                  |  Yes  |  Yes  |  Yes  |  Yes  | kinst    |
+| Killer Instinct 2                |  Yes  |  Yes  |  Yes  |  Yes  | kinst2   |
+| King & Balloon                   |  Yes  |  Yes  |  Yes  |  Yes  | kingball |
+| King of Boxer                    |  Yes  |  Yes  |  Yes  |  Yes  | kingofb  |
+| King of Dragons, The             |  Yes  |  Yes  |  Yes  |  Yes  | kod      |
+| King of Fighters '94, The        |  Yes  |  Yes  |  Yes  |  Yes  | kof94    |
+| King of Fighters '95, The        |  Yes  |  Yes  |  Yes  |  Yes  | kof95    |
+| King of Fighters '96, The        |  Yes  |  Yes  |  Yes  |  Yes  | kof96    |
+| King of Fighters '97, The        |  Yes  |  Yes  |  Yes  |  Yes  | kof97    |
+| King of Fighters '98 - The Slugfe|  Yes  |  Yes  |  Yes  |  Yes  | kof98    |
+| King of Fighters '99 - Millennium|  Yes  |  Yes  |  Yes  |  Yes  | kof99    |
+| King of Fighters 2000, The       |  Yes  |  Yes  |  Yes  |  Yes  | kof2000  |
+| King of the Monsters             |  Yes  |  Yes  |  Yes  |  Yes  | kotm     |
+| King of the Monsters 2 - The Next|  Yes  |  Yes  |  Yes  |  Yes  | kotm2    |
+| Kirameki Star Road               |  Yes  |  Yes  |  Yes  |  Yes  | kirameki |
+| Kitten Kaboodle                  |  Yes  |  Yes  |  Yes  |   No  | kittenk  |
+| Kizuna Encounter - Super Tag Batt|  Yes  |  Yes  |  Yes  |  Yes  | kizuna   |
+| Klax                             |  Yes  |  Yes  |  Yes  |  Yes  | klax     |
+| Knights of Valour / Sangoku Senki|  Yes  |  Yes  |   No  |  Yes  | kov      |
+| Knights of the Round             |  Yes  |  Yes  |  Yes  |  Yes  | knights  |
+| Knuckle Bash                     |  Yes  |  Yes  |   No  |  Yes  | kbash    |
+| Knuckle Heads                    |  Yes  |  Yes  |Partial|  Yes  | knckhead |
+| Knuckle Joe                      |  Yes  |  Yes  |  Yes  |  Yes  | kncljoe  |
+| Kodure Ookami                    |   No  |  Yes  |  Yes  |  Yes  | kodure   |
+| Koi Koi Shimasyo 2 - Super Real H|  Yes  |  Yes  |  Yes  |   No  | koikois2 |
+| Kokontouzai Eto Monogatari       |  Yes  |  Yes  |  Yes  |  Yes  | eto      |
+| Konami GT                        |  Yes  |  Yes  |  Yes  |  Yes  | konamigt |
+| Kosodate Quiz My Angel           |  Yes  |  Yes  |  Yes  |   No  | myangel  |
+| Kosodate Quiz My Angel 2         |  Yes  |  Yes  |  Yes  |   No  | myangel2 |
+| Kosodate Quiz My Angel 3         |  Yes  |  Yes  |   No  |  Yes  | myangel3 |
+| Koukouyakyuh, The                |   No  |  Yes  |  Yes  |  Yes  | kouyakyu |
+| Koutetsu Yousai Strahl           |  Yes  |  Yes  |   No  |  Yes  | strahl   |
+| Kozmik Kroozr                    |  Yes  |  Yes  |  Yes  |  Yes  | kroozr   |
+| Kram                             |  Yes  |  Yes  |  Yes  |  Yes  | kram     |
+| Krazy Bowl                       |  Yes  |  Yes  |  Yes  |  Yes  | krzybowl |
+| Krull                            |  Yes  |  Yes  |  Yes  |  Yes  | krull    |
+| Kung-Fu Master                   |  Yes  |  Yes  |  Yes  |  Yes  | kungfum  |
+| Kung-Fu Taikun                   |  Yes  |  Yes  |  Yes  |  Yes  | kungfut  |
+| Kuri Kinton                      |  Yes  |  Yes  |  Yes  |  Yes  | kurikint |
+| Kyros                            |  Yes  |  Yes  |  Yes  |   No  | kyros    |
+| Kyukyoku Sentai Dadandarn        |  Yes  |  Yes  |  Yes  |  Yes  | dadandrn |
+| Kyukyoku Tiger 2                 |  Yes  |  Yes  |  Yes  |  Yes  | ktiger2  |
+| Kyuukai Douchuuki                |  Yes  |  Yes  |  Yes  |  Yes  | kyukaidk |
+| Lady Bug                         |  Yes  |  Yes  |  Yes  |  Yes  | ladybug  |
+| Lady Killer                      |  Yes  |  Yes  |   No  |  Yes  | ladykill |
+| Laguna Racer                     |  Yes  |  Yes  |   No  |  Yes  | lagunar  |
+| Land Maker                       |  Yes  |  Yes  |  Yes  |  Yes  | landmakr |
+| Land Sea Air Squad / Riku Kai Kuu|  Yes  |  Yes  |  Yes  |  Yes  | lsasquad |
+| Las Vegas Girl                   |  Yes  |  Yes  |  Yes  |  Yes  | lvgirl94 |
+| Lasso                            |  Yes  |  Yes  |  Yes  |  Yes  | lasso    |
+| Last Blade / Bakumatsu Roman - Ge|  Yes  |  Yes  |  Yes  |  Yes  | lastblad |
+| Last Blade 2 / Bakumatsu Roman - |  Yes  |  Yes  |  Yes  |  Yes  | lastbld2 |
+| Last Day, The                    |  Yes  |  Yes  |  Yes  |  Yes  | lastday  |
+| Last Duel                        |  Yes  |  Yes  |  Yes  |  Yes  | lastduel |
+| Last Fortress - Toride           |  Yes  |  Yes  |   No  |  Yes  | lastfort |
+| Last Mission                     |  Yes  |  Yes  |  Yes  |  Yes  | lastmisn |
+| Last Resort                      |  Yes  |  Yes  |  Yes  |  Yes  | lresort  |
+| Lazer Command                    |  Yes  |  Yes  |  Yes  |  Yes  | lazercmd |
+| League Bowling                   |  Yes  |  Yes  |  Yes  |  Yes  | lbowling |
+| Legend                           |  Yes  |  Yes  |  Yes  |  Yes  | legend   |
+| Legend of Hero Tonma             |  Yes  |  Yes  |  Yes  |   No  | loht     |
+| Legend of Kage, The              |  Yes  |  Yes  |  Yes  |  Yes  | lkage    |
+| Legend of Makai                  |  Yes  |  Yes  |  Yes  |  Yes  | lomakai  |
+| Legend of Silkroad, The          |  Yes  |  Yes  |  Yes  |  Yes  | silkroad |
+| Legend of Success Joe / Ashitano |  Yes  |  Yes  |  Yes  |  Yes  | legendos |
+| Legendary Wings                  |  Yes  |  Yes  |  Yes  |  Yes  | lwings   |
+| Legion                           |   No  |  Yes  |  Yes  |  Yes  | legion   |
+| Lemmings                         |  Yes  |  Yes  |  Yes  |  Yes  | lemmings |
+| Leprechaun                       |  Yes  |  Yes  |  Yes  |  Yes  | leprechn |
+| Lethal Crash Race                |  Yes  |  Yes  |  Yes  |   No  | crshrace |
+| Lethal Enforcers II: Gun Fighters|  Yes  |  Yes  |  Yes  |  Yes  | le2      |
+| Lethal Justice                   |  Yes  |  Yes  |  Yes  |  Yes  | lethalj  |
+| Lethal Thunder                   |  Yes  |  Yes  |  Yes  |  Yes  | lethalth |
+| Levers                           |  Yes  |  Yes  |  Yes  |  Yes  | levers   |
+| Libble Rabble                    |  Yes  |  Yes  |  Yes  |  Yes  | liblrabl |
+| Liberation                       |  Yes  |  Yes  |  Yes  |  Yes  | liberate |
+| Liberator                        |  Yes  |  Yes  |  Yes  |   No  | liberatr |
+| Lightning Fighters               |  Yes  |  Yes  |  Yes  |  Yes  | lgtnfght |
+| Liquid Kids                      |  Yes  |  Yes  |  Yes  |  Yes  | liquidk  |
+| Lizard Wizard                    |  Yes  |  Yes  |  Yes  |  Yes  | lizwiz   |
+| Lock'n'Chase                     |  Yes  |  Yes  |  Yes  |  Yes  | lnc      |
+| Locked 'n Loaded                 |   No  |  Yes  |  Yes  |  Yes  | lockload |
+| Loco-Motion                      |  Yes  |  Yes  |  Yes  |  Yes  | locomotn |
+| Lode Runner                      |  Yes  |  Yes  |  Yes  |  Yes  | ldrun    |
+| Lode Runner - The Dig Fight      |  Yes  |  Yes  |  Yes  |  Yes  | loderndf |
+| Lode Runner II - The Bungeling St|  Yes  |  Yes  |  Yes  |  Yes  | ldrun2   |
+| Lode Runner III - Majin No Fukkat|  Yes  |  Yes  |  Yes  |  Yes  | ldrun3   |
+| Lode Runner IV - Teikoku Karano D|  Yes  |  Yes  |  Yes  |  Yes  | ldrun4   |
+| Logger                           |  Yes  |  Yes  |Partial|   No  | logger   |
+| Logic Pro                        |  Yes  |  Yes  |  Yes  |  Yes  | logicpro |
+| Logic Pro 2                      |  Yes  |  Yes  |Partial|  Yes  | logicpr2 |
+| Looping                          |  Yes  |  Yes  |  Yes  |  Yes  | looping  |
+| Lost Tomb                        |  Yes  |  Yes  |  Yes  |  Yes  | losttomb |
+| Lot Lot                          |  Yes  |  Yes  |  Yes  |  Yes  | lotlot   |
+| Lotto Fun                        |  Yes  |  Yes  |  Yes  |  Yes  | lottofun |
+| Lovely Pop Mahjong Jan Jan Shimas|  Yes  |  Yes  |  Yes  |   No  | janjans1 |
+| Lucky & Wild                     |  Yes  |  Yes  |  Yes  |  Yes  | luckywld |
+| Lunar Lander                     |  Yes  |  Yes  |  Yes  |  Yes  | llander  |
+| Lunar Rescue                     |  Yes  |  Yes  | Yes(2)|  Yes  | lrescue  |
+| Lupin III                        |  Yes  |  Yes  |   No  |   No  | lupin3   |
+| M-4                              |  Yes  |  Yes  |   No  |  Yes  | m4       |
+| M.A.C.H. 3                       |   No  |  Yes  |  Yes  |  Yes  | mach3    |
+| M79 Ambush                       |  Yes  |  Yes  |   No  |  Yes  | m79amb   |
+| MX5000                           |  Yes  |  Yes  |  Yes  |  Yes  | mx5000   |
+| Mach Breakers                    |  Yes  |  Yes  |   No  |  Yes  | machbrkr |
+| Macho Mouse                      |  Yes  |  Yes  |  Yes  |  Yes  | machomou |
+| Macross Plus                     |  Yes  |  Yes  |  Yes  |  Yes  | macrossp |
+| Mad Crasher                      |  Yes  |  Yes  |  Yes  |  Yes  | madcrash |
+| Mad Donna                        |  Yes  |  Yes  |  Yes  |  Yes  | maddonna |
+| Mad Gear                         |  Yes  |  Yes  |  Yes  |  Yes  | madgear  |
+| Mad Motor                        |  Yes  |  Yes  |  Yes  |  Yes  | madmotor |
+| Mad Planets                      |  Yes  |  Yes  |  Yes  |  Yes  | mplanets |
+| Mad Shark                        |  Yes  |  Yes  |  Yes  |  Yes  | madshark |
+| Mag Max                          |  Yes  |  Yes  |  Yes  |  Yes  | magmax   |
+| Magic Bubble                     |  Yes  |  Yes  |  Yes  |   No  | magicbub |
+| Magic Sword - Heroic Fantasy     |  Yes  |  Yes  |  Yes  |  Yes  | msword   |
+| Magical Cat Adventure            |  Yes  |  Yes  |  Yes  |   No  | mcatadv  |
+| Magical Crystals                 |  Yes  |  Yes  |  Yes  |  Yes  | mgcrystl |
+| Magical Drop II                  |  Yes  |  Yes  |  Yes  |  Yes  | magdrop2 |
+| Magical Drop III                 |  Yes  |  Yes  |  Yes  |  Yes  | magdrop3 |
+| Magical Spot                     |  Yes  |  Yes  |Partial|  Yes  | magspot  |
+| Magical Spot II                  |  Yes  |  Yes  |Partial|  Yes  | magspot2 |
+| Magician Lord                    |  Yes  |  Yes  |  Yes  |  Yes  | maglord  |
+| Magix / Rock                     |  Yes  |  Yes  |Partial|  Yes  | magix    |
+| Mah-jong, The                    |  Yes  |  Yes  |  Yes  |  Yes  | themj    |
+| Mahjong                          |  Yes  |  Yes  |  Yes  |  Yes  | ttmahjng |
+| Mahjong Banana Dream [BET]       |  Yes  |  Yes  |  Yes  |  Yes  | bananadr |
+| Mahjong CLUB 90's                |  Yes  |  Yes  |  Yes  |  Yes  | club90s  |
+| Mahjong Camera Kozou             |  Yes  |  Yes  |  Yes  |  Yes  | mjcamera |
+| Mahjong Chinmoku no Hentai       |  Yes  |  Yes  |  Yes  |  Yes  | chinmoku |
+| Mahjong Circuit no Mehyou        |  Yes  |  Yes  |  Yes  |  Yes  | cmehyou  |
+| Mahjong Clinic                   |  Yes  |  Yes  |  Yes  |  Yes  | mjclinic |
+| Mahjong Daiyogen                 |  Yes  |  Yes  |  Yes  |  Yes  | daiyogen |
+| Mahjong Derringer                |  Yes  |  Yes  |  Yes  |  Yes  | mjderngr |
+| Mahjong Dial Q2                  |  Yes  |  Yes  |  Yes  |  Yes  | mjdialq2 |
+| Mahjong Diplomat [BET]           |  Yes  |  Yes  |  Yes  |  Yes  | mjdiplob |
+| Mahjong Doukyuusei               |  Yes  |  Yes  |  Yes  |  Yes  | dokyusei |
+| Mahjong Doukyuusei Special       |  Yes  |  Yes  |  Yes  |  Yes  | dokyusp  |
+| Mahjong Erotica Golf             |  Yes  |  Yes  |  Yes  |  Yes  | mjegolf  |
+| Mahjong Focus                    |  Yes  |  Yes  |  Yes  |  Yes  | mjfocus  |
+| Mahjong Friday                   |  Yes  |  Yes  |  Yes  |  Yes  | mjfriday |
+| Mahjong Fun Club - Idol Saizensen|  Yes  |  Yes  |  Yes  |  Yes  | mfunclub |
+| Mahjong G-MEN'89                 |  Yes  |  Yes  |  Yes  |  Yes  | mgmen89  |
+| Mahjong Gakuen                   |  Yes  |  Yes  |  Yes  |  Yes  | mgakuen  |
+| Mahjong Gakuen 2 Gakuen-chou no F|  Yes  |  Yes  |  Yes  |  Yes  | mgakuen2 |
+| Mahjong Gakuensai                |  Yes  |  Yes  |  Yes  |  Yes  | gakusai  |
+| Mahjong Gakuensai 2              |  Yes  |  Yes  |  Yes  |  Yes  | gakusai2 |
+| Mahjong Gal 10-renpatsu          |  Yes  |  Yes  |  Yes  |  Yes  | gal10ren |
+| Mahjong Gal no Kaika             |  Yes  |  Yes  |  Yes  |  Yes  | galkaika |
+| Mahjong Gal no Kokuhaku          |  Yes  |  Yes  |  Yes  |  Yes  | galkoku  |
+| Mahjong Gottsu ee-kanji          |  Yes  |  Yes  |  Yes  |  Yes  | mjgottsu |
+| Mahjong Hana no Momoko gumi      |  Yes  |  Yes  |  Yes  |  Yes  | hanamomo |
+| Mahjong Hourouki Gaiden          |  Yes  |  Yes  |  Yes  |  Yes  | mhgaiden |
+| Mahjong Hourouki Okite           |  Yes  |  Yes  |  Yes  |  Yes  | mjhokite |
+| Mahjong Hourouki Part 1 - Seisyun|  Yes  |  Yes  |  Yes  |  Yes  | hourouki |
+| Mahjong Hyper Reaction           |   No  |  Yes  |  Yes  |   No  | hypreact |
+| Mahjong Hyper Reaction 2         |  Yes  |  Yes  |  Yes  |   No  | hypreac2 |
+| Mahjong Ikaga Desu ka            |   No  |  Yes  |   No  |  Yes  | mjikaga  |
+| Mahjong Jikken Love Story        |  Yes  |  Yes  |  Yes  |  Yes  | mjlstory |
+| Mahjong Jogakuen                 |  Yes  |  Yes  |  Yes  |  Yes  | jogakuen |
+| Mahjong Kaguyahime [BET]         |  Yes  |  Yes  |  Yes  |  Yes  | kaguya   |
+| Mahjong Keibaou                  |  Yes  |  Yes  |  Yes  |  Yes  | mkeibaou |
+| Mahjong Kinjirareta Asobi        |  Yes  |  Yes  |  Yes  |  Yes  | mjkinjas |
+| Mahjong Koi Uranai               |  Yes  |  Yes  |  Yes  |  Yes  | mjkoiura |
+| Mahjong Koi no Magic Potion      |  Yes  |  Yes  |  Yes  |  Yes  | koinomp  |
+| Mahjong Kojinkyouju              |  Yes  |  Yes  |  Yes  |  Yes  | mjkojink |
+| Mahjong Kyoretsuden              |  Yes  |  Yes  |  Yes  |  Yes  | mahretsu |
+| Mahjong Kyou Jidai               |  Yes  |  Yes  |  Yes  |  Yes  | mjkjidai |
+| Mahjong La Man                   |  Yes  |  Yes  |  Yes  |  Yes  | mjlaman  |
+| Mahjong Lemon Angel              |  Yes  |  Yes  |  Yes  |  Yes  | lemnangl |
+| Mahjong Nanpa Story              |  Yes  |  Yes  |  Yes  |  Yes  | mjnanpas |
+| Mahjong Natsu Monogatari         |  Yes  |  Yes  |  Yes  |  Yes  | mjnatsu  |
+| Mahjong Nerae! Top Star          |  Yes  |  Yes  |  Yes  |  Yes  | ntopstar |
+| Mahjong Pachinko Monogatari      |  Yes  |  Yes  |  Yes  |  Yes  | patimono |
+| Mahjong Panic Stadium            |  Yes  |  Yes  |  Yes  |  Yes  | pstadium |
+| Mahjong Pon Chin Kan             |  Yes  |  Yes  |  Yes  |  Yes  | ponchin  |
+| Mahjong Quest                    |  Yes  |  Yes  |  Yes  |  Yes  | mjnquest |
+| Mahjong Ren-ai Club              |  Yes  |  Yes  |  Yes  |  Yes  | renaiclb |
+| Mahjong Rokumeikan               |  Yes  |  Yes  |  Yes  |  Yes  | mrokumei |
+| Mahjong Sailor Wars              |  Yes  |  Yes  |  Yes  |  Yes  | sailorws |
+| Mahjong Satsujin Jiken           |  Yes  |  Yes  |  Yes  |  Yes  | msjiken  |
+| Mahjong Scout Man                |  Yes  |  Yes  |  Yes  |  Yes  | mscoutm  |
+| Mahjong Shikaku                  |  Yes  |  Yes  |  Yes  |  Yes  | mjsikaku |
+| Mahjong Sisters                  |  Yes  |  Yes  |  Yes  |  Yes  | mjsister |
+| Mahjong Studio 101 [BET]         |  Yes  |  Yes  |  Yes  |  Yes  | majs101b |
+| Mahjong THE LADY HUNTER          |  Yes  |  Yes  |  Yes  |  Yes  | mladyhtr |
+| Mahjong Triple Wars              |  Yes  |  Yes  |  Yes  |  Yes  | triplew1 |
+| Mahjong Triple Wars 2            |  Yes  |  Yes  |  Yes  |  Yes  | triplew2 |
+| Mahjong Uchuu yori Ai wo komete  |  Yes  |  Yes  |  Yes  |  Yes  | uchuuai  |
+| Mahjong Uranai Densetsu          |  Yes  |  Yes  |  Yes  |  Yes  | mjuraden |
+| Mahjong Vanilla Syndrome         |  Yes  |  Yes  |  Yes  |  Yes  | vanilla  |
+| Mahjong Vitamin C                |  Yes  |  Yes  |  Yes  |  Yes  | vitaminc |
+| Mahjong Yuugi                    |  Yes  |  Yes  |  Yes  |  Yes  | mjyuugi  |
+| Mahjong-yougo no Kisotairyoku    |  Yes  |  Yes  |  Yes  |  Yes  | mjyougo  |
+| Mahjong-zukino Korinai Menmen    |  Yes  |  Yes  |  Yes  |  Yes  | korinai  |
+| Mahou Daisakusen                 |  Yes  |  Yes  |  Yes  |  Yes  | mahoudai |
+| Maikobana                        |  Yes  |  Yes  |  Yes  |  Yes  | maiko    |
+| Main Event, The                  |  Yes  |  Yes  |  Yes  |  Yes  | mainevt  |
+| Major Havoc                      |  Yes  |  Yes  |  Yes  |  Yes  | mhavoc   |
+| Major League                     |  Yes  |  Yes  |  Yes  |  Yes  | mjleague |
+| Major Title                      |  Yes  |  Yes  |  Yes  |   No  | majtitle |
+| Major Title 2                    |  Yes  |  Yes  |  Yes  |  Yes  | majtitl2 |
+| Mania Challenge                  |  Yes  |  Yes  |  Yes  |  Yes  | maniach  |
+| Maniac Square                    |  Yes  |  Yes  |  Yes  |  Yes  | maniacsq |
+| Many Block                       |  Yes  |  Yes  |Partial|   No  | manybloc |
+| Mappy                            |  Yes  |  Yes  |  Yes  |  Yes  | mappy    |
+| Marble Madness                   |  Yes  |  Yes  |  Yes  |  Yes  | marble   |
+| Marchen Maze                     |  Yes  |  Yes  |  Yes  |  Yes  | mmaze    |
+| Marine Boy                       |  Yes  |  Yes  |  Yes  |  Yes  | marineb  |
+| Mariner                          |  Yes  |  Yes  |Partial|  Yes  | mariner  |
+| Mario Bros.                      |  Yes  |  Yes  | Yes(2)|  Yes  | mario    |
+| Markham                          |  Yes  |  Yes  |  Yes  |  Yes  | markham  |
+| Mars                             |  Yes  |  Yes  |  Yes  |  Yes  | mars     |
+| Mars Matrix: Hyper Solid Shooting|  Yes  |  Yes  |  Yes  |  Yes  | mmatrix  |
+| Martial Champion                 |  Yes  |  Yes  |  Yes  |  Yes  | mtlchmpj |
+| Marvel Land                      |  Yes  |  Yes  |  Yes  |  Yes  | marvland |
+| Marvel Super Heroes              |  Yes  |  Yes  |  Yes  |  Yes  | msh      |
+| Marvel Super Heroes Vs. Street Fi|  Yes  |  Yes  |  Yes  |  Yes  | mshvsf   |
+| Marvel Vs. Capcom: Clash of Super|  Yes  |  Yes  |  Yes  |  Yes  | mvsc     |
+| Marvin's Maze                    |  Yes  |  Yes  |  Yes  |   No  | marvins  |
+| Masked Riders Club Battle Race   |  Yes  |  Yes  |  Yes  |  Yes  | kamenrid |
+| Master of Weapon                 |  Yes  |  Yes  |  Yes  |  Yes  | masterw  |
+| Masters of Kin, The              |  Yes  |   No  |  Yes  |  Yes  | mastkin  |
+| Mat Mania                        |  Yes  |  Yes  |  Yes  |  Yes  | matmania |
+| Max RPM                          |  Yes  |  Yes  |  Yes  |  Yes  | maxrpm   |
+| Maximum Force v1.05              |  Yes  |  Yes  |  Yes  |  Yes  | maxforce |
+| Maya                             |  Yes  |  Yes  |  Yes  |  Yes  | maya     |
+| Mayday                           |  Yes  |  Yes  |  Yes  |  Yes  | mayday   |
+| Mayhem 2002                      |  Yes  |  Yes  |  Yes  |  Yes  | mayhem   |
+| Maze of Flott                    |  Yes  |  Yes  |  Yes  |  Yes  | mofflott |
+| Mazinger Z                       |  Yes  |  Yes  |  Yes  |  Yes  | mazinger |
+| Meadows Lanes                    |  Yes  |  Yes  |Partial|  Yes  | medlanes |
+| Mechanized Attack                |  Yes  |  Yes  |  Yes  |  Yes  | mechatt  |
+| Medal Mahjong Circuit no Mehyou [|  Yes  |  Yes  |  Yes  |  Yes  | mmehyou  |
+| Medal Mahjong Janjan Baribari [BE|  Yes  |  Yes  |  Yes  |  Yes  | mjanbari |
+| Medal Mahjong Pachi-Slot Tengoku |  Yes  |  Yes  |  Yes  |  Yes  | pachiten |
+| Mega Blast                       |  Yes  |  Yes  |  Yes  |  Yes  | megab    |
+| Mega Man - The Power Battle      |  Yes  |  Yes  |  Yes  |  Yes  | megaman  |
+| Mega Man 2: The Power Fighters   |  Yes  |  Yes  |  Yes  |  Yes  | megaman2 |
+| Mega Twins                       |  Yes  |  Yes  |  Yes  |  Yes  | mtwins   |
+| Mega Zone                        |  Yes  |  Yes  |  Yes  |  Yes  | megazone |
+| MegaPlay: Golden Axe 2           |   No  |  Yes  |  Yes  |  Yes  | mp_gaxe2 |
+| MegaPlay: Sonic The Hedgehog     |   No  |  Yes  |  Yes  |  Yes  | mp_sonic |
+| MegaTack                         |  Yes  |  Yes  |  Yes  |  Yes  | megatack |
+| MegaTech: Afterburner            |   No  |  Yes  |  Yes  |  Yes  | mt_aftrb |
+| MegaTech: Altered Beast          |   No  |  Yes  |  Yes  |  Yes  | mt_beast |
+| MegaTech: Astro Warrior          |   No  |  Yes  |  Yes  |  Yes  | mt_astro |
+| MegaTech: Bonanza Bros.          |   No  |  Yes  |  Yes  |  Yes  | mt_bbros |
+| MegaTech: E-Swat                 |   No  |  Yes  |  Yes  |  Yes  | mt_eswat |
+| MegaTech: Fire Shark             |   No  |  Yes  |  Yes  |  Yes  | mt_fshrk |
+| MegaTech: Ghouls and Ghosts      |   No  |  Yes  |  Yes  |  Yes  | mt_gng   |
+| MegaTech: Golden Axe             |   No  |  Yes  |  Yes  |  Yes  | mt_gaxe  |
+| MegaTech: Golden Axe 2           |   No  |  Yes  |  Yes  |  Yes  | mt_gaxe2 |
+| MegaTech: Great Golf             |   No  |  Yes  |  Yes  |  Yes  | mt_ggolf |
+| MegaTech: Great Soccer           |   No  |  Yes  |  Yes  |  Yes  | mt_gsocr |
+| MegaTech: Kid Chameleon          |   No  |  Yes  |  Yes  |  Yes  | mt_kcham |
+| MegaTech: Last Battle.           |   No  |  Yes  |  Yes  |  Yes  | mt_lastb |
+| MegaTech: Moonwalker             |   No  |  Yes  |  Yes  |  Yes  | mt_mwalk |
+| MegaTech: Mystic Defender        |   No  |  Yes  |  Yes  |  Yes  | mt_mystd |
+| MegaTech: Parlour Games          |   No  |  Yes  |  Yes  |  Yes  | mt_parlg |
+| MegaTech: Shinobi                |   No  |  Yes  |  Yes  |  Yes  | mt_shnbi |
+| MegaTech: Sonic the Hedgehog     |   No  |  Yes  |  Yes  |  Yes  | mt_sonic |
+| MegaTech: Space Harrier 2.       |   No  |  Yes  |  Yes  |  Yes  | mt_shar2 |
+| MegaTech: Super Monaco Grand Prix|   No  |  Yes  |  Yes  |  Yes  | mt_smgp  |
+| MegaTech: Super Thunder Blade    |   No  |  Yes  |  Yes  |  Yes  | mt_stbld |
+| MegaTech: Tetris                 |   No  |  Yes  |  Yes  |  Yes  | mt_tetri |
+| MegaTech: The Revenge Of Shinobi |   No  |  Yes  |  Yes  |  Yes  | mt_revsh |
+| MegaTech: Thunder Force 2        |   No  |  Yes  |  Yes  |  Yes  | mt_tfor2 |
+| MegaTech: Tommy Lasorda Baseball |   No  |  Yes  |  Yes  |  Yes  | mt_tlbba |
+| MegaTech: World Cup Soccer       |   No  |  Yes  |  Yes  |  Yes  | mt_wcsoc |
+| Megadon                          |  Yes  |  Yes  |  Yes  |  Yes  | megadon  |
+| Meikyu Jima                      |  Yes  |  Yes  |  Yes  |   No  | kikcubic |
+| Meosis Magic                     |  Yes  |  Yes  |  Yes  |   No  | meosism  |
+| Mercs                            |  Yes  |  Yes  |  Yes  |  Yes  | mercs    |
+| Mermaid                          |   No  |  Yes  |  Yes  |  Yes  | mermaid  |
+| Meta Fox                         |  Yes  |  Yes  |  Yes  |  Yes  | metafox  |
+| Metal Black                      |  Yes  |  Yes  |  Yes  |  Yes  | metalb   |
+| Metal Clash                      |  Yes  |  Yes  |  Yes  |  Yes  | metlclsh |
+| Metal Hawk                       |  Yes  |  Yes  |  Yes  |  Yes  | metlhawk |
+| Metal Slug - Super Vehicle-001   |  Yes  |  Yes  |  Yes  |  Yes  | mslug    |
+| Metal Slug 2 - Super Vehicle-001/|  Yes  |  Yes  |  Yes  |  Yes  | mslug2   |
+| Metal Slug 3                     |  Yes  |  Yes  |  Yes  |  Yes  | mslug3   |
+| Metal Slug X - Super Vehicle-001 |  Yes  |  Yes  |  Yes  |  Yes  | mslugx   |
+| Metal Soldier Isaac II           |   No  |  Yes  |  Yes  |   No  | msisaac  |
+| Metamoqester                     |  Yes  |  Yes  |  Yes  |  Yes  | metmqstr |
+| Metamorphic Force                |  Yes  |  Yes  |  Yes  |  Yes  | metamrph |
+| Metro-Cross                      |  Yes  |  Yes  |  Yes  |  Yes  | metrocrs |
+| Michael Jackson's Moonwalker     | No(1) |  Yes  |  Yes  |  Yes  | moonwalk |
+| Midnight Resistance              |  Yes  |  Yes  |  Yes  |  Yes  | midres   |
+| Mighty Guy                       |   No  |  Yes  |Partial|  Yes  | mightguy |
+| Mighty Monkey                    |  Yes  |  Yes  |  Yes  |  Yes  | mimonkey |
+| Mighty! Pang                     |  Yes  |  Yes  |  Yes  |  Yes  | mpangj   |
+| Mikie                            |  Yes  |  Yes  |  Yes  |  Yes  | mikie    |
+| Mille Miglia 2: Great 1000 Miles |  Yes  |  Yes  |  Yes  |  Yes  | gtmr2    |
+| Millipede                        |  Yes  |  Yes  |  Yes  |  Yes  | milliped |
+| Minefield                        |  Yes  |  Yes  |  Yes  |  Yes  | minefld  |
+| Minesweeper                      |  Yes  |  Yes  |Part(2)|  Yes  | mineswpr |
+| Mini Golf                        |  Yes  |  Yes  |  Yes  |  Yes  | minigolf |
+| Minivader                        |  Yes  |  Yes  |  Yes  |  Yes  | minivadr |
+| Minky Monkey                     |  Yes  |  Yes  |  Yes  |  Yes  | mmonkey  |
+| Minnasanno Okagesamadesu         |  Yes  |  Yes  |  Yes  |  Yes  | minasan  |
+| Mirai Ninja                      |  Yes  |  Yes  |  Yes  |  Yes  | mirninja |
+| Miss Mahjong Contest             |  Yes  |  Yes  |  Yes  |  Yes  | mcontest |
+| Miss World '96 Nude              |  Yes  |  Yes  |  Yes  |   No  | missw96  |
+| Missile Command                  |  Yes  |  Yes  |  Yes  |  Yes  | missile  |
+| Missing in Action                |  Yes  |  Yes  |  Yes  |  Yes  | mia      |
+| Mission 660                      |  Yes  |  Yes  |  Yes  |  Yes  | m660     |
+| Mister Viking                    |  Yes  |  Yes  |  Yes  |  Yes  | mrviking |
+| Miyasu Nonki no Quiz 18-Kin      |  Yes  |  Yes  |  Yes  |   No  | quiz18k  |
+| Mobile Suit Gundam               |  Yes  |  Yes  |  Yes  |  Yes  | msgundam |
+| Moguchan                         |  Yes  |   No  |  Yes  |  Yes  | moguchan |
+| Mogura Desse                     |  Yes  |  Yes  |   No  |  Yes  | mogura   |
+| Mole Attack                      |  Yes  |  Yes  |  Yes  |  Yes  | mole     |
+| Momoko 120%                      |  Yes  |  Yes  |  Yes  |  Yes  | momoko   |
+| Money Money                      |  Yes  |  Yes  |Partial|  Yes  | monymony |
+| Money Puzzle Exchanger / Money Id|  Yes  |  Yes  |  Yes  |  Yes  | miexchng |
+| Monster Bash                     |  Yes  |  Yes  | Yes(2)|  Yes  | monsterb |
+| Monster Slider                   |  Yes  |  Yes  |  Yes  |   No  | mslider  |
+| Monte Carlo                      |  Yes  |  Yes  |  Yes  |  Yes  | montecar |
+| Moon Alien Part 2                |  Yes  |  Yes  |  Yes  |  Yes  | moonal2  |
+| Moon Cresta                      |  Yes  |  Yes  |  Yes  |  Yes  | mooncrst |
+| Moon Patrol                      |  Yes  |  Yes  |  Yes  |  Yes  | mpatrol  |
+| Moon Quasar                      |  Yes  |  Yes  |  Yes  |  Yes  | moonqsr  |
+| Moon Shuttle                     |  Yes  |  Yes  |  Yes  |  Yes  | mshuttle |
+| Moonwar                          |  Yes  |  Yes  |  Yes  |  Yes  | moonwar  |
+| Moriguchi Hiroko no Quiz de Hyuu!|  Yes  |  Yes  |  Yes  |  Yes  | quizhuhu |
+| Mortal Kombat                    |  Yes  |  Yes  |  Yes  |  Yes  | mk       |
+| Mortal Kombat 3                  |  Yes  |  Yes  |  Yes  |  Yes  | mk3      |
+| Mortal Kombat II                 |  Yes  |  Yes  |  Yes  |  Yes  | mk2      |
+| Mosaic                           |  Yes  |  Yes  |  Yes  |  Yes  | mosaic   |
+| Motos                            |  Yes  |  Yes  |  Yes  |  Yes  | motos    |
+| Mouja                            |  Yes  |  Yes  |  Yes  |   No  | mouja    |
+| Mouse Trap                       |  Yes  |  Yes  |  Yes  |  Yes  | mtrap    |
+| Mouser                           |  Yes  |  Yes  |  Yes  |  Yes  | mouser   |
+| Mr. Do!                          |  Yes  |  Yes  |  Yes  |  Yes  | mrdo     |
+| Mr. Do's Castle                  |  Yes  |  Yes  |  Yes  |  Yes  | docastle |
+| Mr. Do's Wild Ride               |  Yes  |  Yes  |  Yes  |  Yes  | dowild   |
+| Mr. Goemon                       |  Yes  |  Yes  |  Yes  |  Yes  | mrgoemon |
+| Mr. Jong                         |  Yes  |  Yes  |  Yes  |  Yes  | mrjong   |
+| Mr. Kougar                       |  Yes  |  Yes  |  Yes  |  Yes  | mrkougar |
+| Mr. TNT                          |  Yes  |   No  |  Yes  |  Yes  | mrtnt    |
+| Ms. Pac-Man                      |  Yes  |  Yes  |  Yes  |  Yes  | mspacman |
+| Mug Smashers                     |  Yes  |  Yes  |  Yes  |  Yes  | mugsmash |
+| Multi Champ                      |  Yes  |  Yes  |  Yes  |  Yes  | multchmp |
+| Musashi Ganryuuki                |  Yes  |  Yes  |  Yes  |  Yes  | ganryu   |
+| Mustache Boy                     |  Yes  |  Yes  |   No  |  Yes  | mustache |
+| Mutant Fighter                   |  Yes  |  Yes  |  Yes  |  Yes  | mutantf  |
+| Mutant Night                     |  Yes  |  Yes  |  Yes  |  Yes  | mnight   |
+| Mutation Nation                  |  Yes  |  Yes  |  Yes  |  Yes  | mutnat   |
+| My Hero                          |  Yes  |  Yes  |  Yes  |  Yes  | myhero   |
+| Mysterious Stones                |  Yes  |  Yes  |  Yes  |  Yes  | mystston |
+| Mystic Marathon                  |  Yes  |  Yes  |  Yes  |  Yes  | mysticm  |
+| Mystic Riders                    |  Yes  |  Yes  |  Yes  |  Yes  | mysticri |
+| Mystic Warriors                  |  Yes  |  Yes  |  Yes  |  Yes  | mystwarr |
+| N.Y. Captor                      |  Yes  |  Yes  |Partial|  Yes  | nycaptor |
+| NAM-1975                         |  Yes  |  Yes  |  Yes  |  Yes  | nam1975  |
+| NATO Defense                     |  Yes  |  Yes  | Yes(2)|  Yes  | natodef  |
+| NBA Hangtime                     |  Yes  |  Yes  |  Yes  |  Yes  | nbahangt |
+| NBA Jam                          |  Yes  |  Yes  |  Yes  |  Yes  | nbajam   |
+| Namco Classics Collection Vol.1  |  Yes  |  Yes  |   No  |  Yes  | ncv1     |
+| Name That Tune                   |  Yes  |  Yes  |  Yes  |  Yes  | nametune |
+| Naname de Magic!                 |  Yes  |  Yes  |  Yes  |   No  | naname   |
+| Narc                             |  Yes  |  Yes  |  Yes  |  Yes  | narc     |
+| Nastar                           |  Yes  |  Yes  |  Yes  |  Yes  | nastar   |
+| Naughty Boy                      |  Yes  |  Yes  |  Yes  |   No  | naughtyb |
+| Naughty Mouse                    |  Yes  |  Yes  |  Yes  |  Yes  | nmouse   |
+| Navalone                         |  Yes  |  Yes  |Partial|  Yes  | navalone |
+| Nebulas Ray                      |  Yes  |  Yes  |   No  |  Yes  | nebulray |
+| Neck-n-Neck                      |  Yes  |  Yes  |  Yes  |  Yes  | neckneck |
+| Nekketsu Grand-Prix Gal          |  Yes  |  Yes  |  Yes  |  Yes  | ngpgal   |
+| Nekketsu Mahjong Sengen! AFTER 5 |  Yes  |  Yes  |  Yes  |  Yes  | nmsengen |
+| Nemesis                          |  Yes  |  Yes  |  Yes  |  Yes  | nemesis  |
+| Nemo                             |  Yes  |  Yes  |  Yes  |  Yes  | nemo     |
+| Neo Bomberman                    |  Yes  |  Yes  |  Yes  |  Yes  | neobombe |
+| Neo Drift Out - New Technology   |  Yes  |  Yes  |  Yes  |  Yes  | neodrift |
+| Neo Mr. Do!                      |  Yes  |  Yes  |  Yes  |  Yes  | neomrdo  |
+| Neo Turf Masters / Big Tournament|  Yes  |  Yes  |  Yes  |  Yes  | turfmast |
+| Neo-Geo Cup '98 - The Road to the|  Yes  |  Yes  |  Yes  |  Yes  | neocup98 |
+| Net Wars                         |  Yes  |  Yes  |  Yes  |  Yes  | netwars  |
+| Nettou! Gekitou! Quiztou!!       |  Yes  |  Yes  |Partial|  Yes  | quiztou  |
+| New Fantasia                     |  Yes  |  Yes  |  Yes  |   No  | newfant  |
+| New Rally X                      |  Yes  |  Yes  | Yes(2)|  Yes  | nrallyx  |
+| New Sinbad 7                     |  Yes  | Close |  Yes  |  Yes  | newsin7  |
+| New York New York                |  Yes  |  Yes  |Partial|  Yes  | nyny     |
+| NewZealand Story, The            |  Yes  |  Yes  |  Yes  |  Yes  | tnzs     |
+| News                             |  Yes  |  Yes  |  Yes  |  Yes  | news     |
+| Next Space, The                  |  Yes  |  Yes  |  Yes  |   No  | tnexspce |
+| Nibbler                          |  Yes  |  Yes  |Part(2)|  Yes  | nibbler  |
+| Night Driver                     |  Yes  |  Yes  |Partial|  Yes  | nitedrvr |
+| Night Stocker                    |  Yes  |  Yes  |  Yes  |  Yes  | nstocker |
+| Night Striker                    |  Yes  |  Yes  |  Yes  |  Yes  | nightstr |
+| Night Warriors: Darkstalkers' Rev|  Yes  |  Yes  |  Yes  |  Yes  | nwarr    |
+| Nightmare in the Dark            |  Yes  |  Yes  |  Yes  |  Yes  | nitd     |
+| Ninja Baseball Batman            |  Yes  |  Yes  |  Yes  |  Yes  | nbbatman |
+| Ninja Clowns                     |  Yes  |  Yes  |  Yes  |  Yes  | ninclown |
+| Ninja Combat                     |  Yes  |  Yes  |  Yes  |  Yes  | ncombat  |
+| Ninja Commando                   |  Yes  |  Yes  |  Yes  |  Yes  | ncommand |
+| Ninja Emaki                      |  Yes  |  Yes  |  Yes  |  Yes  | ninjemak |
+| Ninja Kids, The                  |  Yes  |  Yes  |  Yes  |  Yes  | ninjak   |
+| Ninja Master's - haoh-ninpo-cho  |  Yes  |  Yes  |  Yes  |  Yes  | ninjamas |
+| Ninja Spirit                     |  Yes  |  Yes  |  Yes  |   No  | nspirit  |
+| Ninja Warriors, The              |  Yes  |  Yes  |  Yes  |  Yes  | ninjaw   |
+| Ninja-Kid II                     |  Yes  |  Yes  |   No  |  Yes  | ninjakd2 |
+| Ninjakun Majou no Bouken         |  Yes  |  Yes  |  Yes  |  Yes  | ninjakun |
+| Nintendo Super System: Act Raiser|   No  |  Yes  |   No  |  Yes  | nss_actr |
+| Nintendo Super System: Contra 3: |   No  |  Yes  |   No  |  Yes  | nss_con3 |
+| Nintendo Super System: David Cran|   No  |  Yes  |   No  |  Yes  | nss_aten |
+| Nintendo Super System: F-Zero    |   No  |  Yes  |   No  |  Yes  | nss_fzer |
+| Nintendo Super System: Lethal Wea|   No  |  Yes  |   No  |  Yes  | nss_lwep |
+| Nintendo Super System: NCAA Baske|   No  |  Yes  |   No  |  Yes  | nss_ncaa |
+| Nintendo Super System: Robocop 3 |   No  |  Yes  |   No  |  Yes  | nss_rob3 |
+| Nintendo Super System: Skins Game|   No  |  Yes  |   No  |  Yes  | nss_skin |
+| Nintendo Super System: Super Mari|   No  |  Yes  |   No  |  Yes  | nss_smw  |
+| Nintendo Super System: Super Socc|   No  |  Yes  |   No  |  Yes  | nss_ssoc |
+| Nintendo Super System: Super Tenn|   No  |  Yes  |   No  |  Yes  | nss_sten |
+| Nintendo Super System: The Addams|   No  |  Yes  |   No  |  Yes  | nss_adam |
+| Nitro Ball                       |  Yes  |  Yes  |  Yes  |  Yes  | nitrobal |
+| Niyanpai                         |  Yes  |  Yes  |  Yes  |  Yes  | niyanpai |
+| No Man's Land                    |  Yes  |  Yes  |Partial|  Yes  | nomnlnd  |
+| Noboranka                        |  Yes  |  Yes  |  Yes  |  Yes  | noboranb |
+| Nostradamus                      |  Yes  |  Yes  |  Yes  |   No  | nost     |
+| Nouryoku Koujou Iinkai           |  Yes  |  Yes  |  Yes  |   No  | nouryoku |
+| Nova 2001                        |  Yes  |  Yes  |  Yes  |  Yes  | nova2001 |
+| Numan Athletics                  |  Yes  |  Yes  |Partial|  Yes  | numanath |
+| Nunchackun                       |  Yes  | Close |  Yes  |  Yes  | nunchaku |
+| Off Road Challenge               |   No  |  Yes  |  Yes  |  Yes  | offroadc |
+| Off the Wall                     |  Yes  |  Yes  |  Yes  |  Yes  | offtwall |
+| Off the Wall                     |  Yes  |  Yes  |  Yes  |  Yes  | otwalls  |
+| Oh My God!                       |  Yes  |  Yes  |  Yes  |   No  | ohmygod  |
+| Oishii Puzzle Ha Irimasenka      |  Yes  |  Yes  |  Yes  |  Yes  | oisipuzl |
+| Ojanko Club                      |  Yes  |  Yes  |  Yes  |  Yes  | ojankoc  |
+| Ojanko High School               |  Yes  |  Yes  |  Yes  |  Yes  | ojankohs |
+| Ojanko Yakata                    |  Yes  |  Yes  |  Yes  |  Yes  | ojankoy  |
+| Ojanko Yakata 2bankan            |  Yes  |  Yes  |  Yes  |  Yes  | ojanko2  |
+| Ojousan                          |  Yes  |  Yes  |  Yes  |  Yes  | ojousan  |
+| Oli-Boo-Chu                      |  Yes  |   No  |Partial|  Yes  | olibochu |
+| Omega Fighter                    |  Yes  |  Yes  |  Yes  |   No  | omegaf   |
+| Omega Race                       |  Yes  |  Yes  |  Yes  |   No  | omegrace |
+| One Shot One Kill                |  Yes  |  Yes  |  Yes  |  Yes  | oneshot  |
+| Onna Sansirou - Typhoon Gal      |   No  |  Yes  |Partial|  Yes  | onna34ro |
+| Operation Thunderbolt            |  Yes  |  Yes  |  Yes  |  Yes  | othunder |
+| Operation Wolf                   |  Yes  |  Yes  |  Yes  |  Yes  | opwolf   |
+| Operation Wolf 3                 |  Yes  |  Yes  |  Yes  |  Yes  | opwolf3  |
+| Orange Club - Maruhi Kagai Jugyou|  Yes  |  Yes  |  Yes  |  Yes  | orangec  |
+| Orbit                            |  Yes  |  Yes  |  Yes  |  Yes  | orbit    |
+| Orbitron                         |  Yes  |  Yes  |  Yes  |  Yes  | orbitron |
+| Ordyne                           |  Yes  |  Yes  |  Yes  |  Yes  | ordyne   |
+| Oriental Legend / Xi Yo Gi Shi Re|  Yes  |  Yes  |   No  |  Yes  | orlegend |
+| Othello Derby                    |  Yes  |  Yes  |  Yes  |  Yes  | othldrby |
+| Otome Ryouran                    |  Yes  |  Yes  |  Yes  |  Yes  | ryouran  |
+| Otona no Mahjong                 |  Yes  |  Yes  |  Yes  |  Yes  | otonano  |
+| Out Run                          |  Yes  |  Yes  |  Yes  |  Yes  | outrun   |
+| Out Zone                         |  Yes  |  Yes  |  Yes  |  Yes  | outzone  |
+| Outfoxies                        |  Yes  |  Yes  |   No  |  Yes  | outfxies |
+| Outrunners                       |  Yes  |  Yes  |  Yes  |  Yes  | orunners |
+| Over Drive                       |  Yes  |  Yes  |  Yes  |  Yes  | overdriv |
+| Over Top                         |  Yes  |  Yes  |  Yes  |  Yes  | overtop  |
+| Ozma Wars                        |  Yes  |  Yes  | Yes(2)|  Yes  | ozmawars |
+| Ozon I                           |  Yes  |  Yes  |  Yes  |  Yes  | ozon1    |
+| P-47 - The Phantom Fighter       |  Yes  |  Yes  |  Yes  |  Yes  | p47      |
+| P-47 Aces                        |  Yes  |  Yes  |   No  |  Yes  | p47aces  |
+| P.O.W. - Prisoners of War        |  Yes  |  Yes  |  Yes  |  Yes  | pow      |
+| Pac & Pal                        |  Yes  |  Yes  |  Yes  |  Yes  | pacnpal  |
+| Pac-Land                         |  Yes  |  Yes  |  Yes  |   No  | pacland  |
+| Pac-Man Plus                     |  Yes  |  Yes  |  Yes  |  Yes  | pacplus  |
+| Pac-Mania                        |  Yes  |  Yes  |  Yes  |  Yes  | pacmania |
+| Pachinko Sexy Reaction           |  Yes  |  Yes  |  Yes  |   No  | sxyreact |
+| Paddle Mania                     |  Yes  |  Yes  |  Yes  |  Yes  | paddlema |
+| Pairs                            |  Yes  |  Yes  |Partial|  Yes  | pairsten |
+| Pairs                            |  Yes  |  Yes  |  Yes  |  Yes  | pairs    |
+| Palamedes                        |  Yes  |  Yes  |  Yes  |  Yes  | palamed  |
+| Pandora's Palace                 |  Yes  |  Yes  |  Yes  |  Yes  | pandoras |
+| Pang                             |  Yes  |  Yes  |  Yes  |  Yes  | pang     |
+| Pang Poms                        |  Yes  |  Yes  |   No  |  Yes  | pangpoms |
+| Pang! 3                          |  Yes  |  Yes  |  Yes  |  Yes  | pang3    |
+| Panic Bomber                     |  Yes  |  Yes  |  Yes  |  Yes  | panicbom |
+| Panic Street                     |  Yes  |  Yes  |  Yes  |  Yes  | panicstr |
+| Paperboy                         |  Yes  |  Yes  |  Yes  |  Yes  | paperboy |
+| Paradise                         |  Yes  |  Yes  |  Yes  |  Yes  | paradise |
+| Parodius DA!                     |  Yes  |  Yes  |  Yes  |  Yes  | parodius |
+| Pass                             |  Yes  |  Yes  |Partial|  Yes  | pass     |
+| Passing Shot                     | No(1) |  Yes  |  Yes  |  Yes  | passsht  |
+| Pastel Gal                       |  Yes  |  Yes  |  Yes  |  Yes  | pastelgl |
+| Peek-a-Boo!                      |  Yes  |  Yes  |  Yes  |  Yes  | peekaboo |
+| Peggle                           |  Yes  |  Yes  |  Yes  |  Yes  | peggle   |
+| Pengo                            |  Yes  |  Yes  |  Yes  |  Yes  | pengo    |
+| Penguin Brothers                 |  Yes  |  Yes  |  Yes  |   No  | penbros  |
+| Penguin-Kun Wars                 |  Yes  |  Yes  |  Yes  |  Yes  | pkunwar  |
+| Pepper II                        |  Yes  |  Yes  |  Yes  |  Yes  | pepper2  |
+| Percussor, The                   |  Yes  |  Yes  |  Yes  |  Yes  | percuss  |
+| Perestroika Girls                |  Yes  |  Yes  |  Yes  |  Yes  | perestro |
+| Perfect Billiard                 |  Yes  |  Yes  |  Yes  |  Yes  | pbillrd  |
+| Perfect Soldiers                 |  Yes  |  Yes  |Partial|  Yes  | psoldier |
+| Performan                        |  Yes  |  Yes  |  Yes  |  Yes  | perfrman |
+| Peter Pack-Rat                   |  Yes  |  Yes  |  Yes  |  Yes  | peterpak |
+| Pettan Pyuu                      |   No  |  Yes  |  Yes  |  Yes  | pettanp  |
+| Phantom II                       |  Yes  |  Yes  |   No  |  Yes  | phantom2 |
+| Phelios                          |  Yes  |  Yes  |  Yes  |  Yes  | phelios  |
+| Phoenix                          |  Yes  |  Yes  |  Yes  |  Yes  | phoenix  |
+| Phozon                           |  Yes  |  Yes  |  Yes  |   No  | phozon   |
+| Pickin'                          |  Yes  |  Yes  |  Yes  |  Yes  | pickin   |
+| Pig Newton                       |  Yes  |  Yes  |   No  |  Yes  | pignewt  |
+| Pigout                           |  Yes  |  Yes  |  Yes  |  Yes  | pigout   |
+| Pigskin 621AD                    |  Yes  |  Yes  |  Yes  |  Yes  | pigskin  |
+| Pinball Action                   |  Yes  |  Yes  |  Yes  |  Yes  | pbaction |
+| Pinbo                            |  Yes  |  Yes  |  Yes  |  Yes  | pinbo    |
+| Ping Pong                        |  Yes  |  Yes  |  Yes  |  Yes  | pingpong |
+| Pioneer Balloon                  |  Yes  |  Yes  |Part(2)|  Yes  | pballoon |
+| Pipe Dream                       |  Yes  |  Yes  |  Yes  |  Yes  | pipedrm  |
+| Pipi & Bibis / Whoopee!!         |  Yes  |  Yes  |  Yes  |  Yes  | pipibibs |
+| Pirate Ship Higemaru             |  Yes  |  Yes  |  Yes  |  Yes  | higemaru |
+| Pirates                          |  Yes  |  Yes  |  Yes  |  Yes  | pirates  |
+| Pisces                           |  Yes  |  Yes  |  Yes  |  Yes  | pisces   |
+| Pistol Daimyo no Bouken          |  Yes  |  Yes  |  Yes  |  Yes  | pistoldm |
+| Pit & Run                        |  Yes  |  Yes  |Partial|  Yes  | pitnrun  |
+| Pit Fighter                      |  Yes  |  Yes  |  Yes  |  Yes  | pitfight |
+| Pit, The                         |  Yes  |  Yes  |  Yes  |  Yes  | thepit   |
+| Pitfall II                       |  Yes  |  Yes  |  Yes  |  Yes  | pitfall2 |
+| Play Girls                       |  Yes  |  Yes  |  Yes  |  Yes  | plgirls  |
+| Play Girls 2                     |  Yes  |  Yes  |  Yes  |  Yes  | plgirls2 |
+| PlayBall!                        |  Yes  |  Yes  |  Yes  |  Yes  | playball |
+| PlayChoice-10: 1942              |  Yes  |  Yes  |  Yes  |  Yes  | pc_1942  |
+| PlayChoice-10: Balloon Fight     |  Yes  |  Yes  |  Yes  |  Yes  | pc_bfght |
+| PlayChoice-10: Baseball          |  Yes  |  Yes  |  Yes  |  Yes  | pc_bball |
+| PlayChoice-10: Baseball Stars    |  Yes  |  Yes  |  Yes  |  Yes  | pc_bstar |
+| PlayChoice-10: Captain Sky Hawk  |  Yes  |  Yes  |  Yes  |  Yes  | pc_cshwk |
+| PlayChoice-10: Castlevania       |  Yes  |  Yes  |  Yes  |  Yes  | pc_cvnia |
+| PlayChoice-10: Chip'n Dale - Resc|  Yes  |  Yes  |  Yes  |  Yes  | pc_rrngr |
+| PlayChoice-10: Contra            |  Yes  |  Yes  |  Yes  |  Yes  | pc_cntra |
+| PlayChoice-10: Double Dragon     |  Yes  |  Yes  |  Yes  |  Yes  | pc_ddrgn |
+| PlayChoice-10: Double Dribble    |  Yes  |  Yes  |  Yes  |  Yes  | pc_dbldr |
+| PlayChoice-10: Dr. Mario         |  Yes  |  Yes  |  Yes  |  Yes  | pc_drmro |
+| PlayChoice-10: Duck Hunt         |  Yes  |  Yes  |  Yes  |  Yes  | pc_duckh |
+| PlayChoice-10: Excite Bike       |  Yes  |  Yes  |  Yes  |  Yes  | pc_ebike |
+| PlayChoice-10: Gauntlet          |  Yes  |  Yes  |  Yes  |  Yes  | pc_gntlt |
+| PlayChoice-10: Golf              |  Yes  |  Yes  |  Yes  |  Yes  | pc_golf  |
+| PlayChoice-10: Gradius           |  Yes  |  Yes  |  Yes  |  Yes  | pc_grdus |
+| PlayChoice-10: Hogan's Alley     |  Yes  |  Yes  |  Yes  |  Yes  | pc_hgaly |
+| PlayChoice-10: Kung Fu           |  Yes  |  Yes  |  Yes  |  Yes  | pc_kngfu |
+| PlayChoice-10: Mario Bros.       |  Yes  |  Yes  |  Yes  |  Yes  | pc_mario |
+| PlayChoice-10: Mario's Open Golf |  Yes  |  Yes  |  Yes  |  Yes  | pc_moglf |
+| PlayChoice-10: Mega Man 3        |  Yes  |  Yes  |  Yes  |  Yes  | pc_mman3 |
+| PlayChoice-10: Metroid           |  Yes  |  Yes  |  Yes  |  Yes  | pc_mtoid |
+| PlayChoice-10: Mike Tyson's Punch|  Yes  |  Yes  |  Yes  |  Yes  | pc_miket |
+| PlayChoice-10: Ninja Gaiden      |  Yes  |  Yes  |  Yes  |  Yes  | pc_ngaid |
+| PlayChoice-10: Ninja Gaiden 2    |  Yes  |  Yes  |  Yes  |  Yes  | pc_ngai2 |
+| PlayChoice-10: Ninja Gaiden 3    |  Yes  |  Yes  |  Yes  |  Yes  | pc_ngai3 |
+| PlayChoice-10: Nintendo World Cup|  Yes  |  Yes  |  Yes  |  Yes  | pc_wcup  |
+| PlayChoice-10: Power Blade       |  Yes  |  Yes  |  Yes  |  Yes  | pc_pwbld |
+| PlayChoice-10: Pro Wrestling     |  Yes  |  Yes  |  Yes  |  Yes  | pc_pwrst |
+| PlayChoice-10: RC Pro Am         |  Yes  |  Yes  |  Yes  |  Yes  | pc_rcpam |
+| PlayChoice-10: Rad Racer         |  Yes  |  Yes  |  Yes  |  Yes  | pc_radrc |
+| PlayChoice-10: Rad Racer II      |  Yes  |  Yes  |  Yes  |  Yes  | pc_radr2 |
+| PlayChoice-10: Rockin' Kats      |  Yes  |  Yes  |  Yes  |  Yes  | pc_rkats |
+| PlayChoice-10: Rush N' Attack    |  Yes  |  Yes  |  Yes  |  Yes  | pc_rnatk |
+| PlayChoice-10: Rygar             |  Yes  |  Yes  |  Yes  |  Yes  | pc_rygar |
+| PlayChoice-10: Solar Jetman      |  Yes  |  Yes  |  Yes  |  Yes  | pc_sjetm |
+| PlayChoice-10: Super C           |  Yes  |  Yes  |  Yes  |  Yes  | pc_suprc |
+| PlayChoice-10: Super Mario Bros. |  Yes  |  Yes  |  Yes  |  Yes  | pc_smb   |
+| PlayChoice-10: Super Mario Bros. |  Yes  |  Yes  |  Yes  |  Yes  | pc_smb2  |
+| PlayChoice-10: Super Mario Bros. |  Yes  |  Yes  |  Yes  |  Yes  | pc_smb3  |
+| PlayChoice-10: Tecmo Bowl        |  Yes  |  Yes  |  Yes  |  Yes  | pc_tbowl |
+| PlayChoice-10: Teenage Mutant Nin|  Yes  |  Yes  |  Yes  |  Yes  | pc_tmnt  |
+| PlayChoice-10: Teenage Mutant Nin|  Yes  |  Yes  |  Yes  |  Yes  | pc_tmnt2 |
+| PlayChoice-10: Tennis            |  Yes  |  Yes  |  Yes  |  Yes  | pc_tenis |
+| PlayChoice-10: The Goonies       |  Yes  |  Yes  |  Yes  |  Yes  | pc_goons |
+| PlayChoice-10: Track & Field     |  Yes  |  Yes  |  Yes  |  Yes  | pc_tkfld |
+| PlayChoice-10: Trojan            |  Yes  |  Yes  |  Yes  |  Yes  | pc_trjan |
+| PlayChoice-10: Uncle Fester's Que|  Yes  |  Yes  |  Yes  |  Yes  | pc_ftqst |
+| PlayChoice-10: Volley Ball       |  Yes  |  Yes  |  Yes  |  Yes  | pc_vball |
+| PlayChoice-10: Wild Gunman       |  Yes  |  Yes  |  Yes  |  Yes  | pc_wgnmn |
+| PlayChoice-10: Yo! Noid          |  Yes  |  Yes  |  Yes  |  Yes  | pc_ynoid |
+| Pleasure Goal / Futsal - 5 on 5 M|  Yes  |  Yes  |  Yes  |  Yes  | pgoal    |
+| Pleiads                          |  Yes  | Close |  Yes  |  Yes  | pleiads  |
+| Plotting                         |  Yes  |  Yes  |  Yes  |  Yes  | plotting |
+| Plump Pop                        |  Yes  |  Yes  |  Yes  |  Yes  | plumppop |
+| Plus Alpha                       |  Yes  |  Yes  |  Yes  |  Yes  | plusalph |
+| Pnickies                         |  Yes  |  Yes  |  Yes  |  Yes  | pnickj   |
+| Pocket Gal                       |  Yes  |  Yes  |  Yes  |  Yes  | pcktgal  |
+| Point Blank                      |  Yes  |  Yes  |   No  |  Yes  | ptblank  |
+| Poitto!                          |  Yes  |  Yes  |   No  |  Yes  | poitto   |
+| Poker Ladies                     |  Yes  |  Yes  |  Yes  |  Yes  | pkladies |
+| Polaris                          |  Yes  |  Yes  |Partial|  Yes  | polaris  |
+| Pole Position                    |  Yes  |  Yes  | Yes(2)|  Yes  | polepos  |
+| Pole Position II                 |  Yes  |  Yes  | Yes(2)|  Yes  | polepos2 |
+| Police Trainer                   |  Yes  |  Yes  |  Yes  |  Yes  | policetr |
+| Pollux                           |  Yes  |  Yes  |  Yes  |  Yes  | pollux   |
+| Poly-Play                        |  Yes  |  Yes  |  Yes  |  Yes  | polyplay |
+| Ponpoko                          |  Yes  |  Yes  |  Yes  |  Yes  | ponpoko  |
+| Poolshark                        |  Yes  |  Yes  |   No  |  Yes  | poolshrk |
+| Pooyan                           |  Yes  |  Yes  |  Yes  |  Yes  | pooyan   |
+| Pop 'N Pop                       |  Yes  |  Yes  |  Yes  |  Yes  | popnpop  |
+| Pop 'n Bounce / Gapporin         |  Yes  |  Yes  |  Yes  |  Yes  | popbounc |
+| Pop Flamer                       |  Yes  |  Yes  |  Yes  |   No  | popflame |
+| Popeye                           |  Yes  |  Yes  |  Yes  |  Yes  | popeye   |
+| Popper                           |  Yes  | Close |  Yes  |  Yes  | popper   |
+| Poto Poto                        |  Yes  |  Yes  |  Yes  |  Yes  | potopoto |
+| Pound for Pound                  |  Yes  |  Yes  |  Yes  |   No  | poundfor |
+| Power Drive                      |  Yes  |  Yes  |  Yes  |  Yes  | powerdrv |
+| Power Instinct                   |  Yes  |  Yes  |  Yes  |  Yes  | powerins |
+| Power Instinct 2                 |  Yes  |  Yes  |  Yes  |  Yes  | pwrinst2 |
+| Power Play                       |  Yes  |  Yes  |  Yes  |  Yes  | powrplay |
+| Power Spikes                     |  Yes  |  Yes  |  Yes  |   No  | pspikes  |
+| Power Spikes II                  |  Yes  |  Yes  |  Yes  |  Yes  | pspikes2 |
+| Power Surge                      |  Yes  |  Yes  |  Yes  |  Yes  | psurge   |
+| Prebillian                       |  Yes  |  Yes  |Partial|  Yes  | pbillian |
+| Prehistoric Isle 2               |  Yes  |  Yes  |  Yes  |  Yes  | preisle2 |
+| Prehistoric Isle in 1930         |  Yes  |  Yes  |  Yes  |   No  | prehisle |
+| Premier Soccer                   |  Yes  |  Yes  |  Yes  |  Yes  | prmrsocr |
+| Pretty Soldier Sailor Moon       |  Yes  |  Yes  |  Yes  |  Yes  | sailormn |
+| Primal Rage                      |   No  |  Yes  |   No  |  Yes  | primrage |
+| Pro Mahjong Kiwame               |  Yes  |  Yes  |  Yes  |  Yes  | kiwame   |
+| Progress                         |  Yes  |  Yes  |  Yes  |  Yes  | progress |
+| Prop Cycle                       |  Yes  |  Yes  |   No  |  Yes  | propcycl |
+| Psychic 5                        |  Yes  |  Yes  |  Yes  |   No  | psychic5 |
+| Psycho Soldier                   |  Yes  |  Yes  |  Yes  |   No  | psychos  |
+| Psycho-Nics Oscar                |  Yes  |  Yes  |  Yes  |  Yes  | oscar    |
+| PuLiRuLa                         |  Yes  |  Yes  |  Yes  |  Yes  | pulirula |
+| Puchi Carat                      |  Yes  |  Yes  |  Yes  |  Yes  | puchicar |
+| PuckMan                          |  Yes  |  Yes  |  Yes  |  Yes  | puckman  |
+| Puckman Pockimon                 |  Yes  |  Yes  |  Yes  |  Yes  | puckpkmn |
+| Pulsar                           |  Yes  |  Yes  | Yes(2)|  Yes  | pulsar   |
+| Pulstar                          |  Yes  |  Yes  |  Yes  |  Yes  | pulstar  |
+| Punch-Out!!                      |  Yes  |  Yes  |  Yes  |  Yes  | punchout |
+| Punisher, The                    |  Yes  |  Yes  |  Yes  |  Yes  | punisher |
+| Punk Shot                        |  Yes  |  Yes  |  Yes  |  Yes  | punkshot |
+| Pururun                          |  Yes  |  Yes  |   No  |  Yes  | pururun  |
+| Pushman                          |  Yes  |  Yes  |  Yes  |  Yes  | pushman  |
+| Puyo Puyo                        |  Yes  |  Yes  |  Yes  |  Yes  | puyopuyo |
+| Puyo Puyo 2                      |  Yes  |  Yes  |  Yes  |  Yes  | puyopuy2 |
+| Puzz Loop                        |  Yes  |  Yes  |  Yes  |  Yes  | puzzloop |
+| Puzzle Bobble                    |  Yes  |  Yes  |  Yes  |  Yes  | pbobble  |
+| Puzzle Bobble / Bust-A-Move      |  Yes  |  Yes  |  Yes  |  Yes  | pbobblen |
+| Puzzle Bobble 2                  |  Yes  |  Yes  |  Yes  |  Yes  | pbobble2 |
+| Puzzle Bobble 2 / Bust-A-Move Aga|  Yes  |  Yes  |  Yes  |  Yes  | pbobbl2n |
+| Puzzle Bobble 3                  |  Yes  |  Yes  |  Yes  |  Yes  | pbobble3 |
+| Puzzle Bobble 4                  |  Yes  |  Yes  |  Yes  |  Yes  | pbobble4 |
+| Puzzle Club                      |  Yes  |  Yes  |  Yes  |  Yes  | puzlclub |
+| Puzzle De Bowling                |  Yes  |  Yes  |  Yes  |   No  | pzlbowl  |
+| Puzzle De Pon!                   |  Yes  |  Yes  |  Yes  |  Yes  | puzzledp |
+| Puzzled / Joy Joy Kid            |  Yes  |  Yes  |  Yes  |  Yes  | joyjoy   |
+| Puzzli                           |  Yes  |  Yes  |   No  |  Yes  | puzzli   |
+| Puzznic                          |  Yes  |  Yes  |  Yes  |  Yes  | puzznic  |
+| Q*bert                           |  Yes  |  Yes  | Yes(2)|  Yes  | qbert    |
+| Q*bert's Qubes                   |  Yes  |  Yes  | Yes(2)|  Yes  | qbertqub |
+| Qix                              |  Yes  |  Yes  |  Yes  |  Yes  | qix      |
+| Quantum                          |  Yes  |  Yes  |  Yes  |  Yes  | quantum  |
+| Quarterback                      |  Yes  |  Yes  |  Yes  |  Yes  | quarterb |
+| Quartet                          |  Yes  |  Yes  |  Yes  |  Yes  | quartet  |
+| Quester                          |  Yes  |  Yes  |  Yes  |  Yes  | quester  |
+| Quiz & Dragons                   |  Yes  |  Yes  |  Yes  |  Yes  | qad      |
+| Quiz & Variety Sukusuku Inufuku  |  Yes  |  Yes  |  Yes  |   No  | inufuku  |
+| Quiz Bisyoujo Senshi Sailor Moon |  Yes  |  Yes  |  Yes  |  Yes  | quizmoon |
+| Quiz Channel Question            |  Yes  |  Yes  |Partial|   No  | quizchq  |
+| Quiz Chikyu Bouei Gun            |  Yes  |  Yes  |  Yes  |  Yes  | qzchikyu |
+| Quiz Crayon Shinchan             |  Yes  |  Yes  |  Yes  |  Yes  | qcrayon  |
+| Quiz DNA no Hanran               |  Yes  |  Yes  |  Yes  |  Yes  | quizdna  |
+| Quiz Daisousa Sen - The Last Coun|  Yes  |  Yes  |  Yes  |  Yes  | quizdais |
+| Quiz F-1 1,2finish               |   No  |  Yes  |  Yes  |   No  | quizf1   |
+| Quiz Gakuen Paradise             |  Yes  |  Yes  |  Yes  |  Yes  | gakupara |
+| Quiz Gakumon no Susume           |  Yes  |  Yes  |  Yes  |  Yes  | qgakumon |
+| Quiz Gekiretsu Scramble          |  Yes  |  Yes  |  Yes  |  Yes  | gekiretu |
+| Quiz Ghost Hunter                |  Yes  |  Yes  |  Yes  |  Yes  | qgh      |
+| Quiz H.Q.                        |  Yes  |  Yes  |  Yes  |  Yes  | quizhq   |
+| Quiz Jinsei Gekijoh              |  Yes  |  Yes  |  Yes  |  Yes  | qjinsei  |
+| Quiz King of Fighters            |  Yes  |  Yes  |  Yes  |  Yes  | quizkof  |
+| Quiz Kokology                    |  Yes  |  Yes  |  Yes  |  Yes  | qzkklogy |
+| Quiz Kokology 2                  |  Yes  |  Yes  |  Yes  |  Yes  | qzkklgy2 |
+| Quiz Meitantei Neo & Geo - Quiz D|  Yes  |  Yes  |  Yes  |  Yes  | quizdai2 |
+| Quiz Mekurumeku Story            |  Yes  |  Yes  |  Yes  |  Yes  | quizmeku |
+| Quiz Nanairo Dreams: Nijiirochou |  Yes  |  Yes  |  Yes  |  Yes  | qndream  |
+| Quiz Quest - Hime to Yuusha no Mo|  Yes  |  Yes  |  Yes  |  Yes  | qzquest  |
+| Quiz Sangokushi                  |  Yes  |  Yes  |  Yes  |  Yes  | qsangoku |
+| Quiz Sekai wa SHOW by shobai     |  Yes  |  Yes  |  Yes  |  Yes  | qzshowby |
+| Quiz Theater - 3tsu no Monogatari|  Yes  |  Yes  |Partial|  Yes  | qtheater |
+| Quiz Tonosama no Yabou           |  Yes  |  Yes  |  Yes  |  Yes  | qtono1   |
+| Quiz Tonosama no Yabou 2 Zenkoku-|  Yes  |  Yes  |  Yes  |  Yes  | qtono2   |
+| Quiz Torimonochou                |  Yes  |  Yes  |  Yes  |  Yes  | qtorimon |
+| Quiz de Idol! Hot Debut          |  Yes  |  Yes  |  Yes  |  Yes  | hotdebut |
+| Quiz-Mahjong Hayaku Yatteyo!     |  Yes  |  Yes  |  Yes  |  Yes  | qmhayaku |
+| Qwak                             |  Yes  |  Yes  |  Yes  |   No  | qwakprot |
+| R-Shark                          |  Yes  |  Yes  |  Yes  |  Yes  | rshark   |
+| R-Type                           |  Yes  |  Yes  |  Yes  |   No  | rtype    |
+| R-Type II                        |  Yes  |  Yes  |  Yes  |   No  | rtype2   |
+| R-Type Leo                       |  Yes  |  Yes  |  Yes  |  Yes  | rtypeleo |
+| R2D Tank                         |  Yes  |  Yes  |   No  |  Yes  | r2dtank  |
+| Rabio Lepus                      |  Yes  |  Yes  |  Yes  |  Yes  | rabiolep |
+| Race Drivin'                     |  Yes  |  Yes  |  Yes  |  Yes  | racedriv |
+| Rad Mobile                       |  Yes  |  Yes  |  Yes  |  Yes  | radm     |
+| Rad Rally                        |  Yes  |  Yes  |  Yes  |  Yes  | radr     |
+| Radar Scope                      |  Yes  |  Yes  |Part(2)|  Yes  | radarscp |
+| Radar Zone                       |  Yes  |  Yes  |Partial|   No  | radarzon |
+| Radical Radial                   |  Yes  |  Yes  |  Yes  |   No  | radrad   |
+| Rafflesia                        |  Yes  |  Yes  |  Yes  |  Yes  | raflesia |
+| Ragnagard / Shin-Oh-Ken          |  Yes  |  Yes  |  Yes  |  Yes  | ragnagrd |
+| Raiden                           |  Yes  |  Yes  |  Yes  |  Yes  | raiden   |
+| Raiders5                         |  Yes  |  Yes  |  Yes  |  Yes  | raiders5 |
+| Raiga - Strato Fighter           |  Yes  |  Yes  |  Yes  |  Yes  | stratof  |
+| Raimais                          |  Yes  |  Yes  |  Yes  |  Yes  | raimais  |
+| Rainbow Islands                  |  Yes  |  Yes  |  Yes  |  Yes  | rainbow  |
+| Rally Bike / Dash Yarou          |  Yes  |  Yes  |  Yes  |  Yes  | rallybik |
+| Rally X                          |  Yes  |  Yes  | Yes(2)|  Yes  | rallyx   |
+| Rambo III                        |  Yes  |  Yes  |  Yes  |  Yes  | rambo3   |
+| Rampage                          |  Yes  |  Yes  |  Yes  |  Yes  | rampage  |
+| Rampage: World Tour              |  Yes  |  Yes  |  Yes  |  Yes  | rmpgwt   |
+| Rampart                          |  Yes  |  Yes  |  Yes  |  Yes  | rampart  |
+| Rapid Hero                       |  Yes  |  Yes  |   No  |  Yes  | raphero  |
+| Rastan                           |  Yes  |  Yes  |  Yes  |  Yes  | rastan   |
+| Razzmatazz                       |  Yes  |  Yes  |   No  |  Yes  | razmataz |
+| Reactor                          |  Yes  |  Yes  | Yes(2)|  Yes  | reactor  |
+| Real Bout Fatal Fury / Real Bout |  Yes  |  Yes  |  Yes  |  Yes  | rbff1    |
+| Real Bout Fatal Fury 2 - The Newc|  Yes  |  Yes  |  Yes  |  Yes  | rbff2    |
+| Real Bout Fatal Fury Special / Re|  Yes  |  Yes  |  Yes  |  Yes  | rbffspec |
+| Real Ghostbusters, The           |  Yes  |  Yes  |  Yes  |  Yes  | ghostb   |
+| Real Mahjong Haihai              |  Yes  |  Yes  |  Yes  |  Yes  | rmhaihai |
+| Real Mahjong Haihai Jinji Idou He|  Yes  |  Yes  |  Yes  |  Yes  | rmhaijin |
+| Real Mahjong Haihai Seichouhen   |  Yes  |  Yes  |  Yes  |  Yes  | rmhaisei |
+| Recordbreaker                    |  Yes  |  Yes  |  Yes  |  Yes  | recordbr |
+| Red Alert                        |  Yes  |   No  |Partial|  Yes  | redalert |
+| Red Baron                        |  Yes  |  Yes  |  Yes  |  Yes  | redbaron |
+| Red Clash                        |  Yes  |   No  |   No  |  Yes  | redclash |
+| Red Robin                        |  Yes  |  Yes  |  Yes  |  Yes  | redrobin |
+| Redline Racer                    |  Yes  |  Yes  |  Yes  |  Yes  | redlin2p |
+| Regulus                          |  Yes  |  Yes  |  Yes  |  Yes  | regulus  |
+| Reikai Doushi                    |  Yes  |  Yes  |  Yes  |  Yes  | reikaids |
+| Relief Pitcher                   |  Yes  |  Yes  |  Yes  |  Yes  | relief   |
+| Renegade                         |  Yes  |  Yes  |  Yes  |  Yes  | renegade |
+| Rescue                           |  Yes  |  Yes  |  Yes  |  Yes  | rescue   |
+| Rescue Raider                    |  Yes  |  Yes  |  Yes  |  Yes  | rescraid |
+| Rettou Juudan Nekkyoku Janshi - H|  Yes  |  Yes  |  Yes  |  Yes  | nekkyoku |
+| Return of Ishtar, The            |  Yes  |  Yes  |  Yes  |  Yes  | roishtar |
+| Return of the Invaders           |  Yes  |  Yes  |  Yes  |  Yes  | retofinv |
+| Return of the Jedi               |  Yes  |  Yes  |  Yes  |  Yes  | jedi     |
+| Revolution X                     |  Yes  |  Yes  |  Yes  |  Yes  | revx     |
+| Rezon                            |  Yes  |  Yes  |  Yes  |  Yes  | rezon    |
+| Ribbit!                          |  Yes  |  Yes  |  Yes  |  Yes  | ribbit   |
+| Riddle of Pythagoras             |  Yes  |  Yes  |  Yes  |  Yes  | ridleofp |
+| Riding Fight                     |  Yes  |  Yes  |   No  |  Yes  | ridingf  |
+| Riding Hero                      |  Yes  |  Yes  |  Yes  |  Yes  | ridhero  |
+| Rim Rockin' Basketball           |  Yes  |  Yes  |  Yes  |  Yes  | rimrockn |
+| Ring Rage                        |  Yes  |  Yes  |Partial|  Yes  | ringrage |
+| Ring of Destruction: Slammasters |  Yes  |  Yes  |  Yes  |  Yes  | ringdest |
+| Riot City                        |  Yes  |  Yes  |  Yes  |  Yes  | riotcity |
+| Rip Cord                         |  Yes  |  Yes  |Partial|  Yes  | ripcord  |
+| Rip Off                          |  Yes  |  Yes  | Yes(2)|  Yes  | ripoff   |
+| River Patrol                     |  Yes  |  Yes  |  Yes  |  Yes  | rpatrolb |
+| Road Blasters                    |  Yes  |  Yes  |  Yes  |  Yes  | roadblst |
+| Road Fighter                     |  Yes  |  Yes  |  Yes  |  Yes  | roadf    |
+| Road Riot's Revenge              |   No  |  Yes  |  Yes  |  Yes  | rrreveng |
+| Road Runner                      |  Yes  |  Yes  |  Yes  |  Yes  | roadrunn |
+| Robby Roto                       |  Yes  |  Yes  |  Yes  |  Yes  | robby    |
+| Robo Army                        |  Yes  |  Yes  |  Yes  |  Yes  | roboarmy |
+| Robocop                          |  Yes  |  Yes  |  Yes  |  Yes  | robocop  |
+| Robocop 2                        |  Yes  |  Yes  |  Yes  |  Yes  | robocop2 |
+| Robot Bowl                       |  Yes  |  Yes  |   No  |  Yes  | robotbwl |
+| Robotron                         |  Yes  |  Yes  |  Yes  |  Yes  | robotron |
+| Roc'n Rope                       |  Yes  |  Yes  |  Yes  |  Yes  | rocnrope |
+| Rock 'n Rage                     |  Yes  |  Yes  |  Yes  |  Yes  | rockrage |
+| Rock Climber                     |  Yes  |  Yes  |  Yes  |  Yes  | rockclim |
+| Rod-Land                         |  Yes  |  Yes  |  Yes  |  Yes  | rodland  |
+| Roller Jammer                    |  Yes  |  Yes  |  Yes  |  Yes  | rjammer  |
+| Rollergames                      |  Yes  |  Yes  |  Yes  |  Yes  | rollerg  |
+| Rolling Crash / Moon Base        |  Yes  |  Yes  |   No  |  Yes  | rollingc |
+| Rolling Thunder                  |  Yes  |  Yes  |  Yes  |  Yes  | rthunder |
+| Rolling Thunder 2                |  Yes  |  Yes  |  Yes  |  Yes  | rthun2   |
+| Rompers                          |  Yes  |  Yes  |  Yes  |  Yes  | rompers  |
+| Rong Rong                        |  Yes  |  Yes  |  Yes  |   No  | rongrong |
+| Rotary Fighter                   |  Yes  |  Yes  |   No  |  Yes  | rotaryf  |
+| Rough Ranger                     |  Yes  |  Yes  |Partial|  Yes  | rranger  |
+| Round-Up                         |  Yes  |  Yes  |  Yes  |  Yes  | roundup  |
+| Route 16                         |  Yes  |  Yes  |  Yes  |  Yes  | route16  |
+| Royal Mahjong                    |  Yes  |  Yes  |  Yes  |  Yes  | royalmah |
+| Run and Gun                      |  Yes  | Close |Partial|  Yes  | rungun   |
+| Rygar                            |  Yes  |  Yes  |  Yes  |  Yes  | rygar    |
+| Ryu Jin                          |  Yes  |  Yes  |  Yes  |  Yes  | ryujin   |
+| Ryuusei Janshi Kirara Star       |  Yes  |  Yes  |   No  |  Yes  | kirarast |
+| S.P.Y. - Special Project Y       |  Yes  |  Yes  |  Yes  |  Yes  | spy      |
+| S.R.D. Mission                   |  Yes  |  Yes  |  Yes  |  Yes  | srdmissn |
+| S.S. Mission                     |  Yes  |  Yes  |  Yes  |   No  | ssmissin |
+| S.T.U.N. Runner                  |  Yes  |  Yes  |  Yes  |  Yes  | stunrun  |
+| SAR - Search And Rescue          |  Yes  |  Yes  |  Yes  |  Yes  | searchar |
+| SD Gundam Neo Battling           |  Yes  |  Yes  |  Yes  |  Yes  | neobattl |
+| SD Gundam Psycho Salamander no Ky|  Yes  |  Yes  |   No  |   No  | sdgndmps |
+| SDI - Strategic Defense Initiativ|  Yes  |  Yes  |  Yes  |  Yes  | sdi      |
+| SF-X                             |  Yes  |  Yes  |  Yes  |  Yes  | sfx      |
+| SOS                              |  Yes  |  Yes  |Partial|  Yes  | sos      |
+| SWAT                             |  Yes  |  Yes  |  Yes  |  Yes  | swat     |
+| Saboten Bombers                  |  Yes  |  Yes  |  Yes  |   No  | sabotenb |
+| Sadari                           |  Yes  |  Yes  |  Yes  |  Yes  | sadari   |
+| Safari                           |  Yes  |  Yes  |   No  |  Yes  | safari   |
+| Safari Rally                     |  Yes  |   No  |   No  |  Yes  | safarir  |
+| Saint Dragon                     |  Yes  |  Yes  |  Yes  |  Yes  | stdragon |
+| Salamander                       |  Yes  |  Yes  |  Yes  |   No  | salamand |
+| Salamander 2                     |   No  |  Yes  |  Yes  |  Yes  | salmndr2 |
+| Samurai                          |  Yes  |  Yes  |   No  |  Yes  | samurai  |
+| Samurai Aces                     |  Yes  |  Yes  |  Yes  |  Yes  | samuraia |
+| Samurai Nihon-ichi               |  Yes  |  Yes  |  Yes  |  Yes  | tsamurai |
+| Samurai Shodown / Samurai Spirits|  Yes  |  Yes  |  Yes  |  Yes  | samsho   |
+| Samurai Shodown II / Shin Samurai|  Yes  |  Yes  |  Yes  |  Yes  | samsho2  |
+| Samurai Shodown III / Samurai Spi|  Yes  |  Yes  |  Yes  |  Yes  | samsho3  |
+| Samurai Shodown IV - Amakusa's Re|  Yes  |  Yes  |  Yes  |  Yes  | samsho4  |
+| Sand Scorpion                    |  Yes  |  Yes  |  Yes  |  Yes  | sandscrp |
+| Sankokushi                       |  Yes  |  Yes  |   No  |  Yes  | 3kokushi |
+| Sarge                            |  Yes  |  Yes  |  Yes  |  Yes  | sarge    |
+| Sasuke vs. Commander             |  Yes  |  Yes  |   No  |  Yes  | sasuke   |
+| Satan of Saturn                  |  Yes  |  Yes  |Part(2)|  Yes  | satansat |
+| Satan's Hollow                   |  Yes  |  Yes  |  Yes  |  Yes  | shollow  |
+| Saturday Night Slam Masters      |  Yes  |  Yes  |  Yes  |  Yes  | slammast |
+| Saturn                           |  Yes  |  Yes  |  Yes  |  Yes  | saturn   |
+| Sauro                            |  Yes  |  Yes  |Partial|  Yes  | sauro    |
+| Savage Reign / Fu'un Mokushiroku |  Yes  |  Yes  |  Yes  |  Yes  | savagere |
+| Scandal Mahjong                  |  Yes  |  Yes  |  Yes  |  Yes  | scandal  |
+| Scion                            |  Yes  | Close |Partial|  Yes  | scion    |
+| Scorpion                         |  Yes  |  Yes  |  Yes  |  Yes  | scorpnmc |
+| Scramble                         |  Yes  |  Yes  |  Yes  |  Yes  | scramble |
+| Scrambled Egg                    |  Yes  |  Yes  |  Yes  |  Yes  | scregg   |
+| Screw Loose                      |  Yes  |  Yes  |  Yes  |  Yes  | screwloo |
+| Scud Hammer                      |  Yes  |  Yes  |  Yes  |  Yes  | scudhamm |
+| Sea Fighter Poseidon             |  Yes  |  Yes  |  Yes  |  Yes  | sfposeid |
+| Sea Wolf                         |  Yes  |  Yes  |Part(2)|  Yes  | seawolf  |
+| Sea Wolf II                      |  Yes  |  Yes  |   No  |  Yes  | seawolf2 |
+| Second Love                      |  Yes  |  Yes  |  Yes  |  Yes  | secolove |
+| Section Z                        |  Yes  |  Yes  |  Yes  |  Yes  | sectionz |
+| Sega Ninja                       |  Yes  |  Yes  |  Yes  |  Yes  | seganinj |
+| Seicross                         |  Yes  |  Yes  |  Yes  |   No  | seicross |
+| Seiha                            |  Yes  |  Yes  |  Yes  |  Yes  | seiha    |
+| Sel Feena                        |  Yes  |  Yes  |  Yes  |  Yes  | selfeena |
+| Sen Jin - Guardian Storm         |   No  |  Yes  |  Yes  |  Yes  | grdnstrm |
+| Sen-Know                         |  Yes  |  Yes  |  Yes  |  Yes  | senknow  |
+| Sengeki Striker                  |  Yes  |  Yes  |  Yes  |  Yes  | sengekis |
+| Sengoku / Sengoku Denshou        |  Yes  |  Yes  |  Yes  |  Yes  | sengoku  |
+| Sengoku 2 / Sengoku Denshou 2    |  Yes  |  Yes  |  Yes  |  Yes  | sengoku2 |
+| Sengoku Mahjong                  |  Yes  | Close |  Yes  |  Yes  | sengokmj |
+| Senjyo                           |  Yes  |  Yes  |  Yes  |  Yes  | senjyo   |
+| Sente Diagnostic Cartridge       |  Yes  |  Yes  |  Yes  |  Yes  | sentetst |
+| Sexy Parodius                    |  Yes  |  Yes  |  Yes  |  Yes  | sexyparo |
+| Shackled                         |  Yes  |  Yes  |  Yes  |  Yes  | shackled |
+| Shadow Dancer                    |  Yes  |  Yes  |  Yes  |  Yes  | shdancer |
+| Shadow Force                     |  Yes  |  Yes  |  Yes  |   No  | shadfrce |
+| Shadow Land                      |  Yes  |  Yes  |  Yes  |  Yes  | shadowld |
+| Shadow Warriors                  |  Yes  |  Yes  |  Yes  |  Yes  | shadoww  |
+| Shanghai                         |  Yes  |  Yes  |  Yes  |  Yes  | shanghai |
+| Shanghai II                      |  Yes  |  Yes  |  Yes  |  Yes  | shangha2 |
+| Shanghai III                     |  Yes  |  Yes  |  Yes  |  Yes  | shangha3 |
+| Shanghai Kid                     |  Yes  |  Yes  |  Yes  |   No  | shangkid |
+| Shark Attack                     |  Yes  |  Yes  | Yes(2)|  Yes  | sharkatt |
+| Sharpshooter                     |  Yes  |  Yes  |  Yes  |  Yes  | sshooter |
+| Sheriff                          |  Yes  |   No  |Partial|  Yes  | sheriff  |
+| Shinobi                          |  Yes  |  Yes  |  Yes  |  Yes  | shinobi  |
+| Shippu Mahou Daisakusen          |  Yes  |  Yes  |  Yes  |  Yes  | shippumd |
+| Shock Troopers                   |  Yes  |  Yes  |  Yes  |  Yes  | shocktro |
+| Shock Troopers - 2nd Squad       |  Yes  |  Yes  |  Yes  |  Yes  | shocktr2 |
+| Shocking                         |  Yes  |  Yes  |  Yes  |   No  | shocking |
+| Shoot Out                        |  Yes  |  Yes  |  Yes  |  Yes  | shootout |
+| Shoot the Bull                   |  Yes  |  Yes  |  Yes  |  Yes  | shootbul |
+| Shot Rider                       |  Yes  |  Yes  |  Yes  |   No  | shtrider |
+| Showdown                         |  Yes  |  Yes  |  Yes  |  Yes  | showdown |
+| Shrike Avenger                   |   No  |  Yes  |  Yes  |  Yes  | shrike   |
+| Shuffleboard                     |  Yes  |  Yes  |   No  |  Yes  | shuffle  |
+| Shuffleshot                      |  Yes  |  Yes  |  Yes  |  Yes  | shufshot |
+| Shuuz                            |  Yes  |  Yes  |  Yes  |  Yes  | shuuz    |
+| Sichuan II                       |  Yes  |  Yes  |  Yes  |  Yes  | sichuan2 |
+| Side Arms - Hyper Dyne           |  Yes  |  Yes  |  Yes  |  Yes  | sidearms |
+| Side Pocket                      |  Yes  |  Yes  |  Yes  |  Yes  | sidepckt |
+| Side Track                       |  Yes  |  Yes  | Yes(2)|  Yes  | sidetrac |
+| Silent Dragon                    |  Yes  |  Yes  |  Yes  |  Yes  | silentd  |
+| Silk Worm                        |  Yes  |  Yes  |  Yes  |  Yes  | silkworm |
+| Simpsons, The                    |  Yes  |  Yes  |  Yes  |  Yes  | simpsons |
+| Sindbad Mystery                  |  Yes  |  Yes  |  Yes  |  Yes  | sindbadm |
+| Sinistar                         |  Yes  |  Yes  |  Yes  |  Yes  | sinistar |
+| Skull & Crossbones               |  Yes  |  Yes  |  Yes  |  Yes  | skullxbo |
+| Sky Adventure                    |  Yes  |  Yes  |  Yes  |  Yes  | skyadvnt |
+| Sky Alert                        |  Yes  |  Yes  |   No  |  Yes  | skyalert |
+| Sky Army                         |  Yes  |   No  |  Yes  |  Yes  | skyarmy  |
+| Sky Base                         |  Yes  |  Yes  |  Yes  |  Yes  | skybase  |
+| Sky Bumper                       |  Yes  |  Yes  |  Yes  |  Yes  | skybump  |
+| Sky Chuter                       |  Yes  | Close |   No  |   No  | skychut  |
+| Sky Diver                        |  Yes  |  Yes  |   No  |  Yes  | skydiver |
+| Sky Fox                          |  Yes  |  Yes  |  Yes  |  Yes  | skyfox   |
+| Sky Kid                          |  Yes  |  Yes  |  Yes  |  Yes  | skykid   |
+| Sky Kid Deluxe                   |  Yes  |  Yes  |  Yes  |  Yes  | skykiddx |
+| Sky Lancer                       |  Yes  |  Yes  |  Yes  |  Yes  | skylancr |
+| Sky Raider                       |  Yes  | Close |   No  |  Yes  | skyraid  |
+| Sky Skipper                      |  Yes  |  Yes  |  Yes  |  Yes  | skyskipr |
+| Sky Smasher                      |  Yes  |  Yes  |  Yes  |  Yes  | skysmash |
+| Sky Soldiers                     |  Yes  |  Yes  |  Yes  |  Yes  | skysoldr |
+| Slap Fight                       | No(1) |  Yes  |  Yes  |   No  | slapfigh |
+| Slap Shot                        |  Yes  |  Yes  |  Yes  |  Yes  | slapshot |
+| Slick Shot                       |  Yes  |  Yes  |  Yes  |  Yes  | slikshot |
+| Slither                          |  Yes  |  Yes  |  Yes  |  Yes  | slither  |
+| Sly Spy                          |  Yes  |  Yes  |  Yes  |  Yes  | slyspy   |
+| Smash T.V.                       |  Yes  |  Yes  |  Yes  |  Yes  | smashtv  |
+| Snacks'n Jaxson                  |  Yes  |  Yes  |  Yes  |  Yes  | snakjack |
+| Snake Pit                        |  Yes  |  Yes  |  Yes  |  Yes  | snakepit |
+| Snap Jack                        |  Yes  |  Yes  |  Yes  |  Yes  | snapjack |
+| Snow Board Championship          |   No  |  Yes  |  Yes  |  Yes  | snowboar |
+| Snow Bros. - Nick & Tom          |  Yes  |  Yes  |  Yes  |  Yes  | snowbros |
+| Snow Bros. 2 - With New Elves / O|  Yes  |  Yes  |  Yes  |  Yes  | snowbro2 |
+| Soccer Brawl                     |  Yes  |  Yes  |  Yes  |  Yes  | socbrawl |
+| Sokonuke Taisen Game             |  Yes  |  Yes  |Partial|  Yes  | sokonuke |
+| Sol Divide - The Sword Of Darknes|  Yes  |  Yes  |Partial|  Yes  | soldivid |
+| Solar Fox                        |  Yes  |  Yes  |  Yes  |  Yes  | solarfox |
+| Solar Quest                      |  Yes  |  Yes  | Yes(2)|  Yes  | solarq   |
+| Soldam                           |  Yes  |  Yes  |  Yes  |  Yes  | soldamj  |
+| Soldier Girl Amazon              |  Yes  |  Yes  |  Yes  |  Yes  | amazon   |
+| Solitary Fighter                 |  Yes  |  Yes  |  Yes  |  Yes  | solfigtr |
+| Solomon's Key                    |  Yes  |  Yes  |  Yes  |  Yes  | solomon  |
+| Solvalou                         |  Yes  |  Yes  |  Yes  |  Yes  | solvalou |
+| Son Son                          |  Yes  |  Yes  |  Yes  |  Yes  | sonson   |
+| Son of Phoenix                   |  Yes  |  Yes  |  Yes  |  Yes  | sonofphx |
+| Sonic                            | No(1) |  Yes  |  Yes  |  Yes  | sonic    |
+| Sonic Blast Man                  |  Yes  |  Yes  |  Yes  |  Yes  | sbm      |
+| Sotsugyo Shousho                 |  Yes  |  Yes  |  Yes  |  Yes  | sotsugyo |
+| Space Attack                     |  Yes  |  Yes  |   No  |  Yes  | sspaceat |
+| Space Beam                       |  Yes  | Close |   No  |   No  | spacbeam |
+| Space Bomber                     |  Yes  |  Yes  |  Yes  |  Yes  | sbomberb |
+| Space Chaser                     |  Yes  | Close |Partial|  Yes  | schaser  |
+| Space Cruiser                    |  Yes  |  Yes  |  Yes  |  Yes  | spacecr  |
+| Space Duel                       |  Yes  |  Yes  |  Yes  |  Yes  | spacduel |
+| Space Dungeon                    |  Yes  |  Yes  |  Yes  |  Yes  | sdungeon |
+| Space Encounters                 |  Yes  |  Yes  |   No  |  Yes  | spcenctr |
+| Space Fever                      |  Yes  |  Yes  |Partial|  Yes  | spacefev |
+| Space Firebird                   |  Yes  | Close |Partial|  Yes  | spacefb  |
+| Space Force                      |  Yes  | Close |  Yes  |  Yes  | spcforce |
+| Space Fortress                   |  Yes  |  Yes  |Partial|   No  | spacefrt |
+| Space Fury                       |  Yes  |  Yes  | Yes(2)|  Yes  | spacfury |
+| Space Gun                        |  Yes  |  Yes  |  Yes  |  Yes  | spacegun |
+| Space Harrier                    |  Yes  |  Yes  |  Yes  |  Yes  | sharrier |
+| Space Intruder                   |  Yes  |   No  | Yes(2)|  Yes  | spaceint |
+| Space Invaders                   |  Yes  |  Yes  | Yes(2)|  Yes  | invaders |
+| Space Invaders '95 - Attack Of Th|  Yes  |  Yes  |  Yes  |  Yes  | spcinv95 |
+| Space Invaders DX                |  Yes  |  Yes  |  Yes  |  Yes  | spacedx  |
+| Space Invaders II                |  Yes  |  Yes  | Yes(2)|  Yes  | invad2ct |
+| Space Invaders Part II           |  Yes  |  Yes  | Yes(2)|  Yes  | invadpt2 |
+| Space King 2                     |  Yes  |  Yes  | Yes(2)|  Yes  | spcking2 |
+| Space Laser                      |  Yes  |  Yes  | Yes(2)|  Yes  | spclaser |
+| Space Odyssey                    |  Yes  |  Yes  | Yes(2)|  Yes  | spaceod  |
+| Space Panic                      |  Yes  |  Yes  | Yes(2)|  Yes  | panic    |
+| Space Seeker                     |  Yes  |  Yes  |  Yes  |  Yes  | spaceskr |
+| Space Stranger                   |  Yes  |  Yes  | Yes(2)|  Yes  | sstrangr |
+| Space Stranger 2                 |  Yes  |  Yes  | Yes(2)|  Yes  | sstrngr2 |
+| Space Tactics                    |  Yes  |  Yes  |   No  |  Yes  | stactics |
+| Space Trek                       |  Yes  |  Yes  |   No  |  Yes  | spacetrk |
+| Space Wars                       |  Yes  |  Yes  | Yes(2)|  Yes  | spacewar |
+| Space Zap                        |  Yes  |  Yes  |  Yes  |  Yes  | spacezap |
+| Sparkz                           |  Yes  |  Yes  |  Yes  |  Yes  | sparkz   |
+| Spatter                          |  Yes  |  Yes  |  Yes  |  Yes  | spatter  |
+| Speak & Rescue                   |  Yes  |  Yes  |  Yes  |  Yes  | speakres |
+| Special Criminal Investigation   |  Yes  |  Yes  |  Yes  |  Yes  | sci      |
+| Special Forces                   |  Yes  |  Yes  |   No  |  Yes  | spclforc |
+| Special Forces II                |  Yes  |  Yes  |   No  |  Yes  | spcfrcii |
+| Spectar                          |  Yes  |  Yes  | Yes(2)|  Yes  | spectar  |
+| Speed Attack!                    |  Yes  |   No  |  Yes  |  Yes  | speedatk |
+| Speed Ball                       |  Yes  |  Yes  |  Yes  |  Yes  | speedbal |
+| Speed Ball                       |  Yes  |  Yes  |  Yes  |  Yes  | spdball  |
+| Speed Coin                       |  Yes  |  Yes  |  Yes  |  Yes  | spdcoin  |
+| Speed Freak                      |  Yes  |  Yes  |   No  |  Yes  | speedfrk |
+| Speed Rumbler, The               |  Yes  |  Yes  |  Yes  |  Yes  | srumbler |
+| Speed Spin                       |  Yes  |  Yes  |  Yes  |  Yes  | speedspn |
+| Spelunker                        |  Yes  |  Yes  |  Yes  |  Yes  | spelunkr |
+| Spelunker II                     |  Yes  |  Yes  |  Yes  |  Yes  | spelunk2 |
+| Spiderman                        |  Yes  |  Yes  |  Yes  |  Yes  | spidey   |
+| Spiders                          |  Yes  |  Yes  |   No  |   No  | spiders  |
+| Spiker                           |  Yes  |  Yes  |  Yes  |  Yes  | spiker   |
+| Spin Master / Miracle Adventure  |  Yes  |  Yes  |  Yes  |  Yes  | spinmast |
+| Spinal Breakers                  |  Yes  |  Yes  |  Yes  |   No  | spinlbrk |
+| Splash!                          |  Yes  |  Yes  |  Yes  |  Yes  | splash   |
+| Splat!                           |  Yes  |  Yes  |  Yes  |  Yes  | splat    |
+| Splatter House                   |  Yes  |  Yes  |  Yes  |  Yes  | splatter |
+| Splendor Blast                   |   No  |  Yes  |  Yes  |   No  | splndrbt |
+| Springer                         |  Yes  |  Yes  |  Yes  |  Yes  | springer |
+| Sprint 1                         |  Yes  |  Yes  |  Yes  |  Yes  | sprint1  |
+| Sprint 4                         |  Yes  |  Yes  |   No  |  Yes  | sprint4  |
+| Sprint 8                         |  Yes  |  Yes  |   No  |  Yes  | sprint8  |
+| Spy Hunter                       |  Yes  |  Yes  |  Yes  |  Yes  | spyhunt  |
+| Spy Hunter 2                     |  Yes  |  Yes  |  Yes  |  Yes  | spyhunt2 |
+| Stack Columns                    |  Yes  |  Yes  |  Yes  |  Yes  | stkclmns |
+| Stadium Cross                    |  Yes  |  Yes  |  Yes  |  Yes  | scross   |
+| Stadium Hero                     |  Yes  |  Yes  |  Yes  |  Yes  | stadhero |
+| Stagger I                        |   No  |  Yes  |  Yes  |  Yes  | stagger1 |
+| Stakes Winner / Stakes Winner - G|  Yes  |  Yes  |  Yes  |  Yes  | stakwin  |
+| Stakes Winner 2                  |  Yes  |  Yes  |  Yes  |  Yes  | stakwin2 |
+| Star Castle                      |  Yes  |  Yes  | Yes(2)|  Yes  | starcas  |
+| Star Cruiser                     |  Yes  |  Yes  | Yes(2)|  Yes  | starcrus |
+| Star Fire                        |  Yes  |  Yes  |   No  |  Yes  | starfire |
+| Star Force                       |  Yes  |  Yes  |  Yes  |  Yes  | starforc |
+| Star Guards                      |  Yes  |  Yes  |  Yes  |  Yes  | stargrds |
+| Star Hawk                        |  Yes  |  Yes  |   No  |  Yes  | starhawk |
+| Star Jacker                      |  Yes  |  Yes  |  Yes  |  Yes  | starjack |
+| Star Sweep                       |  Yes  |  Yes  |   No  |  Yes  | starswep |
+| Star Trek                        |  Yes  |  Yes  | Yes(2)|  Yes  | startrek |
+| Star Wars                        |  Yes  |  Yes  |  Yes  |  Yes  | starwars |
+| Starblade                        |  Yes  |  Yes  |  Yes  |  Yes  | starblad |
+| Stargate                         |  Yes  |  Yes  |  Yes  |  Yes  | stargate |
+| Starship 1                       |  Yes  |  Yes  |   No  |  Yes  | starshp1 |
+| Steel Force                      |  Yes  |  Yes  |Partial|  Yes  | stlforce |
+| Steel Gunner                     |  Yes  |  Yes  |  Yes  |  Yes  | sgunner  |
+| Steel Gunner 2                   |  Yes  |  Yes  |  Yes  |  Yes  | sgunner2 |
+| Steel Talons                     |  Yes  |  Yes  |  Yes  |  Yes  | steeltal |
+| Stinger                          |  Yes  |  Yes  |Partial|  Yes  | stinger  |
+| Stocker                          |  Yes  |  Yes  |  Yes  |  Yes  | stocker  |
+| Stompin'                         |  Yes  |  Yes  |  Yes  |  Yes  | stompin  |
+| Stone Ball                       |  Yes  |  Yes  |  Yes  |  Yes  | stonebal |
+| Storm Blade                      |  Yes  |  Yes  |  Yes  |   No  | stmblade |
+| Straight Flush                   |  Yes  | Close |   No  |   No  | sflush   |
+| Strata Bowling                   |  Yes  |  Yes  |  Yes  |  Yes  | stratab  |
+| Strategy X                       |  Yes  |  Yes  |  Yes  |  Yes  | stratgyx |
+| Streaking                        |  Yes  | Close |  Yes  |  Yes  | streakng |
+| Street Fighter                   |  Yes  |  Yes  |  Yes  |  Yes  | sf1      |
+| Street Fighter Alpha 2           |  Yes  |  Yes  |  Yes  |  Yes  | sfa2     |
+| Street Fighter Alpha 3           |  Yes  |  Yes  |  Yes  |  Yes  | sfa3     |
+| Street Fighter Alpha: Warriors' D|  Yes  |  Yes  |  Yes  |  Yes  | sfa      |
+| Street Fighter II - The World War|  Yes  |  Yes  |  Yes  |  Yes  | sf2      |
+| Street Fighter II' - Champion Edi|  Yes  |  Yes  |  Yes  |  Yes  | sf2ce    |
+| Street Fighter: The Movie        |  Yes  |  Yes  |  Yes  |  Yes  | sftm     |
+| Street Football                  |  Yes  |  Yes  |  Yes  |  Yes  | sfootbal |
+| Street Heat - Cardinal Amusements|  Yes  |  Yes  |   No  |  Yes  | strtheat |
+| Street Hoop / Street Slam / Dunk |  Yes  |  Yes  |  Yes  |  Yes  | strhoop  |
+| Street Smart                     |  Yes  |  Yes  |  Yes  |  Yes  | streetsm |
+| Strength & Skill                 |  Yes  |  Yes  |  Yes  |  Yes  | strnskil |
+| Strider                          |  Yes  |  Yes  |  Yes  |  Yes  | strider  |
+| Strike Bowling                   |  Yes  | Close |Partial|  Yes  | sbowling |
+| Strike Force                     |  Yes  |  Yes  |  Yes  |  Yes  | strkforc |
+| Strike Gunner S.T.G              |  Yes  |  Yes  |  Yes  |  Yes  | stg      |
+| Strike Zone Baseball             |  Yes  |  Yes  |  Yes  |  Yes  | strkzone |
+| Strikers 1945                    |  Yes  |  Yes  |  Yes  |  Yes  | s1945    |
+| Strikers 1945 II                 |  Yes  |  Yes  |  Yes  |  Yes  | s1945ii  |
+| Strikers 1945 III                |  Yes  |  Yes  |  Yes  |  Yes  | s1945iii |
+| Strikers 1945 Plus               |  Yes  |  Yes  |  Yes  |  Yes  | s1945p   |
+| Subroc-3D                        |  Yes  |  Yes  | Yes(2)|  Yes  | subroc3d |
+| Subs                             |  Yes  |  Yes  |Partial|  Yes  | subs     |
+| Sundance                         |   No  |  Yes  |   No  |  Yes  | sundance |
+| Sunset Riders                    |  Yes  |  Yes  |  Yes  |  Yes  | ssriders |
+| Super Bagman                     |  Yes  |  Yes  |  Yes  |  Yes  | sbagman  |
+| Super Baseball Double Play Home R|  Yes  |  Yes  |  Yes  |  Yes  | dblplay  |
+| Super Basketball                 |  Yes  |  Yes  |  Yes  |  Yes  | sbasketb |
+| Super Bond                       |  Yes  |   No  |  Yes  |  Yes  | superbon |
+| Super Breakout                   |  Yes  |  Yes  |  Yes  |  Yes  | sbrkout  |
+| Super Bug                        |  Yes  |  Yes  |  Yes  |  Yes  | superbug |
+| Super Burger Time                |  Yes  |  Yes  |  Yes  |  Yes  | supbtime |
+| Super Casino                     |  Yes  |  Yes  |  Yes  |  Yes  | sucasino |
+| Super Champion Baseball          |  Yes  |  Yes  |  Yes  |  Yes  | sbasebal |
+| Super Chase - Criminal Terminatio|  Yes  |  Yes  |  Yes  |  Yes  | superchs |
+| Super Cobra                      |  Yes  |  Yes  |  Yes  |  Yes  | scobra   |
+| Super Contra                     |  Yes  |  Yes  |  Yes  |  Yes  | scontra  |
+| Super Cross 2                    |  Yes  |  Yes  |  Yes  |  Yes  | sprcros2 |
+| Super Cup Finals                 |  Yes  |  Yes  |  Yes  |  Yes  | scfinals |
+| Super Dodge Ball                 |  Yes  |  Yes  |  Yes  |  Yes  | spdodgeb |
+| Super Dodge Ball / Kunio no Nekke|  Yes  |  Yes  |  Yes  |  Yes  | sdodgeb  |
+| Super Doubles Tennis             |  Yes  |  Yes  |  Yes  |  Yes  | sdtennis |
+| Super Duper Casino               |  Yes  |  Yes  |  Yes  |  Yes  | usg32    |
+| Super Gem Fighter Mini Mix       |  Yes  |  Yes  |  Yes  |  Yes  | sgemf    |
+| Super Glob                       |  Yes  |  Yes  |  Yes  |  Yes  | suprglob |
+| Super Hang-On                    | No(1) |  Yes  |  Yes  |  Yes  | shangon  |
+| Super High Impact                |   No  |  Yes  |  Yes  |  Yes  | shimpact |
+| Super Invader Attack             |  Yes  |  Yes  |   No  |  Yes  | sia2650  |
+| Super Locomotive                 |  Yes  |  Yes  |  Yes  |  Yes  | suprloco |
+| Super Marukin-Ban                |  Yes  |  Yes  |  Yes  |  Yes  | marukin  |
+| Super Pac-Man                    |  Yes  |  Yes  |  Yes  |  Yes  | superpac |
+| Super Pang                       |  Yes  |  Yes  |  Yes  |  Yes  | spang    |
+| Super Pinball Action             |  Yes  |  Yes  |  Yes  |  Yes  | spbactn  |
+| Super Punch-Out!!                |  Yes  |  Yes  |  Yes  |  Yes  | spnchout |
+| Super Puzzle Fighter 2 Turbo     |  Yes  |  Yes  |  Yes  |  Yes  | spf2t    |
+| Super Qix                        | No(1) |  Yes  |  Yes  |  Yes  | superqix |
+| Super Real Darwin                |  Yes  |  Yes  |  Yes  |  Yes  | srdarwin |
+| Super Real Mahjong P7            |  Yes  |  Yes  |Partial|   No  | srmp7    |
+| Super Real Mahjong PIV           |  Yes  |  Yes  |  Yes  |   No  | srmp4    |
+| Super Real Mahjong Part 2        |  Yes  |  Yes  |  Yes  |  Yes  | srmp2    |
+| Super Real Mahjong Part 3        |  Yes  |  Yes  |  Yes  |  Yes  | srmp3    |
+| Super Shanghai Dragon's Eye      | No(1) |  Yes  |   No  |  Yes  | sshangha |
+| Super Sidekicks / Tokuten Ou     |  Yes  |  Yes  |  Yes  |  Yes  | ssideki  |
+| Super Sidekicks 2 - The World Cha|  Yes  |  Yes  |  Yes  |  Yes  | ssideki2 |
+| Super Sidekicks 3 - The Next Glor|  Yes  |  Yes  |  Yes  |  Yes  | ssideki3 |
+| Super Slam                       |  Yes  |  Yes  |   No  |  Yes  | sslam    |
+| Super Slams                      |  Yes  |  Yes  |  Yes  |  Yes  | suprslam |
+| Super Space Invaders '91         |  Yes  |  Yes  |  Yes  |  Yes  | ssi      |
+| Super Spacefortress Macross / Cho|  Yes  |  Yes  |   No  |  Yes  | macross  |
+| Super Spacefortress Macross II / |  Yes  |  Yes  |  Yes  |   No  | macross2 |
+| Super Speed Race Junior          |  Yes  |   No  |  Yes  |  Yes  | ssrj     |
+| Super Sprint                     |  Yes  |  Yes  |  Yes  |  Yes  | ssprint  |
+| Super Spy, The                   |  Yes  |  Yes  |  Yes  |  Yes  | superspy |
+| Super Stingray                   |  Yes  |   No  |  Yes  |   No  | sstingry |
+| Super Street Fighter 2: The New C|  Yes  |  Yes  |  Yes  |  Yes  | ssf2     |
+| Super Ten V8.3                   |  Yes  |  Yes  |  Yes  |  Yes  | usg83    |
+| Super Toffy                      |  Yes  |  Yes  |  Yes  |  Yes  | stoffy   |
+| Super Triv II                    |  Yes  |   No  |  Yes  |  Yes  | supertr2 |
+| Super Trivia Master              |  Yes  |   No  |Partial|   No  | strvmstr |
+| Super Visual Football            |  Yes  |  Yes  |  Yes  |  Yes  | svf      |
+| Super Volleyball                 |  Yes  |  Yes  |  Yes  |  Yes  | svolley  |
+| Super World Court                |  Yes  |  Yes  |Partial|  Yes  | swcourt  |
+| Super World Stadium '92          |  Yes  |  Yes  |  Yes  |  Yes  | sws92    |
+| Super World Stadium '93          |  Yes  |  Yes  |  Yes  |  Yes  | sws93    |
+| Super World Stadium '95          |  Yes  |  Yes  |   No  |  Yes  | sws95    |
+| Super World Stadium '96          |  Yes  |  Yes  |   No  |  Yes  | sws96    |
+| Super World Stadium '97          |  Yes  |  Yes  |   No  |  Yes  | sws97    |
+| Super Zaxxon                     |  Yes  |  Yes  | Yes(2)|  Yes  | szaxxon  |
+| Super-X                          |  Yes  |  Yes  |  Yes  |  Yes  | superx   |
+| Superbike                        |  Yes  |  Yes  |Partial|   No  | superbik |
+| Superman                         |  Yes  |  Yes  |  Yes  |  Yes  | superman |
+| Surprise Attack                  |  Yes  |  Yes  |  Yes  |  Yes  | surpratk |
+| Survival Arts                    |  Yes  |  Yes  |  Yes  |   No  | survarts |
+| Suzuka 8 Hours                   |   No  |  Yes  |  Yes  |  Yes  | suzuka8h |
+| Suzuka 8 Hours 2                 |  Yes  |  Yes  |  Yes  |  Yes  | suzuk8h2 |
+| Swimmer                          |  Yes  |  Yes  |  Yes  |  Yes  | swimmer  |
+| Syougi No Tatsujin - Master of Sy|  Yes  |  Yes  |  Yes  |  Yes  | mosyougi |
+| Syusse Oozumou                   |  Yes  |  Yes  |  Yes  |  Yes  | ssozumo  |
+| Syvalion                         |  Yes  |  Yes  |  Yes  |  Yes  | syvalion |
+| T.N.K. III                       |  Yes  |  Yes  |  Yes  |   No  | tnk3     |
+| TH Strikes Back                  |   No  |  Yes  |  Yes  |  Yes  | thoop2   |
+| Tac/Scan                         |  Yes  |  Yes  | Yes(2)|  Yes  | tacscan  |
+| Tactician                        |  Yes  |  Yes  |  Yes  |  Yes  | tactcian |
+| Tail to Nose - Great Championship|  Yes  |  Yes  |  Yes  |   No  | tail2nos |
+| Tailgunner                       |  Yes  |  Yes  |   No  |  Yes  | tailg    |
+| Taisen Hot Gimmick               |  Yes  |  Yes  |Partial|  Yes  | hotgmck  |
+| Taisen Hot Gimmick 3 Digital Surf|  Yes  |  Yes  |Partial|  Yes  | hotgmck3 |
+| Taisen Hot Gimmick Kairakuten    |  Yes  |  Yes  |Partial|  Yes  | hgkairak |
+| Taisen Idol-Mahjong Final Romance|  Yes  |  Yes  |  Yes  |  Yes  | fromanc2 |
+| Taisen Mahjong FinalRomance 4    |  Yes  |  Yes  |  Yes  |  Yes  | fromanc4 |
+| Taisen Mahjong FinalRomance R    |  Yes  |  Yes  |  Yes  |  Yes  | fromancr |
+| Taisen Puzzle-dama               |  Yes  |  Yes  |  Yes  |  Yes  | puzldama |
+| Taisen Quiz HYHOO                |  Yes  |  Yes  |  Yes  |  Yes  | hyhoo    |
+| Taisen Quiz HYHOO 2              |  Yes  |  Yes  |  Yes  |  Yes  | hyhoo2   |
+| Taisen Tokkae-dama               |  Yes  |  Yes  |  Yes  |  Yes  | tokkae   |
+| Taito Power Goal                 |  Yes  |  Yes  |  Yes  |  Yes  | pwrgoal  |
+| Takeda Shingen                   |  Yes  |  Yes  |  Yes  |  Yes  | tshingen |
+| Tank Battalion                   |  Yes  |  Yes  | Yes(2)|  Yes  | tankbatt |
+| Tank Busters                     |  Yes  |  Yes  |  Yes  |  Yes  | tankbust |
+| Tank Force                       |  Yes  |  Yes  |  Yes  |  Yes  | tankfrce |
+| Tant-R                           |  Yes  |  Yes  |  Yes  |  Yes  | tantr    |
+| Tao Taido                        |  Yes  |  Yes  |  Yes  |   No  | taotaido |
+| Tapper                           |  Yes  |  Yes  |  Yes  |  Yes  | tapper   |
+| Targ                             |  Yes  |  Yes  | Yes(2)|  Yes  | targ     |
+| Target Hits                      |   No  |  Yes  |  Yes  |  Yes  | targeth  |
+| Tattoo Assassins                 |  Yes  |  Yes  |  Yes  |  Yes  | tattass  |
+| Taxi Driver                      |  Yes  |  Yes  |  Yes  |   No  | taxidrvr |
+| Tazz-Mania                       |  Yes  |  Yes  |  Yes  |  Yes  | tazmania |
+| Tecmo Bowl                       |  Yes  |  Yes  |Partial|  Yes  | tbowl    |
+| Tecmo World Cup '90              |  Yes  |  Yes  |Partial|   No  | wc90     |
+| Tecmo World Soccer '96           |  Yes  |  Yes  |  Yes  |  Yes  | tws96    |
+| TeddyBoy Blues                   |  Yes  |  Yes  |  Yes  |  Yes  | teddybb  |
+| Tee'd Off                        |  Yes  |  Yes  |  Yes  |  Yes  | teedoff  |
+| Teenage Mutant Ninja Turtles     |  Yes  |  Yes  |  Yes  |  Yes  | tmnt     |
+| Teenage Mutant Ninja Turtles - Tu|   No  |  Yes  |  Yes  |  Yes  | tmnt2    |
+| Tehkan World Cup                 |  Yes  |  Yes  |  Yes  |  Yes  | tehkanwc |
+| Teki Paki                        |  Yes  |  Yes  |   No  |  Yes  | tekipaki |
+| Tel Jan                          |  Yes  |  Yes  |  Yes  |  Yes  | teljan   |
+| Telephone Mahjong                |  Yes  |  Yes  |  Yes  |  Yes  | telmahjn |
+| Tempest                          |  Yes  |  Yes  |  Yes  |  Yes  | tempest  |
+| Tengai / Sengoku Blade: Sengoku A|  Yes  |  Yes  |  Yes  |  Yes  | tengai   |
+| Terminator 2 - Judgment Day      |  Yes  |  Yes  |  Yes  |  Yes  | term2    |
+| Terra Cresta                     |  Yes  |  Yes  |  Yes  |  Yes  | terracre |
+| Terra Force                      |   No  |  Yes  |  Yes  |  Yes  | terraf   |
+| Tetris                           | No(1) |  Yes  |  Yes  |  Yes  | tetris   |
+| Tetris                           |  Yes  |  Yes  |  Yes  |  Yes  | atetris  |
+| Tetris Plus                      |  Yes  |  Yes  |   No  |  Yes  | tetrisp  |
+| Tetris Plus 2                    |  Yes  |  Yes  |  Yes  |  Yes  | tetrisp2 |
+| Thief                            |  Yes  |  Yes  | Yes(2)|  Yes  | thief    |
+| Thrash Rally                     |  Yes  |  Yes  |  Yes  |  Yes  | trally   |
+| Three Stooges In Brides Is Brides|  Yes  |  Yes  |Partial|  Yes  | 3stooges |
+| Three Wonders                    |  Yes  |  Yes  |  Yes  |  Yes  | 3wonders |
+| Thunder & Lightning              |  Yes  |  Yes  |  Yes  |  Yes  | thunderl |
+| Thunder Cross                    |  Yes  |  Yes  |  Yes  |  Yes  | thunderx |
+| Thunder Cross II                 |  Yes  |  Yes  |  Yes  |  Yes  | thndrx2  |
+| Thunder Dragon                   | No(1) |  Yes  |   No  |  Yes  | tdragon  |
+| Thunder Dragon 2                 |  Yes  |  Yes  |  Yes  |   No  | tdragon2 |
+| Thunder Fox                      |  Yes  |  Yes  |  Yes  |  Yes  | thundfox |
+| Thunder Zone                     |  Yes  |  Yes  |  Yes  |  Yes  | thndzone |
+| ThunderForce AC                  |  Yes  |  Yes  |  Yes  |  Yes  | tfrceac  |
+| ThunderJaws                      |  Yes  |  Yes  |  Yes  |  Yes  | thunderj |
+| Thundercade / Twin Formation     |  Yes  |  Yes  |  Yes  |  Yes  | tndrcade |
+| Tickee Tickats                   |  Yes  |  Yes  |  Yes  |  Yes  | tickee   |
+| Tiger Heli                       |  Yes  |  Yes  |  Yes  |   No  | tigerh   |
+| Tiger Road                       |  Yes  |  Yes  |  Yes  |  Yes  | tigeroad |
+| Timber                           |  Yes  |  Yes  |  Yes  |  Yes  | timber   |
+| Time Killers                     |  Yes  |  Yes  |  Yes  |  Yes  | timekill |
+| Time Limit                       |  Yes  | Close |  Yes  |  Yes  | timelimt |
+| Time Pilot                       |  Yes  |  Yes  |  Yes  |  Yes  | timeplt  |
+| Time Pilot '84                   |  Yes  |  Yes  |  Yes  |  Yes  | tp84     |
+| Time Scanner                     |  Yes  |  Yes  |  Yes  |  Yes  | timscanr |
+| Time Soldiers                    |  Yes  |  Yes  |  Yes  |  Yes  | timesold |
+| Time Tunnel                      |  Yes  |  Yes  |  Yes  |  Yes  | timetunl |
+| Tin Star, The                    |  Yes  |  Yes  |  Yes  |  Yes  | tinstar  |
+| Tinkle Pit                       |  Yes  |  Yes  |Partial|  Yes  | tinklpit |
+| Toffy                            |  Yes  |  Yes  |  Yes  |  Yes  | toffy    |
+| Toggle                           |  Yes  |  Yes  |  Yes  |  Yes  | toggle   |
+| Toki                             |  Yes  |  Yes  |  Yes  |  Yes  | toki     |
+| Toki no Senshi - Chrono Soldier  |  Yes  |  Yes  |  Yes  |   No  | tokisens |
+| Tokimeki Memorial Taisen Puzzle-d|  Yes  |  Yes  |  Yes  |  Yes  | tkmmpzdm |
+| Tokio / Scramble Formation       | No(1) |  Yes  |  Yes  |  Yes  | tokio    |
+| Tokoro San no MahMahjan          |  Yes  |  Yes  |  Yes  |  Yes  | mahmajn  |
+| Tokoro San no MahMahjan 2        |  Yes  |  Yes  |  Yes  |  Yes  | mahmajn2 |
+| Tokyo Gal Zukan                  |  Yes  |  Yes  |  Yes  |  Yes  | tokyogal |
+| Tomahawk 777                     |  Yes  |  Yes  |   No  |  Yes  | tomahawk |
+| Tonton [BET]                     |  Yes  |  Yes  |  Yes  |  Yes  | tontonb  |
+| Toobin'                          |  Yes  |  Yes  |  Yes  |  Yes  | toobin   |
+| Top Hunter - Roddy & Cathy       |  Yes  |  Yes  |  Yes  |  Yes  | tophuntr |
+| Top Player's Golf                |  Yes  |  Yes  |  Yes  |  Yes  | tpgolf   |
+| Top Ranking Stars                |  Yes  |  Yes  |  Yes  |  Yes  | trstar   |
+| Top Secret                       |  Yes  |  Yes  |  Yes  |  Yes  | topsecex |
+| Top Speed                        |  Yes  |  Yes  |  Yes  |  Yes  | topspeed |
+| Toride II Adauchi Gaiden         |  Yes  |  Yes  |   No  |  Yes  | toride2g |
+| Tornado Baseball                 |  Yes  |  Yes  |   No  |  Yes  | tornbase |
+| Toryumon                         |  Yes  |  Yes  |  Yes  |  Yes  | toryumon |
+| Total Carnage                    |  Yes  |  Yes  |  Yes  |  Yes  | totcarn  |
+| TouchDown Fever                  |  Yes  |  Yes  |  Yes  |   No  | tdfever  |
+| Tough Turf                       |  Yes  |  Yes  |   No  |  Yes  | tturf    |
+| Tournament Table                 |  Yes  |  Yes  |  Yes  |  Yes  | tourtabl |
+| Tower of Druaga                  |  Yes  |  Yes  |  Yes  |  Yes  | todruaga |
+| Toypop                           |  Yes  |  Yes  |  Yes  |  Yes  | toypop   |
+| Track & Field                    |  Yes  |  Yes  |  Yes  |  Yes  | trackfld |
+| Tranquilizer Gun                 |  Yes  |  Yes  |   No  |  Yes  | tranqgun |
+| Transformer                      |  Yes  |  Yes  |  Yes  |  Yes  | transfrm |
+| Traverse USA / Zippy Race        |  Yes  |  Yes  |  Yes  |  Yes  | travrusa |
+| Tri-Pool                         |  Yes  |  Yes  |  Yes  |  Yes  | tripool  |
+| Tri-Sports                       |  Yes  |  Yes  |  Yes  |  Yes  | trisport |
+| Trick Trap                       |  Yes  |  Yes  |  Yes  |  Yes  | tricktrp |
+| Tricky Doc                       |  Yes  |  Yes  |  Yes  |  Yes  | trckydoc |
+| Trio The Punch - Never Forget Me.|  Yes  |  Yes  |  Yes  |  Yes  | triothep |
+| Triple Hunt                      |  Yes  |  Yes  |   No  |  Yes  | triplhnt |
+| Triple Punch                     |  Yes  |  Yes  |  Yes  |  Yes  | triplep  |
+| Triv Quiz                        |  Yes  |   No  |  Yes  |  Yes  | trivquiz |
+| Trivial Pursuit                  |  Yes  |  Yes  |  Yes  |  Yes  | triviag2 |
+| Trivial Pursuit                  |  Yes  |  Yes  |  Yes  |  Yes  | triviasp |
+| Trivial Pursuit                  |  Yes  |  Yes  |  Yes  |  Yes  | triviag1 |
+| Trivial Pursuit                  |  Yes  |  Yes  |  Yes  |  Yes  | triviabb |
+| Trivial Pursuit                  |  Yes  |  Yes  |  Yes  |  Yes  | triviayp |
+| Trog                             |  Yes  |  Yes  |  Yes  |  Yes  | trog     |
+| Trojan                           |  Yes  |  Yes  |  Yes  |  Yes  | trojan   |
+| Tron                             |  Yes  |  Yes  |  Yes  |  Yes  | tron     |
+| Tropical Angel                   |  Yes  |  Yes  |  Yes  |  Yes  | troangel |
+| Truco-Tron                       |  Yes  |  Yes  |   No  |  Yes  | truco    |
+| Truxton / Tatsujin               |  Yes  |  Yes  |  Yes  |  Yes  | truxton  |
+| Truxton II / Tatsujin II / Tatsuj|  Yes  |  Yes  |  Yes  |  Yes  | truxton2 |
+| Tube Panic                       |  Yes  |  Yes  |  Yes  |  Yes  | tubep    |
+| Tugboat                          |  Yes  |  Yes  |  Yes  |  Yes  | tugboat  |
+| Tumble Pop                       |  Yes  |  Yes  |  Yes  |  Yes  | tumblep  |
+| Tunnel Hunt                      |  Yes  |  Yes  |  Yes  |  Yes  | tunhunt  |
+| Turbo                            |  Yes  |  Yes  | Yes(2)|   No  | turbo    |
+| Turbo Force                      |  Yes  |  Yes  |  Yes  |   No  | turbofrc |
+| Turbo Tag                        |  Yes  |  Yes  |   No  |  Yes  | turbotag |
+| Turkey Shoot                     |  Yes  |  Yes  |  Yes  |  Yes  | tshoot   |
+| Turtle Ship                      |  Yes  |  Yes  |  Yes  |  Yes  | turtship |
+| Turtles                          |  Yes  |  Yes  |  Yes  |  Yes  | turtles  |
+| Tutankham                        |  Yes  |  Yes  |  Yes  |  Yes  | tutankhm |
+| Twin Bee Yahhoo!                 |  Yes  |  Yes  |  Yes  |  Yes  | tbyahhoo |
+| Twin Cobra                       |  Yes  |  Yes  |  Yes  |  Yes  | twincobr |
+| Twin Eagle - Revenge Joe's Brothe|  Yes  |  Yes  |  Yes  |  Yes  | twineagl |
+| Twin Eagle II - The Rescue Missio|   No  |  Yes  |  Yes  |   No  | twineag2 |
+| Twin Hawk                        |  Yes  |  Yes  |  Yes  |  Yes  | twinhawk |
+| Twin Qix                         |  Yes  |  Yes  |  Yes  |  Yes  | twinqix  |
+| TwinBee                          |  Yes  |  Yes  |  Yes  |  Yes  | twinbee  |
+| Twinkle Star Sprites             |  Yes  |  Yes  |  Yes  |  Yes  | twinspri |
+| Two Tigers                       |  Yes  |  Yes  |  Yes  |  Yes  | twotiger |
+| U.N. Defense Force: Earth Joker  |  Yes  |  Yes  |  Yes  |  Yes  | earthjkr |
+| U.N. Squadron                    |  Yes  |  Yes  |  Yes  |  Yes  | unsquad  |
+| U.S. Championship V'ball         |  Yes  |  Yes  |  Yes  |  Yes  | vball    |
+| U.S. Classic                     |  Yes  |   No  |  Yes  |  Yes  | usclssic |
+| US AAF Mustang                   |   No  |  Yes  |   No  |  Yes  | mustang  |
+| Ultimate 11 - The SNK Football Ch|  Yes  |  Yes  |  Yes  |  Yes  | ssideki4 |
+| Ultimate Tennis                  |  Yes  |  Yes  |  Yes  |  Yes  | ultennis |
+| Ultra Balloon                    |  Yes  |  Yes  |  Yes  |  Yes  | uballoon |
+| Ultra Maru-hi Mahjong            |  Yes  |  Yes  |  Yes  |  Yes  | ultramhm |
+| Ultra Tank                       |  Yes  |  Yes  |  Yes  |  Yes  | ultratnk |
+| Ultra Toukon Densetsu            |  Yes  |  Yes  |  Yes  |  Yes  | utoukond |
+| Ultra X Weapons / Ultra Keibitai |  Yes  |  Yes  |  Yes  |   No  | ultrax   |
+| Ultraman                         |  Yes  |  Yes  |  Yes  |  Yes  | ultraman |
+| Ultraman Club - Tatakae! Ultraman|  Yes  |  Yes  |  Yes  |  Yes  | umanclub |
+| Under Fire                       |  Yes  |  Yes  |  Yes  |  Yes  | undrfire |
+| Undercover Cops                  |  Yes  |  Yes  |  Yes  |  Yes  | uccops   |
+| UniWar S                         |  Yes  |  Yes  |  Yes  |  Yes  | uniwars  |
+| Untitled Fighter 'BB'            |  Yes  |  Yes  |   No  |  Yes  | bbprot   |
+| Untouchable                      |  Yes  |  Yes  |  Yes  |  Yes  | untoucha |
+| Uo Poko                          |  Yes  |  Yes  |  Yes  |  Yes  | uopoko   |
+| Up'n Down                        |  Yes  |  Yes  |  Yes  |  Yes  | upndown  |
+| Us vs. Them                      |   No  |  Yes  |  Yes  |  Yes  | usvsthem |
+| V-Five                           |  Yes  |  Yes  |   No  |  Yes  | vfive    |
+| VS Block Breaker                 |  Yes  |  Yes  |  Yes  |  Yes  | vblokbrk |
+| VS Gong Fight                    |  Yes  | Close |  Yes  |  Yes  | vsgongf  |
+| Valkyrie No Densetsu             |  Yes  |  Yes  |  Yes  |  Yes  | valkyrie |
+| Valtric                          |  Yes  |  Yes  |  Yes  |  Yes  | valtric  |
+| Vampire Hunter 2: Darkstalkers Re| No(1) |  Yes  |  Yes  |  Yes  | vhunt2   |
+| Vampire Savior 2: The Lord of Vam|  Yes  |  Yes  |  Yes  |  Yes  | vsav2    |
+| Vampire Savior: The Lord of Vampi|  Yes  |  Yes  |  Yes  |  Yes  | vsav     |
+| Van-Van Car                      |  Yes  |  Yes  |  Yes  |  Yes  | vanvan   |
+| Vandyke                          |  Yes  |  Yes  |   No  |  Yes  | vandyke  |
+| Vanguard                         |  Yes  |  Yes  |Part(2)|  Yes  | vanguard |
+| Vanguard II                      |  Yes  |  Yes  |  Yes  |   No  | vangrd2  |
+| Vapor Trail - Hyper Offence Forma|  Yes  |  Yes  |  Yes  |  Yes  | vaportra |
+| Varth - Operation Thunderstorm   |  Yes  |  Yes  |  Yes  |  Yes  | varth    |
+| Vasara                           |  Yes  |  Yes  |  Yes  |   No  | vasara   |
+| Vastar                           |  Yes  |  Yes  |  Yes  |  Yes  | vastar   |
+| Vendetta                         |  Yes  |  Yes  |  Yes  |  Yes  | vendetta |
+| Venture                          |  Yes  |  Yes  |  Yes  |  Yes  | venture  |
+| Vicious Circle                   |  Yes  |  Yes  |  Yes  |  Yes  | vcircle  |
+| Victory                          |  Yes  |  Yes  |  Yes  |  Yes  | victory  |
+| Victory Road                     |  Yes  |  Yes  |  Yes  |   No  | victroad |
+| Video Eight Ball                 |  Yes  |  Yes  |Partial|   No  | 8ball    |
+| Video Hustler                    |  Yes  |  Yes  |  Yes  |  Yes  | hustler  |
+| Video Pinball                    |   No  |  Yes  |   No  |  Yes  | videopin |
+| Viewpoint                        |  Yes  |  Yes  |  Yes  |  Yes  | viewpoin |
+| Vigilante                        |  Yes  |  Yes  |  Yes  |   No  | vigilant |
+| Vimana                           |  Yes  |  Yes  |   No  |  Yes  | vimana   |
+| Vindicators                      |  Yes  |  Yes  |  Yes  |  Yes  | vindictr |
+| Vindicators Part II              |  Yes  |  Yes  |  Yes  |  Yes  | vindctr2 |
+| Violence Fight                   |  Yes  |  Yes  |  Yes  |  Yes  | viofight |
+| Violent Storm                    |  Yes  |  Yes  |  Yes  |  Yes  | viostorm |
+| Viper                            |  Yes  |  Yes  |  Yes  |  Yes  | viper    |
+| Volfied                          |   No  |  Yes  |  Yes  |  Yes  | volfied  |
+| Voltage Fighter - Gowcaizer / Cho|  Yes  |  Yes  |  Yes  |  Yes  | gowcaizr |
+| Vs. Atari R.B.I. Baseball        |  Yes  |  Yes  |  Yes  |  Yes  | rbibb    |
+| Vs. Balloon Fight                |  Yes  |  Yes  |  Yes  |  Yes  | balonfgt |
+| Vs. BaseBall                     |  Yes  |  Yes  |  Yes  |  Yes  | vsbball  |
+| Vs. Battle City                  |  Yes  |  Yes  |  Yes  |  Yes  | btlecity |
+| Vs. Castlevania                  |  Yes  |  Yes  |  Yes  |  Yes  | cstlevna |
+| Vs. Clu Clu Land                 |  Yes  |  Yes  |  Yes  |  Yes  | cluclu   |
+| Vs. Dr. Mario                    |  Yes  |  Yes  |  Yes  |  Yes  | drmario  |
+| Vs. Duck Hunt                    |  Yes  |  Yes  |  Yes  |  Yes  | duckhunt |
+| Vs. Excitebike                   |  Yes  |  Yes  |  Yes  |  Yes  | excitebk |
+| Vs. Gradius                      |  Yes  |  Yes  |  Yes  |  Yes  | vsgradus |
+| Vs. Gumshoe                      |  Yes  |  Yes  |  Yes  |  Yes  | vsgshoe  |
+| Vs. Hogan's Alley                |  Yes  |  Yes  |  Yes  |  Yes  | hogalley |
+| Vs. Ice Climber                  |  Yes  |  Yes  |  Yes  |  Yes  | iceclimb |
+| Vs. Ice Climber Dual             |  Yes  |  Yes  |  Yes  |  Yes  | iceclmrj |
+| Vs. Mach Rider                   |  Yes  |  Yes  |  Yes  |  Yes  | machridr |
+| Vs. Mahjang                      |  Yes  |  Yes  |  Yes  |  Yes  | vsmahjng |
+| Vs. Mighty Bomb Jack             |  Yes  |  Yes  |  Yes  |  Yes  | mightybj |
+| Vs. Ninja Jajamaru Kun           |  Yes  |  Yes  |  Yes  |  Yes  | jajamaru |
+| Vs. Pinball                      |  Yes  |  Yes  |  Yes  |  Yes  | vspinbal |
+| Vs. Platoon                      |  Yes  |   No  |  Yes  |  Yes  | platoon  |
+| Vs. Raid on Bungeling Bay        |  Yes  |  Yes  |  Yes  |  Yes  | bnglngby |
+| Vs. Slalom                       |  Yes  |  Yes  |  Yes  |  Yes  | vsslalom |
+| Vs. Soccer                       |  Yes  |  Yes  |  Yes  |  Yes  | vssoccer |
+| Vs. Star Luster                  |  Yes  |  Yes  |  Yes  |  Yes  | starlstr |
+| Vs. Stroke and Match Golf        |  Yes  |  Yes  |  Yes  |  Yes  | smgolf   |
+| Vs. Stroke and Match Golf        |  Yes  |  Yes  |  Yes  |  Yes  | ladygolf |
+| Vs. Super Mario Bros.            |  Yes  |  Yes  |  Yes  |  Yes  | suprmrio |
+| Vs. Super SkyKid                 |  Yes  |  Yes  |  Yes  |  Yes  | vsskykid |
+| Vs. TKO Boxing                   |  Yes  |   No  |  Yes  |  Yes  | tkoboxng |
+| Vs. Tennis                       |  Yes  |  Yes  |  Yes  |  Yes  | vstennis |
+| Vs. Tetris                       |  Yes  | Close |  Yes  |  Yes  | vstetris |
+| Vs. The Goonies                  |  Yes  |  Yes  |  Yes  |  Yes  | goonies  |
+| Vs. Top Gun                      |  Yes  |  Yes  |  Yes  |  Yes  | topgun   |
+| Vs. Wrecking Crew                |  Yes  |  Yes  |  Yes  |  Yes  | wrecking |
+| Vulcan Venture                   |  Yes  |  Yes  |  Yes  |  Yes  | vulcan   |
+| Vulgus                           |  Yes  |  Yes  |  Yes  |  Yes  | vulgus   |
+| WEC Le Mans 24                   |  Yes  |  Yes  |  Yes  |  Yes  | wecleman |
+| WWF Superstars                   |  Yes  |  Yes  |  Yes  |  Yes  | wwfsstar |
+| WWF WrestleFest                  |  Yes  |  Yes  |  Yes  |  Yes  | wwfwfest |
+| WWF: Wrestlemania                |  Yes  |  Yes  |  Yes  |  Yes  | wwfmania |
+| Wacko                            |  Yes  |  Yes  |  Yes  |  Yes  | wacko    |
+| Wai Wai Jockey Gate-In!          |  Yes  |  Yes  |  Yes  |  Yes  | wwjgtin  |
+| Wakakusamonogatari Mahjong Yonshi|  Yes  |  Yes  |  Yes  |   No  | mj4simai |
+| Waku Waku 7                      |  Yes  |  Yes  |  Yes  |  Yes  | wakuwak7 |
+| Wall Crash                       |  Yes  |  Yes  |  Yes  |  Yes  | wallc    |
+| Wall Street                      |  Yes  |  Yes  |Partial|   No  | wallst   |
+| Wanted                           |  Yes  |  Yes  |  Yes  |  Yes  | wanted   |
+| War Gods                         |  Yes  |  Yes  |Partial|  Yes  | wargods  |
+| War of Aero - Project MEIOU      |  Yes  |  Yes  |  Yes  |  Yes  | wrofaero |
+| War of the Bugs or Monsterous Man|  Yes  |  Yes  |  Yes  |  Yes  | warofbug |
+| War of the Worlds                |  Yes  | Close |   No  |  Yes  | wotw     |
+| Wardner                          |  Yes  |  Yes  |  Yes  |  Yes  | wardner  |
+| Warlords                         |  Yes  |  Yes  |  Yes  |  Yes  | warlords |
+| Warp & Warp                      |  Yes  |  Yes  |  Yes  |  Yes  | warpwarp |
+| Warrior                          |  Yes  |  Yes  | Yes(2)|  Yes  | warrior  |
+| Warrior Blade - Rastan Saga Episo|  Yes  |  Yes  |  Yes  |  Yes  | warriorb |
+| Warriors of Fate                 |  Yes  |  Yes  |  Yes  |  Yes  | wof      |
+| Watashiha Suzumechan             |   No  |  Yes  |  Yes  |  Yes  | suzume   |
+| Water Match                      |  Yes  |  Yes  |  Yes  |  Yes  | wmatch   |
+| Water Ski                        |  Yes  |  Yes  |  Yes  |  Yes  | waterski |
+| Welltris                         |  Yes  |  Yes  |  Yes  |   No  | welltris |
+| Wheel Of Fortune                 |  Yes  |  Yes  |  Yes  |  Yes  | wfortune |
+| Who Dunit                        |  Yes  |  Yes  |  Yes  |  Yes  | whodunit |
+| Wild Fang / Tecmo Knight         |  Yes  |  Yes  |  Yes  |  Yes  | wildfang |
+| Wild West C.O.W.-Boys of Moo Mesa|  Yes  |  Yes  |  Yes  |  Yes  | moo      |
+| Wild Western                     |  Yes  |  Yes  |  Yes  |  Yes  | wwestern |
+| Willow                           |  Yes  |  Yes  |  Yes  |  Yes  | willow   |
+| Wily Tower                       |  Yes  |  Yes  |   No  |  Yes  | wilytowr |
+| Windjammers / Flying Power Disc  |  Yes  |  Yes  |  Yes  |  Yes  | wjammers |
+| Wiping                           |  Yes  |  Yes  |  Yes  |  Yes  | wiping   |
+| Wit's                            |  Yes  |  Yes  |  Yes  |  Yes  | wits     |
+| Wiz                              |  Yes  |  Yes  |  Yes  |  Yes  | wiz      |
+| Wizard Fire                      |  Yes  |  Yes  |  Yes  |  Yes  | wizdfire |
+| Wizard of Wor                    |  Yes  |  Yes  | Yes(2)|  Yes  | wow      |
+| Wolf Pack                        |  Yes  |  Yes  |   No  |  Yes  | wolfpack |
+| Wonder Boy                       |  Yes  |  Yes  |  Yes  |  Yes  | wboy     |
+| Wonder Boy III - Monster Lair    |  Yes  |  Yes  |  Yes  |  Yes  | wb3      |
+| Wonder Boy in Monster Land       | No(1) |  Yes  |  Yes  |   No  | wbml     |
+| Wonder Momo                      |  Yes  |  Yes  |  Yes  |  Yes  | wndrmomo |
+| Wonder Planet                    |  Yes  |  Yes  |  Yes  |  Yes  | wndrplnt |
+| World Beach Volley               |  Yes  |  Yes  |   No  |   No  | wbeachvl |
+| World Class Bowling              |  Yes  |  Yes  |  Yes  |  Yes  | wcbowl   |
+| World Court                      |  Yes  |  Yes  |  Yes  |  Yes  | wldcourt |
+| World Grand Prix                 |  Yes  |  Yes  |  Yes  |  Yes  | wgp      |
+| World Heroes                     |  Yes  |  Yes  |  Yes  |  Yes  | wh1      |
+| World Heroes 2                   |  Yes  |  Yes  |  Yes  |  Yes  | wh2      |
+| World Heroes 2 Jet               |  Yes  |  Yes  |  Yes  |  Yes  | wh2j     |
+| World Heroes Perfect             |  Yes  |  Yes  |  Yes  |  Yes  | whp      |
+| World Rally 2: Twin Racing       |   No  |  Yes  |  Yes  |  Yes  | wrally2  |
+| World Series: The Season         |  Yes  |  Yes  |  Yes  |  Yes  | wseries  |
+| World Soccer Finals              |  Yes  |  Yes  |  Yes  |  Yes  | wsf      |
+| World Stadium                    |  Yes  |  Yes  |  Yes  |  Yes  | ws       |
+| World Tennis                     |  Yes  |  Yes  |  Yes  |  Yes  | wtennis  |
+| Wrestle War                      |  Yes  |  Yes  |  Yes  |  Yes  | wrestwar |
+| X Multiply                       |  Yes  |  Yes  |  Yes  |   No  | xmultipl |
+| X-Men                            |  Yes  |  Yes  |  Yes  |  Yes  | xmen     |
+| X-Men Vs. Street Fighter         |  Yes  |  Yes  |  Yes  |  Yes  | xmvsf    |
+| X-Men: Children of the Atom      |  Yes  |  Yes  |  Yes  |  Yes  | xmcota   |
+| XX Mission                       |  Yes  |  Yes  |  Yes  |  Yes  | xxmissio |
+| Xain'd Sleena                    |  Yes  |  Yes  |  Yes  |  Yes  | xsleena  |
+| Xenophobe                        |  Yes  |  Yes  |  Yes  |  Yes  | xenophob |
+| Xevious                          |  Yes  |  Yes  | Yes(2)|  Yes  | xevious  |
+| Xexex                            |  Yes  |  Yes  |  Yes  |  Yes  | xexex    |
+| Xor World                        |  Yes  |  Yes  |  Yes  |  Yes  | xorworld |
+| Xybots                           |  Yes  |  Yes  |  Yes  |  Yes  | xybots   |
+| Xyonix                           |  Yes  |  Yes  |  Yes  |  Yes  | xyonix   |
+| Yam! Yam!?                       |  Yes  |  Yes  |  Yes  |  Yes  | yamyam   |
+| Yamato                           |  Yes  |  Yes  |  Yes  |  Yes  | yamato   |
+| Yes/No Sinri Tokimeki Chart      |  Yes  |  Yes  |  Yes  |  Yes  | yesnoj   |
+| Yie Ar Kung-Fu                   |  Yes  |  Yes  |  Yes  |  Yes  | yiear    |
+| Yosaku To Donbee                 |  Yes  |  Yes  |   No  |  Yes  | yosakdon |
+| Youjyuden                        |  Yes  |  Yes  |  Yes  |  Yes  | youjyudn |
+| Yuuyu no Quiz de GO!GO!          |  Yes  |  Yes  |  Yes  |  Yes  | yuyugogo |
+| Zarya Vostoka                    |   No  |  Yes  |  Yes  |  Yes  | zaryavos |
+| Zaviga                           |  Yes  |  Yes  |  Yes  |  Yes  | zaviga   |
+| Zaxxon                           |  Yes  |  Yes  | Yes(2)|  Yes  | zaxxon   |
+| Zed Blade / Operation Ragnarok   |  Yes  |  Yes  |  Yes  |  Yes  | zedblade |
+| Zektor                           |  Yes  |  Yes  | Yes(2)|  Yes  | zektor   |
+| Zero Hour                        |  Yes  |   No  |   No  |  Yes  | zerohour |
+| Zero Point                       |  Yes  |  Yes  |  Yes  |  Yes  | zeropnt  |
+| Zero Point 2                     |  Yes  |  Yes  |  Yes  |  Yes  | zeropnt2 |
+| Zero Wing                        |  Yes  |  Yes  |  Yes  |  Yes  | zerowing |
+| Zero Zone                        |  Yes  |  Yes  |  Yes  |  Yes  | zerozone |
+| Zhong Guo Long II                |  Yes  |  Yes  |   No  |  Yes  | dragwld2 |
+| Zig Zag                          |  Yes  |  Yes  |  Yes  |  Yes  | zigzag   |
+| Zing Zing Zip                    |  Yes  |  Yes  |  Yes  |  Yes  | zingzip  |
+| Zoar                             |  Yes  |  Yes  |  Yes  |  Yes  | zoar     |
+| Zodiack                          |  Yes  | Close |  Yes  |  Yes  | zodiack  |
+| Zombie Raid                      |  Yes  |  Yes  |  Yes  |   No  | zombraid |
+| Zoo Keeper                       |  Yes  |  Yes  |  Yes  |  Yes  | zookeep  |
+| Zunzunkyou No Yabou              |  Yes  |  Yes  |  Yes  |  Yes  | zunkyou  |
+| Zwackery                         |  Yes  |  Yes  |  Yes  |  Yes  | zwackery |
+| Zzyzzyxx                         |  Yes  |  Yes  |  Yes  |  Yes  | zzyzzyxx |
++----------------------------------+-------+-------+-------+-------+----------+
+
+(1) There are variants of the game (usually bootlegs) that work correctly
+(2) Needs samples provided separately
diff --git a/src/unix/doc/mame/listinfo.txt b/src/unix/doc/mame/listinfo.txt
new file mode 100644
index 0000000..0330a4e
--- /dev/null
+++ b/src/unix/doc/mame/listinfo.txt
@@ -0,0 +1,484 @@
+Description of the -listinfo output
+-----------------------------------
+
+Grammar
+-------
+	start -> ENTRY*
+	ENTRY -> ENTRYNAME ENTRYVALUE
+	ENTRYNAME -> SYMBOL
+	ENTRYVALUE -> SYMBOL | STRING | ENTRYLIST
+	ENTRYLIST -> '(' ENTRY* ')'
+	SYMBOL -> any char except separator, '"', '(', ')'
+	STRING -> default C string in double quote ""
+
+Any space (specifically any char that the C function ispace() tells is a
+space) is considered a separator and must be ignored.
+
+
+Semantic
+--------
+game (...)
+Definition of a game emulated.
+
+resource (...)
+Definition of a resource. For example the NeoGeo BIOS rom 'neogeo'.
+
+
+Entries common for 'game' and 'resource'
+----------------------------------------
+name NAME
+Name of the game or resource. This is the only required item.
+The specified NAME is unique in all file.
+
+description DESCRIPTION
+Generic description.
+
+manufacturer MANUFACTURER
+Manufacturer of the game or resource.
+
+year YEAR
+Year of the game or resource.
+
+romof NAME
+The game or resource use rom of another game or resource named NAME.
+[Equal to cloneof entry in GameDriver specification.]
+
+sampleof NAME
+The game or resource use sample of another game or resource named NAME.
+[Is the first element with starting * in the samplenames array.]
+
+rom '(' name NAME size SIZE crc CRC ')'
+Rom specification his name, size and crc.
+
+sample NAME
+Sample specification.
+
+
+Entries specific for 'game'
+---------------------------
+cloneof NAME
+Clone-of relathionship. This is intended to express an abstract
+clone-of relathionship. It's equal to the cloneof entry in gamedriver
+specification with the exception of the special NOT_DRIVER games
+(neogeo, cvs, decocass, playch10).
+
+chip '(' ... ')'
+List of hardware chips used by the game. A MAME cpu used ONLY for sound
+has the 'flags audio'.
+
+video '(' ... ')'
+Informations of the game video hardware.
+
+input '(' ... ')'
+Informations of the game input hardware.
+
+driver '(' status (preliminary | good) color (preliminary | imperfect | good)
+  hiscore (preliminary | good) ... ')'
+Informations of the MAME driver status and requirements.
+
+sound '(' ... ')'
+Number of the sound channels.
+
+
+How to read the file
+--------------------
+If you need to read the output of -listinfo option you must take care
+of these issues:
+
+1) You can't do any assumption of space indentation.
+2) You can't do any assumption of max line length. All output can be
+   in a very long line.
+3) You can't do any assumption of order of the entries.
+4) You can't do any assumption of the presence of any entry except the
+   game.name and resource.name which are mandatory and unique.
+5) You must ignore any entry unknow.
+6) Spaces are required only for separing SYMBOLs.
+7) Lists of entry empty are valid.
+
+For example:
+
+	game(description"Pac Man (Midway)"unknowentry()name pacman rom(size 4096 name pacman.6e crc c1e6ab10))
+
+is a valid output.
+
+Example
+-------
+This is a complete module for reading info files.
+
+info.h Library header
+info.c Library module
+test.c Example of use
+
+-- info.h --------------------------------------------------------------------
+#ifndef __INFO_H
+#define __INFO_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <stdio.h>
+
+enum info_t {
+	info_error,      /* generic error in reading */
+	info_eof,        /* end of file got at valid position */
+	info_symbol,     /* symbol */
+	info_open,       /* ( */
+	info_close,      /* ) */
+	info_string      /* c string automatically converted */
+};
+
+const char* info_text_get(void);
+enum info_t info_token_get(FILE* f);
+enum info_t info_skip_value(FILE* f);
+
+void info_init(void);
+void info_done(void);
+unsigned info_row_get(void);
+unsigned info_col_get(void);
+unsigned info_pos_get(void);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
+------------------------------------------------------------------------------
+
+-- info.c --------------------------------------------------------------------
+#include "info.h"
+
+#include <ctype.h>
+#include <string.h>
+#include <malloc.h>
+#include <assert.h>
+
+/* Start size of buffer */
+#define INFO_BUF_MIN 64
+
+/* Buffer used for storing last token */
+static unsigned info_buf_mac = 0;
+static unsigned info_buf_max = 0;
+static char* info_buf_map = 0;
+
+/* Position in the stream */
+static unsigned info_pos = 0; /* Char */
+static unsigned info_row = 0; /* Row */
+static unsigned info_col = 0; /* Column */
+
+/* Init */
+void info_init(void) {
+	assert(!info_buf_map);
+
+	info_buf_max = 0;
+	info_buf_map = 0;
+	info_pos = 0;
+	info_row = 0;
+	info_col = 0;
+}
+
+/* Done */
+void info_done(void) {
+	free(info_buf_map);
+	info_buf_map = 0;
+}
+
+/* Get information of file position */
+unsigned info_row_get(void) {
+	return info_row;
+}
+
+unsigned info_col_get(void) {
+	return info_col;
+}
+
+unsigned info_pos_get(void) {
+	return info_pos;
+}
+
+/* Resize the buffer */
+static void info_buf_resize(unsigned size) {
+	if (!info_buf_max)
+		info_buf_max = INFO_BUF_MIN;
+	else
+		info_buf_max *= 2;
+	if (size > info_buf_max)
+		info_buf_max = size;
+	info_buf_map = realloc(info_buf_map, info_buf_max );
+	assert( info_buf_map );
+}
+
+/* Add a char to the buffer end */
+static inline void info_buf_add(char c) {
+	if (info_buf_mac >= info_buf_max)
+		info_buf_resize(info_buf_mac + 1);
+	info_buf_map[info_buf_mac++] = c;
+}
+
+/* Reset the buffer */
+static void info_buf_reset() {
+	info_buf_mac = 0;
+}
+
+/* Return last token text */
+const char* info_text_get(void) {
+	/* ensure the buffer end with zero */
+	if (info_buf_mac==0 || info_buf_map[info_buf_mac-1]!=0)
+		info_buf_add(0);
+	return info_buf_map;
+}
+
+/* Read a char from file */
+static int info_getc(FILE* f) {
+	int c = fgetc(f);
+	switch (c) {
+		case EOF:
+			break;
+		case '\n':
+			info_col = 0;
+			++info_row;
+			++info_pos;
+			break;
+		default:
+			++info_col;
+			++info_pos;
+			break;
+	}
+	return c;
+}
+
+/* Unget a char from file */
+static void info_ungetc(int c, FILE* f) {
+	--info_pos;
+	--info_col;
+	ungetc(c,f);
+}
+
+static enum info_t get_symbol(FILE* f,int c) {
+	while (c!=EOF && !isspace(c) && c!='(' && c!=')' && c!='\"') {
+		info_buf_add(c);
+		c = info_getc(f);
+	}
+	/* no reason to unget space or EOF */
+	if (c!=EOF && !isspace(c))
+		info_ungetc(c,f);
+	return info_symbol;
+}
+
+static unsigned hexdigit(char c) {
+	if (isdigit(c))
+		return c - '0';
+	return toupper(c) - 'A' + 10;
+}
+
+static enum info_t get_string(FILE* f) {
+	int c = info_getc(f);
+	while (c!=EOF && c!='\"') {
+		if (c=='\\') {
+			c = info_getc(f);
+			switch (c) {
+				case 'a' : info_buf_add('\a'); break;
+				case 'b' : info_buf_add('\b'); break;
+				case 'f' : info_buf_add('\f'); break;
+				case 'n' : info_buf_add('\n'); break;
+				case 'r' : info_buf_add('\r'); break;
+				case 't' : info_buf_add('\t'); break;
+				case 'v' : info_buf_add('\v'); break;
+				case '\\' : info_buf_add('\\'); break;
+				case '?' : info_buf_add('\?'); break;
+				case '\'' : info_buf_add('\''); break;
+				case '\"' : info_buf_add('\"'); break;
+				case 'x' : {
+					int d0,d1;
+					unsigned char cc;
+					d0 = info_getc(f);
+					if (!isxdigit(d0))
+						return info_error;
+					d1 = info_getc(f);
+					if (!isxdigit(d1))
+						return info_error;
+					cc = hexdigit(d0) * 16 + hexdigit(d1);
+					info_buf_add(cc);
+				}
+				break;
+				default:
+					return info_error;
+			}
+		} else {
+			info_buf_add(c);
+		}
+		c = info_getc(f);
+	}
+	if (c!='\"')
+		return info_error;
+	return info_string;
+}
+
+/* Extract a token */
+enum info_t info_token_get(FILE* f) {
+	int c = info_getc(f);
+	/* reset the buffer */
+	info_buf_reset();
+	/* skip space */
+	while (c!=EOF && isspace(c)) {
+		c = info_getc(f);
+	}
+	/* get token */
+	switch (c) {
+		case EOF:
+			return info_eof;
+		case '(':
+			return info_open;
+		case ')':
+			return info_close;
+		case '\"':
+			return get_string(f);
+		default:
+			return get_symbol(f,c);
+	}
+}
+
+/* Skip a value token
+ * note:
+ *   Skip recusively any info_open and info_close
+ * return:
+ *   info_error error
+ *   otherwise last token skipped
+ */
+enum info_t info_skip_value(FILE* f) {
+	/* read value token */
+	enum info_t t = info_token_get(f);
+	switch (t) {
+		case info_open:
+			t = info_token_get(f);
+			if (t==info_error)
+				return info_error;
+			while (t!=info_close) {
+				/* first read type as a symbol */
+				if (t!=info_symbol)
+					return info_error;
+				/* second skip the value */
+				t = info_skip_value(f);
+				/* two value required */
+				if (t==info_error)
+					return info_error;
+				/* read next token, a type or a info_close */
+				t = info_token_get(f);
+				if (t==info_error)
+					return info_error;
+			}
+		break;
+		case info_symbol:
+		case info_string:
+		break;
+		default:
+			return info_error;
+	}
+	return t;
+}
+------------------------------------------------------------------------------
+
+-- test.c --------------------------------------------------------------------
+#include "info.h"
+
+#include <stdio.h>
+#include <stdlib.h>
+
+#define true 1
+#define false 0
+
+int info_load(FILE* f) {
+	enum info_t token = info_token_get(f);
+	while (token!=info_eof) {
+		if (token != info_symbol) return false;
+		if (strcmp(info_text_get(),"game")==0) {
+			if (info_token_get(f) != info_open) return false;
+			token =	info_token_get(f);
+			while (token != info_close) {
+				if (token != info_symbol)
+					return false;
+				if (strcmp(info_text_get(),"name")==0) {
+					if (info_token_get(f) != info_symbol) return false;
+					printf("name %s\n", info_text_get() );
+				} else if (strcmp(info_text_get(),"description")==0) {
+					if (info_token_get(f) != info_string) return false;
+					printf("description %s\n", info_text_get() );
+				} else if (strcmp(info_text_get(),"manufacturer")==0) {
+					if (info_token_get(f) != info_string) return false;
+					printf("manufacturer %s\n", info_text_get() );
+				} else if (strcmp(info_text_get(),"year")==0) {
+					if (info_token_get(f) != info_symbol) return false;
+					printf("year %s\n", info_text_get() );
+				} else if (strcmp(info_text_get(),"cloneof")==0) {
+					if (info_token_get(f) != info_symbol) return false;
+					printf("cloneof %s\n", info_text_get() );
+				} else if (strcmp(info_text_get(),"romof")==0) {
+					if (info_token_get(f) != info_symbol) return false;
+					printf("romof %s\n", info_text_get() );
+				} else if (strcmp(info_text_get(),"sampleof")==0) {
+					if (info_token_get(f) != info_symbol) return false;
+					printf("sampleof %s\n", info_text_get() );
+				} else if (strcmp(info_text_get(),"rom")==0) {
+					if (info_token_get(f) != info_open)  return false;
+					token =	info_token_get(f);
+					while (token != info_close) {
+						if (token != info_symbol) return false;
+						if (strcmp(info_text_get(),"name")==0) {
+							if (info_token_get(f) != info_symbol) return false;
+							printf("romname %s\n", info_text_get() );
+						} else if (strcmp(info_text_get(),"size")==0) {
+							if (info_token_get(f) != info_symbol) return false;
+							printf("romsize %s\n", info_text_get() );
+						} else if (strcmp(info_text_get(),"crc")==0) {
+							if (info_token_get(f) != info_symbol) return false;
+							printf("romcrc %s\n", info_text_get() );
+						} else {
+							if (info_skip_value(f) == info_error) return false;
+						}
+						token = info_token_get(f);
+					}
+				} else if (strcmp(info_text_get(),"driver")==0) {
+					if (info_token_get(f) != info_open)  return false;
+					token =	info_token_get(f);
+					while (token != info_close) {
+						if (token != info_symbol) return false;
+						if (strcmp(info_text_get(),"status")==0) {
+							if (info_token_get(f) != info_symbol) return false;
+							printf("driverstatus %s\n", info_text_get() );
+						} else {
+							if (info_skip_value(f) == info_error) return false;
+						}
+						token = info_token_get(f);
+					}
+				} else if (strcmp(info_text_get(),"sample")==0) {
+					if (info_token_get(f) != info_symbol) return false;
+					printf("samplenames %s\n", info_text_get() );
+				} else {
+					if (info_skip_value(f) == info_error) return false;
+				}
+				token = info_token_get(f);
+			}
+		} else {
+			if (info_skip_value(f) == info_error) return false;
+		}
+		token = info_token_get(f);
+	}
+
+	return true;
+}
+
+int main() {
+	info_init();
+
+	if (!info_load(stdin)) {
+		info_done();
+		fprintf(stderr,"Error reading at row %d column %d\n",info_row_get()+1,info_col_get()+1);
+		exit(EXIT_FAILURE);
+	}
+
+	info_done();
+
+	return EXIT_SUCCESS;
+}
+------------------------------------------------------------------------------
+
diff --git a/src/unix/doc/mame/mame.txt b/src/unix/doc/mame/mame.txt
new file mode 100644
index 0000000..75e3d5d
--- /dev/null
+++ b/src/unix/doc/mame/mame.txt
@@ -0,0 +1,188 @@
+
+                 M.A.M.E.  -  Multiple Arcade Machine Emulator
+          Copyright (C) 1997-2003 by Nicola Salmoria and The MAME Team
+
+Many people have helped with this project--directly, or by releasing the source
+code for the drivers they have written. We are not trying to take credit that
+isn't ours. See the Acknowledgments section for a list of contributors. Please
+note, however, that the list is largely incomplete. Also see the comments in
+the source code to see the people who contributed to specific drivers. That
+list, too, may be incomplete. We apologize for any omission.
+
+All trademarks cited in this document are property of their respective owners.
+
+
+For usage instructions, please consult the corresponding readme.
+
+MS-DOS:   msdos.txt
+Windows:  windows.txt
+
+
+Usage and Distribution License
+------------------------------
+
+I. Purpose
+----------
+   MAME is strictly a non-profit project. Its main purpose is to be a reference
+   to the inner workings of the emulated arcade machines. This is done for
+   educational purposes and to prevent many historical games from sinking into
+   oblivion once the hardware they run on stops working. Of course to preserve
+   the games, you must also be able to actually play them; you can consider
+   that a nice side effect.
+   It is not our intention to infringe on any copyrights or patents on the
+   original games. All of MAME's source code is either our own or freely
+   available. To operate, the emulator requires images of the original ROMs
+   from the arcade machines, which must be provided by the user. No portions of
+   the original ROM codes are included in the executable.
+
+II. Cost
+--------
+   MAME is free. Its source code is free. Selling either is not allowed.
+
+III. ROM Images
+---------------
+   ROM images are copyrighted material. Most of them cannot be distributed
+   freely. Distribution of MAME on the same physical medium as illegal copies
+   of ROM images is strictly forbidden.
+   You are not allowed to distribute MAME in any form if you sell, advertise,
+   or publicize CD-ROMs or other media containing illegal copies of ROM images.
+   This restriction applies even if you don't make money, directly or
+   indirectly, from those activities. You are allowed to make ROMs and MAME
+   available for download on the same website, but only if you warn users about
+   the ROMs's copyright status, and make it clear that users must not download
+   ROMs unless they are legally entitled to do so.
+
+IV. Source Code Distribution
+----------------------------
+   If you distribute the binary (compiled) version of MAME, you should also
+   distribute the source code. If you can't do that, you must provide a link
+   to a site where the source can be obtained.
+
+V. Distribution Integrity
+-------------------------
+   This chapter applies to the official MAME distribution. See below for
+   limitations on the distribution of derivative works.
+   MAME must be distributed only in the original archives. You are not allowed
+   to distribute a modified version, nor to remove and/or add files to the
+   archive.
+
+VI. Reuse of Source Code
+--------------------------
+   This chapter might not apply to specific portions of MAME (e.g. CPU
+   emulators) which bear different copyright notices.
+   The source code cannot be used in a commercial product without the written
+   authorization of the authors. Use in non-commercial products is allowed, and
+   indeed encouraged.  If you use portions of the MAME source code in your
+   program, however, you must make the full source code freely available as
+   well.
+   Usage of the _information_ contained in the source code is free for any use.
+   However, given the amount of time and energy it took to collect this
+   information, if you find new information we would appreciate if you made it
+   freely available as well.
+
+VII. Derivative Works
+---------------------
+   Derivative works are allowed, provided their source code is freely
+   available. However, these works are discouraged. MAME is a continuously-
+   -evolving project. It is in your best interests to submit your contributions
+   to the MAME development team, so they may be integrated into the main
+   distribution.
+   There are some specific modifications to the source code which go against
+   the spirit of the project. They are NOT considered a derivative work, and
+   distribution of executables containing them is strictly forbidden. Such
+   modifications include, but are not limited to:
+   - enabling games that are disabled
+   - changing the ROM verification commands so that they report missing games
+   - removing the startup information screens
+   If you make a derivative work, you are not allowed to call it MAME. You must
+   use a different name to make clear that it is a MAME derivative, not an
+   official distribution from the MAME team. Simply calling it MAME followed or
+   preceded by a punctuation mark (e.g. MAME+) is not sufficient. The name must
+   be clearly distinct (e.g. REMAME). The version number must also match the
+   number of the official MAME version from which you derived your version.
+
+
+How to Contact Us
+-----------------
+
+The official MAME homepage is http://www.mame.net/  You can always find the
+latest release there, including beta versions and information on things being
+worked on. Also, a totally legal and free ROM set of Robby Roto is available
+on the same page.
+
+If you have bugs to report, check the MAME Testing Project at
+http://www.mametesters.com
+
+If you can't get the emulator to work, you are on your own. First of all, read
+the docs carefully. If you still can't find an answer to your question, try
+checking the beginner's sections that many emulation pages have, or ask on the
+appropriate Usenet newsgroups (e.g. comp.emulators.misc) or on the official
+MAME message board at http://www.mame.net/msg/
+
+For help in compiling MAME, check these pages:
+http://www.mame.net/compile.html
+http://www.mameworld.net
+
+
+
+Acknowledgments
+---------------
+
+First of all, thanks to Allard van der Bas (avdbas@wi.leidenuniv.nl) for
+starting the Arcade Emulation Programming Repository at
+http://valhalla.ph.tn.tudelft.nl/emul8
+Without the Repository, I would never have even tried to write an emulator.
+Unfortunately, the original Repository is now closed, but its spirit lives
+on in MAME.
+
+Z80 emulator Copyright (c) 1998 Juergen Buchmueller, all rights reserved.
+M6502 emulator Copyright (c) 1998 Juergen Buchmueller, all rights reserved.
+Hu6280 Copyright (c) 1999 Bryan McPhail, mish@tendril.force9.net
+I86 emulator by David Hedley, modified by Fabrice Frances (frances@ensica.fr)
+M6809 emulator by John Butler, based on L.C. Benschop's 6809 Simulator V09.
+M6808 based on L.C. Benschop's 6809 Simulator V09.
+M68000 emulator Copyright 1999 Karl Stenerud.  All rights reserved.
+80x86 M68000 emulator Copyright 1998, Mike Coates, Darren Olafson.
+8039 emulator by Mirko Buffoni, based on 8048 emulator by Dan Boris.
+T-11 emulator Copyright (C) Aaron Giles 1998
+TMS34010 emulator by Alex Pasadyn and Zsolt Vasvari.
+TMS9900 emulator by Andy Jones, based on original code by Ton Brouwer.
+Cinematronics CPU emulator by Jeff Mitchell, Zonn Moore, Neil Bradley.
+Atari AVG/DVG emulation based on VECSIM by Hedley Rainnie, Eric Smith and
+Al Kossow.
+
+TMS5220 emulator by Frank Palazzolo.
+AY-3-8910 emulation based on various code snippets by Ville Hallik,
+  Michael Cuddy, Tatsuyuki Satoh, Fabrice Frances, Nicola Salmoria.
+YM-2203, YM-2151, YM3812 emulation by Tatsuyuki Satoh.
+POKEY emulator by Ron Fries.
+Many thanks to Eric Smith, Hedley Rainnie and Sean Trowbridge for information
+   on the Pokey random number generator.
+NES sound hardware info by Matthew Conte.
+YM2610 emulation by Hiromitsu Shioya.
+
+Background art by Peter Hirschberg (PeterH@cronuscom.com).
+
+Allegro library by Shawn Hargreaves, 1994/97
+SEAL Synthetic Audio Library API Interface Copyright (C) 1995, 1996
+   Carlos Hasan. All Rights Reserved.
+Video modes created using Tweak 1.6b by Robert Schmidt, who also wrote
+   TwkUser.c.
+"inflate" code for zip file support by Mark Adler.
+
+DOS executable compressed with UPX by Markus F.X.J. Oberhumer & Laszlo Molnar,
+    http://upx.sourceforge.net/
+
+Big thanks to Gary Walton (garyw@excels-w.demon.co.uk) for too many things
+   to mention.
+
+Thanks to Brian Deuel, Neil Bradley, and the Retrocade dev team for allowing us
+to use Retrocade's game history database.
+
+Thanks to Richard Bush for info on several games.
+
+Thanks to Dave (www.finalburn.com) for info on After Burner.
+
+and thanks to everyone else I forgot.
+
+
diff --git a/src/unix/doc/mame/msdos.txt b/src/unix/doc/mame/msdos.txt
new file mode 100644
index 0000000..cfa400e
--- /dev/null
+++ b/src/unix/doc/mame/msdos.txt
@@ -0,0 +1,332 @@
+
+Using the program
+-----------------
+
+MAME [name of the game to run] [options]
+
+for example:
+
+   MAME mspacman -soundcard 0
+
+...will run Ms Pac Man without sound
+
+
+Options:
+
+-tweak/-notweak (default: notweak)
+              MAME supports a large number of tweaked VGA modes whose
+              resolutions matching those of the emulated games. These modes
+              look MUCH better than VESA modes (and are usually faster), but
+              they may create compatibility problems with some video cards and
+              monitors. Therefore, they are not enabled by default. You should
+              by all means use -tweak if your hardware supports it. Note that
+              some modes might work and other might not--e.g. your card could
+              support 256x256 but not 384x224. In that case, you'll have to
+              turn -tweak on or off depending on the game you run. -noscanlines
+              can also solve many compatibility problems.
+
+-ntsc         a 288x224 mode with standard NTSC frequencies. You need some
+              additional hardware (VGA2TV converter) to use this.
+
+-vesamode vesa1/vesa2b/vesa2l/vesa3
+              Forces the VESA mode. The best available one is used by default.
+              If your video card crashes during autodetection, however, use
+              this option to force a lower standard. (Start with vesa1, and go
+              upwards to find the highest one that works.)
+
+-resolution XxY
+              where X and Y are width and height (ex: '-resolution 800x600')
+              MAME goes to some lengths to autoselect a good resolution. You
+              can override MAME's choice with this option. You can omit the
+              word "resolution" and simply use -XxY (e.g. '-800x600') as a
+              shortcut. Frontend authors are advised to use '-resolution XxY',
+              however.
+
+-skiplines N / -skipcolumns N
+              If you run a game in a video mode smaller than the visible area,
+              you can adjust its position using the PgUp and PgDn keys (alone
+              for vertical panning, shifted for horizontal panning). You can
+              also use these two parameters to set the initial position: 0 is
+              the default, meaning that the screen is centered. You can specify
+              both positive and negative offsets.
+
+-scanlines/-noscanlines (default: -scanlines)
+              Scanlines are small, evenly-spaced, horizontal blank lines that
+              are typical of real arcade monitors. If you don't prefer this
+              "authentic" look, turn scanlines off.
+
+-stretch/-nostretch (default: stretch)
+              use nostretch to disable pixel doubling in VESA modes (faster,
+              but smaller picture).
+
+-depth n      (default: auto)
+              Some games need 16-bit color to get accurate graphics. To improve
+              speed, you can use '-depth 8', which limits the display to
+              standard 256-color mode. (You can also use '-depth 16' to force
+              256-color games to use 16-bit color, but this isn't recommended.)
+
+-gamma n      (default: 1.0)
+              Sets the initial gamma correction value.
+
+-vgafreq n    where n can be 0 (default) 1, 2 or 3.
+              Specifies different frequencies for the custom video modes. This
+              can reduce flicker, especially in 224x288 / noscanlines mode.
+              WARNING: IT IS POSSIBLE TO SET FREQUENCIES WAY OUTSIDE OF YOUR
+              MONITOR'S RANGE, WHICH COULD DAMAGE YOUR MONITOR. BEFORE USING
+              THIS OPTION, BE SURE YOU KNOW WHICH FREQUENCIES YOUR MONITOR
+              SUPPORTS. USE THIS OPTION AT YOUR OWN RISK.
+
+-vsync/-novsync (default: -novsync)
+              Synchronize video display with the video beam instead of using
+              the timer. This option can be used only if the selected video
+              mode has an appropriate refresh rate. Otherwise, MAME will
+              refuse to start, telling you the actual refresh rate of the video
+              mode, and the rate it should have.
+              If you are using a tweaked mode, MAME will try to automatically
+              pick the correct setting for -vgafreq; you can still override it
+              using the -vgafreq option.
+              Note: the 224x288 / noscanlines mode doesn't work on most cards.
+              Many games use this mode, e.g. Pac Man and Galaga. If it doesn't
+              work with your card, either turn scanlines on, or don't use
+              -vsync.
+              If you are using a VESA mode, you should use the program that
+              came with your video card to set the appropriate refresh rate.
+              Note that when this option is turned on, speed will NOT
+              downgrade nicely if your system is not fast enough (i.e.,
+              gameplay will be jerky).
+
+-alwayssynced/-noalwayssynced (default: -noalwayssynced)
+              For many tweaked VGA modes, MAME has two definitions: One which
+              is more compatible, and one which is less compatible but uses
+              frequencies compatible with -vsync. By default, the less-
+              compatible definition is used only when -vsync is requested;
+              using this option, you can force it to be used always.
+
+-triplebuffer/-notriplebuffer (default: -notriplebuffer)
+              Enables triple buffering with VESA modes. This is faster than
+              -vsync, but doesn't work on all cards. Even if it does remove
+              "tearing" during scrolling, it might not be as smooth as -vsync.
+
+-monitor NNNN (default: standard)
+              Selects the monitor type:
+              standard: standard PC monitor
+              ntsc:     NTSC monitor
+              pal:      PAL monitor
+              arcade:   arcade monitor
+
+-centerx N and -centery N
+              Each takes a signed value (-8 to 8 for centerx, -16 to 16 for
+              centery) and lets you change the low scanrate modes (monitor=ntsc,
+              pal, arcade).
+
+-waitinterlace
+              Forces update of both odd and even fields of an interlaced low
+              scanrate display (monitor=ntsc,pal,arcade) for each game loop.
+
+-ror          Rotates the display clockwise by 90 degrees.
+-rol          Rotates display anticlockwise
+-flipx        Flips display horizontally
+-flipy        Flips display vertically
+              -ror and -rol add authentic *vertical* scanlines, given that you
+              have turned your monitor on its side.
+              CAUTION:
+              Monitors are complicated, high-voltage electronic devices.
+              Some monitors are designed to be rotated. If yours is _not_ one
+              of them, but you absolutely must turn it on its side, you do so
+              at your own risk.
+
+              *******************************************
+              PLEASE DO NOT LEAVE YOUR MONITOR UNATTENDED
+              IF IT IS PLUGGED IN AND TURNED ON ITS SIDE!
+              *******************************************
+
+-norotate     Disable all internal rotation of the image, therefore displaying
+              the image in its original orientation (for example, so you need
+              a vertical monitor to see vertical games).
+              In some cases, the image will be upside down. To correct this,
+              use '-norotate -flipx -flipy'
+
+-frameskip n (default: auto)
+              Skips frames to speed up the emulation. The argument is the number
+              of frames to skip out of 12. For example, if the game normally
+              runs at 60 fps, '-frameskip 2' will make it run at 50 fps,
+              '-frameskip 6' at 30 fps. Use F11 to display the speed your
+              computer is actually reaching. If it is below 100%, increase the
+              frameskip value. You can press F9 to change frameskip while
+              running the game.
+              When set to auto (the default), the frameskip setting is
+              dynamically adjusted during run time to display the maximum
+              possible frames without dropping below 100% speed.
+
+-antialias/-noantialias (default: -antialias)
+              Antialiasing for the vector games.
+
+-beam n       Sets the width in pixels of the vectors. n is a float in the
+              range of 1.00 through 16.00.
+
+-flicker n    Makes the vectors flicker. n is an optional argument, a float in
+              the range 0.00 - 100.00 (0=none, 100=maximum).
+
+-translucency/-notranslucency (default: -translucency)
+              Enables or disables vector translucency.
+
+-soundcard n  Selects sound card. (If this is not specified, MAME will ask you.)
+
+-sr n         Sets the audio sample rate. The default is 22050. Smaller values
+              (e.g. 11025) cause lower audio quality but faster emulation speed.
+              Higher values (e.g. 44100) cause higher audio quality but slower
+              emulation speed.
+
+-stereo/-nostereo (default: -stereo)
+              Selects stereo or mono output for games supporting stereo sound.
+
+-volume n     (default: 0)
+              Sets the startup volume. It can later be changed with the On
+              Screen Display (see Keys section). The volume is an attenuation
+              in dB: e.g., "-volume -12" will start with -12dB attenuation.
+
+-joy name (default: none)
+              Allows joystick input. 'name' can be:
+              none         - no joystick
+              auto         - attempts auto detection
+              standard     - normal 2 button joystick
+              dual         - dual joysticks
+              4button      - Stick/Pad with 4 buttons
+              6button      - Stick/Pad with 6 buttons
+              8button      - Stick/Pad with 8 buttons
+              fspro        - CH Flightstick Pro
+              wingex       - Wingman Extreme
+              wingwarrior  - Wingman Warrior
+              sidewinder   - Microsoft Sidewinder (up to 4)
+              gamepadpro   - Gravis GamePad Pro
+              grip         - Gravis GrIP
+              grip4        - Gravis GrIP constrained to move only along the
+			                 x and y axes
+              sneslpt1     - SNES pad on LPT1 (needs special hardware)
+              sneslpt2     - SNES pad on LPT2 (needs special hardware)
+              sneslpt3     - SNES pad on LPT3 (needs special hardware)
+              psxlpt1      - PSX pad on LPT1 (needs special hardware)
+              psxlpt2      - PSX pad on LPT2 (needs special hardware)
+              psxlpt3      - PSX pad on LPT3 (needs special hardware)
+              n64lpt1      - N64 pad on LPT1 (needs special hardware)
+              n64lpt2      - N64 pad on LPT2 (needs special hardware)
+              n64lpt3      - N64 pad on LPT3 (needs special hardware)
+              db9lpt1      - C64/Atari/Sinclair joy via DB9 interface on LPT1
+              db9lpt2      - C64/Atari/Sinclair joy via DB9 interface on LPT2
+              db9lpt3      - C64/Atari/Sinclair joy via DB9 interface on LPT3
+              tgxlpt1      - digital joystick via Turbografix if on LPT1
+              tgxlpt2      - digital joystick via Turbografix if on LPT2
+              tgxlpt3      - digital joystick via Turbografix if on LPT3
+
+              Notes:
+              1) Use the TAB menu to calibrate analog joysticks. Calibration
+              data will be saved in mame.cfg. If you're using different
+              joysticks for different games, you may need to recalibrate your
+              joystick every time.
+              2) Extra buttons of noname joysticks may not work.
+              3) The "official" Snespad-Support site is:
+              http://snespad.emulationworld.com
+              4) http://www.debaser.force9.co.uk/ccmame has info on how to
+              connect PSX and N64 pads.
+              5) http://www.burg-halle.de/~schwenke/parport.html for details on
+              how to build Turbografix interface for 1-7 joysticks. Also go
+              there for information on DB9 interface, the cheapest
+              (wires-only) joystick interface ever.
+
+-steadykey    Some games require two or more buttons to be pressed at exactly
+              the same time to make special moves. Due to limitations in the PC
+              keyboard hardware, it can be difficult or even impossible to
+              accomplish that using the standard keyboard handling. This option
+              selects a different handling that makes it easier to register
+              simultaneous button presses, but has the disadvantage of making
+              controls less responsive.
+
+-log          Creates a log of illegal memory accesses in ERROR.LOG
+
+-help, -?     Displays current MAME version and copyright notice
+
+ - - -
+
+Note: By default, all the '-list' commands below write info to the screen. If
+you wish to write the info to a textfile instead, add this to the end of your
+command:
+
+  > filename
+
+...where 'filename' is the textfile's path and name (e.g., c:\mame\list.txt).
+
+ - - -
+
+-list         Displays a list of currently supported games
+
+-listfull     Displays a list of game directory names + descriptions
+
+-listroms     Displays ROMs required by the specified game
+
+-listsamples  Displays samples required by the specified game
+
+-listdetails  Displays a detailed list of drivers and the hardware they use
+
+-listgames    list the supported games, year, manufacturer
+
+-listinfo     list comprehensive details for all of the supported games
+
+-listclones   Lists clones of the specified game. When no game is specified,
+              this generates a list of all MAME-supported clones.
+
+-noclones     used together with the list commands, doesn't list alternate
+              versions of the same game
+
+-verifyroms   Checks specified game(s) for missing and invalid ROMs.
+              Adding * checks all available games.
+
+-verifysets   Checks specified game(s) and reports its status.
+              Adding * checks all available games.
+
+-verifysamples check selected game for missing samples.
+              Adding * checks all available samples.
+
+-romdir       Specifies an alternate directory (or zipfile name) for loading
+              the ROMs for the specified game.
+              E.g., 'mame pacman -romdir pachack' will run the Pac Man driver
+              but load the ROMs from the "pachack" dir or "pachack.zip" archive.
+
+-mouse/-nomouse (default: -mouse)
+              Enables/disables mouse support
+
+-cheat        Cheats, like the speedup in Pac Man or the level-skip in many
+              other games, are disabled by default. Use this switch to turn
+              them on.
+
+-debug        Activates the integrated debugger.
+              During emulation, press the Tilde key (~) to activate the
+              debugger. This is available only if the program is compiled with
+              MAME_DEBUG defined.
+
+-record name   Records joystick input to file INP/name.inp
+
+-playback name Plays back joystick input from file INP/name.inp
+
+-ignorecfg    ignore mame.cfg and start with the default settings
+
+
+Keys
+----
+Tab          Toggles the configuration menu
+Tilde        Toggles the On Screen Display
+             Use the up and down arrow keys to select the parameter (global
+             volume, mixing level, gamma correction etc.), left and right to
+             arrow keys to modify it.
+P            Pauses the game
+Shift+P      While paused, advances to next frame
+F3           Resets the game
+F4           Shows the game graphics. Use cursor keys to change set/color,
+             F4 or Esc to return to the emulation.
+F9           Changes frame skip on the fly
+F10          Toggles speed throttling
+F11          Toggles speed display
+Shift+F11    Toggles profiler display
+F12          Saves a screen snapshot. The default target directory is SNAP. You
+             must create this directory yourself; the program will not create
+             it if it doesn't exist.
+ESC          Exits emulator
diff --git a/src/unix/doc/mame/whatsnew.txt b/src/unix/doc/mame/whatsnew.txt
new file mode 100644
index 0000000..fa11981
--- /dev/null
+++ b/src/unix/doc/mame/whatsnew.txt
@@ -0,0 +1,120 @@
+0.74
+
+Basically a cleaned up version of .73 now my machine is working again.
+
+General Source Changes
+----------------------
+
+Misc source changes mainly to Improve compatibility with MESS [Nathan Woods]
+	src/driver.h:
+	- Minor changes within #ifdef MESS
+
+	src/inptport.c:
+	- Minor change to recognize MESS IPT_CONFIG input ports
+
+	src/legacy.h:
+	- Changed some of the prototypes to use 'mame_file *' instead of
+	'void *'
+
+	src/mame.h:
+	- Added APPNAME and APPLONGNAME macros to define the name of the
+	program (MAME/M.A.M.E. vs MESS/M.E.S.S.)
+
+	src/vidhrdw/jaguar.c:
+	- Adds some MESS specific templated blitters within #ifdef MESS
+
+	src/vidhrdw/ppu2c03b.c:
+	src/vidhrdw/ppu2c03b.h:
+	src/vidhrdw/playch10.c:
+	src/vidhrdw/vsnes.c:
+	- Small speedups (eliminated some usage of plot_pixel())
+	- Added support for scanline counts other than 262
+	- Interrupt changes by Brad Oliver
+	- Requisite changes to playch10 and vsnes to support Brad's
+	interrupt changes
+
+	src/windows/input.c:
+	src/windows/video.c:
+	src/windows/window.c:
+	src/windows/window.h:
+	src/windows/winmain.c:
+	- Misc changes to support MESS's menu bar (should not affect
+	MAME)
+	- Misc changes to use APPNAME and APPLONGNAME
+
+Improved Loading of .72 cfg Files (prevents Mixer settings corruption) [Stefan Jokisch]
+	src/sound/mixer.c
+
+Fixed User-Interface bug which was causing problems setting controls for some of the
+players [Stefan Jokisch]
+	src/usrintrf.c
+
+Support for 8 Controllers [Robin Merrill]
+	src/input.h
+	src/windows/input.c
+	src/inptport.c
+
+Workaround for a v60 crash causing ultra-x not to run on some systems [Tomasz Slanina]
+	src/cpu/v60/op12.c
+
+Support upd7759 Silence Compression [Olivier Galibert]
+	src/sound/upd7759.c
+
+SegaPCM cleanups / fixes [Olivier Galibert]
+	src/sound/segapcm.c
+	src/sound/segapcm.h
+	src/sndintrf.c
+
+Changed Afterburner Inputs to use z-axis for throttle [Howard Casto]
+	src/drivers/aburner.c
+
+Some Improvements to Chequered Flag protection + Sound [Angelo Salese]
+	src/drivers/chqflag.c
+	src/vidhrdw/konamiic.c
+
+More ST-V Improvements [Angelo Salese, David Haywood]
+	src/drivers/stv.c
+	src/vidhrdw/stvvdp1.c
+	src/vidhrdw/stvvdp2.c
+
+New games supported:
+--------------------
+
+Miyasu Nonki no Quiz 18-Kin (Japan) [Takahiro Nogi]
+	src/drivers/welltris.c
+	src/vidhrdw/welltris.c
+
+Ojanko Club (Japan) [Takahiro Nogi, Uki]
+	src/drivers/ojankohs.c
+
+Quiz & Variety Sukusuku Inufuku (Japan) [Takahiro Nogi]
+	src/drivers/inufuku.c
+	src/vidhrdw/inufuku.c
+
+Dancing Eyes (DC1/VER.A) [smf]
+Kosodate Quiz My Angel 3 (KQT1/VER.A) [smf]
+	src/drivers/namcos11.c
+	+ most psx files
+
+Super-X [David Haywood]
+	src/drivers/dooyong.c
+
+A Few new Megatech sets (mostly SMS based, not yet working)
+	src/drivers/segac2.c
+
+New Clones supported:
+---------------------
+
+Natsuiro Mahjong (Mahjong Summer Story) (Japan) (clone of mjnatsu) [Takahiro Nogi]
+	src/drivers/fromance.c
+
+Bang (Japan) [Manuel Abadia]
+	src/drivers/gaelco2.c
+
+Hangly Man (set 3) [Manuel Abadia]
+	src/drivers/pacman.c
+Apocaljpse Now (bootleg of Rescue) [Pierpaolo Prazzoli]
+	src/drivers/scobra.c
+Explorer (bootleg of Scramble) [Pierpaolo Prazzoli]
+	src/drivers/scramble.c
+	todo : check these 3 bootlegs are worth supporting, if not remove them
\ No newline at end of file
diff --git a/src/unix/doc/mame/whatsold.txt b/src/unix/doc/mame/whatsold.txt
new file mode 100644
index 0000000..933c192
--- /dev/null
+++ b/src/unix/doc/mame/whatsold.txt
@@ -0,0 +1,4088 @@
+0.73
+
+Sorry, this list of changes isn't complete due to hardware problems I'm having.
+
+General Source Changes
+----------------------
+
+Many Improvements to the ST-V emulation, resulting in Hanagumi Columns being
+playable and other games on the driver starting to show some
+graphics [Angelo Salese, David Haywood]
+	src/drivers/stv.c
+	src/vidhrdw/stvvdp1.c
+	src/vidhrdw/stvvdp2.c
+
+Continued MegaPlay Improvements (still none fulyl working yet but more of the
+bios menu tests pass now) [Barry Rodewald]
+	src/drivers/segac2.c
+
+Some System GX Improvements, mainly to the not yet working games [R.Belmont]
+	src/drivers/konamigx.c
+	src/vidhrdw/konamigx.c
+
+Attempted to Improve Super Dodge Ball MCU Simulation [Acho A. Tang]
+	src/drivers/sdodgeb.c
+	src/vidhrdw/sdodgeb.c
+
+Various Changes to keep the code inline with MESS [Nathan Woods]
+
+Added 8 Player Support to the Core [Stefan Jokisch]
+
+New games supported:
+--------------------
+
+Hanagumi Taisen Columns - Sakura Wars  [Angelo Salese, David Haywood]
+	This the first st-v game to be supported by MAME, please note that due
+	to the complexity of the system emulation is still preliminary and there
+	are still various issues that will need ironing out, there is currently
+	no sound.
+	src/drivers/stv.c
+	src/vidhrdw/stvvdp1.c
+	src/vidhrdw/stvvdp2.c
+
+Ultra X Weapons [Tomasz Slanina]
+	some gfx offset problems / alignment (sprite handle can move?)
+	src/drivers/ssv.c
+
+Twin Eagle 2 [Tomasz Slanina]
+	src/drivers/ssv.c
+	Twin Eagle 2 DOES NOT WORK due to protection involving the directions
+	in which objects travel, and as a side-effect collisions don't work
+	correctly either, if somebody fixes this then itmight be fine apart
+	from a few offset problems.
+
+Super Trivia Master [Pierpaolo Prazzoli]
+	wrong colours
+	src/drivers/strvmstr.c
+
+Sprint 8 [Stefan Jokisch]
+	src/drivers/sprint8.c
+	src/vidhrdw/sprint8.c
+
+New Clones supported:
+--------------------
+
+Lady Bug (bootleg on Galaxian Hardware) [Mike Coates]
+	input ports incomplete
+	src/drivers/galaxian.c
+	src/includes/galaxian.h
+	src/machine/scramble.c
+
+Video Pool (Moon Cresta hardware) (bootleg of Video Hustler) [Mike Coates]
+	dipswitches incomplete
+	src/drivers/galaxian.c
+
+0.72u2
+
+General Source Changes
+----------------------
+
+Improved Megaplay a bit, the bios screens now show however the games still don't
+work [Barry Rodewald]
+	src/drivers/segac2.c
+	src/includes/segac2.h
+	src/vidhrdw/segac2.c
+
+Various ST-V improvements, Hanagumi Columns shows a partial title screen (still
+disabled so you'll have to enable it yourself if you want to see)
+	[Angelo Salese]
+	src/drivers/stv.c
+
+Removed DCS Speed-Ups
+	src/sndhrdw/dcs.c
+
+Fixed a bug in the C 68000 core with the SBCD Opcode [Acho A/ Tang]
+	States of the sign(N) and overflow(V) flags after SBCD,
+	ABCD and NBCD operations are "undefined" according to Motorola.
+	The C core randomizes the V flag and sets the N flag like signed
+	operations.
+
+	Viofight expects determinant results of the two flags from SBCD
+	or it gets stuck in a math loop. The V flag now returns zero and
+	the N flag mirrors carry exactly like what the ASM core does.
+	src/cpu/m68000/m68k_in.c
+
+Fixed Mustache Boy Continue Screen and attempted to improve speed [Tomasz Slanina]
+	src/drivers/mustache.c
+
+Misc Konami Fixes [Acho A. Tang]
+	tmnt.c:
+	- qgakumon resetting and screen darkening
+	- tmnt2 load-save states(not good enough yet)
+	- ssriders diagonal jittering(needs testing)
+
+	konamiic.c:
+	- boundary conditions and kludge removal in K007420
+
+	rockrage.c:
+	- rogue sprites
+
+	kncljoe.c:
+	- bad scrolling, clipping, rogue sprites
+
+Couple of Improvements to the Fuuki games (Priority, BG Colours) [Paul Priest]
+	src/drivers/fuukifg2.c
+	src/vidhrdw/fuukifg2.c
+	src/drivers/fuukifg3.c
+	src/vidhrdw/fuukifg3.c
+
+Guard against OP_ROM/OP_RAM overflows [Nathan Woods]
+	This patch adds an optional facility to guard against OP_ROM/OP_RAM
+	overflows.  This is implemented by adding new variables OP_MEM_MIN and
+	OP_MEM_MAX that track the minimum and maximum address ranges for which
+	using OP_ROM/OP_RAM is valid.
+
+	Support for this feature is enabled via conditional compilation in
+	memory.h.  There are three possible modes:
+
+	CPUREADOP_SAFETY_NONE   - The status quo; no range checking at
+	all
+	CPUREADOP_SAFETY_PARTIAL  - Range checking only against the
+	maximum address
+	CPUREADOP_SAFETY_FULL     - Range checking against both the
+	minimum and the maximum
+
+	This patch has MAME using CPUREADOP_SAFETY_NONE, unless MAME_DEBUG is
+	defined in which case CPUREADOP_SAFETY_FULL is set.  Thus as is, this
+	patch should have zero effect on release versions of MAME.
+	Additionally, being able to safely disassemble code near bank boundaries
+	when using the MAME debugger is extremely useful.
+
+	There is a slight performance hit when this is enabled.
+
+Dipswitch Fixes:
+	1st dipswitch of 3rd bank in 1941 [Fabrizio Pedrazzini]
+	src/drivers/cps1.c
+
+	Tetris Plus 2 (MS32 version) [Sonikos]
+	src/drivers/ms32.c
+
+	and a few others ...
+
+Changed nkdodgeb to use proms from another Japan bootleg set, maybe this fixes
+some problems with the colours.
+	src/drivers/nkdodgeb.c
+
+Included 8080 core updates from MESS
+	src/cpu/i8085/*
+
+Preliminary Hyperstone Core, not yet working well enough to run anything [Pierpaolo Prazzoli]
+
+Now using correct Dragon Blaze sound ROM
+	src/drivers/psikyosh.c
+
+New Clones supported:
+--------------------
+
+Hard Dunk (World)
+	src/drivers/multi32.c
+
+Super Bike (DK Conversion) [Pierpaolo Prazzoli]
+	src/drivers/dkong.c
+
+Some CPS clones [Razoola]
+	src/drivers/cps2.c
+
+New games supported:
+--------------------
+
+Mogura Desse (Cabinet Test Board) [David Haywood]
+	no sound (discrete)
+	src/drivers/mogura.c
+
+Speed Attack [Angelo Salese, Pierpaolo Prazzoli]
+	wrong colours
+	src/drivers/speedatk.c
+	src/vidhrdw/speedatk.c
+
+Some New MegaTech Sets (mostly not working yet)
+	src/drivers/segac2.c
+
+0.72u1
+
+General Source Changes
+----------------------
+
+Changed Fuuki 16-bit driver to use Partial Updates for Raster Effects and enabled
+them [David Haywood, Paul Priest]
+	src/drivers/fuukifg2.c
+	src/vidhrdw/fuukifg2.c
+
+Temporary Fixes to a few of the System 16 driver problems (sound banking for
+example)  Note, the driver is still being rewritten these are only minor 'fixes'
+to improve things a bit until the rewrite is complete [Acho A. Tang]
+	src/drivers/sysetm16.c
+	src/vidhrdw/system16.c
+	src/vidhrdw/sys16spr.c
+
+Change so DIP menu isn't displayed if no Dipswitches are defined in the driver
+instead of flashing a blank mneu when you try and enter it [Paul Priest]
+	src/usrintrf.c
+
+Various Changes [Nathan Woods]
+	src/cpu/jaguar/jaguar.c:
+	- Fixed a bug in the NORMI opcode
+
+	src/cpu/mips/mips.c:
+	- Removed use of the GCC specific varargs on macros feature
+
+	src/sndhrdw/jaguar.c:
+	- Changed around one of the #include paths (due to
+	ProjectBuilder on Mac issues)
+
+	src/sound/tms5220.c:
+	src/sound/tms5220.h:
+	- Added support for the TMS0285 variant (an old variant of the
+	TMS5220)
+
+	src/vidhrdw/jagblit.c:
+	src/vidhrdw/jaguar.c:
+	- Added support for the SRCSHADE and DSTA2 command bits to the
+	Jaguar blitter.
+	- Added some miscellaneous logging code
+	- Changed around one of the #include paths (due to
+	ProjectBuilder on Mac issues)
+
+	src/vidhrdw/jagobj.c:
+	- Added support for objects with pitch != 1 for objects with 1-2
+	bits per pixels
+
+	src/harddisk.c:
+	src/harddisk.h:
+	- Added a function to retrieve the interface
+
+	src/ui_text.c:
+	src/ui_text.h:
+	- Added a MESS specific UI string (within #ifdef MESS of course)
+
+	src/usrintrf.c:
+	- Parameterized the setdipswitches() call; so that a menu that
+	looks like the DIP switch menu can easily be made with different IPT_*
+	values (MESS has a configuration menu that functions a lot like the DIP
+	switch menu)
+
+	src/artwork.c:
+	- Small fix to allow the UI to be drawn if the artwork system is
+	active but no artwork is present (not an issue for MAME)
+
+	src/mamedbg.c:
+	- Cleanup and fix of set_ea_info() so that negative offsets of 8
+	or 16 bits do not have extraneous FF's in front of them.
+	- More proper fix to the scanline display bug that prevented
+	registers from being edited when the scanline display was on.
+
+	src/cpu/hd6309/6309dasm.c:
+	- Better message for when invalid opcodes are disassembled
+
+	src/artwork.c
+	src/artwork.h
+	- Fixed crashing bug with clones
+
+	src/inptport.c:
+	- Adds some MESS specific IPT defaults (within #ifdef MESS)
+	- Modified input_port_allocate() so that PORT_BITX declarations
+	that specify JOYCODE_a_BUTTONb for their default codes will also get
+	JOYCODE_MOUSE_a_BUTTONb or'd in.
+
+	src/input.c:
+	src/input.h:
+	- Added seq_set_4() and seq_set_5()
+
+	src/windows/video.c:
+	- Changed render_frame() so that throttle_speed() will also be
+	called when game_is_paused is set.  This prevents MAME from busy looping
+	when paused.
+
+Fixed Remaining Protection problems in TMNT2 and Sunset Riders, Fixed Combat School
+Trackball sets from Crashing, Fixed Escape Kids Spries, Fixed Sticky Sprites in
+Detana! Twinbee, Fixed Sprite Lag in some games [Acho A. Tang]
+	src/drivers/combatsc.c
+	src/vidhrdw/konamiic.c
+	src/vidhrdw/konamiic.h
+	src/palette.c
+	src/palette.h
+	src/drivers/tmnt.c
+	src/vidhrdw/tmnt.c
+
+Misc Improvements / Cleanups / Fixes [Acho A. Tang]
+	src/drivers/aeroboto.c
+	src/vidhrdw/aeroboto.c
+	src/drivers/bwing.c
+	src/vidhrdw/bwing.c
+	src/drivers/equites.c
+	src/vidhrdw/equites.c
+	src/machine/equites.c
+	src/drivers/halleys.c
+	src/drivers/sgladiat.c
+	src/drivers/sidearms.c
+	src/vidhrdw/sidearms.c
+	src/vidhrdw/spdodgeb.c
+	src/drivers/wecleman.c
+	src/vidhrdw/wecleman.c
+	src/drivers/wiz.c
+
+Fixed Background Graphics in Trackball version of WC90 [Angelo Salese]
+	src/drivers/wc90.c
+	src/vidhrdw/wc90.c
+	
+Fixed sound in Super Doubles Tennis [Pierpaolo Prazzoli]
+	src/drivers/btime.c
+
+New games supported:
+--------------------
+
+Asura Blade [Paul Priest]
+	missing sound, some priority errors
+	src/drivers/fuukifg3.c
+	src/vidhrdw/fuukifg3.c
+
+Gaia Crusaders [Paul Priest]
+	src/drivers/cave.c
+
+Street Heat [Dave Widel]
+	src/drivers/dkong.c
+
+New Clones supported:
+--------------------
+
+8 Ball Action (DkJr Kit) [Pierpaolo Prazzoli]
+	src/drivers/dkong.c
+
+
+0.72u2
+
+General Source Changes
+----------------------
+
+Improved Megaplay a bit, the bios screens now show however the games still don't
+work [Barry Rodewald]
+	src/drivers/segac2.c
+	src/includes/segac2.h
+	src/vidhrdw/segac2.c
+
+Various ST-V improvements, Hanagumi Columns shows a partial title screen (still
+disabled so you'll have to enable it yourself if you want to see)
+	[Angelo Salese]
+	src/drivers/stv.c
+
+Removed DCS Speed-Ups
+	src/sndhrdw/dcs.c
+
+Fixed a bug in the C 68000 core with the SBCD Opcode [Acho A/ Tang]
+	States of the sign(N) and overflow(V) flags after SBCD,
+	ABCD and NBCD operations are "undefined" according to Motorola.
+	The C core randomizes the V flag and sets the N flag like signed
+	operations.
+
+	Viofight expects determinant results of the two flags from SBCD
+	or it gets stuck in a math loop. The V flag now returns zero and
+	the N flag mirrors carry exactly like what the ASM core does.
+	src/cpu/m68000/m68k_in.c
+
+Fixed Mustache Boy Continue Screen and attempted to improve speed [Tomasz Slanina]
+	src/drivers/mustache.c
+
+Misc Konami Fixes [Acho A. Tang]
+	tmnt.c:
+	- qgakumon resetting and screen darkening
+	- tmnt2 load-save states(not good enough yet)
+	- ssriders diagonal jittering(needs testing)
+
+	konamiic.c:
+	- boundary conditions and kludge removal in K007420
+
+	rockrage.c:
+	- rogue sprites
+
+	kncljoe.c:
+	- bad scrolling, clipping, rogue sprites
+
+Couple of Improvements to the Fuuki games (Priority, BG Colours) [Paul Priest]
+	src/drivers/fuukifg2.c
+	src/vidhrdw/fuukifg2.c
+	src/drivers/fuukifg3.c
+	src/vidhrdw/fuukifg3.c
+
+Guard against OP_ROM/OP_RAM overflows [Nathan Woods]
+	This patch adds an optional facility to guard against OP_ROM/OP_RAM
+	overflows.  This is implemented by adding new variables OP_MEM_MIN and
+	OP_MEM_MAX that track the minimum and maximum address ranges for which
+	using OP_ROM/OP_RAM is valid.
+
+	Support for this feature is enabled via conditional compilation in
+	memory.h.  There are three possible modes:
+
+	CPUREADOP_SAFETY_NONE   - The status quo; no range checking at
+	all
+	CPUREADOP_SAFETY_PARTIAL  - Range checking only against the
+	maximum address
+	CPUREADOP_SAFETY_FULL     - Range checking against both the
+	minimum and the maximum
+
+	This patch has MAME using CPUREADOP_SAFETY_NONE, unless MAME_DEBUG is
+	defined in which case CPUREADOP_SAFETY_FULL is set.  Thus as is, this
+	patch should have zero effect on release versions of MAME.
+	Additionally, being able to safely disassemble code near bank boundaries
+	when using the MAME debugger is extremely useful.
+
+	There is a slight performance hit when this is enabled.
+
+Dipswitch Fixes:
+	1st dipswitch of 3rd bank in 1941 [Fabrizio Pedrazzini]
+	src/drivers/cps1.c
+
+	Tetris Plus 2 (MS32 version) [Sonikos]
+	src/drivers/ms32.c
+
+	and a few others ...
+
+Changed nkdodgeb to use proms from another Japan bootleg set, maybe this fixes
+some problems with the colours.
+	src/drivers/nkdodgeb.c
+
+Included 8080 core updates from MESS
+	src/cpu/i8085/*
+
+Preliminary Hyperstone Core, not yet working well enough to run anything [Pierpaolo Prazzoli]
+
+Now using correct Dragon Blaze sound ROM
+	src/drivers/psikyosh.c
+
+New Clones supported:
+--------------------
+
+Hard Dunk (World)
+	src/drivers/multi32.c
+
+Super Bike (DK Conversion) [Pierpaolo Prazzoli]
+	src/drivers/dkong.c
+
+Some CPS clones [Razoola]
+	src/drivers/cps2.c
+
+New games supported:
+--------------------
+
+Mogura Desse (Cabinet Test Board) [David Haywood]
+	no sound (discrete)
+	src/drivers/mogura.c
+
+Speed Attack [Angelo Salese, Pierpaolo Prazzoli]
+	wrong colours
+	src/drivers/speedatk.c
+	src/vidhrdw/speedatk.c
+
+Some New MegaTech Sets (mostly not working yet)
+	src/drivers/segac2.c
+
+0.72u1
+
+General Source Changes
+----------------------
+
+Changed Fuuki 16-bit driver to use Partial Updates for Raster Effects and enabled
+them [David Haywood, Paul Priest]
+	src/drivers/fuukifg2.c
+	src/vidhrdw/fuukifg2.c
+
+Temporary Fixes to a few of the System 16 driver problems (sound banking for
+example)  Note, the driver is still being rewritten these are only minor 'fixes'
+to improve things a bit until the rewrite is complete [Acho A. Tang]
+	src/drivers/sysetm16.c
+	src/vidhrdw/system16.c
+	src/vidhrdw/sys16spr.c
+
+Change so DIP menu isn't displayed if no Dipswitches are defined in the driver
+instead of flashing a blank mneu when you try and enter it [Paul Priest]
+	src/usrintrf.c
+
+Various Changes [Nathan Woods]
+	src/cpu/jaguar/jaguar.c:
+	- Fixed a bug in the NORMI opcode
+
+	src/cpu/mips/mips.c:
+	- Removed use of the GCC specific varargs on macros feature
+
+	src/sndhrdw/jaguar.c:
+	- Changed around one of the #include paths (due to
+	ProjectBuilder on Mac issues)
+
+	src/sound/tms5220.c:
+	src/sound/tms5220.h:
+	- Added support for the TMS0285 variant (an old variant of the
+	TMS5220)
+
+	src/vidhrdw/jagblit.c:
+	src/vidhrdw/jaguar.c:
+	- Added support for the SRCSHADE and DSTA2 command bits to the
+	Jaguar blitter.
+	- Added some miscellaneous logging code
+	- Changed around one of the #include paths (due to
+	ProjectBuilder on Mac issues)
+
+	src/vidhrdw/jagobj.c:
+	- Added support for objects with pitch != 1 for objects with 1-2
+	bits per pixels
+
+	src/harddisk.c:
+	src/harddisk.h:
+	- Added a function to retrieve the interface
+
+	src/ui_text.c:
+	src/ui_text.h:
+	- Added a MESS specific UI string (within #ifdef MESS of course)
+
+	src/usrintrf.c:
+	- Parameterized the setdipswitches() call; so that a menu that
+	looks like the DIP switch menu can easily be made with different IPT_*
+	values (MESS has a configuration menu that functions a lot like the DIP
+	switch menu)
+
+	src/artwork.c:
+	- Small fix to allow the UI to be drawn if the artwork system is
+	active but no artwork is present (not an issue for MAME)
+
+	src/mamedbg.c:
+	- Cleanup and fix of set_ea_info() so that negative offsets of 8
+	or 16 bits do not have extraneous FF's in front of them.
+	- More proper fix to the scanline display bug that prevented
+	registers from being edited when the scanline display was on.
+
+	src/cpu/hd6309/6309dasm.c:
+	- Better message for when invalid opcodes are disassembled
+
+	src/artwork.c
+	src/artwork.h
+	- Fixed crashing bug with clones
+
+	src/inptport.c:
+	- Adds some MESS specific IPT defaults (within #ifdef MESS)
+	- Modified input_port_allocate() so that PORT_BITX declarations
+	that specify JOYCODE_a_BUTTONb for their default codes will also get
+	JOYCODE_MOUSE_a_BUTTONb or'd in.
+
+	src/input.c:
+	src/input.h:
+	- Added seq_set_4() and seq_set_5()
+
+	src/windows/video.c:
+	- Changed render_frame() so that throttle_speed() will also be
+	called when game_is_paused is set.  This prevents MAME from busy looping
+	when paused.
+
+Fixed Remaining Protection problems in TMNT2 and Sunset Riders, Fixed Combat School
+Trackball sets from Crashing, Fixed Escape Kids Spries, Fixed Sticky Sprites in
+Detana! Twinbee, Fixed Sprite Lag in some games [Acho A. Tang]
+	src/drivers/combatsc.c
+	src/vidhrdw/konamiic.c
+	src/vidhrdw/konamiic.h
+	src/palette.c
+	src/palette.h
+	src/drivers/tmnt.c
+	src/vidhrdw/tmnt.c
+
+Misc Improvements / Cleanups / Fixes [Acho A. Tang]
+	src/drivers/aeroboto.c
+	src/vidhrdw/aeroboto.c
+	src/drivers/bwing.c
+	src/vidhrdw/bwing.c
+	src/drivers/equites.c
+	src/vidhrdw/equites.c
+	src/machine/equites.c
+	src/drivers/halleys.c
+	src/drivers/sgladiat.c
+	src/drivers/sidearms.c
+	src/vidhrdw/sidearms.c
+	src/vidhrdw/spdodgeb.c
+	src/drivers/wecleman.c
+	src/vidhrdw/wecleman.c
+	src/drivers/wiz.c
+
+Fixed Background Graphics in Trackball version of WC90 [Angelo Salese]
+	src/drivers/wc90.c
+	src/vidhrdw/wc90.c
+	
+Fixed sound in Super Doubles Tennis [Pierpaolo Prazzoli]
+	src/drivers/btime.c
+
+New games supported:
+--------------------
+
+Asura Blade [Paul Priest]
+	missing sound, some priority errors
+	src/drivers/fuukifg3.c
+	src/vidhrdw/fuukifg3.c
+
+Gaia Crusaders [Paul Priest]
+	src/drivers/cave.c
+
+Street Heat [Dave Widel]
+	src/drivers/dkong.c
+
+New Clones supported:
+--------------------
+
+8 Ball Action (DkJr Kit) [Pierpaolo Prazzoli]
+	src/drivers/dkong.c
+
+0.72
+
+FAQ about new drivers added since 0.71
+--------------------------------------
+
+for Run and Gun you must hold down F2 and press F3 to init the Eeprom otherwise
+the game won't boot, the rungunu set doesn't work correctly.
+
+Megatech / Megaplay / NSS are preliminary, since the menu system doesn't yet work
+perfectly on Megatech I've marked all the games as non-working, Megaplay still
+doesn't boot so those are marked as Non-working, and the NSS menu isn't emulated
+at all yet so I also consider that to be Non-working, I've enabled these anyway
+as it may encourage others to help with the development, Mame is NOT turning into
+an emulator for Consoles, these are Arcade systems much like PlayChoice-10.
+
+Outrunners is currently still broken due to problems with the V60 and recent timer
+updates, sorry.
+
+The games using the sp0250 sound for speech still need samples for the sound
+effects, however samples for the speech are no longer needed with this update.
+
+General Source Changes
+----------------------
+
+Work Around for Genix Protection + tilemap scroll making it playable [Paul Priest]
+	src/drivers/pirates.c
+	src/vidhrdw/pirates.c
+
+Various Conversions to Tilemaps [Curt Coder]
+	some were left out as they need checking, or devs didn't like them
+
+Various Dipswitch Fixes [Iigo Luja]
+
+Cleanups to Darius Video [Acho A. Tang]
+	src/vidhrdw/warriorb.c
+	src/vidhrdw/taitoic.c
+	src/vidhrdw/taitoic.h
+	src/vidhrdw/ninjaw.c
+	src/vidhrdw/darius.c
+
+6821 PIA fixes [Martin Adrian]
+	src/machine/6821pia.c
+	src/machine/6821pia.h
+
+Kludge for Combat School Music [Acho A. Tang]
+	might be an fm.c bug, being investigated by Jarek
+
+Some Cleanups in itech32.c, dogfgt.c [Brian Troha]
+
+New Clones supported:
+--------------------
+
+Zero Point (alt) [Brian Troha]
+	src/drivers/unico.c
+
+
+0.71u3p
+
+
+General Source Changes
+----------------------
+
+Cleaned up tmnt.c cuebrick addition, added SSriders bootleg (not working) [R.Belmont]
+	src/drivers/tmnt.c
+	src/vidhrdw/tmnt.c
+
+Added some Slapstics used in Europe / Japan [Aaron Giles]
+	src/machine/slapstic.c
+
+This patch adds some minor callbacks to the artwork system in order to
+enable some MESS specific functionality without polluting artwork.c with
+a bunch of ugly #ifdef MESS's. [Nathan Woords]
+	src/drivers/artwork.c
+	src/drivers/artwork.h
+	src/mame.c
+
+Fixed Tile flip in mermaid driver [Pierpaolo Prazzoli]
+	src/vidhrdw/mermaid.c
+
+NSS Fixes [Pierpaolo Prazzoli]
+	src/cpu/g65816/g65816.c
+	src/drivers/nss.c
+	src/machine/snes.c
+
+Vector Cleanups / Improvements [Frank Palazzolo]
+	- Removed VEC_SHIFT and "magic numbers" stuff from all drivers, 
+	vector.c: all fixed point stuff is now always 16.16.
+	- Removed "bad trench vectors hack" from Star Wars which I created in 
+	1997.  Appears not to be necessary any more :)
+	- Moved flipping and swapping API stuff from vector.c to avgdvg.c, 
+	this is specific to tempest and quantum only.
+	- Added clipping to Sega games per the schematics
+	- Using floating point in vector.c to do scaling.
+	- Removed dead code using Machine->orientation from vector.c
+	- Added capability to register an external vector renderer.
+	src/drivers/quantum.c
+	src/drivers/tempest.c
+	src/machine/starwars.c
+	src/vidhrdw/avgdvg.c
+	src/vidhrdw/avgdvg.h
+	src/vidhrdw/aztarac.c
+	src/vidhrdw/cchasm.c
+	src/vidhrdw/cinemat.c
+	src/vidhrdw/sega.c
+	src/vidhrdw/vector.c
+	src/vidhrdw/vector.h
+
+Fixed compile problems [Brad Oliver]
+	src/vidhrdw/bigevglf.c
+	src/vidhrdw/segaic24.c
+
+re-written and merged the drivers for Sprint 1/2 and Dominos [Stefan Jokisch]
+	src/drivers/sprint2.c
+	src/vidhrdw/sprint2.c
+
+Fixed some problems with Vector Patch [Frank Palazzolo]
+	src/drivers/quantum.c
+	src/drivers/tempest.c
+	src/vidhrdw/sega.c
+	src/vidhrdw/avgdvg.c
+
+Various Fixes [Nathan Woods]
+	src/fileio.c:
+	- Fixes a bug in mame_fgetc() when reading characters between
+	0x80 and 0xFF
+
+	src/hash.c:
+	src/hash.h:
+	- Adds a new function, hash_verify_string(), that takes a string
+	and checks to see if it is a valid hash string
+
+	src/mame.c:
+	- Added a consistency check that uses hash_verify_string() to
+	make sure all of the hash strings are valid
+
+Tiger Heli MCU simulation improvements [Angelo Salese]
+	src/drivers/slapfght.c
+	src/machine/slapfght.c
+
+Coverted Text Layer of Act Fancer to Tilemaps [Angelo Salese]
+	src/vidhrdw/actfancr.c
+
+Fix drawgfx 1:1 optimization [Olivier Galibert]
+	src/drawgfx.c
+
+Fixed i803x jumps [Olivier Galibert]
+	src/cpu/i8039/8039dasm.c
+	src/cpu/i8039/i8039.c
+
+sp0250 sound / g80 speech board emulation [Olivier Galibert]
+	src/drivers/sega.c
+	src/drivers/segar.c
+	src/includes/sega.h
+	src/mame.mak
+	src/rules.mak
+	src/sndhrdw/sega.c
+	src/sndhrdw/segar.c
+	src/sndintrf.c
+	src/sndintrf.h
+	src/sndhrdw/segasnd.c
+	src/sndhrdw/segasnd.h
+	src/sound/sp0250.c
+	src/sound/sp0250.h
+
+Fixed Power Instinct Dips [Brian Troha]
+	src/drivers/powerins.c
+
+Improved Risky Challenge decryption [Angelo Salese]
+	src/machine/irem_cpu.c
+
+Misc Patches [Nathan Woods]
+	src/inptport.c:
+	src/inptport.h:
+	- Raises the maximum number of ports to thirty
+	- Adds a few MESS specific IPT_* types (within #ifdef MESS)
+
+	src/cpu/i86/i86.c:
+	src/cpu/i86/i286.c:
+	- Adds state save support
+
+	src/includes/snes.h:
+	src/machine/snes.c:
+	- Update from Anthony Kruize (MESS SNES driver author)
+
+Starsweep GFX improvements [smf]
+	src/cpu/mips/mips.c
+	src/cpu/mips/mipsdasm.c
+	src/driver.c
+	src/drivers/namcos11.c
+	src/drivers/zn.c
+	src/includes/psx.h
+	src/vidhrdw/psx.c
+
+Fixed register editing when Scanline display is enabled in debugger [Nathan Woods]
+	src/mamedbg.c
+
+Fixed the BCD conversion when using the Decimal Flag in ADC and SBC opcodes
+in the G65816 CPU core.This fixes at least the Act Raiser timer/score bugs. [Angelo Salese]
+	src/cpu/g65816/g65816.c
+	src/cpu/g65816/g65816cm.h
+	src/cpu/g65816/g65816op.h
+
+Added correct roms to Genix but it still doesn't work due to protection [David Haywood]
+	src/drivers/pirates.c
+
+Improvements to Megatech emulation, although its still far from being correct and still
+under development, will be split from segac2.c once finished [Barry Rodewald, David Haywood]
+	src/drivers/segac2.c
+	src/vidhrdw/segac2.c
+
+New games supported:
+--------------------
+
+Power Instinct 2 [Olivier Galibert, ShiRiRu]
+	todo: figure out why we need a rom patch to avoid an ingame problem
+	src/drivers/cave.c
+	src/vidhrdw/cave.c
+
+Sprint 4 [Stefan Jokisch]
+	src/drivers/sprint4.c
+	src/vidhrdw/sprint4.c
+
+Pit 'n' Run [Tomasz Slanina, Pierpaolo Prazzoli]
+	missing analog sounds
+	src/drivers/pitnrun.c
+	src/machine/pitnrun.c
+	src/vidhrdw/pitnrun.c
+
+Special Forces [Pierpaolo Prazzoli]
+	no sound, missing rom?
+Eight Ball Action [Pierpaolo Prazzoli]
+	bad colours, missing proms
+	src/drivers/dkong.c
+	src/vidhrdw/dkong.c
+
+Imago [Pierpaolo Prazzoli]
+	gfx problems, bad colours due to missing proms
+	src/drivers/fastfred.c
+	src/vidhrdw/fastfred.c
+	src/includes/fastfred.h
+
+Sengoku Mahjong [Angelo Salese]
+	src/drivers/sengokmj.c
+	src/vidhrdw/sengokmj.c
+
+New Clones supported:
+--------------------
+
+Shuffle Shot 1.37 [Brian Troha]
+WC Bowling 1.61 [Brian Troha]
+	src/drivers/itech32.c
+
+Sprint 2 (set 2) [Stefan Jokisch]
+	src/drivers/sprint2.c
+
+Parodius (World) [Brian Troha]
+	src/drivers/parodius.c
+
+Acrobatic Dog Fight [Brian Troha]
+	src/drivers/dogfgt.c
+
+Sunset Riders (bootleg) [R.Belmont]
+	doesn't work
+	src/drivers/tmnt.c
+
+Pit Fighter (Japan) [Aaron Giles]
+	src/drivers/atarig1.c
+
+Various CPS2 clones [Razoola]
+	src/drivers/cps2.c
+	src/vidhrdw/cps1.c
+	
+0.71u2
+
+General Source Changes
+----------------------
+
+Some progress on MegaTech emulation [David Haywood]
+	menu is now displayed, but carts not recognised, display currently controllled
+	by a dipswitch, will be changed later, enabled the other games on the driver
+	while work is done, these might be disabled for 0.72
+	src/drivers/segasyse.c
+	src/vidhrdw/segasyse.c
+	src/drivers/segac2.c
+	src/vidhrdw/segac2.c
+	src/includes/segac2.h
+
+Fixes to some NeoGeo sets [Razoola]
+	98e -> 98, -98a 99 <-> 99a 
+	src/drivers/neogeo.c
+
+Fixed Sound Chips in lsasquad [Jarek Burczynski]
+	src/drivers/lsasquad.c
+
+Fixed Loading of Landmaker (prototype) [David Haywood]
+	src/drivers/taito_f3.c
+
+Converted Some Drivers to Tilemaps [Curt Coder]
+	src/drivers/bogeyman.c
+	src/vidhrdw/bogeyman.c
+	src/drivers/funkybee.c
+	src/vidhrdw/funkybee.c
+	+ more
+
+Cleaned Up some Konami GX rom loading [R.Belmont]
+	src/drivers/konamigx.c
+
+Various Changes [Nathan Woods]
+	src/cpu/jaguar/jaguar.c
+	src/includes/jaguar.h
+	src/vidhrdw/jaguar.c
+	src/vidhrdw/jagobj.c
+	- Adds save state support to Cojag
+	- Disables certain error logging and speedup hacks under MESS
+	- get_jaguar_memory() now based on memory_get_read_ptr()
+	- Jaguar blitter won't crash if it is instructed to blit to a
+	  weird address
+
+	src/windows/winmain.c
+	- Moved helpfile name into a constant
+
+	src/mame.c
+	- Minor tweaks in #ifdef MESS, and #ifndef MESS'ed a consistency
+	  check inapprpriate for MESS
+
+	src/inptport.c
+	src/inptport.h
+	- Added very small hooks for MESS
+
+	src/input.c
+	- Changed seq_name() so that instead of saying "<KEY> or n/a",
+	  it will say "<KEY>"
+
+Cpu Interrupt Improvements fixing the Exidy 440 games (Chiller etc.), Ultimate
+Tennnis, and the Seibu Sound System [Aaron Giles]
+	src/cpuint.c
+	src/sndhrdw/seibu.c
+
+Fixed Reset in robokid when time runs out (robokid37b15red) [Tomasz Slanina]
+	src/drivers/omegaf.c
+
+Stopped Nova2001 from resetting when a coin is inserted [Tomasz Slanina]
+	if you insert coins too quickly the game still resets, its probably
+	just the way it was, the code for this part was changed in the clone
+	src/drivers/nova2001.c
+
+Some Dipswitch Fixes [Iigo Luja]
+	src/drivers/rohga.c
+	src/drivers/deadang.c
+
+Changed way Snapshot code works [Nathan Woods]
+
+Huge Improvements in Prop Cycle (Namco System 22) [Phil Stroffolino]
+	Changes include:
+	- pulled out matrix3d to its own module
+	- near plane clipping
+	- perspective correct textures
+	- preliminary lighting (all or nothing)
+	- gamma correction
+	- preliminary fader support
+	- per polygon and per object depth bias
+	- sprite-polygon priority
+	- two-sided polygon flag
+	- tile flip attributes
+	- tilemap color bank
+	- improved steering responsiveness
+	- camera zoom and pan feature
+	- fixes to display list parsing
+	- corrected rotation mappings for System22/21
+	src/drivers/namcos22.c
+	src/vidhrdw/namcos22.c
+	src/includes/namcos22.h
+	src/vidhrdw/namcos21.c
+	src/vidhrdw/namcos3d.c
+	src/includes/namcos3d.h
+	src/vidhrdw/matrix3d.c
+	src/vidhrdw/matrix3d.h
+
+Stopped Sprites being hidden by track in fourtrax [Phil Stroffolino]
+	src/vidhrdw/namcos2.c
+
+Fixed CPS2 raster effect (xmvsf069agre) [ShiRiRu]
+	src/drivers/cps2.c
+	src/vidhrdw/cps1.c
+
+Added Missing Resources
+	src/info.c
+	
+	
+
+New games supported:
+--------------------
+
+Xor World (prototype) [Manuel Abadia]
+	src/drivers/xorworld.c
+	src/vidhrdw/xorworld.c
+	src/sound/saa1099.c
+	src/sound/saa1099.h
+
+Big Event Golf [Tomasz Slanina, Jarek Burczynski]
+	src/drivers/bigevglf.c
+	src/vidhrdw/bigevglf.c
+	src/machine/bigevglf.c
+
+Strike Bowling [Tomasz Slanina, Jarek Burczynski]
+	lacks analog sounds, in progress
+	src/drivers/sbowling.c
+
+Super Speed Race Junior [Tomasz Slanina]
+	bad colours due to missing proms
+	src/drivers/ssrj.c
+	src/vidhrdw/ssrj.c
+
+Great Guns [Jarek Burczynski]
+	graphics leave trails
+	src/drivers/mazerbla.c
+
+Taisen Hot Gimmick 3 Digital Surfing [David Haywood]
+	src/drivers/psikyo4.c
+
+Actraiser (Nintendo Super System) [MESS, Pierpaolo Prazzoli, David Haywood]
+	just to show the current status, has no menu system emulated, still being
+	worked on, no sound, everything else on the system has been left as 
+	testdrivers
+	src/drivers/nss.c
+	src/vidhrdw/snes.c
+	src/machine/snes.c
+	src/sndhrdw/snes.c
+	src/includes/snes.h
+
+Genix [David Haywood]
+	missing gfx / sound roms, might work with them
+	src/drivers/pirates.c
+
+New clones supported
+--------------------
+
+Cowbows of Moo Mesa (bootleg) [R.Belmont]
+	no sprites yet
+	src/drivers/moo.c
+
+Cue Brick (Japan Ver. D) [R.Belmont]
+	I suspect its not Japan
+	src/drivers/tmnt.c
+	src/vidhrdw/tmnt.c
+
+Pest Place (Mario Bros bootleg) [Pierpaolo Prazzoli]
+	bad colours, some bad gfx etc.
+	src/drivers/dkong.c
+	src/vidhrdw/dkong.c
+
+Area 51 / Maximum Force Duo (R3000) [Brian A Troha]
+	speed hack needs doing
+	src/drivers/cojag.c
+
+New TESTDRIVERS in source
+-------------------------
+
+Little Casino [Pierpaolo Prazzoli, David Haywood]
+	inputs, video etc. needs finishing
+	src/drivers/ltcasino.c
+
+Super Draw Poker [Pierpaolo Prazzoli]
+	needs inputs finishing, need to work out if its a gambling game, if so it will
+	be removed
+	src/drivers/supdrapo.c
+	
+
+0.71u1
+
+General Source Changes
+----------------------
+
+Cleaned Up and Fixed filenames in Namco System 11 driver [smf]
+	src/drivers/namcos11.c
+
+Added Cocktail Mode to Mole Attack [Pierpaolo Prazzoli]
+	src/drivers/mole.c
+
+Fixed Mame not looking in Parent directory for Hard Drive Images [Stefan Jokisch]
+	src/mame.c
+	src/audit.c
+
+Converted Drivers to use Tilemaps [Curt Coder]
+	src/drivers/rocnrope.c
+	src/vidhrdw/rocnrope.c
+	src/drivers/nova2001.c
+	src/vidhrdw/nova2001.c
+	src/drivers/hanaawas.c
+	src/vidhrdw/hanaawas.c
+
+Improved Genesis Emulation a bit in preparation for MegaTech / MegaPlay,
+sound code based on MESS [David Haywood]
+	src/drivers/segac2.c
+	src/vidhrdw/segac2.c
+
+Improvements to GI Joe [Acho A. Tang]
+	tilemap.h,tilemap.c
+	 - added tilemap_get_transparency_data() for transparency cache
+	   manipulation
+
+	vidhrdw\konamiic.c
+	 - added preliminary K056832 tilemap<->linemap switching and tileline
+	   code
+
+	drivers\gijoe.c
+	 - updated video settings, memory map and irq handler
+	 - added object blitter
+
+	vidhrdw\gijoe.c
+	 - completed K054157 to K056832 migration
+	 - added ground scroll emulation
+	 - fixed sprite and BG priority
+	 - improved shadows and layer alignment
+
+Improvements to Run and Gun making it playable (single screen game only) [Acho A. Tang]
+	drivers\rungun.c (this file)
+	 - mem maps, device settings, component communications, I/O's, sound...etc.
+
+	vidhrdw\rungun.c
+	 - general clean-up, clipping, alignment
+
+	vidhrdw\konamiic.c
+	 - missing sprites and priority
+
+Added missing rowselect effect to toaplan2 driver (bbakraid, batrider) [David Haywood]
+	src/vidhrdw/toaplan2.c
+
+Compiler Fixes [Bryan McPhail]
+	src/vidhrdw/raiga.c
+
+Compiler Fixes [Brad Oliver]
+	src/drivers/system24.c
+	src/vidhrdw/system24.c
+
+New games supported:
+--------------------
+
+Sonic (MegaTech, MegaPlay) [David Haywood]
+	just to show the current status, megatech has no menu system emulated, megaplay doesn't boot,
+        everything else on the systems has been left as testdrivers
+	src/drivers/segac2.c
+	src/vidhrdw/segac2.c
+
+
+New clones supported
+--------------------
+
+Landmaker (World prototype) [Bryan Mcphail]
+	src/drivers/taito_f3.c
+
+
+0.71
+
+Everything from 0.70u1 - u5 (see details below) as well as
+
+General Source Changes
+----------------------
+
+Fixed MultiPCM banking for Stadium Cross [R.Belmont]
+	src/drivers/multi32.c
+	src/sound/multipcm.c
+	src/sound/multipcm.h
+
+Improved Ay8910 Noise Generator [Jarek Burczynski]
+	src/sound/ay8910.c
+
+Corrected some filenames for Ajax [Brian A. Troha]
+	src/drivers/ajax.c
+
+Improved Graphics in Strato Fighter and Super Pinball Action [Leon van Rooij]
+	src/drivers/raiga.c
+	src/vidhrdw/raiga.c
+	src/drivers/spbactn.c
+	src/vidhrdw/spbactn.c
+	src/drawgfx.c
+
+Converted a bunch of drivers to tilemaps, fixed dipswitches etc. [Curt Coder]
+
+New games supported:
+--------------------
+
+Boxer (prototype) [Stefan Jokisch]
+	src/drivers/boxer.c
+	src/vidhrdw/boxer.c
+
+Star Sweep [smf, MooglyGuy]
+	src/drivers/namcos11.c
+	src/drivers/psx.c
+	src/vidhrdw/psx.c
+	+ various other source files
+
+Magical Spot [Pierpaolo Prazzoli]
+	src/drivers/cosmic.c
+
+New clones supported
+--------------------
+
+Sengekis Striker (Asia) [Brian A. Troha, David Haywood]
+	src/drivers/suprnova.c
+	src/vidhrdw/suprnova.c
+
+Maximum Force (v1.05) [Brian A. Troha]
+	note: there seems to be a problem with the way mame handles chd filenames for clones
+	src/drivers/cojag.c
+
+Space Invasion (Europe Original?) [Brian A. Troha]
+	src/drivers/commando.c
+
+Underfire (US and Japan) [Brian A. Troha]
+	src/drivers/undrfire.c
+
+Puzzle Bobble (NeoGeo) (set 2) [Razoola]
+	src/drivers/neogeo.c
+
+
+New TESTDRIVERS in source
+-------------------------
+
+Various ZN based systems [smf, MooglyGuy]
+
+Rougien [..]
+	video hardware emulation needs finishing
+	src/drivers/mermaid.c
+
+0.70u5
+
+Please, if you submit dipswitch changes to me make sure they've been tested with a DEBUG compile, fixing
+'fixed' dipswitches is time consuming, there are extra warnings when you attempt to run Mame in a DEBUG
+compile.
+
+General Source Changes
+----------------------
+
+Some Dipswitch Fixes [Iigo Luja]
+	src/drivers/gameplan.c
+	src/drivers/cps1.c (kodj064gra)
+	src/drivers/ms32.c
+	src/drivers/freekick.c
+	src/drivers/wwfwfest.c (wwfwfest055gra partial?)
+	src/drivers/exidy.c (venture37b8gra)
+	src/drivers/suprnova.c
+	src/drivers/seta.c
+	src/drivers/system16.c
+
+Improvements and Fixes to Strato Fighter / Raiga [David Haywood, TheGuru, Leon van Rooij]
+	there are still some graphics problems (priority, incomplete alpha blending effects, bad tiles)
+	src/drivers/gaiden.c
+	src/vidhrdw/gaiden.c
+
+Fixed some Misplaced Sprites in Tricky Doc [Pierpaolo Prazzoli]
+	src/vidhrdw/sauro.c
+
+Changed drivers to use mame_rand for random numbers [Barry Rodewald]
+	src/drivers/artmagic.c
+	src/drivers/centiped.c
+	src/drivers/namcona1.c
+	src/drivers/namconb1.c
+	src/machine/namcos1.c
+
+A Few Namco Fixes for things broken in u4 [Phil Stroffolino]
+	src/vidhrdw/namcos2.c
+	src/machine/namcos2.c
+
+Changed Steel Gunner to use Correct Rom [Bryan McPhail]
+	src/drivers/namcos2.c
+
+Improved ncv1 filenames [TheGuru]
+	src/drivers/namcond1.c
+
+Fixed Sprites in simpsons [Acho A Tang]
+	src/drivers/simpsons.c
+	src/machine/simpsons.c
+	src/vidhrdw/simpsons.c
+	src/vidhrdw/konamiic.c
+	src/vidhrdw/konamiic.h
+
+Various Changes [Nathan Woods]
+	src/fileio.c:
+	- Introduced a "debug cookie"; when in debug mode, puts a cookie
+	value in the mame_file structure to prevent files from being closed
+	twice without an assertion
+
+	src/windows/window.c:
+	- Fixes a bug in visible area changing in windowed, non-stretch
+	mode.  Previously, when the visible area changed, the code would simply
+	change the visible area, and look at the resulting window size and tweak
+	it accordingly with win_adjust_window().  The problem with this is that
+	if you have a sequence where the visible area is made larger, then
+	smaller again, what would happen is you wouldn't get the original window
+	size; you would simply get the enlarged window with a bunch of buffer
+	area.  Now instead of calling win_adjust_window(), I added code that
+	preserves the "scale" factors, and the space between the emulation
+	rectangle and the window client area.
+
+	src/windows/winddraw.h:
+	src/windows/winddraw.c:
+	src/windows/wind3d.c:
+	- Added a call win_ddraw_fullscreen_margins() that given the
+	dwWidth and dwHeight parameters of a DirectDraw surface, comes up with a
+	RECT that represents the margins.  For MAME, this is a very simple
+	operation (a rectangle from (0,0)-(dwWidth,dwHeight)) (and the
+	implementation that I've submitted is corrspondingly simple), but in
+	MESS the window can have a menu bar so this operation works differently.
+	I've also modified winddraw.c and wind3d.c to use this call.
+
+	src/timer.c:
+	src/timer.h:
+	- Changes timers so that they are now 'mame_timer *' instead of
+	'void *'.  mame_timer is an opaque structure, similar to mame_file in
+	fileio.h.  I didn't update any code using timers yet; it doesn't seem to
+	me that there isn't a rush and since they used 'void *' before,
+	everything compiles just fine.  I hope noone objects to this one.
+
+	src/vidhrdw/jaguar.c:
+	- Fixes a potential crash in jaguar_tom_regs_w() (while this
+	crash doesn't occur under normal execution of the cojag games though, it
+	can occur if modified ROMs are being used).
+
+	src/sound/fmopl.c:
+	Added #if/#endif pair
+
+Changed message for Double Clicking on EXE slightly [Leon van Rooij]
+	src/windows/winmain.c
+
+
+New games supported:
+--------------------
+
+Stadium Cross [Jason Lo]
+	there seem to be some sound problems
+	src/drivers/multi32.c
+	src/drivers/system32.c
+	src/vidhrdw/system32.c
+
+R2D Tank [Pierpaolo Prazzoli]
+	src/drivers/r2dtank.c
+
+New TESTDRIVERS in source
+-------------------------
+
+Counter Run (bootleg)
+	encrypted?
+	src/drivers/freekick.c
+
+New clones supported
+--------------------
+
+Some namco ones that were forgotten last time
+
+
+0.70u4
+
+General Source Changes
+----------------------
+
+Tilemap viewer now displays a more logical ordering for "tilemap#1", "tilemap#2", etc. [Phil Stroffolino]
+Broadened support for palette_offset, and made it work in tilemap viewer [Phil Stroffolino]
+	src/tilemap.c
+
+Various Namco Improvements [Phil Stroffolino]
+	- Improved Namco road emulation
+	- Speedup when ROZ layer rapidly switches palettes (Metal Hawk 2nd stage)
+	- Window registers in namconb1 sprite drawing (fixes the "Tank" stage of Point Blank
+	- lots of consolidation/cleanup in vidhdrw/namcos2.c
+	
+	src/drivers/namcoic.c
+	src/includes/namcoic.h
+	src/drivers/namconb1.c
+	src/vidhrdw/namconb1.c
+	src/includes/namconb1.h
+	src/drivers/namcos2.c
+	src/vidhrdw/namcos2.c
+	src/machine/namcos2.c
+	src/includes/namcos2.h
+	src/drivers/namcos21.c
+	src/vidhrdw/namcos21.c
+	src/drivers/namcos22.c
+	src/vidhrdw/namcos22.c
+	src/includes/namcos22.h
+	src/vidhrdw/namcos3d.c
+	src/includes/namcos3d.h
+
+Silent Dragon Dipswitch Fixes [Brian A. Troha]
+	src/drivers/taito_b.c
+
+A Few Data East Rom Name Fixes / Board Info [Brian A. Troha]
+	src/drivers/deco32.c
+	src/vidhrdw/deco16ic.c
+
+
+New games supported:
+--------------------
+
+Final Lap [Phil Stroffolino]
+Suzuka 8 Hours 2 [Phil Stroffolino]
+Four Trax [Phil Stroffolino]
+	some gfx / sound problems but mostly working
+	src/drivers/namcos2.c
+	+ the other namco files listed above
+
+Final Lap 2 [Phil Stroffolino]
+Suzuka 8 Hours [Phil Stroffolino]
+	not working due to bad / missing roms and / or incomplete emulation but enabled anyway
+	src/drivers/namcos2.c
+	+ the other namco files listed above
+
+
+Final Lap 3 [Phil Stroffolino]
+	not working due to incomplete emulation but enabled anyway
+	src/drivers/namcos2.c
+	+ the other namco files listed above
+
+New TESTDRIVERS in source
+-------------------------
+
+Cyber Commando [Phil Stroffolino]
+Air Combat 22 [Phil Stroffolino]
+Cyber Cycles [Phil Stroffolino]
+Time Crisis [Phil Stroffolino]
+	very preliminary
+	src/drivers/namcos22.c
+	+ the other namco files listed above
+
+R2D Tank [Pierpaolo Prazzoli]
+	still being worked on
+	src/drivers/r2dtank.c
+
+
+
+0.70u3
+
+General Source Changes
+----------------------
+
+Allowed Region to be selected via Dipswitch on Banpresto games in cave.c [David Haywood]
+	src/drivers/cave.c
+
+Message Box prompting the user to read windows.txt if MAME.EXE is double clicked on instead of being run
+from the command line [Leon van Rooij]
+	note, this still needs testing on Win9x, it works as expected on 2000/XP, if it creates new
+	problems it might not be included.  Seems to work on 98
+	src/windows/winmain.c
+
+Fixed Colours in Mustache Boy with new Proms [Tomasz Slanina]
+	src/drivers/mustache.c
+	src/vidhrdw/mustache.c
+
+Fixed Colours in Tricky Doc with new Proms [David Haywood]
+	src/drivers/sauro.c
+
+Added Colour Map to Enigma 2, swapped sets around, used a more sensible cpu freq [Tomasz Slanina]
+	src/drivers/enigma2.c
+
+Fixed Trackball controls in Country Club [Tomasz Slanina]
+	src/drivers/snk.c
+
+New games supported:
+--------------------
+
+Battle Cry [Tomasz Slanina]
+	some tiny gfx glitches
+	src/drivers/homedata.c
+	src/vidhrdw/homedata.c
+	src/includes/homedata.h
+
+New clones supported
+--------------------
+
+Dock Man (parent of portman) [TheGuru]
+	src/drivers/thepit.c
+
+
+0.70u2
+
+General Source Changes
+----------------------
+
+Fixed a few minor problems in the Wolf Pack Driver [Stefan Jokisch]
+	src/drivers/wolfpack.c
+	src/vidhrdw/wolfpack.c
+
+Fixed ports in some TESTDRIVERS so there are no complaints with the Sanity Checks [smf]
+	src/drivers/coolpool.c
+	src/drivers/taitoair.c
+	src/cpu/yms32025/tms32025.h
+	
+Various Sound Improvements to YM2610, YM2608, Y8950 [Jarek Burczynski]
+	Inspired by Frits Hilderink (NLMSX emulator author) I attempted to:
+	- improve support of the ymdeltat module for the status registers (YM2610,YM2608,Y8950),
+	- implement x1bit/x8bit DRAM usage for the ADPCM samples,
+	- implement memory read/write via deltat (Y8950 and YM2608)
+	- ADPCM synthesis in 'slave' mode (CPU controlled, instead of memory based).
+
+	I made some tests but the changes are quite big so please test them before including. I'm sure the
+	Y8950 will be tested by NLMSX authors too.
+
+	src/sound/ymdelta.c
+	src/sound/ymdelta.h
+	src/sound/fmopl.c
+	src/sound/fmopl.h
+	src/sound/fm.c
+	src/sound/3812intf.c
+	src/sound/3812intf.h
+	
+Some Dipswitch / Input Fixes [Curt Coder]
+	src/drivers/twin16.c
+	src/drivers/sega.c
+	src/drivers/safarir.c
+	src/drivers/playch10.c
+	src/drivers/nmk16.c
+	
+Some Dipswitch / Input Fixes [El Condor]
+	src/drivers/crimfght.c
+	src/drivers/cps1.c
+	src/drivers/contra.c
+	src/drivers/astrocde.c
+	src/drivers/8080bw.c
+	
+Some Dipswitch Fixes [Iigo Luja]
+	src/drivers/toaplan2.c
+	src/drivers/taito_b.c
+	src/drivers/deniam.c
+	src/drivers/sg1000a.c
+	
+Fixed i86 DAA opcodes + more [Nathan Woods]
+	src/usrintrf.c:
+	src/usrintrf.h:
+	- Renames display_fps() to ui_display_fps() and makes it
+	non-static
+	
+	src/windows/fileio.c:
+	- In osd_fopen(), if a file is opened with mode "r",
+	FILE_SHARE_READ will be passed to the dwShareMode parameter of
+	CreateFile().  This allows other programs to read any files that MAME
+	opens for read only.
+
+	src/cpu/i86/instr86.c
+	src/cpu/nec/nec.h
+	- i86 DAA fixes
+
+Corrected Green Beret Rom Names [Grald]
+	src/drivers/gberet.c
+
+Preliminary MCU simulation for Paddle 2 [Angelo Salese]
+	src/drivers/arkanoid.c
+	
+Fixed Audit with Optional Roms [Nathan Woods]
+	src\audit.c
+	src\audit.h
+	
+New games supported:
+--------------------
+
+Enigma 2 [Pierpaolo Prazzoli, Tomasz Slanina]
+	No Sound (bad rom?) could be merged with 8080bw?
+	src/drivers/enigma2.c
+
+
+0.70u1
+
+General Source Changes
+----------------------
+
+Fixed Night Striker dips [Brian A. Troha]
+	src/drivers\taito_z.c
+	
+This fixes the data size parameter of the DUMP command in the debugger [smf]
+This fixes the bug where SAVE only worked on 8bit cpus in the debugger [smf]
+Made dbg_show_scanline the default [Bryan McPhail]
+	src/mamedbg.c
+
+Changed a few MAME core files for MESS (shouldn't change Mame behavior) [Nathan Woods]
+	src/usrintrf.h:
+	src/usrintrf.c:
+	- Adds four new calls to control showing the fps count and the
+	profiler:
+	void ui_show_fps_set(int show);
+	int ui_show_fps_get(void);
+	void ui_show_profiler_set(int show);
+	int ui_show_profiler_get(void);
+	
+	src/common.h:
+	- Adds ROM_LOAD32_DWORD
+	
+	src/machine/idectrl.c:
+	src/machine/idectrl.h:
+	src/harddisk.c:
+	src/harddisk.h:
+	src/hdcomp.c:
+	- Enhances the hard disk code to support sector sizes other than
+	512 bytes (a non-IDE harddisk in MESS for one of the TI systems uses
+	this).  src/machine/idectrl.c has been modified to take this into
+	account; it requires that HD images be 512 bytes.  The new code is fully
+	backwards compatible with old CHDs that do not have a sector size within
+	them.  
+
+Tiny changes to enable easy compiling under VC6/7 & older non-c99 compilers [Bryan McPhail]
+	src/drivers/konamigx.c
+	src/drivers/mystwarr.c
+	src/hdcomp.c
+	src/windows/fileio.c
+	src/windows/wind3d.c
+	
+Konami Updates and Fixes (including fix for dbz / moo / simpsons crashes in 0.70) [Acho A. Tang]
+	src/drivers/moo.c
+	src/vidhrdw/moo.c
+	src/drivers/xexex.c
+	src/vidhrdw/xexex.c
+	src/vidhrdw/konamiic.c
+	src/vidhrdw/konamiic.h
+	
+Fixed some problems with the new alt. bios code [Chris Kirmse, Paul Priest]
+	src/common.c
+	src/info.c
+	
+Rewrote Wolf Pack driver based on schematics [Stefan Jokisch]
+	src/drivers/wolfpack.c
+	src/vidhrdw/wolfpack.c
+
+D3D Code fixes / Improvements [Leon van Rooij]
+	src/windows/wind3d.c
+
+New games supported:
+--------------------
+
+Grand Tour [Tomasz Slanina]
+	src/drivers/iqblock.c
+
+
+0.70
+
+This contains all the updates listed which were part of the source only diffs listed below
+(0.69a, 0.69b, 0.69u3) plus a few extra bits and pieces.  A couple of drivers still appear to
+be broken with the new timer system (deadang, artmagic for example) but hopefully most of the
+problems were ironed out.
+
+General Source Changes
+----------------------
+
+Konami GX Sound Improvements [R.Belmont]
+
+General Konami Updates [Acho A. Tang, R. Belmont]
+
+Various Dipswitch fixes / conversion of drivers to tilemaps [Curt Coder]
+
+Removed hacks from Oriental Legend [Olivier Galibert]
+	src\drivers\pgm.c
+
+Some D3D updates / fixes [Leon van Rooij]
+
+Sanity checks for Ports [Pierpaolo Prazzoli]
+	src\mame.c
+	
+Documentation updates [Santeri Saarimaa, Randolph, Leon van Rooij]
+
+Improved bios selection code, now -bios japan can be used with the NeoGeo driver for
+example [Paul Priest]
+
+New clones supported
+--------------------
+
+Korosuke Roller (clone of Crush Roller) [BUT, nono]
+	src\drivers\pacman.c
+	
+New TESTDRIVERS in source
+-------------------------
+
+DJ Boy [Phil Stroffolino]
+	not working due to protection
+	src\drivers\djboy.c
+	src\vidhrdw\djboy.c
+
+0.69u3 (0.69 Update 3)
+
+source diff, changed numbering system to ux instead of a,b,c because people were getting
+confused and thinking mame069b.zip (mame 0.69 _b_inary) was the updated version when it
+wasn't.
+
+misc fixes and improvements this time, no changes related to the timer system so as far
+as testing that goes this isn't an essential upgrade.
+
+if you use this code in your own build of Mame please make sure you use the correct
+version number to reflect the inclusion of this updated code.
+
+General Source Changes
+----------------------
+
+Direct 3D update to change the way cleanstretch is handled [Leon van Rooij]
+	-cleanstretch works like this:
+	-cleanstretch auto: let blitter decide, the same as -nocs in 0.69 (default).
+	-cleanstretch full: same as -cs in 0.69
+	-cleanstretch none: disable (won't look good with scanlines)
+	-cleanstretch horizontal: horz only
+	-cleanstretch vertical: vert only
+	
+Added Ozon 1 Prom [Pierpaolo Prazzoli]
+	src\drivers\galaxian.c
+	
+Added correct roms to Mighty Monkey (bootleg on Super Cobra Hardware) [Pierpaolo Prazzoli]
+	src\drivers\scobra.c
+
+Fixed some problems in the makefile for the xml2info program [Andrea Mazzoleni]
+	makefile
+	src\core.mak
+	
+Fixed crash in usclssic []
+	src\drivers\seta.c
+
+Fixed problem where controls stopped working after the first level in Tugboat [Tomasz Slanina]
+	src\drivers\tugboat.c
+
+Changed MULU timing in asm 68k core so that it matches the C ones [Razoola]
+	src\cpu\m68000\make68k.c
+
+Bug fix to loop addressing on YMF278B which helps stablise the tuning on looped samples
+(noticable in parts of s1945 at least). [OpenMSX]
+	src\sound\ymf278b.c
+	
+Fixed hedpanic sound banking []
+	src\drivers\esd16.c
+	
+Corrected various clocks in the vball driver [TheGuru]
+	src\drivers\vball.c
+
+New clones supported
+--------------------
+
+Field Day (now the parent of The Undoukai) [Tomasz Slanina]
+	src\drivers\40love.c
+
+King of Fighters '98 (alt M1) [Razoola]
+King of the Monsters (set 2) [Razoola]
+	src\drivers\neogeo.c
+	
+Various CPS2 clones [Razoola]
+	src\drivers\cps2.c
+	
+New TESTDRIVERS in source
+-------------------------
+
+Sparkman [Luca Elia]
+	not working, protection
+	src\drivers\suna8.c
+
+
+
+0.69b (0.69 Update 2)
+
+Another source diff update, this fixes some of the problems Mametesters discovered
+with the new timer code, please test this well too, if anything else is broken which
+worked in .69 let us know, it could be important.
+
+General Source Changes
+----------------------
+
+Fixed Dipswitches and Inputs in Atlantic City Action / Broadwalk Casion [Peter Storey]
+	src\drivers\pacman.c
+	
+Fixed a few Misc Typos [Santeri Saarimaa]
+	src\drivers\metro.c
+	src\drivers\oneshot.c
+	src\drivers\lethalj.c
+	
+Added 'Right' in Moon Shuttle [David Haywood]
+	src\drivers\galaxian.c
+
+Various fixes to the PIC16C5x core. [Quench]
+	src\cpu\pic16c5x\pic16c5x.c
+	src\cpu\pic16c5x\pic16c5x.h
+	src\cpuintrf.c
+	
+Sound working in BIGTWIN [Quench]
+	src\drivers\playmark.c
+	
+The use of the PIC HEX dumps for DRGNMST and BIGTWIN [Quench]
+	src\drivers\playmark.c
+	src\drivers\drgnmst.c
+
+Fixed a bug in the V60 CPU core causing it to break with the new timer system [Aaron Giles]
+	src\cpu\v60\v60.c
+	
+Fixed a problem in snprintf.c printing out floats with fractional partswith leading
+zeroes [Chris Kirmse]
+	src\windows\snprintf.c
+
+Fixed bug in K054539 causing bad vocals in Dadandarn [R.Belmont]
+	src\sound\k054539.c
+	
+Added PGM Calender [Pierpaolo Prazzoli]
+	src\drivers\pgm.c
+	
+Fixed a problem which caused sound to break in games using a YM2610 using the new timer
+system [Aaron Giles]
+	src\cpuint.c
+	
+Changed NeoGeo to use boost_interleave for tight CPU communications instead of throwing
+cyces away [Aaron Giles]
+	src\drivers\neogeo.c
+
+New games supported:
+--------------------
+
+Space Cruiser [Tomasz Slanina]
+	src\drivers\taitosj.c
+
+Mustache Boy [Tomasz Slanina, Nicola Salmoria]
+	previously a TESTDRIVER, decryption completed by Nicola
+	still bad colours and no sound due to missing roms / mcu?
+	src\drivers\mustache.c
+	src\vidhrdw\mustache.c
+	
+Evil Stone [Tomasz Slanina]
+	src\drivers\taito_l.c
+	
+Glass [Manuel Abadia]
+	this isn't playable due to protection but I've enabled it anyway
+	src\drivers\glass.c
+	src\vidhrdw\glass.c
+	
+Tri-Pool [David Haywood]
+	src\drivers\jack.c
+
+New clones supported
+--------------------
+
+Final Fight (Japan Set 2) [Razoola]
+	src\drivers\cps1.c
+	src\vidhrdw\cps1.c
+
+0.69a (0.69 Update 1)
+
+This version is provided as a source diff only, more releases like this may follow
+depending on how this one goes down, the intention is to allow people to have the
+latest code without the hassle and bandwidth requirements of a new binary.
+
+If you can't compile this then don't worry, normal releases will still happen, this
+doesn't change anything as normal release plans are concerned, please don't hassle
+whoever maintains your favourite port of Mame to add the updates here, not everybody
+is going to have time to make new binaries on a regular basis.
+
+General Source Changes
+----------------------
+
+Fixed eeprom in Head Panic [Paul Priest]
+	src\drivers\esd16.c
+
+Few tweaks/minor optimizations to MIPS3 Dynacrec [Aaron Giles]
+	src\x86drc.c
+	src\x86drc.h
+	src\cpu\mips\mips3drc.c
+
+Improved Save-State support for NeoGeo games [Mame32Plus]
+Changed NeoGeo Resolution to be 320 wide, this is correct, the glitches it causes
+are verified against a real MVS [David Haywood]
+Verified and corrected clock speeds etc. for NeoGeo [TheGuru]
+	src\drivers\neogeo.c
+	src\machine\neogeo.c
+	src\vidhrdw\neogeo.c
+	src\includes\neogeo.h
+	
+Removed analog input definition and encoded it directly from
+Joystick input in Metal Soldier Isaac II [Jarek Burczynski]
+	src\drivers\msisaac.c
+
+IDE Update adding support for a few things needed in the future [Aaron Giles]
+	src\machine\idectrl.c
+	src\machine\idectrl.h
+
+TMS32010 BIO fix [Aaron Giles]
+	src\cpu\tms32010\tms32010.h
+	
+C 68k core is now default, this fixes collisions in Assault []
+
+Fixed bug causing Timings to be broken when using D3D [Leon van Rooij]
+	src\windows\wind3d.c
+
+Optional XML output and xml to info converter (see xmlinfo.txt) [Andrea Mazzoleni]
+	use -listxml, converter isn't fully set up yet.
+	src\info.c
+	src\info.h
+	src\windows\fronthlp.c
+	src\xml2info\*
+
+A number of Changes to the Timer System [Aaron Giles]
+
+	All the CPU scheduling has moved into cpuexec.c and been taken out of
+	timer.c. A number of bugs relating to time tracking for suspended CPUs have
+	been fixed.
+
+	A side effect of all this is a change in the behavior of the CPU scheduling.
+	For the most part, games are fine with this. However, there were a few
+	exceptions:
+
+	* taitosj.c: timing of the MCU communication broke
+	* arkanoid.c: timing of the MCU communication broke
+	* harddriv.c: stunrun timing glitches, racedriv/steeltal/hdrivair broken
+	
+	(There may be more, but I haven't found them yet.)
+
+	The first two problems have been fixed, as has racedriv, but steeltal,
+	hdrivair, and stunrun still have issues.
+	
+	Oh, one other useful function I added is this:
+
+	   cpu_boost_interleave(double timeslice_duration, double boost_duration);
+
+	You call this if you need to temporarily crank up the interleave for a short
+	period of time in order to get CPU synchronization working. I used this in
+	arkanoid and taitosj to get the MCU communications working. For example, you
+	could say:
+
+	   cpu_boost_interleave(TIME_IN_USEC(1), TIME_IN_USEC(100));
+
+	which would interleave the CPUs on 1 usec boundaries for the next 100 usecs.
+	Even more useful is this:
+
+	   cpu_boost_interleave(0, TIME_IN_USEC(10));
+
+	A very small value (0) for the first parameter means "use perfect
+	synchronization", which should guarantee cycle-accurate synchronization for
+	the specified duration. Note that this is *really* slow, so you don't want
+	to be doing it too much!
+
+	Let us know ASAP if anything else is broken as a result of this update
+	
+	src\cpuintrf.c
+	src\cpuintrf.h
+	src\cpuexec.c
+	src\cpuexec.h
+	src\timer.c
+	src\timer.h
+	src\drivers\taitosj.c
+	src\machine\taitosj.c
+	src\machine\arkanoid.c
+	src\drivers\harddriv.c
+	src\machine\harddriv.c
+	src\sndhrdw\harddriv.c
+	
+New games supported:
+--------------------
+
+Guts'n [Paul Priest]
+	src\drivers\suprnova.c
+	src\vidhrdw\suprnova.c
+	
+Dragonball Z [R.Belmont]
+	src\drivers\dbz.c
+	src\vidhrdw\dbz.c
+	src\vidhrdw\konamiic.c
+	src\vidhrdw\konamiic.h
+
+Ozon I [Pierpaolo Prazzoli]
+	bad colours due to missing prom
+	src\drivers\galaxian.c
+
+New clones supported
+--------------------
+
+King of Fighters '95 (set 2) [Jarek Burczynski]
+	note, we use the new v1,c1,c2,c3,c4 from this set in the parent too
+	src\drivers\neogeo.c
+Kyros No Yakata (Japan) [David Haywood]
+	src\drivers\alpha68k.c
+Ambush (Tecfri) [David Haywood]
+	src\drivers\ambush.c
+Frisky Tom (set 2) [David Haywood]
+	src\drivers\seicross.c
+
+New TESTDRIVERS in source
+-------------------------
+
+Photo Y2K [ElSemi]
+	unemulated protection
+Stadium Cross [David Haywood]
+	graphic problems, no controls
+	src\drivers\multi32.c
+
+
+0.69
+
+Mainly a bugfix release for problems discovered with new features in 0.68,
+it also further clears the backlog.  Put together by David Haywood, 
+
+If you submit changes please make sure they're up to date with the latest
+source code, if not it means more work for us in sorting them out.
+
+Several people have asked about the SHA1Merger program for updating their
+own drivers, if you need this it should be on www.mame.net within a few
+hours of this release.
+
+Note, we are aware of some problems with the Direct 3D core which cause
+some games to function incorrectly (Rolling Thunder title screen, Hard
+Drivin' Dashboard, Puyo Puyo title screen raster etc.) if you have problems
+with games when using -d3d try them without before reporting a bug. (although
+please do report games broken with -d3d if you find them but make sure to
+specify the problem is with -d3d)
+
+The cause of this problem seems to lie somewhere in
+
+result = IDirect3D7_CreateDevice(d3d7, &IID_IDirect3DHALDevice, back_surface, &d3d_device7);
+
+however we don't know how to fix this nor why it happens, could the real problem
+be elsewhere?
+
+General Source Changes
+----------------------
+
+Fixed a problem with missing 'returns' in the PIC CPU core [Bryan McPhail]
+	src\cpu\pic16c5x\pic16c5x.c
+
+Fixed a few MCU simulation problems in bking3 [Angelo Salese]
+	src\drivers\bking2.c
+
+Various changes [Nathan Woods]
+
+	src/cheat.c:
+	- Minor change to the MESS specific code
+
+	src/datafile.c:
+	- DriverDataCompareFunc() is now declared with CLIB_DECL
+
+	src/hash.c:
+	- Removed strupr() in favor a manual implementation, because it
+	is non-ANSI
+
+	src/usrintrf.c:
+	- Minor tweaks within #ifdef MESS code
+	- UI code for discrete sound engine now encapsulated within '#if
+	HAS_DISCRETE'
+
+	src/ui_text.c:
+	src/ui_text.h:
+	- Changed some #ifdef MESS specific strings
+
+	src/windows/rc.c:
+	src/windows/rc.h:
+	- Fixed a potential crash that could occur if the last line in
+	an INI file was not terminated with a CRLF
+	- Added osd_rc_write(); which does the reverse as osd_rc_read()
+	(this is only used in the MESS Win32 port)
+
+	src/fileio.c:
+	src/fileio.h:
+	- New mame_fputs(), mame_vfprintf() and mame_fprintf() functions
+	(used in osd_rc_write()) above
+	
+	src/windows/fileio.c:
+	- Removed some no longer relevant MESS globals
+	- Unicode enabled (i.e. - compiles under #define UNICODE)
+
+	src/windows/winalloc.c:
+	- Added corresponding _msize implementation (this fixes a benign
+	but very subtle bug when debugging with VC)
+
+	src/idectrl.c:
+	src/idectrl.h:
+	- Added ide_controller_init_custom() (used by MESS)
+
+	src/fileio.c:
+	src/hash.c:
+	src/windows/fronthlp.c:
+	- Removed private prototypes of crc32(), in favor of #include <zlib.h>
+
+	src/windows/fronthlp.c:
+	- Minor tweaks within #ifdef MESS
+
+	src/sha1.h:
+	- Put #ifndef _STDINT_H around typedefs for uint32_t and uint8_t
+	(apparently these are already defined on the Mac)
+
+	src/windows/winalloc.c:
+	src/windows/winmain.c:
+	- Put CLIB_DECL in front of a few declarations
+
+
+Various Changes [Andrea Mazzoleni]
+
+	src/info.c
+	- Substitutes in the -listinfo output the strings "nodump" and "baddump"
+	  with "flags nodump" and "flags baddump".
+
+	src/sound/disc_mth.c
+	- Substitutes the _HUGE macro with the standard DBL_MAX value
+	
+	src/cpu/tms9900/9900stat.h
+	src/cpu/tms9900/99xxstat.h
+	- Adds a test for the GNU C compiler to skip some POWERPC inline assembler
+	  not compatible with the GNU assembler format.
+
+	src/x86drc.h
+	- Fixes some macros with arguments not used. Otherwise it doesn't compile
+	  with gcc 2.95.3.
+
+Auditing Fixes for cases where no good dump is known but a file is found [BUT]
+	src\audit.c
+	
+Improvements and Bug Fixes to the Direct 3D Blitting [Leon van Rooij]
+
+	-effect same as 0.68 and earlier, no effect on d3d module
+	-zoom or -z (default is 2) select zoom level, works for the ddraw code as well
+	find the smallest display mode that will fit an n times zoomed game image
+	(only used when no display mode is explicitly forced,
+	the d3d code takes the aspect ratio into account, ddraw behaviour is 
+	unchanged)
+	-cleanstretch or -cs only strecth to integer ratios, works for the ddraw 
+	code as well
+
+	-d3dfilter or -d3dflt select filtering algorithm
+	0 is none, 1 bi-linear, 2 flat bi-cubic, 3 gaussian bicubic, 4 anisotropic
+	-d3deffect behaves exactly the same as -effect, but only affects the d3d module
+	You can use all -effect parameters, so none, scan25, scan50, scan75,
+	rgb16, rgb6, rgb4, rgb3, and sharp work, they are identical at 2x zoom
+	scan75v and rgb4v also work, and are identical to scan75 adn rgb4
+	(as the d3d effects are automatically rotated already)
+	Additionally, all effects presets and auto work
+	none affects only the presets now.
+	The presets are renamed, in addition to the -effect presets, they are now:
+	rgbminmask,
+	dotmedmask,
+	rgbmedmask,
+	rgbmicro
+	rgbtiny
+	aperturegrille,
+	dotmedbright,
+	rgbmaxbright
+
+	-d3dscan scanline intensity, 100 is off
+	-d3dfeedback feedback intensity, 0 is off
+	-d3dsaturate oversaturation intensity, 0 is off
+	-d3dprescale AKA sharp.
+	-d3dcustom custom preset, as before
+	(anyone who wants to customise presets can, everybody else should ignore it)
+	-d3dexpert Normal users should not use this one, basically if you can't 
+	read the
+	source to figure out what it does, you have no business using it <g>
+	Behaves as -effect did in the previous updates, plus some new stuff;
+	disable disables all effects,
+	prescale lets you control prescale explicitly,
+	pixelcounter changes the scanline texture
+	(use mame whatever -z 4 -d3d -cs -flt 0 -d3dexpert pixelcounter),
+	norotate disables rotating effects
+	
+	It has it's own ini section and it handles priorities itself to ensure 
+	correct behaviour. For custom presets, patterns are no longer loaded from 
+	the effects directory, the name should just include the path.
+	
+	There are warning messages when you do e.g. -nod3d -d3dscan50, or -d3d 
+	-effect sharp (although the latter will work as it has up until 0.68). It 
+	tests all hardware capabilities it should (as far as I'm aware, at least). 
+	It won't chop textures in 256x256 blocks for old Voodoo cards. 
+	-texture_management is now enabled by default as leaving it off seems to 
+	have worse consequences for more people than having it on. I haven't added 
+	a workaround for cards that can't render to textures yet, other than that, 
+	any possible typos, etc. or any suggestions people may have, it should be 
+	good for 0.69.
+	
+	Apparently some videocards don't like the DX7 pageflip in combination with 
+	a triple buffer. (behaviour when triple buffering is unchanged from 0.67, 
+	that goes for the d3d code as well as the ddraw code).	
+	
+	src\windows\video.c
+	src\windows\video.h
+	src\windows\wind3d.c
+	src\windows\wind3d.h
+	src\windows\win3dfx.c
+	src\windows\win3dfx.h
+	src\windows\windraw.c
+	src\windows\windraw.h
+	src\windows\window.c
+	src\windows\window.h
+	src\windows\d3d_extra.h
+	src\windows\windows.mak
+	
+Added USA 2-Slot bios to NeoGeo Driver (recompile to use) also readded line removed
+by mistake, fixed coinage bug when using USA Bios []
+	src\drivers\neogeo.c
+	src\machine\neogeo.c
+	
+Added Asia Bios to NeoGeo Driver []
+	src\drivers\neogeo.c
+	
+Renamed Proms in Eggor [David Haywood]
+	src\drivers\pacman.c
+
+Fixed Demo Sound Dipswitch in sotsugyo [Fujix]
+	src\drivers\funkyjet.c
+
+Fixed Infinite Lives Dipswitch in qtono2 [BUT]
+	src\drivers\cps1.c
+	
+Various Fixes and Improvements to Chack'n Pop [BUT]
+	src\drivers\chaknpop.c
+	src\machine\chaknpop.c
+	src\vidhrdw\chaknpop.c
+	
+Fixed the Sound Loading in some Taito F3 Games [Paul Priest, Ryan Holtz]
+	src\drivers\taito_f3.c
+
+Corrected Dragon Master Dipswitches and Frequencies [David Silva, Guru]
+	src\drivers\drgnmst.c
+
+Added NeoGeo Mahjong control panel support [David Haywood]
+	src\drivers\neogeo.c
+	src\machine\neogeo.c
+
+Corrected sprite priority in brkthru and darwin and converted the driver to use
+tilemaps [Satoshi Suzuki, David Haywood]
+	src\drivers\brkthru.c
+	src\vidhrdw\brkthru.c
+
+Fixed a bug with -crconly which could cause options.debug_width to become
+corrupt [Paul Priest]
+	src\mame.h
+
+Fixed a problem where a NODUMP rom was reported as found even if it didn't
+exist in the rompaths [HobbesAtPlay]
+	src\fileio.c
+
+Corrected Colours in Progres & added 3rd Button for Aiming [Uki]
+	src\drivers\timelimt.c
+	
+Fixed Length of Proms in Main Event (SNK) TESTDRIVER [David Haywood]
+	src\drivers\mainsnk.c
+
+Fixed Merging of Sets in Shougi TESTDRIVER [Toby Broyad]
+	src\drivers\shougi.c
+
+Fixed Name of Mach Breakers (was Match Breakers) [MameTesters]
+	src\drivers\namconb1.c
+	
+Fixed Interrupt being triggered on Non-Existant CPU for TaitoSJ games with no
+MCU [Aaron Giles]
+	src\machine\taitosj.c
+	
+Added -bios option [Paul Priest]
+
+Adds the system option "bios". An integer that is valid where: 0 <= n < 15
+
+	Rom loading is now modified so that if any of the 4 bits in
+	ROM_BIOSFLAGSMASK of the rom flags are set, it will only be loaded if
+	the value+1 == options.bios
+
+	NeoGeo has been modified to take advantage of this as follows:
+	0 - "sp-s2.sp1"    - Europe, 1 Slot (also been seen on a 4 slot) (default)
+	1 - "sp-s.sp1"     - Europe, 4 Slot
+	2 - "usa_2slt.bin" - US, 2 Slot
+	3 - "sp-e.sp1"     - US, 6 Slot (V5?)
+	4 - "asia-s3.sp1"  - Asia S3 Ver 6
+	5 - "vs-bios.rom"  - Japan, Ver 6 VS Bios
+	6 - "sp-j2.rom"    - Japan, Older
+	
+	Note that using a value >6 and <15 will result in NO bios rom being
+	loaded (And a red screen in NeoGeo's case).
+	
+	src\common.c
+	src\common.h
+	src\drivers\neogeo.c
+	src\mame.h
+	src\windows\config.c
+
+Corrected Filenames for Steel Gunner 2 [Brian Troha]
+	src\drivers\namcos2.c
+	
+Fixed Scrolling bug in One Shot One Kill [Angelo Salese]
+	src\vidhrdw\oneshot.c
+
+Fixed Mcu Reset for Tiger Heli [Angelo Salese]
+	src\machine\slapfght.c
+
+Removed a graphic rom loading kludge in Yamato,which caused a bad gray square
+when launching missiles(yamato37b9gre);also fixed crashes in clone
+yamato2. [Angelo Salese]
+	src\drivers\yamato.c
+
+Removed NeoGeo Memory Card Manager RESET / CALL option from UI, this feature is
+only available on the AES console and should be in Mess (and probably won't be
+needed at all with a real AES bios) []
+	src\ui_text.c
+	src\ui_text.h
+	src\usrintrf.c
+
+Changed NeoGeo Framerate to 59fps based on Mametesters report about Kof98 Intro Sync
+It would be nice if somebody could give a real accurate measurement of this []
+	src\drivers\neogeo.c
+
+Fixed FM bug causing bad sounds in maglord and other games which was introduced in
+the last release [Jarek Burczynski]
+
+Discrete Sound update for several games [Derrick Renaud]
+
+	- Atari Baseball - added video invert (triples/home runs).
+	- Avalanche - changed to discrete sounds adding missing top rocks sound
+	(Aud0 trigger). (and yes the game is supposed to sound horrible)
+	- Dominos - added 60Hz ac signal (but it does not seem to affect anything).
+	- Drag Race - added discrete sounds.
+	- Night Driver - added discrete sounds and video invert during crash.
+	Motor/skid sounds are not 100% correct.
+	- Sprint 2 - switched player controls so they lined up under the proper
+	score color.
+	- Orbit - added discrete sounds.
+
+	- [but] fixed the 'no stereo' bug in src\sound\discrete.c
+	- I also fixed a minor bug in src\sound\discrete.h causing
+	DISCRETE_LOGIC_INVERT not to work.
+	- And did minor code cleanup to Basketball.
+	- Removed GAME_IMPERFECT_SOUND flag from Circus.  If correct samples are
+	used then it is ok, like all sample games.  (New accurate samples have been
+	posted at twisty's)
+	
+	src\machine\atarifb.c
+	src\drivers\avalnche.c
+	src\machine\avalnche.c
+	src\drivers\bsktball.c
+	src\drivers\circus.c
+	src\sound\discrete.c
+	src\sound\discrete.h
+	src\drivers\dominos.c
+	src\machine\dominos.c
+	src\includes\dominos.h
+	src\drivers\dragrace.c
+	src\drivers\nitedrvr.c
+	src\machine\nitedrvr.c
+	src\includes\nitedrvr.c
+	src\drivers\orbit.c
+	src\drivers\sprint2.c
+	
+Preliminary WIP Discrete Sound in Subs [Derrick Renaud]
+	src\drivers\subs.c
+	src\machine\subs.c
+	src\vidhrdw\subs.c
+
+Correct Colours in Clash Road [Luca Elia]
+	src\drivers\clshroad.c
+	src\vidhrdw\clshroad.c
+
+
+New games supported:
+--------------------
+
+Wolf Pack (prototype) [Stefan Jokisch]
+	graphic emulation might not be perfect, no sound
+	src\drivers\wolfpack.c
+	src\vidhrdw\wolfpack.c
+Naughty Mouse [Dave Widel]
+	src\drivers\pacman.c
+Broadwalk Casino / Atlantic City Action [Dave Widel]
+	this doesn't appear to be a gambling game
+	src\drivers\pacman.c
+	src\includes\pacman.h
+	src\machine\acitya.c
+Paradise [Luca Elia]
+	there seems to be a problem with the hi-score system
+	src\drivers\paradise.c
+	src\vidhrdw\paradise.c
+	src\includes\paradise.h
+
+New clones supported
+--------------------
+
+Metamorphic Force (Japan JAA) [GMB]
+	src\drivers\mystwarr.c
+GI Joe (Japan) [GMB]
+	src\drivers\gijoe.c
+Falcon (Phoenix bootleg) [Smitdogg]
+	src\drivers\phoenix.c
+Mr. Do's Castle (older) [Lee Taylor]
+	src\drivers\docastle.c
+Police Trainer 1.3B (Sharpshooter Hardware) [Brian Troha]
+	fails rom check, does so on original hardware too
+	src\drivers\policetr.c
+Street Fighter 2 (USA 911101) [David Haywood]
+	src\drivers\cps1.c
+	src\vidhrdw\cps1.c
+Make Trax (set 2) [Dave Widel]
+	src\drivers\pacman.c
+NewPuc2 (hack) [Dave Widel]
+	this hack was common in the arcades, it has intermissions between each
+	maze and a slot machine every 3 mazes.
+	src\drivers\pacman.c
+World Class Bowling (v1.66, v1.65) [Brian Troha]
+	v1.66 is now the parent
+	src\drivers\itech32.c
+Targ (cocktail?) []
+Rallys (bootleg? of Spectar) []
+	src\drivers\exidy.c
+Route 16 (set 2) []
+	src\drivers\route16.c
+Labyrinth Runner (World Ver. K) []
+	src\drivers\labyrunr.c
+The Main Event (2 Players ver. X) []
+	src\drivers\mainevt.c
+Quartet 2 (Japan) []
+Flash Point (Japan, bootleg) []
+	no, these have nothing to do with the system16 rewrite
+	src\drivers\system16.c
+Chopper [US set 2 & set 3] []
+	src\drivers\snk.c
+	src\vidhrdw\snk.c
+Tunnel Hunt (Atari Original) [David Haywood]
+	this is now the parent, old set is tunhuntc
+	src\drivers\tunhunt.c
+Arkanoid (US, older) [Stephane Humbert]
+	src\drivers\arkanoid.c
+	
+New TESTDRIVERS in source
+-------------------------
+
+Polygonet Commanders [R.Belmont]
+	only text layer is emulated, hangs waiting for network, DSP used for 3D
+	graphics isn't emulated
+	src\drivers\plygonet.c
+	src\vidhrdw\plygonet.c
+Mahjong Daireikai [David Haywood]
+Mahjong Channel Zoom In [David Haywood]
+Mahjong Kakumei [David Haywood]
+Mahjong Kakumei 2 - Princess League [David Haywood]
+	these just load the roms and decode the gfx for now, they might be
+	similar to nmk16.c just incase somebody wants to finish them.
+	src\drivers\jalmah.c
+Slipstream [David Haywood]
+	doesn't work due to unemulated v60 opcodes
+	src\drivers\system32.c
+Atlus Print Club (v1, v2, v4, v5)
+	mainly for reference, it might not be possible to emulate them as they 
+	need a camera + printer
+	src\drivers\segac2.c
+Portraits [Steve Ellenoff & Peo]
+	preliminary driver, still being worked on
+	src\drivers\portrait.c
+	src\vidhrdw\portrait.c
+Mustache Boy [Tomasz Slanina]
+	preliminary driver, gfx not fully decrypted, missing proms, no sound
+	src\drivers\mustache.c
+	src\vidhrdw\mustache.c
+	src\sndhrdw\seibu.c
+
+0.68
+
+Note, this Release was put together by David Haywood, some of it is
+untested but most of it seems to work.
+
+General Source Changes
+----------------------
+
+SHA1 hash support, including various new command line options [Farfetch'd]
+	src\too many to list ;-)
+
+Mame Blitter Generation Code [Phil Stroffolino]
+	src\mameblit.c
+	src\mame.c
+	src\mame.h
+	src\drawgfx.c
+	src\blitgen.c
+
+Basic Direct3D blitting support [Leon van Rooij]
+
+You need DirectX7 headers and libs to compile it, I'm using the set from
+http:\\caesar.logiqx.com\html\tools\compilers\mingw.shtml which has the
+original MS headers (the same set is used for Allegro and FB Alpha) and
+I've made a minor update to the ddraw code so that it compiles with this
+set of headers (VC++ should still be fine as well).
+
+The code manually imports the DirectDrawCreateEx() function so MAME
+compiled with d3d support will (or rather should, I've not actually tested
+that yet) still run on PC's with older versions of DirectX. It should work
+with pretty much any 3D hardware (except perhaps older Voodoo-based cards),
+and the speed should be similar to the DirectDraw blit (a bit faster for
+some older cards).
+
+-direct3d or -d3d: use Direct3D (default is off, overrides -dd);
+-filter or -flt: use bi-linear filtering (default is on);
+-texture_management: use DirectX texture management (default is off, but
+ some 3D cards need this (however, there's a small-ish speed-penalty)).
+	src\windows\windows.mak
+	src\windows\window.h
+	src\windows\window.c
+	src\windows\windraw.h
+	src\windows\windraw.c
+	src\windows\wind3d.h
+	src\windows\wind3d.c
+	src\windows\video.h
+	src\windows\video.c
+	
+Various Konami Related Fixes and Improvements [Acho A. Tang, R. Belmont]
+	src\tilemap.c
+	src\palette.c
+	src\drivers\mystwarr.c
+	src\vidhrdw\mystwarr.c
+	src\vidhrdw\konamiic.c
+	src\vidhrdw\konamiic.h
+	src\machine\konamigx.h
+	src\drivers\konamigx.c
+	src\machine\konamigx.c
+	src\vidhrdw\konamigx.c
+	src\drivers\xexex.c
+	src\vidhrdw\xexex.c
+	src\sound\ko54539.c
+	src\sound\ko54539.h
+	src\drawgfx.c
+	src\blitgen.c
+	
+Various System 32 Updates (Priority, SVF Pitch etc.) [Acho A. Tang, Jason Lo, David Haywood]
+	Note, theres a chance some things may be broken
+	src\drivers\multi32.c
+	src\drivers\system32.c
+	src\vidhrdw\system32.c
+	
+Sound in Macross Plus & Quiz Bisyoujo Senshi Sailor Moon [Bryan McPhail]
+	src\drivers\macrossp.c
+	src\sound\es5506.c
+
+Fixes for Crashes introduced in last version
+	src\drivers\namcos1.c
+	src\drivers\namcos2.c
+	src\drivers\shangha3.c
+
++ plenty of other things I just don't have time to list.
+	
+New games supported:
+--------------------
+
+Chack'n Pop [BUT]
+	src\drivers\chaknpop.c
+	src\machine\chaknpop.c
+	src\vidhrdw\chaknpop.c
+
+Salamander 2 [Acho A. Tang, R. Belmont]
+	Some protection issues remain (ships in attract mode)
+Tokimeki Memorial Taisen Puzzle-dama [Acho A. Tang, R. Belmont]
+Dragoon Might [Acho A. Tang, R. Belmont]
+	src\ see list in 'Various Konami Updates' above
+Koi Koi Shimasyo 2 - Super Real Hanafuda [Luca Elia]
+Vasara []
+Vasara 2 []
+	src\drivers\ssv.c
+	src\vidhrdw\ssv.c
+	src\includes\seta.h
+Billiard Academy Real Break [Luca Elia]
+	src\drivers\realbrk.c
+	src\vidhrdw\realbrk.c
+	src\includes\realbrk.h
+	src\drivers\seta2.c
+	src\machine\tmp68301.c
+	src\machine\tmp68301.h
+	src\sound\ymz280b.c
+	src\sound\ymz280b.h
+Cannonball [Jarek Burczynski]
+	some gfx problems (Bad ROMs?)
+	src\drivers\cclimber.c
+Kick Start Wheelie King [Tomasz Slanina]
+	previously a testdriver, emulation completed
+	src\drivers\taitosj.c
+	src\vidhrdw\taitosj.c
+Truco-Tron [Ernesto Corvi]
+	src\drivers\truco.c
+	src\vidhrdw\truco.c
+(Super) Ground Effects [David Graves, Bryan McPhail]
+	src\drivers\groundfx.c
+	src\vidhrdw\groundfx.c
+	src\vidhrdw\taitoic.c
+	src\drivers\undrfire.c
+Horizon [smf, David Haywood]
+	src\drivers\m62.c
+	src\vidhrdw\m62.c
+Fire Battle [Martin Pugh]
+	previously a testdriver, patch added
+	src\drivers\clshroad.c
+Rapid Hero [David Haywood]
+	src\drivers\nmk16.c
+	src\vidhrdw\nmk16.c
+Zero Point 2 [Luca Elia]
+	src\drivers\unico.c
+	src\vidhrdw\unico.c
+	src\includes\unico.h
+Idol Janshi Su-Chi-Pie 2 [David Haywood]
+	src\drivers\ms32.c
+	src\vidhrdw\ms32.c
+Quiz Ghost Hunter [Olivier Galibert]
+Tokoro San no MahMahjan [Olivier Galibert]
+Tokoro San no MahMahjan 2 [Olivier Galibert]
+Quiz Mekiromeki Story [Olivier Galibert]
+	src\drivers\system24.c
+	src\vidhrdw\system24.c
+	src\machine\system24.c
+	src\includes\system24.h
+	src\vidhrdw\segaic24.c
+	src\vidhrdw\segaic24.h
+Straight Flush [Tomasz Slanina]
+	2 player mode isn't working
+	src\drivers\8080bw.c
+	src\vidhrdw\8080bw.c
+	src\includes\8080bw.h
+SD Gundam Neo Battling [Luca Elia]
+	src\drivers\seta.c
+Fantasy Land [Luca Elia]
+Galaxy Gunners [Luca Elia]
+	src\drivers\fantland.c
+	src\vidhrdw\fantland.c
+Metal Soldier Isaac II [Angelo Salese]
+	previously a testdriver, mcu simulation added
+	src\drivers\msisaac.c
+Progress [David Haywood]
+	Bad Colours due to missing Proms
+	src\drivers\timelimt.c
+Birdie King 3 [Angelo Salese]
+	src\drivers\bking2.c
+Dark Tower [Bryan McPhail, David Haywood]
+	dips need mapping correclty, default coinage is bad
+	src\drivers\ddragon.c
+Tricky Doc [Reip, David Haywood]
+	Bad Colours due to missing Proms
+	src\drivers\sauro.c
+	src\vidhrdw\sauro.c
+Tournament Table [Stefan Jokisch]
+	src\drivers\tourtabl.c
+	src\machine\6532riot.c
+	src\machine\6532riot.h
+	src\sound\tiaintf.c
+	src\sound\tiaintf.h
+	src\sound\tiasound.c
+	src\sound\tiasound.h
+	src\vidhrdw\tia.c
+Eggor [Tomasz Slanina]
+	src\drivers\pacman.c
+Rock Climber [Tomasz Slanina]
+	src\drivers\galaxian.c
+	src\vidhrdw\galaxian.c
+	src\includes\galaxian.h
+Kung-Fu Taikun [Tomasz Slanina]
+	src\drivers\wiz.c
+Metal Clash [Luca Elia]
+	src\drivers\metlclsh.c
+	src\vidhrdw\metlclsh.c
+Head Panic
+	eeprom needs hooking up
+	src\drivers\esd16.c
+	src\vidhrdw\esd16.c
+Puckman Pockimon [Luca Elia]
+	src\drivers\segac2.c
+	src\vidhrdw\segac2.c
+Operation Wolf 3 [David Graves, Bryan McPhail]
+	src\drivers\slapshot.c
+Sky Army [Ryan Holtz]
+	src\drivers\skyarmy.c
+Super Doubles Tennis [Bryan McPhail]
+	src\drivers\btime.c
+Egg Venture [Aaron Giles]
+Lethal Justice [Aaron Giles]
+	src\drivers\lethalj.c
+	src\vidhrdw\lethalj.c
+	src\includes\lethalj.h
+Area 51 \ Maximum Force Duo [Aaron Giles]
+	src\drivers\cojag.c
+Prebillian [Tomasz Slanina]
+	src\drivers\pbillian.c
+	src\vidhrdw\pbillian.c
+	src\sndhrdw\pbillian.c
+Bwings [Acho A. Tang]
+Zaviga [Acho A. Tang]
+	src\drivers\bwing.c
+	src\vidhrdw\bwing.c
+Wall Crash [Jarek Burczynski]
+	src\drivers\wallc.c
+Mighty Pang [Razoola]
+	src\drivers\cps2.c
+	src\vidhrdw\cps1.c
+J-League Soccer V-Shoot [Phil Stroffolino]
+	src\drivers\namconb1.c
+Rotary Fighter [Barry Rodewald]
+	src\drivers\rotaryf.c
+The Deep \ Run Deep [Luca Elia]
+	src\drivers\thedeep.c
+	src\vidhrdw\thedeep.c
+
+
+New clones supported
+--------------------
+
+Lethal Enforcers 2 (USA) [Brian Troha]
+	src\drivers\konamigx.c
+Violent Storm (Europe) [David Haywood]
+	src\drivers\mystwarr.c
+Mello Yello Q*Bert [David Haywood]
+	src\drivers\gottlieb.c
+Big Bang (clone of Thunder Dragon 2) [David Haywood]
+Vandyke (Jaleco) [David Haywood]
+	src\drivers\nmk16.c
+BlockBuster (clone of Mr Jong) [David Haywood]
+	src\drivers\mrjong.c
+Catsbee (clone of Galaga) [David Haywood]
+	src\drivers\galaga.c
+	src\vidhrdw\galaga.c
+Croquis (clone of Logic Pro) [David Haywood]
+	src\drivers\deniam.c
+Super Pinball Action (US) [David Haywood]
+	src\drivers\spbactn.c
+Pollux (set 2) [David Haywood]
+	src\drivers\dooyong.c
+Vautour (clone of Phoenix) [Chris Hardy]
+	src\drivers\phoenix.c
+Moon Alien (clone of Galaxian) [David Haywood]
+	src\drivers\galaxian.c
+Country Club (clone of Fighting Golf) [Tomasz Slanina]
+	src\drivers\snk.c
+DoDonPachi (International Version) [Brian Troha]
+	src\drivers\cave.c
+Batrider (Korea) [Brian Troha]
+	src\drivers\toaplan2.c
+Vs Block Breaker (clone of sarukani) [David Haywood]
+	src\drivers\suprnova.c
+	src\vidhrdw\suprnova.c
+Ring Fighter (clone of Vs. Gong Fight) [David Haywood]
+	src\drivers\tsamurai.c
+Space Panic (various alt sets) [Zsolt]
+	src\drivers\cosmic.c
+Piranha (GL sets) [Dave Widel]
+	src\drivers\pacman.c
+Hydra (prototype set 2) [Aaron Giles]
+	src\drivers\atarig1.c
+Millpac (clone of centipede) [Chris Hardy]
+	src\drivers\centiped.c
+Some Cps1 Clones [Razoola]
+	src\drivers\cps1.c
+Bang Bead (Release Version) [Various]
+	src\drivers\neogeo.c
+Terminator 2 (LA1) [Brian Troha]
+	src\drivers\midyunit.c
+Various NeoGeo Clones [Razoola]
+	src\drivers\neogeo.c
+	src\machine\neogeo.c
+
+	
+New TESTDRIVERS in source
+-------------------------
+
+Shougi [Jarek Burczynski, Tomasz Slanina]
+Shougi 2 [Jarek Burczynski, Tomasz Slanina]
+	Not Working due to Protection MCU
+	src\drivers\shougi.c
+Konami's Open Golf Championship [Acho A. Tang, R. Belmont]
+	Missing ROZ layer, always thinks the ball is in the water
+	src\drivers\konamigx.c
+F1 Grand Prix Star 2 [Luca Elia]
+	Missing \ Bad ROMs
+	src\drivers\cischeat.c
+	src\vidhrdw\cischeat.c
+Ultra Weapon X [Luca Elia]
+	problems with v60 interrupts
+Joryuu Syougi Kyoushitsu [Luca Elia]
+	unemulated CPU
+	src\drivers\ssv.c
+	src\vidhrdw\ssv.c
+Hot Rod [Olivier Galibert]
+Bonanza Bros [Olivier Galibert]
+Quiz Rouka Ni Tattenasai [Olivier Galibert]
+	various problems with the System 24 emulation
+	src\drivers\system24.c
+	src\vidhrdw\system24.c
+	src\machine\system24.c
+	src\includes\system24.h
+	src\vidhrdw\segaic24.c
+	src\vidhrdw\segaic24.h
+Thunder Strike
+	src\drivers\ddragon.c
+Hot Smash [Tomasz Slanina]
+	MCU Protection problems
+	src\drivers\pbillian.c
+	src\vidhrdw\pbillian.c
+	src\sndhrdw\pbillian.c
+Raiden 2 [Bryan McPhail]
+	Protected and Encrypted Sprites
+	src\drivers\raiden2.c
+Grand Tour [David Haywood]
+	Protection?
+	src\drivers\iqblock.c
+Great Wall
+	Needs work on vidhrdw (none done)
+	src\drivers\grtwall.c
+China Dragon
+	Needs work on vidhrdw (none done)
+	src\drivers\chindrag.c
+Space Bugger [David Haywood]
+	bad rom?
+	src\drivers\sbugger.c
+	src\vidhrdw\sbugger.c
+Main Event (SNK) [David Haywood]
+	vidhrdw not finished
+	src\drivers\mainsnk.c
+
+
+0.67
+
+
+MAME Testers bugs fixed (there are probably more)
+-----------------------
+
+rocnrope37b7ora [Nicola Salmoria]
+m62sound066yel
+bladstle065gra   [Jake Stookey]
+poundfor37b14gra (only the second part) [Jake Stookey]
+
+
+These drivers have improved SOUND:
+----------------------------------
+
+- Fixed sample playback in the M72 games. [Nicola Salmoria]
+
+- Music in Battle Rangers. [Charles MacDonald]
+
+
+Other drivers changes:
+----------------------
+
+- Dozens of corrections to game description/flags [Toby Broyad]
+
+- Deveral improvements to Championship VBall. [Steve Ellenoff]
+
+
+Changes to the main program:
+----------------------------
+
+- New options -autoror/-autorol. They rotate the screen only if the game is
+  vertical; useful with "pivot" LCD monitors. [Paul Priest]
+
+
+Source:
+-------
+
+- MIPS 3/4 x86 dynamic recompiling core. [Aaron Giles]
+
+- PIC16C5x CPU core. [Quench]
+
+- Sega 315-5560 "MultiPCM" sound chip emulation. [R. Belmont]
+
+- HuC6280 sound emulation. [Charles MacDonald]
+
+
+New games supported:
+--------------------
+
+Mystic Warriors [R. Belmont, Phil Stroffolino]
+Gaiapolis [R. Belmont, Phil Stroffolino]
+Metamorphic Force [R. Belmont, Phil Stroffolino]
+Kyukyoku Sentai Dadandarn [R. Belmont, Phil Stroffolino, Acho A. Tang]
+Violent Storm [R. Belmont, Phil Stroffolino, Acho A. Tang]
+Twin Bee Yahhoo! [R. Belmont, Phil Stroffolino, Acho A. Tang]
+Martial Champion [R. Belmont, Phil Stroffolino, Acho A. Tang]
+Lethal Enforcers 2 [R. Belmont, Phil Stroffolino, Olivier Galibert]
+Taisen Puzzle-Dama [R. Belmont, Phil Stroffolino, Olivier Galibert]
+Gokujou Parodius [R. Belmont, Phil Stroffolino, Olivier Galibert]
+Sexy Parodius [R. Belmont, Phil Stroffolino, Olivier Galibert]
+Daisu-Kiss [R. Belmont, Phil Stroffolino, Olivier Galibert]
+Taisen Tokkae-Dama [R. Belmont, Phil Stroffolino, Olivier Galibert, David Haywood]
+Guardians / Denjin Makai II [Luca Elia]
+Dragongun [Bryan McPhail]
+Tattoo Assassins [Bryan McPhail]
+Locked 'n Loaded [Bryan McPhail]
+Dead Angle [Bryan McPhail, David Haywood]
+Dragon Master [David Haywood, Quench]
+Las Vegas Girl (Girl '94) [David Haywood]
+Hard Dunk [Jason Lo, R. Belmont, David Haywood]
+Outrunners [Jason Lo, R. Belmont, David Haywood]
+Tecmo Bowl [David Haywood, Tomasz Slanina]
+Complex X [Brian Crowe]
+
+
+==========================================================================
+
+0.66
+
+Codename "FR-34"
+
+
+MAME Testers bugs fixed (there are probably more)
+-----------------------
+
+galpanib062gre   [Paul Priest]
+usclssic065red   [Kale]
+pang3065gre
+housemn2065gra   [Nomax]
+myangel065gre    [Nicola Salmoria]
+88games062yel    [Nicola Salmoria]
+glfgreat061gre   (was fixed some time ago)
+robocop2064gre   [Bryan McPhail]
+dassault061gre2  [Bryan McPhail]
+jdredd060gra     [Smitdogg]
+ringdest062gra   [Smitdogg]
+spbactn061gra    [Smitdogg]
+term2064gra      [Smitdogg]
+xmen062ora       [Smitdogg]
+sotsugyo061red	 [Bryan McPhail]
+tmnt065gre		 [Acho A. Tang]
+astdelux059gre   [Derrick Renaud]
+gunforc2058gre_2 [Angelo Salese]
+gunforc2058gre_3 [Bryan McPhail]
+
+
+MAME Testers bugs to check
+--------------------------
+
+mrheli37b2gre   - I believe this was fixed some time ago
+
+
+These drivers have improved SOUND:
+----------------------------------
+
+- Fixed samples in Pachinko Sexy Reaction [Suppi-Chan]
+
+- Major improvements to the Namco NA sound emulation. [cync]
+
+- Sound in IQ Block. [David Haywood]
+
+- Fixed drums in Exterminator [Steve Ellenoff, Jim Hernandez]
+
+
+Other drivers changes:
+----------------------
+
+- Misc improvements to the Namco NA driver. [Phil Stroffolino]
+
+- Several improvements and games additions to the Nintendo VS and Playchoice
+  drivers. [Pierpaolo Prazzoli]
+
+- Several fixes to Super Real Darwin [Acho A. Tang]
+
+
+Changes to the main program:
+----------------------------
+
+- New option -high_priority to increase the thread priority so MAME runs better
+  while other programs are running. It is off by default because enabling it
+  might make MAME use too much CPU time.
+
+- Major update to the discrete sound system. This includes adjustable parameters
+  controls in the UI, fixes to existing games, and new sound support in canyon,
+  polaris, sprint and ultratnk. [Derrick Renaud & Keith Wilkins]
+
+- Fixed some bugs in the I86/NEC CPU emulation. This includes raster effect
+  problems in Geostorm and the 99 credits bug in Lethal Thunder. [Bryan McPhail]
+
+
+Source:
+-------
+
+- Now compiled with GCC 3.2.2. Removed the patch that was needed to work around
+  a GCC 3.2 bug.
+
+- First version of YMF262 emulator. [Jarek Burczynski]
+
+
+New games supported:
+--------------------
+
+Fantasy '95 [Brian A. Troha]
+Hana no Mai [Nicola Salmoria]
+Mahjong Friday [Nicola Salmoria]
+Mahjong Dial Q2 [Nicola Salmoria]
+Don Den Mahjong [Nicola Salmoria]
+Watashiha Suzumechan [Nicola Salmoria]
+Mahjong Studio 101 [Nicola Salmoria]
+Mahjong Derringer [Nicola Salmoria]
+Hana Yayoi [Nicola Salmoria]
+Untouchable [Nicola Salmoria]
+Rong Rong [Nicola Salmoria]
+Don Den Lover Vol. 1 [Nicola Salmoria]
+Quiz Channel Question [Nicola Salmoria]
+Mad Donna [David Haywood]
+Dorodon [Frank Palazzolo]
+Ben Bero Beh [Acho A. Tang]
+Halley's Comet [Acho A. Tang]
+Triv Quiz [MooglyGuy]
+Gigas [Tomasz Slanina]
+Gigas Mark II [Tomasz Slanina]
+Mad Shark [Luca Elia]
+Ultra Toukon Densetsu [Luca Elia]
+
+
+New clones supported:
+---------------------
+
+Gratia (set 1)
+Mysterious Stones (set 1)
+Cosmic Cop (= Gallop)
+
+
+==========================================================================
+
+0.65
+
+
+MAME Testers bugs fixed (there are probably more)
+-----------------------
+
+arbalest060gre    [Nicola Salmoria]
+arbalest37b1gre   [Nicola Salmoria] (please verify)
+calibr50062gre    [Nicola Salmoria]
+downtown062gre    [Nicola Salmoria]
+oisipuzl061gre    [Nicola Salmoria]
+galpanic064gre    [Nicola Salmoria]
+mitchellc063gre   [Smitdogg]
+avengers061gre    [Acho A. Tang]
+avengers37b16gre  [Acho A. Tang]
+lwingsc37b7gre    [Acho A. Tang]
+pow37b5yel        [Acho A. Tang] (only the first part)
+powj36rc2gre      [Acho A. Tang]
+sidearms060red    [Acho A. Tang]
+sidearms055gre    [Acho A. Tang]
+turtship37b5yel   [Acho A. Tang]
+roadblst35b10yel  [Aaron Giles]
+kinst063red       [Aaron Giles]
+
+
+MAME Testers bugs to check
+--------------------------
+
+krzybowl058gre  - does this still apply? please check
+seta2c060yel    - does this still apply? please check
+myangel056gre   - this was probably fixed a couple of releases ago, please check
+avengers061gre2 - can this be verified on a real US board? Might be a bug in the original.
+
+
+These drivers have improved GRAPHICS:
+-------------------------------------
+
+- Fixes to CPS2 raster effects. [Shiriru]
+
+- Preliminary starfield emulation in Sidearms. [Acho A. Tang]
+
+- Cleaned up some Nichibutsu mahjong games, added LCD support to House Mannequin and
+  Bijokko Yume Monogatari. [Nicola Salmoria]
+
+- Major improvements to the Jaleco Mega System 32 games. [Nicola Salmoria]
+
+
+These drivers have improved SOUND:
+----------------------------------
+
+- Fixed sound in Fire Truck, Super Bug, Monte Carlo. [Derrick Renaud]
+
+- Fixed some issues with uPD7759 (TMNT, 88 Games, P.O.W.) [Acho A. Tang]
+
+
+Changes to the main program:
+----------------------------
+
+- Optimized V60/V70 memory access. [Aaron Giles]
+
+- Added stereo support to the X1-010 emulator and made it a proper sound core.
+  [Nicola Salmoria]
+
+
+New games supported:
+--------------------
+
+Orange Club - Maruhi Kagai Jugyou [Nicola Salmoria]
+Mahjong-zukino Korinai Menmen [Nicola Salmoria]
+Idol no Himitsu [Nicola Salmoria]
+Kanatsuen no Onna [Nicola Salmoria]
+Pairs [MooglyGuy]
+Tao Taido [David Haywood, Stephane Humbert]
+Perestroika Girls [David Haywood]
+Ryuusei Janshi Kirara Star [Malice]
+Hayaoshi Quiz Ouza Ketteisen [Malice]
+Mouser [Frank Palazzolo]
+Ribbit! [Aaron Giles]
+
+
+==========================================================================
+
+0.64
+
+
+MAME Testers bugs fixed (there are probably more)
+-----------------------
+
+spaceint061red [Stefan Jokish]
+robocop2056gre [Bryan McPhail]
+stoneage060gre [Bryan McPhail]
+
+
+These drivers have improved GRAPHICS:
+-------------------------------------
+
+- Fixed priorities and shadows in Skull & Crossbones. [Aaron Giles]
+
+
+These drivers have improved SOUND:
+----------------------------------
+
+- Sound in Reikai Doushi [Nicola Salmoria]
+
+
+Other drivers changes:
+----------------------
+
+- Simulated the 8751 protection in Fire Trap. [Bryan McPhail]
+
+
+New games supported:
+--------------------
+
+Tickee Tickats [Aaron Giles]
+Crowns Golf [Aaron Giles]
+Ultimate Tennis [Aaron Giles, Nicola Salmoria]
+Stone Ball [Aaron Giles, Nicola Salmoria]
+Cheese Chase [Aaron Giles, Nicola Salmoria]
+Mahjong Kojinkyouju (Private Teacher) [Nicola Salmoria]
+Mahjong Vitamin C [Nicola Salmoria]
+Mahjong-yougo no Kisotairyoku [Nicola Salmoria]
+Mahjong Kinjirareta Asobi [Nicola Salmoria]
+Mahjong Lemon Angel [Nicola Salmoria]
+Mahjong Jogakuen [Nicola Salmoria]
+Mahjong Ikagadesuka [Nicola Salmoria]
+Raiga - Strato Fighter
+Edward Randy [Bryan McPhail]
+Mutant Fighter / Death Brade [Bryan McPhail]
+Wizard Fire / Dark Seal 2 [Bryan McPhail]
+Zombie Raid [David Haywood]
+Enforce
+Shot Rider [Tomasz Slanina]
+
+
+New clones supported:
+---------------------
+
+Shadow Warriors (set 2)
+Carrier Air Wing (US)
+Chi-Toitsu (= Mahjong Gakuen)
+Mahjong Nanpa Story (Ura)
+
+
+==========================================================================
+
+
+0.63
+
+An interim release with many things submitted in the past two months not
+included yet.
+
+
+These drivers have improved GRAPHICS:
+-------------------------------------
+
+- Subroc-3D, Turbo and Buck Rogers use the artwork to show the LED counters.
+  [Stefan Jokish]
+
+- Fixed colors in Dynamic Ski. [Stefan Jokish]
+
+
+These drivers have improved SOUND:
+----------------------------------
+
+- Samples support in Subroc-3D [Dave France]
+
+- Fixed noie frequency in the Exidy games. [Jim Hernandez]
+
+- Preliminary Namco NA sound support. [Phil Stroffolino]
+
+
+Other drivers changes:
+----------------------
+
+- Partially simulated the protection in Birdie Try [Angelo Salese]
+
+- Improved decryption in Quiz F1 1-2 Finish, it's still incomplete though.
+  [Angelo Salese]
+
+- Fixed ball position recognition in Golfing Greats. [Olivier Galibert]
+
+
+Changes to the main program:
+----------------------------
+
+- New options -nodisclaimer and -nogameinfo to disable startup screens.
+  Warnings about incorrect emulation are not disabled. [Aaron Giles]
+
+- Replaced RDTSC timing with QueryPerformanceCounter. This should fix problems
+  on SpeedStep notebooks. It seems, however, that it causes even worse problems
+  on other machines. Therefore, the old behaviour can be forced with the new
+  -rdtsc option. [smf]
+
+
+Source:
+-------
+
+- Now compiled with MinGW 2.0/GCC 3.2. There might be bugs caused by the new
+  compiler, let us know.
+
+- All new, much better, YM2413 emulation. [Jarek Burczynski]
+
+- Drum support in YM2608 emulation (check e.g. Tail 2 Nose). [Jarek Burczynski]
+
+- Moved most of the file I/O out of the OS depndant code and into the core.
+  Added two new types, mame_file and osd_file, which enforce better type
+  checking throughout the system (and prevents confusing the two).
+  Instead of calling osd_fopen, osd_fread, osd_fwrite, etc., you now call
+  mame_fopen, mame_fread, mame_fwrite, etc. The osd_* calls are reserved
+  to the core.
+  All the ZIP handling is done in the mame_file functions, so it will be
+  inherited by all ports.
+  [Aaron Giles]
+
+- [Win32] The diff, snap, cfg, nvram, etc. directories are created
+  automatically if they don't exist the first time MAME tries to create a file
+  there. [Aaron Giles]
+
+- MIPS III/IV CPU cores. [Aaron Giles]
+
+- ADSP-2115 CPU support. [Aaron Giles]
+
+- TMS32025 CPU core. [Quench]
+
+- Fixed YMF278B emulation. [R.Belmont]
+
+
+MAME Testers bugs fixed (there are probably more)
+-----------------------
+
+galaga37b8gre [Satoshi Suzuki]
+galaga37b16gre [Satoshi Suzuki]
+cutieq37b2gre [Stephane Humbert]
+crusn062gre [Aaron Giles]
+totcarn062gre [Aaron Giles]
+commsega062gra [Stephane Humbert]
+wiping062red [Stefan Jokish]
+heartatk062red [Stefan Jokish]
+polyplay060red [Stefan Jokish]
+
+
+New games supported:
+--------------------
+
+Off Road Challenge [Aaron Giles]
+Shrike Avenger [Aaron Giles]
+War Gods [Aaron Giles]
+Grudge Match [Aaron Giles]
+Sharpshooter [Aaron Giles]
+Killer Instinct [Aaron Giles, Bryan McPhail]
+Killer Instinct 2 [Aaron Giles, Bryan McPhail]
+Dr. Micro [Uki]
+Run and Gun [R.Belmont]
+Holosseum [David Haywood, Olivier Galibert, R. Belmont, Farfetch'd]
+Super Visual Football [David Haywood, Olivier Galibert, R. Belmont, Farfetch'd]
+Burning Rivals [David Haywood, Olivier Galibert, R. Belmont, Farfetch'd]
+Rad Mobile [David Haywood, Olivier Galibert, R. Belmont, Farfetch'd]
+Rad Rally [David Haywood, Olivier Galibert, R. Belmont, Farfetch'd]
+F1 Exhaust Note [David Haywood, Olivier Galibert, R. Belmont, Farfetch'd]
+Alien 3 [David Haywood, Olivier Galibert, R. Belmont, Farfetch'd]
+Sonic [David Haywood, Olivier Galibert, R. Belmont, Farfetch'd]
+Golden Axe 2 [David Haywood, Olivier Galibert, R. Belmont, Farfetch'd]
+Spiderman [David Haywood, Olivier Galibert, R. Belmont, Farfetch'd]
+Arabian Fight [David Haywood, Olivier Galibert, R. Belmont, Farfetch'd]
+Gumbo [David Haywood]
+Golly Ghost [Phil Stroffolino]
+Moon Shuttle [Zsolt Vasvari]
+SF-X [Zsolt Vasvari]
+Mighty Monkey [Zsolt Vasvari]
+Triv Two [David Haywood]
+Pirates [David Haywood, Nicola Salmoria, Paul Priest]
+Free Kick [Tomasz Slanina]
+Perfect Billiard [Nicola Salmoria]
+Wakakusamonogatari Mahjong Yonshimai [Nicola Salmoria]
+Got-cha [Nicola Salmoria]
+Formula 1 Grand Prix Part II [Nicola Salmoria]
+Real Mahjong Haihai [Nicola Salmoria]
+Real Mahjong Haihai Jinji Idou Hen [Nicola Salmoria]
+Real Mahjong Haihai Seichouhen [Nicola Salmoria]
+Mahjong Kyou Jidai [Nicola Salmoria]
+The Mah-jong [Uki]
+Mahjong Hourouki Part 1 - Seisyun Hen [Nicola Salmoria]
+Mahjong Hourouki Gaiden [Nicola Salmoria]
+Mahjong Hourouki Okite [Nicola Salmoria]
+Mahjong Clinic [Nicola Salmoria]
+Mahjong Rokumeikan [Nicola Salmoria]
+Tugboat [MooglyGuy, Nicola Salmoria]
+Super Triv 2 [MooglyGuy]
+Penguin Bros
+Target Hits [Manuel Abadia]
+TH Strikes Back [Manuel Abadia]
+Alligator Hunt [Manuel Abadia]
+World Rally 2: Twin Racing [Manuel Abadia]
+Maniac Squares [Manuel Abadia]
+Snow Board Championship [Manuel Abadia]
+Bang! [Manuel Abadia]
+Boomer Rang'r / Genesis [Bryan McPhail]
+Kamikaze Cabbie [Bryan McPhail]
+Liberation [Bryan McPhail]
+P-47 Aces
+
+
+New clones supported:
+---------------------
+
+Nostradamus (Korea)
+Cruis'n World (rev L2.0)
+Terminator 2 (LA2)
+Super High Impact (prototype)
+Mr Kougar (set 2)
+Donkey Kong Jr (bootleg on Galaxians hardware)
+Police Trainer (older)
+Hokuha Syourin Hiryu no Ken (=Shanghai Kid)
+
+
+==========================================================================
+
+
+0.62
+
+LICENSE CHANGE WARNING:
+We are considering changing distribution license, switching to GPL for the
+whole project and LGPL for some CPU and sound cores.
+If you contributed code to MAME and are against this change, now is the
+right time to let us know.
+
+
+These drivers have improved GRAPHICS:
+-------------------------------------
+
+- Improved raster effects in CPS2 games. [Barry Rodewald]
+
+- Fixed priorities in several Atari games. [Aaron Giles]
+
+- Sprite alpha blending in the Taito F3 games. [Shiriru]
+
+
+These drivers have improved SOUND:
+----------------------------------
+
+- Improved sound in Asteroids. [Ken Reneris]
+
+- Sound in Bal Cube and Bang Bang Ball, and in the Psikyo games.
+  [Olivier Galibert]
+
+- Rewritten sound support for the Seta games. [Manbow-J]
+
+- Sound in Blazing Tornado. [R.Belmont]
+
+- Fixed sound in Battle Bakraid. [R.Belmont]
+
+- Fixed cracking and missing sounds in some neogeo games especially kof99 "how
+  to play" loop and shocktro end of attract missing sound. [ElSemi]
+
+- Sound in Hard Drivin'. [Aaron Giles]
+
+
+Other drivers changes:
+----------------------
+
+- CusKey simulation for Namco games. [John Wil]
+
+
+Changes to the main program:
+----------------------------
+
+- Fixed keyboard LEDs being messed up on program exit. [Paul Priest]
+
+- TESTDRIVER's are now part of the database used by -romident and -isknown.
+  [Nicola Salmoria]
+
+
+Source:
+-------
+
+- Screen rotation is now entirely handled at blit time by the OS layer. The
+  core no longer prerotates the bitmap. [Aaron Giles]
+
+- Preliminary YMF278B emulation (missing FM support). [R.Belmont]
+
+- Implementation of the SH7604 internal timers, giving sound to Sol Divide and
+  the Super Kaneko Nova System games. [R.Belmont]
+
+- V70 CPU support. [Olivier Galibert]
+
+- DSP32 CPU emulation. [Aaron Giles]
+
+- TMS32013 CPU emulation. [Aaron Giles]
+
+
+MAME Testers bugs fixed (there are probably more)
+-----------------------
+
+bjourney061gre
+doubledr36rc1gre [ElSemi]
+crosshairs061yel [Robin Merrill]
+tnzs36b16yel MIGHT be fixed - needs thorough testing [Kale]
+deco8061red [Paul Priest]
+blstroidc061gra
+bking236b14yel [Stefan Jokish]
+bking237b14gre [Stefan Jokish]
+fround37b16gre [Bryan McPhail]
+vulcan37b13gre [Bryan McPhail]
+vulcan237b1gre [Bryan McPhail]
+vulcan137b1gre [Bryan McPhail]
+
+
+New games supported:
+--------------------
+
+Fantasia II [Nicola Salmoria]
+Golden Fire II [Nicola Salmoria]
+Bouncing Balls [ElSemi]
+Dragon World II [David Haywood, ElSemi]
+Tengai / Sengoku Blade [Paul Priest]
+Magical Cat Adventure [Paul Priest, David Haywood]
+Nostradamus [Paul Priest, David Haywood]
+Strikers 1945 [Olivier Galibert, R.Belmont]
+IPM Invader
+Green Beret
+Escape Kids [Ohsaki Masayuki]
+Solvalou [Phil Stroffolino]
+Star Blade [Phil Stroffolino]
+Prop Cycle [Phil Stroffolino]
+Lucky & Wild [Phil Stroffolino]
+Super World Stadium '95 [Phil Stroffolino]
+Metal Hawk [Phil Stroffolino]
+Steel Gunner 2 [Phil Stroffolino]
+Amazon [Phil Stroffolino]
+Kid no Hore Hore Daisakusen [Phil Stroffolino, Stephane Humbert]
+Legion [David Haywood, Phil Stroffolino]
+Dragonball Z 2 Super Battle [David Haywood]
+Daioh [David Haywood]
+Cyvern [Sylvain Glaize, David Haywood]
+Sen-Know [Sylvain Glaize, David Haywood]
+Gals Panic 4 [Sylvain Glaize, David Haywood]
+Gals Panic S - Extra Edition [Sylvain Glaize, David Haywood]
+Gals Panic S2 [Sylvain Glaize, David Haywood]
+Panic Street [Sylvain Glaize, David Haywood]
+PuzzLoop [Sylvain Glaize, David Haywood]
+Jan Jan Paradise [Sylvain Glaize, David Haywood]
+Jan Jan Paradise 2 [Sylvain Glaize, David Haywood]
+Otome Ryouran [Sylvain Glaize, David Haywood]
+Tel Jan [Sylvain Glaize, David Haywood]
+Sengeki Striker [Sylvain Glaize, David Haywood]
+Speed Ball [Aaron Giles]
+Race Drivin' [Aaron Giles]
+Steel Talons [Aaron Giles]
+Asylum [Aaron Giles]
+Cruis'n USA [Aaron Giles]
+Cruis'n World [Aaron Giles]
+Area 51 [Aaron Giles]
+Maximum Force [Aaron Giles]
+Vicious Circle [Aaron Giles]
+Sky Raider [Stefan Jokish]
+Starship 1 [Frank Palazzolo, Stefan Jokish]
+Desert War [David Haywood, Paul Priest, Stephane Humbert]
+Gratia - Second Earth [David Haywood, Paul Priest, Stephane Humbert]
+The Game Paradise - Master of Shooting! [David Haywood, Paul Priest, Stephane Humbert]
+One Shot One Kill [David Haywood, Paul Priest, Stephane Humbert]
+Tetris Plus [David Haywood, Paul Priest, Stephane Humbert]
+Best Bout Boxing [David Haywood, Paul Priest, Stephane Humbert]
+Super Slam [David Haywood]
+Aquarium [David Haywood]
+S.S. Mission [David Haywood]
+Fit of Fighting [David Haywood]
+The History of Martial Arts [David Haywood]
+Indoor Soccer [David Haywood]
+Diver Boy [David Haywood]
+Speed Spin [David Haywood]
+Masked Riders Club Battle Race [David Haywood, Stephane Humbert]
+Hanaroku [David Haywood, Stephane Humbert]
+Fancy World - Earth of Crisis [David Haywood, Stephane Humbert]
+Flower [InsideOutBoy, David Haywood, Stephane Humbert]
+Ace [Jarek Burczynski]
+N.Y. Captor [Tomasz Slanina]
+Beam Invader [Zsolt Vasvari]
+Zarya Vostoka [Zsolt Vasvari]
+Megadon [Mike Haaland]
+Catapult [Mike Haaland]
+4 En Raya [Tomasz Slanina]
+Sky Skipper
+Gomoku Narabe Renju [Takahiro Nogi]
+
+
+New clones supported:
+---------------------
+
+Sanrin San Chan (= Spatter)
+New Rally X (vertical bootleg)
+Lode Runner - The Dig Fight (ver. A)
+Samurai Aces (= Sengoku Ace)
+Big Striker (bootleg)
+X-Men (US 2 Players)
+MatchIt (= Sichuan 2)
+Super Basketball (version G)
+Thunder Cross II (Asia)
+Alpha Fighter / Head On
+Donkey Kong (US set 2)
+Triple Fun (= Oishii Puzzle)
+Blandia
+Centipede (1 player, timed)
+Raiden [Taiwan]
+Goindol (World and Japan)
+Super Volleyball (US)
+Strikers 1945 (Japan, unprotected)
+
+
+==========================================================================
+
+
+0.61
+
+
+These drivers have improved GRAPHICS:
+-------------------------------------
+
+- Fixed tilemaps in Sotsugyo Shousho. [Nicola Salmoria]
+
+- Fixed graphics in Pinbo. [Zsolt Vasvari]
+
+- Improved raster effects handling in NeoGeo games. [Razoola]
+
+- Improved gfx in HAL21. [Acho A. Tang]
+
+- Preliminary support for raster effects in CPS2 games. [Barry Rodewald]
+
+- Added alpha blending to Psikyo games. [Paul Priest]
+
+
+These drivers have improved SOUND:
+----------------------------------
+
+- Fixed Y8950 confincting with YM3812/YM3526 in some SNK games.
+  [Jarek Burczynski]
+
+- Fixed sound in Spinal Breakers. [Nicola Salmoria]
+
+- Sound in HAL21. [Acho A. Tang]
+
+
+Other drivers changes:
+----------------------
+
+- Fixed controls & gfx in Outrun and Space Harrier. [Bryan McPhail]
+
+- Simulated protection in S.P.Y. [Acho A. Tang]
+
+- Fixed Rip Cord. [Acho A. Tang]
+
+- Fixed collision detection in Labyrinth Runner and Fast Lane. [Acho A. Tang]
+
+- Fixed protection in Funky Jet [Bryan mcPhail, Stephane Humbert]
+
+- Several fixes to the F3 games. [Shiriru, Bryan McPhail]
+
+
+Changes to the main program:
+----------------------------
+
+- Light gun support. [Bryan McPhail]
+
+
+Source:
+-------
+
+- Important for porters: major redesign of the OS interface for display update.
+  - VIDEO_SUPPORTS_DIRTY flag removed
+  - osd_mark_dirty() removed
+  - osd_create_display() now takes an extra parameter rgb_components
+  - osd_set_visible_area() removed
+  - osd_allocate_colors() removed
+  - osd_modify_pen() removed
+  - osd_update_video_and_audio() now takes a mame_display pointer
+  - osd_debugger_focus() removed
+  - osd_set/get_gamma() removed
+  - osd_set/get_brightness() removed
+  [Aaron Giles]
+
+- Completely redesigned the artwork handling. Any game can now use artwork,
+  with no specific support in the driver. Configuration is done with external
+  .art files. [Aaron Giles]
+  -[no]artcrop -- crops artwork to the game screen area only
+  -[no]backdrop -- enables/disables backdrop art
+  -[no]overlay -- enables/disables overlay art
+  -[no]bezel -- enables/disables bezel art
+
+- The Windows version now rotates the screen at blit time instead of requiring
+  the core to do so. Since the new code is usually faster than the old one, and
+  it allows for great simplifications in the core, rotation at blit time will
+  probably be a requirement in next release. Porters are advised to begin
+  implementing it now. [Aaron Giles]
+
+- New YM-2413 emulator. [Fabio R. Schmidlin, Charles Mac Donald]
+
+
+MAME Testers bugs fixed (there are probably more)
+-----------------------
+
+mk3060gre
+ozmawars055gra
+alpine057gra     [Stephane Humbert]
+elevator057gra   [Stephane Humbert]
+tinstar36b4gra   [Stephane Humbert]
+kof94057gre      [RYO]
+tokib059red      [David Graves]
+dogyuun058yel    [Quench]
+battleg37B10gre  [Quench]
+batrider058gre   [Quench]
+cchasm1059red    [Paul Priest]
+dspirit37b6gre   [Acho A. Tang]
+rompers36rc2gre  [Acho A. Tang]
+rompers37b4gre   [Acho A. Tang]
+splatter336b6gre [Acho A. Tang]
+splatter336b9yel [Acho A. Tang]
+splatter137b5gre [Acho A. Tang]
+splatter237b5gre [Acho A. Tang]
+splatter057gre   [Acho A. Tang]
+dangseed060yel (needs checking)
+bjourney37b16gre [Acho A. Tang]
+ncombat36b3yel   [Acho A. Tang]
+ncommand37b2gre  [Acho A. Tang]
+overtop37b13red
+sdodgeb37b13yel (needs checking)
+iganinju37b14yel [Kale]
+iganinju37b1yel  [Kale]
+iganinju055yel   [Kale]
+scudhamm058gre   [Mike Herrin]
+adstick37b16gre  [Robin Merrill]
+pedal055yel      [Robin Merrill]
+toobin058yel     [Robin Merrill]
+
+
+New games supported:
+--------------------
+
+Super Slams [David Haywood]
+Macross Plus [David Haywood]
+Quiz Bisyoujo Senshi Sailor Moon - Chiryoku Tairyoku Toki no Un [David Haywood]
+Jump Kids [David Haywood]
+Toffy [David Haywood]
+Super Toffy [David Haywood]
+Battle Cross [David Haywood]
+Gulf War II [David Haywood]
+Bubble 2000 [David Haywood]
+4 Fun in 1 [David Haywood]
+Kick Goal [David Haywood, Nicola Salmoria]
+U.S. Games collections [David Haywood, Nicola Salmoria]
+Wily Tower [Nicola Salmoria]
+Lethal Crash Race [Nicola Salmoria]
+F-1 Grand Prix [Nicola Salmoria]
+Dog-Fight [Nicola Salmoria]
+Find Out [Nicola Salmoria]
+Golfing Greats [Nicola Salmoria]
+Sankokushi [Nicola Salmoria]
+Super Shanghai Dragon's Eye [Bryan McPhail]
+Mechanized Attack [Bryan McPhail]
+Beast Busters [Bryan McPhail]
+Thunder Zone / Desert Assault [Bryan McPhail]
+The Next Space [Bryan McPhail, Acho A. Tang]
+Bakutotsu Kijuutei [Acho A. Tang]
+Equites [Acho A. Tang]
+Bull Fighter [Acho A. Tang]
+The Koukouyakyuh [Acho A. Tang]
+Splendor Blast [Acho A. Tang]
+High Voltage [Acho A. Tang]
+Red Robin [Zsolt Vasvari]
+Net Wars [Zsolt Vasvari]
+Clay Shoot [Zsolt Vasvari]
+Mr. Kougar [Zsolt Vasvari]
+Car Polo [Zsolt Vasvari]
+Dingo [M*A*S*H, Zsolt Vasvari]
+Birdie King [M*A*S*H]
+Inferno [Juergen Buchmueller, Aaron Giles]
+Dribbling [Aaron Giles]
+Triple Hunt [Stefan Jokish]
+Orbit [Stefan Jokish]
+Monte Carlo [Stefan Jokish]
+Tube Panic [Jarek Burczynski]
+Roller Jammer [Jarek Burczynski]
+Kikiippatsu Mayumi-chan [Uki]
+Knights of Valour / Sango [ElSemi]
+Battle Bakraider [Quench]
+
+
+New clones supported:
+---------------------
+
+ESP Ra.De (International Ver 1998 4/22)
+ESP Ra. De. (Japan Ver 1998 4/21)
+The Outfoxies (Japan)
+Tactician (set 2)
+Battles (=Xevious)
+Power Spikes (World)
+Condor (= Phoenix)
+Grind Stormer (set 2)
+Battle Garegga (set 2)
+Hell Fire (1 player)
+Same! Same! Same! (2 players)
+Gravitar (prototype)
+Lunar Battle (= Gravitar)
+Super Cobra (Sega)
+S.P.Y. (World)
+Air Buster (English)
+Baraduke (set 2)
+Metro-Cross (set 2)
+Red Hawk (= Stagger I)
+Bagman (bootleg on Galaxian hardware)
+
+
+==========================================================================
+
+
+0.60
+
+
+These drivers have improved GRAPHICS:
+-------------------------------------
+
+- Fixed disappearing enemies in later levels of Batsugun. [Kale]
+
+- Fixed colors in Wec Le Mans and wrong graphics in Hot Chase. [Acho A. Tang]
+
+
+These drivers have improved SOUND:
+----------------------------------
+
+- Improved Irem GA20 emulation, used by M92 games. [Acho A. Tang]
+
+
+Other drivers changes:
+----------------------
+
+- Fixed several problems in Kiki KaiKai. [Acho A. Tang]
+
+- Several fixes to Psikyo games. [Paul Priest, David Haywood]
+
+- Several fixes to nemesis.c. [Hau]
+
+
+Changes to the main program:
+----------------------------
+
+- Support for external configuration files for special controllers; this
+  replaces the -hotrod and -hotrodse options. See ctrl.txt for the detailed
+  explanation. [Ron Fries]
+
+- Complete rewrite of the cheat engine. [Ian Patterson]
+
+
+Source:
+-------
+
+- New function memory_set_unmap_value(), to specify the value returned when an
+  unmapped memory address is read. [Aaron Giles]
+
+- Fixes to Y8950 sample playback. [Acho A. Tang]
+
+- Complete rewrite of YM3812/YM3526/Y8950 emulation, verified on the real chip.
+  [Jarek Burczynski]
+
+- osd_opl_control() and osd_opl_write() removed; direct access to the
+  SoundBlaster OPL chip is no longer useful.
+
+
+MAME Testers bugs fixed (there are probably more)
+-----------------------
+
+blmbycar059red
+uopoko059red
+gcpinbal059red
+jitsupro059red
+metroc059red
+phelios059red
+paclandc059red
+ncv1058red
+av2mj059red
+fromancec058red
+neogeoc37b15gre
+fround056red
+bioatack37b6gre
+crush057gre
+driverc056ora
+batsugun37b6gre
+
+
+New games supported:
+--------------------
+
+Judge Dredd [Aaron Giles]
+Primal Rage [Aaron Giles]
+Road Riot's Revenge [Aaron Giles]
+World Class Bowling [Aaron Giles]
+Tactician [Nicola Salmoria, Stephane Humbert]
+The Masters of Kin [Nicola Salmoria]
+IQ Block [Nicola Salmoria, Ernesto Corvi]
+Taxi Driver [Nicola Salmoria]
+Block Gal [Angelo Salese]
+Drag Race [Stefan Jokisch]
+Pool Shark [Stefan Jokisch]
+The Outfoxies [Phil Stroffolino]
+Oriental Legend [ElSemi, David Haywood]
+News [David Haywood]
+Shadow Force [David Haywood]
+The Legend of Silk Road [David Haywood, Stephane Humbert, R.Belmont]
+Miss Bubble 2 [David Haywood]
+Black Heart [from Raine]
+Mustang [from Raine]
+Many Bloc [David Haywood, Stephan Humbert]
+Xyonix [David Haywood, Stephan Humbert, Nicola Salmoria]
+Hyper Pacman [David Haywood, Stephan Humbert]
+Mille Miglia 2: Great 1000 Miles Rally [David Haywood, Stephan Humbert]
+Formation Z [Acho A. Tang]
+Tank Busters [Jarek Burczynski]
+Hyper Duel [E. Watanabe]
+
+
+New clones supported:
+---------------------
+
+Pengo (bootleg)
+Bone Crusher (= Knuckle Joe)
+Fighter & Attacker (= F/A)
+Knuckle Heads (World)
+Hero in the Castle of Doom (Donkey Kong conversion)
+Blood Storm (v1.10)
+Fighting Golf (set 2)
+Clowns (rev 1)
+Magic Worm (= Centipede)
+Hot Shots Tennis (V1.0)
+Strata Bowling (V1)
+Pirate Pete (= Jungle King)
+Street Fighter (prototype)
+Nebulas Ray (World)
+Gun Bird (World)
+Bubble Symphony (Europe)
+Space Invaders '95 (US)
+C.O.W. Boys of Moo Mesa (World)
+R-Type Leo (World)
+Dragon Punch (= Sports Match)
+
+
+==========================================================================
+
+
+0.59
+
+
+Other drivers changes:
+----------------------
+
+- Loads of fixes to input ports etc. in several drivers. [Stephane Humbert]
+
+- Fixed Rainbow Islands and Rainbow Islands Extra c-chip emulation
+  [Robert Gallagher, Tormod Tjaberg]
+
+- Fixed Super Stingray and Kyros, and most problems in Gold Medalist.
+  [Acho A. Tang]
+
+
+Changes to the main program:
+----------------------------
+
+- [Windows] Some changes to use less CPU time when it's not needed.
+  Use -nosleep to disable this behaviour during gameplay. [Aaron Giles]
+
+- [Windows] MMX implementation of the tilemap drawing code, providing a 5-10%
+  speed increase with some games. [Andrea Mazzoleni]
+
+
+Source:
+-------
+
+- Rewritten the UPD7759 emulator (used by TMNT etc). [Olivier Galibert]
+
+- Support for compressed hard disk images. [Aaron Giles]
+
+- New function tilemap_set_palette_offset() to set a global palette offset
+  without having to use tilemap_mark_all_tiles_dirty(). [Aaron Giles]
+
+
+MAME Testers bugs fixed (there are probably more)
+-----------------------
+
+eto37b9gre
+captaven058gre_2
+captaven058gre_5
+thndrx2058red
+punchoutc37b15gre
+skyadvnt136b8gre
+gangwars37b15gre
+
+
+New games supported:
+--------------------
+
+Police Trainer [Aaron Giles]
+Pass [David Haywood, Stephan Humbert]
+Super Pinball Action [David Haywood, Stephan Humbert]
+Sol Divide [David Haywood]
+Strikers 1945 II [David Haywood]
+Space Bomber [David Haywood]
+Daraku Tenshi - The Fallen Angels [David Haywood]
+Gunbird 2 [David Haywood]
+Mahjong Sisters [Uki]
+Quiz Gakuen Paradise [Uki]
+Quiz DNA no Hanran [Uki]
+Quiz Gekiretsu Scramble [Uki]
+Wild West C.O.W.boys of Moo Mesa [R.Belmont]
+Bucky O'Hare [R.Belmont]
+Super Bug [Stefan Jokisch]
+Paddle Mania [Acho A. Tang]
+Scorpion [Stephane Humbert]
+
+
+New clones supported:
+---------------------
+
+Dynasty Wars (World)
+Captain America (Japan)
+Gradius 3 (World?)
+Magical Crystals (World)
+Crystal Castles (version 4)
+Moon Cresta (Nichibutsu set 2)
+Galaxian (Midway, old rev)
+Pisces (original)
+Haunted Castle (Japan version N)
+Beraboh Man (Japan version B)
+
+
+==========================================================================
+
+
+0.58
+
+
+Other drivers changes:
+----------------------
+
+- Fixed (?) collision detection in Thunder Cross. [Eddie Edwards]
+
+- Fixed the VLM5030 emulation (Punch Out, Track & Field, Yie-Ar Kung Fu etc.).
+  [Tatsuyuki Satoj]
+
+
+Changes to the main program:
+----------------------------
+
+- [windows] New blitting effect "-effect sharp". This gives a sharper image
+  than the default. [John IV]
+
+
+Source:
+-------
+
+- New macros have been added to declare common callback functions and enforce
+  naming conventions. All drivers have been converted to the new macros:
+
+      void init_drivername()            -> DRIVER_INIT( name )
+      int generate_int()                -> INTERRUPT_GEN( func )
+      void name_init_machine()          -> MACHINE_INIT( name )
+      void nvram_handler()              -> NVRAM_HANDLER( name )
+      void name_vh_convert_color_prom() -> PALETTE_INIT( name )
+      int name_vh_start()               -> VIDEO_START( name )
+      void name_vh_stop()               -> VIDEO_STOP( name )
+      void name_vh_eof()                -> VIDEO_EOF( name )
+      void name_vh_screenrefresh()      -> VIDEO_UPDATE( name )
+
+- Major change to the way machine drivers are set up. A series of macros is
+  now available (defined in driver.h) to "build up" a machine driver. The
+  ordering of items in the machine driver is arbitrary, apart from CPU-specific
+  data, which is tied to the most-recently referenced CPU. With this new format,
+  machine drivers can now be built by modifying another machine driver,
+  providing a primitive inheritance mechanism. See any driver for an example
+  of the new format. See mcr.c for a more complex example of inheritance.
+
+- New functions auto_bitmap_alloc() and auto_bitmap_alloc_depth() are now
+  available to create automatically managed bitmaps. Combined with auto_malloc(),
+  there is no need for a video_stop function in most cases. All existing
+  drivers have been modified to take advantage of these features.
+
+- The old interrupt system has now been made officially obsolete. This means
+  that the function cpu_cause_interrupt() is no longer available; you must use
+  cpu_set_irq_line() or cpu_set_irq_line_and_vector() instead. It also means
+  that a number of old/conflicting constants have been removed. In addition,
+  interrupt generation callbacks for CPUs no longer return an IRQ line or
+  vector. Instead, the interrupt callback must actively cause the interrupt
+  via cpu_set_irq_line(). All existing drivers have been updated to these
+  changes.
+
+- New interrupt callback functions: nmi_line_pulse(), nmi_line_assert(),
+  irqn_line_hold(), irqn_line_pulse(), irqn_line_assert(). These functions
+  replace the old interrupt() and nmi_interrupt() callbacks and can be used
+  directly as interrupt callbacks.
+
+- The function tilemap_set_clip() has been removed. In its place, there is a
+  new 'cliprect' parameter to tilemap_draw(). All existing drivers have been
+  updated to support this change.
+
+- In preparation for partial updating support, the parameters to video_update
+  have changed. A new parameter 'cliprect' has been added, which should be
+  honored. In the future, the parameter will contain the subset of the screen
+  to render; for now, it just contains Machine->visible_area. In addition,
+  the 'full_refresh' parameter is gone; update functions must always redraw
+  the requested portion of the bitmap. Some drivers have been updated to fully
+  support the cliprect; others still need to be updated.
+
+- Two new functions have been added to the timer system. timer_create() creates
+  a new "permanent" timer, and timer_adjust() adjusts the scheduling of that
+  timer. This is now the only way to dynamically manipulate a timer. The old
+  functions timer_set() and timer_pulse() are still around, but they no longer
+  return a handle to the timer they create. Timers created with timer_create()
+  should be created at initialization time, not dynamically. Timers also now
+  participate in the automatic resource tracking, so there is no need to
+  explicitly dispose of them. All existing drivers have been updated with the
+  necessary changes.
+
+- Basic generic NVRAM handlers have been added. For a number of games, it is
+  sufficient to point the global variables 'generic_nvram' and
+  'generic_nvram_size' to the location and size of the NVRAM area. In the
+  machine driver, you can now specify 'generic_0fill' or 'generic_1fill' to
+  request a generic NVRAM handler. The 0fill and 1fill refer to how the memory
+  is initialized in the absence of an .nv file.
+
+- The following old functions and macros have now been fully deprecated:
+
+     cpu_get_pc()           -> activecpu_get_pc()
+     cpu_get_sp()           -> activecpu_get_sp()
+     cpu_getpreviouspc()    -> activecpu_get_previouspc()
+     cpu_get_reg()          -> activecpu_get_reg()
+     cpu_set_reg()          -> activecpu_set_reg()
+     cpu_set_op_base()      -> activecpu_set_op_base()
+     cpu_get_pc_byte()      -> activecpu_get_pc_byte()
+     READ_WORD              -> (no equivalent)
+     WRITE_WORD             -> (no equivalent)
+
+- New function force_partial_update(), call this to force a partial update to
+  occur up to and including the specified scanline. [Aaron Giles]
+
+- ARM CPU emulation [Bryan McPhail, Phil Stroffolino]
+
+
+MAME Testers bugs fixed (there are probably more)
+-----------------------
+
+rampart057yel
+artwork057gre
+mrgoemon36b16gre
+pigout37b4gre
+
+
+New games supported:
+--------------------
+
+Gun Force 2 [Chris Hardy]
+Angel Kids [David Haywood]
+Noboranka [Stephane Humbert]
+Steel Force [David Haywood, Stephan Humbert]
+Mug Smashers [David Haywood, Stephan Humbert]
+Captain America [Bryan McPhail]
+Lemmings [Bryan McPhail]
+Flyball [Stefan Jokisch]
+Grand Cross [David Graves]
+
+
+New clones supported:
+---------------------
+
+Mayday (set 3)
+Alpha One (prototype of Major Havoc)
+Blaster (kit)
+Buck Rogers (encrypted)
diff --git a/src/unix/doc/mame/windows.txt b/src/unix/doc/mame/windows.txt
new file mode 100644
index 0000000..f01c53b
--- /dev/null
+++ b/src/unix/doc/mame/windows.txt
@@ -0,0 +1,995 @@
+
+Using the program
+-----------------
+
+mame [name of the game to run] [options]
+
+For example:
+
+   mame mspacman -nosound
+
+...will run Ms Pac Man without sound
+
+
+Configuration options
+---------------------
+
+-createconfig / -cc
+
+	Creates the default MAME.INI file. All the following configuration
+	options can be permanently changed by editing this configuration file.
+
+-showconfig / -sc
+
+	Displays the current configuration settings. If you route this to a
+	file, you can use it as an INI file. For example, the command:
+
+		mame -showconfig >mame.ini
+
+	is equivalent to -createconfig.
+
+-showusage / -su
+
+	Displays a summary of all the command line options. For options that
+	are not mentioned here, the short summary given by "mame -showusage" is
+	usually sufficient.
+
+-[no]readconfig / -[no]rc
+
+	Enables or disables the reading of the config files. When enabled
+	(which is the default), MAME reads the following config files in order:
+
+		- MAME.INI
+		- $MY_MAME.INI (i.e. if MAME was renamed MAME060.EXE, MAME
+				parses MAME060.INI here)
+		- MAMED.INI  (if this is a debug build, i.e. MAMED.EXE)
+		- VECTOR.INI (for vector games only)
+		- DRIVER.INI (based on the source filename of the driver)
+		- PARENT.INI (for clones only, may be called recursively)
+		- GAMENAME.INI
+
+	The settings in the later ini's override those in the earlier ini's.
+	So, for example, if you wanted to disable hardware stretch in the
+	vector games, you can create a VECTOR.INI with the "hwstretch 0" line
+	in it, and it will override whatever hwstretch value you have in your
+	MAME.INI.
+
+-[no]verbose / -[no]v
+
+	Displays some diagnostic information at startup. IMPORTANT: when
+	reporting bugs, please run with mame -verbose and include the resulting
+	information. It can be very helpful in tracking down problems. The
+	default is off (-noverbose)
+
+
+Windows path and directory options
+----------------------------------
+
+IMPORTANT: Please use the path, directory and file options ONLY in MAME.INI.
+Otherwise, the outcome may be unpredictable and not consistent across releases.
+
+-rompath / -rp
+
+	You can give a path (list of directories seperated by semicolons) of
+	directories to be searched for roms. The default is ROMS (that is, a
+	directory "roms" in the current directory).
+
+-samplepath / -sp
+
+	You can give a path (list of directories seperated by semicolons) of
+	directories to be searched for samples. The default is SAMPLES (that
+	is, a directory "samples" in the current directory).
+
+-inipath
+
+	You can give a path (list of directories seperated by semicolons) of
+	directories to be searched for INI-files. The default is .;ini (that
+	is, search in the current directory first, and then in the directory
+	"ini" in the current directory).
+
+-cfg_directory
+
+	After running a game, MAME stores some user changeable settings into
+	cfg_directory/gamename.cfg. Additionally, on the first start of MAME a
+	cfg_directory/default.cfg is created. The default is CFG.
+
+-nvram_directory
+
+	The original hardware of some games use non-volative ram chips to save
+	their configuration. The contents of these are saved into this
+	directory. The default is NVRAM.
+
+-memcard_directory
+
+	The original hardware of some games supports so-called memory cards.
+	The contents of these are stored here. The default is MEMCARD.
+
+-input_directory
+
+	Input recordings created by "-record" will be saved here and loaded by
+	"-playback". The default is INP.
+
+-hiscore_directory
+
+	If there exists a file HISCORE.DAT in the MAME directory, highscores
+	may also be saved for games that do not have the original hardware to
+	support this. The quality of this feature depends on the accuracy of
+	the externally available file HISCORE.DAT. The default is HI.
+
+-state_directory
+
+	MAME supports state saving for some games. These states will be saved
+	here. The default is STATE.
+
+-artwork_directory
+
+	Some games used extra artwork not created by electical circuits. MAME
+	supports such artwork in PNG image format, located in this directory.
+	The default is ARTWORK.
+
+-snapshot_directory
+
+	Screenshots will go here. The default is SNAP.
+
+-diff_directory
+
+	Directory for hard drive image difference files. The default is DIFF.
+
+-ctrlr_directory
+
+	This directory holds controller-specific input port mapping .ini files.
+	The default is CTRLR.
+
+-history_file
+
+	The default is HISTORY.DAT. Modifying the default may not work at the
+	moment.
+
+-mameinfo_file
+
+	The default is MAMEINFO.DAT. Modifying the default may not work at the
+	moment.
+
+-cheat_file
+
+	The default is CHEAT.DAT. Modifying the default may not work at the
+	moment.
+
+
+Windows video options
+---------------------
+
+-[no]autoframeskip / -[no]afs
+
+	Automatically determines the frameskip level while you're playing the
+	game, adjusting it constantly in a frantic attempt to keep the game
+	running at full speed. Turning this on overrides the value you have set
+	for -frameskip above. The default is ON (-autoframeskip).
+
+-frameskip / -fs
+
+	Specifies the frameskip value. This is the number of frames out of
+	every 12 to drop when running. For example, if you say -frameskip 2,
+	then MAME will display 10 out of every 12 frames. By skipping those
+	frames, you may be able to get full speed in a game that requires more
+	horsepower than your computer has. The default value is -frameskip 0,
+	which skips no frames.
+
+-[no]waitvsync
+
+	Waits for the refresh period on your computer's monitor to finish
+	before starting to draw video to your screen. If this option is off,
+	MAME will just draw to the screen at any old time, even in the middle
+	of a refresh cycle. This can cause "tearing" artifacts, where the top
+	portion of the screen is out of sync with the bottom portion. Tearing
+	is not noticeable on all games, and some people hate it more than
+	others. However, if you turn this option on, you will waste more of
+	your CPU cycles waiting for the proper time to draw, so you will see a
+	performance hit. The default is OFF (-nowaitvsync). This option
+	requires -ddraw.
+
+-[no]triplebuffer / -[no]tb
+
+	Enables or disables "triple buffering". Normally, MAME just draws
+	directly to the screen, without any fancy buffering. But with this
+	option enabled, MAME creates three buffers to draw to, and cycles
+	between them in order. It attempts to keep things flowing such that one
+	buffer is currently displayed, the second buffer is waiting to be
+	displayed, and the third buffer is being drawn to. Unfortunately, due
+	to some DirectDraw issues, this doesn't always work out as well as it
+	should. This is still being investigated. The default is OFF
+	(-notriplebuffer). This option required -ddraw and -nowindow.
+
+-[no]window
+
+	Run MAME in either in a window or full screen. The default is OFF
+	(-nowindow).
+
+-[no]ddraw / -[no]dd
+
+	This is really just for testing. It disables the use of DirectDraw,
+	which removes a lot of the features of the video system (-triplebuffer,
+	-waitvsync, -resolution, -refresh, -switchres, -switchbpp, -resolution,
+	-hwstretch all won't work). It will generally run really slowly. If
+	anyone has a legitimate use for this option, we'd be curious to know.
+	The default is ON (-ddraw).
+
+-[no]hwstretch / -[no]hws
+
+	MAME uses the hardware stretching abilities of modern graphic cards to
+	scale the game image to the requested resolution. Depending on the
+	quality of your graphic card and its drivers, this may be a fractional,
+	antialiased scaling (nice) or an integer, blocky scaling (not so nice).
+	In any case, you can disable this stretching altogether and let MAME do
+	the scaling in software, which is probably slower, though. The default
+	is ON (-hwstretch). Note: Vector games may actually look better with
+	"-nohws".
+
+-cleanstretch [option] / -cs [option]
+
+	Stretch the image to integer ratios only. This may leave a black border
+	around the image in fullscreen mode. The options are:
+
+		none	    disable. This will cause artifacts when using
+			    scanlines.
+		auto	    let the blitter decide. The d3d module will select
+			    the best option.
+		full	    always stretch to integer ratios both horizontally
+			    and vertically.
+		horizontal  always stretch to integer ratios horizontally.
+		vertical    always stretch to integer ratios vertically.
+
+	The default is AUTO (-cleanstretch auto). This option requires -ddraw
+	or -direct3d.
+
+-resolution wxh[xd] / -r wxh[xd]
+
+	Specifies an exact resolution to run in. In full screen mode, MAME will
+	try to use the specific resolution you request. The width (w) and
+	height (h) are required; the color depth (d) is optional. If omitted or
+	set to 0, MAME will determine the mode auomatically. For example,
+	-resolution 640x480 will force 640x480 resolution, but MAME is free to
+	choose the color depth. Similarly, -resolution 0x0x32 will force 32-bit
+	color depth, but allows MAME to choose the resolution. The string
+	"auto" is also supported, and is equivalent to 0x0x0. In window mode,
+	this resolution is used as a maximum size for the window. The default
+	is auto (-resolution auto). This option requires -ddraw for full screen
+	resolution switching.
+
+-refresh
+
+	Specifies a particular refresh rate to set your monitor to. If the
+	refresh rate is not found, or if this parameter is 0, the default
+	DirectDraw refresh rate is used. The default is -refresh 0. This option
+	requires -ddraw and -nowindow.
+
+-[no]scanlines / -[no]sl
+
+	Enables the classic MAME "scanlines" effect. The default is OFF
+	(-noscanlines). This option requires -nohwstretch.
+
+-[no]switchres
+
+	Enables resolution switching. This option is required for the
+	-resolution option to switch resolutions in full screen mode. On many
+	modern video cards with hardware stretching support, there is little
+	performance penalty at higher resolutions, so it is nice to be able to
+	get rid of the monitor resync time when you run in full screen mode.
+	This is also useful on LCD displays with a fixed resolution. The
+	default is ON (-switchres). This option requires -ddraw.
+
+-[no]switchbpp
+
+	Enables color depth switching. This option is required for the
+	-resolution option to switch color depths in full screen mode. This
+	option is useful if you normally run at 16, 24, or 32 bit color depth
+	on your desktop, and want to keep that color depth when you run MAME.
+	The default is ON (-switchbpp). This option requires -ddraw.
+
+-[no]maximize / -[no]max
+
+	Controls initial window size in windowed mode. If it is set on, the
+	window will initially stretch to the maximum supported size when you
+	start MAME. If it is turned off, the window will start out at the
+	smallest supported size. The default is ON (-maximize). This option
+	requires -window.
+
+-[no]keepaspect / -[no]ka
+
+	Enables aspect ratio enforcement. When this option is on, the game's
+	proper aspect ratio (generally 4:3 or 3:4) is enforced, so you get the
+	game looking like it should. When running in a window with this option
+	on, you can only resize the window to the proper aspect ratio, unless
+	you are holding down the CONTROL key. By turning the option off, the
+	aspect ratio is allowed to float. In full screen mode, this means that
+	all games will stretch to the full screen size (even vertical games).
+	In window mode, it means that you can freely resize the window without
+	any constraints. The default is ON (-keepaspect).
+
+-[no]matchrefresh
+
+	Enables refresh rate matching. When enabled, MAME will try to find the
+	closest refresh rate match that is greater than the game's refresh
+	rate. For example, if the game runs at 57fps, and you have 60, 70, 75Hz
+	refresh rates, MAME will choose 60Hz. If the game runs at 61fps, then
+	it will choose 70Hz. This is intended mainly for those who have tweaked
+	their video card's settings to provide carefully matched refresh rate
+	options. The default is OFF (-nomatchrefresh). This option requires
+	-ddraw and -nowindow.
+
+-[no]syncrefresh
+
+	Enables speed throttling only to the refresh of your monitor. This
+	means that the game's actual refresh rate is ignored; however, the
+	sound code still attempts to keep up with the game's original refresh
+	rate, so you may encounter sound problems. Again, this is intended
+	mainly for those who have tweaked their video card's settings to
+	provide carefully matched refresh rate options. The default is OFF
+	(-nosyncrefresh). This option requires -ddraw.
+
+-[no]throttle
+
+	Configures the default thottling setting. When throttling is on, MAME
+	attempts to keep the game running at the game's intended speed. When
+	throttling is off, MAME runs the game as fast as it can. The default is
+	ON (-throttle).
+
+-full_screen_brightness / -fsb
+
+	Some video cards adjust the brightness/gamma when they switch into full
+	screen mode. To counteract this, you can specify the
+	-full_screen_brightness value, which is a number between 0.1 and 2. 0.1
+	means 1/10th as bright as the default, and 2 means twice as bright.
+	Note that the hardware support for this option is not present on all
+	video cards. If you set a non-zero value, you may get a warning if MAME
+	was unable to set the brightness on your card. The default is 0, which
+	means that MAME will not attempt to adjust the brightness on your video
+	card at all. This option requires -ddraw and -nowindow.
+
+-frames_to_run / -ftr
+
+	This option can be used for benchmarking. It tells MAME to stop
+	execution after a fixed number of frames. By combining this with a
+	fixed set of other command line options, you can set up a consistent
+	environment for benchmarking MAME performance.
+
+-effect
+
+	Apply various blitting effects to emulate the look of Arcade monitors.
+	Using these modes comes at the cost of reduced emulation speed, which
+	is inherent to these modes. The current implementation is already as
+	fast as possible, using self-modifying assembly code. For some of
+	these, MMX is required. Possible values:
+
+		none	    no effect (this is the default)
+		sharp	    no effect, but gives a sharper image
+		scan25	    25% scanlines
+		scan50	    50% scanlines
+		scan75	    75% scanlines
+		scan75v     75% scanlines (vertical)
+		rgb3	    a certain "monitor mask"
+		rgb4	    another one
+		rgb4v	    another one (vertical)
+		rgb6	    another one
+		rgb16	    another one
+		rgbtiny     another one. Choose the one you like best.
+
+-screen_aspect
+
+	Give a screen aspect ration in the form X:Y where X is the horizontal
+	and Y the vertical part. Examples are 4:3 for most resolution settings
+	on computer monitors, 5:4 for the 1280x1024 resolution or 3:4 for
+	turnable LCD's in the turned position. The default is 4:3.
+
+
+Windows video options (Direct3D)
+--------------------------------
+
+-[no]direct3d / -[no]d3d
+
+	Use Direct3D to display the image. This does not render 3D games using
+	3D hardware, it just uses 3D hardware to display the image, and apply
+	effects to it. -triplebuffer, -waitvsync, -resolution, -refresh,
+	-switchres, -switchbpp, -resolution all work with this option. This
+	option overrides -ddraw and implies -hwstretch. The default is OFF
+	(-nodirect3d).
+
+-[no]d3dtexmanage
+
+	Let Direct3D handle conversion of the image to a texture (required to
+	display it with Direct3D). This is more compatible, but can be
+	(significantly) slower on some hardware. The default is ON
+	(-d3dtexmanage). Using -nod3dtexmanage can eliminate a loss of
+	performance that may occur with some graphics cards when using
+	-direct3d. This option requires -direct3d.
+
+-zoom [z] / -z [z]
+
+	Try to get a resolution that enlarges the emulated game z times. The
+	default is -zoom 2. MAME determines the resolution automatically. This
+	option only works with -direct3d.
+
+-d3dfilter [f] / -flt [f]
+
+	Select the type of filtering to apply to the image when stretching. 0
+	is point filtering, 1 is bi-linear filtering, 2 is bi-cubic filtering
+	(flat kernel), 3 is bi-cubic filtering gaussian kernel), 4 is
+	anisotropic filtering. Note that very few graphics cards support
+	bi-cubic filtering, and that older graphics cards may not support
+	anisotropic filtering. The default is bi-linear filtering (-d3dfilter
+	1). This option requires -direct3d.
+
+-d3dscan [i]
+
+	Select the scanline effect intensity in percentages. 0 is black lines
+	between scanlines, 100 is disable scanline effect. The default is
+	DISABLE (-d3dscan 100). This option requires -direct3d.
+
+-d3dfeedback [i]
+
+	Select the feedback effect intensity in percentages. 0 is disable,
+	higher values feed back the previous frame to the current one at the
+	specified intensity. The default is DISABLE (-d3dfeedback 0). This
+	option requires -direct3d.
+
+-d3dprescale [option]
+
+	Pre-scale up the image with point filtering before fitting the image to
+	the screen. This gives an only slightly fuzzy image even at high
+	display resolutions. The options are:
+
+		none	    disable.
+		auto	    adaptively apply a moderate pre-scale effect,
+			    depending on other efects used.
+		full	    adaptively apply an agressive pre-scale effect.
+		n	    (where 2 <= n <= 4) pre-scale the image n times.
+
+	The default is AUTO (-d3dprescale auto). This option requires
+	-direct3d.
+
+-d3deffect [preset]
+
+	Select an effect preset. Valid presets are:
+
+		none		no effect (this is the default)
+		sharp		no effect, but gives a sharper image
+		scan25		25% scanlines
+		scan50		50% scanlines
+		scan75		75% scanlines
+		scan75v 	75% scanlines (vertical)
+		rgbmicro	a certain "monitor mask"
+		rgbtiny 	another one
+		rgb3		another one
+		rgb4		another one
+		rgb4v		another one (vertical)
+		rgb6		another one
+		rgb16		another one
+		rgbminmask	another one
+		dotmedmask	another one
+		rgbmedmask	another one
+		dotmedbright	another one (extra bright)
+		rgbmaxbright	another one (extra bright)
+		aperturegrille	another one. Choose the one you like best.
+		auto		adaptively selects a special preset based on
+				zoom level.
+
+	The default is none (-d3deffect none). This option requires -direct3d.
+
+-d3dcustom [custom preset]
+
+	Supply a custom preset. The format is <-d3dcustom
+	1,0,0x0100,0xC0,0,0,0,0x22,-1,8x8_mame_rgbtiny.rgb>. The meaning
+	of the mumbers is:
+
+		1	    RGB effects mode: 0 is off, 1 is multiply mode, 2
+			    is add and multiply mode.
+		2,3,4,5     pattern preprocessing; use mask, white level, black
+			    level, desaturation, respectively.
+		6	    image attenuation
+		7	    feedback (0 is don't use)
+		8	    prescale. bit 4: prescale horizontally, bit 0:
+			    prescale vertically.
+		9	    maximum scanline intensity.
+		10	    pattern filename, including path.
+
+	The filename must start with XxY, where X and Y are the dimensions of
+	the pattern in pixels. Each pixel is represented by 4 bytes, red,
+	green, blue, and mask, respectively. mask is an on/off value, where 0
+	is off. This option requires -direct3d.
+
+-d3dexpert [settings]
+
+	Undocumented settings intended mostly for developers. This option
+	requires -direct3d.
+
+
+Windows sound options
+---------------------
+
+-audio_latency
+
+	This controls the amount of latency built into the audio streaming. By
+	default MAME tries to keep the DirectSound audio buffer between 1/5 and
+	2/5 full. On some systems, this is pushing it too close to the edge,
+	and you get poor sound sometimes. The latency parameter controls the
+	lower threshold. The default is 1 (meaning lower=1/5 and upper=2/5).
+	Set it to 2 (-audio_latency 2) to keep the sound buffer between 2/5 and
+	3/5 full. If you crank it up to 4, you can definitely notice the lag.
+
+
+Windows misc options
+--------------------
+
+-[no]sleep
+
+	Since MAME is running in a multitasking environment, it should be nice
+	to its fellow processes. Therefore, if MAME does not need all
+	processing power to emulate a game, it gives back already granted
+	processor time to the operating system. This may not work in every
+	case, so it can be disabled and MAME turned once again into a CPU hog.
+	The default is ON (-sleep).
+
+-[no]high_priority
+
+	Increases the thread priority so MAME runs better. The default is OFF
+	(-nohigh_priority).
+
+-[no]rdtsc
+
+	Prefer RDTSC over QueryPerformanceCounter for timing. The default is
+	OFF (-nordtsc). -rdtsc sometimes causes problems on laptops, and
+	-nordtsc may cause problems on desktop computers. If MAME does not
+	operate smoothly (and you are sure you have enough CPU power for
+	the emulation), try toggling this.
+
+
+Input device options
+--------------------
+
+-[no]mouse
+
+	Controls whether or not MAME looks for a mouse controller to use. When
+	this is enabled, you will not be able to use your mouse in Windows
+	while playing a game. If you want to get control of your computer back,
+	you will need to pause the game, or quit. The default is OFF
+	(-nomouse).
+
+-[no]joystick / -[no]joy
+
+	Controls whether or not MAME looks for joystick/gamepad controllers.
+	When this is enabled, MAME will ask DirectInput about which controllers
+	are connected. The default is OFF (-nojoystick).
+
+-[no]steadykey / -[no]steady
+
+	Some games require two or more buttons to be pressed at exactly the
+	same time to make special moves. Due to limitations in the PC keyboard
+	hardware, it can be difficult or even impossible to accomplish that
+	using the standard keyboard handling. This option selects a different
+	handling that makes it easier to register simultaneous button presses,
+	but has the disadvantage of making controls less responsive. The
+	default is OFF (-nosteadykey)
+
+-[no]keyboard_leds / -[no]leds
+
+	Since MAME uses an input device (keyboard) for output, this sort of
+	belongs here. Using this option enabes/disables simulation of the game
+	LEDs by the keyboard LEDs. This works fine, but can lead to problems
+	after exiting MAME (i.e. CAPS LOCK remains ON), so you can disable it
+	here. The default is ON (-keyboard_leds).
+
+-ctrlr <controller>
+
+	Enables support for special controllers. Configuration files are
+	provided for:
+
+		hotrod	    HotRod
+		hotrodse    HotRod SE
+		slikstik    SlikStik
+		xarcade     X-Arcade
+
+	There is extra documentation available about this in the file
+	ctrlr.txt.
+
+-a2d_deadzone / -a2d
+
+	If you play with an analog joystick, but the game requires digital
+	input, MAME needs to convert the signals. Here you can give the ratio
+	of movement along an axis that accounts for a digital signal. This
+	option expects a float in the range of 0.0 to 1.0. The default is 0.3.
+	Note: the current handling is not precise, as it does also implicitely
+	set the size of the arc which is interpreted as diagonal movement. This
+	is a known problem but it requires some major rework of the input
+	handling code to fix it.
+
+
+MAME core video options
+-----------------------
+
+-[no]norotate
+-[no]autorol
+-[no]autoror
+-[no]rol
+-[no]ror
+-[no]flipx
+-[no]flipy
+
+	These are the standard MAME rotation options. They are all OFF by
+	default.
+
+-debug_resolution wxh / -dr wxh
+
+	Specifies the resolution of the debugger bitmap in the debug build.
+	This controls how big the debugger window will be, and therefore, how
+	many rows/columns it will display. The default value is 0x0, which sets
+	the automatic 640x480 default debugger size. Note that the debugger is
+	only available when running in a window.
+
+-gamma
+
+	This controls the global gamma correction in the game. It is the same
+	gamma that is applied when you bring up the on-screen-display within
+	MAME. The default is 1.0.
+
+-brightness / -bright
+
+	This controls the global brightness correction in the game. It is the
+	same brightness that is applied when you bring up the on-screen-display
+	within MAME. The default is 1.0.
+
+-pause_brightness
+
+	This controls the brightness level when MAME is paused. The default
+	value is 0.65.
+
+
+MAME core vector options
+------------------------
+
+-[no]antialias / -[no]aa
+
+	Antialiasing for vector games. The default is ON (-antialias).
+
+-[no]translucency / -[no]tl
+
+	Enables or disables vector translucency. Colors of crossing vector
+	beams will be merged. The default is ON (-translucency).
+
+-beam
+
+	Sets the width in pixels of the vectors. This option expects a float in
+	the range of 1.00 through 16.00 as argument. The default is 1 (1 pixel
+	wide).
+
+-flicker
+
+	Makes the vectors flicker. This option requires a float argument in the
+	range of 0.00 - 100.00 (0=none, 100=maximum). The default is 0.
+
+-intensity
+
+	Sets the intensity correction for the beam. Higher values give a
+	brighter beam. This option expects a float in the range of 0.5 through
+	3.0 as argument.  The default is 1.5.
+
+
+MAME core sound options
+-----------------------
+
+-[no]sound
+
+	Enable or disable sound altogether. The default is ON (-sound).
+
+-[no]samples
+
+	Use samples if available. The default is ON (-samples).
+
+-volume / -vol
+
+	Sets the startup volume. It can later be changed with the On Screen
+	Display (see Keys section). The volume is an attenuation in dB: e.g.,
+	"-volume -12" will start with -12dB attenuation. The default is 0.
+
+-samplerate / -sr
+
+	Sets the audio sample rate. Smaller values (e.g. 11025) cause lower
+	audio quality but faster emulation speed. Higher values (e.g. 44100)
+	cause higher audio quality but slower emulation speed. The default is
+	44100.
+
+-[no]resamplefilter
+
+	If the samplerate of the original hardware does not match the
+	samplerate actually used by an integer factor, apply a filter. This is
+	more faithful to the original sound, however, the sound may not be as
+	crisp. The default is ON (-resamplefilter).
+
+
+MAME core misc options
+----------------------
+
+-[no]artwork / -[no]art
+
+	Enable or disable usage of additional artwork (backdrops, overlays,
+	etc.). The default is ON (-artwork).
+
+-[no]use_backdrops / -[no]backdrop
+
+	Enables/disables the display of backdrops. The default is ON
+	(-use_backdrops).
+
+-[no]use_overlays / -[no]overlay
+
+	Enables/disables the display of overlays. The default is ON
+	(-use_overlays).
+
+-[no]use_bezels / -[no]bezel
+
+	Enables/disables the display of bezels. The default is ON
+	(-use_bezels).
+
+-[no]artwork_crop / -[no]artcrop
+
+	This will crop the artwork to the game screen area only. The default is
+	OFF (-noartwork_crop).
+
+-artworkresolution / -artres
+
+	Scale the game by this factor to accommodate for higher resolution
+	artwork. The default is 0 (auto).
+
+-bios
+
+	Expects a BIOS name as the parameter. -listinfo/xml will list the
+	possible BIOS names for a game/system.
+
+-[no]skip_disclaimer
+
+	Forces MAME to skip displaying the disclaimer screen. The default is
+	OFF (-noskip_disclaimer).
+
+-[no]skip_gameinfo
+
+	Forces MAME to skip displaying the game info screen. The default is OFF
+	(-noskip_gameinfo).
+
+-[no]cheat / -[no]c
+
+	Cheats, like the speedup in Pac Man or the level-skip in many other
+	games, are disabled by default. Use this switch to turn them on. The
+	default is OFF (-nocheat).
+
+-[no]debug
+
+	Activates the integrated debugger.  During emulation, press the tilde
+	key (~) to activate the debugger. This is available only if the program
+	is compiled with MAME_DEBUG defined. The default is OFF (-nodebug).
+
+-playback / -pb
+
+	Expects a filename as parameter. Play back all game inputs from from
+	file INP/filename.inp. The gamename is contained in this file,
+	therefore a gamename needs not be given on the commandline.
+
+-record / -rec
+
+	Expects a filename as parameter. All game inputs are written to the
+	file INP/filename.inp.
+
+-[no]log
+
+	Creates a log of illegal memory accesses in ERROR.LOG. The default is
+	OFF (-nolog).
+
+-maxlogsize
+
+	Expects a number as parameter. If the size of error.log (in kilobytes)
+	hits that number, MAME will exit. By default, this is set fairly low
+	(10 MB). This is in effect only if you are actually generating the
+	error.log file.
+
+
+Other MAME frontend options
+----------------------------
+
+Note: By default, all the '-list' commands below write info to the screen. If
+you wish to write the info to a textfile instead, add this to the end of your
+command:
+
+  > filename
+
+...where 'filename' is the textfile's path and name (e.g., c:\mame\list.txt).
+
+-help / -?
+
+	Displays current MAME version and copyright notice
+
+-[no]clones
+
+	Used together with the list commands, enables/disables listing of
+	alternate ("cloned") versions of the same game. The default is ON.
+
+-list / -ls
+
+	Displays a list of currently supported games.
+
+-listfull / -ll
+
+	Displays a list of game directory names + descriptions.
+
+-listgames
+
+	List the supported games, year, manufacturer.
+
+-listdetails
+
+	Displays a detailed list of drivers and the hardware they use.
+
+-listsourcefile
+
+	Displays the source file (in the drivers directory) containing the
+	driver for the specified game. Useful for finding which driver a game
+	runs on in order to fix bugs.
+
+-listinfo / -li
+
+	List comprehensive details for all of the supported games. The output
+	is quite long, so better redirect this into a file. The output is in
+	MAME's own format, see listinfo.txt for details.
+
+-listxml / -lx
+
+	List comprehensive details for all of the supported games. The output
+	is quite long, so better redirect this into a file. The output is in
+	XML format.
+
+-listclones / -lc
+
+	Lists clones of the specified game. When no game is specified, this
+	generates a list of all MAME-supported clones.
+
+-listsamdir
+
+	List directory names for samples. Some clones can share their samples
+	with their parents (no pun intended).
+
+-listcrc
+
+	List CRC32 checksums of rom files
+
+-listdupcrc
+
+	Find romfiles with same CRC32 (for developers).
+
+-listroms
+
+	Displays ROMs required by the specified game.
+
+-listsamples
+
+	Displays samples required by the specified game.
+
+-verifyroms
+
+	Checks specified game(s) for missing and invalid ROMs.	Adding "*"
+	checks all available games.
+
+-verifysets
+
+	Checks specified game(s) and reports its status. Adding "*" checks all
+	available games. Terse output.
+
+-vset
+
+	Checks specified game(s) and reports its status. Adding "*" checks all
+	available games. Slightly more verbose output.
+
+-verifysamples
+
+	Check selected game for missing samples. Adding "*" checks all
+	available samples.
+
+-vsam
+
+	Check selected game for missing samples. Adding "*" checks all
+	available samples.
+
+-romident
+
+	Attempts to identify ROM files, if they are known to MAME, in the
+	specified .zip file. Can be used to try and identify ROM sets taken
+	from unknown boards.
+
+-isknown
+
+	Very terse romident.
+
+-crconly
+
+	Uses only CRC-32 for all integrity checks. Disables the use of SHA-1
+	checks when loading the ROMs.
+
+-gamelist
+
+	Used internally to create gamelist.txt
+
+-sortname
+-sortdriver
+
+	Used internally for creating gamelist.txt
+
+-listcpu
+-listcpuclass
+-listgamespersourcefile
+-listnosound
+-listnvram
+-listpalettesize / -lps
+-listromdistribution
+-listromnumber
+-listromsize / -lrs
+-listsound
+
+	Lists various statistical data.
+
+-listwrongmerge / -lwm
+-wrongfps
+-wrongorientation
+
+	Attempts to catch careless developers.
+
+
+Keys
+----
+
+Tab	     Toggles the configuration menu
+
+Tilde	     Toggles the On Screen Display. Use the up and down arrow keys to
+	     select the parameter (global volume, mixing level, gamma
+	     correction etc.), left and right to arrow keys to modify it.
+
+P	     Pauses the game
+
+Shift+P      While paused, advances to next frame
+
+F1	     toggle raster effects in some games
+
+F2	     Service Mode
+
+F3	     Resets the game
+
+F4	     Shows the game palette, decoded GFX, and any tilemaps
+	     Cursor left/right changes between palette, GFX and tilemaps
+	     Cursor up/down cycle through valid palettes
+	     Page up/down scroll through the palette and GFX
+	     Page up/down, D, G scroll the tilemap display
+	     Ctrl & Shift are modifiers to change movement speed.
+	     F4 or Esc returns to the emulation.
+	     Note: Not all games have decoded graphics and/or tilemaps.
+
+F5	     Toggle debugger (only in debug build)
+
+F6	     Toggle cheat mode (if started with "-cheat")
+
+F7	     Load a 'Save State'. You will be requested to press a key to
+	     determine which Save State you wish to load. Note that the 'Save
+	     State' feature is for developing drivers and not intended for
+	     users. It is incomplete and works only on a number of drivers. Use
+	     at own risk.
+
+Shift+F7     Create a 'Save State'. Requires an additional keypress to identify
+	     the state.
+
+F8	     Decrease frame skip on the fly
+
+F9	     Increase frame skip on the fly
+
+F10	     Toggles speed throttling
+
+F11	     Toggles speed display
+
+Shift+F11    Toggles profiler display (debug builds only)
+
+F12	     Saves a screen snapshot. The default target directory is SNAP.
+
+ESC	     Exits emulator
+
diff --git a/src/unix/doc/mess/cgafont.txt b/src/unix/doc/mess/cgafont.txt
new file mode 100644
index 0000000..36c35aa
--- /dev/null
+++ b/src/unix/doc/mess/cgafont.txt
@@ -0,0 +1,61 @@
+CGAFONT is a program to assist in making a dump of the CGA character
+generator ROM.
+
+CGAFONT was written on 4 April 2003 by John Elliott <jce@seasip.demon.co.uk>
+and is Public Domain software.
+
+Latest version and executable is available at
+
+http://www.seasip.demon.co.uk/1512/index.html
+
+To use it, you will need an IBM-compatible PC with:
+* A CGA (or compatible) video controller.
+* DOS.
+
+How it works
+============
+CGAFONT creates a 2k font in memory. You edit this font until it matches the
+character shapes produced by the CGA in text mode. When the two sets of
+characters are identical, you have a dump of your CGA character generator ROM.
+
+How to use CGAFONT:
+===================
+1. Run GRAFTABL (optional, but will make your life easier by providing
+  default character shapes).
+2. Run CGAFONT. The screen will switch to 40-column mode and show this
+display:
+
+     Choose character to edit
+
+        000:
+
+     Cursor keys to select, ENTER to edit
+     W to write font dump to disc
+     S/T to test with ROM font, ESC to exit
+
+3. Press S or T to compare the font in CGAFONT's memory with the one in the
+  CGA ROM. It is not possible to display them both at once (one is drawn in
+  text mode, the other in graphics mode) so the display shows one, then the
+  other.
+
+  The S option switches between the two once every second, while T switches
+as fast as the system can manage. Press ESC to leave the test mode.
+
+  If the two fonts looked identical, then skip to step 6.
+
+4. Using the cursor keys, select a character that looked different in both
+  display modes. Press ENTER to edit it.
+
+5. The editing screen will now be displayed. On the left is an enlarged bitmap
+  of the character (from CGAFONT's memory); on the right is the one from the
+  CGA ROM, drawn at its usual size. Edit the bitmap on the left using the
+  cursor keys and SPACE. You can test using S/T on this screen as well; press
+  ESC to leave it. Note that you cannot undo changes you have made.
+
+6. Once you are satisfied that the font in CGAFONT's memory matches the one
+  in your CGA ROM, press W to write the font dump. This will write a file
+  CGAFONT.BIN to the current disc.
+
+7. If your card has more than one font (eg: a genuine IBM CGA card or an
+  Amstrad PC1512 built-in CGA) then rename CGAFONT.BIN, set the option links
+  for the next font, and repeat.
diff --git a/src/unix/doc/mess/compilewin.html b/src/unix/doc/mess/compilewin.html
new file mode 100644
index 0000000..c6b6b18
--- /dev/null
+++ b/src/unix/doc/mess/compilewin.html
@@ -0,0 +1,242 @@
+<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/1998/REC-html40-19980424/loose.dtd">
+<html>
+<head>
+	<style type="text/css">
+		.filename	{font-family: "Courier new", courier;	color: brown; font-weight: bold}
+		.command	{font-family: "Courier new", courier;	color: green; font-weight: bold}
+		.key		{font-family: "Courier new", courier;	color: gray; font-weight: bold}
+		.fixedsize	{font-family: "Courier new", courier}
+	</style>
+	<title>How to compile MESS (Win32)</title>
+</head>
+<body bgcolor="white">
+<h1>How to compile MESS (Win32)</h1>
+<p>
+	<i>(Last updated 19-Apr-2002)</i>
+</p>
+<p>
+	(This document is based on <a href="http://www.mame.net/compilewin.html">"How to
+	compile MAME (Win32)"</a>.  Since the procedure for compiling MAME and MESS are
+	virtually identical, these two documents are virtually identical)
+</p>
+
+<p>
+	<b>Compiling means</b> rebuilding the actual executable program from its source code.
+	MESS is almost fully written in C, with some assembler hacks in
+	speed-critical places. The Win32 version of MESS is compiled with
+	<a href="http://www.mingw.org/">MinGW</a>, which is the minimalist Win32
+	port of a C compiler called <a href="http://gcc.gnu.org/">GCC</a> and its libraries.
+</p>
+
+<p>
+	This particular how-to is written for MESS 0.56, but with a bit of luck you can 
+	compile other versions with the help of this page. This how-to tells how to 
+	compile the Win32 version of MESS, which includes both the command line and GUI versions.
+</p>
+					
+<p>
+	The MinGW development environment will be installed to <span class="filename">
+		C:\MINGW</span> and MESS sources will be placed into <span class="filename">
+		C:\MINGW\MESS</span>. Before beginning, you should make sure that you do 
+	not have the directories <span class="filename">c:\mingw\</span>
+	and <span class="filename">c:\download\</span> yet.
+	
+	If you do have them, rename them to another name or simply delete them (if you are sure that there
+	aren't any important files in there).
+</p>
+
+<p>
+				Remember, when you type commands into the command prompt, you should avoid 
+				making typos <span class="fixedsize">;-)</span> In this how-to, 
+				filenames and other static text are marked with the color <span class="filename">
+					brown</span> and command lines or other information that you need to type 
+				in are marked with the color <span class="command">green</span>.
+<p>
+				<hr>
+				<b>1. Get Unzip</b>
+<p>
+				First of all, most files that are transferred over the Internet are compressed, 
+				to minimize download times and bandwidth costs. You might already have a 
+				Windows-based uncompressing utility, but since compiling MESS is done in a 
+				command prompt, a different kind of utility is necessary. Download the 
+				following file into the directory <span class="filename">
+					c:\windows\command\</span> so that the
+utility is accessible from any directory.
+<p>
+				<table width="100%" border="2" cellspacing="1" cellpadding="5">
+					<TR>
+						<td><span><b>File&nbsp;name</b></span></td>
+						<td><span><b>File&nbsp;size</b></span></td>
+						<td><span><b>Description</b></span></td>
+					</TR>
+					<TR>
+						<td><span><b><A href="http://www.mame.net/zips/compile/unzip.exe">unzip.exe</A></b></span></td>
+						<td><span>140kB</span></td>
+						<td><span>This is the <a href="http://www.info-zip.org/pub/infozip/">Info-ZIP</a> uncompressing 
+								utility called UnZip/NT v5.41.</span></td>
+					</TR>
+				</table>
+
+<p>
+				<hr>
+				<b>2. Get MinGW</b>
+<p>
+				Then you need the MinGW files. Make a new directory, for example <span class="filename">
+					c:\download\</span> and
+download the following files into that directory. Note that there may be newer
+versions of these files, but MESS is not verified to compile with any other
+versions of the following files.
+
+<p>
+				<Table width="100%" border="2" cellspacing="1" cellpadding="5">
+					<TR>
+						<td><span><b>File&nbsp;name</b></span></td>
+						<td><span><b>File&nbsp;size</b></span></td>
+						<td><span><b>Description</b></span></td>
+					</TR>
+					<TR>
+						<td><span><A href="http://www.mame.net/zips/compile/mingw_for_mame.zip">mingw_for_mame.zip</A></span></td>
+						<td><span>5517 kB</span></td>
+						<td><span>This is the MinGW compile environment for use in Windows.</span></td>
+					</TR>
+				</table>
+
+<p>
+				<hr>
+				<b>3. Uncompress MinGW</b>
+<p>
+				Next we will uncompress the MinGW files and set up some environment variables 
+				so that MinGW is functional. Open up a command prompt. You can find it either 
+				from under Start Menu - Programs, or you can simply select Run and type 
+				command.com into the dialog box. When you have it open, type <span class="command">
+					cd \download</span> and hit enter to change to the correct directory. After that,
+type
+<p>
+	<ul>
+		<li>
+			<span class="command">unzip mingw_for_mame.zip -d c:\</span>
+			<br>and hit enter to start uncompressing the MinGW files.
+		</li>
+	</ul>
+<p>
+				If you do not see the message "1 archive was successfully processed.", 
+				re-download the archives. If you get a "Bad commmand or file name", verify once 
+				again that you have <span class="filename">unzip.exe</span>
+				in <span class="filename">c:\windows\command\</span>
+
+<p>
+				<hr>
+				<b>4. Set up MinGW</b>
+<p>
+				Next we will have to set up the environment variables. To make the changes 
+				permanent, we will have to edit <span class="filename">AUTOEXEC.BAT</span>, 
+				which is a file that always gets run before Windows starts up. Type <span class="command">
+					edit \autoexec.bat</span> and hit
+enter. There might be a lot of things in there, so do not touch anything else
+than what you are told to.
+<p>
+				Find the line which says something like <span class="filename">
+					PATH C:\WIN98;C:\WIN98\COMMAND</span> (there might be some other 
+				directories defined after these two). Add <span class="command">
+					;C:\MINGW\BIN</span> to the end of that line, so that it will look like <span class="filename">
+					PATH C:\WIN98;C:\WIN98\COMMAND</span><span class="command">;C:\MINGW\BIN</span>
+				(again, there might be something extra in there, leave them as they are). Take 
+				note that if you have added <span class="filename">C:\DJGPP\BIN</span>
+				into that line, you should remove it. Now you can save the file (<span style="key">ALT-F</span>
+				then <span style="key">S</span>) and quit (<span style="key">ALT-F</span>
+				then <span style="key">X</span>) (These might differ depending on your language version of Windows). Then you will
+need to reboot your computer, to make the changes effective.
+<p>
+				With systems that don't use startup files (such as Windows NT, 2000 or XP), you 
+				can instead type <span class="command">edit 
+					c:\mingw\mingw.bat</span> and write <span class="command">
+					SET PATH=%PATH%;c:\mingw\bin</span> into it. You'll have to run this file 
+				(simply type <span class="command">c:\mingw\mingw</span> to run it)
+before being able to use MinGW.
+<p>
+				<hr>
+				<b>5. Compile MESS</b>
+<p>
+				Now you can compile MESS. Download the source ZIP into <span class="filename">
+					c:\download\</span>
+<p>
+				<Table width="100%" border="2" cellspacing="1" cellpadding="5">
+					<TR>
+						<td><span><b>File&nbsp;name</b></span></td>
+						<td><span><b>File&nbsp;size</b></span></td>
+						<td><span><b>Description</b></span></td>
+					</TR>
+					<TR>
+						<td><a href="http://homepage.eircom.net/~mess/mess056s.zip"><b>mess056s.zip</b></a><br></td>
+						<td>2717 kB</td>
+						<td>This is the source archive of MESS 0.56.</td>
+					</TR>
+				</table>
+<p>
+				Go to the download directory by typing <span class="command">
+					cd \download</span> and uncompress the MESS sources by typing <span class="command">
+					unzip mess056s.zip -d c:\mingw\mess\</span>.
+<p>
+				Then you can compile MESS. Type <span class="command">make -f makefile.mes</span>
+				and hit enter. This will finally compile MESS itself. If you want to compile 
+				the CPU optimized versions, type <span class="command">make -f makefile.mes 
+					I686=1</span> or <span class="command">make -f makefile.mes K6=1</span>
+				instead of just <span class="command">make -f makefile.mes</span>.
+It will take a lot of time, ranging from 15 minutes to an hour depending on your
+CPU speed, so go get yourself something to drink.
+<p>
+				When the compilation is done, you can type <span class="command">
+					dir</span>. You should see a brand new <span class="filename">
+					MESS.EXE</span> in there.
+<p>
+	You also need to make the INI file, by typing <span class="command">
+	mess -cc</span> (an abbreviation of -createconfig).
+<p>
+Congratulations, you did it!
+<p>
+				<hr>
+				<b>6. A new MESS appeared</b>
+<p>
+To successfully compile a new version of MESS, you should NOT uncompress a new set
+of sources over an old version of MESS. Instead, rename the MESS directory to another
+name or simply delete it totally (if you are sure that nothing important is there),
+and then uncompress the new set of sources to an empty directory.
+<p>
+				<hr>
+				<b>7. Then what..</b>
+<p>
+				Of course, the biggest advantage of building your own binary is the possibility 
+				to tinker around with the source files. For example, to try out drivers which 
+				are not fully working yet, take a look at the file <span class="filename">
+					mess/system.c</span> with a normal text editor (like EDIT). The disabled 
+				drivers are marked with the text TESTDRIVER. Simply remove the TEST part from a 
+				driver you want to test, save the file and type <span class="command">
+					make -f makefile.mes</span> again. Remember,
+the license forbids you from redistributing binaries that contain systems which
+are disabled in the official versions. Naturally, there should not be any reasons to redistribute
+such binaries since this page makes it easy for everybody to build their own binaries.
+<p>
+				You might notice that the UPX part takes an obscene amount of time. The 
+				simplest solution to avoid it is to just rename <span class="filename">
+					upx.exe</span> to another name. If you do that, the make utility will give 
+				you an error and the file <span class="filename">MESSDLIB.DLL</span> is
+about 7 MB, but it will work fine.
+<p>
+				<hr>
+				<b>8. Debug modes</b>
+<p>
+				To include the debugger functionality in your MESS executable, edit <span class="filename">
+					makefile.mes</span>. Near the top you will see a text like "uncomment next line 
+				to include the debugger". Remove the <span class="command">
+					#</span> character from the next line, so that it only has <span class="filename">
+					DEBUG = 1</span> in that particular line. Save the file, type <span class="command">
+					make -f makefile.mes clean</span> and then <span class="command">make -f makefile.mes</span>. 
+				To actually use the debugger, edit <span class="filename">
+					MESS.INI</span> and find the line that says <span class="filename">
+					debug = no</span>. Change it to <span class="filename">
+					debug = </span><span class="command">yes</span> 
+				and save the file. In MESS, hit tilde (&nbsp;<span style="key">~</span>&nbsp;) 
+				or key to the left of the key &nbsp;<span style="key">1</span>&nbsp; 
+				to enter the debugger.
+	</body>
+</html>
diff --git a/src/unix/doc/mess/credits.txt b/src/unix/doc/mess/credits.txt
new file mode 100644
index 0000000..341c13a
--- /dev/null
+++ b/src/unix/doc/mess/credits.txt
@@ -0,0 +1,46 @@
+Credits:
+---------------------------------------------------------------------------
+SID Emulation:
+
+/home/ms/source/sidplay/libsidplay/emu/RCS/6581_.cpp,v
+
+Contributions:
+
+Noise generation algorithm is used courtesy of Asger Alstrup Nielsen.
+His original publication can be found on the SID home page.
+
+Noise table optimization proposed by Phillip Wooller. The output of
+each table does not differ.
+
+MOS-8580 R5 combined waveforms recorded by Dennis "Deadman" Lindroos.
+
+--- MOS-6581 Emulator ---
+
+Copyright (c) 1994-1997 Michael Schwendt. All rights reserved.
+
+Redistribution and use  in source and  binary forms, either  unchanged or
+modified, are permitted provided that the following conditions are met:
+
+(1)  Redistributions  of  source  code  must  retain  the above copyright
+notice, this list of conditions and the following disclaimer.
+
+(2) Redistributions  in binary  form must  reproduce the  above copyright
+notice,  this  list  of  conditions  and  the following disclaimer in the
+documentation and/or other materials provided with the distribution.
+
+THIS SOFTWARE  IS PROVIDED  BY THE  AUTHOR ``AS  IS'' AND  ANY EXPRESS OR
+IMPLIED  WARRANTIES,  INCLUDING,   BUT  NOT  LIMITED   TO,  THE   IMPLIED
+WARRANTIES OF MERCHANTABILITY  AND FITNESS FOR  A PARTICULAR PURPOSE  ARE
+DISCLAIMED.  IN NO EVENT SHALL  THE AUTHOR OR CONTRIBUTORS BE LIABLE  FOR
+ANY DIRECT,  INDIRECT, INCIDENTAL,  SPECIAL, EXEMPLARY,  OR CONSEQUENTIAL
+DAMAGES (INCLUDING, BUT NOT  LIMITED TO, PROCUREMENT OF  SUBSTITUTE GOODS
+OR SERVICES;  LOSS OF  USE, DATA,  OR PROFITS;  OR BUSINESS INTERRUPTION)
+HOWEVER  CAUSED  AND  ON  ANY  THEORY  OF LIABILITY, WHETHER IN CONTRACT,
+STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING  IN
+ANY  WAY  OUT  OF  THE  USE  OF  THIS  SOFTWARE,  EVEN  IF ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGE.
+---------------------------------------------------------------------------
+
+CoCo disk controller code (src/mess/machine/cocodisk.c) based on code from 
+the PC-Dragon emulator by Paul Burgin and Stewart Orchard.
+---------------------------------------------------------------------------
diff --git a/src/unix/doc/mess/imgtool.txt b/src/unix/doc/mess/imgtool.txt
new file mode 100644
index 0000000..e4b640f
--- /dev/null
+++ b/src/unix/doc/mess/imgtool.txt
@@ -0,0 +1,515 @@
+Imgtool - A generic image manipulation tool for MESS
+
+Imgtool is a tool for the maintenance and manipulation of disk and other types
+of images that MESS users need to deal with.  Functions include retrieving and
+storing files and CRC checking/validation.
+
+Imgtool is part of the MESS project.  It shares large portions of code with
+MESS/MAME, and its existance would not be if it were not for MESS.  As such,
+the distribution terms are the same as MESS.  Please read mess.txt thouroughly.
+
+Some portions in Imgtool is Copyright (c) 1989, 1993 The Regents of the
+University of California.  All rights reserved.
+
+Using Imgtool
+=============
+
+Imgtool is a command line program that contains several "subcommands" that
+actually do all of the work.  Most commands are invoked in a manner along the
+lines of this:
+
+	imgtool <subcommand> <format> <image> ...
+
+<subcommand> is the name of the subcommand
+<format> is the format of the image
+<image> is the filename of the image
+
+Further details vary with each subcommand.  Also note that not all subcommands
+are applicable or supported for different image formats.
+
+Certain Imgtool subcommands (info, crc, good) make use of the CRC files, so if
+you use these commands, make sure that your CRC directory is set up.
+
+Imgtool Subcommands
+===================
+
+create            Creates an image
+dir               Lists the contents of an image
+get               Gets a single file from an image
+put               Puts a single file on an image (wildcards supported)
+getall            Gets all files off an image
+del               Deletes a file on an image
+info              Retrieves info about an image (by reading CRC files)
+crc               Retrieves info about an image in the same format used by the
+                  CRC files
+good              CRC checks a set of images and for matching images, copy into
+                  a new directory
+listformats       Lists all image file formats supported by imgtool
+listfilters       Lists all filters supported by imgtool
+listdriveroptions Lists all format-specific options for the 'put' and 'create'
+                  commands
+
+Filters
+=======
+Filters are a means to process data being written into or read out of an image
+in a certain way.  Filters can be specified on the get, put, and getall
+commands by specifying --filter=xxxx on the command line.  Currently, only
+three filters are supported:
+
+  ascii           Translates end-of-lines to the appropriate format
+  cocobas         Processes tokenized CoCo BASIC programs
+  dragonbas       Processes tokenized Dragon BASIC programs
+
+Format Info
+===========
+
+rsdos CoCo Disks
+----------------
+Fully implemented.  This format supports two format-specific options on the put
+command:
+
+  --ftype=(0|1|2|3) Specifies the file type
+  --ascii=(A|B)     Specifies the ASCII flag
+
+cococas CoCo Cassettes
+----------------------
+Both .cas and .wav supported, but read only.
+
+lnx Commodore 64 Lynx Archive
+-----------------------------
+only for early revisions of lynx archivs
+only extraction supported
+not heavily tested
+
+Lynx archivs could and should be handled in a c64 emulation 
+with the native lynx tool
+
+
+t64 Commodore 64/C64S Archive for Tapes
+---------------------------------------
+not heavily tested
+further creation/use of these archivs discouraged
+
+
+c64crt/crt Commodore 64 Cartridge
+---------------------------------
+for professional use only (cartridge dumper)
+not heavily tested
+
+
+d64 Commodore SX64/VC1541/1551/2031 Diskette
+x64 VICE variant of the above
+d71 Commodore 128D/1571 Diskette
+d81 Commodore 65/1565/1581 Diskette
+-----------------------------------
+not heavily tested
+x64: further creation/use discouraged
+
+
+msdos/fat Microsoft DOS Diskette
+--------------------------------
+directories not finished
+not heavily tested
+
+Formatting (low and high level) must be done with the msdos utility format!
+Boot structures must be installed on these disks with the msdos utility sys!
+
+standard parameter for common disk formats:
+type 0: 5 1/4 inch, double density, single sided, 160kb: sectors 8, heads 1, tracks 40
+type 1: 5 1/4 inch, DD, SS, 180kb: sectors 9, heads 1, tracks 40
+type 2: 5 1/4 inch, DD, double sided, 320kb: sectors 8, heads 2, tracks 40
+type 3: 5 1/4 inch, DD, DS, 360kb: sectors 9, heads 2, tracks 40
+type 4: 3 1/2 inch, DD, DS, 720kb: sectors 9, heads 2, tracks 80
+at disk controller neccessary for high density
+type 5: 5 1/4 inch, high density, DS, 1.2mb: sectors 15, heads 2, tracks 80
+        3 1/2 inch, HD, DS, 1.2mb: sectors 15, heads 2, tracks 80
+type 6: 3 1/2 inch, HD, DS, 1.44mb: sectors 18, heads 2, tracks 80
+special disk controller neccessary for enhanced density
+type 7: 3 1/2 inch, enhanced density, DS, 2.88mb: sectors 36, heads 2, tracks 80
+
+unix with bash: use
+dd if=/dev/zero of=<name.dsk> bs=512 count=$((9*2*40)) 
+to generate standard blank 360kb image
+
+
+msdoshd/fat Microsoft DOS Harddisk/PC Partition Table
+-----------------------------------------------------
+not finished and not working
+(see also unter msdos/fat)
+
+No low level format neccessary with image files
+Partitioning must be done with the msdos utility fdisk
+Then you can format each partition with msdos utility format
+
+standard parameter for common disk formats:
+type 0: 20mb standard pc/xt harddisk: 17 sectors, 4 heads, 615 cylinders
+
+unix with bash: use
+dd if=/dev/zero of=<name.dsk> bs=512 count=$((17*4*615)) 
+to generate standard blank 20mb pc xt harddisk image
+
+
+Virtual MSX tape archive
+------------------------
+Converts .tap files from Virtual MSX 1.x to .cas files. It is not
+fault-tolerant. 
+
+
+Virtual MSX Game Master 2 SRAM file
+-----------------------------------
+Very simple, not overly useful but some might want it. Virtual MSX stored the
+SRAM of Konami's Game Master 2 in "gmaster2.ram". To convert this to something
+useful with MESS and other MSX emulators, go:
+
+imgtool getall vmsx_gm2 gmaster2.ram 
+
+You'll get a file called gmaster2.mem, which must place in the correct directory
+of mess to use  (MESS\MEMCARD\GameMaster2 if your Game Master 2 .rom file is
+called GameMaster2.rom). It's ~/.xmess/memcard/GameMaster2.mem for xmess.
+
+
+fMSX style .cas file
+--------------------
+Converts .cas files to .wav files. The MSX driver can use .cas files directly
+so you don't have to convert them. You can use it to export files to a real
+MSX. Connect the MSX to the line out of your computer. Give the apropriate
+command on the MSX (BLOAD "CAS:",R for example) and then play the .wav file
+on your computer. 
+
+imgtool dir fmsx_cas file.cas
+imgtool getall fmsx_cas file.cas
+imgtool get fmsx_cas file.cas file.wav newfile.wav
+
+
+XelaSoft Archive (.xsa)
+-----------------------
+
+The XelaSoft Archive is a compressed file. It can only contain one
+file. Although it can contain any file, it's always used for MSX disk 
+images. The were programs written by XelaSoft which made a dump
+of a disk, and compressing them at the same time. Very useful to store
+a disk dump on another disk. zip/gzip offer much better compression and
+are mainstream, so let's stick with that.
+
+imgtool uses XSA code developed by Alex Wulms/XelaSoft.
+
+http://web.inter.nl.net/users/A.P.Wulms/
+
+
+Various bogus MSX disk images (img/ddi/msx/multidisks)
+------------------------------------------------------
+
+These are formats you might come across, which have no actual added value
+whatsoever. The only format MESS will support, like most other MSX
+emulators, is .dsk (a plain dump without any header information). This
+filetype converts them all to .dsk format.
+
+msx_img are disk images with an extra byte at the beginning. It' 1 (0x01)
+for single-sided images and 2 (0x02) for double-side images. These 
+files are at: ftp://ftp.funet.fi/pub/msx/. The extension is .img
+
+msx_ddi are DiskDupe 5.12 disk images. There is a 0x1800 bytes header
+at the beginning. The CompuJunkS MSX emulator used these files. The header
+often contain garbage so it's simply stripped. The extension is .ddi
+
+msx_msx are disk images with a weird sector order. You can find them
+at: ftp://jazz.snu.ac.kr/pub/msx/. The extension is .msx
+
+msx_mul are "multi disk" images, used by fmsx-dos 1.6. It is simply 
+more than one .dsk image appended to one another. The extension is
+still .dsk, but the file is larger than 720kB (actually always a 
+multiple of 720kB.
+
+
+rom16 16 bit wide rom image
+---------------------------
+allows easy access to even and odd parts
+file even: even bytes
+file odd: odd bytes
+
+
+Amstrad NC100/NC150/NC200 PCMCIA Ram Card Images (crd/card)
+-----------------------------------------------------------
+
+The card filesystem is similar to FAT, but not identical.
+The maximum card size is 1mb, and maximum file size is 64k.
+(Files will be cut at 64k if they are larger - e.g. when putting a large file)
+
+As far as I know there is no directory system, however there is always a 
+system "NC100" directory which points to the root directory. (Like the DOS "."
+directory).
+
+Using imgtool, you can put, get and delete files.
+
+At this time only ascii file type is supported. These files can be loaded
+into the internal wordprocessor,or,if the file is a BASIC listing, it can
+be loaded into basic with "*EXEC <filename>" at the ">" prompt.
+
+From BASIC you can get a directory listing of the card filesystem with "*."
+at the ">" prompt.
+
+The file date information is not supported at this time.
+
+The card filesystem reading/writing in imgtool has not been heavily tested.
+
+
+TI99 floppy disk images (v9t9/pc99fm/pc99mfm/ti99_old)
+------------------------------------------------------
+
+These modules enable you to create and catalog ti99 images, to delete
+individual files and directories, and to get and put files in TIFILE format.
+Note that you cannot create images in pc99 format.
+
+The v9t9 module supports the v9t9 disk images that is used by MESS, the pc99fm
+module supports FM-encoded pc99 images, and the pc99mfm supports MFM-encoded
+pc99 images, and the ti99_old module supports the now obsolete image format
+that was used by MESS versions prior to .69.  The MESS ti99 drivers supports
+the v9t9 disk image format only.  (Note that the old MESS was identical to the
+V9T9 format for single-sided disks, but that the track order was completely
+different for double-sided disks, which caused the two formats to be
+incompatible for double-sided disk images.  I have changed the format to v9t9
+to make interexchange with other utilities easier.)
+
+The TIFILE format is a file format that is supported by many ti99 utilities: it
+encodes a TI99 file as a flat stream of bytes, which enables to store it on
+file systems that do not support the TI99 file structure and to transmit it
+through networks.  This format uses a data format similar to the one used on
+ti99 floppies (i.e. logical records are grouped in records of 256 bytes
+matching the sector size of 256 bytes), with a custom 128-byte header.
+
+Legal characters for volume and file names are upper case ASCII characters,
+except period ('.') and space (' ').  Lower case characters are not recommended
+because they are not supported by TI99/4.  You had better avoid control
+characters and non-ASCII characters, too.  (Additionally, the NULL character is
+forbidden in file names, but I think nobody in his right sense would even try
+to enter a NULL character in a file name.)  The restriction on the period ('.')
+character may sound strange to users of other OSes, but this character is used
+as a path separator by TI systems.  (As a matter of fact, no TI99 floppy disk
+DSR (except the HFDC DSR) implements disk directories, but other TI systems
+implement this convention extensively.)  Since period is used as the path
+separator, TI99 users often use the slash ('/') or dash ('-') characters as
+file extension separators; note, however, that the use of file extensions is
+never systematic in TI99: you may use file extensions if you find them useful,
+just like you may use any other file naming scheme, but no program enforce or
+require filename extensions as it is often the case in the DOS/windows world.
+
+
+Parameters for create:
+
+--label=...: an optional string of up to 10 characters.
+--sides=[1|2]: 1 for single-sided, 2 for double-sided
+--tracks=[1-80]: number of track per side.  From 1 to 40 on 40-track disks,
+    from 1 to 80 on 80-track disks.
+--sectors=[1-36]: number of sectors per track.  From 1 to 9 in single density
+    (FM), from 1 to 18 in double density (MFM), from 1 to 36 in high density
+    (MFM).
+--protection=[0|1]: when set to 1, the disk will be protected and some (but not
+    all) TI99 programs won't overwrite the disk.
+--density=[0|1|2|3]: you should probably leave this parameter to 0 to select
+    the correct value automatically.  If you really want to know, 1 means
+    single density (FM), 2 means double density (MFM), and 3 means high density
+    (MFM).
+
+Supported geometries for create:
+
+  description    |sides|tracks|sectors| size | FDC Compatibility (1)
+                 |     |      |       |      |
+SSSD 48TPI 5"1/4 |  1  |  40  |    9  |  90K | All
+                 |     |      |       |      |
+DSSD 48TPI 5"1/4 |  2  |  40  |    9  | 180K | All
+                 |     |      |       |      |
+DSDD 48TPI 5"1/4 |  2  |  40  |   18  | 360K | SNUG BwG, Myarc HFDC
+                 |     |      |       |      |
+DSDD 96TPI 5"1/4 |  2  |  80  |   18  | 720K | Myarc HFDC (2)
+or DSDD 3"1/2    |     |      |       |      |
+                 |     |      |       |      |
+DSHD 3"1/2       |  2  |  80  |   36  |1.44M | Myarc HFDC (Geneve Only) (3)
+
+(1) Only emulated controllers are listed in this table
+(2) SNUG BwG can read such images, but it will corrupt them when writing new
+    data to them
+(3) You cannot boot from such images (this is because the Geneve MDOS operating
+    system needs to replaces the incomplete HFDC DSR with a better DSR to
+    support HD: since MDOS is not loaded yet at boot time, you cannot boot from
+    a HD disk).
+
+
+Examples:
+
+List the catalog of image test.dsk:
+imgtool dir v9t9 test.dsk
+
+Extract file FILE1 located on image test.dsk:
+imgtool get v9t9 test.dsk FILE1
+
+Extract file FILE1 located in subdirectory SUBDIR1 on image test.dsk:
+imgtool get v9t9 test.dsk SUBDIR1.FILE1
+
+Write file FILE1 on image test.dsk:
+imgtool put v9t9 test.dsk FILE1
+(Note that file FILE1 must not exist before the command is run.  Use the delete
+command if you need to an existing file.)
+
+Delete file FILE1 located in subdirectory SUBDIR1 on image test.dsk:
+imgtool delete v9t9 test.dsk SUBDIR1.FILE1
+
+Delete subdirectory SUBDIR1 on image test.dsk:
+imgtool delete v9t9 test.dsk SUBDIR1
+(Subdirectory SUBDIR1 must be empty.)
+
+Create a SSSD image compatible with all controllers:
+imgtool create v9t9 test.dsk --sides=1 --tracks=40 --sectors=9
+
+Create a DSSD image compatible with all controllers:
+imgtool create v9t9 test.dsk --sides=2 --tracks=40 --sectors=9
+
+Create a DSDD image compatible with BwG and HFDC controllers:
+imgtool create v9t9 test.dsk --sides=2 --tracks=40 --sectors=18
+
+Create a 80-track DSDD image compatible with the HFDC controller:
+imgtool create v9t9 test.dsk --sides=2 --tracks=80 --sectors=18
+
+Create a DSHD image compatible with the Geneve with a HFDC controller:
+imgtool create v9t9 test.dsk --sides=2 --tracks=80 --sectors=36
+
+
+TI99 hard disk images (ti99hd)
+------------------------------
+
+This module can catalog ti99 hard disk images, delete individual files and
+directories, and get and put files in TIFILE format.  Only images in HFDC
+format are supported for now (no SCSI format).
+
+
+TI990 disk images (ti990hd)
+---------------------------
+
+This module supports disk images in DNOS format (which appears to be virtually
+identical to DX10 3.x format).  Although the module is named ti990hd, this
+module will work fine with floppy images as well as hard disk images: just make
+sure that the disks are formatted in the proper format, as neither DX10 2.x nor
+TX990 formats are supported.
+
+
+Parameters for create:
+
+The most interesting command is create, as you cannot create new images within
+emulation.
+
+--cylinders: number of cylinders
+--heads: number of heads
+--sectors: number of sectors per track
+--seclen: bytes per sector
+
+
+Known restrictions on geometry:
+
+256 < bytes per sector < 512 (arbitrary restriction, actual TI990s might
+    accept values out of this range)
+bytes per sector must be even
+3 < # cylinders < 2047
+1 < # heads < 31
+1 < sectors per track < 256
+(sectors per track) * (bytes per sector) < 2^17 = 131072 (which implies
+    (sectors per track) < 255 if sectors are 512-byte long)
+
+(There are probably other restrictions, so you had better stick to values
+similar to the ones used by actual disk units...  Also note that according to
+the Spectra 126-Plus manual, ADU size limitations prevent most operating
+systems from supporting units larger than 500MBytes.)
+
+
+Known drive geometries:
+
+(Sources: 946250-9703 p. 3-14, 2270512-9701 p. 11-3, 945250-9701 pp. 5-20
+through 5-28, 946250-9701B pp. 2-1 through 2-3, 2540219A-0001 pp. 4-2 and 4-3,
+2306140-9701 p. 1-15, 223439B-9701 pp. 3-14 and 3-28.  See also "Spectra
+126-Plus Product Reference Manual" by Cipher P/N 8500055 revision A4 page 2-8.)
+
+Disk Type       Units   Size (MB)   Cylinders   Heads   Sectors/Track   Bytes/Sector
+FD800 (min)     1          .244?      77         1?      26?            128?
+FD800 (max)     1          .978???    77         2???    26???          256???
+FD1000          1         1.15        77         2       26             288
+DS31/DS32       1         2.81       203         2       24             288
+DS10            2         4.70       408         2(*2)   20             288
+DS25            1        22.3        408         5       38             288
+DS50            1        44.6        815         5       38             288
+DS200           1       169.5        815        19       38             288
+CD1400-32       2        13.5        821         1       64             256
+CD1400-96 (rem) 1        13.5        821         1       64             256
+CD1400-96 (fix) 1        67.3        821         5       64             256
+DS80            1        62.7        803(c)      5       61             256
+DS300           1       238.3        803(c)     19       61             256
+WD800-18        1        18.5        651(b)      3       37             256
+WD800-43        1        43.2        651(b)      7       37             256
+WD800A/38       1        38.5        911(d)      5       33             256
+WD800A/69       1        69.3        911(d)      9       33             256
+WD800A/114      1       114.6        904(d)     15       33             256
+WD500           1         4.92       150(a)      4       32             256
+WD500A          1        17.1        694(a)      3       32             256
+WD900-138       1       138.1        805(e)     10       67             256
+WD900-138/2     2        69.0        805(e)      5(*2)   67             256
+WD900-425       1       425.8        693(e)     24      100             256
+WD900-425/2     2       212.9        693(e)     12(*2)  100             256
+MSU II          1       158.8        957(f)      9       36             512
+MSU IIA         1       332.9       1204(f)     15       36             512
+
+a) some extra cylinders are reserved for diagnostics
+b) 6 extra cylinders are reserved for storage system use (including 2 for
+  diagnostics)
+c) some extra cylinders are reserved for diagnostics, and 10 extra cylinders
+  are reserved to replace bad tracks
+d) 4 extra cylinders are reserved for storage system use (including 2 for
+  diagnostics), and 10 extra cylinders are reserved to replace bad tracks
+e) 16 extra cylinders are reserved for bad track relocation
+f) there are extra cylinders, and the way logical addresses relates to physical
+  address is so complex I don't even want to talk about it
+
+Note that 2270512-9701 and 946250-9703 describe more disk units (namely CMD 16,
+CMD 80, WD800A-43 and WD800A-100 for the former, and WD500-10 for the later).
+Since there are no other references anywhere and DX-10 does not seem to know
+about them, I assume that these models were uncommon.
+
+FD800 is a 8'' floppy disc unit that is not emulated, and it is only cited for
+completeness.  (The FD800 controller is connected to the CRU bus instead of the
+TILINE bus, and it is the only disc controller that is supported by non-TILINE
+systems).
+
+FD1000 is a 8'' floppy disc unit.
+
+DS31/DS32 was the first hard disk unit for ti990.  The only difference between
+DS31 and DS32 is that DS32 does not require a screwdriver to change the disc
+cartridge.
+
+DS10 has one 5-mb fixed platter and one 5mb disk cartridge.
+
+CD1400-32 and CD1400-96 have a one-platter 16-mb removable unit, and a fixed
+unit (16 mb for CD1400-32 and 80 mb for CD1400-96).
+
+WDxxx units are Winchester drives that connect to a proprietary PBUS bus
+interface.  This bus is a built-in interface in BS300 and BS300A systems, and
+the TPBI card enables any TILINE 990 system to support it.  WD800s are 8''
+drives with integrated tape backup, WD500s are 5''1/4 drives with integrated
+FD1000 backup, and WD900s are 9'' drives.  The WD900 controller can optionally
+partition the disc into two partitions: the set-up with no partitioning is
+listed as WD900-138 and WD900-425, whereas the set-up with partitioning is
+listed as WD900-138/2 and WD900-425/2.
+
+MSU II and MSU IIa are SCSI units to be connected to the 990/SCSI controller
+board.
+
+
+Macintosh floppy disk images (mac)
+----------------------------------
+
+This module supports MFS (Macintosh File System) and HFS (Hierarchical File
+System) floppy disk images, either in diskcopy 4.2 or raw image format (the raw
+image format is partially compatible with diskcopy 6 format).
+
+This module can catalog images and extract individual files.  It does not
+support folders in MFS format, because MFS folders are not documented by Apple.
+
+Extracted files are in MacBinary III format (which is fully compatible with
+MacBinary I and II).  The MacBinary III format joins both macintosh file forks,
+the comment field, and most file info in one single file: it is supported by
+several Macintosh utilities.
diff --git a/src/unix/doc/mess/messhelp.txt b/src/unix/doc/mess/messhelp.txt
new file mode 100644
index 0000000..154934d
--- /dev/null
+++ b/src/unix/doc/mess/messhelp.txt
@@ -0,0 +1,102 @@
+
+SYSTEM ROMS
+===========
+
+Most systems will require a bios/system rom. If a system requires a bios/system rom, then it will
+not start without it. Most drivers have been written using a specific bios/system rom and you
+are recommended to use this rom. When the system is started, the rom you have provided is compared
+against the recommended rom and a report is generated if they are different.
+
+If you use a rom which does not match the recommended rom then the driver is not guaranteed to work.
+
+All bios/system roms should be put into the bios directory.
+
+The rom you use must have the same filename as the recommended rom.
+You have two options:
+
+1. You can put the rom into a zip archive and this archive must have the same name as the system.
+e.g. 
+
+"cp464.zip" containing "cpc464.rom" and "cpcados.rom" in the "bios" directory:
+
+bios\cpc464.zip
+
+2. You can create a sub-directory inside "roms" which has the same name as the system. Put the roms for the
+system inside this sub-directory.
+
+e.g.
+"bios\cpc464" directory containing "cpc464.rom" and "cpcados.rom"
+
+bios\cpc464\cpc464.rom
+bios\cpc464\cpcados.rom
+
+SOFTWARE
+========
+
+To use software with a system you must have it in a emulator format (e.g. a rom dump, a cartridge dump,
+a disk image, a tape image).
+
+If there isn't a "software" directory you must create one, so that you have the following directory tree:
+
+mess.exe
+bios\
+software\
+
+In the "software" directory, create a sub-directory which has the same name as the system:
+
+e.g.
+
+software\cpc464\
+
+put the software in a uncompressed form into this directory.
+
+e.g.
+
+software\cpc464\commando.dsk
+
+You can see a list of devices and the emulator file format that they support by typing:
+
+mess -listformats
+
+
+USAGE
+=====
+
+The minimum to start MESS is:
+
+mess <system name>
+
+e.g.
+
+mess cpc464
+
+MESS will stop if:
+
+1. the system roms can't be found
+2. the system roms are incorrect 
+3. a emulator file is required but it was not specified (e.g. a cartridge is required but this has not been specified)
+4. a emulator file was specified but the format was not recognised.
+
+<insert image info here from original mess.txt>
+
+KEYBOARD
+========
+
+MESS has two keyboard-modes, UI and Game. You can press SCROLL-LOCK to toggle between these,
+and a window will display for a brief time to display the current mode.
+
+Mode: FULL keyboard
+UI: Disabled
+
+or
+
+Mode: PARTIAL keyboard
+UI: Enabled
+
+When UI is enabled, the function of some keys will change. These are not passed through to the emulation!
+
+If you press TAB when the UI is enabled a menu will appear where you can view and change settings.
+When you return to the emulation, be careful if UI mode is still active, pressing P for example will
+pause the emulation (pressing P again will resume the emulation). You can press SCROLL-LOCK to change
+it back to Game mode.
+
diff --git a/src/unix/doc/mess/messnew.txt b/src/unix/doc/mess/messnew.txt
new file mode 100644
index 0000000..22f00a1
--- /dev/null
+++ b/src/unix/doc/mess/messnew.txt
@@ -0,0 +1,36 @@
+0.74
+
+New System Drivers Supported (in no particular order):
+------------------------------------------------------
+(none)
+
+
+System Driver Changes:
+----------------------
+- [A7800] Implemented Kangaroo and transparency modes. [Eric Ball]
+
+- [A7800] Removed use of plot_pixel(), resulting in performance gains. [Nate
+  Woods]
+
+- [APPLE2] Writing to disk images and ProDOS order (*.po) disk images are now
+  supported.  [Nate Woods]
+
+
+User Interface Changes:
+-----------------------
+- [Windows] It is now possible to make customized keyboard dialogs for
+  different drivers, in the same way that it is possible to make per-driver
+  customized joystick dialogs.  [Nate Woods]
+  
+
+Imgtool Changes:
+----------------
+(none)
+
+
+Source Changes:
+---------------
+- The core is based on MAME 0.74.  This incorporates all features of the
+  update to this core.  [MAME team]
+
+
diff --git a/src/unix/doc/mess/messold.txt b/src/unix/doc/mess/messold.txt
new file mode 100644
index 0000000..d93a02d
--- /dev/null
+++ b/src/unix/doc/mess/messold.txt
@@ -0,0 +1,2772 @@
+0.73
+
+New System Drivers Supported (in no particular order):
+------------------------------------------------------
+- DAI Personal Computer [Krzysztof Strzecha, Nate Woods]
+
+System Driver Changes:
+----------------------
+- [COCO] CoCo joystick buttons can now be mapped to the mouse buttons (bug
+  #317).  [Nate Woods]
+  
+- [COCO3] Now supports option for 8MB of RAM. [Nate Woods]
+
+- [SNES] Improved sprite to sprite priority. [Anthony Kruize]
+
+User Interface Changes:
+-----------------------
+(none)
+
+Imgtool Changes:
+----------------
+(none)
+
+Source Changes:
+---------------
+- The core is based on MAME 0.73.  This incorporates all features of the
+  update to this core.  [MAME team]
+
+- Added some bounds checking to opcode fetches (bug #352).  [Nate Woods]
+
+- Made some debugger fixes when dealing with 8 or 16 bit numbers.  [Nate
+  Woods]
+  
+- Fixed a bug in the handline of low resolution systems; the UI would not be
+  properly rendered.  [Nate Woods]
+
+- Adds info regarding device extensions to -listinfo and -listxml output.
+  [Andrea Mazzoleni]
+
+- Renamed config.? to crcfile.?.  [Nate Woods]
+
+- [Windows] When the new UI is active and MESS is paused, MESS now should not
+  waste any excess CPU time.  [Nate Woods]
+
+
+
+0.72
+
+New System Drivers Supported (in no particular order):
+------------------------------------------------------
+(none)
+
+System Driver Changes:
+----------------------
+- [COCO3] Fixed a bug whereby $FE00-$FEFF would be mapped to the wrong memory
+  when bit 3 of $FF90 was set when more than 512k was available.  This caused
+  some NitrOS-9 programs to crash when allocating too much memory (bug #352).
+  [Nate Woods]
+
+- [COCO3] Added '_' to the supported keys for the natural keyboard.  '_' is
+  specific to [Nitr]OS-9. [Nate Woods]
+
+- [JAGUAR] Some enhancements to the blitter; most games are still not
+  playable however. [Nate Woods]
+
+- [NES] Updated NES so that it uses the ppu2c03b support within MAME (which
+  was actually originally based on the MESS NES driver code). [Brad Oliver,
+  Nate Woods]
+  
+- [PC] Made fonts, monitor types and CGA chipsets configurable. [John Elliot] 
+
+- [PC] Basic state save support. [Nate Woods]
+
+- [SNES] Name select is only for sprites using tiles over 255. Fixed sprite
+  wrap at the bottom of the screen. Fixed clearing of HDMA channels. Fixed
+  background colours in mode 0. [Jimmy Li, Anthony Kruize]
+
+- [TI99] Several behind-the-scenes changes to support TI-99/8 emulation
+  (which is not 100% working and disabled in MESS builds but implemented
+  in source code).  Hopefully, there will be no change in functionality in
+  the various TI-99/4(a) drivers. [Raphael Nabet]
+  
+- [VECTREX] Fixed a bug that prevented the default mine.art file from being
+  loaded if no other artwork was found. [Nate Woods]
+
+User Interface Changes:
+-----------------------
+- Added separate configuration menu, to be used for configuration items that
+  were formerly represented with DIP switches.  [Nate Woods]
+  
+- [Windows] Revamped options menu, and added a keyboard customization menu.
+  Also added the ability to create artwork for controller configuration
+  screens (used NES as a testbed).  [Nate Woods]
+
+Imgtool Changes:
+----------------
+- [MAC] Added preliminary support for MFS images. [Raphael Nabet]
+- [TI99] Added support for HD images. [Raphael Nabet]
+
+Source Changes:
+---------------
+- The core is based on MAME 0.72.  This incorporates all features of the
+  update to this core.  [MAME team]
+
+- Fixed a bug that would cause a hang when parsing certain invalid filenames
+  (for example, D:\FOO\D:\FOO\BAR.ZIP). [Nate Woods]
+
+- Revamped some inputs, added IPT_MOUSE, IPT_START, and IPT_SELECT.  The
+  latter two can be used with IPF_PLAYER masks.  Also removed legacy
+  IPT_SELECT1-4, and IPT_START1-4 should no longer be used by MESS. 
+  [Nate Woods]
+
+- Tripled the delay in which wd179x errors are reported.  This manifested
+  itself in the CoCo driver by an emulated crash on some versions of NitrOS-9
+  when run on a write protected image. [Nate Woods]
+
+
+
+0.71
+
+New System Drivers Supported (in no particular order):
+------------------------------------------------------
+- Atari Jaguar [Nate Woods]
+
+System Driver Changes:
+----------------------
+- [APPLE2] Moved Apple 2 disks over to use the standard floppy device code.
+  [Nate Woods]
+
+- [GENEVE] Fixed a bug with undocumented VDP behaviour.  Fixed Mouse buttons.
+  [Raphael Nabet]
+
+- [PC] Fixed a bug in keyboard handling that caused a 'stuck key' keyboard
+  error to be displayed (bug #427). [Colin Howell, Nate Woods]
+
+- [PC] Added support for CGA 160x100 mode (bug #225).  [Nate Woods]
+
+- [PC] Fixed a bug that would occasionally cause garbage to be displayed on
+  the screen after a screen resolution change (bug #100).  [Nate Woods]
+
+- [PC1512] Fixed a few more video modes. [John Elliott]
+
+- [TI99] Added support for Mechatronics mouse [Raphael Nabet]
+
+- [TRS80] Fixed a crash on startup. [Nate Woods]
+
+User Interface Changes:
+-----------------------
+- [WIN32] Fixed some resizing problems in windowed mode when the system
+  resized the screen (bug #100). [Nate Woods]
+
+- [WIN32 FE] Fixed a bug whereby refreshing would reset the current system to
+  the last saved one (bug #384). [Nate Woods]
+
+- [WIN32 FE] Missing optional BIOSes no longer trigger audit errors (bug
+  #424). [Nate Woods]
+
+Imgtool Changes:
+----------------
+- [TI99] Added support for HFDC subdirectories. [Raphael Nabet]
+
+Source Changes:
+---------------
+- The core is based on MAME 0.71.  This incorporates all features of the
+  update to this core.  [MAME team]
+  
+- Fixed a bug in the code that chooses artwork files for software images (bug
+  #112). [Nate Woods]
+
+0.70
+
+New System Drivers Supported (in no particular order):
+------------------------------------------------------
+- Corvus Concept [Raphael Nabet]
+- Tomy Tutor [Raphael Nabet]
+
+System Driver Changes:
+----------------------
+- [A2600] Fixed bug #405 and corrected some dipswitches. [Stefano Priore]
+
+- [A7800] Reset and Start buttons now appear in the Input menu. Added
+  console's own Pause button. [Stefano Priore]
+
+- [ASTROCADE] Fixed some Input menu descriptions and corrected paddles'
+  sensitivities. [Stefano Priore]
+
+- [COCO] Implemented cocodmk_sector_count() and cocodmk_sector_info() in
+  coco_dsk.c, allowing DMK images with weird sector sizes to load properly
+  (bug #378). [tim lindner]
+
+- [EINSTEIN/EP128] Fixed crashes on startup (bug #407). [Nate Woods]
+
+- [GENEVE] Fixed sound in native mode and a mirror of the VDP ports that is
+  used by the converted Tomy carts.  Enabled access to the RTC in ti99 mode.
+  Implemented extra VDP ports in ti99 mode.  Implemented third mouse button.
+  [Raphael Nabet]
+
+- [IBMPC] Fixed a bug in the DAA instruction that prevented the driver from
+  starting up (bugs #423, #425). [Colin Howell]
+
+- [LISA] Implemented some missing MMU feature.  The Lisa OS still won't boot,
+  though. [Raphael Nabet]
+
+- [PC] Added support for natural keyboard handling.  Also fixed a bug in hard
+  disk handling (bug #403). [Nate Woods]
+
+- [PC200] Fixed a bug causing corrupted characters (bug #398) and a bug
+  affecting floppies at startup. [John Elliott]
+
+- [PCMDA] Fixed a bug whereby the screen wouldn't fully refresh all the time
+  (bug #419).  [Nate Woods, John Elliott]
+
+- [SNES] Fixed negative increment in GDMA. [Anthony Kruize]
+
+- [TI99] Fixed some bugs that had been introduced in IDE emulation. [Raphael
+  Nabet]
+
+- [TI99 EVPC card] Implemented missing VDP ports.
+
+- [TI99, GENEVE] Added hfdc HD support.  Changed floppy disk image format
+  from the previous MESS-specific format to the more universal v9t9 format.
+  This does make any difference for single-sided images, but you will need to
+  convert existing double-sided image to the new format. [Raphael Nabet]
+
+User Interface Changes:
+-----------------------
+- [WIN32 FE] The emulation will not be started up if any required devices are
+  not specified with an image, like cartridges on a console system.  (bug #415)
+  [Nate Woods]
+
+Imgtool Changes:
+----------------
+- Renamed the ti99 module to ti99_old, since the format it handles has been
+  obsoleted by changes in the ti99 driver. [Raphael Nabet]
+
+- Added support for Corvus Concept disk images. [Raphael Nabet]
+
+Source Changes:
+---------------
+- The core is based on MAME 0.70.  This incorporates all features of the
+  update to this core.  [MAME team]
+
+- Modified flopdrv.c to reset pDrive->id_index to zero when head is moved
+  from track to track. [tim lindner]
+
+- CRC calculation of read/write images has been disabled (bug #416).
+  [Raphael Nabet, Nate Woods]
+
+0.68
+
+New System Drivers Supported (in no particular order):
+------------------------------------------------------
+- Amstrad PC1512 v2 [John Elliott]
+- Apple ][, Apple ][+ [Stefano Priore]
+- Bally Computer System [Ian Knowles]
+- GameBoy Pocket [Anthony Kruize]
+- Myarc Geneve 9640 [Raphael Nabet]
+- PC AT and PC AT VGA [Nate Woods]
+
+System Driver Changes:
+---------------------- 
+- [A2600] Complete driver rewrite, including emulation of the 6532 RIOT (RAM, 
+  INPUT, OUTPUT, TIMER) chip, cycle count correction in the t6502 core (fixes 
+  games like Space Invaders) and a new tia core.  [Stefan Jokisch]
+
+- [APPLE2] Enhanced models now have the M65C02 processor specified; apple2c
+  now boots.  Removed *.vid files from the BIOS set in favor of the proper
+  character ROMs (suffixed with *.chr).  80-character text mode fixed (bug
+  #311).  Implemented double hires mode (bug #303) and support for the
+  alternate character set.  [Nate Woods]
+
+- [APPLE2] Now uses the Robert Munafo palette. [Steve Nickolas]
+
+- [AQUARIUS] The palette now corresponds to the one described in the User's
+  Manual. [Stefano Priore]
+
+- [COCO] PIA properly resets. [Nate Woods]
+
+- [PC] Fixed bugs in CGA and MDA rendering (bugs #339 and #374).  Also speeded
+  up EGA/VGA rendering and marked 'xtvga' as working. [Nate Woods]
+
+- [SNES] Improved 16x16 background tile mode. Fixed another GDMA bug. Various
+  mode 7 fixes. Fixed background priorities in modes 2 to 7. Added support for
+  direct select to mode 7. Removed support for horizontal interrupts as it was
+  totally broken. 16bit by 8bit multiply is now signed. [Anthony Kruize]
+
+- [SUPERGB/GBCOLOR] No longer marked as clones of the GameBoy. [Anthony
+  Kruize]
+
+- [TI99] Added support for Thierry Nouspickel's IDE card prototype. Added
+  incomplete but working support for the HFDC disk controller card and 80-
+  track drives. Added support for a fourth floppy drive with non-TI floppy
+  controllers. Fixed Super AMS memory card emulation. [Raphael Nabet]
+
+
+Source Changes:
+---------------
+- The core is based on MAME 0.68.  This incorporates all features of the
+  update to this core.  [MAME team]
+
+- Drivers now have a 'compatible_with' field, that specify drivers that have
+  compatible software but are not mere clones.  [Nate Woods]
+
+- Devices are now referenced by a mess_image pointer, rather than a type/id
+  pair. [Nate Woods]
+  
+- Enhanced MESS's natural keyboard facility, so that drivers can specify
+  handlers to bypass keypress simulation.  [Nate Woods]
+
+- Changed device load and unload so that all devices are loaded before machine
+  init, but not necessarily driver init, in response to a bug (bug #366).
+  [Nate Woods]
+
+- [Windows] Default directories for the file dialogs can now be specified on
+  a device type basis at the command line (e.g. -floppydisk_dir).  This
+  option will get written out when launched from the GUI, so that per system
+  directories can be recorded (bug #345). [Nate Woods]
+
+- [Windows GUI] Fixed a bug whereby extra software paths with spaces in them
+  would not be properly persisted (bug #369). [Nate Woods]
+
+- [Imgtool] Enabled support for ti99 disk formats with more than 1600 sectors.
+  Added support for v9t9 and pc99 disk image formats (note that these image
+  formats are supported by imgtool, but not by the ti99 driver).
+  [Raphael Nabet]
+
+
+0.67
+
+New System Drivers Supported (in no particular order):
+------------------------------------------------------
+(none)
+
+System Driver Changes:
+----------------------
+- [A2600/A5200/COLECO/COCO/INTV/MSX/SNES/VECTREX] Added support for new
+  GoodTools file extensions. (bugs #277, #278, #279, #350) [Nate Woods]
+
+- [C16/VC20] Fixed crashes in quickloader. [Nate Woods]
+
+- [C16] Improved TED7360 sound emulation. [Attila Grosz]
+
+- [COCO] Added direct support for OS-9 floppy disk images. If an attached disk's
+  filename ends in .os9, the first sector will be analyzed for geometry
+  information. [Tim Lindner]
+
+- [COCO] Scaled the joystick port to 64 quanta rather than 256. (bug #340)
+  [Tim Lindner]
+
+- [COCO] Fixed bug #359. [Nate Woods]
+
+- [MAC] Improved mouse emulation when moving diagonally. [Raphael Nabet]
+
+- [MC10] Fixed bug #358. [Nate Woods]
+
+- [PC200] Replaced generic character ROM with one reconstructed using CGAFont.
+  [John Elliott]
+
+- [PC1512] Replaced generic character ROM with one reconstructed using CGAFont.
+  [John Elliott]
+
+- [PC1640] Added definition for the character ROM in ROM_LOAD structure.
+  [Stefano Priore]
+
+- [PDP1] Added support for lightpen with variable tip size. [Raphael Nabet]
+
+- [TI99] Added support for new disk geometries (9 sec/trk DSSD, 16 sec/trk SSDD,
+  16 sec/trk DSDD). [Raphael Nabet]
+
+- [TOOLS] Added CGAFont, a tool to help people reconstructing PC character ROMs
+  without using an EPROM reader. [John Elliott]
+
+Source Changes:
+---------------
+- The core is based on MAME 0.67.  This incorporates all features of the
+  update to this core.  [MAME team]
+
+- VIDEO_UPDATE() now has a do_skip parameter, which enables drivers to inform
+  the core that no significant drawing has occured, and it is safe to skip
+  blitting the current frame. [Nate Woods]
+
+- [Windows] New -writeconfig option, that causes the current settings to be
+  written back to an INI on exiting the emulation. [Nate Woods]
+
+- [Windows] SSE optimizations to the blitter. [Nate Woods]
+
+- [Windows] Fixed bug #344. [Nate Woods]
+
+- [Windows UI] Fixed bug #348. [Nate Woods]
+
+- [Windows UI] Changes made to mounted devices at runtime will now be persist
+  between emulation sessions. (bug #228) [Nate Woods]
+
+
+0.66
+
+New System Drivers Supported (in no particular order):
+------------------------------------------------------
+(none)
+
+System Driver Changes:
+----------------------
+- [Lviv] Support for .SAV snapshots. Joystick support. [Krzysztof Strzecha]
+
+- [SNES] Added support for fullgraphic VRAM transfers. Fixed VRAM reads. Fixed
+  a rare clip window bug. [Anthony Kruize]
+
+- [T1000HX] Modified to use character data from the actual BIOS. [Nate Woods]
+
+- [APPLE2] Implemented floating bus emulation. [Nick Westgate]
+
+- [COCO3] Fixed a performance bug that could slow things down in simple cases
+  where not much screen IO is being made. [Nate Woods]
+
+- [TI99/4] Driver is now enabled. Some bugfixes and support for IR remote
+  handlers. [Raphael Nabet]
+
+Source Changes:
+---------------
+- The core is based on MAME 0.66.  This incorporates all features of the 
+  update to this core.  [MAME team]
+
+- Major change to device handling; all devices now have separate init/exit
+  and load/unload handlers.  The former are called on startup/shutdown, and
+  the latter are called when images are loaded and unloaded. [Nate Woods]
+
+- Moved CRC handling to use the core fileio functions. [Nate Woods]
+
+- Added a osd_image_load_status_changed() call, so that front ends can get
+  notified when the load status of an image changes. [Nate Woods]
+  
+- Introduced a cartslot_load_generic() call, to make simple cartridge image
+  loading a bit simpler. [Nate Woods]
+
+- [Win32 GUI] Fixed a bug where screenshots with periods in them would not be
+  loaded properly. [Nate Woods]
+
+- [Win32 GUI] Now uses INI files rather than the registry to store settings
+  [MAME32 Team]
+
+0.65
+
+New System Drivers Supported (in no particular order):
+------------------------------------------------------
+(none)
+
+System Driver Changes:
+----------------------
+(none)
+
+Source Changes:
+---------------
+- The core is based on MAME 0.65.  This incorporates all features of the 
+  update to this core.  [MAME team]
+
+- Fixed a fatal bug that could cause crashes when unmounting disk images for
+  certain systems at runtime.  [Nate Woods]
+  
+- [Win32] Fixed a bug that caused us to be looking for the MAME names of
+  sysinfo.dat and messinfo.dat (history.dat and mameinfo.dat).  [Nate Woods]
+
+- [Win32 GUI] Fixed a bug that caused software specific screenshots to
+  not show up if clicking between tabs.  [Nate Woods]
+
+0.64
+
+LICENSE CHANGE WARNING:
+We are considering changing distribution license, switching to GPL for the
+whole project and LGPL for some CPU and sound cores.
+If you contributed code to MESS and are against this change, now is the
+right time to let us know.
+
+New System Drivers Supported (in no particular order):
+------------------------------------------------------
+(none)
+
+System Driver Changes:
+----------------------
+- [SNES] SRAM is now saved/restored correctly. Allow DMA registers to be read.
+  More colour addition/subtraction improvements. Fixed the palette not updating
+  in some situations. Improved fixed-colour support. Fixed object drawing at
+  the left and top edges. Added support for clip windows. [Anthony Kruize]
+
+- [SNESPAL] Now informs carts that it's a PAL system. Corrected maximum line
+  count. [Anthony Kruize]
+
+Source Changes:
+---------------
+- The core is based on MAME 0.64.  This incorporates all features of the 
+  update to this core.  [MAME team]
+
+0.62.1
+
+New System Drivers Supported (in no particular order):
+------------------------------------------------------
+(none)
+
+System Driver Changes:
+----------------------
+- [AQUARIUS/TRS80/MICROTAN] Now use tilemap. [Nate Woods]
+
+- [GAMEBOY] Fixed envelope generation in sound channels 1 and 2. (bug #289)
+  [Anthony Kruize]
+
+- [APPLE2] Added support for lo-res color and 80 column text. [Nate Woods]
+
+- [APPLE2] Fixed open/closed apple keys and joystick buttons. (bug #297,
+  bug #302) [Nate Woods]
+
+- [A800] Fixed a recently introduced bug in disk support. [Lawrence Gold]
+
+- [SFZCH] Fixed and re-enabled. [Anthony Kruize]
+
+- [T1000HX] Minor video optimizations. [Nate Woods]
+
+Source Changes:
+---------------
+- New generic code for emulating terminals, now in use by the Apple I and
+  Kaypro drivers. [Nate Woods]
+
+- Added the ability to specify a minimum resolution to display a system, in
+  order to better support low resolution drivers. [Nate Woods]
+
+0.62
+
+New System Drivers Supported (in no particular order):
+------------------------------------------------------
+- Odyssey 2 [PeT, Dopefish Justin]
+
+System Driver Changes:
+----------------------
+- [SPECTRUM] Fixed snapshot loading. [Nate Woods]
+
+- [COCO] Fixed some bugs related to handling of degenerate JVC files (where the
+  file size is less than 161280 bytes) (bug #281) [Nate Woods]
+
+- [SNES] Fixed a GDMA bug that was causing graphics corruption. Added support
+  for FastROMs. Improved object and background layering priorities. Colour
+  addition/subtraction is greatly improved. Added vertical mosaic effect. Fixed
+  Mode 7 rotation and draw outside screen area. Added x/y flip to Mode 7. Added
+  support for the back colour constant. [Anthony Kruize]
+
+- [APPLE2] Fixed keyboard and aspect ratio, and also added color, joystick, and
+  natural keyboard support. (bug #291) [Nate Woods]
+
+- [SVI318] Enhanced disk drive support. [Tomas Karlsson]
+
+Source Changes:
+---------------
+- The core is based on MAME 0.62.  This incorporates all features of the 
+  update to this core.  [MAME team]
+
+- Added new snapshot/quickload code, to hide the details about loading
+  snapshots and quickloads from the drivers.  [Nate Woods]
+
+- Added the ability for systems to override the friendly names of devices. [Nate
+  Woods]
+  
+- [WIN32] Added the ability to toggle the frames per second view, differentiate
+  between soft and hard resets in certain systems, and to save screenshots in
+  the new UI.  [Nate Woods]
+
+0.61.2
+
+New System Drivers Supported (in no particular order):
+------------------------------------------------------
+(none)
+
+System Driver Changes:
+----------------------
+- [SNES] Fixed background scrolling. Added 16x16 tile mode. Improved Mode 21
+  SRAM support. [Anthony Kruize]
+
+- [GAMEBOY] Finally fixed sound channel 3 so it produces correct frequencies!
+  Flagged sound as being stereo. Improved input ports. Fixed loud buzz caused
+  by the new sound code when digital audio is used. (bug #275) [Anthony Kruize]
+
+- [SUPERGB] Fixed certain areas of the border image being left blank instead of
+  being filled in. (bug #264) [Anthony Kruize]
+
+- [COCO3] Fixed a bug that caused a few display glitches when switching between
+  40 column and 80 column mode. (bug #271) [Nate Woods]
+
+- [Z88] Video updates. [Kev Thacker]
+
+Source Changes:
+---------------
+- Updated all drivers device declarations to new system and removed old dev
+  array. [Nate Woods]
+
+- New options.disable_normal_ui and osd_trying_to_quit() functions created, to
+  support the new Win32 UI. [Nate Woods]
+
+- Added the ability for drivers to support drawing to the UI in a standard way;
+  which helped fix a problem where the tape graphic was lost in MESS 0.61. (bug
+  #270) [Nate Woods]
+
+- [Win32] New user interface replaces old UI; this is on by default but can be
+  disabled with the -nonewui command switch.  This new UI uses Windows native
+  menus and should be much easier to use. [Nate Woods]
+
+- [Win32] Help file entries for each system now list the directory name
+  expected by MESS. [Nate Woods]
+
+- [Win32 GUI] Fixed an incredibly MORONIC bug where RAM preferences were stored
+  as booleans (!?!) rather than integers (bug #260) [Nate Woods]
+
+- [Win32 GUI] Fixed a bug where certain elements in the treeview lost their
+  first character (bug #262) [Nate Woods]
+
+0.61.1
+
+New System Drivers Supported (in no particular order):
+------------------------------------------------------
+- Amstrad family (fixed and reenabled) [Raphael Nabet]
+
+System Driver Changes:
+----------------------
+- [COCO1] Update CRC for bas10.rom. Previous dump was bad. I would like to send
+  a pecial "Thank you" to Sellam Ismail (http://www.vintage.org) for finding a
+  Color Computer that contained Color BASIC 1.0. [tim lindner]
+
+- [COCO1/2/3] Moved disk handling code over to new FormatDriver system;
+  allowing transparent disk image handling for JVC, VDK, and DMK file formats.
+  [Nate Woods]
+
+- [COCO] Fixed a recent stupid bug in m6847 timing that had an effect on
+  certain timing situations (bug #249) [Nate Woods]
+
+- [COCO3] Fixed a palette timing bug that affected mid-frame video rendering.
+  (bug #253) [Nate Woods]
+  
+- [COCO3] Fixed a bug where hi-res text characters with the high bit set were
+  rendered as garbage. [Nate Woods]
+
+- [COCO3] Fixed a bug where $FF9D and associated registers were being updated
+  before vblank, when they should have been updated after. (bug #252) [Nate
+  Woods]
+  
+- [COCO1/2/3] Made sure that SAM (and GIME on the CoCo 3) registers are
+  properly reset after a crash. [Nate Woods]
+
+- [DRAGON32/64] Made artifacting disabled by default, as this is how PAL systems
+  would normally be.  [Nate Woods]
+
+- [DRAGON64] Fixed a bug that prevented the system to run (the dragon64 driver
+  was using the coco memory map) [Nate Woods]
+
+- [DRAGON64] Adjusted the memory mapping scheme, enabling the DragonDOS
+  cartridge and 64k mode to coexist.  Thanks to Simon Hardy for tracking down a
+  better algorithm. [Nate Woods]
+
+- [A5200] Fixed a regression in 0.61 that prevented the keypad from working.
+  (bug #246) [Nate Woods]
+
+- [A7800] Suffixed the name of the a7800 driver with NTSC and marked the PAL
+  version as a clone of the NTSC version. [Nate Woods]
+
+- [GBCOLOR] Implemented background priority. This fixes objects appearing over
+  the background when they shouldn't be. [Anthony Kruize]
+
+- [TI99/4A] Added support for BwG clock and floppy controller [Raphael Nabet]
+
+- [SNES] Memory map is more accurate, adding support for HiRom carts. Fixed
+  DMA transfers. Fixed missing tiles. Added preliminary mode 7 support. Added
+  subscreens, including colour addition/subtraction. Fixed vertical flip for
+  large objects. Improved vertical/horizontal latches. Improved ROM loading
+  with better header and ROM type detection. Improved the SPCSkipper so a lot
+  more games actually run now. [Anthony Kruize]
+
+Source Changes:
+---------------
+- The MESS core will not automatically open software images in a clone system
+  drivers directory anymore, under the belief that this functionality belongs
+  in the OSD code. [Nate Woods]
+
+- All MESS drivers need a SYSTEM_CONFIG (formerly COMPUTER_CONFIG) parameter
+  specified.  Also changed the implementation of the SYSTEM_CONFIG_* macros to
+  provide a more flexible system for representing the data.
+
+  Added the ability for devices to be declared within the SYSTEM_CONFIG block.
+  Consider the older way of declaring devices deprecated.
+
+  Added new functions for iterating through devices, in order to better
+  abstract the internal representation of devices:
+  
+	device_first()
+	device_next()
+	device_find()
+		
+  Also renamed GameDriver dev field to dev_ in order to break any source
+  dependencies on the dev field. [Nate Woods]
+
+- Added new memory pool code that implements memory pools that can be freed in
+  one step. [Nate Woods]
+
+- Overhaul of code that maintained the list of loaded images; moved to
+  mess/image.[c|h], and changed the prefix of them from device_ to image_ (as
+  opposed to the device_* calls that are used to access the IODevice
+  structure).  Also, implemented these new calls for drivers to use:
+  
+	image_malloc()    (similar to auto_malloc(), but for the lifetime of devices)
+	image_strdup()    (uses image_malloc() to allocate strings)
+	image_exists()    (tests for the existance of a loaded image)
+	image_filetype()  (accessor for file extension)
+
+  For the most part, there is no longer any reason for MESS drivers to use
+  malloc() and free(), so calls to these should be eliminated over time. [Nate
+  Woods]
+  
+- Removed IO_RESET_ALL, as it was broken and an ugly hack to begin with (bug
+  #239) [Nate Woods]
+
+- In the opening display software info box, if the filename and the goodname
+  (as determined by CRC) match up, the goodname will not be displayed in
+  order to reduce screen clutter. [Nate Woods]
+  
+- Removed all calls to device_close(IO_CASSETTE) in system drivers, instead
+  provided a cassette_exit() function that drivers can specify, removing this
+  responsibility from system drivers. [Nate Woods]
+
+- Implemented preliminary paste functionality; it attempts to decode the
+  driver's input tables and attempts to create a mapping between ASCII and
+  input signals.  This process is far from perfect at this time.  In the
+  future, it will be possible for drivers to customize the way that paste works
+  for a more perfect translation.  [Nate Woods]
+
+- Added new PORT_KEYx macros that should be used in place of PORT_BITX when
+  mapping keyboards.  These macros also specify unicode values for the input
+  codes for natural keyboard support.  [Nate Woods]
+
+- Added a new osd_keyboard_disabled() call.  If this returns non-zero, then
+  the core will supress input of type IPT_KEYBOARD.  This is useful if a front
+  end wants to implement a natural keyboard.  [Nate Woods]
+
+- Added a new osd_parallelize() call, for basic SMP acceleration.  [Nate Woods]
+
+- Renamed osd_dir.h to osd_mess.h, to further reflect that it is more than just
+  directory calls.  [Nate Woods]
+
+- [Win32] New -threads parameter, to specify the maximum amount of threads used
+  for osd_parallelize(); defaults to the number of processors in the system.
+  [Nate Woods]
+
+- [Win32 GUI] Printers are now treated separately from the other devices; you
+  do not specify printer ouput like you do disk images.  Printer output now
+  gets specified in the configuration tab of the system properties.  The added
+  benefit is that the same output file can be used repeatedly. [Nate Woods]
+
+- [Imgtool] Imgtool floppy drivers can now be "templated"; a driver for a
+  particular file system format can point at a structure that lists allowable
+  disk image formats.  This allows for the addition of new disk image format
+  drivers without touching the imgtool drivers. [Nate Woods]
+  
+- [Imgtool] Fixed a bug in the FormatDriver handling that caused some file puts
+  to not be properly written.  [Nate Woods]
+
+- [Imgtool] Added Color Computer DMK disk image support. [tim lindner]
+
+0.61
+
+New System Drivers Supported (in no particular order):
+------------------------------------------------------
+- Super GameBoy [Anthony Kruize]
+- GameBoy Color (preliminary) [Anthony Kruize]
+- Innumerable Sega Master System Variants [Mike Luong]
+
+Removed drivers:
+----------------------
+- Amstrad
+- Chess Champion I
+- Sinclair ZX Family
+- Studio 2
+
+System Driver Changes:
+----------------------
+- [COCO] The virtual printer should now be responsive to bitbanger output of
+  any arbitrary baud. [Nate Woods]
+
+- [COCO] Fixed a OKI M6242B clock emulation problem and a problem with Disto
+  Real Time Clock emulation. [tim lindner]
+
+- [COCO] Fixed a very ugly bug that could cause freezups under OS-9 and other
+  forms of disk accesses.  This was because interrupts were dropped when the
+  CPU is halted. (Bugs #197, #229) [Nate Woods]
+
+- [COCO3] Fixed a bug in the GIME video emulation that caused all parts of
+  the $FF9B/D/E video registers to be used in lo-res mode; where in reality
+  the low 16 bits are dropped.  This caused a bug in CoCoTracker that caused
+  the screen to be garbled after the MOD files are played. [Nate Woods]
+
+- [COCO3] Adjusted composite colors slightly with help from SockMaster (Bug
+  #227) [John Kowalski, Nate Woods]
+  
+- [COCO3] Exposed the two high bits on MMU registers (even though their value
+  is undefined) to fix a problem with SockMaster's LSAVEM utility. [Nate Woods]
+  
+- [COLECO] The Coleco driver now recognizes the *.col extension for Coleco
+  cartridges. [Nate Woods]
+  
+- [SPECPL3E] Updated BIOS to the 1.11 version romset
+  (http://www.z88forever.org.uk/zxplus3e/) [Stefano Priore]
+
+- [GAMEBOY] Can now load ROMs that are larger than 2MB. Fixed RAM bank
+  switching in MBC3 ROMs. [Anthony Kruize]
+
+- [COUPE] Combined coupe and coupe512 drivers into one driver that uses
+  configurable RAM sizes. [Nate Woods]
+  
+- [A2600] Converted video code from using plot_pixel() to draw_scanline() [Nate
+  Woods]
+  
+- [VTECH1] Converted back to using generic M6847 video hardware module (Bug #36)
+  [Nate Woods]
+
+- [SNES] Rewrite of the driver.  Still at a preliminary stage though. Some
+  games are playable, others run but aren't playable, however most don't work.
+  [Anthony Kruize]
+  
+- [VECTREX] Because of the MAME core's new artwork system, new .art files are
+  now needed in conjunction with the normal Vectrex .png files to specify the
+  artwork layout. [Nate Woods]
+
+- [GENESIS] Changed input ports to be consistent with other drivers.
+  [Anthony Kruize]
+
+Source Changes:
+---------------
+- The core is based on MAME 0.61.  This incorporates all features of the 
+  update to this core.  [MAME team] 
+
+- Converted numerous drivers to use the auto_malloc() and auto_bitmap_alloc()
+  calls, and also to use generic_bitmapped video calls. [Nate Woods]
+
+- Added new videomap code that makes it easy to support arbitrary video modes
+  in a fast, efficient manner.  This takes the place of the old
+  rasterbits/rastertrack code; converted m6847, CoCo 3, and Mac video hardware
+  to use videomap. [Nate Woods]
+
+- Added a new disk format handling system that allows disk formats to be
+  generically specified in such a way usable by both MESS itself, and imgtool
+  [Nate Woods]
+
+- Fixed a bug in the wave code that could cause a crash if a cassette image is
+  unloaded. [Nate Woods]
+  
+- Added a [none] entry in the File Manager, that allows the user to unload an
+  image. [Nate Woods]
+  
+- The file manager will now default to the directory that a preexisting image
+  resides in. [Nate Woods]
+
+- Fixed some bugs that caused the battery backups in the NES and GB systems to
+  be placed in odd directories. [Nate Woods]
+  
+- Added palette_set_colors() function to make it easy to initialize a palette
+  with a predefined list of colors. [Nate Woods]
+  
+- Readded record/playback support. [Nate Woods]
+
+- Added artwork_use_device_art() to the MAME core to support Vectrex style
+  artwork. [Nate Woods]
+
+- Fixed bugs #192 and #200 - remember that:
+
+  1) In File Manager you can press SHIFT+ENTER to manually edit a filename
+     and CTRL-Y to delete the field.
+
+  2) In the file selector you can edit the file specification and you can use
+     SHIFT+UP/DOWN as PgUp/PgDown and
+     CTRL+UP/DOWN as Home/End. [Stefano Priore]
+
+- With help from SockMaster, fixed some very subtle timer bugs in the m6809
+  and hd6309 CPU cores [Nate Woods, tim lindner, John Kowalski]
+  
+- New OSD function:
+
+		void osd_device_eject(int type, int id);
+
+  It sets a device image to NULL, as would a device_filename_change(type, id,
+  NULL), but enables osd code to update its osd structures.  The mac and lisa
+  drivers will use this function instead of device_filename_change to eject
+  floppy disks.
+
+  This function is needed because the mac osd code keeps track of each
+  selected file, and the data went out of sync when device_filename_change
+  was called. [Raphael Nabet]
+
+- [GUI] Fixed a very minor bug that caused the software list view background
+  to not be updated at the same time as the system list if the snap directory
+  was changed. [Nate Woods]
+
+0.56.1
+
+New System Drivers Supported (in no particular order):
+------------------------------------------------------
+- Dragon 64 [Nate Woods]
+- PK-01 Lviv (three ROM revisions) [Krzysztof Strzecha]
+- Microbee 32 PC [Stefano Priore]
+- ZX Spectrum +3e (Spain) [Stefano Priore]
+- TI-99/4P (preliminary) [Raphael Nabet]
+- TI-990/10 [Raphael Nabet]
+
+System Driver Changes:
+----------------------
+- [GAMEBOY] Added sound emulation(Bug #75).  Added support for MBC2, MBC3 and
+  MBC5 carts. Most GBC games now show a "this game only works on GBC" screen.
+  MBC1 can now switch modes. MBC3 has partial RTC emulation. Added support for
+  battery backed ram(Bug #133). Sprites no longer have inverted colours in some
+  games(Bug #26). Fixed window layer positioning(Bug #39). Changed the palette
+  to closer resemble the LCD screen(Bug #87). Games which originally have no
+  sound don't produce bass sound at start up(Bug #195). Improved LCD status
+  timing and interrupts(Bug #117). [Anthony Kruize]
+
+- [CGENIE] Floppy initialization fixed for when no floppy attached 
+  (Bug #95) [Ben Bruscella]
+
+- [UK101/SUPERBOARD] Cassette Initialization fixed [Stefano Priore]
+
+- [MBEE] Renamed mbeepc to mbeepc85. Now mbee emulates the IC model (editor
+  assembler), mbeepc emulates the PC model (terminal emulator) and mbeepc85
+  emulates the PC85 model (WordBee wordprocessor) [Stefano Priore]
+
+- [JUPITER] Cartridge and Cassette Initialization fixed 
+  (Bug #126) [Ben Bruscella]
+
+- [NASCOM]  Cassette Initialization fixed
+  (Bug #183) [Ben Bruscella]
+
+- [A7800] Fixed interrupt handling bug - more carts run again [Ben Bruscella]
+
+- [A7800] Fixed bug that caused crashes on resets [Nate Woods]
+
+- [ORICA] The FUNCT key (present on Oric Atmos/Telestrat model) is now recognized.
+  [Stefano Priore]
+
+- [PRAV8D] Pravetz keyboard is now fully mapped and the keycaps are correctly
+  displayed (see the "Input" menu) [Stefano Priore]
+
+- [SPECTRUM] 48k machines are now able to run code in screen memory (Bug #46).
+  Fixed problem with interrupt vector set to 0xffff (much more 128k games works
+  now). Corrected frames per second value for 48k and 128k Sincalir machines.
+  Remaped some Spectrum+ keys. Added support to load .SP snapshots. Added .BLK
+  tape images support. #FF port emulation added (Arkanoid works now but is still
+  not playable due to wrong timings) (Bug #47). [Krzysztof Strzecha]
+
+- [SPECPL3E] Updated BIOS to the 1.10 version and added support for the spanish
+  romset (http://www.z88forever.org.uk/zxplus3e/) [Stefano Priore]
+
+- [TI99/4A] xtensive rewrite: The code should be more flexible and more readable.
+  * Updated tms9901 code.
+  * Optional floppy controller, speech synthesizer, memory extension can be
+    disabled.
+  * Support for super AMS, foundation, and a myarc look-alike memory extension
+    cards.
+  * Improved fdc emulation.
+  * Better GROM and speech timings.
+  * Support for multiple extension cards, and multiple GROM ports.
+  * Speech synthesizer now works!!!
+  * Added support for EVPC video card. [Raphael Nabet]
+
+- [AMSTRAD CPC] Fixed RAM configuration selection, now the original Heroquest 
+  will run [Kev Thacker, Richard Wilson]
+
+- [COCO] Converted CoCo drivers to use configurable RAM sizes, and the CoCo 3
+  driver now supports the 2 MB upgrade (if I knew the specs, it would be very
+  trivial for me to support the 8 MB upgrade). [Nate Woods]
+  
+- [COCO] Fixed a bug in DMK disk image on little endian machines. (Bug #179)
+  [Nate Woods]
+
+- [PC] Fixed a bug that caused the keyboard buffer to get flooded and the
+  emulated system to get paralyzed in beeping under certain situations (bug
+  #151). [Nate Woods]
+
+- [EXIDY & KC85/3] These drivers now startup with the MAME 0.56 core. [Kev Thacker]
+
+- [EINSTEIN] Implemented more interrupts and fixed their priorities [Kev Thacker]
+
+- [SORD M5] Cassette writing is working, but loading is not :( [Kev Thacker]
+
+- [TS1000] The main rom file is now called zx81a.rom, instead of zx81.rom in
+  order to match the other drivers in the family. [Nate Woods]
+
+- [COCO3] Added support for Jeff Vavassour's virtual hard disk. His Color
+  Computer 3 emulator comes with an OS-9 driver. [tim lindner]
+
+- [INTV] Added collision detection (Bug #163) [Kyle Davis]
+
+- [PDP1] Added support for perforated tape and read-in mode.  Removed the
+  current image load hack, since the use of the perforated tape reader in
+  read-in mode enables the user to enter programs in an historically-correct
+  way.  Various additional bug-fixes and some code clean-up.
+  Added control panel, variuos memory sizes, automatic multiply/divide,
+  interactive typewriter display and Spacewar! supports hyperspace controls
+  now. IO code has been rewrote and timings are greatly improved.
+  Teletyper output can be logged to a file (via -printer switch).
+  Added support for sequence break system.
+  Simulation of CRT remanence. WARNING: .rim files must be run pressing
+  LCTRL+ENTER to switch into read-in mode! [Raphael Nabet]
+
+- [APPLE1] Snapshot support added - memory dumps loaded via the image MESS 
+  loading interface.  The images need a header, using the following 
+  format - "LOAD:xxyyDATA:".  This header enables the emulation to load the 
+  data to the correct location.  [Ben Bruscella, Stefano Priore]
+
+- [NES] Now uses battery_save() and battery_load() to save and load battery
+  backed NVRAM. [Nate Woods]
+
+- [GENESIS] Fixed broken input in some games(Bug #139). [Anthony Kruize]
+
+- [VECTREX] Improved detection of 3D games. [Cowering]
+
+- [sysinfo.dat] Updates to genesis and nes [Hobie Troxell]
+
+Source Changes:
+---------------
+- The core is based on MAME 0.56.  This incorporates all features of the 
+  update to this core.  [MAME team] 
+
+- The core now supports configurable RAM sizes; drivers can expose RAM
+  configurations (e.g. 4k, 16k, 32k etc) and on Windows, this setting is
+  exposed through a command line switch -ramsize.  [Nate Woods]
+
+- Fixed a bug that prevented introducing completely new software images when
+  there was already one of that particular image type already loaded. [Nate
+  Woods]
+
+- Added some infrastructure for automated tests. [Nate Woods]
+
+- Fixed a bug in tape handling that would cause rewind and fast forward to not
+  work if the system was stopping the tape (bug #168). [Nate Woods]
+
+- Added battery_save() and battery_load() functions to abstract handling of
+  battery-backed NVRAM on cartridges. [Nate Woods]
+  
+- Modified osd_fopen() with OSD_FILETYPE_NVRAM so that the filename parameter
+  can specify subdirectories (for use by battery_save() and battery_load().
+  [Anthony Kruize, Nate Woods]
+
+- [Windows] Fixed a bug in the core that caused the MESS process to not die if
+  the close box was pressed, and the UI was disabled (bug #170). [Nate Woods]
+ 
+- [Windows] Fixed a bug in the GUI that caused heap corruptions. [Nate Woods]
+
+- [Windows] Fixed a bug in the GUI that caused auditing to report BIOS-less
+  console systems as missing BIOSes. [Nate Woods]
+
+- [IMGTOOL/Windows] Added wildcard support in the put command, since the
+  Windows shell doesn't do this by default. [Nate Woods] 
+  
+- [IMGTOOL/FAT driver] Fixed bug where files would get stored into a FAT image
+  without forcing the filename to upper case. [Nate Woods]
+
+- [MacMESS] Added configurable RAM sizes and dipswitch controls to the MESS
+  tab. [tim lindner]
+
+
+Removed Systems:
+----------------
+- sfzch, snes
+
+------------------------------------------------------------------------------
+0.56
+
+New System Drivers Supported (in no particular order):
+------------------------------------------------------
+Unipolbrit Komputer 2086 [Krzysztof Strzecha]
+ZX Spectrum 48k Psycho (ROM modification) [Krzysztof Strzecha]
+
+
+System Driver Changes:
+----------------------
+- [TI81] ON/OFF fixed. ROM bank switching added (port 5). NVRAM support added.
+  [Krzysztof Strzecha]
+
+- [TI85/TI86] Snapshot loading corrected. [Krzysztof Strzecha]
+
+- [TC2048/TS2068] Aspect ratio corrected. [Krzysztof Strzecha]
+
+- [TS2068] Support for DOCK cartridges added. Support for Z80 snapshots added.
+  AY sound added. [Krzysztof Strzecha]
+
+- [DRAGON/COCO] Improved one bit sound out. Improved support for DMK file format;
+  now supports multiple sector sizes. Fixed double sided disk access in OS-9.
+  Added support for the memory sense switch used to select between 64/32, 16 and
+  4K. [tim lindner]
+  
+- [APF Imagination] Cassette loading and saving is working. Disc emulation is working.
+  Added some more key definitions. [Kev Thacker]
+
+- [ORIC] Fixed cassette loading and saving. [Kev Thacker, Mathis Rosenhauer]
+
+Source Changes:
+---------------
+
+- The core is based on MAME 0.56.  This incorporates all features of the 
+  update to this core.  [MAME team] 
+
+- [Windows] The CONSOLE and GUI (the former MESS32) versions of MESS have been
+  combined into one distribution.  [Ben Bruscella, Nate Woods, with a Huge
+  thanks to MAME32 team, especially: Michael Soderstrom, Mike Haaland, and
+  Chris Kirmse]
+
+- [Windows GUI] CRC directory now configurable from MESS GUI [Nate Woods]
+  
+- MESSRoms now recognizes more ROMs. [Krzysztof Strzecha]
+
+- Switch -a for MESSRoms, which allow to scan files of all sizes.
+  [Krzysztof Strzecha]
+
+- Removed extension renaming code. [Nate Woods]
+
+- Combined OSD_FILETYPE_IMAGE_R and OSD_FILETYPE_IMAGE_RW image load types
+  into OSD_FILETYPE_IMAGE. [Nate Woods]
+
+- Converted a few drivers (namely Amstrad, Atom, Exidy, Galaksija, Microbee,
+  Microtan, Sord, Spectrum, TI99) to use the new cassette loading APIs. [Nate
+  Woods]
+
+- Added new core file (led.c) for display of leds and segmented displays.
+  Also converted Chess Champion drivers to use these calls. [Nate Woods]
+
+- On the images screen before emulation starts, only the base name of an image
+  will be displayed (bug 34). [Nate Woods]
+
+- [Windows] Added support for transparent zip paths
+  (e.g. C:\imgs\mule.zip\mule.atr) [Nate Woods]
+
+- Added a call to flopdrv.c to allow the driver to manualy set the number of
+  tracks and sides. [tim lindner]
+
+--------------------------------------
+0.37b15
+For Lee Ward (lee@the-mothershp.fsnet.co.uk)
+  *If you know Lee, please contact us......
+
+
+New System Drivers Supported (in no particular order):
+------------------------------------------------------
+NEC PC8801SR [Shouhei Nishi]
+Emerson Arcadia 2001 (preliminary) [PeT]
+More Nascom1/2 official releases [JoJo]
+Sharp PC1403/1403H (preliminary) [PeT]
+Texas Instruments TI-81 (preliminary) [Krzysztof Strzecha]
+Texas Instruments TI-86 (preliminary) [Krzysztof Strzecha]
+CoCo 3 PAL [Cowering and Nate Woods]
+Intellivision & Intellivision Kbd Component (preliminary) [Frank Palazzolo]
+Sord M5 (preliminary) [Kev Thacker]
+Einstein TC-01 (preliminary) [Kev Thacker]
+
+System Driver Changes:
+----------------------
+
+- [ATARI7800] Fixed a bug in TIA emulation: now the driver doesn't lock 
+  anymore with some ports. [Frank]
+
+- [NC200] Keyboard reading and display memory address differences (compared 
+  to NC100) implemented. [Kev Thacker and Russell Marks]
+
+- [NC100/NC200] Changed CPU frequency to be more accurate 
+  [Kev Thacker and Russell Marks]
+
+- [PRAVETZ] Emulation of Apple2 disc controller interface (low 8D DOS and high 
+  8D DOS is supported. (DOS1->1.30 for low DOS and DOS 2.10 or better for high 
+  DOS) Disk images are ".DSK" and same as used by Apple2 driver. [Kev Thacker]
+
+- [KC COMPACT] colours generated from colour rom [Kev Thacker]
+
+- [TI85] Snapshot loading (VTI 2.0 save state files). Sound added (speaker
+  connected to link port). Video engine totaly rewriten so grayscale works 
+  now.  NVRAM support added. Link port emulation added (variables, memory 
+  backups and screen dumps receiving, variables and memory backups sending). 
+  Reset fixed. PCR emulation added.
+
+- [APPLE I] Support for the correct chargen ROM. Character grid has now the 
+  correct dimensions [JoJo]
+
+- [AQUARIUS] Added correct palette. [JoJo]
+
+- [ATARI5200] Changed the cart loading strategy. Many more carts work now. 
+  [PeT]
+
+- [COLECO] Changed MEMORY handlers which allows more carts to work (like aqua 
+  attack and tutankham). Small fix to input handling which means Defender and 
+  Centipede now work. Accurate NMI handling added which fixes remaining carts 
+  like Buck Rogers, DragonFire, Zenji, Bump and Jump, etc. Also, keys are 
+  configurable from the OSD for both controllers. Code cleanup.
+  [Ben, Sean Young]
+
+- [DRAGON/COCO1-2-3] Completely rewritten midframe video mode rendering, which
+  now applies not just to the CoCo 3, but to all systems that use the m6847 and
+  derivatives.  Also, a few effects now work that never have done before,
+  including the dynamite effect in Canyon Climber and some SockMaster demos.
+  Totally reworked ROM support; cartridge IO is now modular,
+  the CART signal is handled better, and ROMs that don't take up the full
+  address space are properly mirrored.  These changes make many more cartridges
+  work properly, including Mind-Roll which is banked.  Also, properly NOP'd
+  invalid memory areas, which prevented Arkanoid from running.  [Nate Woods]
+
+- [COCO] Implemented support for the Orch90 cartridge. [Tim Lindner]
+
+- [MSX2] The V9938 emulation is improved, added interlaced mode, fixed blitter 
+  timings, sprites, and GRAPHIC 5 (SCREEN 6). The MSX2 now has a 128kB memory 
+  mapper, so now many more games run. Numeric keypad emulation added. Fix to
+  the K051649 (SCC) now F1 Spirit sound works. [Sean Young]
+
+- [C128] VIC charracter rom switching and color ram banking added. [PeT]
+
+- [C64/MAX/C128/CBM B series/C65] fixed cia6526 interrupt enabling. [PeT]
+
+- [C64/MAX/C128/CBM500/C65] fixed 3 sprite collision issues,
+  fixed interrupt enabling. [PeT]
+
+- [C64/MAX/C128/C65] added support for alternate keyboard polling 
+  (matrix i/o reversed). added second cia6526 irq(nmi) generation. [PeT]
+
+- [C64] added support for game/exrom cartridge lines in crt files
+  bankswitching fixes [PeT]
+  
+- [VIC20] power up strategy changed (RAM is not filled with 0xff 0x00 pattern 
+  like in VICE anymore, real SRAM is indeed filled with random pattern). Power 
+  up "support" for jelly monsters. Keyboard polling support for 
+  second/alternate matrix io selection. Some "dipswitch" fixes. [PeT]
+
+- [C16] TED timer 1 reloading on underrun changed. [PeT]
+  ECM and Multicolor mode: cursor and character inversion disabled.
+  TED sound channels simplified to generate only rectangular signals: 
+  digisound working, less static, clearer sound. Now the driver uses MOS 8580. 
+  [PeT]
+
+- [C16/C64/CBM B/C128/C65] SID cleanup, realtime modifications, digisound 
+  support (fx sound good now, random number generation ok). [PeT]
+
+- [C16/C64] tape fixed. [PeT]
+
+- [C65] Stereo enabled. [PeT]
+
+- [SUPERVISION] nmi added (crystball bonus items fixed)
+  irq changed, preliminary sound added & fix of the stereo allocation.
+  Stereo enabled. [PeT]
+
+- [PC1401] Memory configuration fix. Display on/off emulation. [PeT]
+
+- [SPECTRUM] Interface 2 emulation. [David Robertson]
+
+- [SATURN] Many fixes. The driver now boots up and displays splash screen, but 
+  it's still non-functional. [James Forshaw]
+
+- [SNES] Added preliminary tile-mosaic effect and fixed a small matrix bug in 
+  mode 7, F-zero now renders the screen the correct way [Lee Ward]
+
+- [LNW80] Added correct BIOS. The driver is still non functional. [JoJo]
+
+- [EP128] Some graphics problem fixed [Kev Thacker]
+
+- [LYNX] Preliminary sound support & fix of the stereo allocation. Stereo 
+  enabled.  Added enhanced blitter modes and multiplier. Added rasterline 
+  rendering, screen flipping, fixed reset and added audio/timer connection. 
+  [PeT]
+
+- [VZ200] Video code has been temporarily reverted to Jurgen's code, and 
+  doesn't make use of the new M6847 features. [Nate Woods]
+
+Source:
+-------
+
+- The main binary distribution of MESS is now a completely new win32 console
+  port. Some of the benefits are: support for full screen hardware stretching
+  (if you have a decent video card), and a much better command line / options
+  file parsing (ported from xmame).    To create the mess.ini configuration 
+  file on startup, use the -createconfig option. -showusage lists all 
+  available options. [Aaron Giles, Bernd Wiebelt, Lee Ward, Ben Bruscella]
+
+- The core is based on MAME 0.37b15.  This incorporates all features of the 
+  update to this core.  [MAME team] 
+
+- Added support for the SUPPORT_ODD_WORD_SIZES macro, needed by ApexC and PDP 1.
+  [Nate Woods]
+
+- CoCo cartridge code has been moved to its own file [Nate Woods]
+
+- The switches "-cylinder", "-punchcard", "-punchtape" and "-parallel" are now
+  recognized. At the moment "-parallel" is not used by any driver, but has been
+  reserved for future expansions. [JoJo]
+
+- Huge rewriting/rationalization of the device handling/image loading code. [Ben]
+
+- Logging routines have been fixed. [Ben]
+
+- Added Jurgen's tool to create generic CP/M disk images to the tools/ directory
+  [JoJo]
+
+- Imgtool's dir command now displays CRC32s. [PeT]
+
+- MESS now supports the new TINY_COMPILE model. [Ben]
+
+- MESSRoms now recognizes more ROMs. [PeT]
+
+- An init function has been added to the M65CE02 CPU emulation. [PeT]
+
+- M, D and V registers support in the state saving engine and MD register's
+  behaviour fixed in the HD6309 code. [Tim Lindner]
+
+- Z80 CPU now behaves correctly after an IRQ: this fixed a bug in PC8801 
+  emulation. [Sean Young]
+
+- Added save sate support to TMS34010 CPU. [Nate Woods]
+
+- Many fixes to the SC61860 CPU. H is treated now as an internal register. [PeT]
+
+- Added a static memory interface, interrupt functionality and runtime loader 
+  support to the F8 CPU core. [PeT]
+
+- Fixed the DIV1 instruction Q bit generation for the SH2 CPU. [James Forshaw]
+
+- Alias handling removed and wont be back. [Ben]
+
+
+-------------------------------------------------------------------------------  
+0.37b14
+
+This release was skipped
+
+-------------------------------------------------------------------------------  
+0.37b13
+
+Several drivers may be broken due to the MAME memory handling changes.
+And as a result, the Amiga has been temporarily removed.
+
+Note: .inp record/playback does still not work currently.
+
+New System Drivers Supported (in no particular order):
+------------------------------------------------------
+...
+
+System Driver Changes:
+----------------------
+- Sfz (cps changer) fixed to work with the new MAME code [Ben]
+
+- [DRAGON/COCO1-2-3] Added support for raw Program Pak dumps (use file extenion
+  .ROM).  Also, implemented the 1-bit sound mode. [Nate Woods]
+
+- [DRAGON/COCO1-2] Basic save state support added. [Nate Woods]
+
+Other Changes:
+--------------
+- The core is based on MAME 0.37b13. This incorporates all features of the update to this 
+  core.  [MAME team] 
+
+- [IMGTOOL] Added special support in imgtool to separate floppy image formats from the 
+  file system.  Also added a test command that only gets built in debug builds that runs 
+  a set of test cases on an imgtool driver.  [Nate Woods]
+
+
+-------------------------------------------------------------------------------  
+0.37b12
+
+Several drivers may be broken due to the MAME memory handling changes.
+And as a result, the Amiga has been temporarily removed.
+
+Note: .inp record/playback does still not work currently.
+
+New System Drivers Supported (in no particular order):
+------------------------------------------------------
+N/A
+
+System Driver Changes:
+----------------------
+- [KC85/4 & KC85/3] Colours fixed. Added colour flash support. Improved accuracy of video 
+  redraw;  mid frame changes are now supported (only flash changes are supported at this 
+  time); flashing lines in Boulderdash are reproduced now. Thankyou to Torsten Paul for 
+  his information about the colour flash. Swapped CLR and DEL keys (previously you had to 
+  press "delete" near Scroll Lock to delete back a char. Now you can press backspace).
+  [Kev Thacker]
+
+- [ORIC1/ORICA/TELSTRAT] Fixed .tap loading. (Conversion from .tap to internal .wav form 
+  was completely broken). [Kev Thacker]
+  
+- [COCO 3] More work on improving video timing for mid frame video register modification. 
+  Now supports mid frame palette modification, and altered the way video RAM is scanned so 
+  that John Kowalski's Boink demo now runs (albeit with many glitches).  Also fixed a bug 
+  that would cause the "Speed Up Poke" to still be in effect after a reset. [Nate Woods]
+
+
+Other Changes:
+--------------
+- The core is based on MAME 0.37b12. This incorporates all features of the update to this 
+  core.  [MAME team] 
+
+- [IMGTOOL] Added support for NC100/NC200 PCMCIA Ram Card images. Card can be formatted 
+  and files can be transfered to and from card filesystem. [Kev Thacker] 
+
+- [machine/z80fmly] The Zero count/Timeout output pulse was very short. Now the pulse is
+  active for longer. Required for KC85/4 colour flash to work! [Kev Thacker]
+
+
+
+-------------------------------------------------------------------------------  
+0.37b11
+
+Several drivers may be broken due to the MAME memory handling changes.
+And as a result, the Amiga has been temporarily removed.
+
+Note: .inp record/playback does still not work currently.
+
+New System Drivers Supported (in no particular order):
+------------------------------------------------------
+- Atari Lynx (preliminary) [PeT]
+- KC85/3 (preliminary) [Kev Thacker]
+- MSX2 and MSX2 Japanese (preliminary) [Sean Young]
+- Exidy Sorcerer (preliminary) [Kev Thacker]
+
+System Driver Changes:
+----------------------
+
+- [ATOMEB] Eproms were not being selected; now fixed. Random data is poked into address 
+  8,9,$A,$B, this is used by the OS to seed the random number generator. Thanks to Kees 
+  van Oss for providing this information [Kev Thacker]
+
+- [KC85/4] Implemented keyboard hardware. Previous hack has been removed.
+  Seperated machine/kc.c into machine/kc.c and systems/kc.c.
+  Merged all headers into includes/kc.h, and added all defines here.
+  Cleaned up some of the code, and made sure allocated memory was free'd properly.
+  Implemented preliminary tape reading using ".wav". Implemented preliminary
+  sound emulation. Added IO_QUICKLOAD to load ".kcc" and binary files with 128 byte
+  header. Load the file then type MENU and it should appear in the list, now you
+  can type the name of the program to run it.
+  [Kev Thacker]
+
+- [ORIC1/ORICA/TELSTRAT] .tap tape images can now be used. These are converted
+  at run-time into .wav files, and can be used in the same way as .wav. Code based
+  heavily on tap2wav by Fabrice Frances [Kev Thacker, Fabrice Frances]
+
+
+- [COCO 1/2/3] Reworked m6847 synchronization and sound mux signals to make
+  them much more accurate.  Fixed a bug that caused the joystick to max out all
+  the time. Added a new abstraction layer for cartridge IO interfaces.  Optimized
+  graphics emulation a bit.  Adjusted default controls so that joystick buttons
+  will work by default.  Improved PMODE 4 artifact colors to be more accurate
+  (special thanks to John Kowalski for providing color information) [Nate Woods]
+
+- [DRAGON] Fixed DragonDOS cartrdige, so now DragonDOS works fine.  [Nate Woods]
+
+- [NC100/NC200] Fixed PCMCIA Memory card emulation: Read/Write state can be changed using
+  a dipswitch in the UI, memory card changes are saved back to memory card file. 
+  Discovered more about the NC200 hardware and updated the code. Cleaned up more
+  of the source, added better description about the I/O ports and seperated it into 
+  common code, nc100 only and nc200 only code. Serial baud rate was not setup correct,
+  now fixed.
+  [Kev Thacker]
+
+- [EP128/EP128A] Initial sound emulation. Some sampled sounds work, and simple tone is 
+  working.  Fixed some interrupt problems [Kev Thacker]
+
+Other Changes:
+--------------
+
+- The core is based on MAME 0.37b11. This incorporates all 
+  features of the update to this core.  [MAME team] 
+
+- [Intel 8271 Floppy disc controller] Writing should work now. [Kev Thacker]
+ 
+- [src/machine/z80fmly] Added support for BSTB and ASTB inputs for Z80 PIO.
+  These are required by KC85/4 and KC85/3 systems. Added code to execute callback for 
+  BRDY and ARDY outputs. [Kev Thacker]
+
+- [IMGTOOL] Fixed a bug that caused crashes when parameters to create were not
+  properly specified [Nate Woods]
+
+
+
+-------------------------------------------------------------------------------  
+0.37b10
+
+Several drivers may be broken due to the MAME memory handling changes.
+And as a result, the Amiga has been temporarily removed.
+
+Note: .inp record/playback does still not work currently.
+
+New System Drivers Supported (in no particular order):
+------------------------------------------------------
+- Super Vision [PeT]
+- SVI-318 and SVI-328 [Sean Young]
+- Pravetz,Pravetz 8D (clone of Oric) [Stefano Priore]
+
+System Driver Changes:
+----------------------
+
+- [ATOM] Implemented colour change support of M6847. 
+  Fixed eprom box emulation. [Kev Thacker]
+
+- [LASER110/LASER200/LASER310] Changed video hardware to use M6847 [Kev Thacker]
+
+- [NC100] Added MENU key and fixed problems with characters being dropped
+  in serial transfer [Kev Thacker]
+
+- [NC200] Added MENU key, fixed some key assignments, fixed a memory problem.
+  Blockade game now works. Fixed characters being dropped in serial transfer
+  [Kev Thacker]
+
+- [ORIC] Added VSYNC cable hardware; This can be enabled with a dipswitch 
+  in the UI. Added support for Jasmin floppy disc interface; Floppy disc 
+  interface can be chosen in UI: None, Microdisc or Jasmin. Improved video
+  emulation; hires/text changes in the middle of a line will now work. [Kev Thacker]
+
+- [COCO 3] Fixed the GIME Timer so that it isn't resetting on writes to
+  $FF95 [Nate Woods]
+
+- [COCO 3h] 6309 core completed; so NitrOS9 now runs.  GAME_NOT_WORKING flag
+  removed [Tim Linder]
+
+Other Changes:
+--------------
+
+- The core is based on MAME 0.37b10. This incorporates all 
+  features of the update to this core.  [MAME team] 
+- [IMGTOOL] Added filter support, and filters that translate endoflines, as
+  well as the startings of BASIC tokenization.  Also updated the docs [Nate
+  Woods]
+  
+-------------------------------------------------------------------------------  
+0.37b9 
+
+Several drivers may be broken due to the MAME memory handling changes.
+And as a result, the Amiga has been temporarily removed.
+
+Note: .inp record/playback does still not work currently.
+
+New System Drivers Supported (in no particular order):
+------------------------------------------------------
+- CoCo 2B (CoCo with a M6847T1 VDG chip) [Nate Woods]
+- EURO PC, IBMXT [PeT]
+
+System Driver Changes:
+----------------------
+
+- [NC100,NC100A,NC200] Implemented serial hardware: Programs can be loaded into emulation
+  using the NC's built in terminal program. Some characters are dropped, could be 
+  synchronisation problems. XModem transfer not supported at this time. Implemented printer 
+  emulation: Documents can be printed now. [Kev Thacker]
+- [COCO 3] Basics of mid-frame video mode changing made.  Crystal City runs a bit better, 
+  but some timing is still probably off.  Hi-res text will now display the underline in the 
+  proper place when the lines per row is not 8.  Lo-res font now skewed one scanline, as 
+  was the original machine.  Fixed Composite Monitor colors.  [Nate Woods]
+- [COCO & COCO 3] Fixed the border colors when POKE 65314, [64-79;88-95] is invoked. 
+  [Nate Woods]
+- [ORIC] fixed a bug in microdisc memory paging. Some discs start to boot now.
+  Added a dipswitch to enable/disable microdisc interface [Kev Thacker]
+- [PC & compatibles] repartitioned, several problems fixed,
+  major rewrite of graphic subsytems (dirtybuffering disabled temporary),
+  Tandy 1000HX now uses EURO PC'S fontrom for acceptable displayment of its 8x9 characters,
+  EURO PC supports CGA and MDA/Hercules (adjust it in its emulated setup) [PeT]
+
+Other Changes:
+--------------
+
+- The core is based on MAME 0.37b9. This incorporates all 
+  features of the update to this core.  [MAME team] 
+
+- The M6847 interfaces were given a facelift, and now more correctly mimic the signals on 
+  the chip.  [Nate Woods]
+
+-------------------------------------------------------------------------------
+0.37b8 
+
+Several drivers may be broken due to the MAME memory handling changes.
+And as a result, the Amiga has been temporarily removed.
+
+Note: .inp record/playback does still not work currently.
+
+New System Drivers Supported (in no particular order):
+------------------------------------------------------
+- Chess Champion MK II [PeT]
+
+System Driver Changes:
+----------------------
+
+- [ATOM] Finished floppy disc emulation. To use it you require a rom using
+  the original 8271 memory locations (0x0a00-0x0a04). Linked in 6522via,
+  more programs should work with it. Added printer support. 
+  [Kev Thacker, Kees van Oss]
+
+- [BBC] Added a new BBC clone (BBCB1770) to use the WD1770 disc controller.
+  Much improved SAA5050 teletext support (mode 7), There is still a
+  problem with the Mode 7 cursor.
+  Added two new BBC clones they are BBCBP the BBC B Plus with 64K and
+  the BBCBP128 the BBC B plus with 128K.
+  Also Joystick support has now been added [Gordon Jefferyes]
+
+- [AMSTRAD CPC] Added support for printer. [Kev Thacker]
+
+- [GameBoy] Finally fixed the interrupt problem, which in turn helped a lot of carts 
+  actually run now. [Lee Ward] 
+
+- [Vectrex] Loading carts should work again. [Mathis Rosenhauer]
+
+- [ORIC] Rewrote to use 6522via code in MESS core. Previously it had it's own 
+  implementation which was not complete. Added floppy disc emulation (emulates a 
+  Microdisc interface). Added support for MFM_DISK disk image type as used by 
+  Euphoric. This driver uses the IO_CASSETTE device, and can be controlled with 
+  the "Tape Control" menu. However, this is not working yet.
+  Previous method for loading tapes has been disabled. Floppy disc emulation
+  does not appear to be working fully yet. [Kev Thacker]
+
+- [COCO/DRAGON] Added support for printer.  Optimized graphics emulation. [Nate
+  Woods]
+
+- [Studio II] added cartridge support [PeT]
+
+Other Changes:
+--------------
+- The core is based on MAME 0.37b8. This incorporates all 
+  features of the update to this core.  [MAME team] 
+
+- pure DOS mode crash fixed [Ben Bruscella]
+
+- SID6581 Approximation [PeT]
+  Interface changed,
+  partitioned, unused parts removed, cleaned up 
+  support for multiple chips finished
+
+- Imgtool now supports Virtual MSX Tape Archives (converts them to .cas files)
+  and imgtool can convert .cas to .wav files. [Sean Young]
+
+
+-------------------------------------------------------------------------------
+0.37b7 
+
+Note: .inp record/playback does still not work currently.
+
+New System Drivers Supported (in no particular order):
+------------------------------------------------------
+- Amstrad NC200 (preliminary) [Kev Thacker]
+- RCA Studio II [Peter Trauner]
+- Sharp Pocket Computer PC1251 [Peter Trauner]
+
+System Driver Changes:
+----------------------
+
+- [ATOM] Added preliminary floppy disc emulation. [Kev Thacker]
+
+- [BBC B] Updated to use updated 8271 FDC code. Disk images can be used and games
+  can be loaded and played. [Kev Thacker]
+ 
+- [BBC B] Cleaned up the memory accessing a little. This fixed a problem with
+  the DNFS rom thinking it found an econet controller. [Gordon Jefferyes]
+
+- [SAM COUPE] Updated Sam Coupe to use WD179x code (same as WD1772). [Kev Thacker]
+
+- [COCO] Updated CoCo and CoCo 3 drivers with new rom sets to match the actual chips 
+  in the system.  coco.rom split into bas12.rom, extbas11.rom and disk11.rom, and 
+  coco3.rom now must be of length 32768.  This requires a dump from an EPROM reader.  
+  Fixed a bug in cassette writing.  Cassette tape controls and CoCo motor signal now 
+  operate independently.  [Nate Woods]
+
+- [C16] added SIDCARD support at address $d400 [Peter Trauner]
+
+- [NES] new sound core. [Matt Conte]
+
+Other Changes:
+--------------
+- The core is based on MAME 0.37b7. This incorporates all 
+  features of the update to this core.  [MAME team] 
+
+- Fixed write protect reporting in WD179x [Kev Thacker]
+
+- Added "Disk Control" menu to the user interface. With this you can
+  enable/disable a drive (e.g. this is comparable to connecting a disconnecting
+  a drive to the real machine), set write enable/write protect of the disc,
+  and selecting between disc image and real drive access. Real drive access
+  is currently limited to the drivers which use the WD179x, NEC765 and Intel
+  8271 floppy disc controllers. [Kev Thacker]
+
+- Removed hard-coded disk image format in the WD179x code. This floppy
+  disc controller emulation uses the same disk image access as the NEC765 and
+  Intel 8271. It can now support different disk image formats, and as before
+  real discs in a real drive [Kev Thacker]
+
+- NEC765 and Intel 8271 can now use real disc access in DOS version
+  of MESS. Run under pure DOS, or in a Windows 95
+  DOS box mode for this to work correct. [Kev Thacker]
+
+- Imgtool now supports CoCo cassette files (both .CAS and .WAV).  This is done
+  through a framework that makes it easy to implement cassette images in
+  general.  Also, the CoCo RSDOS disk handling is now a bit more tolerant
+  [Nate Woods]
+
+- Updated Intel 8271 floppy disc controller emulation. [Kev Thacker]
+
+- CRC and sysinfo updates will now be appearing at the official MESS homepage:
+  http://mess.emuverse.com
+  Please send all CRC/sysinfo file contributions to Chris Henry. 
+  (battlepriest@hotmail.com).
+
+- M6510 cpu core added first write cycle for NMOS memory modifying instructions
+  [Peter Trauner]
+
+- CDP1802 cpu core [Peter Trauner]
+
+------------------------
+
+0.37b6 
+
+Note: DELETE mess.cfg!
+
+Note: .inp record/playback does still not work currently.
+
+
+New System Drivers Supported (in no particular order):
+------------------------------------------------------
+- Amstrad NC100 [Kev Thacker]
+- CoCo 3 (with a preliminary 6309 CPU core) [Tim Linder, Nate Woods]
+- SNES (preliminary) [Lee Hammerton]
+- ChannelF [Frank Palazzolo, Juergen Buchmueller]
+
+
+System Driver Changes:
+----------------------
+- SPECTRUM:  Fixed +3 disk handling [David Robertson]
+
+- COCO 3: Fixed low resolution video so that it is sensitive to the MMU; this
+  fixes a problem that made OS-9 Level 2 display garbage.  Also fixed two bugs
+  that prevented horizontal scrolling from working properly [Nate Woods]
+
+Other Changes:
+--------------
+- The core is based on MAME 0.37b6. This incorporates all 
+  features of the update to this core.  [MAME team] 
+
+- [DOS] File handling has CHANGED!  heres a brief description:
+  MESS supports a softwarepath= global setting (in the [directories] section of mess.cfg) 
+  and this is overrideable per driver (in the [driver] sections) Default for softwarepath= 
+  is .;SOFTWARE
+  OSD_FILETYPE_ROM uses the biospath= setting from now on (MAME rompath=) Default for 
+  biospath= is .;BIOS.
+  OSD_FILETYPE_IMAGE_R and _RW use the softwarepath= settings from now on, so BIOS ROMs can 
+  be kept separate from carts, floppy, harddisk etc. images.
+  The search paths/files are for a hypothetic system driver 'sys':
+  
+  extensions of carts for sys = .rom, .bin
+  softwarepath = .;x:/software
+
+  mess sys -cart cart
+
+  ./cart
+  ./sys/cart
+  ./cart.zip containing cart
+  ./sys/cart.zip containing cart
+  x:/software/cart
+  x:/software/sys/cart
+  x:/software/cart.zip containing cart
+  x:/software/sys/cart.zip containing cart
+  ---> assume it failed, because the real extension is .bin
+  ./cart.rom
+  ./sys/cart.rom
+  ./cart.zip containing cart.rom
+  ./sys/cart.zip containing cart.rom
+  x:/software/cart.rom
+  x:/software/sys/cart.rom
+  x:/software/cart.zip containing cart.rom
+  x:/software/sys/cart.zip containing cart.rom
+  ---> still not found, so image_fopen() tries .bin now
+  ./cart.bin
+  ./sys/cart.bin
+  ./cart.zip containing cart.bin
+  ./sys/cart.zip containing cart.bin
+  x:/software/cart.bin
+  x:/software/sys/cart.bin
+  x:/software/cart.zip containing cart.bin
+  x:/software/sys/cart.zip containing cart.bin
+
+  As you can see it might take quite some time until an image is found, with two 
+  directories on the path already, that's why the main softwarepath= setting should be 
+  short. If you have many, different drives/paths where you store software, you better use 
+  the system specific overrides like this:
+
+  [sys]
+  biospath=x:/sys
+  softwarepath=x:/sys
+  
+  [sys2]
+  biospath=roms
+  sofwarepath=z:/somewhere/sys2
+  
+  However, if you have a 'complete set' you would be done (mostly) if you only change the 
+  [directories] setting for biospath= and softwarepath= to the drive/path where your 
+  mirrored files are.
+
+  One extension to the searches that might make sense would be to also look into a 
+  path/ext/cart.ext directory, that means you could have subirectories for eg. dsk, cas, 
+  vz, bin or whatever the extensions of the system are. [Juergen Buchmueller, Ben Bruscella]
+
+- Many fixes to cheat engine [Cowering]
+
+- MESS CRC files now use 'Good' database CRCs where applicable [Cowering]
+
+- NES now gets correct mapper info from nes.crc (if present) [Cowering]
+
+- Genesis/Megadrive now gets correct CRC info for .smd and .md files [Cowering]
+
+- new function osd_select_file() added [Brad Oliver]
+
+- IMGTOOL: Fixed a bug that caused saving a file into an image to error if that
+  file was in a different directory.  Also fixed a bug that would cause crashes
+  when reporting certain types of errors [Nate Woods]
+
+- CRC and sysinfo updates will now be appearing at the official MESS homepage:
+  http://mess.emuverse.com
+  Please send all CRC/sysinfo file contributions to Chris Henry. 
+  (battlepriest@hotmail.com).
+
+
+
+------------------------
+0.37b5
+
+Note: .inp record/playback does still not work currently.
+
+
+New System Drivers Supported (in no particular order):
+------------------------------------------------------
+- NES (pal) [Brad Oliver]
+- Famicom [Brad Oliver]
+- Mattel Aquarius [Paul Daniels]
+- PCW8256, and many clones [Kev Thacker]
+- PCW16 [Kev Thacker]
+- PC 1512, PC1640 [Peter Trauner]
+- Microtan-65 [Juergen Buchmueller]
+- IBM PC [Peter Trauner]
+- TRS80 alt [Juergen Buchmueller]
+- Sharp Mz700, Mz700J [Juergen Buchmueller] 
+- Enterprise 128 (with EXOS 2.1) [Stefano Priore]
+- Some ZX Spectrum ROM mods, Spectrum 128 (Spain) [Stefano Priore]
+- Sharp PC1402, PC1350 [Peter Trauner]
+- Atari2600 (preliminary) [Lee Ward]
+
+
+System Driver Changes:
+----------------------
+- NES: Now features battery support and vastly improved PPU emulation - compare Kirby and 
+  RC Pro Am. 
+  * Palette is no longer hardcoded - it is mathematically generated. It may need some 
+    formulaic tweaking, but it's pretty accurate.  
+  * Games like GI Joe Atlantis Factor are working again, the NES Test cartridge no longer 
+    fails.  
+  * There is a compile switch to emulate the color intensity used in Chris Covell's "Wall" 
+    demo.  It's off by default because it requires 16-bit mode and the sprite blitters need 
+    rewriting to support 16-bit. Still, you can enable it to see the demo run as it was 
+    intended.  
+  * Many mapper fixes: mapper 18 irqs should be close, mapper 19 added, the mid-20 Konami 
+    mappers are nearly 100%, and some of the mappers in the 60's are much more accurate.  
+  * Super Mario 3  _finally_ works! Excitebike also works again, and elite and PAL games, 
+    Elite will draw properly -- but only using the PAL NES emulation.  
+  * Fixed some more timing errors, Bayou Billy sine wave looks perfect now. 
+  * low/high sprite priorities fixed. Super Mario 3 uses low priority sprites to mask out 
+    pieces of high priority ones.
+  * low-priority sprite/background transparency problem fixed (see Jaleco's Bases Loaded 3)
+  * Mapper 5 is much better, although some interrupt problems remain.
+  * Mappers 9/10 are _almost_ perfect.
+  * Fixed mapper 16 - it was completely wrong.
+  * Fixed rendering problems in mapper 68 (Afterburner 2).
+  * Fixed mapper 69 (Batman: Return of the Joker).
+  * Mapper 70 (arkanoid 2 j) works, but is it right? It starts up on round 0, which appears 
+    to be the last round and not the first.
+  * Implemented some Taito mappers (80, 82).
+  * Implemented Konami VRC7, minus OPL (mapper 85).
+  * Preliminary support for the zapper via a fake dipswitch. Collision detection isn't 
+    working yet.
+  * Modified sound core to read dpcm samples from the right place in memory. Added clock 
+    specifier and read/write callbacks for register $14. NES driver now hooks into this for 
+    sprite DMA. 
+  * Zapper support, configurable via the fake dipswitches. Most games look for it connected 
+    to the 2nd input port, not the first. Tested it with Duck Hunt and Hogan's Alley. If any 
+    other zapper games don't work, let me know and I'll beat them down.
+  * 4-player joypad support, also configurable via the fake dipswitches. For best results, 
+    set both ports to the double setting. I tested it in Gauntlet 2 and RC Pro Am 2. Again, 
+    let me know if it's busted in any other 4p games.
+  * Fixed sprite priorities for the last time. I swear it's really working now. ;-) As a 
+    side effect, the rendering code is a bit faster than before. 
+  * More mapper fixes/additions.  
+  * Added support for Famicom Disk System. Split up the main NES driver into NES and 
+    Famicom. Only the Famicom supports the disk system, because that's the way it is in 
+    real life. Press p1 button 3 to cycle amongst the disk sides. Once you switch a side, 
+    you may need to wait a second or two for the switch to be recognized. Let me know if 
+    any games fail to see the switch. Disk writing is not yet supported.
+  * Added preliminary support for the Arkanoid paddle. It's pretty busted at the moment.
+  * Fixed a small PPU bug regarding reads from the chr-gen ram portion of the ppu.
+  * Correct display of left-most column when it has been programmatically disabled - 
+    see SMB3.
+  * Added some more mappers, some of which aren't working fully.
+  * Fixed mapper 40 (SMB2j pirate) - it should be close to 100%
+  * Fixed some issues with the disk support. It now supports that stupid padded format with 
+    the useless header in addition to the other format.
+  * DPCM samples fixed (now hear SMB3 in all it's steel drum glory).
+    [Brad Oliver]
+
+- COCO: Now using schedule_full_refresh() and PAK loader fixes applied [Nate Woods]
+
+- KAYPRO: Keyboard fixed [Juergen Buchmueller]
+
+- PCW16: emulation is fully working. To run this you need the "OS rescue disk". The system 
+  rom is contained on the OS rescue disc and you will need this to install the OS. This 
+  disc is available on the net, do a search to find it. [Kev Thacker]
+
+- PC: improved PC-AT keyboard emulation to work with PCW16. Should work better with PC 
+  emulation too.  Improved PC-Serial Mouse emulation to work with PCW16, improved PC FDC 
+  emulation to work with PCW16. FDC now works as before but uses same nec765 code as the 
+  Amstrad and Spectrum drivers. More software that programs the FDC directly should work.
+  Changed PIO code in PC-XT to use 8255 emulation. Seperated PC-LPT code to be used with 
+  PCW16. seperated and improved PC-Serial code. Works with PCW16 now, and interrupts are 
+  set/cleared correctly. seperated pc floppy disc handling code for use with PCW16.
+  Fixed tandy1000 problem, pc's changed to use pckeybrd, split pc_cga, pc_mda, pc_t1t from 
+  pc and fixed atcga, xtvga init/blink problems.  changed uart8250 and pc_mouse interface, 
+  realtime clock fixes and improvements (starts with current time) better vga retrace 
+  emulation, fixed mouse problem in pc's (was a simple inputport configuration problem)
+  [Kev Thacker, Peter Trauner]
+
+- SPECTRUM: The border displaying code is now includes a full refresh flag. 128K port 
+  decoding updated (still not exact on +3) - Sound now works on Zub 128K.
+  [David Robertson]
+
+- A7800: TIA sound update, which replaced the fixed/rand() polynome initializations to 
+  ones based on the same algorithms that are used in the Pokey driver.
+  [Juergen Buchmueller]
+
+- TRS80: Split the ROMs into the 4K sizes they originally had 
+  trs80.rom -> trs80.z33, trs80.z34 and trs80.zl2
+  sys80.rom -> sys80rom.1 sys80rom.2 and sys80rom.3
+  added an trs80alt driver for the 'R/S L2 BASIC' (its an original ROM with a shorter 
+  bootstrap message and some code modifications). IO_CASSETTE now only loads *.cas files in 
+  SYSTEM format and IO_QUICKLOAD is used for files in *.cmd format (disk excerpts)
+  [Juergen Buchmueller]
+
+- Commodore: m65ce02/m4510 timing corrected, fixed rtn, plp, rti, eom, added m65ce02 aug
+  c65 speed improvements, ega/vga speed improvements [Peter Trauner]
+
+- AMSTRAD: Changed video hardware code to use 6845 CRTC code.  Also added Eventlist code to 
+  the Amstrad video hardware code. It will record colour changes, mode changes and crtc 
+  register writes.  This means support for multi-modes on the same screen, colour changing 
+  effects, and demos. There is a second method which updates between I/O writes that
+  would affect the screen. The rendering method can be chosen with a compile switch.
+  Also added correct opcode timings for Amstrad using new cpu_setcycletable, this
+  means raster effects are now correct. Also added emulation of the Multiface hardware.
+  It requires a rom (optionally loaded). You must enable it in the dipswitches. When
+  enabled F1 will be the "stop" button. [Kev Thacker]
+
+- ZX: Fixed ZX80 palette: it's black on white, and not viceversa. [Stefano Priore]
+
+- CoCo/Dragon: Fixed a bug the CoCo 3 horizontal scroll so Crystal City is partially 
+  playable now, converted the CoCo/Dragon driver to use an include file, moved PAK loading 
+  code into a new src/mess/formats directory [Nate Woods]
+
+- PDP/1: Fixed a null pointer access if no image is loaded. [Nate Woods]
+
+- PC1401/1402/1350: Artwork support added [Peter Trauner]
+
+- PCW: Added sound emulation. [Kev Thacker]
+
+- PCW/CPC/SPECTRUM: Fixed some bugs in the disk image handling code used in
+the Amstrad CPC, Amstrad PCW, and Spectrum+3 drivers [Kev Thacker]
+
+
+Other Changes:
+--------------
+- The core is based on MAME 0.37b5. This incorporates all 
+  features of the update to this core.  [MAME team] 
+
+- NEC765: improved and more commands added, supports DMA access. Can handle
+  images with copyprotection. A lot more software should now run on the 
+  systems that use it (PCW,Spectrum, Amstrad,PC and PCW16). [Kev Thacker]
+
+- 6522via Bug fix [Gordon Jefferyes]
+
+- Optional ROM support. It can be used in MESS for BIOS ROMs for peripherals for which 
+  you'd like to provide a valid crc32 without requiring the ROM. [Brad Oliver]
+
+- Imgtool: Added a CRC command to imgtool so output image information in .crc format 
+  basename()'s the command name when printing error info, Fixed a typo in the usage 
+  examples, added a very rough imgtool.txt to document imgtool [Nate Woods]
+
+- Added new endian macros [Nate Woods]
+
+- DeviceIO bug fixed for most drivers [Juergen Buchmueller]
+
+- CRC and sysinfo updates will now be appearing at the official MESS homepage:
+  http://mess.emuverse.com
+  Please send all CRC/sysinfo file contributions to Chris Henry. 
+  (battlepriest@hotmail.com).
+
+
+
+
+
+
+------------------------------
+
+0.37b4
+
+Note: .inp record/playback does still not work currently.
+
+
+New System Drivers Supported (in no particular order):
+------------------------------------------------------
+Mac 512ke [Raphael Nabet]
+BBC a&b (rename BBC) [Gordon Jefferyes, Kev Thacker]
+Sharp Pocket Computer (prelim) [Peter Trauner]
+Lisa2 [Raphael Nabet]
+heaps of c65 variants [Peter Trauner]
+XTVGA, ATCGA (prelim) [Peter Trauner]
+
+
+System Driver Changes:
+----------------------
+- MACPLUS: Keyboard support added.  Variable memory configurations used now (a variable 
+  named ram_size which can be initializzed to any value), and added variable ROM size, too.  
+  Updated iwm.c to support Apple Diskcopy format : this will allow to exchange data with 
+  real-world macintosh, and to use images from Mac sites.
+  Fixed the RTC, and added a feature which initializes the Macintosh clock with the current 
+  date and time.  Fixed some cosmetic sound core issues. [Raphael Nabet]
+
+- SPECTRUM: Added support for .SCR (Screendump) files. Note that to ensure that the
+  image is not immediately overwritten by the ROM initialisation routine the
+  loading routine adds a short machine code press any key routine.  The Border engine 
+  code now only uses those events with the correct ID
+  instead of all events.  The specpls4 has been is now declared as GAME_COMPUTER_MODIFIED 
+  .SCR files are now quickload files and are loaded by pressing F8.  The 128K machines are 
+  now defined as GAME_NOT_WORKING because of the crashes when running 128K files.
+  [David (aka Peter) Robertson]
+
+- CoCo3: Now supports LPR field on INIT1 GIME register when in graphics modes, 
+  fixed a bug that prevented video updates in hires 4-color modes. 
+  Fixed high speed timer to have the correct speed.  Subtle tweaks to interrupt handling.  
+  Special thanks to John Kowalski for info. [Nate Woods]
+
+- CoCo/Dragon: Now supports memory size SAM register, removed 2nd fire button from 
+  joysticks (only CoCo 3 has this). Video display now draws border. [Nate Woods]
+
+- CoCo/CoCo3/Dragon: Optimized screen refresh routines accross the entire family.  
+  Routing cassette audio to the speaker (AUDIO ON command in basic) now supported.  
+  Documented more references about the CoCo hardware, as well as added docs for hardware 
+  enhancements not supported yet. Interrupt timings now relative to clock cycles for more 
+  exact timing.  Also, much more documentation. [Nate Woods]
+
+- UK101/Superboard: Tidy up palette code, Caps lock implemented properly, Memory config. 
+  4K, 8K and 40K. Added MC6850 ACIA. Cleaned up keyboard port_bits, Tape load.
+  Hand crafted a superboard II graphics rom. Source YC July 82.  Swapped monitors roms, 
+  wrong way around. Superboard video is 64 by 16 Max. UK101 video is 32 by 25 Max.
+  To load tape images from Basic, type "LOAD", wait for the program to load, press space, 
+  then RUN, LIST, etc. Some images should be loaded from the monitor, asteroids, 
+  asteroids+ and scramble. When in the monitor, press L and wait for the program to load 
+  and run. [Paul Daniels]
+
+- NASCOM: Tidy up palette code. Nascom1 tape load. Memory config. 1Kb, 16Kb, 32Kb, 40Kb at 
+  1000.  Test all known software. .cas done. .bin done. .nas done. Cleaned up keyboard 
+  port_bits. [Paul Daniels]
+
+- Apple1: Cleaned up code. Tidied up colour palette. Added memory configs. [Paul Daniels]
+
+- Jupiter ace: Tidied up colour palette. Added memory configs. [Paul Daniels]
+
+- BBC: The Hi-Res video modes have been improved with  full 6845 CRTC emulation, and 
+  preliminary Teletext support has now been added. [Gordon Jefferyes]
+
+- CBM: added c128 resolution switching, added c65 resolution switching, interlace support
+  renamed c65 system to c65e, changed c64gs to pal. [Peter Trauner]
+
+- PC: added vga resolution switching [Peter Trauner]
+
+
+
+Other Changes:
+--------------
+
+- The core is based on MAME 0.37b4. This incorporates all 
+  features of the update to this core.  [MAME team] 
+
+- TOOLS: Created an "osdtools.h" file that implements cross platform defininitions for 
+  the tools (dat2html, imgtool, etc) [Nate Woods]
+  added a info function (info is showed before the file listing in the dir command), added 
+  extract command to allow conversion between file formats with create and extract 
+  functions, added stream_clear to clear files (fopen(...,"w+")), added some parameters to 
+  the create and put commands, c64crt c64 cartridge file support, more for professional 
+  use (c64 cartridge dumper) and t64 c64 tape format support. [Peter Trauner]
+
+- Implemented a new palette in tms9928a, computed from TI datasheet.  [Raphael Nabet]
+
+- Cassette/wave code: Adds the ability to mute the cassette audio output.  This is done 
+  by setting bit 1 of the device status.  [Nate Woods]
+
+- SC61860 CPU core [Peter Trauner]
+
+- Fixed CLR bug in m6809 core [Nate Woods]
+
+- Using the C 68k core. Macplus now works.
+
+- Extensive CRC updates.
+  [Chris Henry, Stefano Priore, Cowering]
+  SysInfo.dat documentation update 
+  [Chris Henry]
+  Please send all CRC/sysinfo file contributions to Chris Henry. 
+  (battlepriest@hotmail.com).
+
+
+
+---------------------
+0.37b3
+
+Note: .inp record/playback does still not work currently.
+
+
+New System Drivers Supported (in no particular order):
+------------------------------------------------------
+Spectrum +2 (France) [David Robertson]
+Spectrum +2 (Spain) [David Robertson]
+Spectrum +3 (Spain) [David Robertson]
+BBC Micro Model B (preliminary) [Gordon Jefferyes]
+Vic20 with IEEE488 interface cartridge [Peter Trauner]
+PCW [Kev Thacker]
+
+
+System Driver Changes:
+----------------------
+- VECTREX: Support for true color artwork added [Mathis Rosenhauer]
+
+- SPECTRUM: .TAP loading on TS2068 now works, and fixed bug where the last byte 
+  in .Z80 blocks was not decoded - Head Over Heels now works. 
+  .TAP files now classified as cassettes files not snapshots because of how they are 
+  used - this now means they appear on Tape Control menu, corrected clock speed of 
+  TS2068, fixed Issue 2/3 dipswitch implementation, dipswitch to enable/disable disk 
+  drives on +3 and clones (disabling disk drives on +3 correctly shows machine as +2a 
+  on start up menu). implemented TS2068/TC2048 64 column and hires modes, rewrote 
+  Spectrum 128 screen refresh to use plot_pixel for a major speedup. 
+  Fixed bug that created a new file if trying to use a non-existant .TAP file, modified 
+  border size based on the comp.sys.sinclair FAQ (48 pixels at the left, right and top 
+  and 56 pixels at the bottom of the screen, initial support for border colour - fills 
+  entire border with last the outputted colour, border colour set when loading snapshots.
+  Added a Border Engine to all Spectrum machines. [David Robertson]
+
+- C65: added m4510 core, memory management changed and keyboard finished, DMA 
+  controller enhanced, quickloader fixed, added floppy simulation for devices 10,11, 
+  very early support of special c65/vic3 videomodes, (on the funet disks are only some 
+  graphic demos, works when you change disk access (bload, loadiff) to:
+  bload "name",u10
+  loadiff "name",u10
+  (load with dload"name",u10 or load"name",10)
+  (and change the names to 8 letters in msdos.  [Peter Trauner]
+
+- C16: emulated flashing mode of the TED chip, activated and fixed blinking. 
+  Disabled blinking in multicolor modes (winter edition) [Peter Trauner]
+
+- PC series: Changed osd_modify_pen calls to palette_change_color.  Emulation of the 
+  EGA/VGA palette registers in tandy1000 video driver, vga palette management fix,
+  changed drivername to t1000hx (rename your romset from tandy1t), added eeprom 
+  support (fixes disk support), added turboswitch functionality, changed frequency 
+  to 8 MHz, removed some dipswitches.  [Peter Trauner]
+
+- CoCo/Dragon/MC-10: Better .CAS file support, now supports cassette writes, 
+  slightly better .PAK file support. [Nate Woods]
+
+- CoCo: Now uses the standard wd179x code.  As a result, src/mess/machine/cocodisk.c 
+  is not necessary anymore, implemented 63.5usec horizontal sync interrupt 
+  (Dragon/CoCo/CoCo 3), implemented secondary fire buttons for both joysticks 
+  (Dragon/CoCo/CoCo 3), keyboard interrupt (CoCo 3). [Nate Woods]
+
+- CBM: cbm floppy drive simulation names for file system access changed, floppy disk 
+  simulation for pet series (not working with first pet and superpet), added 8096 memory 
+  expansion to cbm80 series, and cartridge/rom support in pet and cbmb series.
+  [Peter Trauner]
+
+- MTX: Cassette support can now handle multiple files in the same image, and country cde 
+  (CTYLST) Dipswitches now implemented. [Lee Ward]
+
+- Updated Amstrad and Enterprise driver with correct aspect ratio, updates to the KC85/4 
+  driver including code to emulate the keyboard - works by poking OS system variables.
+  [Kev Thacker]
+
+
+Other Changes:
+--------------
+
+- The core is based on MAME 0.37b3. This incorporates all 
+  features of the update to this core.  [MAME team] 
+
+- Bug fix in wd179x controller [Nate Woods]
+
+- Bug fix in the wave handler (when image is closed, osd_fclose() is now called 
+  on the file descriptor [Nate Woods]
+
+- Bug fix in the tape control that cause the control to give percentage erros when 
+  using *.cas files. [Nate Woods]
+
+- ImgTool: Preliminary PC Hard drive driver, better error reporting, a new command 
+  ('good') that functions as a rom sorter (a la GoodNes).  CRC information is retrieved 
+  from the standard MESS CRC files, the 'crc' command is replaced with 'info'.  This new 
+  command will return data regarding the image if MESS's CRC files are aware of the 
+  image. dir and del now can take multiple arguments. [Nate Woods]
+
+- Extensive CRC updates.
+  [Kurunir, Chris Henry]
+  SysInfo.dat documentation update 
+  [Chris Henry]
+  Please send all CRC/sysinfo file contributions to Chris Henry. 
+  (battlepriest@hotmail.com).
+
+
+
+----------------------------------------------------------------
+0.37b2
+
+Note: .inp record/playback does still not work currently.
+
+
+New System Drivers Supported (in no particular order):
+------------------------------------------------------
+
+Spectrum +4 (48K) [David Robertson]
+Inves Spectrum 48K+ [David Robertson]
+TK90x Color Computer [David Robertson]
+TK95 Color Computer [David Robertson]
+Timex Computer 2048 [David Robertson]
+Timex-Sinclair 2068 [David Robertson]
+Spectrum +2 [David Robertson]
+C128 Italian [Peter Trauner]
+Vic64s (c64 swedish version/or c64 with swedish expansion kit) [Peter Trauner]
+Vic20swe (vic20 with swedish expansion kit) [Peter Trauner]
+Cbm40pal, Cbm80pal, superpet [Peter Trauner]
+Nascom2 [Paul Daniels]
+Memotech MTX512 [Lee Ward]
+Acorn Atom (preliminary) [Paul Daniels]
+Sam Coupe (preliminary) [Lee Hammerton]
+
+
+System Driver Changes:
+----------------------
+- PC: Mouse now very usable, PC CGA scrolling support in 320x200x2 fixed 
+  (Boulderdash), Tandy1000 Graphics memory switching enchanced (Lemmings), 
+  Joystick changes (slow autocenter remaining), added xtcga with mf2 keyboard 
+  and turbo switch, split the xtvga in xtega (vga with ega monitor), and added 
+  palette handling to ega/vga. [Peter Trauner]
+
+- C364: preliminary speech added (similar hardware in the C64 
+  cartridge Magic Voice, used in few programs). [Peter Trauner]
+
+- C128: Esc-x to switch c128 to 40 column mode. Keypad enter to switch 
+  emulator to 40 column mode. In the input keys configuration menu you 
+  should find several key assignments with normal (not reversed)T.  Change 
+  these to another key, and the normal T will work. (in the system file
+  these keys are disabled, until I find a better solution) [Peter Trauner]
+
+- MACPLUS: driver boots (must use the 68k C core) [Nate Woods]
+
+- SEGA MASTER SYSTEM: Rewrite of the SMS video code, so quite a lot of games with
+  interrupt problems or corrupt graphics run fine now. [Charles MacDonald]
+
+- SPECTRUM: Added support for 128K .SNA and .Z80 files, ensured that the 48K Basic 
+  ROM is paged in when running 48K snapshots on 128K machine (for improved 
+  reliability and access to the default character set), changed +3 initialisation, 
+  128 and +3 now set 0x4000-0x7fff to bank 5 (Now not changed if switching to shadow 
+  screen), cleaned up spectrum_plus3_update_memory, fixed bug in decoding uncompressed 
+  v2+ .Z80 files, and changed running speed of 128K Machines to 3.54690MHz
+  [David Robertson]
+
+- COMMODORE: cbmdrive (memory freeing) fixed, cia6526 tod fix, c128fra fix, 
+  50 hertz machines now really have 50 hz video refresh, c16 1551 simulation fixed 
+  [Peter Trauner]
+
+- DRAGON series: Now supports a new variant of the .PAK file format for snapshots.
+  [Nate Woods]
+
+- TI99:  Mini Memory Support (rename minimemc.bin to minimemm.bin for it to 
+  work correctly), fixed a bug in banked roms when a hard reset (F3) is done, rom 
+  images are now identified by their filename extensions (image order isn't important 
+  anymore), no need to use NUL when no grom image, both alt -> fctn and both ctrl -> ctrl 
+  added, and new rom image extensions (.c .d .m .g .crom. drom. mrom .grom).
+  [Norberto Alfredo Bensa]
+
+- A7800: Support for bankswitched carts and carts with extra RAM, added 160B video mode, 
+  increased screen height to fix clipping at bottom, updated header format (details can be 
+  found in machine/a7800.c), added support for light gun trigger (not the light gun 
+  targetting yet, just the trigger), and removed requirment for a cartridge (since the 7800 
+  starts in the BIOS it doesn't technically need a cartridge) [Dan Boris]
+
+
+
+
+Other Changes:
+--------------
+
+- The core is based on MAME 0.37b2. This incorporates all
+  features of the update to this core.  [MAME team] 
+
+- TOOLS: Disk Utility added (mkhdimg.exe) which will create variable sized HD images 
+  for use in MESS.  Can create images from 9,216 bytes to 142,606,848 bytes 
+  without problems.  The Western Digital 1004A that is emulated in MESS is 
+  limited to 1024 Cylinders and 16 heads. The sector size is limited to 512 
+  bytes as well as the sectors per track being limited to 17, this is also 
+  due to the WD1004A's limitations. [Randy Rains]
+
+- TOOLS: Generic image tool added (imgtool.exe) with the following features:
+  *MAME/MESS style driver architecture; where the image formats are contained in drivers.  
+   Currently, the only driver is for CoCo .DSK disk images, but there could be more.
+  *Runs on the command line.
+  *Commands for listing image contents, retrieving and storing files.
+  *Supports images in .ZIP files.
+  *"Engine" is separate from the "shell"; which gives the potential for front ends for 
+   those who don't like command lines. [Nate Woods]
+
+- Disk write support for AMSTRAD CPC [Oscar Martn Gonzlez]
+
+- Wave timer fix [Oscar Martn Gonzlez]
+
+- m6510t/m7501/m8502 CPU cores added [Peter Trauner]
+
+- Extensive CRC updates.
+  [Kurunir, Chris Henry]
+  SysInfo.dat documentation update 
+  [Chris Henry]
+  Please send all CRC/sysinfo file contributions to Chris Henry.
+  (battlepriest@hotmail.com).
+
+
+
+
+
+----------------------------------------------------------
+
+0.37b1
+
+Note: .inp record/playback does still not work currently.
+
+
+New System Drivers Supported (in no particular order):
+------------------------------------------------------
+ZX Spectrum 128	   [David Roberson]
+ZX Spectrum 128 +2 [David Roberson]
+
+
+System Driver Changes:
+----------------------
+- PC Mouse now very usable. [Peter Trauner]
+
+- COCO/DRAGON now supports two distinct joysticks. [Nate Woods]
+
+- SPECTRUM: Fixed .TAP loading for Spectrum +3, added Dipswitch for action
+  on end of tape, and snapshot files are now classifed as snapshots not
+  cartridges [David Robertson]
+
+- MSX: added a detection routine which can detect most types of megaROMs.
+  [Sean Young]
+
+- VTECH: driver update to use V1.2 BASIC ROMs with the Laser 110, 200 and
+  Texet 8000. [Juergen Buchmueller]
+
+
+
+Other Changes:
+--------------
+
+- The core is based on MAME 0.37b1. This incorporates all
+  features of the update to this core.  [MAME team]
+
+- Alias bug fix [Norberto Alfredo Bensa]
+
+- Systems with no ROMS but a ROM_REGION defined (eg Genesis, NES) are now
+  correctly identified.  Clones with no differing roms from the main set
+  are correctly identified (eg. the Laser 210 clones etc.)
+  [David Robertson]
+
+- Extensive CRC updates.
+  [Sean Young, Chris Henry, Gerardo Jorrin, Peter Trauner, Cowering]
+  SysInfo.dat documentation update
+  [Thierry Schimbi, Chris Henry, Kev Thacker, Raphael Nabet]
+  Please send all CRC/sysinfo file contributions to Chris Henry.
+  (battlepriest@hotmail.com).
+
+
+
+----------------------------------------------------------
+0.36
+
+Note1: MESS is now developed and distributed as a MAME source
+override, hence the MESS version number leap ;-)
+Note2: .inp record/playback does still not work currently.
+
+
+New System Drivers Supported (in no particular order):
+------------------------------------------------------
+Vectrex  [Mathis Rosenhauer, Chris Salomon]
+Atari 800/5200  [Juergen Buchmueller]
+Apple II Family  [Mike Balfour, Brad Oliver]
+PDP/1  [Chris Salomon]
+Sega Master System  [Mathis Rosenhauer, Brad Oliver]
+Sega GameGear  [Mathis Rosenhauer, Brad Oliver]
+Kaypro CP/M  [Juergen Buchmueller, Benjamin C. W. Sittler]
+Bally Astrocade  [Frank Palazzolo]
+Amstrad CPC  [Kevin Thacker]
+Atari 7800  [Dan Boris]
+Commodore Amiga  [Ernesto Corvi]
+Dragon 32  [Mathis Rosenhauer]
+EACA Colour Genie 2000  [Mathis Rosenhauer]
+Enterprise 128K  [Kevin Thacker]
+KC Compact  [Kevin Thacker]
+PC-Engine / Turbo Graphics-16  [Charles Mac Donald]
+PC-compatible (MDA, CGA)  [Juergen Buchmueller]
+RA+A Spectrum I+  [Mathis Rosenhauer]
+TI-994a  [Raphael Nabet]
+ZX-Spectrum 48k  [Allard van der Bas]
+KIM 1  [Juergen Buchmueller]
+Tandy 1000TX (PC clone)  [Juergen Buchmueller]
+Coco 3  [Nate Woods]
+ORIC 1  [Paul Cook]
+ORIC Atmos  [Paul Cook]
+Vic20 (NTSC)  [Peter Trauner]
+Vc20 (Vic20 Pal)  [Peter Trauner]
+Commodore 16  [Peter Trauner]
+Commodore Plus4 NTSC  [Peter Trauner]
+VZ 200  [Juergen Buchmueller]
+VZ 300  [Juergen Buchmueller]
+MSX  [Sean Young]
+GameBoy (preliminary)  [Carsten Sorensen, Marat Fayzullin,
+                       Pascal Felber, Hans de Goede,
+                       Juergen Buchmueller]
+TI99_4 (not working)  [Raphael Nabet]
+CP400  [Nate Woods]
+AdventureVision  [Dan Boris]
+Commodore64(NTSC&pal), Max  [Peter Trauner]
+Apple1, Nascom1  [Paul Danials]
+MicroBee (32,56k)  [Juergen Buchmueller]
+zx80, zx81, ts1000, aszmic, pc8300, pow3000
+  [Juergen Buchmueller]
+laser 110, 210, 200, 310, 350, 500, 700, tx8000
+  [Juergen Buchmueller]
+cpc464, cpc664  [Kev Thacker]
+kc85_4 (preliminary)  [Kev Thacker]
+a400, a400pal (16K RAM only)  [Juergen Buchmueller]
+spectrum plus3  [Kev Thacker]
+a800pal  [Juergen Buchmueller]
+sys80  [Juergen Buchmueller]
+c364, c64gs  [Peter Trauner]
+ti99_4e, ti99_4ae  [Raphael Nabet]
+Atari800xl (not working)  [Juergen Buchmueller]
+Philips P2000t/m  [Paul Daniels]
+Tandy MC-10  [Nate Woods]
+Uk101, SuperBoard (Note: have SHIFT pressed when typing)
+  [Paul Daniels]
+MSX Japanese and Korean  [Sean Young]
+Commodore 65  [Peter Trauner]
+Commodore 128  [Peter Trauner]
+Commodore PET2000/CBM2000  [Peter Trauner]
+Commodore CBM3000  [Peter Trauner]
+Commodore CBM4000  [Peter Trauner]
+Commodore CBM8000  [Peter Trauner]
+MacIntosh Plus  [Nate Woods, Ernesto Corvi]
+CPS Changer - Street Fighter Zero  [MAME team]
+Commodore B series  [Peter Trauner]
+MSX1 UK  [Sean Young]
+C16 (c1551)  [Peter Trauner]
+Plus4 (c1551)  [Peter Trauner]
+
+
+System Driver Changes:
+----------------------
+- Apple2 driver keyboard fix 	 [Juergen Buchmueller]
+
+- Apple2 driver changed to use 'normalized' character and graphics
+  layout.  The scanlines are now done by the hosts video code.
+  [Juergen Buchmueller]
+
+- ColecoVision Video refresh fixed. [Sean Young]
+
+- Adjusted timing of NES clock to be accurate. [Brad Oliver]
+
+- Preliminary Mockingboard support for the Apple II. [Brad Oliver]
+
+- Genesis sound improvements. [Gareth Long]
+
+- Several drivers have had compatibility improved (eg. NES, Genesis and Coleco)
+
+- The Apple II drivers have been fleshed out a little more. The //e
+  family now works. The disk emulation is significantly faster as well.
+  There is still plenty of work to be done though. [Brad Oliver]
+
+- Bug fixes to the TI9928a video code. This affects the ColecoVision and the
+  TI-994a drivers. [Raphael Nabet, Sean Young]
+
+- NES psg frequency is now correct. [Brad Oliver]
+
+- Genesis now features preliminary FM sound. [Gareth Long, Tatsuyuki Satoh]
+
+- Increased Genesis compatibility. [Gareth Long]
+
+- Memory allocation fix in the NES driver [Juergen Buchmueller]
+
+- Commodore SID emulation!  [Peter Trauner]
+
+
+Other Changes:
+--------------
+
+- [DOS] Images specified at the command line must now be accompanied by the device they
+  are to be attached to, and will not be loaded unless the device is specified *and*
+  supported by that system.  Eg, to attach a cartridge for the NES, you must specify:
+  MESS nes -cart galaga.nes
+  This may affect the usage of frontends, however it brings the MESS command line
+  into sync with the well accepted MAME convention for command line usage.  See mess.txt
+  for options and usage.
+
+- Added support to automagically append or replace extensions for files
+  opened with image_fopen(), which means, if opening a given filename
+  fails (also from the optional clone_of parent driver), the code replaces
+  or appends the next available extension and tries again.   Therefore, there
+  is no need to actually supply the file extension to the command line.
+  [Juergen Buchmueller]
+
+- The core is based on MAME 0.36 final. This incorporates all
+  features of the update to this core.  [MAME team]
+
+- New option -listdevices. Use this to obtain valid device names for use at the command
+  line to attach images to the system.
+
+- Extensive CRC updates.
+  [Sean Young, Chris Henry, Gerardo Jorrin, Peter Trauner, Cowering]
+  SysInfo.dat documentation update
+  [Thierry Schimbi, Chris Henry, Kev Thacker, Raphael Nabet]
+  Please send all CRC/sysinfo file contributions to Chris Henry.
+  (battlepriest@hotmail.com).
+
+- Small bug in the 6522 emulator fixed. [Gordon Jefferyes]
+
+- Important inclusions for this release:
+  *wave sound interface and IODevice handler
+  *speaker sound driver (replaces the buzzer code)
+  *preliminary file manager
+  *mess_printf() which checks for gui_host
+  Check the UI (TAB) for handling options for most of the above.
+
+- Generic M6847 code  [Nate Woods]
+
+- Wd179x disk access update.  The correct sector size is now
+  calculated for the nec765 real FDD access.  Now it is calculated
+  from sector size. Loading from real disc works on Enterprise
+  emulator.  [Kev Thacker]
+
+- void via_set_clock(int which,int clock); added to 6522via.c.  This
+  can be called after via_config() to change the clock, otherwise the
+  clock speed of CPU1 is used. [Mathis Rosenhauer]
+
+- mess/msdos.c & mess/msdos.h created for MESS DOS specific functions.
+  Note: Each port is now responsible for handling these functions.
+
+
+- GAME_ALIAS flag added.  Use this when specifying a clone system
+  which requires the same romset as another. [Juergen Buchmueller]
+
+- System documentation is now contained in sysinfo.dat and
+  sysinfo.htm.  Use dat2html to generate sysinfo.htm from sysinfo.dat
+  [Chris Henry, Juergen Buchmueller, Ben Bruscella]
+
+- You can now specify switches on the commandline in which case every
+  image name following them goes to that respective slot, regardless
+  of it's extension.  See mess.txt for some examples
+  [Peter Trauner, Juergen Buchmueller]
+
+- [DOS] New options for IMAGES to be opened, namely OSD_FOPEN_READ,
+  OSD_FOPEN_WRITE, OSD_FOPEN_RW, and OSD_FOPEN_RW_CREATE.  Check
+  mess.h for a description of what they are used for.  Be sure to use
+  these semantics when handling read/write files.
+  [Juergen Buchmueller]
+- slight changes to the PDP1 driver.
+
+- [DOS] TI99 keyboard fix! [Raphael Nabet]
+
+- System ROM (Image) name matched from CRC database file on startup.
+  (file stored in CRC directory)
+
+- You can now specify in MESS.CFG the *exact* directory a rom is
+  which you want to run.  no longer necessray to have a directory with
+  the same name as the system [Juergen Buchmueller]
+
+- Zipped cart and image support added. To use, make sure that the zip has the
+  same name as the file in the zip. (eg) for a coleco CART called
+  "venture.rom", zip to "venture.zip".  When running MESS, type "mess coleco
+  venture.rom".  MESS will then load "venture.rom" from "venture.zip".  Any
+  system roms can also be zipped and placed anywhere in you ROMPATH. (eg)
+  coleco.rom in coleco.zip.
+  [Ben Bruscella]
+
+- GAME_COMPUTER flag added.  Use this to specify that the system requires
+  full keyboard emulation.  Emulated Computer systems now use the
+  scroll_lock key to toggle the keyboard emulation.  When on, MAME keys
+  (such as "P" for pause) are disabled, until toggled with the scroll_lock.
+  [Juergen Buchmueller]
+
+
+- [DOS] MAKEFILE/compilation changes. To compile MESS, simply make sure you
+  can compile MAME. Then, apply the MESS source over-ride and:
+
+   1. Rename MAKEFILE to MAKEFILE.mm
+   2. Rename MAKEFILE.MES MAKEFILE
+   3. Type MAKE
+
+
+- There have been major changes to the Driver structures and loading procedure.
+
+*Here is an overview:
+
+* Every game driver's struct GameDriver (src/mess/systems/*.c) is now
+defined using one of four macros COMP/COMPX or CONS/CONSX.
+COMP is for computers and CONS is for consoles. The X versions allow
+specifying additional flags (GAME_NOT_WORKING ect.)
+
+* Every game driver specifies it's peripherals in an array of
+"struct IODevice" elements.
+
+* rom_load and rom_id fields were moved into that list, together with
+the number of devices and the known file extensions for images of that
+type.
+
+* MAME's src/driver.h now only contains one pointer to this list of
+devices, all of MESS' extra fields are gone.
+Old:
+#ifdef MESS
+    int (*rom_load)(void);
+    int (*rom_id)(const char *name, const char *gamename);
+    const char **file_extension;
+    int num_of_rom_slots;
+    int num_of_floppy_drives;
+    int num_of_hard_drives;
+    int num_of_cassette_drives;
+#endif
+
+New:
+#ifdef MESS
+    const struct IODevice *dev;
+#endif
+
+
+* The global rom_name[], floppy_name[], hard_name[] and cassette_name[]
+arrays are gone! Instead each machine driver (src/mess/systems/*.c)
+should specify an init function for every device it supports.
+This init function is called during the startup with an id (0 to max
+instances of the device - 1) and a filename.
+
+* rom_load is called very early when a driver is started.
+It is the 'init' function for the device type IO_CARTSLOT, so the
+previous statement applies here too.
+
+* the rom_id function pointer moved into the struct IODevice too.
+Every device can have a id function, so if it is possible to identify
+eg. a floppy disk, harddisk, cassette ect., you should provide the
+identifying functions and put them in this field in your systems/driver code.
+The id function return value is sort of TRUE/FALSE, ie. non zero
+means image is ok for this device, zero is not recognized.
+
+* The IODevice contains an "void (*exit)(int id);" entry, so each
+driver could (and probably should) handle shutting down the various
+device instances.
+The exit entries are called from src/mess/mess.c exit_devices(),
+which is called from src/mame.c shutdown_machine().
+
+* Startup handling moved from src/mame.c to src/mess/mess.c
+In the first stage load_image() is called.
+The images specified on the command line are parsed in mess.c now, and
+a list of "struct ImageFile" entries in the GameOptions is set.
+This struct contains a "char *name" and an "int type", where type should
+be set to one of the IO_CARTSLOT, IO_FLOPPY ect. values.
+GUI ports could use this to store some file selection lists together with
+the type of files selected.
+The DOS port stores image names from the command line (*argv) in this
+array, and the type of image is determined this way:
+1st: user specified a type using a switch before a (list of) name(s).
+     For DOS this looks like "mess system -flop test -cart rom1 -cart rom2"
+2nd: the extension of the filename matches one of the MessDevice entries
+     of the driver which is started. So if a driver defines "cas" for
+     it's IO_CASSETTE device and "dsk" for it's IO_FLOPPY device, the
+     command line "mess driver a.dsk b.cas" will be sufficient.
+
+* In the second stage during startup, the get_files() function is called
+and images are sorted into some (static) arrays of names in mess.c.
+This is to allow easier/faster access to them and maybe useful for
+swapping the names and calling init_<device> again.
+
+* The third stage now walks through the list of devices of the driver
+which is to be started and calls it's init functions with the the
+names from the arrays. If the driver returns non zero, the startup
+process is terminated here.
+
+
+----------------------------------------------------------
+0.2b4
+
+Note that this is the first public beta - not all features are working yet.
+
+New drivers supported (in no particular order):
+-----------------------------------------------
+
+Vectrex [Mathis Rosenhauer, Chris Salomon]
+Atari 800/5200 [Juergen Buchmueller]
+Apple II Family [Mike Balfour]
+PDP/1 [Chris Salomon]
+Sega Master System [Mathis Rosenhauer, Brad Oliver]
+Sega GameGear [Mathis Rosenhauer, Brad Oliver]
+Kaypro CP/M [Juergen Buchmueller, Benjamin C. W. Sittler]
+Bally Astrocade [Frank Palazzolo]
+
+
+These drivers have improved GRAPHICS:
+-------------------------------------
+
+- The TRS-80 now uses the real character prom data. [Mike Balfour]
+
+
+
+These drivers have new or improved SOUND:
+-----------------------------------------
+
+- NES psg frequency is now correct. [Brad Oliver]
+
+- Genesis now features preliminary FM sound. [Gareth Long, Tatsuyuki Satoh]
+
+
+
+Other drivers changes:
+----------------------
+
+- General bug fixes to the TRS-80, Colour Genie. [Juergen Buchmueller]
+
+- Increased Genesis compatibility. [Gareth Long]
+
+
+
+Changes to the main program:
+----------------------------
+
+- Code is in sync with MAME 0.33 final + some extras. All bug fixes to the core
+  are incorporated.
+
+- New 6502 core with support for the 65c02 and 6510 variants. [Juergen Buchmueller]
+
+- The 6809 core has been tweaked to increase cycle counting accuracy, needed
+  for the Vectrex. [Mathis Rosenhauer]
+
+- The core key functions have been abstraced to make better use of the
+  keyboard. This is especially handy for computer emulations. [Aaron Giles]
+
+
+
+Source:
+-------
+
+- The DOS version is now compiled with GCC 2.8.1 and using Allegro 3.0 + WIP
+  (30th May).
+
+- [DOS] To improve portability, the makefile is more conservative, using the
+  -pedantic and -Wshadow switches. Note that to compile with these switches,
+  several changes had to be made to allegro.h, which is included.
+
+
+----------------------------------------------------------
+0.1
+
+First version, based upon MAME 0.31 source
+
+New drivers supported (in no particular order):
+-----------------------------------------------
+
+Colecovision [Mike Balfour]
+NES [Brad Oliver]
+TRS-80 [Jurgen Buchmueller]
+Colour Genie [Juergen Buchmueller]
+Genesis [Gareth Long]
diff --git a/src/unix/doc/mess/messroms.txt b/src/unix/doc/mess/messroms.txt
new file mode 100644
index 0000000..6f9f60d
--- /dev/null
+++ b/src/unix/doc/mess/messroms.txt
@@ -0,0 +1,183 @@
+messroms.txt
+------------
+
+information about
+* messroms utility
+* dumping roms
+* saving roms
+* transfering data to pc
+
+files
+-----
+main.c, roms.h, comp.h messroms tool
+dumppc.c, dumppc.txt, dumppc.exe msdos utility for dumping pc rom area 
+ (also binary, because with djgpp you can't create a 8086 based pure msdos utility)
+dumpat.c, dumpat.txt, dumpat.exe msdos utility for dumping at boot area
+read6530.c contains the info for dumping mos rriot 6530
+rddil24.c contains the info for dumping mos rom6332 or similar 24 pin roms
+read6332.c contains the info for dumping mos rom 6332
+rddil32.c this is more a bugfix for my eprommer software
+
+cbm.txt info for dumping, saving, transfering commodore computers and devices
+c64savec.prg program to copy c64 character to basic area for later saving
+
+svision.txt info for building an adapter for supervision cartridge to
+			27c4001 eprom pinout
+pc1500.txt pinout of sharp pc1500/pc1500a/trs80pc2 rom
+tc.txt pinout of TC531000 (128k x 8 rom) TC571001 (128k x 8 eprom)
+
+cvhp48.c conversion utility for hp48 ascii/romdump dumps into binary
+
+messroms utility
+----------------
+
+motivation: help identifying already known roms, bad dumps,
+and give info to convert roms into the needed format.
+
+messroms --0x0000000 
+ identify crc 
+messroms directory
+ identifies files in directory
+messroms zipfile.zip
+ identifies files in zip archiv
+
+
+dumping roms
+------------
+
+most roms are dumped with eprom burners.
+There are many variations of eprom burners outside,
+each supported a large range of eprom chip types.
+
+I will give only a few tips for special chips:
+
+Always use the romcmp utility to identify bad dumps.
+Dump several times, and compare if the dumped data is the same.
+
+Weak dumps: had different dumps with watara supervision cartridges
+ when oe, ce was not switched when reading
+
+MOS6332: rom 4 kbyte 8bit, DIL 24 package
+ for pinout look into mess/messroms/rddil24.c or read6332.c
+ to allow dumping as 2732 build an adapter exchanging pin 18 and 20
+ 
+Signetics C19081, C19082 (24 pin dil) look into rddil24.c
+
+CN45048N look into rddil24.c
+
+Bally 9316 (24 pin dil) look into rddil24.c
+
+generic 24 pin dil: you might find an idea for dumping in rddil24.c
+
+EPROM DIL 32 PIN:
+ dumping as 278001 should be save
+
+rom/eprom in epoxy:
+ often you can see the wire into the epoxy.
+ These are in the same ordering as the pinout of the chip
+ (helped finding out watara super vision cartridge pinout)
+
+soldered roms/eproms, and you can't or want unsolder them:
+ wire an adapter with 2 sockets 
+ (a cheap one to place on top of the eprom, and another one for the eprommer)
+ cut 1 of the power lines with a sharp knife
+ solder socket on 2 points over the eprom for mechanical stability
+ now you should be able to read it out
+ unsolder the piggyback socket
+ reconnect the cut pin
+
+MOS6530: rom, ram, input, output timer
+ difficult to read
+ look into mess/messroms/read6530.c
+ maybe you can wire an adapter for an eprommer and read it as 27128 (a0 simulating clock)
+ you have to identify the rom, ram, io area in the usually 8kbyte dumped data
+ ram 64 bytes 0xff, io 16 bytes misc data, rom 1kbyte, 
+ unused depends on your hardware in mine 0
+
+PIC1655
+ info at www.microchip.com: technical reference manual and programming reference manual
+ available
+
+ could be protected (you read protected data, with info lost)
+ reading of mask programmed chips?
+ PIC16C55 and PIC1655(NMOS) differences?
+
+SC61860: Sharp Pocket Computer internal rom of the cpu
+ not known if it is accessible on the pinout
+
+TC531000 (128k x 8 mask rom)
+ look into mess/tools/messroms/tc.txt
+
+TC571001 (128k x 8 eprom )
+ look into mess/tools/messroms/tc.txt
+
+Sharp PC1500, PC1500A
+Tandy TRS80 PC-2
+----------------
+ look into mess/tools/messroms/pc1500.txt for rom pinout
+
+RCA Studio 2 and cartridges
+ look at Paul Robson's Studio2 page at www.classicgaming.com/studio2
+
+Watara Supervision Cartridges
+ look into mess/tools/messroms/svision.txt for building an adapter
+
+Saving roms
+-----------
+
+Some dump roms with the help of rom sockets in computer.
+E.g. pc network adapter to plug in an 8kbyte rom in its bootrom socket
+and read it.
+
+Sometimes it is not possible to get the single chips for reading.
+* you may not or can not open the appliances
+* roms are soldered directly into the board and you cannot unsolder them
+* roms are in a smd package with very small place between pins
+....
+
+Many roms are complete visible to cpu. So you can read them out with programs.
+
+IBMPC
+-----
+most bios, graphics, harddisk, ethernet bootroms are complete visible.
+Character roms in pre EGA graphics adapters are not visible.
+Flash roms of modern pcs not complete in the small 256 kbyte PC realmode area.
+Some special roms (deskmate of tandy1000) are not visible in the small 256kbyte area.
+
+You can used msdos debug, or any other debugger to save there roms:
+c0000-c7fff typical EGA,VGA
+c8000-c9fff typical PC harddisk controller
+f6000-fdfff BASIC
+fe000-fffff PC bios
+f0000-fffff bigger bios
+
+In dumppc.zip you find a msdos utility dumping the complete c0000-fffff area.
+
+VAMPIRE warning
+vampire extracts only the basic and the bios areas,
+and therefor does incomplete dumps on many pcs!
+(ibm pcjr, ibm xt, ibm at, tandy 1000hx, tandy 2500xl, at's )
+
+IBMAT
+-----
+This saves the boot area of intel 386 compatibles at's
+(0xfff00000-0xfffffffff)
+Should work with intel 286 compable at's (0xf00000-0xffffff).
+Hopefully works with those 286 based xt's and tandy's.
+
+Sharp Pocket Computer
+---------------------
+look into src/cpu/sc61860/readpc.c
+Internal rom only accessible in machine language
+
+HP48S/SX/G/GX
+-------------
+In some emulators (x48) you can find instructions and a tool for 
+transmitting the rom to a computer with 
+rs232 (9600 8N1 with kermit? protocoll).
+cvhp48.c converts this dump into a binary.
+
+Transfering data to another computer
+------------------------------------
+
+?
diff --git a/src/unix/doc/mess/sysinfo.dat b/src/unix/doc/mess/sysinfo.dat
new file mode 100644
index 0000000..1746a7b
--- /dev/null
+++ b/src/unix/doc/mess/sysinfo.dat
@@ -0,0 +1,8483 @@
+# MESS System Information Data File
+# Maintained by Hobie Troxell &  Chris Henry
+# Send corrections/submissions to: 
+#   Hobie Troxell <ht1848@yahoo.com> 
+#   Chris Henry <battlepriest@hotmail.com>
+
+# This file contains the basic documentation for most of the drivers presented in the MESS
+# distribution. Please read the readme.txt, mess.txt and messnew.txt prior to reading this
+# supplementary documentation. This file should be placed in the same directory as the MESS
+# executable when using the DOS version of MESS.
+
+# Driver entries are usually divided into sections such as: Usage, Features, Links, Known Issues,
+# History and Trivia, and MESS Emulation State.
+
+# Usage - This section lists any helpful commands for the computer or console in question, 
+# such as disk operating system and file loading BASIC commands. This information is not 
+# intended to replace a proper owner's manual for the system in question, and only contains 
+# the most simple commands that can also be found on any of dozens of websites devoted to 
+# the system.
+
+# Known Issues - This section lists any known problematic spots for the driver. These will be
+# fixed as time and knowledge permit. Please be patient. If you have information that may
+# help the MESS team resolve these issues, contact them at the addresses listed in MESS.TXT
+
+# History and Trivia - This section contains various background pieces for a system. If you
+# have anything you'd like to contribute contact me at the address above. Much of the 
+# information in these sections was kindly provided by Thierry Schembri and Olivier Boisseau of the 
+# "Old-computers.com Museum". Visit the excellent site at:  www.old-computers.com.
+
+#---------------------------------------------------------------------------------------------#
+
+$info=a2600
+$bio
+Atari 2600 Video Computer System
+
+
+History and Trivia:
+
+The Atari Video Computer System (VCS) was released in 1977 at a suggested retail price of 
+$299, which dropped quickly as sales soared; about 340,000 systems were sold the first year 
+alone.  Joe Decuir, Steve Mayer and Ron Milner designed the VCS.  The Atari VCS was 
+developed under the project codename "Stella".  The VCS later became known, both commonly
+and officially as the Atari 2600 (from the model number CX2600).  It is rumored that the number 
+2600 was chosen because 2600 cycles was a prominent long distance access tone, and that
+one of the developers had created devices that would trick pay phones into granting long
+distance access as a hobby.
+
+
+Features:
+
+Resolution: 160 x 260 (horz.) at 60.00 Hz
+CPU: 6507
+Cpu Clock: 1.19 MHz
+Graphics Clock: 1.19 MHz
+Bits: 8 
+ROM: 4k max
+RAM: 128 bytes, in VLSI
+Video Display Processor: Stella
+Sprites: 32 
+Colors: 256 (static)
+Sound Processor: Two Channel Square or Noise (TIA)
+Cartridge ROM: 2k up to 64k
+
+
+Links:
+
+Atari Age - www.atariage.com
+
+Atari Historical Society - www.atari-history.com/a2600.html
+
+
+MESS Emulation State:
+
+
+1) Restricted to 2KB and 4KB carts
+
+2) supports NTSC games only
+
+3) Limited compatibility
+
+4) no support for keypad controls
+
+5) Dip switch used to select joystick or paddles
+
+$end
+
+#---------------------------------------------------------------------------------------------#
+
+$info=a400
+$bio
+Atari 400 Home Computer
+
+
+Usage/Known Issues:
+
+Requires full keyboard emulation. At startup, full keyboard emulation mode is enabled by 
+default. Whilst in full keyboard emulation mode, some key associated functionality may be 
+disabled (like the ESC key for EXIT). The keyboard emulation mode is toggled using the 
+scroll_lock key.
+
+
+Most disk and cartridge images should work, though some graphic issues may exist. Note that
+the Atari 400 has less memory than the Atari 800, and some disk images may not work as a
+consequence; this is not a bug in the emulation.
+
+
+
+History and Trivia:
+
+The Atari 400 and 800 were the first home computers to use custom coprocessors and the first 
+to use "sprites" and special video interruptions like display lists, features that will be 
+implemented several years after on the Commodore Amiga. It offered high graphic resolution, 
+lots of colors and great sound capabilities, more than other computers could do then! The 
+two models had same characteristics, the 400 is the low-cost version, it has only 16 KB 
+(instead of 48 KB), one cartridge port (two for the 800) and a membrane keyboard (a 
+typewriter style keyboard one for the 800). 
+
+
+$end
+
+#---------------------------------------------------------------------------------------------#
+
+$info=a5200
+$bio
+Atari 5200 SuperSystem
+
+
+Usage/Known Issues:
+
+Keyboard input is a little difficult, using a joystick or mouse is recommended.
+
+Most games are playable. See a5200.crc for a fairly exhaustive compatibility list.
+
+
+History and Trivia:
+
+The Atari 5200 was introduced in 1982, and was actually designed to be a competitor to the 
+Intellivision, before ColecoVision entered the market. Developed under the name of "Pam" 
+(Atari, at the time, typically named projects after well-endowed female employees), Atari 
+considered releasing it with that moniker; PAM in this case an acronym for "Personal Arcade 
+Machine".
+
+
+The 5200 shared much of the architecture of the Atari 400/800 computers, but featured a 
+different cartridge connector and completely different controllers. Non-centering analogue 
+joysticks which offered a full 360 degrees of mobility, were both innovative and unreliable. 
+Other controller features included a keypad, and a ahead-of-it's-time pause button.
+
+
+The Atari 5200 suffered from it's initial incompatibility with the VCS/2600 (an adapter was 
+later released) and fierce competition from Coleco. When Warner Communications sold Atari 
+Corp. to the Tramiels in 1984, they quickly removed it from the market.
+
+
+$end
+
+#---------------------------------------------------------------------------------------------#
+
+$info=a7800
+$bio
+Atari 7800 ProSystem
+
+
+Known Issues:
+
+The Reset key "R" and Select key "S" are hard-mapped to the same location as the default 
+Player 2 up and fire two, respectively. You will need to remap these manually to avoid
+control conflicts in some games.
+
+Most games work fine, but a few have graphic and playability issues. See a7800.crc for a 
+full compatibility list.
+
+
+History and Trivia:
+
+Originally developed in 1984 as the Atari 3600, the Atari 7800 Prosystem was released to the 
+US market in 1986, in an attempt to compete in a revitalized home videogame market. The 7800 
+was actually designed by Gencomp as part of a lawsuit settlement (Gencomp had been sued for 
+releasing a speedup chipset for Atari coinop Missile Command).
+
+
+The 7800 was compatible with pre-existing Atari 2600 game program cartridges, without the need 
+for expansion modules or turning switches, but was also designed to use enhanced 7800-only 
+cartridges such as the pack-in "Pole Position 2". (n.b., only the 7800-specific cartridges are 
+currently supported in MESS.) Many peripherals, including a computer/keyboard and high score 
+saving cartridge were planned but never released.
+
+
+Unfortunately for Atari, the system did poorly in the late 1980's market dominated by Nintendo.
+
+
+www.atari-history.com has this interesting anecdote: "In the summer of 1984 the first 5,000 
+Atari 7800's had just been built in the new El Paso assembly plant. The production line 
+manager, Brad Saville was eager to meet with Jack Tramiel to show him the new flagship Atari 
+video game console. The meeting ended abruptly as Jack Tramiel was quoted "Get your pollution 
+out of here! We make computers now and we don't want your garbage." The line manager was fired 
+2 days later. About 8-9 months later the line manager received a phone call from Atari asking 
+him as to the whereabouts of the die molds for the Atari 7800. The ex-line manager responded 
+that he did in fact know where they were and for $50/hour for about 200 to 300 hours of his 
+time he would remember where they were and find them. The Atari Corp. representative who 
+called was infuriated and informed the former production line manager that Atari's lawyers 
+would be in contact with him. He never heard from Atari again."
+
+
+$end
+
+#---------------------------------------------------------------------------------------------#
+
+$info=a800
+$bio
+Atari 800 Home Computer
+
+
+Known Issues:
+
+Requires full keyboard emulation. At startup, full keyboard emulation mode is enabled by 
+default. Whilst in full keyboard emulation mode, some key associated functionality may be 
+disabled (like the ESC key for EXIT). The keyboard emulation mode is toggled using the 
+scroll_lock key.
+
+
+The Atari800 driver now has two ROM slots. It really had two slots, so the code was modified 
+to optionally read the second part of a 16K ROM from the second cartridge filename provided 
+(right slot). The previous version had a800_cartridge_32k flag which was wrong. Cartridges 
+are either 8K or 16K, so that was renamed to ..._16k too ;)
+
+
+Most disk and cartridge images should work, though some graphic issues may exist.
+
+
+The Atari 800XL driver (a800xl) is not currently working.
+
+
+History and Trivia:
+
+The Atari 400 and 800 were the first home computers to use custom coprocessors and the first 
+to use "sprites" and special video interruptions like display lists, features that will be 
+implemented several years after on the Commodore Amiga. It offered high graphic resolution, 
+lots of colors and great sound capabilities, more than other computers could do then! The 
+two models had same characteristics, the 400 is the low-cost version, it has only 16 KB 
+(instead of 48 KB), one cartridge port (two for the 800) and a membrane keyboard (a 
+typewriter style keyboard one for the 800). 
+
+
+$end
+
+#---------------------------------------------------------------------------------------------#
+
+$info=advision
+$bio
+Entex Adventurevision
+
+
+Known Issues:
+
+Sound is not currently supported.
+
+All four games are playable. 
+
+
+History and Trivia:
+
+The Adventure Vision was a cartridge based, electronic handheld video game that was 
+manufactured by Entex Industries in 1982. It measured about 13 1/4" X 10" X 9" and used 
+one vertical strip of 40 red LEDs and a spinning mirror to produce a screen with a 150X40 
+resolution drawn at 15 frames/sec. There were only four cartridges produced for it: Defender, 
+Turtles, Super Cobra, and an Asteroids clone, Space Force.
+
+
+Visit http://www.adventurevision.com for more information.
+
+
+$end
+
+#---------------------------------------------------------------------------------------------#
+
+$info=aim65
+$bio
+Rockwell AIM-65
+
+
+Very early computer 
+
+
+Features:
+* Integrated 20 digit (16segment) display 
+* Full size keyboard
+* Integrated printer
+* Connector for tty input/output
+* Tape interface
+
+
+Known Issues:
+
+* Display and keyboard working
+* Usable picture of the display with its white frame as artwork would be nice.
+* Would suffer from support for intelligent terminals as tty equipment.
+* Stopped. For me it is much to cryptic to operate, and therefore not interesting for me anymore.
+
+
+Contributors:
+
+Richard A. Cini: provided help and pictures
+
+$end
+
+#---------------------------------------------------------------------------------------------#
+
+$info=amiga
+$bio
+Commodore Amiga
+
+
+Known Issues:
+
+Sound is not currently supported.
+
+The driver is now working fairly well, though some games may need more memory than currently
+emulated.
+
+
+History and Trivia:
+
+The conceptor of the Amiga 1000 was Jay Miner, who created the Atari 800 many years before. 
+He wanted to make the most powerful computer ever, then he joined a little California 
+company called Amiga. He used the principle of the three coprocessors (again) to help the 
+main processor. At the beginning, the Amiga had only 64 kilobytes of RAM!, Atari wanted to 
+buy the Amiga but finally, Commodore succeeded to buy it (then there was a lawsuit, which 
+Commodore won). It was meant to be a competitor to the Atari 520 ST. The operating system 
+was done by Metacomco, a British company who specialized in the 68000 processor (they also 
+made languages for the Sinclair QL). It is a fully multitasking system which looks like 
+UNIX with a graphical user interface. It was the very first personal computer with great 
+graphics and sound capabilities with a GUI environment. The Amiga BASIC was written by 
+Microsoft (like most other versions of BASIC). The Amiga 1000 began to lose popularity one 
+year later with the creation of its two main successors: the Amiga 500 and the Amiga 2000.
+There were two versions of the Amiga 1000. The first one, just called "Amiga", was sold 
+only in USA, had a NTSC display, and didn't have the video modes EHB and HAM, later 
+versions would have this built in. The second one, called "Amiga 1000" (to avoid confusion 
+with its successor, the Amiga 2000) had a PAL display, the enhanced video modes 
+(HAM & EHB) and was built in Germany.
+
+
+
+
+$end
+
+#---------------------------------------------------------------------------------------------#
+
+$info=apexc
+$bio
+APEXC (All Purpose Electronic X-Ray Computer)
+
+
+Usage Notes:
+
+You should specify a cylinder image with code to run in it. Arguably, APEXC does not require such
+an image, since you may enter code in the control panel, but this would be a pain in the ass.
+
+
+If the program you run use punched tape I/O, you may specify tape image files. The first unit is
+read-only, the second unit is write-only.
+
+
+On a CLI MESS port, the resulting MESS command line may look like this:
+	mess apexc -cyln ram_image.apc -ptap input.tap output.tap
+
+
+Note that, when you quit MESS or the APEXC driver, the contents of the cylinder are saved
+to the image you specified. This simulates the behavior of the APEXC, where the cylinder image
+IS the working memory. If you don't like this behavior, you may either write-protect
+the cylinder image file, or keep a backup copy elsewhere on your hard disk (highly recommended).
+
+
+Note that the APEXC CPU is stopped on start-up, so that you may check the machine state and enter
+the start-up program address.
+
+
+On start-up, the instruction at address 0 is loaded into the Control Register, then the machine
+is stopped. To run the program starting at address 0, just press the Run/stop switch
+(the Run/stop switch is mapped to the Return key on the main keyboard).
+
+
+To start a program at another address, you need to load the first instruction into the Control
+register with the control panel. To do so, use keys 1 through 0 on the main keyboard to enter
+the 10-bit address into the 10 most significant bits of the Control Panel display, and set
+other bits to 0 with the three rows of keys under 1 through 0 (each key toggles a bit in the
+control panel display; don't be intimidated if it sounds complicated, it should eventually
+appear straight-forward when you try, provided you know what binary scale is). You have thus
+generated a Stop instruction pointing to the first instruction of the program. Write this
+instruction into the Control Register, by holding Left Shift pressed and pressing 1 on
+the numeric keypad. You should now press the Run/stop switch twice (mapped to the Return key
+on the main keyboard). First press executes the stop order, but fetches the first
+instruction of the program into the control register. Second press starts running the program,
+starting with the first instruction.
+
+
+Control panel usage:
+
+
+This is relatively simple. The Control Panel may hold and display a 32-bit value. Display is made
+of 32 lamps, which show the current value in binary scale (each lamp represents one bit). Hence,
+the normal usage is loading the value you want to edit into the control panel, editing it,
+then saving it to the proper location.
+
+
+Default key map:
+
+ Run/stop switch: Return key on main keypad
+
+The next 6 keys may be used alone to read the register into the control panel display, or
+in combination with the Left Shift key to write the value in the control panel display into the
+register.
+
+ Read/write Control Register: 1 key on numeric keypad
+
+ Read/write Accumulator: 2 key on numeric keypad
+
+ Read/write Register: 3 key on numeric keypad
+
+ Read/write current Head Block (never used on APEXC - used for bank switching): 4 key on numeric keypad
+
+ Read/write Memory Location: 5 key on numeric keypad
+
+ Read/write memory location pointed to by ML register: 6 key on numeric keypad
+
+ write instead of reading: Left Shift key (when you press one of the 6 keys above, the
+designated register is read into the control panel display, unless this key is being pressed,
+in which case the value in the control panel display is written into the register)
+
+ Toggle bits 1 through 10 in display: keys 1 through 0 on the main keyboard
+
+ Toggle bits 11 through 20 in display: key row directly below the former on the main keyboard
+(Q through P if your keyboard is QWERTY)
+
+ Toggle bits 21 through 30 in display: key row directly below the former on the main keyboard
+(A through ; if your keyboard is QWERTY)
+
+ Toggle bits 31 and 32 in display: key row directly below the former on the main keyboard
+(W and X if your keyboard is QWERTY)
+
+
+Known Issues:
+
+
+The driver should work correctly as of MESS .37b15. Still, it needs development tools, sample
+code and usage instructions desperately. I have tons of sample code (which was the reason for
+starting to write this driver), but still need to retype it.  I have started work on an assembler,
+too.
+
+
+Since I have no description of the control panel of an actual APEXC, I implemented a common-place
+control panel, so this part of the emulation is not accurate. I don't even know how an actual
+APEXC was operated, and the procedures I describe above are not accurate, either.
+
+
+History and Trivia:
+
+
+The APEXC was designed by Andrew D. Booth at Birkbeck College, London, in the early 50's.
+From 1943 on, he started working on the determination of crystal structures using X-ray diffraction
+data.  The computations involved were extremely tedious and there was ample incentive for automating
+the process. In 1947, along with his collaborator and future spouse Kathleen Britten, he spent
+a few months with von Neumann's team, which was the leading edge in computer research at the time.
+Booth designed an electromechanical computer, the ARC, in the late 40's. Later on, they built
+an experimental electronic computer named 'SEC' (Simple Electronic Computer), and finally the APEC
+(All-Purpose Electronic Computer) series.
+
+
+According to a 1956 document, the APEC series included the following machines:
+
+ * APE(X)C: Birkbeck College, London (before 1955)
+
+ * APE(N)C: Board of Mathematical Machines, Oslo ('N' must stand for 'Norway')
+
+ * APE(H)C: British Tabulating Machine Company (No idea what 'H' can stand for)
+
+ * APE(R)C: British Rayon Research Association ('R' must stand for 'Rayon')
+
+ * UCC: University College, London (circa January 1956)
+
+ * MAC (Magnetic Automatic Calculator): "built by Wharf Engineering Laboratories" (February 1955)
+
+ * The HEC (Hollerith Electronic Computer - silly name invented by BTM
+directors), built by the British Tabulating Machine Company (later to become
+International Computers and Tabulators (ICT), then International Computers
+Limited (ICL)), a commercial machine sold in several models (I have heard of
+HEC 1, HEC 2, HEC 2M (no idea what the difference with HEC 2 is) and HEC 4)
+(before 1955)
+
+
+Only one of each of these machines was built, with the exception of HEC (and possibly MAC)
+which were commercial machines produced in small series. They were similar in design,
+with various small differences, mostly in I/O equipment (either punched-card machines - APEXC,
+APEHC - or teletypers (keyboard and printer, and paper tape reader and puncher) - APERC, APENC).
+Also, the UCC had 8k words of storage, instead of 1k word for other machines, and the MAC
+used germanium diodes in replacement of many tubes.  The HEC used standard
+Hollerith punch cards; the HEC 4 had a printer, too, and it featured several
+instructions (divide) and registers not found on the APEXC.
+
+
+I am sorry I know little more about Booth, his team, and the history of these machines.
+
+
+Technical Description:
+
+
+The APEXC is an incredibly simple machine.
+
+
+Instruction and Data words are always 32-bit-long. The processor uses integer arithmetic with 2's
+complement representation. Addresses are 10-bit-long. The APEXC has no RAM, except a 32-bit
+accumulator and a 32-bit data register (used along with the 32-bit accumulator to implement 64-bit
+shift instructions and hold the 64-bit result of a multiplication). Instructions and data are
+stored in two magnetic drums, for a total of 32 circular magnetic tracks of 32 words. Since
+the rotation rate is 3750rpm (62.5 rotations per second), the program execution speed can go
+from as high as the theoretical maximum of 1 kIPS to lower than 100IPS if program instructions
+and data are not contiguous. Nowadays, many a pocket calculator is faster.
+
+
+One oddity is that there is no program counter: each machine instruction includes the address
+of the next instruction. This design may sound weird, but it is the only way to achieve optimal
+performance with this cylinder-based memory.
+
+
+The machine code is made of 15 instructions only, namely addition, subtraction, multiplication,
+load (3 variants), store (2 variants), conditional branch, right arithmetic bit shift,
+right bit rotation, punched-card input, punched-card output, machine stop, and bank-switching
+(which is never used on the APEXC, since it only has 1024 words of storage, and addresses are
+10-bit-long). A so-called vector mode enables to repeat the same operation 32 times with 32
+successive memory locations. Note the lack of bitwise and/or/xor and division. Also, note
+the lack of indirect addressing modes: dynamic modification of opcodes is the only way one may
+simulate it.
+
+
+Another oddity is that the memory bus and the ALU are 1-bit-wide. There is a 64kHz bit-clock and
+a 2kHz word-clock, and each word memory and arithmetic operation is decomposed into 32 1-bit
+memory and arithmetic operations: this takes 32 bit cycles, for a total of 1 word cycle.
+
+
+The processor is fairly efficient: most instructions take only 2 word cycles (1 for fetch,
+1 for read operand and execute), with the exception of stores, shifts and multiplications.
+Yes, the APEXC CPU is a RISC: there is no other adequate word.
+
+
+Note there is no ROM, and therefore no 'bootstrap loader' or default start-up program whatever.
+As far as I know, no executive or operating system was ever written for the APEXC, although
+there were subroutine libraries of sorts for common arithmetic, I/O and debug tasks.
+
+
+Operation of the machine is normally done through a control panel which allows the user to start,
+stop and resume the CPU, and to alter registers and memory when the CPU is stopped. When starting
+the machine, the address of the first instruction of the program to be executed must be entered
+in the control panel, then the run switch must be pressed. Most programs end with a stop
+instruction, which enables to check the state of the machine, possibly run some post-mortem
+debugging procedures (a core dump routine is described in an APEXC programming book), then enter
+the address of another program and run it.
+
+
+Two I/O devices were supported: a paper tape reader, and a paper tape puncher. The puncher output
+could be fed to a printer ('teletyper') unit when desirable. Printer output is emulated and is
+displayed on screen. Tape input was either computer-generated by the APEXC, or hand-typed with
+a special 32-key keyboard (each tape row had 5 data holes (<-> bits), which makes 32 different
+values).
+
+$end
+
+#---------------------------------------------------------------------------------------------#
+
+$info=apfimag
+$bio
+APF Imagination Machine
+
+
+The APF Imagination has the same hardware as the APF-M1000, but it is a computer.
+It has a keyboard and built in cassette player.
+
+An additional disc interface was available.
+
+In basic, pressing "FUNCTION" (currently mapped to CTRL) and a letter/number will display
+a basic keyword making it easier to enter programs.
+
+
+FUNCTION+Q = IF
+FUNCTION+W = STEP
+FUNCTION+E = STOP
+FUNCTION+R = READ
+FUNCTION+T = NEXT
+FUNCTION+Y = PRINT
+FUNCTION+U = END
+FUNCTION+I = LIST
+FUNCTION+O = REM
+FUNCTION+P = USING
+FUNCTION+1 = GOSUB
+FUNCTION+2 = LET
+FUNCTION+3 = DATA
+FUNCTION+4 = INPUT
+FUNCTION+5 = DIM
+FUNCTION+6 = FOR
+FUNCTION+7 = RETURN
+FUNCTION+8 = THEN
+FUNCTION+9 = ON
+FUNCTION+0 = GOTO
+FUNCTION+- = RESTORE
+FUNCTION+ENTER = CLOAD
+
+For cassette:
+
+Use CSAVE"<filename>" to save a file, and CLOAD"" to load the file back.
+
+For disc:
+
+Use SAVE"<filename>" to save a file, and LOAD"<filename>" to load the file back.
+You can use "DIR <drive number>" e.g. "DIR 0" and "DIR 1" to give a directory of the
+disc.
+
+Basic disk images with the ".APD" extension are supported.
+
+
+Known issues:
+
+* cassette loading and saving is working
+
+* interrupts are not exact. I don't know enough about them, any info would be appreciated.
+
+* disc interface is working, but there may be some bugs.
+
+* keyboard is mostly working but some keys may be missing
+
+* keypad is not emulated
+
+* the M6847 emulation is very advanced *BUT* I don't think I have set it up correctly for the APF Imagination, therefore the graphics are wrong.
+
+* memory emulation is not complete
+
+$end
+
+#---------------------------------------------------------------------------------------------#
+
+$info=apfm1000
+$bio
+APF M-1000
+
+
+The APF M-1000 is a console. It has a built in game. The emulation is not exact and the
+built in game does not work.
+
+Known issues:
+
+* internal game does not work
+* keypad is not emulated
+
+$end
+
+#---------------------------------------------------------------------------------------------#
+
+$info=apple1
+$bio
+Apple 1
+
+
+History and Trivia:
+
+Steve Wozniak, who worked for Hewlett-Packard at the time, wanted to build his own computer.
+He couldn't afford the Intel 8080 CPU (this CPU was very popular then, as it was used in the
+Altair 8800 & IMSAI 8080, but was pretty expensive), he would use the Motorola 6800 but it
+was also much too expensive. Finally he decided to build his computer around the MOS 6502
+(which was pretty compatible with the Motorola 6800). The computer was easier to use than
+the Altair: unlike the Altair, the computer has a keyboard and can display characters on a
+TV (the Altair uses LEDs for its display). The display was very slow, only 60 characters (!)
+were displayed each second.
+
+
+Steve Jobs, who made the game "Breakout" for Atari, with a little help from "the Woz", was
+interested in this computer. Together they created the Apple Computer Company and they tried
+to sell the computer. Paul Terrell, the owner of a computer shop, was interested in this
+computer, but fully assembled (the Apple 1 was sold "naked", no monitor, power supply,
+keyboard, tape drive, etc.) and with a cassette interface, which Wozniak designed. He sold
+it with the Basic he wrote soon after. They sold about two hundred of these units. This
+machine was so popular that Jack Tramiel of Commodore (!) offered to buy Apple, because
+Apple was, at the time, a major purchaser of MOS 6502 processors (Commodore owned Mos
+Technologies). Wozniak wanted $15,000 more than Tramiel offered, needless to say, the deal
+fell through. It was followed the next year by the Apple ][.
+
+
+$end
+
+#---------------------------------------------------------------------------------------------#
+
+$info=apple2c
+$bio
+Apple //c Series
+
+
+Known Issues:
+
+Requires full keyboard emulation. At startup, full keyboard emulation mode is enabled by
+default. Whilst in full keyboard emulation mode, some key associated functionality may be
+disabled (like the ESC key for EXIT). The keyboard emulation mode is toggled using the
+scroll_lock key.
+
+
+History and Trivia:
+
+Apple "][", Apple "II", Apple "//" - Which is correct?
+
+"][", "II", and "//" tend to be used pretty much interchangably for any model of Apple II
+computer, although, practically speaking, there are a few usages which may provoke a
+correction.
+
+"][" is the original Apple II symbol. It appears on all early II's and II+'s as well as on the
+Disk ][ drive. It is, easily, the most attractive and distinctive II symbol; but, it is also
+associated with old Apple II's. The "//" usage is generally associated with the "c" and
+newer "e" models.
+
+The generally preferred machine designations are:
+
+Apple ][   or  Apple II for pre-][+ models
+Apple ][+  or  Apple II+
+Apple IIe  for non-enhanced IIe computers
+Apple //e  for 128k-enhanced IIe computers
+Apple //c
+Apple IIc+
+Apple IIgs or  GS  or best (if you have the fonts)  ||GS
+
+The Apple //c is the compact (the "c" means compact) version of the Apple IIe. It has the
+same characteristics but lot of features which are optional on the IIe are provided on the
+//c (floppy disk drive, 80 columns display, color display, 128 KB RAM), but unlike the
+Apple IIe, it has no expansion slots, so it is hard to add features to this computer. It
+runs either with DOS 3.3 either with ProDos and has the first version of QuickDraw in ROM.
+The Apple //c was originally designed to be a portable version of the Apple II, but it
+wasn't a stand alone system, it has no batteries and no LCD screen (Apple would soon
+release the items), it could also be used with a small 9" monochrome green screen which
+plugged into the unit. The Apple //c was mainly used as a desktop computer and
+was replaced with the Apple IIc+ in 1988.
+
+
+The Apple IIc+ unit was a direct response to the Laser 128EX/2.  Apple retrofitted the
+//c design to try to compete with Video Technology's high speed Apple II clone. The
+retrofitting is evident in the design of the motherboard.  The motherboard runs at 1Mhz,
+unlike the Laser 128EX/2.  In order to run its programs faster, Apple used a 4Mhz 65C02
+with 8k of high speed SRAM cache and licensed the accelerator design from Zip
+Technologies (makers of the ZipChip accelerator for the IIe and //c).  They built an
+accelerator into a 1Mhz motherboard rather than design a faster motherboard from scratch.
+
+
+The designers of the Apple IIc+ originally wanted to make a portable ||GS. Apple's
+management, bent on promoting the Mac, balked at the idea. At the same time, the
+Laser 128EX/2 made a quick design cycle mandatory. The result is an updated //c.
+
+Apple //c went under several revisions: you can discover which machine you are using issuing
+the command PRINT PEEK(64447).
+
+If 255 is displayed, you have the first, original model. This model is known to have problems
+producing accurate baud rates for serial communications.
+
+If 0 is displayed, you can use 3.5" drives, but you don't have the memory expansion connector.
+
+If 3 is displayed, you have the memory exapnsion connector and you can plug in extra memory.
+
+If 4 is displayed, you have the latest model with memory expansion connector and extra upgrades.
+
+If 5 is displayed, you have an Apple IIc+.
+
+The Apple IIc+ was the finest Apple 8-bit computer ever built, but lack of marketing,
+the apparent de-evolution in technology compared to the 16-bit Apple ||GS, and the
+aggressive sale of the Laser 128EX/2 made the IIc+ the most short lived of the
+Apple II models.
+
+
+$end
+
+#---------------------------------------------------------------------------------------------#
+
+$info=apple2e
+$bio
+Apple IIe series
+
+
+Known Issues:
+
+Requires full keyboard emulation. At startup, full keyboard emulation mode is enabled by
+default. Whilst in full keyboard emulation mode, some key associated functionality may be
+disabled (like the ESC key for EXIT). The keyboard emulation mode is toggled using the
+scroll_lock key.
+
+
+
+History and Trivia:
+
+Apple "][", Apple "II", Apple "//" - Which is correct?
+
+"][", "II", and "//" tend to be used pretty much interchangably for any model of Apple II
+computer, although, practically speaking, there are a few usages which may provoke a
+correction.
+
+"][" is the original Apple II symbol. It appears on all early II's and II+'s as well as on the
+Disk ][ drive. It is, easily, the most attractive and distinctive II symbol; but, it is also
+associated with old Apple II's. The "//" usage is generally associated with the "c" and
+newer "e" models.
+
+The generally preferred machine designations are:
+
+Apple ][   or  Apple II for pre-][+ models
+Apple ][+  or  Apple II+
+Apple IIe  for non-enhanced IIe computers
+Apple //e  for 128k-enhanced IIe computers
+Apple //c
+Apple IIc+
+Apple IIgs or  GS  or best (if you have the fonts)  ||GS
+
+
+The Apple IIe (the "e" means enhanced) is the successor of the Apple ][+. It was a very
+great success and was widely used in schools (and it's still used today in some places!)
+It works under DOS 3.3 (the Apple II operating system) and uses 143 KB floppy disks.
+
+
+The Apple IIe was replaced with the Apple //e, which had an enhanced keyboard, a 4 MHz
+65C02 CPU and a 3.5" floppy disk unit.
+
+
+$end
+
+#---------------------------------------------------------------------------------------------#
+
+$info=aquarius
+$bio
+Mattel Aquarius
+
+
+Usage Notes:
+
+From within the emulation, there are several BASIC command keyboard shortcuts available by
+pressing control and another key.
+
+
+CHR$      Ctrl[SPACE]
+
+CLOAD     Ctrl[Z]
+
+COPY      Ctrl[9]
+
+CSAVE     Ctrl[A]
+
+DATA      Ctrl[F]
+
+DIM       Ctrl[E]
+
+FOR       Ctrl[-]
+
+GOSUB     Ctrl[7]
+
+GOTO      Ctrl[5]
+
+IF        Ctrl[3]
+
+INPUT     Ctrl[T]
+
+LEFT$     Ctrl[V]
+
+LIST      Ctrl[2]
+
+MID$      Ctrl[B]
+
+NEXT      Ctrl[=]
+
+ON        Ctrl[6]
+
+PEEK      Ctrl[;]
+
+POINT     Ctrl[L]
+
+POKE      Ctrl[']
+
+PRESET    Ctrl[K]
+
+PSET      Ctrl[J]
+
+READ      Ctrl[D]
+
+REM       Ctrl[W]
+
+RIGHT$    Ctrl[N]
+
+RETURN    Ctrl[8]
+
+RUN       Ctrl[1]
+
+STR$      Ctrl[,]
+
+THEN      Ctrl[4]
+
+VAL       Ctrl[.]
+
+
+To break/stop a program, press Ctrl[C]
+
+To interrupt the LISTing of a program, press Ctrl[S]
+
+To repeat the entire last line you typed, press Ctrl[R]
+
+To get the machine to beep, press Ctrl[G]
+
+
+Known Issues:
+
+Image loading is not currently supported.
+
+
+History and Trivia:
+
+The Aquarius was Mattel Electronics' (a division of a huge US toy manufacturer) attempt at
+entering the home computer market. It was a commercial failure, and was frequently found 
+in bargain bins in toy stores for many years following. 
+
+
+$end
+
+
+#---------------------------------------------------------------------------------------------#
+
+$info=arcadia
+$bio
+Emerson Arcadia 2001 (1982)
+
+
+8-bit Console system
+
+
+Sold from several firms with different names:
+
+Hanimex mpt-03 (first variant?) with large cartridge slot
+
+Palladium Video - Computer - Game with different cartridge slot, Controllers
+
+Emerson Arcadia 2001
+
+Schmid TVG2000 / Tele Fever (Germany)
+
+Hanimex hmg 2650
+
+LeisureVision (Canada)
+
+Leonardo (Italy)
+
+Advision Home Arcade (France)
+
+
+Features:
+
+128x208 in 8 colors
+
+4 8x8 single color sprites
+
+single channel sound
+
+2 controller with analog joystick and keypad
+
+
+Controller Layout:
+
+  1   2   3
+
+  4   5   6
+
+  7   8   9
+
+ Del  0 Enter
+
+
+Links:
+
+
+r2001 for DOS by Paul Robson at http://users.aol.com/mk14emu/arcadia.htm
+
+
+MESS Emulation State:
+
+Based on info by Paul Robson, Ward Shrake
+
+Look into crc/arcadia.crc for some issues
+
+Bad analog joystick emulation
+
+
+$end
+
+#---------------------------------------------------------------------------------------------#
+
+$info=astrocde
+$bio
+Bally Professional Arcade/Astrocade
+
+
+Usage:
+
+Loading the Astrocade driver without a cassetridge image will allow you to use the four
+built-in programs.
+
+
+Known Issues:
+
+To the best of our knowledge, full compatibility, aside from Bally Basic tape support.
+
+
+History and Trivia:
+
+The game console commonly known as the "Bally Astrocade" was never officially sold by that 
+name, having originally been released by Bally Manufacturing in 1978 as the Bally Professional 
+Arcade. It was withdrawn rather quickly though, due to the success of the competing Atari VCS. 
+A group of Pro Arcade enthusiasts under the name Astrovision Inc., bought the rights to the 
+Pro Arcade and reintroduced it as the Bally Computer System, including the Basic casettrige as 
+a pack-in. In 1982, the system and company was renamed Astrocade, once again trying to market 
+it as a video game system. The system didn't last much longer, though; it was a product with a 
+limited interest base even before the video game slump of the next few years.
+
+
+$end
+
+#---------------------------------------------------------------------------------------------#
+
+$info=at
+$bio
+AT (1987)
+
+
+Features:
+
+
+MESS Emulation State:
+
+$end
+
+#---------------------------------------------------------------------------------------------#
+
+$info=atom
+$bio
+Acorn Atom (1979)
+
+
+Features:
+
+
+
+MESS Emulation State:
+
+
+
+$end
+
+#---------------------------------------------------------------------------------------------#
+
+$info=avigo
+$bio
+TI Avigo
+
+
+This system does not work properly.
+There is no documentation on the hardware available and more is required.
+
+$end
+
+#---------------------------------------------------------------------------------------------#
+
+$info=bbca
+$bio
+Acorn BBC Micro Model A (1981)
+
+
+Features:
+
+
+MESS Emulation State:
+
+$end
+
+#---------------------------------------------------------------------------------------------#
+
+$info=bondwell
+$bio
+BONDWELL PRO28 Series - BW230
+
+
+IBM PC compatible computer
+
+Features:
+
+CPU on pc-type adapter
+ 8088 with 3.75/8 mhz (turboswitch)
+ socket for 8087
+ 512 kb ram build in 
+ sockets for additional 128kb ram on board
+ integrated floppy disk controller
+ setup ram/realtime clock?
+ MF2 Keyboard (US layout)
+ socket for additional bios?
+game port on motherboard or slot?
+serial port on motherboard or slot?
+parallel port on motherboard or slot?
+cga adapter in slot or motherboard?
+5 1/4 inch 360 kb disk drive
+harddisk controller in slot or motherboard?
+32mb harddisk
+
+MESS Emulation State:
+
+basically the same as mess ibmpc emulation
+rtc/setup ram not emulated
+character rom dump missing
+needs i8086 "dirval reset fix" to work
+bios stops without emulation of disketts controller (->you have to start with disk image!)
+
+
+$end
+
+#---------------------------------------------------------------------------------------------#
+
+$info=c128
+$bio
+Commodore c128
+
+
+Sequel of to the c64.
+
+
+Description:
+
+hardware emulation mode for c64
+ displayed over din/tv connector only
+ c64 cartridges
+ c64 userport
+ only the c64 standard keys available
+country support (keyboard, character rom, kernel (keyboard polling))
+ character rom german
+ character rom french, belgium, italian
+ editor, kernel for german
+ editor, kernel for swedish
+ editor, kernel for finish
+ editor, kernel for norwegian
+ editor, kernel for french
+ editor, kernel for italian
+enhanced keyboard
+m8502 processor (additional port pin)
+additional vdc videochip for 80 column modes with own connector (rgbi)
+ 16k byte ram for this chip
+128 kbyte ram, 64 kbyte rom, 8k byte charrom, 2k byte static colorram
+ (1 mbyte ram possible)
+sid6581 soundchip
+c64 expansion port with some additional pins
+z80 CPU for CPM mode
+
+c128d:
+
+ c1571 floppy drive build in
+ 64kb vdc ram
+ sid8580 sound chip
+
+c128cr/c128dcr:
+
+ cost reduced
+ only modified for cheaper production (newer rams, ...)
+
+
+MESS emulation state:
+
+uses c64 emulation for c64 mode
+so only notes for the additional subsystems here
+
+rasterline based video system
+ no CPU holding
+ imperfect scrolling support (when 40 columns or 25 lines)
+ lightpen support not finished
+ rasterline not finished
+vdc emulation
+ dirtybuffered video system
+ text mode
+  only standard 8x8 characters supported
+ graphic mode not tested
+ lightpen not supported
+ scrolling not supported
+z80 emulation
+ floppy simulation not enough for booting CPM
+ so simplified z80 memory management not tested
+no CPU clock doubling
+no internal function rom
+c64 mode
+ differences to real c64???
+no sound
+cia6526's look in machine/cia6526.c
+keyboard
+gameport a
+ paddles 1,2
+ joystick 1
+ 2 button joystick/mouse joystick emulation
+ no mouse
+ lightpen (not finished)
+gameport b
+ paddles 3,4
+ joystick 2
+ 2 button joystick/mouse joystick emulation
+ no mouse
+simple tape support
+ (not working, cia timing, CPU timing?)
+serial bus
+ simple disk drives
+ no printer or other devices
+expansion modules
+ no c128 modules
+expansion modules c64
+ rom cartridges (exrom)
+ ultimax rom cartridges (game)
+ c64 cartridges (only standard rom cartridges)
+ no other rom cartridges (bankswitching logic in it, switching exrom, game)
+ no ieee488 support
+ no cpm cartridge
+ no speech cartridge (no circuit diagram found)
+ no fm sound cartridge
+ no other expansion modules
+no userport
+ no rs232/v.24 interface
+
+
+Video notes:
+
+if the game runs too fast with the NTSC version, try the PAL version!
+flickering affects in one video version, try the other video version
+
+
+Keys:
+
+Some PC-Keyboards does not behave well when special two or more keys are
+pressed at the same time
+(with my keyboard printscreen clears the pressed pause key!)
+
+shift-cbm switches between upper-only and normal character set
+(when wrong characters on screen this can help)
+run (shift-stop) loads program from type and starts it
+esc-x switch between two videosystems
+
+additional keys (to c64) are in c64mode not useable
+
+
+Lightpen:
+
+Paddle 5 x-axe
+Paddle 6 y-axe
+
+
+Tape:
+
+(DAC 1 volume in noise volume)
+loading of wav, prg and prg files in zip archive
+command line -cassette image
+wav:
+ 8 or 16(not tested) bit, mono, 125000 Hz minimum
+ has the same problems like an original tape drive (tone head must
+ be adjusted to get working(no load error,...) wav-files)
+zip:
+ must be placed in current directory
+ prg's are played in the order of the files in zip file
+
+use LOAD or LOAD"" or LOAD"",1 for loading of normal programs
+use LOAD"",1,1 for loading programs to their special address
+
+several programs relies on more features
+(loading other file types, writing, ...)
+
+
+Discs:
+
+only file load from drive 8 and 9 implemented
+ loads file from rom directory (*.prg,*.p00) (must NOT be specified on command line)
+ or file from d64 image (here also directory LOAD"$",8 supported)
+use LOAD"filename",8
+or LOAD"filename",8,1 (for loading machine language programs at their address)
+for loading
+type RUN or the appropriate sys call to start them
+
+several programs rely on more features
+(loading other file types, writing, ...)
+
+most games rely on starting own programs in the floppy drive
+(and therefore CPU level emulation is needed)
+
+
+Roms:
+
+.prg
+.crt
+.80 .90 .a0 .b0 .e0 .f0
+files with boot-sign in it
+  recognized as roms
+
+.prg files loaded at address in its first two bytes
+.?0 files to address specified in extension
+.crt roms to addresses in crt file
+
+
+Quickloader:
+
+.prg and .p00 files supported
+loads program into memory and sets program end pointer
+(works with most programs)
+program ready to get started with RUN
+loads first rom when you press quickload key (numeric slash)
+
+
+c64 mode:
+
+hold down commodore key while resetting or turning on
+type go64 at the c128 command mode
+
+
+cpm mode:
+
+cpm disk must be inserted in device 8
+turn on computer
+or
+type boot at the c128 command mode
+
+when problems start with -log and look into error.log file
+
+
+rom dumping:
+
+Dumping of the roms from the running machine:
+in the monitor program
+s "drive:name",device,start,end
+
+s "0:basic",8,f4000,fc000
+s "0:editor",8,fc000,fd000
+s "0:kernel",8,ee000,f0000
+s "0:char128",8,ed000,ee000
+
+*z80bios missing (funet says only 1 version!?)
+I don't know, maybe there is a cpm utility allowing saving
+the memory area 0-0xfff of bank 0.
+(I don't want to develop (and can't test) this short complicated
+program)
+
+*c64basic and kernel (only 1 version!?)
+in c64 mode
+poke43,0:poke44,160:poke45,0:poke46,192:save"0:basic64",8
+
+in c64 mode
+for i=0 to 8191:poke 32*256+i, peek(224*256+i): next
+poke43,0:poke44,32:poke45,0:poke46,64:save"0:kernel64",8
+
+*c64 charset (swedish version or original c64 version)
+in c128 mode
+monitor
+a 2000 sei
+lda #33
+sta 1
+ldy #0
+sty fa
+sty fc
+lda #c0
+sta fd
+lda #d0
+sta fb
+ldx #10
+lda (fa),y
+sta (fc),y
+iny
+bne 2015
+inc fb
+inc fd
+dex
+bne 2015
+lda #37
+sta 1
+cli
+rts
+(additional enter to end assembler input)
+x (to leave monitor)
+go64 (answer with y)
+sys 32*256
+poke 43,0:poke44,192:poke45,0:poke46,208:save"0:char64",8
+
+or in c64 mode
+load the program in the attachment
+load"savechar64",8,1
+sys 32*256
+poke 43,0:poke44,192:poke45,0:poke46,208:save"0:char64",8
+
+c128d floppy disk bios:
+I think you have to download a program
+copying the bios to puffers.
+Then you could read this buffer into the computer, or write
+these buffers to disk.
+
+Transportation to your pc:
+1571 writing to mfm encoded disketts (in cpm mode only, or use program)
+ maybe the IBM CPM-86 formats are like the standard DOS formats.
+ but using dd may create images known by some other emulators.
+1581 writes mfm encoded:
+ can one of these drives to a format know by linux?
+Some years ago I build a simple adapter pc/parport to vc1541
+ floppy disk drive.
+
+Dumping roms with epromer:
+
+c128
+U18       (read compatible 2764?) 8kB c64 character rom, c128 character rom
+U32 23128 (read compatible 27128?) 16kB c64 Basic, c64 Kernel
+U33 23128 (read compatible 27128?) 16kB c128 Basic at 0x4000
+U34 23128 (read compatible 27128?) 16kB c128 Basic at 0x8000
+U35 23128 (read compatible 27128?) 16kB c128 Editor, Z80Bios, C128 Kernel
+c128 cost reduced
+U18       (read compatible 2764?) 8kB c64 character rom, c128 character rom
+U32 23256 (read compatible 27256?) 32kB c64 Basic, c64 Kernel, c128 Editor, Z80Bios, C128 Kernel
+U34 23256 (read compatible 27256?) 32kB C128 Basic
+c128dcr
+as c128 cr
+U102 23256 (read compatible 27256?) 32kB 1571 system rom
+
+$end
+
+#---------------------------------------------------------------------------------------------#
+
+$info=c16
+$bio
+Commodore C16, Plus 4, and C364
+
+
+Cassette Usage:
+
+Cassette images can have the .wav or .prg extensions, and multiple .prg files 
+can be contained within a zip file. Zip files must be placed in the current directory, and 
+the contained prg files are played in sequential order.
+
+
+The format for WAVs are: 
+8 bit (16 bit may work, but this hasn't been tested), mono, 12500 Hz minimum. This has the 
+same problems as an original Datasette tape drive (the tone head must be adjusted to get 
+working (no load error...) wav-files)
+
+
+Note that tape volume is DAC1 volume within the MESS UI On Screen Display Options (accessed
+with the tilde (~) key in the DOS version.
+
+
+Within the emulation, use LOAD or LOAD"" or LOAD"",1 for loading normal programs. Use 
+LOAD"",1,1 for loading programs to a special address.
+
+
+Diskette Usage:
+
+Disk drives are simulated at the moment, and only file loads from drive 8 and 9 
+are implemented. You can load a program file from the rom directory (*.prg,*.p00)
+(This must NOT be specified on command line, start the c16 emulation with no images specified)
+
+
+The directory command LOAD"$",8 is supported when using d64 images.
+
+
+
+Within the emulation, basic programs can be loaded with: 
+
+
+DLOAD"filename" or LOAD"filename",8 
+
+
+
+Machine language programs can be loaded to their address with: 
+
+
+DLOAD"filename" or LOAD"filename",8,1
+
+
+When a program is loaded, type RUN or the appropriate SYS call to start it. 
+
+
+Note that several programs rely on more features not currently emulated (such as 
+loading other file types, writing...) Some games also rely on starting programs in the 
+floppy drive's processor (and therefore CPU level emulation of the 1541 is needed).
+
+
+Cartridge Usage:
+
+Cartridges may have any of the following extensions: .bin .rom .lo .hi .prg
+Files with boot-sign in it are recognized as roms. Some cartridges require more than one 
+image to load (e.g., tutor.lo tutor.hi).
+
+
+ 
+.prg files loaded at address in its first two bytes
+
+
+ 
+.bin, .rom, .lo , .hi roms are loaded to cs1 low, cs1 high, cs2 low, cs2 high addresses 
+accordingly to their order in the command line.
+
+
+ 
+Note that .prg and .p00 files are assigned to the quickloader (so you have to use 
+the -cart switch when loading rom images).
+
+
+Quickloader Usage:
+
+A quickloader is available via the f8 key. It supports program image files 
+with the .prg extension. This loads the program into memory and sets the program end 
+pointer. It works with most programs. The program can be started by entering "RUN" in 
+the emulation.
+
+
+Miscellaneous Usage Notes:
+
+See "Keys (This Machine)" for key assignments.
+
+Shift-cbm switches between upper-only and normal character set (if wrong characters are on 
+screen this may help).
+
+Run (shift-stop) loads the first program from device 8 (dload"*) and starts it.
+
+If you run into difficulty, be sure to start the emulation with the -log switch, and look into
+the error.log file that is created in your mess directory.
+
+
+Known Issues:
+
+Memory check by c16 kernel will not recognize more memory without restarting MESS.
+
+CPU clock switching/changing.
+
+Imperfect colors; should be enough for 95% of the games and programs.
+
+Imperfect scrolling support (when 40 columns or 25 lines)
+
+Lightpen support missing.
+
+Some PC-Keyboards do not behave well when special two or more keys are pressed at the same 
+time (with my keyboard printscreen clears the pressed pause key!)
+
+Expansion modules other than the 1551 floppy drive are not supported.
+
+The rs232/v.24 interface is not supported, nor are printers and other parallel devices.
+
+The Plus 4's userport is not supported.
+
+Note if a game runs too fast with the NTSC version, try the PAL version!
+
+
+The following features are emulated:
+
+rasterline based video system
+
+keyboard, joystick 1 and 2
+
+simple tape support
+
+serial bus
+
+simple disk drives
+
+expansion modules
+
+rom cartridges
+
+simple ieee488 floppy support (c1551 floppy disk drive)
+
+quickloader
+
+
+History and Trivia:
+
+When the first Commodore 264 prototype unofficially debuted at the Winter Consumer 
+Electronics Show (CES) in January (?) 1984, the developers had obviously not yet agreed 
+about the keyboard layout; some keys are unlabeled, the right shift key was missing, 
+instead having a key which seems to be meant as a line feed key.
+
+ 
+It was planned that when buying a C264, you could have chosen between these programs: 
+
+3 plus 1 (word processor, data base, spread sheet, windowing) 
+
+Superscript (professional word processor) 
+
+Magic Desk (word processor, data base, spread sheet, calculator) 
+
+Logo 
+
+Pilot 
+
+Easycalc 264 (spread sheet) 
+
+COM 264 
+
+Financial Advisor 
+
+
+ 
+The C264 should then be delivered with the selected program built in. The remaining programs 
+could only be used with cartridges for the expansion port.
+
+
+ 
+The official presentation of the C264 series took place on the Hannover fair in 1984. 
+Luckily, the developers didn't eliminate the right shift key in the final keyboard layout. 
+The formerly unlabeled keys bear a label now: the key that used to be the left arrow 
+key on the C64 and the VC20 says 'Esc', the key between '@' and '*' bears the English pound 
+sign, and the key that was labelled 'SHIFT LOCK' on all 8-bit computers Commodore ever 
+produced now says - guess what - 'SHIFT LOCK' :-) (must have been a hard decision between 
+SHIFT and CAPS lock).
+
+
+ 
+A word about the C364 : This prototype was a C264 with a bigger keyboard (86 keys incl. a 
+numeric keypad) and with a builtin speech synthesizer with a vocabulary of 250 words (which 
+could be expanded by either diskettes or modules). Commodore dropped this model and decided 
+to sell a separate speech module (Magic Voice) for the C64.
+
+
+ 
+Among the Commodore news from the Summer CES 1984 was the renaming of the C264 to Plus/4. 
+This renaming came along with a slight change in the builtin software: you could not choose 
+between many different programs anymore, but each Plus/4 was delivered with the 3-plus-1 
+software.
+
+
+ 
+The built-in software was really limited: a word processing (only with 40 columns and can 
+manage documents with only 99 lines of 77 columns), a very small spreadsheet (only 17 
+columns and 50 lines), a poor graphic software (which can display graphically data from 
+the sheets but only in text mode) and a small database (999 record with 17 fields each 
+and only 38 characters by field). Most of these programs can only be used with a floppy 
+disk unit. The Plus 4 can use peripherals of the C64 or the Vic 20, the printer MPS801 
+and the Disk Unit 1541 run well with it but it can't use C64 software. This machine 
+wasn't built to be a competitor of the C64 nor to replace it. It has an improved basic 
+in relation to the C64 one with graphic and sound instructions and a built-in assembler, 
+but has lost lots of interesting C64 features like great soundchip or hardware sprites. 
+
+
+ 
+The Commodore 16/116 belongs to the Commodore 264 series (with the Commodore Plus/4). It was 
+designed to replace the Commodore VIC-20, but was not compatible with it, nor with 
+the C64. It had the same characteristics as the Commodore Plus/4 : same graphic resolution, 
+same sound system, same CPU and speed, just less memory. It has a powerful basic language 
+(contrary to the VIC-20 or the C64) which makes graphics and sounds easy to program. 
+The C16, like the Commodore Plus/4 was a commercial failure.
+
+
+ 
+The C116 was an earlier version of the C16 and had a rubber keyboard. It was sold in Austria, 
+at least, and perhaps in other countries as well.
+
+
+ 
+It seems that the first C16s had the two control ports labelled JOY 0 and JOY 1 instead of 
+JOY 1 and JOY 2, just as a hint for collectors :-)
+
+
+ 
+Note that like the C116, the C16 lacks a user port.
+
+
+$end
+
+#---------------------------------------------------------------------------------------------#
+
+$info=c64
+$bio
+Commodore 64
+
+
+Diskette Usage:
+
+Disk drives are simulated at the moment, and only file loads from drive 8 and 9 
+are implemented. You can load a program file from the rom directory (*.prg,*.p00)
+You can also load a file from a d64 image (The directory command LOAD"$",8 is supported when 
+using d64 images).
+
+
+ 
+Within the emulation, basic programs can be loaded with:  LOAD"filename",8 
+
+
+ 
+Machine language programs can be loaded to their address with:  LOAD"filename",8,1
+
+
+ 
+When a program is loaded, type RUN or the appropriate SYS call to start it. 
+
+
+ 
+Note that several programs rely on more features not currently emulated (such as 
+loading other file types, writing...) Some games also rely on starting programs in the 
+floppy drive's processor (and therefore CPU level emulation of the 1541 is needed).
+
+
+Cartridge Usage:
+
+Cartridges may have any of the following extensions: .prg .crt .80 .90 .a0 .b0 
+.e0 .f0   Files with boot-sign in it are recognized as roms. Some cartridges may require more 
+than one image.
+
+ 
+.prg files loaded at address in its first two bytes
+
+ 
+.?0 files are loaded to the address specified in the extension.
+
+ 
+.crt roms are loaded to the addresses specified in crt file.
+
+
+ 
+Note that .prg files are assigned to the quickloader (so you have to use 
+the -cart switch when loading rom images).
+
+
+Cassette Usage:
+
+Cassette images with the .wav or .prg extensions as well as multiple .prg files 
+contained within a zip file can be loaded. Zip files must be placed in the current directory, 
+and the contained prg files are played in sequential order.
+
+
+ 
+The format for WAVs are: 
+8 bit (16 bit may work, but hasn't been tested), mono, 12500 Hz minimum. This has the same 
+problems as an original Datasette tape drive (the tone head must be adjusted to get working 
+(no load error...) wav-files)
+
+
+ 
+Note that tape volume is DAC1 volume within the MESS UI On Screen Display Options (accessed
+with the tilde (~) key in the DOS version.
+
+
+ 
+Within the emulation, use LOAD or LOAD"" or LOAD"",1 for loading normal programs. Use 
+LOAD"",1,1 for loading programs to a special address.
+
+
+Quickloader Usage:
+
+A quickloader is available via the f8 key. It supports program image files with 
+the .prg and .p00 extensions. This loads the program into memory and sets the program end 
+pointer. It works with most programs. The program can be started by entering "RUN" in the 
+emulation.
+
+
+Miscellaneous Usage Notes:
+
+Gameport A supports paddles 1 & 2,  joystick 1, lightpen (implementation not finished).
+
+Gameport B supports paddles 3 & 4, joystick 2
+
+If you run into difficulty, be sure to start the emulation with the -log switch, and look into
+the error.log file that is created in your mess directory.
+
+If the game runs too fast with the NTSC version, try the PAL version! (c64pal)
+
+
+Known Issues:
+
+The rasterline based video system currently has the following issues: no CPU holding, imperfect 
+scrolling support (when 40 columns or 25 lines), lightpen support not finished, rasterline not 
+finished.
+
+Sound is not currently supported
+
+The restore key is not currently working.
+
+NTSC/PAL select not correct.
+
+The Gameports do not support the mouse (Serial Protocol?).
+
+No printer or other devices support in the serial bus (apart from simple disk drives).
+
+Simple tape support not working (cia timing?)
+
+As far as expansion modules go, non-bankswitching rom cartridges (exrom) should work, but no 
+other rom cartridges (those with bankswitching logic in it, switching exrom, game). There is 
+no ieee488 support nor support for other expansion modules.
+
+No userport support and no rs232/v.24 interface.
+
+ 
+Some issues with the cia6526: 
+
+port a,b
+
+handshake support, flag input, not pc output
+
+no serial in/out, cnt
+
+timer a,b
+
+not counting of external clocks
+
+not switching port b pins
+
+
+History and Trivia:
+ 
+Designed similar to the Vic-20, the Commodore 64 featured a better video chip supporting 
+sprites, as well as the famous sid6581 sound chip, two "Atari-compatible" joystick ports,
+and 64 kilobytes of RAM.
+
+
+ 
+The Commodore 64 is, along with the Apple II and the Atari 8-Bit computers, one of the 
+most famous home computers of it's era. During its production from 1982 to 1993 (!) 17 
+to 22 million (!) of these computer would sell, to put in perspective, that's more than 
+all the Macintoshes in the world. It was one of the first to offer a high quality sound 
+chip and graphic resolution with many colors and sprites. A great range of peripherals 
+was developed for this computer and can use several of the Vic 20 peripherals. 
+
+
+ 
+Several versions of the Commodore 64 were launched : The first one (C64-1) uses the VIC 20 
+case, it will be quickly replaced with the C64-2 which uses the famous brown case and by 
+the C64-3 with small cosmetic changes in the keyboard. A special version called Educator 64 
+or PET64 or CBM 4064 was proposed for schools and uses the PET case.
+
+
+ 
+Commodore produced the first generation of C64s until May 1986, then it was discontinued 
+and they introduced the C64C. According to the 64'er magazine, this version has been 
+planned since the Hannover mass in 1985, but as the old version sold so well during 
+Christmas '85, its release date was pushed back.
+
+
+ 
+The new model does not differ much from its predecessor, the only innovation is the 
+flatter case, which makes the keyboard (which has off-white keys now) more ergonomic 
+(it looks like the C128 case), as it is less higher than the old one. But the new case 
+did not only have advantages: due to its low profile and additional metal screening, 
+some of the numerous hardware expansions did not fit anymore. This was changed with 
+the C64G. The 64'er staff noticed that VIC-II as well as the two CIAs have new version 
+numbers; they didn't write which, though (these are probably just bugfixed chips). 
+
+
+ 
+The official name for this model was "C=64 C", but nevertheless the German 64'er magazine 
+decided to call it "C64-II" (because the first units didn't have the new name on the label 
+at the bottom), the badges on all the 64 C's just says "Commodore 64". They pointed out 
+that this name was only valid for the 64'er magazine, but since the 64'er was the 
+magazine for the C64 for a long time, the name was widely accepted and so this model 
+is mostly known as "C64-II" in Germany.
+
+
+ 
+The C64C appeared again after (or concurrently with?) the C64G, this time with the new, 
+short board. So, although the case might look the same and the label says "Commodore 64", 
+the boards may be completely different.
+
+
+ 
+Commodore also released a "laptop version" (though hardly portable) of the C64, called SX64. 
+This computer has a built-in 5" color screen, one detachable keyboard, one 5.25" floppy 
+disk drive (the famous 1541) and a second one can be installed as well. A version called 
+DX-64 was launched (in very limited quantities) at the same time, it has same 
+characteristics as the SX64 except its two 5.25" floppy disk drives. The SX64 and DX64 
+computers never had success, but it is known as the world's first color portable.
+
+
+ 
+The C64GS was released in 1990. Basically it was a re-boxed C64, without a keyboard or any 
+other interfaces, except for the cartridge slot on top. It didn't have much success as you 
+could buy a C64 for not much extra, and the C64GS games would still work on the C64.
+It came with one game cartridge containing International Soccer, Klax, Flimbo's Quest
+and Fiendish Freddy's Big Top O'Fun. The carts had a memory of 4 megabits (512k).
+
+
+
+$end
+
+#---------------------------------------------------------------------------------------------#
+
+$info=c65
+$bio
+Commodore c65 (1991)
+
+
+homecomputer under the keyboard to redo the commodore c64
+success (with good c64 compatibility)
+
+Never released, because the compatibility was not good enough!
+(Some prototypes! were sold)
+
+Project name was C64DX
+
+Features:
+
+hardware emulation mode for c64
+ adapter needed for c64 cartridges (many should work)
+ only standard c64 keys plus cursor-up and cursor-left
+ CPU not full compatible (no illegal instructions)
+enhanced keyboard
+m65ce02 processor core (1 or 3.5 Mhz frequency)
+vic3 (4567) with additional capabilities
+ vic2 compatibility mode
+ graphic modes
+ 80 column modes
+second sid audio chip (both 8580)
+uart 6511 rs232 chip
+special dma controller
+128 kb ram
+128 kb rom (kernel, editor, basic, monitor, characters, c64 roms)
+build in mfm floppy disk 3 1/2 inch double sided double density
+connector for second mem floppy disk
+special ram expansion slot
+rs232 connector (round din)
+no tape connector
+new expansion slot
+
+
+MESS emulation state:
+
+rasterline based video system
+ quick modified vic6567/c64 video chip
+ no support for enhanced features, only 80 column mode
+ no CPU holding
+ imperfect scrolling support (when 40 columns or 25 lines)
+ lightpen support not finished
+ rasterline not finished
+no sound
+cia6526's look in machine/cia6526.c
+keyboard
+gameport a
+ paddles 1,2
+ joystick 1
+ 2 button joystick/mouse joystick emulation
+ no mouse
+ lightpen (not finished)
+gameport b
+ paddles 3,4
+ joystick 2
+ 2 button joystick/mouse joystick emulation
+ no mouse
+serial bus
+ simple disk drives (device 10 and 11, hang in c64 mode!)
+ no printer or other devices
+expansion modules
+ none (did there any exist)
+expansion modules c64 (adapter needed)
+ ultimax rom cartridges not working
+ rom cartridges (exrom) not working
+ no other rom cartridges (bankswitching logic in it, switching exrom, game)
+ no ieee488 support
+ no cpm cartridge
+ no speech cartridge (no circuit diagram found)
+ no fm sound cartridge
+ no other expansion modules
+no userport
+ no rs232/v.24 interface
+
+
+Keys:
+
+Some PC-Keyboards does not behave well when special two or more keys are
+pressed at the same time
+(with my keyboard printscreen clears the pressed pause key!)
+
+shift-cbm switches between upper-only and normal character set
+(when wrong characters on screen this can help)
+run (shift-stop) loads program from type and starts it
+
+
+Lightpen:
+
+Paddle 5 x-axe
+Paddle 6 y-axe
+
+
+Discs:
+
+only file load from drive 10 and 11 implemented
+ loads file from rom directory (*.prg,*.p00) (must NOT be specified on command line
+ or file from d64 image (here also directory LOAD"$",8 supported)
+use LOAD"filename",10
+or LOAD"filename",10,1 (for loading machine language programs at their address)
+for loading
+type RUN or the appropriate sys call to start them
+
+several programs rely on more features
+(loading other file types, writing, ...)
+
+most games rely on starting own programs in the floppy drive
+(and therefore CPU level emulation is needed)
+
+
+Quickloader:
+
+.prg and .p00 files supported
+loads program into memory and sets program end pointer
+(works with most programs)
+program ready to get started with RUN
+loads first rom when you press quickload key (numeric slash)
+
+when problems start with -log and look into error.log file
+
+$end
+
+#---------------------------------------------------------------------------------------------#
+
+$info=cbm500
+$bio
+Commodore CBM 500 Series
+
+
+History and Trivia:
+
+The 500 / 600 / 700 series were mainly sold in Europe, but a few models are known to have been 
+sold in the United States. The CBM 600 is same as the 500 but has a 80 column display and 
+256 Kb RAM. The CBM 700 is same as the 600 but has two 5.25" disk drives (370 KB each) and a 
+hard disk (7.5 MB). Microsoft Basic is in ROM. The Z80 and the 8088 are optional. When they 
+are used, the 6809 is used then for i/o, display and keyboard management. It works under 
+Commodore DOS or CP/M and MSDOS when the computer use the other processors. 
+
+
+$end
+
+#---------------------------------------------------------------------------------------------#
+
+$info=cbm610
+$bio
+Commodore Business Machines B128-80LP/610 (1983)
+
+
+Features:
+
+
+MESS Emulation State:
+
+$end
+
+#---------------------------------------------------------------------------------------------#
+
+$info=cbm710
+$bio
+Commodore B-128/80 Series
+
+
+History and Trivia:
+ 
+The CPU in the CBM B series was a MOS/Commodore 6509, which is basically a m6502 with 1 
+megabyte address space and weird bankswitching.
+
+$end
+
+#---------------------------------------------------------------------------------------------#
+
+$info=cgenie
+$bio
+EACA Colour Genie 2000
+
+
+Cassette Usage:
+
+From within the emulation you can use SYSTEM or CLOAD commands to read images: 
+
+SYSTEM supports 6 character filenames.
+
+CLOAD loads a file named BASIC(N).CAS, where (N) is the character you supplied 
+(e.g., CLOAD"M" loads BASICM.CAS)
+
+CLOAD is for BASIC type tapes only.  It should work if you have a BASIC *.cas file. 
+File "names" in that case are _one_ character in length (inside the emulation).  In your 
+roms/cgenie folder the names will be basicA.cas, basicB.cas and so on.  If you CSAVE"A you'll 
+see a file basicA.cas later and you can CLOAD"A it again. 
+
+
+To load a binary image there was a different command: SYSTEM
+
+You'll see a prompt looking like this: 
+
+*?
+
+
+and there you can enter a name of up to six (wow!) characters.
+
+*?chop16 [ENTER]
+
+This will start loading a file named chop16.cas if it is in your rompath. If you don't have 
+it... well, wait and see (nothing ;)  If you have it, you'll see two stars (**) in the upper 
+right corner.  The right one will twinkle after every couple of bytes loaded, every 254 I 
+think.
+	
+After several minutes you'll see the prompt again
+
+*?
+
+
+now type / (slash) and ENTER and the program will be started at it's defined run address. If 
+a program does not have a run address, you could also specify /[decimal value] to run from a 
+specific value...
+
+
+ 
+Diskette Usage:
+
+When the emulation starts, tap [ENTER] and also confirm the following 
+	
+MEM SIZE?
+
+with [ENTER].
+
+After that you're in BASIC (DISK BASIC, to be exact, unless you disable cgdos.rom via the 
+dip switches).
+
+Now you can use the DISK BASIC extensions to issue commands.  Most important
+
+CMD"I[disk#] 
+
+Display inventory, disk# is optional and can be from 0 to 3
+
+You can use CMD"I0" to "CMDI3" to get an inventory of drive 0 to 3.
+
+
+Use CMD"S FILENAME/CMD" to start a binary executable or use LOAD"FILENAME/BAS" to load a basic 
+program.
+CMD"Sname/cmd will start a binary file name/cmd from any disk
+
+CMD"Limage/bin:3 will load image/bin from disk 3
+
+To start a game, eg. paint/cmd, type
+
+cmd"s paint/cmd
+
+
+You can omit the blank between cmd"s and the filename.
+
+
+To ease things you could also enable my DOS lookalike frontend ;) It's contained in 
+newe000.rom (2,772 bytes; CRC 953491a7) but not enabled by default. If you enable it 
+you can type HELP (hehe ;) and DIR and simply give a name to execute a binary file.
+
+The optional newe000.rom is loaded if the corresponding "dip switch" is set from within the 
+driver itself. There is no need to specify this rom on the command line.
+
+
+Miscellaneous Usage Notes:
+ 
+Under the "Options" menu, accessible by hitting TAB, there are three settings: 
+
+"Floppy Disc Drives"  - enable or disable floppy disc controller.
+
+"DOS ROM C000-DFFF"   - enable 8K DOS ROM or make it RAM.
+
+"EXT ROM E000-EFFF"   - enable 4K Extension ROM or make it RAM.
+
+
+Known issues:
+
+Startup with CAS or CMD images does not always work. Use the BASIC SYSTEM or CLOAD commands 
+to read cassette image files, or use the Colour Genie DOS ROM with floppy disc images to run 
+programs. The driver does not yet emulate the printer port mode for AY-3-8910. Right now it 
+always uses the AY-3-8910 ports for joystick emulation.
+
+
+Requires full keyboard emulation. At startup, full keyboard emulation mode is enabled by 
+default.  Whilst in full keyboard emulation mode, some key associated functionality may be 
+disabled (like the ESC key for EXIT). The keyboard emulation mode is toggled using the 
+scroll_lock key.   
+
+
+The Colour Genie driver should run most of the known programs out there. It supports the 
+Motorola 6845 CRT controller with text and graphics modes (LGR and FGR), the AY-3-8910 
+sound chip with three audio channels and noise and the WD 179x floppy disc controller with up 
+to four virtual floppy disc drives contained in image files.
+
+
+The keyboard is relatively close to the original layout; see "Keys (This Machine)" in the
+TAB/Options menu.
+
+
+Emulation of dual Colour Genie joysticks with keypads is also supported.
+
+
+History and Trivia:
+
+The Colour Genie is the successor of the Genie 1, Genie 2 and Genie 3. It is not possible 
+to mix characters and graphics because text and graphic memories are not mixed. There was 
+a little level display located above the keyboard which allows to set the recording 
+level of the tape recorder to avoid failure when writing onto a tape. 
+
+
+
+$end
+
+#---------------------------------------------------------------------------------------------#
+
+$info=channelf
+$bio
+Fairchild Channel F
+
+
+Usage:
+
+MAME coin inputs (keys 5, 6, 7, 8) are used to select the game at the G? prompt.
+
+
+
+History and Trivia:
+
+Introduced in August 1976 at a suggested retail price of $170 (US), The Channel F was the 
+first programmable video game system to use replaceable cartridges. The controllers, which were
+often described as looking like plungers were attached directly to the system via 8 foot wires.
+The Channel F didn't fair well in the late 1970s market dominated by Atari, and Fairchild switched 
+their efforts to developing the Spark-16 minicomputer.
+
+$end
+
+#---------------------------------------------------------------------------------------------#
+
+$info=coco
+$bio
+Tandy/Radio Shack Color Computer / Dragon Data Ltd. Dragon 32
+
+
+Usage:
+
+	- Cassette images (.cas):
+
+Not all of these work; don't panic.
+
+You can pick the cassette image you wish to run from the FILE MANAGER in the Tab/Options menu.
+Once you've selected the image, go back into the CoCo emulation, and use "scroll lock" to set 
+it back in keyboard emulation mode.
+
+type CLOAD (if it's a BASIC program) or CLOADM (for assembler programs)
+
+then EXEC (if it's an assembler program)
+
+or RUN (if it's a basic program)
+
+If you include the name of the file (eg. CLOAD "PROG") it will skip any files preceding the
+one you specified.
+
+	- Snapshot images (.PAK)
+
+Go to file menu pick the .pak
+Should automatically start running the game.
+if it does not run, it isn't supported yet.
+
+    - Cartridge rom images (.ROM)
+
+Go to file menu and pick the .rom
+Reset to CoCo and it will start running the game.
+if it does not run it isn't supported yet.
+
+	-Diskette images (.DSK)
+
+Basically the same as cassette images, except you insert the image in Floppy Disk#1 
+from the file manager. Once you return to the coco emulation, switch back to keyboard 
+emulation mode by pressing SCROLL LOCK and type:
+DIR
+
+To load a binary file (/BIN), type LOADM "GAME/BIN:1" (replacing the ":1" with the 
+appropriate drive designation ":0" through ":3" )
+
+then EXEC
+
+To load a basic file (/BAS), type LOAD "GAME/BAS:0"
+
+then RUN
+
+Thanks to "Axe" for the command summary.
+
+
+Known Issues:
+
+Requires full keyboard emulation. At startup, full keyboard emulation mode is enabled by 
+default. Whilst in full keyboard emulation mode, some key associated functionality may be 
+disabled (like the ESC key for EXIT). The keyboard emulation mode is toggled using the 
+scroll_lock key.
+
+
+History and Trivia:
+
+The Tandy TRS-80 Color Computer was typically called 'CoCo'. It was compatible with the 
+Welsh Dragon 32: they can use same software and cartridges. Unlike the Dragon, though, it 
+used its own basic, Tandy Basic instead of the Microsoft basic. It was followed by the 
+TRS 80 color computer II. The two BASICs use different tokens so they are not binary
+compatible.
+
+
+The Tandy/TRS-80 Color Computer 2 (CoCo 2) replaced the original in 1983. It has the same 
+characteristics than the first. It has 16 KB RAM and can have a 16 KB ROM which contains 
+Microsoft Basic. It was replaced with the Tandy Color Computer 3 in 1986. 
+
+
+The Tandy Color Computer 3 is the successor of the Tandy/TRS-80 Color Computer 2. It can 
+work with OS-9 Level II (an operating system designed for 6809 processors). As this processor
+is an 8 bit (strange choice when Atari and Commodore were using a 68000), it can't access 
+simultaneously to the 128 KB (or 512 KB), it uses several RAM banks (as the Thomson TO8, or 
+MSX 2 computers) which can be switched in 8K blocks. 
+
+
+Tandy made several prototypes of a Tandy Color Computer 4 but it was never released. The 
+DRAGON 32 enjoyed a pretty good success in Europe. Its ROM holds the Operating System and a 
+BASIC programming language by Microsoft. One of its characteristics is partial compatibility 
+with the Tandy TRS-80 Color Computer Series: they can use same peripherals and some 
+cartridges. Two years later, Welsh launched the DRAGON 64 which has the same 
+characteristics except the added memory (64 KB instead of 32 KB), a RS232c port and a keyboard 
+with repetitive keys.
+
+
+
+$end
+
+#---------------------------------------------------------------------------------------------#
+
+$info=coco3
+$bio
+Tandy Color Computer 3
+
+
+First off, also read the history for the Color Computer and Color Computer 2 drivers. Much
+of the information there also applies to this driver.
+
+Besides fully emulating the Color Computer 3 this driver also contains some extras. It contains
+two different real time clocks. Currently they can be set under the "DIP switches". The two
+types are Disto and Cloud-9.
+
+Disto Real Time Clock:
+	Chip:      OKI m6242B
+	Addressed: $FF50 and $FF51
+
+Cloud-9 Real Time Clock:
+    Chip:      Dallas Semiconductor's Phantom Time Chip DS1315
+    Addressed: $FF79, $FF78, $FF7C
+
+This driver also contains an implementation of Jeff Vavasours' Virtual Hard Disk. See his
+Color Computer 3 emulator for information regarding it.
+
+$end
+
+#---------------------------------------------------------------------------------------------#
+
+$info=coco3h
+$bio
+Tandy Color Computer 3 (Hitachi)
+
+
+First off, also read the history for the Color Computer, Color Computer 2 and Color Computer 3
+drivers. Much of the information there also applies to this driver.
+
+This driver is exactly like the coco3 drivers except the MPU has been replaced by a Hitachi
+6309. This chip has extra features not documented by Hitachi.
+
+$end
+
+#---------------------------------------------------------------------------------------------#
+
+$info=coleco
+$bio
+Coleco Industries ColecoVision
+
+
+Known Issues:
+
+This emulation runs most cartridges accurately. Games requiring analogue controls (Steering 
+Wheel, Roller Controller) are not playable. See coleco.crc for further compatibility notes.
+
+
+History and Trivia:
+
+The ColecoVision video game system was released in August of 1982 for a suggested retail 
+price of $175 US. Similar at it's core to the MSX computers, ColecoVision had both superior 
+graphics and more expansion capabilities compared to it's chief rivals: the Atari 2600 and 
+Intellivision. Among the expansion module options were a hardware Atari 2600 emulator, and a 
+Steering Wheel for driving games, both unheard of at the time.
+
+
+The competitive price, technical superiority, and perhaps more importantly, the inclusion of 
+Donkey Kong as the pack-in cartridge, led to Coleco becoming an industry leader. With the 
+emergence of the popularity of home computers, however, the console market seemed in jeopardy 
+of losing it's share to the likes of Commodore and Apple. Coleco responded by releasing the 
+Adam Family Computer as both a standalone unit and as an expansion to the ColecoVision itself. 
+
+
+The Adam was a phenomenal market failure though, and Coleco pulled itself from both the 
+console and computer markets just before the game market crash in late 1984.
+
+
+Telegames purchased the rights to the system, and many of the manufactured games, and released 
+a clone, The Personal Arcade, in 1988. It was later re-released by them, as the DINA.
+
+
+$end
+
+#---------------------------------------------------------------------------------------------#
+
+$info=comquest
+$bio
+Team Concept Comquest Plus German
+
+
+laptop computer for children
+
+
+Features:
+
+mono LCD display with about 144x100 pixels
+integrated speaker
+integrated keyboard and joypad
+integrated batterie box
+serial port connector (for special printer)
+connector for external power supply
+cartridge slot
+
+
+MESS Emulation State:
+
+not working (not even CPU is known)
+stopped until CPU type is recognized or info found
+
+$end
+
+#---------------------------------------------------------------------------------------------#
+
+$info=concept
+$bio
+Corvus Concept
+
+
+Known Issues:
+
+The keyboard is not emulated fully.
+
+Hard disks, serial ports, and Omninet are not emulated.
+
+Only the original floppy controller (8" SSSD disks) is emulated.
+
+
+Usage:
+
+The driver can boot from a 8" SSSD floppy image.  Start the computer and press
+'F' when the computer asks for a boot device.
+
+You may invoke the MACSbug debugger as well by pressing the key 'D'.  However,
+this version of MACSbug requires a terminal to be connected to the serial port
+to do anything useful, so you are out of luck.
+
+
+History and Trivia:
+
+The Concept was announced in the spring of 1982.
+
+This computer uses a state-of-art (at the time) MC68000 CPU.  Its CCOS
+operating system is a variant of the Merlin operating system by Silicon Valley
+Software: it is a mono-tasking OS, with source-level compatibility with the
+UCSD p-system, and vague reminiscences of UNIX.
+
+The Concept has a bitmapped screen, which enables to mix text in any style and
+size with graphics, and some programs were reportedly WYSIWYG (which was
+uncommon at the time).  The system includes a primitive window manager, but
+don't delude yourself: it is no GUI.  The most original feature is probably the
+rotatable screen that can be used either in horizontal or vertical position:
+however you need to reboot the computer after flipping the screen.   Another
+feature of interest is the integrated network support: the Concept can be used
+either as a disk-less network computer or as a full-featured personal computer,
+and you could connect Concepts, Apple IIs and IBM PCs in an heterogeneous
+Omninet LAN.
+
+Available programs were mostly business applications: word processor,
+spreadsheet, grapher, database, accounting...  Thanks to its large screen, its
+WYSIWYG capability and to the use of various hierarchical menus, the Concept is
+relatively user-friendly for a 1982 business computer.  There were also Pascal
+and FORTRAN compilers, a BASIC, a UCSD runtime, an 8080 simulator, a port of
+the CP/M OS, a version of SPICE to simulate discrete ICs, and even a paint
+program that could take advantage of a mouse.
+
+The price was about 4000$ for a bare 256-kbyte system in 1984 (1000$ for extra
+256kbytes, $750 for floppy, from 2000$ to 4000$ for hard disk according to
+size).
+
+
+$end
+
+#---------------------------------------------------------------------------------------------#
+
+$info=coupe
+$bio
+Sam Coupe (1989)
+
+
+Features:
+
+
+MESS Emulation State:
+
+$end
+
+#---------------------------------------------------------------------------------------------#
+
+$info=cpc464
+$bio
+Amstrad/Schneider CPC 464
+
+
+Usage:
+
+With a disk image loaded, the emulation starts from the BASIC "Ready" prompt. 
+From here you can enter commands to access the disk image: 
+ 
+
+A directory listing can be obtained with: "CAT"
+
+
+A program can be run with: RUN"filename"
+
+
+The common programs to run are those with a .BIN or .BAS extension and usually the smaller 
+of the files on the disk image.
+
+
+On a few games you can type: RUN"disc or RUN"disk to start the game.
+
+
+If a directory listing cannot be obtained, then the disc might be copy-protected. 
+In this case, try: 
+
+|CPM
+
+
+| is obtained by pressing shift and the @ key together. Since the keyboard is mapped so the 
+keys are in the roughly same place as on a real Amstrad keyboard, then @ can be found 
+around the [,@,],# keys.
+
+The |CPM works by loading and executing the first sector on the first track of the disc.
+
+
+Snapshots, which contain a memory dump, CPU state and hardware state, can be run from a 
+command line interface with the following command: 
+
+mess cpc464 -snap "snapshot name"
+
+
+The snapshot will start automatically.
+
+
+There are a few excellent utilities for creating and maintaining
+disk images for the Amstrad CPC emulators. Here are just a couple - 
+
+CPDRead   http://www.classicgaming.com/caprice/
+CPCfs     ftp://ftp.lip6.fr/pub/amstrad/emu-util/cpcfs085.zip
+
+
+Others can be found in the FAQ at http://genesis8.free.fr/
+
+
+
+Known Issues:
+
+Requires full keyboard emulation. At startup, full keyboard emulation mode is enabled by 
+default.  Whilst in full keyboard emulation mode, some key associated functionality may be 
+disabled (like the ESC key for EXIT). The keyboard emulation mode is toggled using the 
+scroll_lock key.   
+
+Runs many disk images and snapshots well.
+
+
+History and Trivia:
+
+The CPC464 was an 8-bit Amstrad computer, produced in 1984, with 64k of ram and a tape 
+recorder built in.
+
+$end
+
+#---------------------------------------------------------------------------------------------#
+
+$info=cpc6128
+$bio
+Amstrad/Schneider CPC 6128
+
+
+Usage:
+
+With a disk image loaded, the emulation starts from the BASIC "Ready" prompt. 
+From here you can enter commands to access the disk image: 
+ 
+
+A directory listing can be obtained with: "CAT"
+
+
+A program can be run with: RUN"filename"
+
+
+The common programs to run are those with a .BIN or .BAS extension and usually the smaller 
+of the files on the disk image.
+
+
+On a few games you can type: RUN"disc or RUN"disk to start the game.
+
+
+If a directory listing cannot be obtained, then the disc might be copy-protected. 
+In this case, try: 
+
+|CPM
+
+
+| is obtained by pressing shift and the @ key together. Since the keyboard is mapped so the 
+keys are in the roughly same place as on a real Amstrad keyboard, then @ can be found 
+around the [,@,],# keys.
+
+The |CPM works by loading and executing the first sector on the first track of the disc.
+
+
+Snapshots, which contain a memory dump, CPU state and hardware state, can be run from a 
+command line interface with the following command: 
+
+mess cpc6128 -snap "snapshot name"
+
+
+The snapshot will start automatically.
+
+
+There are a few excellent utilities for creating and maintaining
+disk images for the Amstrad CPC emulators. Here are just a couple - 
+
+CPDRead   http://www.classicgaming.com/caprice/
+CPCfs     ftp://ftp.lip6.fr/pub/amstrad/emu-util/cpcfs085.zip
+
+
+Others can be found in the FAQ at http://genesis8.free.fr/
+
+
+
+Known Issues:
+
+Requires full keyboard emulation. At startup, full keyboard emulation mode is enabled by 
+default.  Whilst in full keyboard emulation mode, some key associated functionality may be 
+disabled (like the ESC key for EXIT). The keyboard emulation mode is toggled using the 
+scroll_lock key.   
+
+Runs many disk images and snapshots well.
+
+
+History and Trivia:
+
+The CPC6128 was a 8-bit Amstrad computer, produced in 1985. The computer was sold with a 
+colour monitor or a green screen monitor. This connected to a keyboard unit which had a 3" 
+drive in it. The monitor contained the power supply for the computer. Using this arrangement 
+only a single plug was required. The CPC6128 was the third in the CPC series. It had the same 
+hardware as the CPC464 and the CPC664.
+
+
+CPC464: 64k of ram, tape recorder built in.
+
+CPC664: 64k of ram, 3" disk drive built in
+
+CPC6128: 128k of ram, 3" disk drive built in.
+
+
+The Amstrad had a Z80 at it's core. It had a palette of 27 colours, produced from combinations 
+of 3 levels of r,g and b. It has three graphics modes. 640x200 in 2 colours (hi-res), 320x200 
+in 4 colours (medium res), 160x200 in 16 colours (lo-res).
+
+
+$end
+
+#---------------------------------------------------------------------------------------------#
+
+$info=cpc664
+$bio
+Amstrad/Schneider CPC 664
+
+
+Usage:
+
+The the emulation starts from the BASIC "Ready" prompt. 
+From here you can enter commands to access a disk image: 
+ 
+
+A directory listing can be obtained with: "CAT"
+
+
+A program can be run with: RUN"filename"
+
+
+The common programs to run are those with a .BIN or .BAS extension and usually the smaller 
+of the files on the disk image.
+
+
+On a few games you can type: RUN"disc or RUN"disk to start the game.
+
+
+If a directory listing cannot be obtained, then the disc might be copy-protected. 
+In this case, try: 
+
+|CPM
+
+
+| is obtained by pressing shift and the @ key together. Since the keyboard is mapped so the 
+keys are in the roughly same place as on a real Amstrad keyboard, then @ can be found 
+around the [,@,],# keys.
+
+The |CPM works by loading and executing the first sector on the first track of the disc.
+
+
+Snapshots, which contain a memory dump, CPU state and hardware state, can be run from a 
+command line interface with the following command: 
+
+mess cpc664 -snap "snapshot name"
+
+
+The snapshot will start automatically.
+
+
+There are a few excellent utilities for creating and maintaining
+disk images for the Amstrad CPC emulators. Here are just a couple - 
+
+CPDRead   http://www.classicgaming.com/caprice/
+CPCfs     ftp://ftp.lip6.fr/pub/amstrad/emu-util/cpcfs085.zip
+
+
+Others can be found in the FAQ at http://genesis8.free.fr
+
+
+
+Known Issues:
+
+Requires full keyboard emulation. At startup, full keyboard emulation mode is enabled by 
+default.  Whilst in full keyboard emulation mode, some key associated functionality may be 
+disabled (like the ESC key for EXIT). The keyboard emulation mode is toggled using the 
+scroll_lock key.   
+
+Runs many disk images and snapshots well.
+
+
+History and Trivia:
+
+The CPC664 was an 8-bit Amstrad computer, produced in 1985, with 64k of ram and a 3" disk 
+drive built in.
+
+$end
+
+#---------------------------------------------------------------------------------------------#
+
+$info=dream
+$bio
+ETI Dream
+
+
+early 6800 based computer
+
+
+Features:
+
+video connector
+chip8 interpreter
+
+
+Notes:
+
+seams to be very related to rca cosmac vip.
+emulator source available
+documented bios source available
+
+
+Emulators:
+
+Dream for DOS by Paul Robson
+
+$end
+
+#---------------------------------------------------------------------------------------------#
+
+$info=einstein
+$bio
+Tatung Einstein TC-01
+
+The Tatung Einstein is a 8-bit computer with hardware similar
+to the MSX-1. The computer was produced with two 3" disk drives and
+ran the CP/M operating system.
+
+The TC-01 is the first version of the hardware, with the 256 being
+the second version aimed more towards games.
+
+When this driver starts, and a disk is not in the drive, a internal
+monitor program will start. 
+
+To use this driver you will need the Xtal operating system disks
+which will start CP/M and from here you can run many CP/M based
+programs.
+
+You can put a disk image into the drive and boot CP/M by pressing
+CTRL+ALT together.
+
+Usage/Known Issues:
+
+The floppy disc emulation may not be fully working.
+Interrupts are not working properly.
+
+Thankyou to Chris Coxall for the schematics, a dump of the bios rom,
+and the Xtal operating system. He has been a great help with the development
+of this driver.
+
+Thankyou to Andrew Dunipace for help with the 80-column expansion card.
+
+
+$end
+
+#---------------------------------------------------------------------------------------------#
+
+$info=elf
+$bio
+RCA Cosmac ELF and ELF2
+
+
+very early computer
+
+
+Features:
+
+operation without builtin roms, you can enter your program directly with
+help of the CPU integrated dma.
+2 segment digits
+tape connector
+
+
+Notes:
+
+much like rca cosmac vip without video chip
+
+Info for building an elf/elf2 is at
+http://incolor.inetnebr.com/bill_r/computer_simulators.htm
+
+$end
+
+#---------------------------------------------------------------------------------------------#
+
+$info=ep128
+$bio
+Enterprise 128
+
+
+Usage:
+
+This computer has a built in word processor, from BASIC enter "type" to enter it.
+
+To load programs:
+
+You can type ":EXDOS" to enter a CLI interface where you can type EXDOS commands.
+If typing from BASIC you must enter ":" in front of EXDOS commands.
+
+The following EXDOS commands are allowed:
+
+CHDIR	[dir name]
+		- Change Dir.[dir name] does not need to be enclosed in quotes.
+DIR		
+		- show directory listing
+
+To run a program, enter from BASIC:
+
+RUN"filename" or
+
+LOAD"filename"
+
+
+Known Issues:
+
+Requires full keyboard emulation. At startup, full keyboard emulation mode is enabled by 
+default. Whilst in full keyboard emulation mode, some key associated functionality may be 
+disabled (like the ESC key for EXIT). The keyboard emulation mode is toggled using the 
+scroll_lock key.
+
+Some programs do not work well.
+
+Not all graphic modes are emulated.
+
+Interrupts are not emulated correctly.
+
+Samples and simple tone is supported, complex effects using ring modulation and filtering are not supported.
+
+Tapes are not supported.
+
+
+History and Trivia:
+
+The Enterprise 64 was a very long-awaited computer, two years between its announce and 
+its marketing ! It changed its name a lot of times : its first name was Elan 64, then 
+Flan, lastly Enterprise. It has great features, which wasn't found on all other home 
+computers like its interfaces and its great graphics and sounds capacities provided by 
+two special custom chips called "Nick" and "Dave". The Basic is supplied on a ROM 
+cartridge and can be easily replaced with an other language. This basic is a very 
+powerful structured basic with great graphic commands and can store several programs 
+simultaneously in RAM. It has a small word processing in ROM and up to 32 computers can 
+be linked together. Despite its great characteristics and all its interfaces, the 
+Enterprise 64 had few success. Several months later, a new model was launched : the 
+Enterprise 128 which is an Enterprise 64 with 128 KB RAM. 
+
+
+$end
+
+#---------------------------------------------------------------------------------------------#
+
+$info=exidy
+$bio
+Exidy Sorcerer (1979)
+
+
+Features:
+
+
+MESS Emulation State:
+
+$end
+
+#---------------------------------------------------------------------------------------------#
+
+$info=Famicom
+$bio
+Nintendo Famicom (1979)
+
+
+Features:
+
+
+MESS Emulation State:
+
+
+$end
+
+#---------------------------------------------------------------------------------------------#
+
+$info=europc
+$bio
+Schneider EUROPC
+
+
+IBM PC compatible computer "under the keyboard"
+
+
+Features:
+
+integrated cga/mda/hercules graphics adapter, connector for CGA and MDA/Hercules monitors
+multi language and keyboard support in bios
+integrated harddisk controller, connector for 2 external harddisks
+3 1/2 inch 720 kb disk drive, connector for 1 external disk drive
+integrated realtimeclock 
+setup memory
+Joystick/Mouse connector
+connector for external xt busplane
+connector for external power supply
+at type connector for rs232 serial port
+parallel port connector
+
+
+MESS Emulation State:
+
+basically the same as mess ibmpc emulation
+special keyboard emulated
+rough emulation of rtc, setup memory, special graphics adapter
+work stopped until more info or system software available
+
+
+$end
+
+#---------------------------------------------------------------------------------------------#
+
+$info=fx850p
+$bio
+Casio FX850P
+
+
+Pocket Computer/Scientific Calculator
+(fx880p is the big brother (better display, more ram?))
+
+
+Features:
+
+2 lines with 32 5x7 characters LCD display
+(some indicators and a 5 digit 7segment display)
+8 kb ram
+integrated speaker
+internal slot for memory expansion (32kb?)
+connector with support for rs232 and centronics
+(only level converter for rs232 needed)
+(only latch for centronics needed)
+2 3V CR2032 lithium as power supply
+1 3V CR2012 lithium as ram power supply
+
+MESS Emulation State:
+
+not started, need information about the hd62002 CPU
+(should be in the normal user manual!)
+
+$end
+
+#---------------------------------------------------------------------------------------------#
+
+$info=galaxy
+$bio
+Galaksija
+
+
+ZX81 class kit built computer from Yugoslavia (Serbia) invented by Voja Antonic.
+Also available in complete form.
+There were 7000 kit complets sold and approximately 10.000 made computers
+(including kit built ones).
+
+
+Features:
+
+Z80A 3.072MHz
+RAM 6kB
+text mode 32 x 16
+I/O ports Z80 Bus, tape, video
+
+
+Emulator:
+
+Galaksija emulator by Miodrag Jevremovic
+
+
+MESS Emulation State:
+
+tape not emulated
+video hardware not emulated (hack used)
+sound not emulated (if any)
+work stopped until info about Galaksija hardware is available
+
+
+$end
+
+#---------------------------------------------------------------------------------------------#
+
+$info=gameboy
+$bio
+Nintendo Game Boy (1989)
+
+
+The Game Boy was a huge success for Nintendo. It was the second portable system 
+created by Nintendo (the first being the Game & Watch series starting in 1980). The 
+original Game Boy was released in 1989 and allowed game players to play a huge library 
+of games away from home.  Games like Super Mario Land, The Legend of Zelda: Link's 
+Awakening and Tetris proved that quality games could be developed for portable use.
+
+Nintendo later released the Play it Loud Game Boy series in 5 colors, and the redesigned 
+slimmed down Game Boy pocket version was released in 1996.
+
+
+Features:
+
+CPU: 8-bit (Similar to the Z80 processor) at 4.194304MHz
+
+Main RAM: 8k Byte internal
+
+Video RAM: 8k Byte internal
+
+Video Display: Reflective LCD 160 x 144 dots (20 x 18 Tiles)
+
+Video Colors: 4 shades of gray
+
+Screen Size: 2.6"
+
+Max # of sprites: 40
+
+Max # sprites/line: 10
+
+Max sprite size: 8x16
+
+Min sprite size: 8x8
+
+Sound: 4 channels each of which can be mapped either to the left or to the right or to
+both speakers
+
+Communications: Serial port. Up to 4 Game boys can be connected together using this port.
+
+Baud rate and protocol: (?)
+
+Power: 6 VDC, 0.7 Watts (3 VDC 0.7W for Game Boy Pocket)
+
+4 AA Batteries ~ 35 hours 
+
+Rechargeable battery (NAKI) ~ 12 hours
+
+
+MESS Emulation State:
+
+Preliminary sound support only.  
+
+$end
+
+#---------------------------------------------------------------------------------------------#
+
+$info=gamegear
+$bio
+Sega Game Gear (1990)
+
+
+The Game Gear is the portable version of the Sega Master System, with slightly enhanced 
+graphics and stereo sound, but fully compatible (i.e. you could play SMS games on the GG
+with the use of a special adaptor). The Game Gear was sold 11 million times world-wide 
+(2 million in Japan, 9 million in the rest of the world). (note taken from www.eidolons-inn.de)
+
+
+Features:
+
+CPU:  4 MHz Zilog Z80
+
+Colors Palette: 512; 32 max on screen
+
+Resolution: 160x140 viewable from 256x224
+ 
+Sprite size: 8x8 , 8x16 (16x16 in doubled mode)
+ 
+Max # of sprites:  64 on screen; 128 in memory
+
+Sound:  6 channel FM, 2 channel noise - Stereo
+ 
+Battery life:  6 hours on 6 AA batteries
+
+
+Links:
+
+EIdolons inn - www.eidolons-inn.de
+
+
+MESS Emulation State:
+
+???
+
+$end
+
+#---------------------------------------------------------------------------------------------#
+
+$info=gbcolor
+$bio
+Nintendo Gameboy Color (1998)
+
+
+This is an update to the original Gameboy system that adds color capabilities as well as backwards
+compatibility.
+
+
+Features:
+
+Processor:  8 MHz Z80 work alike by Sharp with two processor modes: Single (4MHz) and double (8MHz)
+
+Video: 10, 32, or 56 on screen colors from a palette of 32000, Screen made by Sharp
+
+Sound: 4 Channel FM stereo
+
+Controls:  8 directional D-Pad, A, B, select, and start buttons. 
+ 
+Resolution: 160x144x56 colors
+
+Sprites: 40 - 8x16, 8x8 (four color sprites-4 colors- 1 being a transparent)
+
+Tiles:  512 on screen making use of the 16K of VRAM
+
+Cart Size: 256KBit - 16MBit for GB compatible games. Up to 64 MBit ROM & 128 KBytes RAM for CGB 
+cartridges, although 32Mbit ROM / 64K RAM carts are the largest currently manufactured.
+
+Serial port speed: 512 Kbps
+
+Power:  ~13 hours on 2 AA batteries or AC adapter.
+
+
+MESS Emulation State:
+
+???
+
+$end
+
+#---------------------------------------------------------------------------------------------#
+
+$info=genesis
+$bio
+Sega Megadrive/Genesis (1988)
+
+
+The Sega Genesis was released in Japan on the 29th of October 1988, and in the USA on the 1st
+of September 1989. At that time, no other console could compete with Segas powerful 16-bit 
+system, apart from the PC-Engine / TurboGrafx-16, perhaps. But due to a lack of third-party 
+support - especially with the arrival of the SNES, because many of the major game companies 
+were still bound to Nintendo because of the contracts they made in the NES era - the Genesis 
+never became as successful as Nintendos 16-bit console. Nevertheless, about 28.5 million 
+consoles were sold worldwide, compared to about 48 million SNES consoles. Looking at the 
+different regions of the world, the Genesis was most successful in the USA. It was quite strong in 
+Europe, too (especially Great Britain is famous for being the European Sega stronghold), but did
+not succeed very well in Japan, Nintendo's home country. It was definitely no mistake to buy the
+console, as I did in early 1990, shortly after Super Shinobi had been released.  Among the 
+approximetaly 1000 games which were produced during the genesis' lifespan (about 10 years 
+during 1988-1998) are a lot of evergreens which deserve to be played even today. (note taken 
+rom www.eidolons-inn.de)
+
+
+Features:
+
+Main Processor: Motorola M68000 (16-bit) at 7.67 Mhz
+ 
+Co-processor: Z80a at 3.58Mhz
+
+Sound Chips: YM2612 and a 4 channel TI PSG76489
+
+Ram: 64k (Plus 64k Ram for sound)
+
+Max Cart Size: ??
+
+
+Video:
+
+Max resolution: 320 X 224 
+
+Color palette: 512; 64 max on screen
+
+Max # of sprites: 80; 20 max per scanline
+
+Sound: Stereo FM-based sound with 8-bit audio samples 
+
+
+Usage:
+
+Under the "Options" menu, accessible by hitting TAB, you will find the following option: 
+
+
+"Country" - this allows you to alter the 'flavour' of Genesis, to either European, Japanese
+or American. Many cartridges compare their country codes with that of the Genesis itself and
+may behave differently, or lock up if the two types do not match.
+
+
+'Auto' attempts to auto-set the Genesis country code to the value the cartridge will appear
+to be checking for. This may not be 100% accurate, however.
+
+
+Links:
+
+EIdolons inn - www.eidolons-inn.de
+
+
+MESS Emulation State:
+
+Most games tend to run fairly well. Some have slight graphic glitches; incorrect colours part
+way down the screen or other bizarre effects. See genesis.crc for a partial list.
+
+
+Cartridges up to 32MBit (4MByte) are supported.
+
+
+The controller may not work well with some games. This will be resolved when more information
+is obtained. Similarly, 6-button joypads aren't emulated yet.
+
+
+Split screen effects and interlacing are not yet supported.
+
+
+Sprite/layer priority should be perfect.
+
+
+Sound is emulated at Z80 and PSG76489 level. 
+
+
+I still consider the Genesis driver extremely preliminary. I have a lot of further work to do 
+before I consider it anywhere near complete. My initial goal is to make it as compatible 
+as possible. Currently there is scope within the driver to handle split screen colour changes/any
+ VDP effect, interlacing, without rewriting. The graphics renderer emulates VDP at scanline 
+level, and does not use tile-based methods.
+
+
+Wanted: Any Sega Megadrive information specifically, some of the finer points of DMA transfer,
+ and access of the 68K memory map by the Z80! Information is extremely sparse; typically the
+ same three-four documents, with parts incomplete, conflicting, and corrupted. Generally, points
+ which conflict with themselves in the documentation available on the net...
+
+$end
+
+#---------------------------------------------------------------------------------------------#
+
+$info=geneve
+$bio
+Myarc Geneve 9640
+
+
+Known Issues:
+
+Wait states are not emulated (except for the speech synthesizer), so the Geneve
+will always run at full speed.
+
+The keyboard does not seem to work properly in BHDMV.
+
+
+Usage:
+
+This driver emulates a Geneve with (almost) 2Mbytes of RAM, 4 floppy drives,
+and a mouse.  3 Hard Disk are supported by the HFDC disk controller.
+
+You need an MDOS disk image to boot the Geneve.  Insert the image and run the
+computer.
+
+
+History and Trivia:
+
+Myarc is known as the builder of several fine extension cards for the TI99.
+They managed to remain in business for several years after TI abandonned its
+TI99 series of computers in 1983, and, in 1987, they even introduced their
+Geneve 9640 computer.  The computer is a single card to be inserted in the TI
+PEB as a replacement of the TI99 console.  The card has standard connectors to
+attach a PC-XT keyboard and a monitor, but no other I/O ports, as the Geneve
+relies on expansion cards in the PEB to provide disk and RS232 interfaces.  The
+Geneve features a TMS9995 at 12MHz, a V9938 VDP, an SN76496 sound generator
+(compatible with TMS9919), a MM58274 RTC, 512 kbytes of 1-wait-state CPU RAM
+(expandable to almost 2 Mbytes), 32 kbytes of 0-wait-state CPU RAM (expandable
+to 64 kbytes), and 128 kbytes of VRAM (expandable to 192 kbytes).  Thanks to
+the GenMod modification, the 512 kbytes of on-board RAM can be disabled so that
+0-wait-state RAM may be used instead, but this breaks the TI99 emulation mode.
+
+Although the Geneve is compatible with the TI99, it is a different machine.  It
+has a disk-based Operating System that looks like MS-DOS.  It has two operating
+modes: a native mode, and a TI99-compatible mode.  The TI99 mode is normally
+entered by running the GPL program: the Geneve can run most TI99 programs in
+this mode, which uses some special areas of CPU RAM to emulate GROMs and
+cartridge ROMs.
+
+$end
+
+#---------------------------------------------------------------------------------------------#
+
+$info=hp48s
+$bio
+Hewlett Packard HP48S/SX/G/GX
+
+
+Scientific Calculator
+
+S 32kb ram
+SX 128KB ram
+G 1MB rom, 32kb ram
+GX 128kb ram
+
+
+Features:
+
+131x64 monochrome LCD display
+memory/cartridge slot
+batterie slot
+infrared interface
+serial rs232 interface
+
+
+Notes:
+
+on and - decreases contrast
+on and + increases contrast
+
+
+Official and legal HP rom images:
+
+http://www.hpcalc.org/hp.php
+
+
+MESS Emulation State:
+
+not working
+(g memory management not finished)
+(s is a few bugfixes from working)
+
+$end
+
+#---------------------------------------------------------------------------------------------#
+
+$info=i286
+$bio
+IBM8530 286 (Personal System 2 Model 30 286)
+
+
+concrete IBM AT model
+
+Features:
+
+80286 with 10 mhz
+socket for 80287
+512kb ram (expandable to 1mb, 2mb or 4mb) (4? 30pin 8?bit simms)
+3 isa slots
+integrated vga adapter
+ps2 keyboard and mouse connectors
+3 1/2 inch high density (1.44mb) floppy disk drive
+1 parallel port
+1 serial port (pc style dsub)
+mf2 keyboard with 102 keys
+ps2 mouse with 2 buttons
+greyscale or color vga monitor
+optional: ethernet adapter with bnc (coax) and rj45 (twisted pair) connectors
+
+
+MESS Emulation State:
+
+basically the same as ibmat emulation
+ps2 mouse not emulated now
+vga emulation incomplete
+needs i286 core v1.5
+
+$end
+
+#---------------------------------------------------------------------------------------------#
+
+$info=i8530
+$bio
+IBM 8530 (Personal System 2 Model 30)
+
+
+concrete IBM XT model
+
+
+Features:
+
+8086 with 8 mhz
+socket for 8087
+640mb ram
+3 8 bit slots
+integrated mcga adapter (vga style connector for vga monitor)
+ps2 keyboard and mouse connectors
+2 3 1/2 inch double density (720kb) floppy disk drive
+in some models instead of the 2nd disk drive a 20mb or 30mb harddisk drive
+1 parallel port
+1 serial port (pc style dsub)
+ethernet adapter with bnc (coax) and rj45 (twisted pair) connectors
+mf2 keyboard with 102 keys
+ps2 mouse with 2 buttons
+greyscale or color vga monitor
+
+$end
+
+#---------------------------------------------------------------------------------------------#
+
+$info=ibmat
+$bio
+IBM AT
+
+
+extended IBM PC
+
+
+Features:
+
+basically an IBMPC,
+80286 processor
+16 mb memory space
+16 bit wide, 24 bit wide slots (xt downwards compatible)
+2nd programmable interrupt controller
+16 bit direct memory access controller
+realtimeclock and setup memory
+(changed keyboard and keyboard circuits on board)
+high density supporting disk controller
+hard disk support in bios
+
+
+Emulators:
+
+Virtual PC for Linux, NT (commercial, very usable)
+Bochs
+
+
+MESS Emulation State:
+
+basically the same as ibmpc emulation
+rough emulation of keyboard controller
+rough emulation of keyboard
+rough emulation of dma chips
+rough emulation of pic chips
+incomplete emulation of CPU
+no support for high density disks
+no support for at harddisks
+needs i80286 v1.5
+
+$end
+
+#---------------------------------------------------------------------------------------------#
+
+$info=ibmpc
+$bio
+IBM PC
+
+
+the grandfather of the now common personal computer
+
+
+Features:
+
+8088 CPU
+expanded through several slots for interface cards
+programmable interrupt controller
+direct memory access controller
+support for a tape drive on the motherboard of the first series
+even elementary equipment is not on the motherboard
+even a display adapter must be plugged in
+
+Features IBMXT:
+
+8086 CPU (16 bit data bus)
+
+
+MESS Emulation State:
+
+rough emulation of the keyboard controller
+rough emulation of the pic chip
+rough emulation of the dma chip
+no emulation of the tape drive
+mono display adapter emulated
+color graphics adapter emulated
+hercules graphics adapter emulated
+rough ega/vga emulation
+1 floppy disk controller emulated
+1 harddisk controller emulated
+rough emulation of up to 4 serial ports emulated
+rough emulation up to 3 parallel ports emulated
+1 serial mouse emulated
+rough emulation of 1 game port and its 2 joysticks
+
+
+$end
+
+#---------------------------------------------------------------------------------------------#
+
+$info=imbpcjr
+$bio
+IBM PC Junior
+
+
+enhanced IBM PC for home use
+
+
+Features:
+
+basically an IBM PC
+support for cartridges
+enhanced cga graphics adapter with additional graphics modes (160x200x4, 320x200x4, 640x200x2)
+integrated sound chip
+unique keyboard
+integrated joystick support
+
+
+MESS Emulation State:
+
+basically the same as mess ibmpc emulation
+pc junior graphics emulated
+pc junior sound emulated
+work stopped until complete bios roms are available
+
+
+$end
+
+#---------------------------------------------------------------------------------------------#
+
+$info=intv
+$bio
+Mattel Intellivision (1979)
+
+
+Usage/Known Issues:
+
+This driver is almost complete.
+ 
+
+Still TBD are:
+
+collision detection - 16-way controller mapping - default mapping of the right player 
+controller - Only .ROM format cartridges (Intellicart) are supported in this release.
+
+  
+$end
+
+#---------------------------------------------------------------------------------------------#
+
+$info=intvkbd
+$bio
+Mattel Intellivision + Keyboard Component (1981)
+
+
+Usage/Known Issues:
+
+This driver is almost complete.  The tape drive is not yet supported.
+
+The keyboard component has two cartridge slots - one to replace the occupied intv cart slot, 
+and one for new keyboard carts (BASIC).   If you want to use the BASIC cart at startup, you
+must specify it as the second cart, even if the first cart slot is unused. 
+(ex. -cart dummy -cart basic.bin)  Some tapes require the BASIC cartridge.
+Also, there is currently no mapping to the normal intellivision hand controllers yet, when 
+using the keyboard component.  This driver uses the full keyboard, to toggle to the standard
+MESS keys, hit scroll-lock.
+
+  
+$end
+
+#---------------------------------------------------------------------------------------------#
+
+$info=intvsrs
+$bio
+Mattel Intellivision - Sears version (19??)
+
+
+Usage/Known Issues:
+
+This is the Sears version of the Mattel Intellivision.  Please see the base (intv) system 
+info for current status of this driver.
+
+  
+$end
+
+#---------------------------------------------------------------------------------------------#
+
+#$info=jaguar
+#$bio
+#Atari Jaguar (1993)
+
+
+#Features:
+
+
+#Usage/Known Issues:
+
+
+#MESS Emulation State:
+#nowhere near working yet, but the title screen now loads
+
+  
+#$end
+
+#---------------------------------------------------------------------------------------------#
+
+$info=jupiter
+$bio
+Jupiter Cantab Jupiter Ace (1981)
+
+
+Features:
+
+
+MESS Emulation State:
+
+$end
+
+#---------------------------------------------------------------------------------------------#
+
+$info=kaypro
+$bio
+Kaypro IIx (kaypro)
+
+
+Usage/Known Issues:
+
+Requires full keyboard emulation. At startup, full keyboard emulation mode is enabled by 
+default. Whilst in full keyboard emulation mode, some key associated functionality may be 
+disabled (like the ESC key for EXIT). The keyboard emulation mode is toggled using the 
+scroll_lock key.
+
+
+As of 37b4, this driver is once again working. 
+
+  
+$end
+
+#---------------------------------------------------------------------------------------------#
+
+$info=kc85_3
+$bio
+VEB Mikroelektronik KC 85/3 (1981)
+
+
+Features:
+
+
+MESS Emulation State:
+
+$end
+
+#---------------------------------------------------------------------------------------------#
+
+$info=kccomp
+$bio
+KC Compact
+
+
+Usage:
+
+Image loading is the same as for the Amstrad CPC series.
+
+
+Known Issues:
+
+Requires full keyboard emulation. At startup, full keyboard emulation mode is enabled by 
+default. Whilst in full keyboard emulation mode, some key associated functionality may be 
+disabled (like the ESC key for EXIT). The keyboard emulation mode is toggled using the 
+scroll_lock key.
+
+Z8536 CIO is not emulated
+
+History and Trivia:
+
+The KC Compact is a clone of the Amstrad CPC series, made in East Germany
+by VEB Mikroelektronik. It was made in 1989 to celebrate 30 years of the GDR
+(German Democratic Republic). Soon after the Berlin wall came down, east and west
+merged, and production stopped.
+
+The system contains a hacked Amstrad CPC 6128 Operating System and the
+Amstrad CPC 6128 BASIC. Unlike the CPC, this system didn't come with a built in 
+disc drive or cassette unit, and did not require a special monitor. 
+
+The base unit can connect to a TV through a aerial or scart lead. 
+
+Not many of these systems were produced and they are rare.
+
+The Amstrad CPC had a gate array chip which contained the logic for the
+palette, mode display, rom paging, ram paging and interrupt
+system. This is emulated in the KC Compact using a lot of TTL logic chips
+and a Zilog 8536 chip.
+
+Hardware that was designed for the CPC systems should work on the KC
+Compact, however, since the KC Compact has a different
+expansion port layout, a adaptor must be made.
+
+$end
+
+#---------------------------------------------------------------------------------------------#
+
+$info=kim1
+$bio
+Commodore/MOS Kim-1
+
+
+Usage:
+
+key   name  description
+
+-----------------------
+
+F1     AD    address mode
+
+F2     DA    data mode
+
+F3     RS    reset
+
+F5     GO    execute from address
+
+F6     PC    program counter (hmm.. whatever)
+
+F7	 ST    step (note: NMI handling for K7 missing)
+
+ENTER  +     increase address
+
+0-F    hex   hex digits
+
+
+Known Issues:
+
+This driver supports the backdrop image of the KIM-1, and code images in .kim format.
+
+
+$end
+
+#---------------------------------------------------------------------------------------------#
+
+$info=laser110
+$bio
+Video Technology Laser 110 (1983)
+
+
+Features:
+
+
+MESS Emulation State:
+
+$end
+
+#---------------------------------------------------------------------------------------------#
+
+$info=laser210
+$bio
+Laser 210 Series/Dick Smith VZ-200
+
+
+Usage:
+
+Basic programs start with RUN.
+
+Other programs usually start with X=USR(0)
+
+X=USR(0) can be typed out with the following PC keystrokes: x, shift -, u, s, r, shift 8, 0, 
+shift 9, enter.
+
+
+History and Trivia:
+
+The laser 200 was the successor of the Laser 100/110 (which had only monochrome graphic 
+modes).
+
+
+Adman Harbison says "The Video Technology Laser 200 (and the Laser 300) were marketed in 
+Australia by Dick Smith Electronics and badged as the VZ200 and the VZ300 computers.  
+For memory the computers were exactly the same, although he can not be too sure.  
+Some of the peripherals that I got while I had such a machine were things like a 16Kb 
+expansion cartridge, a printer/plotter which wasn't much bigger than those little 
+calculators that print out accounts etc. and some joysticks. The trouble with these 
+computers was that they tended to die after a couple of years use. But they were cheap and 
+came with a few software titles."
+
+
+$end
+
+#---------------------------------------------------------------------------------------------#
+
+$info=laser310
+$bio
+Video Technology Laser 310 (1983)
+
+
+Features:
+
+
+MESS Emulation State:
+
+$end
+
+#---------------------------------------------------------------------------------------------#
+
+$info=laser350
+$bio
+Video Technology Laser 350 (1983)
+
+
+Features:
+
+
+MESS Emulation State:
+
+$end
+
+#---------------------------------------------------------------------------------------------#
+
+$info=lisa2
+$bio
+Apple Lisa
+
+
+Usage:
+
+This driver is still buggy. Neither the hard drive nor the serial port are supported. There are
+many other bugs remaining with MMU emulation. Only Macworks will boot.
+
+When you boot up the Lisa, you can see a self-test progress indicator. At least one test will fail:
+you must discard the error message by selecting the 'Ignore' or 'Start-up from...' button. Then,
+you get a boot device menu. Select the floppy drive unit, since it is the only available device.
+If the mouse temporarily refuses to work, you may use the keyboard shortcuts Apple+2 and Apple+3
+(the Apple key should be mapped to Control; you must use the numeric keys on the main keyboard, not
+on the numeric keypad). If the computer does boot, you will see an icon representing a weird floppy
+disk with a cross (maybe it actually represents a twiggy disk).
+
+
+History and Trivia:
+
+The Lisa project started in the summer of 1979. At the time, the idea was merely designing
+a powerful business computer, with scheduled release in march 1981. After his legendary visit
+to the Xerox PARC research center, Steve Jobs realized the GUI was the future of computing.
+So, in March 1980, a GUI was added to the Lisa specs.
+
+Despite huge support from Apple, the project got behind schedule, and Lisa was introduced
+on January, 19th, 1983.
+
+
+The Lisa was an impressive computer for its time. It had TONS of memory (1Mb on Lisa 1),
+a high-resolution graphic display, and it was fairly expandable. Its OS (weirdly called
+"Lisa 7/7 Office System") featured a complete GUI, and full preemptive multitasking
+with memory protection (something neither Windows 98 nor MacOS offer!).
+Its 68000 CPU was one of the fastest microprocessor in its time.
+
+Unfortunately, Lisa was never too successful. It was quite expensive, and relatively few units were
+sold (possibly about 10,000 Lisa 1 and 80,000 Lisa 2). Little software was developed for it.
+Also, it was extremely resource hungry: it was reportedly slow, and its memory requirements were
+the major cause for its high price.
+
+
+On 24th January 1984, Lisa 1 was replaced by Lisa 2, with 3.5" floppies and several small
+hardware changes. In January 1985, Lisa 2 was replaced by Macintosh XL, which had a modified video
+hardware, and used a variant of the Macintosh system instead of the 7/7 Lisa OS. Mac XL was
+discontinued in May 1985 (although it was still available at much later dates). Rumor has it that
+an enhanced, 68020-based Lisa was in development when Apple discontinued the Lisa.
+
+Note that, contrary to a common belief, the Macintosh is not a mere offspring of the Lisa, since
+both projects were led simultaneously. While the Macintosh borrowed many ideas from the Lisa project
+(which had more financial resources), the reverse is often true, too: for instance, the Macintosh
+included a GUI from the beginning.
+
+
+The significance of Lisa:
+
+Lisa is a milestone in the history of computing. Arguably, the Xerox PARC research center invented
+most GUI concepts (along with Object-Oriented programming and Ethernet) 10 years before Lisa was
+introduced. However, although Xerox research was public, and some Xerox Altos were actually sold,
+or given to universities, these experiments remained little known, and raised little interest.
+I guess this was because computing was mostly the field of highly-trained professionals who did
+not care about ease of use (you know, the same kind of guys who laughed at Macintosh and worshipped
+the early IBM-PCs). So, Lisa made the world aware that GUI could exist, all the more since Apple
+was a major computer maker. Also, Lisa (along with Macintosh, Atari ST and Commodore Amiga)
+introduced GUI to hobbyists and home computer users, which enabled GUI to live.
+
+$end
+
+#---------------------------------------------------------------------------------------------#
+
+$info=lviv
+$bio
+PK-01 Lviv (1989)
+
+
+Features:
+
+
+MESS Emulation State:
+
+$end
+
+#---------------------------------------------------------------------------------------------#
+
+$info=lynx
+$bio
+Atari Lynx (1989) and Atari Lynx II (1990)
+
+
+The Lynx was the world's first hand-held color video game system.  Sold by Atari (developed by 
+Epyx a few years earlier), the Lynx offered true multi-player competition, built-in 3D and 
+distortion graphic effects, reversible controls, and fast arcade action.  The system featured 
+some accurate arcade translations such as Joust, Rampart, and Klax.  The Lynx II is a lightweight
+redesign and features stereo sound and shorter power down timer.  Around 1993 Atari ceased marketing
+the Lynx and focused on their new console, the Jaguar. (Notes taken from FAQ and Atari Age)
+
+
+Features:
+
+Two 16-Bit custom CMOS chips running at 16Mhz (named Mikey and Suzy)
+Sound: 8 bit DAC for each channel; 4 channels integrated stereo speaker (wired for mono in original)
+Screen: 160 x 102 (horz) 60.00 Hz 
+Color: 4096 colors, 16 max per scanline
+Others: 64KB RAM of 120ns DRAM
+
+
+Headphone port (mini-DIN 3.5mm stereo; wired for mono on the original Lynx)
+ComLynx (multiple unit communications, serial)
+Power (9V DC, 1 A)
+Game cartridge slot
+Battery holder (six AA) ~4-5 hours
+
+
+Size: 9.25" x 4.25" x 2" (10.75" x 4.25" x 1.5" for original Lynx)
+Screen: 3.5" diagonal (3.25" x 1.88" approx.) 
+
+
+Notes:
+
+Lynx is flip-able for optimal support of left and right hand players (hold down pause and press 
+option 2 in many games) Some games want to be rotated by 90 degree
+
+
+Links:
+
+Atari age - www.atariage.com
+
+FAQ on Lynx - www.digiserve.com/eescape/atari/Atari.shtml
+
+
+MESS Emulation State:
+
+several cartridges playable
+
+blitter imperfect
+
+timer system incomplete
+
+audio imperfect
+
+no serial port emulation
+
+Lynx II bios is needed.
+
+$end
+
+#---------------------------------------------------------------------------------------------#
+
+$info=mac512ke
+$bio
+Apple Macintosh 512ke
+
+
+History and Trivia:
+
+Introduced on 14th April 1986, the Macintosh 512ke was essentially a Macintosh 512k with
+the same 128k ROMs and double-sided 800 KB internal floppy drive as the Mac Plus.
+
+It was sold as a poor man's Macintosh. Also, any existing Macintosh 512k could be upgraded to 512ke.
+(They could be upgraded to a Mac Plus, too, but this involved changing the motherboard.)
+
+Since this model was discontinued a few months later (in August 1986), it may have just been
+a way for Apple to get rid of its excess Macintosh 512 motherboard. Or maybe they realized that
+512 kb of RAM were not enough to run real-world Macintosh programs.
+
+$end
+
+#---------------------------------------------------------------------------------------------#
+
+$info=macplus
+$bio
+Apple Macintosh Plus
+
+
+History and Trivia:
+
+Introduced on 16th January 1986, the Macintosh Plus was the first real improvement of
+the original Macintosh 128k (The Macintosh 512k was just a Mac 128k with 512 kb of RAM). It had
+several new features.
+
+The extended ROM held the new version of operating system: it supported hard disk units,
+the SCSI bus, and the new file system: HFS (Hierarchical File System), along with many other
+new features (Time Manager...). Additionally, various routines and managers previously located
+in RAM (Appletalk manager, RAM Serial Driver, Standard File Package...) had been moved to ROM.
+
+The new floppy disk unit could use double-sided 800 kb disks (compared to single-sided 400 kb
+for the Macintosh 128k). It came with 1 Mb of RAM, and could easily be expanded to 4 Mb, using
+standard 1Mb SIMMs. It had an enhanced keyboard with a numeric pad and last but not least, it had
+a SCSI 1 interface which allowed to connect several high speed peripherals (maximal transfer rate of
+312 kbyte/s on Mac Plus - which is incredibly inefficient) such as hard disks and scanners.
+
+Although the Mac Plus was made obsolete in march 1987 by the new Macintosh series (Macintosh SE
+and the Macintosh II), it remained in production as a cheaper alternative until the introduction
+of Macintosh Classic on 15th october 1990. This makes Macintosh Plus the longest lived Macintosh
+ever produced.
+
+$end
+
+#---------------------------------------------------------------------------------------------#
+
+$info=macxl
+$bio
+Apple Macintosh XL
+
+
+Usage:
+
+This driver is still buggy. Neither the hard drive nor the serial port are supported. There are
+many other bugs remaining with MMU emulation. Only Macworks will boot.
+
+When you boot up the Lisa, you can see a self-test progress indicator. At least one test will fail:
+you must discard the error message by selecting the 'Ignore' or 'Start-up from...' button. Then,
+you get a boot device menu. Select the floppy drive unit, since it is the only available device.
+If the mouse temporarily refuses to work, you may use the keyboard shortcuts Apple+2 and Apple+3
+(the Apple key should be mapped to Control; you must use the numeric keys on the main keyboard, not
+on the numeric keypad). If the computer does boot, you will see an icon representing a weird floppy
+disk with a cross (maybe it actually represents a twiggy disk).
+
+If you boot MacWorks, you should eventually see a floppy disk icon with a question mark. At this
+point, it is time to insert a bootable Macintosh image: to do so, use the file manager or whatever
+osd equivalent you may have.
+
+
+History and Trivia:
+
+In late 1984, Apple's financial health was questionable, and Apple came to the conclusion that
+it did not make sense to support both Lisa and Macintosh.
+
+Therefore, on 1st January 1985, Apple discontinued the Lisa. However, they released
+a program named MacWorks, which enabled a Lisa to run the Macintosh operating system.
+
+The same day, they introduced a new variation of the Lisa hardware, named Macintosh XL,
+which was a Lisa 2 whose video hardware was modified in order for it to display square pixels.
+Additionally, existing Lisas could be upgraded to Macintosh XL. This modification improved
+the appearance of Macintosh programs; however, it prevented the Macintosh XL from running
+the Lisa operating system, or any Lisa program, for that matter. Needless to say, it would have
+been very easy to patch the Lisa OS to support the new video resolution: this was simply not done,
+since Apple had discontinued the Lisa OS.
+
+Macintosh XL was not very successful: Apple discontinued it in May 1985, and the remaining
+stocks were sold to another company (Sun Remarketing) which did manage to sell them.
+
+Though ill-fated, the Macintosh XL was an interesting machine. It was slow, slower than even
+the original Macintosh, but it supported up to 2 Megabytes of RAM (while the original Macintosh
+came with 128kb or 512kb only), had a larger screen, supported hard drives units (which
+the original Macintosh could not do until the Hard Disk 20 was introduced), and it had three
+expansion ports (it was thus the first expandable Macintosh, more than 2 years before Macintosh II
+and Macintosh SE were introduced). A number of these was bought by developers who needed
+the hard drive and appreciated the larger screen (anyway, Macintosh development was originally done
+on Lisa, so the transition from Lisa Workshop on Lisa to Macintosh Programmer Workshop on
+Macintosh XL was a natural one).
+
+$end
+
+#---------------------------------------------------------------------------------------------#
+
+$info=max
+$bio
+Commodore Max
+
+
+History and Trivia:
+
+Delivered in japan only?
+
+ (vic10,ultimax,vickey prototype)
+
+ (all modules should work with c64)
+
+ cartridges necessary (nothing works without cartridge)
+
+ low cost c64
+
+ flat design
+
+ only 4 kbyte sram
+
+ simpler banking chip
+
+  no portlines from CPU
+
+ only 1 cia6526 chip
+
+  restore key connection?
+
+  no serial bus
+
+  no userport
+
+ keyboard
+
+  restore key in pictures!
+
+ tape port
+
+ 2 gameports
+
+  lightpen (port a only) and joystick mentioned in advertisement
+
+  paddles
+
+ cartridge/expansion port (some signals different to c64)
+
+ no rom on board (minibasic with kernel delivered as cartridge?)
+
+
+$end
+
+#---------------------------------------------------------------------------------------------#
+
+$info=mbee
+$bio
+Applied Technologies Microbee
+
+
+Features:
+
+
+MESS Emulation State:
+
+$end
+
+#---------------------------------------------------------------------------------------------#
+
+$info=mc10
+$bio
+Tandy Radio Shack MC-10 (1983)
+
+
+Features:
+
+
+MESS Emulation State:
+
+$end
+#---------------------------------------------------------------------------------------------#
+
+$info=microtan
+$bio
+Tangerine Microtan 65 (1979)
+
+
+Features:
+
+
+MESS Emulation State:
+
+$end
+
+#---------------------------------------------------------------------------------------------#
+
+$info=mk1
+$bio
+Super System 1/MK I
+
+
+early chess computer
+
+sold from several firms
+in Germany as MK1
+
+
+Features:
+
+4 7segment led digits
+plug for external power supply
+
+
+Instructions:
+
+number with dot means thinking about move?
+4 dots mean ready for input?
+
+power up prompt L asks for level?
+answering with 5 prompts you with bp
+than you can play as white and enter your move (enter is d/play)
+
+
+MESS Emulation State:
+
+operating instructions needed!
+not working (CPU core problem?)
+
+
+$end
+
+#---------------------------------------------------------------------------------------------#
+
+$info=mk2
+$bio
+Super System 2/MK 2
+
+
+early chess computer
+
+sold from several firms
+in Germany as MK2
+
+2 designs known, seams to be functional the same
+
+
+Features:
+
+4 7segment led digit
+integrated speaker
+plug for external power supply
+
+
+Notes:
+
+for the computer to start as white
+ switch to black (h enter)
+ swap players (g enter)
+Pinout and instructions for reading roms are in messroms.txt
+
+
+MESS Emulation State:
+
+Random number generation is not accurate (rriot6530 emulation)
+led emulation not accurate (noticeable while computer is thinking)
+
+
+$end
+
+#---------------------------------------------------------------------------------------------#
+
+$info=msx
+$bio
+MSX 1 Class Computers
+
+
+The MSX driver currently emulates the MSX1, international, UK, korean and Japanese models.
+
+
+Not emulated:
+Printer port, diskdrives, megaRAM, Sound Cartridge (SCC+), MSX2, etc..
+
+
+Cartridge emulation:
+The MSX has 64kB RAM, like most (by far) MSX1 computers. It is located in slot 3. Two 
+cartridges are allowed: the first in slot 1 and the second in slot 2. So subslots aren't 
+emulated (yet). 
+
+
+The msx.crc file is important. The last field on every line specifies the type of ROM mapper. 
+See msx.crc for more information.
+
+
+Sound emulation:
+The standard sound chip, the PSG (AY8910) is emulated, so is the extension that was included 
+in some Konami cartridges: the SCC. The keyclick (PPI) is also emulated, as is the FM-PAC 
+(you'll need the fmpac.rom of the original Panasonic FM-PAC for this). Unfortunately the 
+YM2413 emulation in MAME does not emulate the volumes correctly.
+
+
+Last but not least, the DAC in Konami's Synthesizer is emulated, and the SIMPL (DAC on the 
+printer port). The DAC in Konami's Matjusushi is also emulated, but the driver lacks MSX2 
+support.  
+
+
+SRAM in cartridges:
+A number of cartridges (Hydlide 2, Xanadu, The Game Master 2 and more) had on-board sram. 
+This sram is automagically saved as a MEMCARD.  
+
+
+Tape emulation:
+Unlike other MSX emulators, the tape emulation is not done by trapping BIOS calls. In our 
+opinion this is an evil kludge; apart from that, our setup does have an advantage. Tapes with 
+a custom loader (using direct access to the hardware) will work fine. It is done by saving 
+the tape as a .wav file. In principle, you could record a tape to .wav, and load them into 
+MESS.
+
+
+History and Trivia:
+
+In the early 80's, there were a lot of home computers, Microsoft and a Japanese company 
+called ASCII corporation (directed by Kay Nishi) decided then to create an industry standard 
+for the home computers: MSX (for MicroSoft eXtended). The new standard was based on an 
+existing computer: The Spectravideo SV 318. Microsoft designed the MSX 1 computers and the 
+first version of the OS: MSX DOS 1 (which looks like earlier versions of MS DOS).
+
+
+Almost all Japanese and Korean computer companies made their own MSX computers (except 
+perhaps NEC). Bill Gates was then very confident about the future of the MSX standard. 
+Spectravideo (one of the MSX companies) made a 80 columns card and adapted CP/M on the MSX.
+A lot of software(especially a lot of games from Sega, Konami, Taito, Ascii,...) and 
+hardware was developed for this standard. Despite all its qualities, the MSX family didn't 
+have great success in USA, however was pretty known in Europe (Netherlands and France), in 
+South America (Brazil) and USSR. This standard was replaced in 1985 by MSX 2. 
+
+
+A list of known MSX compliant machines:
+
+
+Canon (Japan)
+
+V-8: 16kB RAM (other source says 32kB RAM)
+V-10: 16kB RAM
+V-20: 64kB RAM
+
+
+
+Casio (Japan)
+
+MX-10: 16kB RAM (other source says 64k), docking station available
+MX-101: 16kB RAM (other source says 64k)
+PV-7: 32kB RAM
+PV-16: 16kB RAM
+
+
+
+Daewoo/Yeno (Korea)
+
+Ce-Tec MPC-80: 64kB RAM (other source says 32KB)
+DPC-100: 16kB RAM, built in loudspeaker, available in green, blue or silver
+DPC-200: 64kB RAM
+DPH-64: 64kB RAM (other source says 32kB RAM)
+DPH-?: 64kB RAM, built in software, Arabic version
+IQ-1000: 32kB RAM, produced for Korea
+MX64: 64kB RAM
+
+
+
+Dragon (Spain)
+
+MSX-64: 64kB RAM
+
+
+
+Dynadata (MSX from Daewoo in Spain)
+
+DPC-200: 64kB RAM
+
+
+
+Fenner (Italy?)
+
+FPC-500: 64kB RAM
+
+
+
+Fujitsu (Japan)
+
+MB-H1: ??kB RAM
+FM-X: 16kB RAM
+
+
+
+General (Japan)
+
+PAXON-PC K50: ??kB RAM, separate keyboard, computer and monitor in one box
+PAXON-PC T50: 16kB RAM, RGB connector
+PAXON-PC T55: 32kB RAM, RGB connector
+
+
+
+Goldstar (Korea)
+
+FC-80: ??kB RAM
+FC-100: 16kB RAM
+FC-200: 64kB RAM (with hole for light-pen)
+
+
+
+Gradiente (Brazil)
+
+XP-800 Expert 1.0: 64kB RAM, separate keyboard
+XP-800 Expert 1.1: 64kB RAM, separate keyboard (with fixed ASCII tables, grey colour)
+Expert plus: 64kB RAM, separate keyboard (black colour)
+Expert DD plus: 64kB RAM, separate keyboard, 3,5" floppy disk drive (black colour)
+
+
+
+Hitachi (Japan)
+
+Hint: 16kB RAM
+MB-H1 (Humanicatio): 32kB RAM, built in software (Sketch and Music)
+MB-H1E: 16kB RAM
+MB-H2: 64kB RAM, built in tape recorder
+MB-H21: ??kB RAM
+MB-H25: ??kB RAM
+MB-H50: 64kB RAM
+MB-H80: 64kB RAM, also built in software (Sketch and Music)
+
+
+
+JVC/Victor (Japan)
+
+HC-5: 32kB RAM (other source says 16kB RAM)
+HC-6: 16kB RAM
+HC-6AV: 32kB RAM, RGB connector
+HC-7: 64kB RAM (Japanese version)
+HC-7E: 64kB RAM (English version, other source says 32KB RAM)
+HC-7GB: 64kB RAM
+HC-30: 32kB RAM
+HC-60: 32kB RAM
+
+
+
+Kyocera (Japan)
+
+YC-64: 64kB RAM
+
+
+
+Mitsubishi (Japan)
+
+Letus: 16kB RAM
+ML-8000: 32kB RAM
+ML-F48: 32kB RAM
+ML-F80: 64kB RAM
+ML-F110: 16kB RAM
+ML-F120(D): 32kB RAM
+ML-F8000: 32kB RAM
+ML-FX1: 64kB RAM
+ML-FX2: 64kB RAM, built in software
+
+
+
+National (Japan)
+
+CF-1200: 16kB RAM
+CF-2000: 16kB RAM
+CF-2700: 32kB RAM
+CF-3000: 64kB RAM
+CF-3300: 64kB RAM
+CF-4000: ??kB RAM
+FS-1300: 64kB RAM
+FS-4000: 64kB RAM
+
+
+
+Olympia (France)
+
+PHC-2: ??kB RAM, same as some Sanyo?
+PHC-28: 32kB RAM, same as Sanyo's PHC-28S
+
+
+
+Panasonic/Matsushita (Japan)
+
+CF-2000: 16kB RAM
+CF-2700: 64kB RAM, same as Sanyo MPC-64
+CF-3000: ??kB RAM
+CF-3300: ??kB RAM
+
+
+
+Perfect (Daewoo in Kuwait)
+
+Perfect1: 64kb RAM, 1 slot, no reset, built in software
+
+
+
+Philips (The Netherlands)
+
+VG-8000: 16kB RAM
+VG-8010: 32kB RAM
+VG-8020: 64kB RAM, (VG8020 comes in 2 different versions (/00 and /20), new versions use 
+sub-slot for ram)
+
+
+
+Pioneer (Japan)
+
+PX-7 PALCOM: 32kB RAM, built in laser disk interface, superimpose (image & sound (stereo)), 
+separate keyboard (UK version in black, JP version in black/silver (lila/blue keys) colour)
+PX-V60: 64kB RAM
+
+
+
+Radofin (Hong-Kong)
+
+Triton: 64kB RAM
+
+
+
+Radiola (France)
+
+MX-180: 32kB RAM, Same as Philips VG-8010 with a different color case
+
+
+
+Sakhr/Universal/Al Alamiah (Kuwait/Yemen)
+
+     Those computers are Yamaha and Sanyo MSX modified for arabian countries.
+
+AX-100: 64kB RAM
+AX-150: 64kB RAM
+AX-170: 64kB RAM, built in special roms with Arabic characters set and software
+AX-230: 64kB RAM, same software as AX-170 + 1MB of other software
+AX-330: 64kB RAM, same as AX-230 but with built in SEGA-MEGADRIVE board
+AX-990: 64kB RAM, 50 programs built in, SEGA-MEGADRIVE board built in
+SX-100: 32kB RAM, 3 slots, RGB connector
+SX-101: ??kB RAM, 3 slots
+
+
+
+Samsung (Korea)
+
+SPC-800: 64kB RAM
+
+
+
+Sanyo (Japan)
+
+MPC-2: 16kB RAM
+MPC-3: 16kB RAM
+MPC-4: 16kB RAM
+MPC-5: 16kB RAM
+MPC-6: 64kB RAM
+MPC-10(mk2): 64kB RAM (other source says 32kB RAM), lightpen-interface
+MPC-11: 64kB RAM (other source says 32kB RAM), lightpen-interface
+MPC-64: 64kB RAM
+MPC-100: 64kB RAM, hole for lightpen
+MPC-200: 64kB RAM
+MPC-X: 64kB RAM, built in lightpen, high-res adaptor and speech-synthesizer
+PHC-27: 64kB RAM
+PHC-28L: 64kB RAM, Same as PHC-28S but with 64kB RAM
+PHC-28S: 16KB (or 32KB) RAM
+PHC-30: 16kB RAM (other source says 32KB), built in tape recorder
+PHC-30N: 64kB RAM
+PHC-33: 32kB RAM
+WAVY-MPC-10: 32KB (other source says 16KB) RAM, built in light pen unit
+
+
+
+Schneider (Germany)
+
+MC-810: 32kB RAM, (Same as Philips VG-8010 with a different color case)
+
+
+
+Sharp/Epcom (Brazil)
+
+HB-8000 HotBit: 64kB RAM (white colour)
+HB-8000 HotBit 1.2: 64kB RAM (in black color)
+
+
+
+Sony (Japan)
+
+     Note: Some of the Sony's computer names are followed by a letter like HB-101P, or 
+HB-101F or HB-700D. The last letter is only depending of the keyboard layout of the 
+country. D=German (QWERTZ) F=French (AZERTY) S=Spanish P=UK (QWERTY)
+
+HB-10: 64kB RAM
+HB-11: 64kB RAM
+HB-11U: ??kB RAM, built in dictionary Japanese-English
+HB-20: 32kB RAM
+HB-55: 16kB RAM
+HB-75: 64kB RAM, built in program: Personal Databank (schedule/memo/address)
+HB-101: 32kB RAM, (Same as HB-201 but with 32kB RAM, but other source says 16kB RAM)
+HB-201: 64kB RAM, built in joystick (Same as HB-501 but without tape recorder)
+HB-501: 64kB RAM, built in tape recorder ('BitCorder'), pause button, joystick
+HB-701, 64kB RAM
+HB-701FD: 64kB RAM, floppy disk drive
+
+
+
+Spectravideo (Hong-Kong/USA)
+
+SVI-728: 64kB RAM, numeric keypad
+SVI-738: 64kB RAM, built in 80 columns card (V9938), RS232C interface, 360KB 3,5" floppy 
+disk drive. Also called X'PRESS and also SVI-318 and SVI-328 MSX compatible with an emulator
+
+
+
+Talent/Telematica (Argentina)
+
+DPC-200: 64kB RAM, Daewoo's MSX model sold under the Talent name
+
+
+
+Toshiba (Japan)
+
+HX-10: 64kB RAM
+HX-10D: 16kB RAM
+HX-10DP: 64kB RAM
+HX-10DPN: 64kB RAM, built in program (??)
+HX-10E: 64kB RAM
+HX-10S: 16kB RAM
+HX-20: 64kB RAM, built in word processor (in total 64kB ROM), RAMdisk feature (32kB of 
+main RAM in page 0 and 1 are used, under BASIC), T6950 VDP (software compatible with 
+9929A which is normally used)
+HX-20e: 64kB RAM, built in word processor, RS232C interface
+HX-21: 64kB RAM, built in software
+HX-22: 64kB RAM, RS-232C interface, RGB connector (SCART 21), built in word processor (in 
+total 64kB ROM)
+HX-30: ??kB RAM, built in software
+HX-31: ??kB RAM, built in software
+HX-32: ??kB RAM, built in software
+HX-51: ??kB RAM
+
+
+
+Triton (Hong-Kong)
+
+PC64: 64kB RAM
+
+
+
+Yamaha (Japan)
+
+CX5: 32kB RAM
+CX5F: 32kB RAM
+CX5M: 32kB RAM, built in FM synthesizer (SFG-01) and MIDI-Interface
+CX5MII: 64kB RAM, built in FM synthesizer (SFG-01), MIDI-interface
+CX5MII/128: 128kB RAM, built in FM synthesizer (SFG-05), (V9938 built in), built in 
+FM VOICING program II
+CX-11: 32kB RAM
+CX-100: 32kB RAM
+YIS-303: 16kB RAM
+YIS-503: 32kB RAM
+YIS-503II/64: 64kB RAM, FDD
+
+
+
+Yashica (Japan)
+
+YC-64: 64kB RAM, Kyocera's MSX sold by Yashica
+
+
+MSX system list compiled from the list by TRD, Manuel Bilderbeek & Alex Wulms. Thanks to
+Stefano Priore, for abridging it to MSX1 specific info.
+
+
+Other Info:
+
+The MSX driver is very preliminary. Disk drive emulation doesn't work properly
+for example, and memory emulation isn't very good either. Various MSX1 models
+are emulated, and there is preliminary MSX2 support through the msx2 and msx2j
+driver.
+
+The required bios dumps are available at:
+
+	http://www.file-hunter.com/
+
+
+Cartridges:
+
+The ROM mapper (which is specified with -rom x in fMSX) is autodetected but
+isn't perfect. So you should also install the crc files, which can be 
+downloaded from the official mess site. With the CRC files, cartridges with
+SRAM or a DAC (like Synthesizer or Majutsushi from Konami) are detected
+properly.
+
+
+Tape emulation:
+
+Tape emulation is done via .wav files; the actual sound the MSX produces
+is recorded / played back, making tape emulation more authentic. Because of
+this, you can record your existing tapes to .wav and play them in MESS. Make
+sure your record them at high quality (44100Hz, 16 bit and mono).
+
+.cas files are also supported but they're converted to sound by the driver
+on startup. There is no support for writing .cas files.
+
+While recording or playback you can hear the sound through the sound card
+of your computer. You can control the volume by pressing <SCROLL LOCK> and
+<~>. 
+
+.tap files from Virtual MSX can be converted to .cas using imgtool (see
+imgtool.txt for more information).
+
+
+Memory Emulation:
+
+The memory map is from a standard MSX1; there are no subslots, nor MSX2 
+memory mappers for RAM. RAM is 64Kb in slot 3, and slot 1 and 2 are where 
+the cartridges end up.
+
+
+Sound emulation:
+
+The PSG, PPI (key click), SCC are emulated. The SCC isn't perfect yet, you
+can hear slight imperfections in King's Valley 2 (when you through the knife),
+F1 Spirit (when you start a race), Solid Snake (when you get to building 3).
+The SCC is called `k051649' in the volume menu.
+
+The FM-PAC is also emulated for which you need the ROM dump of an original
+Panasonic FM-PAC. However the sound emulation isn't very good at all. :/
+
+The following DACs are emulated: SIMPL, Konami's Synthesizer, Konami's
+Majutsushi. The keyclick is also done through the DAC. To enable SIMPL
+(which disables the printer port), press <SCROLL LOCK>, <TAB> and go to
+Dip Switches. Here set SIMPL to "On".
+
+You can control the volumes by pressing <SCROLL LOCK> (so you go to UI
+mode) and then <~>. Press <UP> and <DOWN> to see different sound chips, and
+<LEFT> and <RIGHT> to change the volume.
+
+
+Video emulation:
+
+The tms9928a (MSX1) emulation is very good, but doesn't emulate changes while
+the screen is being drawn to the screen. 
+
+The v9938 emulation is preliminary and has problems with sprite mode 2 (MSX2
+games), interlaced mode, graphic engine emulation, timing (Zanac Ex doesn't
+run correctly and Aleste only runs in the Japanese version of the driver).
+Also the PAL/NTSC (50/60Hz) switch is an evil hack, the actual refresh rate
+of the screen isn't changed.
+
+Also it's not very well optimized, I'll start optimizing as soon as it
+works alright. 
+
+The v9958 isn't emulated at all. 
+
+The MSX1 and MSX2 video chips only only display a limited number of sprites on
+one line; this causes sprite flickering, you can turn this off (which isn't
+like a real MSX of course) by pressing: <SCROLL LOCK>, <TAB> and going to the
+Dip Switches menu. Set "Enforce 4/8 sprites/line" to "Off". Note that sometimes
+this feature is used for other purposes, like making sure a sprite is only
+partly displayed (when you enter a world in The Maze of Galious for example).
+
+
+Printer port:
+
+The printer port is emulated; output to the port is saved to disk. However
+no emulation/translation is done, so the data is raw. 
+
+
+MSX2 RTC:
+
+The real-time clock, which keeps information like the time and date, should
+be emulated correctly. However in PAL mode the timing isn't correct as the
+refresh rate isn't properly adjusted. All settings are saved to disk.
+
+
+Keyboard/joystick/mouse:
+
+The keyboard layout should be properly emulated. Joysticks seem to default
+to having key-bindings as well, so pressing <CTRL> or <ALT> will also work
+for the joysticks, but might give some unexpected results.
+
+The mouse emulation doesn't work properly yet. :(
+
+
+Disk Emulation:
+
+Disks are emulated through proper wd2793 emulation. Currently only the
+Philips and Sony diskroms are supported; the Panasonic machines use the
+tc8566af diskcontroller (unemulated) and the Brazillian machines are 
+port-based (not memory-mapped).
+
+You need a proper diskrom dump, and the msx.crc file in place. The diskrom 
+should be recognized as type 15 otherwise the driver doesn't know it's
+a diskrom. 
+
+Next specify the diskrom as one of the cartridges. That should do the 
+trick. :) Note that only .dsk files are supported; other formats can
+be converted to .dsk using imgtool (it can convert .msx, .img, .ddi, .xsa,
+multidisks -- see imgtool.txt for more information).
+
+Error aren't properly handled yet. ``not ready'' is reported as ``record
+not found'', which results in ``Disk I/O error'' in MSX-BASIC.
+
+Also not that memory emulation isn't complete so MSX2 memory mappers
+don't work yet.
+
+
+$end
+
+#---------------------------------------------------------------------------------------------#
+
+$info=mtx512
+$bio
+Memotech MTX512
+
+
+Usage:
+
+
+currently, the driver requires cassette images to be stored
+in the following directory - 
+
+roms\mtx512
+
+the cassette image is a flat binary image with the first 0x12 bytes being the
+original mtx header and the rest being the file data.
+
+A note about cassette naming schemes - so long as the filename of the cassette image is the same 
+as that stored in the header, you should be alright.
+
+
+To run a tape image just type LOAD"<image name>" at the Ready Prompt.
+
+MTX basic is pretty much a standard dialect, so you should have no problems
+using it, but graphic handling etc is a bit esoteric.
+
+
+
+Known Issues:
+
+
+Improving the tape support, because at the moment it is just a hack.
+
+Improve the TMS99x8 driver (appears the dirtyrect handling there is not
+quite right)
+
+RELCPMH Mode (CP/M Memory configuration)
+
+support for additional roms
+
+No Cassette Save support.
+
+No Printer support
+
+
+$end
+
+#---------------------------------------------------------------------------------------------#
+
+$info=mz700
+$bio
+Sharp MZ-700 (1982)
+
+
+Features:
+
+
+MESS Emulation State:
+
+$end
+
+#---------------------------------------------------------------------------------------------#
+
+$info=mvision
+$bio
+MB Microvision
+
+
+First handheld (mono)
+
+
+Features:
+
+16x16 LCD display
+CPU is in the cartridge (normally TMS1100 with on chip rom)
+
+how to dump the TMS1100?
+
+$end
+
+#---------------------------------------------------------------------------------------------#
+
+$info=nascom1
+$bio
+Nascom 1 & 2
+
+
+Usage Notes:
+The Nascom 2 clone has support for .cas, .bin and .nas cassette files.
+
+The .cas files are used by BASIC. To get there from the monitor, type
+EE000, enter 49152 as the memory size then CLOAD "<letter>". You can use
+RUN/LIST etc. The <letter> for the existing cassettes are:
+
+adventr.cas     A
+snailr.cas      S
+startrek.cas    T
+swinghs.cas     M
+swords.cas      S
+
+The .nas files are loaded by the monitor. Type L, wait for the loading to
+finish, then E<start addr>. The start address is the address first
+displayed by the load, usually 1000. To load the .bin files, use R in the
+monitor.
+
+
+$end
+
+#---------------------------------------------------------------------------------------------#
+
+$info=nc100
+$bio
+Amstrad NC100 Notepad computer
+
+
+The Amstrad NC100 Notepad computer is a portable computer.
+
+This system has a LCD screen and nice keyboard. The memory is
+protected by a lithium battery which is charged when the computer
+is connected to a mains supply.
+
+PCMCIA ram cards can be used to store programs and documents.
+
+The computer has a built in wordprocessor, BBC Basic, Serial Terminal,
+Calculator, Diary and more. The whole system is a personal organiser with lots
+of extras.
+
+MESS Emulation State:
+
+a. ACCURACY
+
+The emulation is reasonably accurate. I have used NCIOSPEC.TXT published by Cliff
+Lawson at Amstrad to write the driver. Unfortunately this document does not describe
+undocumented hardware features, so at this time, any programs relying on undocumented
+behaviour will not work well. I am currently looking for NC owners (especially NC150
+owners) to run some tests for me.
+
+
+b. PRINTER
+
+Printer emulation is working. All data is saved out to a file on the host filesystem.
+The data is not processed in any way, so the file will contain the raw bytes output
+to the printer port.
+
+
+c. PCMCIA RAM CARD
+
+The NC100 supports a PCMCIA Ram card up to 1mb in size. 
+
+The emulator supports all ram card operations: reading, writing, formatting
+and write enable/write protect.
+
+It also supports ram cards of all sizes (128k, 256k, 512k and 1mb).
+
+The file format of a ram card is a simple memory dump; there are no headers or 
+other information stored in the file.
+
+If files have been saved onto the ram card by the emulation, then the file
+on the host filesystem will be updated (the update will happen when MESS is exited,
+or a new card is inserted).
+
+Use imgtool to create blank cards, and to put/get files to the card image.
+At this time, only 1mb cards can be created and there is no support to create unformatted
+or executable cards.
+
+Do not forget to insert memory card (as "Cartridge"), and if you want to write files
+to it make sure it is write enabled (see dipswitches in UI).
+
+imgtool create nccard <card name>
+	Create a blank formatted memory card. The NC100 can write files to this.
+
+	You can view the files by:
+		1. Pressing FUNCTION + B to enter BASIC, then typing "*." at the ">"
+		prompt.
+		2. Enter wordprocessor menu and select list files.
+	
+imgtool put nccard <card name> <host filesystem name> <nc100 name>
+	Put a file from the host filesystem (e.g. PC harddrive) to the nc memory card.
+	The file will be cut if it is larger than 64k (64k is the maximum file size
+	supported by the nc100 filesystem).
+
+	At this time, all files are assumed to be ASCII. There is no support to put binary
+	or BASIC files.
+
+imgtool get nccard <card name> <nc100 name> <host filesystem name>
+	Get a file from the nc memory card to the host filesystem. Files are always
+	saved as binary regardless of file type on memory card.
+
+imgtool dir nccard <card name>
+	Show a directory listing of the memory card.
+
+imgtool del nccard <card name> <nc100 name>
+	Delete a file from the memory card
+
+
+d. SERIAL
+
+Serial is mostly working. 
+
+MESS does not have a UI to change the serial device transmit/receive properties, so at 
+this time it is fixed to: 9600 baud, 8 data bits, 1 stop bit, no parity for the NC100
+driver.
+
+At this time, the serial device only supports a simple protocol. (Each byte is transmitted
+in a basic serial form, with start bits, data bits, parity and stop bits).
+
+In the future the serial device will support xmodem and xmodem send/receive will then
+work in the emulation.
+
+XMODEM transfer instructions:
+
+NC100:
+
+1. Enter wordprocessor.
+2. Start a new document
+3. Quit wordprocessor
+3. Go to list documents.
+4. Press MENU key
+5. Here you can navigate the menu to find "XMODEM receive document".
+6. Start XMODEM send on PC.
+
+
+Links:
+
+http://genesis8.free.fr/
+http://www.ncus.org.uk/
+
+$end
+
+#---------------------------------------------------------------------------------------------#
+
+$info=nc200
+$bio
+Amstrad NC200 Notebook computer
+
+
+The Amstrad NC200 Notebook computer is a portable computer.
+
+This system has a fold-down LCD screen, nice keyboard and disc drive.
+(The disc format is 720k PC Double Density DOS compatible).
+
+The memory is  protected by a lithium battery which is charged when the computer
+is connected to a mains supply.
+
+PCMCIA ram cards can be used to store programs and documents.
+
+The computer has a built in wordprocessor, BBC Basic, Serial Terminal,
+Calculator, Diary and more. The whole system is a personal organiser with lots
+of extras.
+
+MESS Emulation State:
+
+a. ACCURACY
+
+
+The emulation is reasonably accurate. There are no documents about the hardware
+of the NC200. Originally Cliff Lawson published details but these have been lost
+when his WWW site went down. Since then he has been unable to write up the details
+of the hardware (Cliff is a very busy man).
+
+So I have worked out much of the NC200 hardware by disassembling the ROM and I have
+also had much help from Russel Marks.
+
+a. PRINTER
+
+
+Same state as NC100, please see nc.txt for details.
+
+b. PCMCIA RAM CARD
+
+
+Same state as NC100, please see nc.txt for details.
+
+c. SERIAL
+
+
+Serial is not working properly. It is almost at the same state as the NC100.
+
+d. DISK DRIVE
+
+
+Not working. I am trying to find out the details of the disc interface by looking
+at lots of disassemblies!
+
+
+Links:
+
+http://genesis8.free.fr/
+http://www.ncus.org.uk/
+
+
+$end
+
+#---------------------------------------------------------------------------------------------#
+
+$info=neat
+$bio
+New Enhanced AT
+
+
+popular AT compatible chipset for 80286
+
+Features:
+
+support of LIM EMS4.0 (or only 3.2?)
+
+Notes:
+
+msdos utilities for quickset and ems available
+
+
+MESS Emulation State:
+
+basically the same as mess ibmat emulation
+special chipset features not emulated yet
+not working
+
+
+$end
+
+#---------------------------------------------------------------------------------------------#
+
+$info=nes
+$bio
+Nintendo Entertainment System / Famicom (1985 USA)
+
+
+The Nintendo Entertainment System (called Famicom in Japan) was an instant hit with such popular
+titles as Super Mario Bros., The Legend of Zelda and Excitebike.  It was released to the states
+in August, 1985. The 8-bit graphics were far superior to any-home based console that had come 
+before it. Strong sales were were driven by the gamers wanting the feeling of real-life arcade
+games in their homes.
+
+The NES boasts an impressive library of games with over 8000 games (Cowering goodnes), offering
+a smorgasbord of titles for fans of every genre. The Nintendo continued it's reign with other 
+big hits such as The Mega Man series, Ninja Gaiden, Contra, Castlevania, Double Dragon and of 
+course, Super Mario Bros 3.  The NES continued it's strong sales with over 36 million units sold
+worldwide by its official cancellation in January 1996 but not before releasing a redesigned NES. 
+
+
+Usage:
+
+Note that the one player hand controller Select is
+mapped as Coin 1 (default key 5), and 
+Start is mapped as Player 1 Start (default key 1).
+This makes it convenient to use the driver with a
+"MAME" configured controller.
+
+
+Famicom Disk System switching is mapped to Player 1
+Button 3 (default key [space]).
+
+
+Features:
+
+Main Processor: 8bit NMOS 6502 CPU with a secondary PPU (Picture Processing Unit). 
+Clock Speed: 1.7897725MHz for NTSC and 1.773447MHz for the PAL version.
+Data Path width: 8-bits
+Color Palette: 256; 16 max on screen
+Sprites: 64 (8x8 or 8x16)
+Sound: FM with 5 sound channels (4 analog, 1 digital)
+Video Ram: 16 Kbits
+SPR-RAM: 256 Bytes
+Rom addressing: 8k
+Cart Size: 64k - 4 Megabit
+Controls:  8 directional D-Pad, A, B, select, and start buttons.  
+
+
+Links:
+
+Nintendo - www.nintendo.com
+NES World - nesworld.parodius.com
+The Warp Zone - www.classicgaming.com/thewarpzone
+
+
+MESS Emulation State:
+
+The NES driver should run most of the images currently out there with very little problem.  It doesn't yet support the obscure one-game mappers used by many "pirate carts".
+
+
+The NES driver has quite accurate sound and sample playback. For example, you can hear speech samples in Bayou Billy, Gauntlet, Dirty Harry, and Skate or Die that are not present in a few other NES emulators.
+
+
+The main focus up until this point has been in getting the NES driver as accurate as possible.  Unfortunately, the scanline rendering method is quite slow, so future efforts will be focusing on bringing up the speed.
+
+
+Wanted: I'd appreciate any info on some of the more obscure mappers. If you have any of this, please drop me a line at bradman@pobox.com
+
+
+$end
+
+#---------------------------------------------------------------------------------------------#
+
+$info=odyssey2
+$bio
+Magnavox(?) Odyssey2
+
+
+Console for TV connection
+
+Philips G7000 videopac
+
+
+Features:
+
+2 digital joysticks
+keyboard
+
+
+Emulators:
+
+Dan Boris o2em for DOS
+
+
+MESS Emulation State:
+
+Based on info by Dan Boris.
+
+
+$end
+
+#---------------------------------------------------------------------------------------------#
+
+$info=oric1
+$bio
+Oric 1
+
+
+History and Trivia:
+
+This British computer was one of the most popular computers in Europe in early 80's, and a 
+competitor of the Sinclair Spectrum. The two models (16 and 48) had the same technical 
+characteristics, but the model 48 was sold with FORTH language. A small plotter was available 
+for this computer. Note that the sound chip was the same as the one in the Amstrad CPC, 
+MSX computers and Atari ST! The Oric 1's ROM was very bugged though, and it was replaced with 
+the Oric Atmos.
+
+
+$end
+
+#---------------------------------------------------------------------------------------------#
+
+$info=orica
+$bio
+Oric Atmos
+
+
+The emulation supports Microdisc and Jasmin floppy disc controller emulation, this
+can be chosen using a Dipswitch. 
+
+
+Known issues:
+
+- The disc controller emulation is not exact and some programs may fail to load.
+- The cassette emulation is not exact and some programs may fail to load
+- Screen display should be accurate, but there might be some small bugs.
+- Tape programs are found but not loaded.
+- there are bugs in the Microdisc and Jasmin floppy disc controller emulation so some
+programs will not boot.
+
+
+History and Trivia:
+
+The Oric Atmos was the successor of the Oric 1 and had almost the same characteristics. Its 
+main difference with the Oric 1 was it's enhanced RAM (48 KB instead of 16 KB), the keyboard 
+and the debugged ROM (the ORIC 1 had several bugs). Several peripherals were available: 
+3" floppy disk drive, a small 4 colour plotter, a speech synthesizer and a Digital/Analogue 
+converter. An external interface was needed to use joysticks. 
+
+
+$end
+
+#---------------------------------------------------------------------------------------------#
+
+$info=pc
+$bio
+IBM Personal Computer XT (and clones)
+
+
+History and Trivia:
+
+In early 1980, IBM decided to create a micro computer (up to this date, IBM produced only 
+mini and mainframe computers), they didn't really know what they wanted and they didn't 
+think for one second that producing micro computer was a profitable business! They asked 
+Digital Research (the authors of CP/M) to create an operating system for their new computer.
+DR was not very interested, so they approached the then small company Microsoft (at this point 
+famous for it's BASIC language) to write this operating system. Microsoft wasn't capable of 
+doing it themselves, so Bill Gates bought up the rights to an OS written by a small company 
+called Seattle's Computers Products: QDOS (Quick and Dirty Operating System) which became 
+PCDOS and later MS-DOS.
+
+
+The IBM PC wasn't very powerful (and was certainly less powerful than a lot of 8 bit 
+computers), the very first PC had only 16 KB RAM and no floppy disk units -- they used 
+cassettes. Notice that the functions to handle the cassettes were present in the operating 
+system up to MS-DOS 5. The PC was available with either CGA or MDA (on an MPA card). The CGA 
+adapter actually had an RCA composite output to hook it up to your TV if you did not want the 
+CGA monitor.
+
+
+The IBM PC XT was the successor of the IBM PC. It's enhanced features included hard disk 
+capability, more memory, and no more tape port. Perhaps because of the name and fame of IBM, 
+the PC series became a standard and IBM dominated the computer market up until the end of the 
+80's. Clones of the XT, such as the Tandy 1000 became commonplace by the end of the decade.
+
+
+The following PC's and compatibles are supported by, or currently under development in MESS:
+
+
+IBM PC
+
+Intel 8088 process with 4.77 Mhz clock.
+
+
+IBM PC Junior
+
+based on IBM PC
+Special keyboard
+CGA with 160x200x16, 320x200x16 and 640x200x4? colors
+3 channel sound chip
+
+
+IBM PC/XT
+
+based on IBM PC
+Intel 8086 instead of 8088, but only ram memory data bus
+enhanced to 16 bit.
+
+
+Tandy1000 Series
+
+IBM PC Junior compatible graphic system.
+Later the 640x200x16 graphic mode was also available.
+Later models were delivered with EGA/VGA compatible graphic system/card.
+IBM PC Junior compatible sound system.
+In later models there was also a DAC channel available.
+First series with own keyboard (own layout, different keys)
+
+
+
+Tandy1000HX
+
+First Tandy 1000 with EEPROM memory for configuration.
+Delivered with 3,5 inch  double density disk drive (720kb).
+
+
+
+Amstrad PC1512/PC1640/PC6400/PPC664?/PC2086?
+
+Packed IBM PC/XT functionality in few custom chips.
+Power supply in the monitor was also used for the computer.
+Serial Port,
+Parallel Port,
+Real Time clock with battery buffered cmos ram,
+Graphics adapter,
+mouse port for included mouse integrated in the motherboard.
+Joystick port for cpc-joystick in the keyboard.
+
+
+
+Amstrad PC 1512
+(Schneider in Germany/Austria)
+
+CGA compatible graphics system with special 640x200x16 graphics mode.
+512 KB ram on board, sockets for additional 128 kb on board.
+
+delivered as
+PC1512SD (1 5,25 inch double density disk drive (360kb))
+PC1512DD (2 5,25 inch double density disk drives)
+PC1512HD10 (1 5,25 inch double density disk driver, harddisk controller and 10MB harddisk)
+PC1512HD20 (....20 MB harddisk)
+(monochrome (about 16 levels grays) or color monitor)
+
+
+
+Amstrad PC 1640
+(PC6400 in the US)
+(Schneider in Germany/Austria)
+
+EGA compatible graphics card and monitor
+
+
+
+Amstrad PC2086
+(Schneider in Germany/Austria)
+
+VGA compatible graphics card and monitors?
+
+$end
+
+#---------------------------------------------------------------------------------------------#
+
+$info=p2000t
+$bio
+Philips P2000T (1980)
+
+
+Features:
+
+
+MESS Emulation State:
+
+$end
+
+#---------------------------------------------------------------------------------------------#
+
+$info=pc1251
+$bio
+Sharp Pocket Computer 1251
+
+
+small pocket computer
+
+also marketed as tandy trs80 pc-3
+
+
+Features:
+
+24 digit (5x7 pixel) LCD display
+integrated speaker
+same connector for printer and tape drive as pc1401
+2 "build in" batteries
+
+
+MESS Emulation State:
+
+look at pc1401
+
+
+$end
+
+#---------------------------------------------------------------------------------------------#
+
+$info=pc1350
+$bio
+Sharp Pocket Computer 1350
+
+
+small pocket computer
+
+
+Features:
+
+150x32 pixel LCD display
+integrated speaker
+connector for printer and tape drive
+2 build in batteries
+
+Features of this model included a BASIC interpreter, an 8-bit sharp CPU, 150x32 pixel 
+display, 8+32K ROM, 4K RAM which was expandable with a RAM cartridge to 12 or 20K.
+
+Emulator:
+
+pockemul for win32
+
+
+MESS Emulation State:
+
+look at pc1401
+
+
+$end
+
+#---------------------------------------------------------------------------------------------#
+
+$info=pc1401
+$bio
+Sharp Pocket Computer 1401
+
+
+small scientific calculator and pocket computer
+
+Features:
+16 digit (5x7 pixel) LCD display
+integrated speaker
+connector for printer and tape drive
+2 "build in" batteries
+
+Usage Notes:
+
+Holding C-CE while resetting, preserves basic programs. (simulated when starting mess)
+
+(???which of these is correct???)
+
+holding CE while hitting reset prevents the basic area from being overwritten
+
+
+Error Codes:
+error codes found at the inner side of the top:
+( should be the same for several models)
+1 syntax error
+2 calculation error
+3 illegal function argument
+4 too large a line number
+5 next without for
+  return without gosub
+6 memory overflow
+7 print using error
+8 i/o device error
+9 other errors
+
+
+
+History and Trivia:
+
+The PC 1401 was a combination scientific calculator and computer with BASIC interpreter.
+Featured an 8-bit Sharp CPU,  8+32K ROM, 4K RAM, and 16 5x7 character display. The PC 1402 
+has the same features but includes 10K of RAM.
+
+
+Other related models (not currently supported by MESS) include -
+
+
+
+pc1251
+basic computer
+24 5x7 character display
+
+
+
+pc1253
+calculator
+derived from the pc1251, reduced keyboard
+
+
+
+pc1260
+basic computer
+16x2 5x7 character display
+8 bit sharp CPU
+6+32kb rom, 4kb ram
+
+
+
+pc1261
+pc1260 with 10kb ram
+
+
+
+pc1360
+pc1350 with?
+
+
+
+pc1403
+derived from the pc1401
+8+32+32kb rom, 8 kb ram
+24 5x7 character display
+
+
+
+pc1403h
+pc1403 with 32 kb ram
+
+
+
+pc1421
+derived from the pc1401
+
+
+
+pc1430
+prequel to pc1401
+
+
+
+pc1450
+pc1401 with some additional keys
+
+
+
+pc1475
+derived from the pc1450 with some pc1403 features
+24x2 5x7 character display
+
+
+$end
+
+#---------------------------------------------------------------------------------------------#
+
+$info=pc1403
+$bio
+Sharp Pocket Computer 1403
+
+
+small scientific calculator and pocket computer
+
+sequel of the pc1401 (better display, more ram, better system software,...)
+
+pc1403 has 8kbyte? ram
+pc1403h has 32kbyte ram
+
+Features:
+
+24 digit (5x7 pixel) LCD display
+integrated speaker
+connector for printer and disk drive
+no contrast adjustment
+
+
+MESS Emulation State:
+
+look at pc1401
+
+$end
+
+#---------------------------------------------------------------------------------------------#
+
+$info=pc1500
+$bio
+Sharp Pocket Computer 1500
+
+
+Pocket computer
+
+clone sold as trs80 pc-2
+cost reduced redesign with more memory pc1500a
+
+
+Features:
+
+156x7 pixel LCD display
+integrated speaker
+integrated realtimeclock
+memory/cartridge slot
+expansion port for printer and tape drives
+batterie slot
+connector for external power supply
+
+
+MESS Emulation State:
+
+not working
+incomplete CPU core
+lh5811 not emulated
+speaker not emulated
+realtimeclock not emulated
+tape not emulated
+printer not emulated
+work stopped until more info about
+ lh5811
+ CPU lh5801 power/interrupt management available
+
+
+$end
+
+#---------------------------------------------------------------------------------------------#
+
+$info=pc1512
+$bio
+Amstrad PC1512
+
+
+IBM XT compatible desktop with modified CGA Monitor
+
+sold as Schneider PC1512 in Germany
+
+
+Features:
+
+integrated 5 1/4 inch 360 kb disk drive
+RTC with integrated setup ram as in IBM AT
+1 serial port connector
+1 parallel port connector
+special mouse (keys wired to keyboard, movement counters on the motherboard)
+special connector for cpc compatible joysticks (digital)
+power supply in monitor
+color graphics adapter with 640x200 in 16 colors
+multi language support in bios
+Some models sold with second 5 1/4 inch disk drive
+Some models sold with harddisk controller and 20mb harddisk
+
+
+MESS Emulation State:
+
+basically the same as mess ibmpc emulation
+special keyboard emulated
+special mouse emulated
+special joystick emulated
+unique dipswitches are emulated
+unique color graphics adapter mode emulated
+CHARACTER rom dump is missing, and so multinational character support
+work stopped until more information available or character rom available
+
+
+$end
+
+#---------------------------------------------------------------------------------------------#
+
+$info=pc1640
+$bio
+Amstrad PC1640
+
+
+IBM XT compatible with modified EGA monitor
+
+sold as Schneider PC1640 in Germany
+sold as Amstrad PC6400 in USA
+
+
+Features:
+
+the same as PC1512, except the integrated graphics adapter
+is EGA compatible and the monitor is an EGA one.
+
+
+MESS Emulation State:
+
+basically the same as PC1512
+paradise ega emulation incomplete, will profit from generic ega/vga improvements
+
+
+$end
+
+#---------------------------------------------------------------------------------------------#
+
+$info=pc200
+$bio
+Sinclair PC200 Professional Series
+
+
+IBM XT compatible computer "under the keyboard"
+
+Marketed also as Amstrad PC20
+
+Features:
+
+8086 with 8 mhz
+socket for 8087 math coprocessor
+512 kb ram on board, sockets for additional 128kb
+integrated cga/mda/hercules graphics adapter, 
+connector for CGA and MDA/Hercules monitors and TV (hf modulated; PAL?)
+integrated 102 key keyboard
+2 ibm pc compatible expansion slots (half length)
+multi language bios
+3 1/2 inch 720 kb disk drive
+ connector for external floppy disk drive
+rs232 serial port
+centronics printer port
+standard analog joystick port, delivered with sinclair joystick 
+proprietary pc1512 style mouse connector, delivered with sinclair 2 button mouse
+rtc?
+delivered with msdos, dr gem, organizer software
+
+Notes:
+
+download the mouse driver at http://www.users.zetnet.co.uk/johnhayward/pc200/software.htm
+
+MESS Emulation State:
+
+basically the same as mess ibmpc emulation
+character rom dump missing
+rough emulation of special graphics adapter
+work stopped until more info or system software available
+
+
+$end
+
+#---------------------------------------------------------------------------------------------#
+
+$info=pc8801
+$bio
+NEC PC-8801 series
+
+
+early Z80 based computer commonly used in Japan
+
+Features:
+
+main Z80 CPU 4MHz(some models has 8MHz version)
+sub Z80 CPU 4MHz(for 5'floppy disk drive)
+64KB RAM
+48KB Video RAM
+640x200 8colors or B/W graphics
+640x400 B/W graphics(required "high-resolution" display(VSYNC 24KHz))
+80x25 text(alphabet or Kata-kana only, can overlay on graphics)
+YM-2203 or YM-2608 FM sound(some models or optional)
+extended RAM(various size, some models or optional)
+5'2D or 5'2HD or 8'2D floppy disk drives(some models or optional)
+96KB BASIC ROM
+Kanji ROM(some models or optional)
+Kana-Kanji dictionary ROM(some models)
+RS-232C
+CD-ROM(some models)
+printer port
+
+MESS emulation state:
+
+CPU
+text or graphics
+YM-2203 sound(YM-2608 not yet)
+extended RAM
+5'2D disk drives
+Kanji ROM
+Note: Currently, each model is separated which use "High-resolution"
+      display and "Low-resolution" display. Because I don't know how
+      to change display resolution and HSYNC frequency dynamically
+      (when machine is running).
+
+ROM:
+
+BIOS images has same format as one of images for M88 emulator, but
+"disk.rom" is only used first 2K bytes, that is, you must truncate
+last 6KB of "disk.rom". M88 emulator and BIOS tools can be downloaded
+from this:
+
+	http://www.remus.dti.ne.jp/~cisc/m88/
+
+Currently PC-8801mkIISR rom is only tested.
+
+Disk Emulation:
+
+The D88 format disk image is supported now, but multiple disks image
+files are not supported, That is, disk in image file must be only
+one. The D88 disk image format is supported by more PC-8801
+emulators. Tools for D88 format can be downloaded from these:
+
+	http://www1.plala.or.jp/aoto/index.html
+	http://www.remus.dti.ne.jp/~cisc/m88/
+	http://member.nifty.ne.jp/arearea/M882.html
+
+
+TODO:
+integrate "high-resolution" and "low-resolution" mode
+optimization of CPU switching
+more accurate speed(memory wait and DMAC overhead)
+YM-2608 sound
+joystick and mouse
+5'2HD or 8'2D floppy disk drives
+font substitution
+Kana-Kanji dictionary ROM
+test ROMs of other models
+multiple disks image support
+source clean-up
+printer
+RS-232C
+CD-ROM
+more good English documentation
+
+$end
+
+#---------------------------------------------------------------------------------------------#
+
+$info=pc88srl
+$bio
+NEC PC-8801 (1985)
+
+
+Features:
+
+
+MESS Emulation State:
+
+$end
+
+#---------------------------------------------------------------------------------------------#
+
+$info=pcd85
+$bio
+Tesla PMD-85 (1985)
+
+
+homecomputer for TV connection in Czechoslovakia.
+
+
+Features:
+
+8080 compatible CPU
+288x256 dots resolution
+(version 1 and 2 mono)
+(version 3 with 4 colors)
+integrated beeper or beep generation for TV
+centronics port?
+something like user port?
+
+
+$end
+
+#---------------------------------------------------------------------------------------------#
+
+$info=pce
+$bio
+NEC PC Engine/TurboGrafx-16 (1987)
+
+
+The PC Engine (called TurboGrafx - 16 in the US)  was the first 16-Bit graphics home entertainment 
+system to be released. The PC Engine was created by NEC of Japan. Supporting over 1000 software 
+titles with such popular titles as Bonk's Adventure, Bomberman, Dracula X and Ys IV . The PC Engine
+was embraced by millions of Japanese gamers, and because of this, the system will be remembered as
+the starting of a legacy. This system was the first of it's kind to use credit card size game cartridges
+and later supported CD-ROMs and portable models with built in TV tuners.
+
+
+Features:
+
+Custom 8bit CPU: HuC6280 (7.16MHz)  (1.5 Million Instructions Per Second [MIPS])
+Video Processor: HuC6270 - 16 bit
+Color Processor: HuC6260 
+Resolution: 256 x 216 
+Sound Processor: 8 bit PCM stereo / 6-channel stereo 
+Ram: 8 Kbyte (64Kbit) 
+Video Ram: 64Kbyte (512 Kbit)
+Cart Size: 256Kbit - 20 Megabit Max. (S.F. 2) Normally 8 Mbits 
+colors Pallet: 512 - (256 for sprites, 256 for the background.) 
+Max # of sprites: 64
+Sprite Size: 16 x 16 , 32x64
+
+
+Links:
+
+Universo PCENGINE - upce.netfirms.com/index.html
+Turbo Station 16 - pcenginefx.com/TS/
+
+
+MESS Emulation State:
+
+Preliminary...  Xevious and Raiden8x work OK.
+
+$end
+
+#---------------------------------------------------------------------------------------------#
+
+$info=pcw16
+$bio
+Amstrad PCW16
+
+
+This is a successor to the PCW 8xxx and PCW9xxx series.
+
+It is a re-designed machine, with a 16Mhz Z80 CPU, improved graphics and improved hardware, 
+and a nice GUI system.
+
+This system takes advantage of a Super I/O chip, as used in many PCs, which provides PC 
+Floppy Disc Controller, Serial and Parallel port hardware. As a result, the system uses 
+a PC-AT keyboard and PC Serial Mouse.
+
+The PCW16 has a high-density floppy disc drive which uses the MSDOS filesystem.
+
+The OS comes on a rescue disc and is installed into 2MB flash-file memory. This is also used 
+for storing documents, files and user details. The main purpose of this machine, like the original is 
+wordprocessing, spreadsheet and other business tasks.
+
+Other programs have been written for it, including a CP/M "shell" by John Elliot 
+(www.seasip.demon.co.uk), a route-planner and more. You can run these by selecting 
+"Run External Program" from the "Tasks" menu.
+
+This system contains the "Anne" ASIC custom chip designed by Amstrad. Technical 
+information is still available and the rescue disc can be downloaded from Cliff Lawsons 
+Amstrad computer support site at: http://web.ukonline.co.uk/cliff.lawson/ (the disc is 
+listed in the files section). Cliff works at Amstrad plc, and has worked on the many 
+projects from the Amstrad CPC to the latest e-mail phone.
+
+MESS Emulation State:
+
+All major functions are working and the computer is useable, however there
+are some accuracy problems.
+
+
+a. SCREEN DISPLAY
+
+
+The screen emulation does not support mid-frame or mid-line changes.
+I don't think any programs do this yet?
+
+
+b. PRINTER
+
+
+Not working. The printer emulation assumes a ECP/EPP compatible parallel port
+which is not yet emulated. Therefore you cannot print out documents :(
+
+c. HARD DRIVE
+
+
+Not emulated. Has anyone used a hard-drive on their PCW16? Please let me know
+and I will add support for it.
+
+d. ANALOGUE JOYSTICKS
+
+Not emulated. Are there any programs that use the joysticks?
+
+
+Notes:
+
+
+To use the PCW16 you will need the OS rescue disc, when this has been inserted,
+and the on/off switch has been toggled (see UI for the dipswitch to do this),
+then the OS will be installed.
+When the OS is installed the computer is now useable and you can write documents
+and perform tasks.
+
+The emulation will run the CP/M implementation by John Elliot. It should run
+almost all software provided it is in a disc image.
+
+Development has been halted because this computer is in a working state.
+I plan to go back to it to fix the remaining problems at a later date when I
+have more time and more information.
+
+If you want to see more added to this driver, please contact me and I will
+try and fix it.
+
+$end
+
+#---------------------------------------------------------------------------------------------#
+
+$info=pcw8256
+$bio
+Amstrad PCW8256/8512/9512/9512+/10
+
+
+These machines were designed primarily for word processing (hence the name
+"Personal Computer Word processor"), but are capable of a lot more.
+
+The original PCW8256 system had a green screen monitor, with 2 3" disc
+drives mounted vertically in it, a keyboard and a special printer. (The CPU and other 
+hardware was also contained in the base of the monitor)
+
+Later models changed the case design, but also allowed the use of any printer that 
+was available. (The original 8256 had a proprietary printer and interface).
+
+The hardware is simple, a Z80 running at 4Mhz, slowed to 3.3 with wait states, an Amstrad 
+ASIC custom chip for driving the display (2 colours, 720x256 in PAL, 720x200 in NTSC), a 
+beep for sound, and a NEC765 floppy disc controller.
+
+The boot-program is contained on the printer chip, and is enabled at power-on or reset. 
+The data is passed through a Amstrad custom ASIC chip, and is executed by the Z80. The 
+program is simple, and just loads track 0, side 0,sector &01 to &f000 where it is then 
+executed at &f010. (The first 16 bytes appear to contain some format parameters which 
+are used to initialize CPM). I don't own a PCW machine so I don't know the exact display 
+that the PCW shows on boot-up.
+
+AFAIK, no dumps are available for this program. The MESS driver uses a program coded by 
+myself. This program waits for a key to be pressed and then starts the boot procedure. If 
+an error occurs, the screen will flash 6 times, and then it will repeat the procedure. If 
+all is well, you will see some lines appear on the screen, and the boot will continue.
+
+The original computer came with CP/M and Locoscript (a special word processor).
+
+Since it was able to use CP/M there was a lot of public domain and CP/M programs available 
+that would run on it.
+
+A few games were written for it, two of these are "Head Over Heels" and "Hitchhikers Guide 
+to the Galaxy".
+
+THIS SYSTEM REQUIRES A BOOT DISK TO RUN!
+
+$end
+
+#---------------------------------------------------------------------------------------------#
+
+$info=pdp1
+$bio
+DEC PDP-1
+
+
+Currently supports three images: Spacewar! (first computer-based video game),
+Munching Squares (minimalistic yet beautiful graphic demo) and LISP (programming
+language). I have OCR'ed and assembled the source code of DDT (debugger), but I
+am still looking for bugs in this program. No other images are known at the
+time of writing: I know there were a text editor (Expensive Typewriter), an
+assembler/linker (MACRO), and even a multi-user, multi-tasking operating system
+(MIT PDP-1 Timesharing System), but I have no idea where a copy of these
+programs could be found (except for macro1, which is should be OCR'ed soon).
+
+
+This driver emulates a complete pdp-1 system, including:
+
+* operator control panel
+
+* perforated tape reader and punch
+
+* typewriter for keyboard input and printer output
+
+* optional type 30 precision CRT display
+
+* optional type 15 memory expansion control, with 64kwords of RAM (16 type 12 memory modules)
+
+* optional type 10 automatic multiply and divide
+
+
+The internals of the sequence break (i.e. interrupt) system are implemented,
+but no device has been set up to trigger an interrupt.
+
+
+Usage Notes:
+
+
+PDP-1 currently supports a perforated tape reader (punchtape unit #1), a perforated tape punch
+(punchtape unit #2), and a typewriter (printer unit #1).
+
+The simplest way to load and run software is to insert a read-in mode tape (.rim files) in
+the perforated tape reader and press the read-in switch once (press simultaneously the Control
+Panel key (Left Control) and the Read In key (main keypad Return)).
+
+Three dip switches (RAM size, Hardware multiply and Hardware divide) enable or disable computer
+extensions. These switches are only read at reset. Therefore, if you edit them, you must reset
+the emulator (press F3 in partial keyboard emulation mode) for the changes to be taken into
+account.
+
+The "RAM size" switch installs and removes type 15 memory expansion control:
+it is disabled when set on 4kw, enabled with 15-bit addresses when set on
+32kw, and enabled with 16-bit addresses when set on 64kw. All known programs
+work well whether memory expansion control is installed or not. Only LISP can
+take advantage of the extra RAM.
+
+The "Hardware multiply" and "Hardware divide" switches enable or disable
+the automatic multiply/divide extension. When they are enabled, two pdp-1
+machine instructions (namely MUS and DIS) are replaced with two other,
+incompatible, instructions (MUL and DIV, respectively). Therefore, programs
+which use the former variant of these instructions require automatic
+multiply/divide to be disabled, whereas programs which use the latter require
+it to be enabled. In practice, Spacewar! requires automatic multiply and
+divide to be DISABLED (i.e. both switches OFF), whereas LISP requires
+automatic multiply and divide to be ENABLED (i.e. both switches ON).
+
+
+For information on pdp-1 operation, you may have a look at:
+<http://www.dbit.com/~greeng3/pdp1/pdp1.html>.
+
+
+History and Trivia :
+
+
+In 1957, Kenneth Olsen and Harlan Anderson founded a society called Digital Equipment
+Corporation (DEC).
+
+
+In 1960, they started selling the pdp-1. This was a very interesting computer for its time.
+
+
+First of all it was cheap and fast for its time: about 100,000 dollars, and a theoretical maximum
+of 0.1 MIPS. It included 4 kWords of RAM, expandable to 64 kWord (as word size is 18 bits,
+this makes from 9 to 144 kBytes, which is HUGE for this time): this is an important detail, since,
+at this time, cheap computers (e.g. IBM 650) often had no RAM, and used a magnetic drum instead,
+which implied extremely long memory access times.
+
+
+What made it even more interesting was that it was designed to be operated interactively.
+It featured an on-line typewriter (i.e. keyboard and printer), and a CRT (which was seldom used
+as a computer device at this time). You could even buy an optional light-pen (this device was
+the closest equivalent to today's mouse). Along with its simplicity, this made the pdp-1 quite
+user-friendly for its time.
+
+
+The pdp-1 may be regarded as one of the first personal computers, since one person was quite
+enough to run and operate it (although, needless to say, its price was not the kind of price
+you would expect from a personal computer today).
+
+
+The pdp-1 attracted the attention of various hackers in MIT. This resulted into the creation
+of Spacewar!, which was the first computer-based videogame, but this is another story.
+
+
+The pdp-1 was a reasonably successful machine: 49 units were sold, which was not as bad as it
+sounds for this time. DEC intended to sell variants of pdp-1 with a bigger word size
+(pdp-3 with 36-bit words, and possibly other variants (pdp-2???) with 24-bit or 30-bit words),
+but it eventually did not. However, it later replaced pdp-1 with other models, including the first
+minicomputer (the pdp-8 in 1965), and, by the early 1970's, it had become a major computer
+manufacturer, second only to IBM.
+
+$end
+
+#---------------------------------------------------------------------------------------------#
+
+$info=pet
+$bio
+Commodore PET series
+
+
+History and Trivia:
+
+The name PET, besides being a marketing ploy to imply a user-friendly machine, is an acronym 
+for "Personal Electronic Translator".
+
+
+The Commodore PET 2001 was a great success. Three models were made : the PET 2001-8N with 8 KB 
+RAM, PET 2001-16N with 16 KB RAM and the PET 2001-32N. They were conceived by Chuck Peddle who 
+later founded Tandon.
+
+
+The CBM PET 3032 was the successor of the PET 2001-32N (and has the same characteristics as the 
+PET 2001-32N), and the predecessor of the CBM 40000 Series.
+
+
+The disk drives were "Intelligent", which means that they were CPU driven (MOS 6502) and had 
+internal RAM (4 KB) & ROM (16KB, which contains the DOS). The 4032 and the 4016 (the version 
+of the CBM 4000 with 16 KB of RAM) were sold with a 80 column dot matrix printer (5x8 
+character matrix). This printer (4022) was an Epson printer with the Commodore name on it.
+
+
+The Commodore 8000 series was a "bundle". It was made up of the computer (most often the CBM 
+8032, though other models were made), the 5.25" double disk drive CBM 8050 (500 KB, 77 tracks) 
+and the bi-directional 132 columns, 160 CPS printer. The 8050 has two 6502's, 4 KB of RAM and 
+12 KB of ROM (which contains the DOS). It was sold with Ozz - a Database, and a version of the 
+spreadsheet "Visicalc".
+
+
+$end
+
+#---------------------------------------------------------------------------------------------#
+
+$info=pong
+$bio
+Pong Games
+
+
+first done in discrete logic
+later pong in a chip by several firms (atari, ge, ...)
+late pongs probably signetnics 2650/2636 system in Germany
+
+
+ay-3-8500-7 6(7) games in this chip
+ pelota
+ squash
+ fussball
+ tennis
+ schiessen-1
+ schiessen-2
+ undocumented (when all switches are off)
+nothing known about its internal design
+
+ay-3-8610
+ Zielschiessen
+ Tennis
+ Hockey
+ Squash
+ Squash-Training
+ Schiess-Training
+ Gridball
+ Fussball
+ Basketball
+ Basketball-Training
+nothing known about its internal design
+
+ay-3-8765
+ artisten rennen
+ gelaende fahren
+ motorrad rennen
+ geschicklichkeitsspringen
+nothing known about its internal design
+
+
+universum multispiel 2006: ay-3-8500-7, the six official selectable
+
+shg black point (type fs 1003)
+ cartridge with ay-3-8610 (fs 1201)
+ cartridge with ay-3-8765 (fs 1215)
+
+$end
+
+#---------------------------------------------------------------------------------------------#
+
+$info=prav8d
+$bio
+Pravetz 8D
+
+
+The emulation is the same as the Oric Atmos. (I don't know if there are any hardware
+differences compared to an original Oric Atmos, if there are please tell me and I will
+implement them).
+
+
+Disk:
+
+The disk drive interface has a boot-rom which loads the DOS from the disc
+in the drive. 
+
+The driver supports 2 versions of the disc interface:
+- "low dos 8d" has a 256 byte boot rom and supports DOS v1.0 to v1.30 ("Apple 2" on dipswitch)
+- "high dos 8d" has a 512 byte boot rom and supports DOS v2.10 and higher. ("Apple 2 v2" on dipswitch)
+
+If you are using the standard prav8d driver you will need to type:
+
+CALL #320
+
+to start the boot procedure.
+
+If you are using prav8dd (with the "BOBY" rom), then the disc is booted
+automatically.
+
+The Pravetz 8D uses Apple 2 compatible disk drives only and these
+are supported by the driver. 
+
+Here is a brief listing of DOS commands provided by George:
+
+options:
+f - FileName (1-30 signs)
+d - drive (one or two)
+v - volume
+a - beginning address
+e - end address
+l - record length
+r - record number
+b - number of byte in the record
+
+
+filetypes:
+B - Basic program
+C - Bynary file
+T - Text file
+M - Text file, created with Make command ( batch file:) )
+
+commands:
+DIR [1] [2] - not comment
+INIT [,Vv] [,Dd] - formatting Disk (in first or second Disk Drive)
+DOS [f] [,Dd], [,Vv] - writing Dos on the disk without formatting It. File f automatically starts after booting
+MAP [1] [2] - show chart of the disk.
+SAVE f [,A,a] [,Ee] [,Vv] [,Dd] - Saves file on the disk. If missing parameter of the addresses A,E - 
+saving Basic file in Memory
+LOAD f [,Aa] [,Dd] [,Vv] - loads file in memory
+MERGE - adding program in Basic to already exists in Memory
+- -only for files B or C types. Loads file in Memory and start It. (RUN and BRUN together in Apple ][)
+DELETE f [,Dd] [,Vv] - deleting file f
+RENAME f1, f2 [,Vv] [,Dd] - renaming last name of the file f1 with f2
+* f [,Dd] [,Vv] - lock/unlock file
+
+MAXFILES m - allowing up to m open files
+VERIFY f [,Dd] [,Vv] - checks surface integrity of file
+EXIT - leaving Dos
+
+OPEN f [,Vv] [,Dd] - open file for read/write
+CLOSE [f] - closing f. If there's no f pointed - closes all open files
+READ f [,Bb] - points that will be reading of the file with command INPUT
+WRITE f [,Bb] - writes in Text file
+APPEND f [,Vv] [,Dd] - adding information in Text file. Always there's WRITE after It
+POSITION f [,Rr] - allow writing or reading in Text file from r position
+in Program mode using of the commands is:
+
+10LPRINT CHR$(2); "MAXFILES 5"
+
+e.g.
+
+To load a program called "MONITOR" type:
+
+LOAD MONITOR
+
+often you will see a load address (it is the first number with # prefix).
+Now type CALL #<number> to execute the program.
+
+
+History and Trivia:
+
+The Pravetz 8D is a Bulgarian clone of the Oric Atmos.
+It was produced between 1985 and 1989: Pravetz is both the name of the firm and the name of
+the city where the firm is located. The "D" in the name stands for "Domashen" ('home' in
+Bulgarian) while the "8" stands for (you've never guess!) '8 bits'.
+
+There was a whole family of Pravetz computer which included the following models:
+
+Pravetz 82, 8M, 8A, 8E, 8C, 8D (8 bits)
+Pravetz 16, 16A, 286 (16 bits, PC clones)
+
+Most of 8 bits machines were Apple II compatibles, "8D" being the exception. The "8D" model was
+issued in 1985 and cost 420 lev - if you think that the average salary by that time was about
+180-200 lev, you can see that it was pretty expensive.
+
+The "82" model was the trade name of a machine called "IMKO-2" and was released in 1981. The "IMKO-2"
+was the upgraded version of the "IMKO", designed in 1979 and used for robot control.
+
+The main differences from the Oric Atmos were obviously the keyboard and the floppy interface.
+
+The Pravetz 8D can display both Cyrillic and Latin alphabets - the one currently in use is selected
+by the key labelled "C/L" which takes place of the "FUNCT" key present on the Atmos. Other features
+of the keyboard are the "ESC" and "CTRL" keys, labeled respectively "OSV" and "MK".
+
+During Pravetz' glory days none of Oric's disk interfaces were imported in Bulgaria, thus the magazine
+"Computer for you" organized a competition to develop a disk interface which was compatible with
+the most widespread disk drive currently used, namely the Apple II's disk drive.
+The competition was won in 1989 by Borislav "Boby" Zahariev, student at MEI University of Sofia.
+The first version of the disk interface used top 16Kb of RAM to store the DOS, which prevented
+users from loading larger programs. Later Boris developed an upgrade of his interface which
+used in conjunction with a new version of the DOS allowed programs to use the whole memory. He provided
+also a new version of BIOS which detected the presence of the interface and automatically booted
+the DOS from the disk.
+
+
+Thanks to:
+
+Joro Dramchev, Ventzislav Alexandrov and Todor Arnaudov for Pravetz information,
+Fabrice Frances for Oric information.
+
+
+$end
+
+#---------------------------------------------------------------------------------------------#
+
+$info=raaspec
+$bio
+RA+A Spectrum I+
+
+
+Usage:
+
+For the 8-button key mappings, see the user menu under "Keys (This Machine)".
+
+This driver supports the LED backdrop images:
+
+spec_bt.png
+
+led.png
+
+
+History and Trivia:
+
+The Spectrum I+ was a modified Vectrex. It had a 32K ROM cart and 2K additional battery 
+backed RAM (0x8000 - 0x87ff). PB6 was used to signal inserted coins to the VIA. The 
+unit was controlled by 8 buttons (2x4 buttons of controller 1 and 2).  Each button had a 
+LED which were mapped to 0xa000.  The service mode can be accessed by pressing button 8 
+during startup.  As soon as all LEDs light up, press 2 and 3 without releasing 8. Then 
+release 8 and after that 2 and 3. You can leave the screen where you enter ads by 
+pressing 8 several times.
+
+
+$end
+
+#---------------------------------------------------------------------------------------------#
+
+$info=saturn
+$bio
+Sega Saturn (1994)
+
+
+
+In 1994 Sega launched its new 32-bit console, just a few weeks ahead of its rival Sony Playstation.
+The Playstation was much easier to develop for and quickly overtook the Saturn in sales.  While 
+the Saturn was much more successful in Japan than it was in the US or Europe the lack of good 
+software and strong competition from the PlayStation doomed the Sega Saturn to a fate similar 
+to that of the Master System.  The CDROM based system did have some great arcade conversions such
+as House of The Dead and Virtua Fighter 3.  Despite being the first consoles with Internet 
+capabilities (via the NetLink adapter), Sega was relatively quiet after the slow demise of the 
+Saturn.  Sega turns its focus to the 128-bit Dreamcast a few years later.
+
+
+Features:
+
+CPU: Two Hitachi SH2 7604 32 Bit RISC chips at ~27 MHz (36 MIPS)
+Sound CPU: Motorola 68EC000 at 11.3 MHz
+Sound: 32 Channels, with 16 bit sampling at a sampling rate of 44.1 KHz max.
+Resolution: 704 x 512 (horz) 60.00 Hz 
+Colors: 32768 (static)
+Main Memory: 1 Megabyte of SDRAM and 1 Megabyte of DRAM
+Internal Memory Card 
+Video Hardware: Two VDP (video display processors) chip sets (VRAM: 512Kb each)
+-VDP1 Draw Sprites, lines, warped sprites (quads)
+-VDP2 controls background graphics.
+
+
+CDROM: Max 2x speed - custom interface controlled by Hitachi SH1 processor. (512 Kb Buffer RAM)
+
+
+MESS Emulation State:
+
+See source code for more information.
+
+Bios starts requesting pad data so maybe we are now in the time set area ????
+Need to emulate pad system, add more interrupts and get some grafix working so we can see exactly 
+where we are at this current time.  Currently locks up waiting on (i guess) a response from the 68k
+CPU. Probably need to emulate this shortly.
+
+$end
+
+#---------------------------------------------------------------------------------------------#
+
+$info=sfzch
+$bio
+Capcom CPS Changer (1995)
+
+
+History and Trivia:
+
+Perhaps inspired by SNK's Neo-Geo, Capcom released the Capcom Power System Changer (CPS in 
+this case NOT referring to Capcom Play System) in 1994, as an attempt to sell their arcade 
+games in console format.  The console basically served as an encased SuperGun (Television 
+JAMMA adapter) but was wired up so coin inputs could not be added by hackers, and only the
+special CPS Changer cartridge boards would work. The CPS Changer had outputs for Composite
+video, S-Video and 8 channel mono audio. It's joystick (named the "CPS Fighter") had the
+same connection as the Super Famicom, and was even marketed separately for that console.
+
+
+The games came as PCBs in plastic casing, and were virtually identical to their CPS-1 arcade
+counterparts, though they often contained extra debugging features.  The CPS Changer was
+sold as a package deal of the console itself, one CPS Fighter controller, and the Street
+Fighter II Turbo game for 39,800 yen. Additional games were sold for about 20,000 yen.
+
+
+The CPS Changer sold poorly though, and support was dropped in March 1996 after releasing 
+the console's only unique (as in non-CPS1) title: Street Fighter Zero, for 35,000 yen.
+Street Fighter Zero was a downscaled version of the CPS2 arcade version from the year prior.
+It ran somewhat choppier, had a reduced colour depth, and the sounds were at a lower sample
+rate.
+
+
+Ten other games were released for the CPS Changer, though none have been dumped at present
+(to the best of my knowledge). If/when these are dumped, support will be added for them: 
+
+Captain Commando (1995)
+
+Final Fight  (1994)
+
+The King of Dragons (1995)
+
+Knights of the Round (1995)
+
+Muscle Bomber:The Body Explosion (1994)
+
+Muscle Bomber Duo: Burn Up Warriors (1995)
+
+Quiz Capcom World 2 (1994)
+
+Street Fighter II' Champion Edition (1994)
+
+Street Fighter II Turbo (1994, Pack-in)
+
+Tenchi O Kurau II (1995)
+
+
+$end
+
+#---------------------------------------------------------------------------------------------#
+
+$info=sms
+$bio
+Sega Master System (1987)
+
+
+The Master System (called Mark III in Japan) was Segas competitor for the NES. Though Sega 
+constantly developed new (and good) games, the Master System never beat the NES. The MS was 
+most successful in Europe, especially Great Britain, where most of the games were developed in
+the "final" days in 1993/94. Overall, about 6 million consoles were sold world-wide until the 
+end of 1994. (note taken from www.eidolons-inn.de)
+
+
+Features:
+
+CPU: Z80 at 4 MHz
+Custom video controller (VDP) derived from the TI chip TMS9918/9928
+Resolution: 256x192 tile-based screen in 16 colors
+Sprites: 64 at 8x8, 8x16 or 16x16
+Color Pallette: 64; 32 max on screen (16 for sprites, 16 for background)
+Scrolling: Hardware up/down/left/right - all or part of screen.
+Sound chip: Generic SN76489 sound chip (PSG) made by Texas Instruments
+Sound output: 3 square-wave sound and white noise/periodic noise channel
+Music: Yamaha YM2413 FM sound chip
+
+
+Links:
+
+EIdolons inn - www.eidolons-inn.de
+
+
+MESS Emulation State:
+
+This driver runs just about everything!
+
+
+$end
+
+#---------------------------------------------------------------------------------------------#
+
+$info=snes
+$bio
+Super Nintendo Entertainment System (1989)
+
+
+Nintendo released the cartridge based 16-bit Super Nintendo to compete with the already released 
+Sega Genesis and NEC's TurboGraphix 16 (PCEngine in Japan). The Super Nintendo features true 
+stereo sound, multiple scrolling backgrounds and increased internal memory. It was a very popular
+system because people could play continuations of their favorite NES game. The Legend of Zelda: 
+A Link To The Past, The Donkey Kong Country Series, The Final Fantasy Series and Super Mario Kart
+were a few of the top titles for the SNES. In 1997 Nintendo redesigned the case, but never 
+included a CD-ROM expansion.
+
+
+Features:
+
+CPU: Custom 16-bit - 65C816 at 3.58 MHz (Machine adjustable to 3.58, 2.68, and 1.79 Mhz)
+Co-processor: None (DSP and SuperFX were inside the cartridge of selected games )
+RAM: (?)
+Video RAM: (?)
+
+Color Palette: 32,768; 256 max on screen
+Maximum Screen Resolution: 512 x 448 pixels
+Max # of sprites: 128, 32 per scanline
+Max and Min Sprite Size: 64 x 64 pixels; 8 x 8 pixels
+Scrolling: Horizontal, Vertical, Diagonal
+
+Sound channels: 8 ADPCM with 64 Kb Ram
+Sound Processor: Sony SPC700 ("wavetable-like" music, near 16-bit sound quality playback(CD) & Q-Sound surround sound.)
+
+Cart Size: 4Mbit - 128 Megabit Max. (Tengay Maikio at 70+ Megabits is the largest game)
+Controller: 8-way direction pad with Select, Start, A, B, X, Y and 2 Flipper buttons labeled R and L
+Controller Response: 16ms
+
+
+Links:
+
+Nintendo - www.nintendo.com
+
+
+MESS Emulation State:
+
+This driver is preliminary and most images will not work. Super Mario World (US version) is playable.
+
+$end
+
+#---------------------------------------------------------------------------------------------#
+
+$info=sordm5
+$bio
+Sord M5
+
+
+This computer used cartridges. You can insert game cartridges, or if you want
+to use basic, you can insert one of 3 basic cartridges:
+"BASIC-I" a integer based basic, "BASIC-G" a basic for graphics, "BASIC-F" a basic
+for floating point operations.
+
+
+Cartridges:
+
+The Sord must have a cartridge to start up.
+- some cartridges may not work
+
+Cassette:
+
+The cassette emulation uses .WAV sample files.
+
+saving:
+save"cmt:<filename>" where <filename> is the name of the file. 
+
+loading:
+old"cmt:" will load the next file on the cassette.
+chan"cmt:" and run"cmt:" can also be used to load and run the next file on the cassette.
+
+History and Trivia:
+
+The Sord M5 is similar in design to the MSX but not compatible with it.
+(It has the same CPU (Z80), a Z80 CTC timer chip and the same video chip, but 
+a different sound chip and the I/O port assignments are not the same).
+
+In fact some MSX games have been converted to the Sord by enthusiasts.
+
+Known Issues:
+- no memory expansion supported
+- loading from cassette does not work
+
+$end
+
+#---------------------------------------------------------------------------------------------#
+
+$info=spec128
+$bio
+ZX Spectrum 128
+
+
+Usage Notes:
+
+A HTML version of the Spectrum 128 manual (converted by Damien Burke, with the approval of 
+the copyright holder Amstrad) is available at:
+
+http://www.jetman.dircon.co.uk/speccy/128manua/index.html
+
+
+$end
+
+#---------------------------------------------------------------------------------------------#
+
+$info=specpls4
+$bio
+Amstrad Spectrum +4 Rom
+
+
+The plus4.rom is copyright (c)1982-2000 Amstrad plc
+and is distributed with their kind permission.
+
+I would like to thank Cliff Lawson and Amstrad for making this
+project possible, Phillip Kendall for the Spectrum ROM page, Ian
+Collier for documenting the changes he made to the ROM and giving me
+additional advice, Dr Ian Logan and Dr Frank O'Hara for the invaluable
+Complete Spectrum ROM Disassembly, and whoever it was that sold the
+book to me and contributors to comp.sys.sinclair for keeping me
+constantly amused and informed.
+
+-Andrew Owen, 24-2-2000
+
+
+Introducing the Spectrum +4.
+
+Remember when Apple promised its customers a whole new computer for
+$99. What they meant was they hoped their new operating system would
+change the experience of their users so profoundly it would make them
+feel as if they had a new machine. Well now you can have a whole new
+Spectrum for FREE!
+
+
+What is the idea behind this?
+
+I've taken the original 48K machine as my starting point and tweaked
+it until the point where I don't think there is any further room for
+improvement without adding extra hardware. Now if someone wants to
+build a new machine at least they have a place to start.
+
+
+How compatible is it?
+
+The Spectrum +4 ROM is very similar to the one in the 48 and so it
+should be 90% compatible or better with machine code. BASIC programs
+may require minor modifications but should then run without problems.
+
+
+What are the changes?
+
+There are so many changes that it is impossible to summarize them all.
+Only the important changes have been detailed with the exception of
+the new NMI routine which is self explanatory.
+
+
+THE KEYBOARD
+
+The keyboard layout has been completely redesigned, based on the
+standard international English keyboard, to make it quicker to use and
+easier to remember which keys are where. This is made possible by
+replacing the keyword entry system.
+
+All the SHIFT functions on the number keys are retained, as are the
+EXTEND and SHIFT-EXTEND attribute functions. But that is where the
+similarity to the old keyboard ends.
+
+All but a few symbols are accessed by holding down SYMBOL shift and
+the relevant key, while the remainder are accessed using EXTEND mode.
+Pressing either SHIFT or SYMBOL shift in EXTEND mode will give the
+same result as if SYMBOL shift alone had been pressed. In addition to
+the characters shown below, the 16 pre-defined graphics characters are
+accessible using SYMBOL shift or EXTEND mode and keys Q-R and A-F.
+
+ ---------------------------------------
+| ! | @ |  | $ | % | ^ | & | * | ( | ) |
+| 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 0 |
+ ----------------------------------------
+ |   |   |   |   |   |   | { | } | : | " |
+ |   |   |   |   |   |   | [ | ] | ; | ' |
+ | Q | W | E | R | T | Y | U | I | O | P |
+  ---------------------------------------
+   |   |   |   |   |   |   | | | _ | + |
+   |   |   |   |   |(c)|   | \ | - | = |
+   | A | S | D | F | G | H | J | K | L |
+    -----------------------------------
+     | ~ |   |   |   | ? | < | > |
+     | # |   |   |   | / | , | . |
+     | Z | X | C | V | B | N | M |
+      ---------------------------
+
+SYMBOL = Lower symbols
+EXTEND = Upper symbols and attributes on number keys
+SHIFT  = Upper case letters and functions on number keys
+
+
+BASIC EDITOR
+
+The most noticeable change is that all commands must be typed in full.
+Instructions are converted into tokens automatically when you press
+ENTER. It is also possible to use the cursors to move up and down
+while editing a line. Instructions can be entered in both capital and
+lower letters. No space is required between commands such as DEF FN or
+after a command unless the argument begins with a letter.
+
+
+BASIC COMMANDS
+
+CAT, when entered without parameters, calls up the built-in monitor.
+
+The PLOT, DRAW and CIRCLE commands have been modified to use the whole
+screen.
+
+ERASE "i" erases extra Interface 1 variables, extended channels and
+such without affecting the BASIC program in memory.
+
+The GO SUB, GO TO and CONTINUE commands have been replaced by GOSUB,
+GOTO, and CONT, to replicate other BASIC interpreters.
+
+MOVE can be used to shift data around in memory. For example, the
+command MOVE "r0,6144","r16384" would copy the first 6144 bytes of ROM
+to the screen area of memory.
+
+The COPY command has been replaced by the FREE command which reports
+the amount of free memory below RAMTOP.
+
+
+THE MONITOR PROGRAM
+
+The Spectrum +4 features a built-in monitor which can be accessed with
+the CAT command or holding down SYMBOL shift, SPACE and B while
+interrupts are enabled. The following commands are then available:
+
+B             Return to BASIC (if possible)
+
+D<hex_num>    Displays entered hex number in decimal notation
+
+G<hex_addr>   Execute a subroutine at address G
+              (RET will return to the monitor).
+
+H<dec_num>    Displays entered decimal number in hex notation
+
+M<hex_addr>   Hex and ASCII dump from given address
+              (SPACE to exit).
+
+R             View and/or change registers
+              AF, BC, DE, HL, IX and SP.
+
+S<hex_addr>   Patch memory from given address using hex editor
+              (SPACE to exit editor).
+
+
+BUG FIXES
+
+Every effort has been made to fix all the bugs mentioned in The
+Complete Spectrum Rom Disassembly and a few others besides as follows:
+
+Fixed a bug the CLOSE # bug. eg CLOSE #4
+
+Fixed the forwardspace (CHR$ 9) bug. e.g. PRINT "A";CHR$ 9;"B"
+
+Fixed the backspace (CHR$ 8) bug. e.g. PRINT AT 0,0;CHR$ 8;"A"
+
+Fixed the STR$ bug. e.g. PRINT "BUG"+STR$ 0.5
+
+Fixed the division bug. e.g. IF 1/2<>0. 5 THEN PRINT "BUG"
+
+Fixed the -65536 bug. e.g. PRINT INT -65536
+
+Fixed the SCREEN$ bug. e.g. IF "X"=SCREEN$ (0,0) THEN PRINT "BUG"
+
+Fixed the "scroll?" bug. Try pressing True Video at the request.
+
+Fixed the syntax check error.
+
+Fixed the double store bug at 257Dh.
+
+Resolved the K-MODE bug. There is no 'K' mode.
+
+Resolved printer buffer error. There is no COPY command.
+
+Resolved the NMI bug. There is a different routine.
+
+Fixed the 'lock up if interrupts are disabled on error report' bug
+
+
+LEGAL NOTICE FOR THE CURIOUS
+
+Just to make sure it was 100% okay to do this I wrote to Amstrad's
+Cliff Lawson on 23/02/00. Here's what followed.
+
+ME: I know it's okay in principle to distribute modified Spectrum
+    ROMs as long as the copyright message is unchanged. However,
+    I've just finished a very major overhaul of the ROM and would
+    like to use an alternative message.
+
+CL: Well you can't really associate a name such as "+4" with
+    "Amstrad Consumer Electronics" because it makes it look as if
+    it's an "official" development.
+
+ME: Would this be acceptable?
+
+      AMSTRAD CONSUMER ELECTRONICS PLC
+       (C)1982-2000 unofficial +4 48K
+
+CL: Yup, sounds OK but you do realize that the company was only
+    called "Amstrad Consumer Electronics" for a few years in the
+    early..mid 80's then the company name was shortened to
+    "Amstrad plc" so it's a bit "out of date" to use it but I
+    guess that probably describes the "Spectrum" too! :-)
+
+ME: Mind if I quote you in the "readme" just so no one accuses me
+    of violating copyrights?
+
+CL: No problem.
+
+ Visit the Amstrad website at http://www.amstrad.com
+
+                   Amstrad plc. Registered in England No. 955321
+Registered Office: Brentwood House, 169 Kings Road, Brentwood,
+                   Essex CM14 4EF, England
+
+
+$end
+
+#---------------------------------------------------------------------------------------------#
+
+$info=spectrum
+$bio
+Sinclair ZX Spectrum (and clones)
+
+
+Usage Notes (TK90X/TK95):
+
+TK90X/TK95 add two commands to the Sinclair BASIC: TRACE 1/0 (E cursor, Symbol Shift+P) 
+turns on/off the display of the line currently executed. UDG 0/1/2 (K/L/C cursor, 
+Symbol Shift+X) controls the behavior of the (guess what?) UDGs: when the parameter is 0/1 
+they restore their shape to accented letters used in the Portuguese language (still haven't 
+discovered the difference between 0 and 1) while the UDG 2 command activate the built-in 
+character editor: you can use the keys 5,6,7,8 +CAPS or Symbol Shift to plot/move the 
+cursor, the A-U keys to select the UDG to edit or copy (with the shift keys), INVERSE 
+VIDEO key to reverse the character. Maybe there are yet more command-keys, but I haven't 
+discovered them yet. Curiously, the BEEP command has been renamed to SOUND: who knows why... 
+[JoJo Priore]
+
+
+Known Issues:
+
+Requires full keyboard emulation. At startup, full keyboard emulation mode is enabled by 
+default.  Whilst in full keyboard emulation mode, some key associated functionality may be 
+disabled (like the ESC key for EXIT). The keyboard emulation mode is toggled using the 
+scroll_lock key.   
+
+$end
+
+#---------------------------------------------------------------------------------------------#
+
+$info=srdm5fd5
+$bio
+Sord M5 with PI-5 parallel interface and FD-5 disc interface
+
+
+This computer used cartridges. You can insert game cartridges, or if you want
+to use basic, you can insert one of 3 basic cartridges:
+"BASIC-I" a integer based basic, "BASIC-G" a basic for graphics, "BASIC-F" a basic
+for floating point operations.
+
+To use the disc interface, use the floating point basic "BASIC-F". This has support
+for the disc interface built-in.
+
+This driver consists of:
+- a Sord M5 computer
+- a Sord FD-5 disc interface
+- a Sord PI-5 parallel interface
+
+The Sord M5 computer communicates with the FD-5 through the parallel interface.
+
+The parallel interface has:
+- a Intel 8255 parallel peripheral interface chip
+Communication with the FD-5 is done using mode-2 operation. i.e. port A is
+a bi-directional 8-bit port, port C upper is a control port.
+
+The floppy disc interface:
+- Z80
+- 16k ROM
+- RAM
+- NEC765 compatible disc controller
+- internally the disc interface uses interrupts to transfer data into it's own ram.
+
+The floppy disc drives are 3" and are believed to use 40 track, double density, double sided discs,
+giving 360K per disc.
+
+The M5 sends 3 character commands, with parameters to the disc interface using the following
+command:
+
+fx 0,<command>
+
+<command> can be:
+
+TDA
+TRA
+WBI
+RBI
+WTX
+RTX
+WBL
+RBL
+WMM
+RMM
+EXC
+SDR
+WDR
+RDR
+RDC
+OPN
+CLS
+CHN
+MAP
+SAP
+CAP
+ATR
+NAM
+DEL
+FMT	- Format disc
+CPY
+GEN
+VPR
+RVI
+IDV
+FNM
+RDB
+WDB
+WHO
+DOM
+
+Known issues:
+- See sordm5 description
+
+
+$end
+
+#---------------------------------------------------------------------------------------------#
+
+$info=ssystem3
+$bio
+Super System III/MK III
+
+
+early chess computer
+
+sold in Germany as MK III
+
+
+Features:
+
+LCD display with 4 digits and several symbols
+integrated speaker
+connection for external power supply
+connection for printer
+connection for board display
+
+
+MESS Emulation State:
+
+not working
+low priority for me because it uses features not implemented in via6522 emulation
+(pin b6 timer counting!)
+
+
+$end
+
+#---------------------------------------------------------------------------------------------#
+
+$info=studio2
+$bio
+RCA Studio II
+
+
+early console for TV connection
+
+sold from several firms under different names
+
+
+Features:
+
+mono display of 64x128
+integrated speaker
+Controls for 2 Player2
+Cartridge port
+
+
+Notes:
+
+build in rom expects selection of game
+without printing something to screen! (keys 1 to 5)
+
+
+2 Keypads: Player 1 left, Player 2 right
+
+Keypads have following Layout
+ 1 2 3
+ 4 5 6
+ 7 8 9
+   0
+
+
+The console has 5 Built in programs. Without a cartridge inserted, the screen stays black 
+after turning on. Player 1 selects game.
+
+1 Paint? not working now
+2 Not sure what game 2 is; it's not working currently
+3 Bowling, working
+4 Rally, not working now
+5 Math (calculate the sum of the 3 digits, and enter it), working
+
+
+Emulators:
+
+Paul Robson's stem for DOS at www.classicgaming.com/studio2
+
+
+Mess Emulation State:
+
+no support for st2 cartridges
+
+
+$end
+
+#---------------------------------------------------------------------------------------------#
+
+$info=supergb
+$bio
+Nintendo Super Game Boy (1994)
+
+
+The Super Game Boy is an adapter for the SNES that let you play Game Boy games on your TV. It 
+also had some extended features like backgrounds around the game and primitive color, although
+not all games take advantage of this. It possible for Super Game Boy games to make use of the 
+SNES sound hardware for extra effects. Try compairing Astroids/Missle Commmand, Space invadors
+or Donkey Kong to see some excellent use of the of enhancments. In 1994 the Super Game Boy sold
+for under $60.
+
+There was a Super Game Boy 2 released in 199?. It has the same features of the original Super 
+Game Boy but adds a green game link LED, red power LED and a Game link port.
+
+
+Features:
+
+Supports 256 colors in static screens (i.e the title screen) and 12 colors in the normal game.
+
+
+Links:
+
+http://www.gamersgraveyard.com/repository/snes/peripherals/sgbfaq.txt
+
+
+MESS Emulation State:
+
+???
+
+$end
+
+#---------------------------------------------------------------------------------------------#
+
+$info=svi318
+$bio
+Spectravideo SVI-318 (1983)
+
+
+Features:
+
+
+MESS Emulation State:
+
+$end
+
+#---------------------------------------------------------------------------------------------#
+
+$info=svision
+$bio
+Watara Supervision
+
+
+non-color handheld
+
+sold from several firms under different names
+Quickshot Supervision
+Hartung SV-100
+...
+
+There are several designs, but all have the same functionality.
+*(knickable screen)
+*GB2000 (game boy style, no comm port)
+
+
+Features:
+
+160x160 in 4 greys LCD display
+4? stereo voices (integrated mono speaker, port for stereo speaker)
+Controls for 1 Player
+Serial port
+Cartridge port
+Batterie port
+Connector for external power supply
+
+
+Optional features:
+
+TV adapter
+
+
+Notes:
+
+Cartridge must be in for operation
+Pinout of cartridge is in mess/messroms/svision.txt
+
+
+MESS Emulation State:
+
+very preliminary support
+preliminary sound support
+no serial port
+no TV adapter support
+work stopped until more cartridges are available
+
+
+$end
+
+#---------------------------------------------------------------------------------------------#
+
+$info=sym1
+$bio
+Synertek SYM-1/SY-VIM1
+
+
+very early computer
+
+
+Features:
+
+6 digit 7segment display
+connector for tty input/output
+tape interface
+
+
+MESS Emulation State:
+
+display, keyboard working
+Work on it stopped. For me it is much to cryptic to operate and therefore not interesting
+for me anymore.
+
+
+$end
+
+#---------------------------------------------------------------------------------------------#
+
+$info=t1000hx
+$bio
+Tandy 1000HX
+
+
+IBM PC Junior compatible
+
+
+Features:
+
+basically the same features as ibmpcjr
+setup memory
+integrated serial port
+integrated parallel port
+integrated game port with unique connectors (but software compatible with ibm joysticks)
+integrated 3 1/2 inch 720 kb disk drive
+connector for external disk drive
+support for msdos with multilanguage support in rom
+
+
+Keyboard notes:
+
+The Tandy 1000 series computers have 12 function keys (analogous to modern PC keyboards) 
+whose functions depend on the program you are running. 
+Some function keys have special functions during boot up, if you press them right after the 
+startup "beep", while MS-DOS loads:
+* F1 = Switches the computer into monochrome video mode.
+* F2 = Switches the computer into composite/TV video mode (40 Column/200 scanline mode). 
+This can also be achieved by issuing a MODE command from DOS.
+* F3 = Reverses the drive references so B: becomes the primary drive, 
+and A: becomes the secondary drive, this lets you start the
+computer from the B Drive.
+* F4 = Starts the computer in slow (4 mhz) mode. 
+This is useful if a program runs too fast or not at all in normal (8 mhz) mode.
+
+
+Notes:
+
+get the setup utility for msdos at tandy's web side 
+to change setup
+
+
+MESS Emulation State:
+
+basically the same as ibmpcjr
+special setup memory emulated
+work stopped until dump of character rom available
+
+
+$end
+
+#---------------------------------------------------------------------------------------------#
+
+$info=telstrat
+$bio
+Oric Telestrat
+
+
+This system is a update to the Atmos.
+
+Known Issues:
+
+Disc emulation is not correct so it fails to boot! 
+
+
+$end
+
+#---------------------------------------------------------------------------------------------#
+
+$info=ti74
+$bio
+Texas Instruments TI74 Basicalc
+
+
+Pocket Computer
+
+TI74S is a variant
+TI95 Procalc seams to be related
+Compact Computer CC40 seams to be related
+
+
+Features:
+
+31 5x7 character LCD display
+32+4kb rom
+8 kb ram
+ram/rom memory expansion port
+hexbus port
+place for 4 micro batteries
+
+
+Peripherals:
+
+Texas Instruments PC-324 thermo? printer
+(how to dump the C70016 integrated rom? (tms7000 family))
+24 characters per line
+hexbus port
+place for 4 mignon batteries
+port for power supply
+
+
+
+$end
+
+#---------------------------------------------------------------------------------------------#
+
+$info=ti81
+$bio
+Texas Instruments TI-81 (1990)
+
+
+The TI-81, TI's first graphing calculator, was designed for algebra and
+precalculus. It has since been replaced by newer models which have faster
+processors, more memory, and popular features such as linking capability and
+flash upgradability. The TI-81 drew little in the way of third-party games and
+other programs, since the code must be typed into the calculator by hand. 
+(note taken from www.ticalc.org)
+
+
+Features:
+
+CPU: Z80 2 MHz
+Memory: RAM 32kB(?), ROM 128kB
+Screen: 96x64 pixels, 16x8 characters
+Known ROM versions: 1.1, 1.8, 2.0
+
+
+Emulator:
+
+Texas Instruments TI-81 simulator (http://www.ti.com)
+
+Links:
+
+Texas Instruments Homepage
+http://www.ti.com
+ticalc.org
+http://www.ticalc.org
+TI-Files
+http://www.ti-files.org
+
+
+MESS Emulation State:
+
+driver for rom versions:  1.8
+grayscale effects emulated
+200Hz(?) timer and ON key interrupts emulated
+there are bugs in port 3 emulation (ON/OFF)
+
+Notes:
+
+1. After start TI-81 waits for ON key interrupt, so press ON key to start
+   calculator.
+2. Video engine (with grayscale support) based on the idea found in VTI source
+   emulator written by Rusty Wagner.
+
+To do:
+
+port 3 and 4
+nvram
+better artworks
+drivers for other rom versions
+
+Needed:
+
+1. Any hardware info.
+2. High quality artwork.
+3. Dumps of other rom versions.
+
+
+$end
+
+#---------------------------------------------------------------------------------------------#
+
+$info=ti85
+$bio
+Texas Instruments TI-85 (1992)
+
+
+The TI-85 was designed as a powerful engineering and calculus calculator.
+It was the first TI calculator to have a link port and assembly programming
+capability (through an unintentional loophole). It has since been eclipsed by
+the TI-86, which features TI-85 compatibility along with more advanced features.
+(note taken from www.ticalc.org)
+
+
+Features:
+
+CPU: Z80 6 MHz
+Memory: RAM 32kB, ROM 128kB
+Screen: 128x64 pixels, 21x8 characters
+Known ROM versions: 1.0, 2.0, 3.0A, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0
+Link port
+
+
+Emulator:
+
+TI-85 Emulator by David Ellsworth and others (ftp://users.aol.com/davidells/TI-Calc/)
+TI86EMU by Steve Gordon (http://www.dogtech.com/cybop/ti86)
+TI-8X emulator by Randy Gluvna (http://ti8xemu.home.ml.org)
+TIGraph by Rene Doss & Joerg Sander
+Virtual TI by Rusty Wagner (http://vti.acz.org)
+
+
+Links:
+
+Texas Instruments Homepage
+http://www.ti.com
+ticalc.org
+http://www.ticalc.org
+TI-Files
+http://www.ti-files.org
+
+
+MESS Emulation State:
+
+drivers for rom versions:  3.0A, 4.0, 5.0, 6.0, 8.0, 9.0, 10.0
+sound emulated (speaker connected to link port)
+link port emulated
+grayscale effects emulated
+nvram emulated
+200Hz timer and ON key interrupts emulated
+snapshot loading (Virtual TI 2.0 save state files)
+
+
+Notes:
+
+1. After start TI-85 waits for ON key interrupt, so press ON key to start
+   calculator.
+2. Video engine (with grayscale support) based on the idea found in VTI source
+   emulator written by Rusty Wagner.
+3. NVRAM is saved properly only when calculator is turned off during MESS
+   exiting.
+4. To receive data from TI press "R" immediately after TI starts to send data.
+5. To send data to calculator start receiving on TI and choose file from
+   Built-in File Manager.
+6. To request screen dump from calculator press "S".
+
+
+To do:
+
+port 3 and 4
+better artworks
+drivers for rom versions: 1.0, 2.0, 7.0
+
+
+Needed:
+
+1. Info about ports 3 (bit 2 seems to be always 0) and 4.
+2. High quality artwork.
+3. Dumps of rom versions: 1.0, 2.0, 7.0
+
+
+$end
+
+#---------------------------------------------------------------------------------------------#
+
+$info=ti86
+$bio
+Texas Instruments TI-86 (1997)
+
+
+Just as the TI-83 succeeded the TI-82, the TI-86 followed up on the TI-85's
+advanced functionality while adding a stylish new case, assembly support
+similar to that of the TI-83, and greater memory capacity, while still
+maintaining compatibility with TI-85 programs. 
+(note taken from www.ticalc.org)
+
+
+Features:
+
+CPU: Z80 6 MHz
+Memory: RAM 128kB, ROM 256kB
+Screen: 128x64 pixels, 21x8 characters
+Known ROM versions: 1.2, 1.3, 1.4, 1.5, 1.6
+Link port
+
+
+Emulator:
+
+Emulator86 by Kirk Meyer
+TI86EMU by Steve Gordon (http://www.dogtech.com/cybop/ti86)
+TI-8X emulator by Randy Gluvna (http://ti8xemu.home.ml.org)
+Virtual 86 by Daniel Foesch (http://www.geocities.com/Area51/Station/7142/?startpage=v86.html)
+Virtual TI by Rusty Wagner (http://vti.acz.org)
+
+
+Links:
+
+Texas Instruments Homepage
+http://www.ti.com
+ticalc.org
+http://www.ticalc.org
+TI-Files
+http://www.ti-files.org
+
+
+MESS Emulation State:
+
+drivers for rom versions: 1.3, 1.4, 1.5, 1.6
+driver for ti86grom (homebrew rom by Daniel Foesch)
+sound emulated (speaker connected to link port)
+link port preliminary emulation
+grayscale effects emulated
+nvram emulated
+200Hz timer and ON key interrupts emulated
+snapshot loading (Virtual TI 2.0 save state files)
+
+
+Notes:
+
+1. After start TI-86 waits for ON key interrupt, so press ON key to start
+   calculator.
+2. Video engine (with grayscale support) based on the idea found in VTI source
+   emulator written by Rusty Wagner.
+3. NVRAM is saved properly only when calculator is turned off during MESS exiting.
+4. To receive data from TI press "R" immediately after TI starts to send data.
+5. To send data to calculator start receiving on TI and choose file from
+   Built-in File Manager.
+6. Homebrew rom by Daniel Foesch does nothing but showing charset.
+
+
+To do:
+
+many corrections of existing code
+port 3 and 4
+better artworks
+driver for rom version 1.2
+
+
+Needed:
+
+1. Info about ports 3 (bit 2 seems to be always 0) and 4.
+2. High quality artwork.
+3. Dumps of rom version 1.2
+
+
+$end
+
+#---------------------------------------------------------------------------------------------#
+
+#$info=ti99_2
+#$bio
+#Texas Instruments TI-99/2 BASIC Computer
+
+
+#Known Issues:
+
+#This TI99/2 driver is preliminary and could not be tested. (It may work,
+#it may not work.) It is commented out in the source code distribution.
+
+
+#History and Trivia:
+
+#The TI99/2 BASIC Computer was an attempt at producing a cheap ($100)
+#computer.  TI started designing it in the summer of 1982, it was first
+#introduced in January 1983, and it was abandoned, before entering
+#production, by April 1983.
+
+#It featured a TMS9995 microprocessor (with on-line timer and 256-byte RAM),
+#4kb of RAM, 24kb (or 32kb) of ROM, a B&W character-based display.  There
+#was no sound generator.  It was mostly incompatible with TI99/4(a), but
+#it used the same Basic syntax and file format.
+
+#The computer was obviously unattractive. On the other hand, it would have
+#been cheap, fairly fast for its time, and easy to program in both BASIC and
+#assembly.
+
+#Moreover, the expansion port of TI99/2 carried every bus signal, and even
+#allowed to disable the system ROMs and use one's own ROMs instead, so this
+#computer could have been a hobbyist's dream.
+
+
+#Wanted (dead or alive):
+#If you have an actual TI99/2 or TI99/2 ROM image at hand, please mail me at
+#pytheas@club-internet.fr
+
+#$end
+
+#---------------------------------------------------------------------------------------------#
+
+$info=ti99_4
+$bio
+Texas Instruments TI-99/4 Home Computer
+
+
+Known Issues:
+
+Requires full keyboard emulation.  At startup, full keyboard emulation mode is
+enabled by default.  Whilst in full keyboard emulation mode, some key
+associated functionality may be disabled (like the ESC key for EXIT).
+The keyboard emulation mode is toggled using the scroll_lock key.
+
+A TI-99/4 is not a TI-99/4a.  Most programs are compatible with both /4 and
+/4a, but some programs require a /4a.
+
+The BwG disk controller has display bug which causes it to change the character
+definitions for no appearent reason, but, out of this, it seems to work fine.
+If this is an issue, you may revert to the TI disk controller.
+
+
+Usage:
+
+See the sysinfo entry for the ti-99/4a driver.
+
+The only extra feature is the IR remote handsets.  This feature was abandoned
+by TI at the last minute, but the support was seemingly not deleted from the
+ti99/4 ROMs until the release of the ti99/4a.  This feature is disabled by
+default because some programs are incompatible with it, but it can be enabled
+by setting the IR remote handsets dip-switch on and resetting the emulator
+(press F3 in so-called partial keyboard emulation mode to reset the emulator).
+A few programs can use the improved joysticks (TI-Invaders seems to be one of
+them).
+
+
+History and Trivia:
+
+The TI99/4 Home Computer was designed and built by Texas Instruments.  About
+200 prototypes were built in 1978, it was first shown in June 1979, and TI
+started shipping it in October 1979.  It was replaced with TI99/4a in the
+summer of 1981.  It was first sold in US, then was available in Europe in
+early 1981.
+
+This computer was easy to use.  It displayed nice color graphics, and
+played sound.  It was highly expandable, too.  One expansion enabled the
+computer to speak.  Programs were generally on cartridges.  TI, which always
+tried to keep the control of program production, put an emphasis on games,
+education, and home utilities (home finance, etc.).  Incidentally, it was
+the first 16-bit home computer.
+
+The general architecture was odd.  The computer had only 256 bytes of CPU
+RAM, the remaining 16kb of RAM were attached to the video processor.  It
+had been designed to use some slow "GROM" cartridges, written in an
+interpreted language, "GPL".
+
+Due to these poor designing and programming choices, the computer was slow.
+The keyboard was uneasy to use, and there was serious bugs in ROMs.  Also,
+it wasn't until November 1980 that TI could build a TV modulator to attach
+the computer to a TV instead of a monitor.  Worse, the computer was awfully
+expensive for a home computer (more than $1000 with the monitor, more than
+$500 with the modulator).  Unsurprisingly, it is estimated that only a few
+dozen thousand units were sold.
+
+The design of TI99/4 caused many headaches to TI engineers.  It was first
+designed as a console, then an inexpensive home computer (which explains
+its slowness and kludgy design), then a hybrid (with remote I/R joysticks
+and keypads - which were abandoned at the last minute - and a cartridge
+port).  It was intended to use a TI-designed microcontroller, tms9985, but the
+processor was never actually produced, so engineers had to use a
+software-compatible, high-end (in 1979) tms9900 with tons of glue logic.
+Note that the processor software design was remarkably weird (no stack, no
+on-chip data register).
+
+$end
+
+#---------------------------------------------------------------------------------------------#
+
+$info=ti99_4a
+$bio
+Texas Instruments TI-99/4a Home Computer
+
+
+
+Known Issues:
+
+
+Requires full keyboard emulation.  At startup, full keyboard emulation mode is
+enabled by default.  Whilst in full keyboard emulation mode, some key
+associated functionality may be disabled (like the ESC key for EXIT).
+The keyboard emulation mode is toggled using the scroll_lock key.
+
+
+
+Usage:
+
+
+This TI-99/4a driver offers a high level of compatibility, and implements
+several optional extensions:
+
+
+* Image cartridges are in V9t9 format (see below for instructions).
+
+
+* Speech synthesis is emulated completely.  The speech synthesizer occasionally
+generates some weird noise instead of the expected phonemes.  I think the
+actual reason for this issue is the original ti-99/4(a) speech synthesizer did
+not use the tms5220 chip that is used under emulation: I think I have read
+somewhere that TI 99/8, which did use a tms5220, was affected by similar bugs.
+
+
+* Three types of memory expansion cards are emulated: the original TI 32kbyte
+card, the Super AMS card, and the Foundation card.
+
+
+* Any of three different floppy disk controllers can be emulated: TI's original
+SD disk controller, SNUG's BwG disk controller, and Myarc's HFDC disk
+controller.  These disk controllers have different abilities: TI's controller
+only supports single density disks with 9 sectors per track and 40 tracks per
+sides; the BwG controller supports double density, and it uses no VDP RAM at
+all; the HFDC controller supports 80-track floppy disks (high density support
+is incomplete and non-functional on the TI-99 because of issues with the DSR,
+though it works fine on the Geneve).  Four floppy disk drives are emulated,
+though the TI controller only supports three of them (the fourth disk drive
+will be ignored by the TI-99 if the TI controller is selected, but it will work
+fine with other controllers).  Floppy disk images are in V9T9 format.  The
+older MESS-specific format that was used in MESS .69 and earlier has been
+abandonned; note that this format was compatible with single-sided V9T9 disk
+images (but not double-sided ones).
+
+
+* In addition to the floppy drives, the HFDC can support up to 3 MFM hard
+disks.  If you want to use these hard disks, you must use the HFDC as a floppy
+disk controller.  Disk images use a variant of the MAME harddisk format that
+supports sector sizes other than 512 (the sector size for HFDC harddisks is
+256).  (BTW, early HFDC cards also included a tape interface  which is not
+emulated.)
+
+
+* Thierry Nouspickel's IDE card prototype is emulated.  A description can be
+found on Thierry's page along with the required disk-based DSR.  Note that
+there are two minor errors in the DSR disk image: the byte at offset >12 must
+be edited from >02 to >01, and the byte at offset >7601 must be edited from >21
+to >20; the byte at offset >13 should be edited from >02 to >01, too, but this
+is not a critical issue at present.  Note that the disk image does not work
+very well with the BwG disk controller, though I cannot figure out why (it
+works fine with both the TI controller and the HFDC controller).  The hard disk
+image is in the standard MESS/MAME hardddisk format; since MESS does not
+support image diff file currently, only un-compressed images can be written to
+(compressed images ARE supported, but only as read-only disks).
+
+
+* Serial port and PIO emulation is incomplete.  On the one hand, nothing useful
+can be done with the RS232 interface, but, on the other hand, the PIO interface
+enables you to redirect PIO output to a file and save listings to this file by
+"printing" them to PIO.
+
+
+* SNUG's HSGPL support is incomplete, but you can already play with it if you
+want to.  You will need the HSGPL DSR (and probably the software manual, too)
+from the SNUG web site to do anything useful.  The FEEPROM is saved to a file
+called "hsgpl.mem", in the memcard folder.  Its format is relatively simple:
+byte 0 is always 0, and the rest of the file is made of four similar sections
+for each Flash EEPROM (DSR, GROM0, GROM1, and ROM6); the first byte of each
+section is 0, the second should be 1, and the next 512kbytes is the raw FEEPROM
+data.   The DSR and system GROM0 needs to be loaded into the FEEPROM: to do so,
+you can use a hex editor to create a hsgpl.mem file in correct format.
+Afterwards, you may write extra GROM using the HSGPL DSR.  Note that Supercart
+and MBX paging are not emulated correctly, and there must be other issues.
+
+
+* The tape interface is emulated.  The CS1 unit is read/write, whereas CS2 is
+write-only.   Tapes are stored as sampled wave files.  You may find that the
+emulated tape interface is a relatively simple way to exchange files with
+real-world TI99s.
+
+
+
+Loading a cartridge:
+
+
+You do not need a cartridge image to run the computer, since TI99/4a has
+a small built-in basic interpreter.
+
+
+V9t9-format cart images are typically split into up to 3 files.  You MUST load
+all individual files.  Loading a single zip archive containing all the
+cartridge files will NOT work, you must uncompress the archive and select every
+file instead.  These files can be loaded in any order, as long as all necessary
+files are loaded.
+
+
+The following file name extensions are recognized for cartridges dumps:
+
+* "g.bin", ".grom" or ".g": GROM dump
+
+* "c.bin", ".crom" or ".c": CPU ROM dump
+
+* "d.bin", ".drom" or ".d": CPU ROM dump for second page (pages cartridges
+	only), to be loaded alongside a CPU ROM dump
+
+The following two types are supported as alternatives to the CPU ROM type
+(these extensions are only found in MESS, not V9T9):
+
+* "m.bin", ".mrom" or ".m": minimemory CPU ROM dump; similar to CPU ROM dump,
+	but the address range >7000->7fff is set up as RAM (paging is not
+	supporting); unfortunately, there is no way you can save the contents of
+	minimemory to disk
+
+* "b.bin", ".brom" or ".b": MBX CPU ROM dump; similar to CPU ROM dump, but the
+	address range >6c00->6ffd is set up as RAM, and the paging scheme is
+	different; unfortunately, I do not have any correct dump of a MBX cart to
+	test emulation with
+
+
+
+Setting up the system configuration:
+
+
+A few dip switches enable or disable computer extensions.  These switches are
+only read at reset.  Therefore, if you edit them, you must reset the emulator
+(press F3 in partial keyboard emulation mode) for the changes to be taken
+into account.
+
+
+
+History and Trivia:
+
+
+The TI-99/4a Home Computer was a TI-99/4 with improved keyboard, revised
+ROMs, and an additional graphics mode.  It was officially introduced in
+June 1981, and was retired in late 1983.
+
+
+TI99/4a was quite successful in Europe and US (possibly hundreds of
+thousand units built).  In 1983, though, competition on the home computer
+market was so harsh that TI had to cut down the price of TI99/4a to less
+than $100, while suffering heavy losses.  So, by the end of 1983, TI had
+abandoned TI99/4a, its prototype successors, and withdrawn from the home
+computer market.
+
+$end
+
+#---------------------------------------------------------------------------------------------#
+
+$info=ti99_4ev
+$bio
+Texas Instruments TI-99/4a Home Computer with SNUG EVPC video card
+
+
+See the TI99/4a driver for non-EVPC information.
+
+
+Known Issues:
+
+EVPC emulation is not complete.  The palette chip is not emulated.
+The computer may crash on soft reset, though I have no idea why.
+
+
+History and Trivia:
+
+A common hack on the ti99/4a is replacing the old tms9918/9928/9929a with
+an improved, upward-compatible v9938.  This enhanced vdp supports true 16-
+and 256-color graphic modes, high-res 512*192 graphic and 80-column text
+modes, accelerated 2D graphics, etc.  The only drawback is that some programs
+(including TI's own TI BASIC) will not run with the v9938.  Also, only
+specially designed programs can take advantage of the improved graphic modes.
+
+The EVPC card does just that: it includes a v9938 with 128kb of VRAM, 64kb of
+extended RAM, an additional palette chip to program the palette in 256-color
+mode, and a DSR ROM with various useful subroutines.
+
+Also, this driver uses a hacked TI BASIC GROM so that TI BASIC will work
+normally with the v9938.  Only two bytes were modified to derive file
+"994agr38.bin" from file "994agrom.bin": the bytes >F0 >0C >F8 at offset >216C
+of the file were changed to >00 >0C >00.  (This fix was contributed by Tony
+Knerr, but I have no idea who invented it first.)
+
+
+$end
+
+#---------------------------------------------------------------------------------------------#
+
+$info=ti990_10
+$bio
+Texas Instruments Model 990/10 Minicomputer System
+
+
+Known Issues:
+
+The controller panel is not emulated yet.
+
+The computer seems to lock when running various installation scripts, and
+rebuilding the system.
+
+
+Usage:
+
+This driver emulates a TI990/10 CPU with mapping option, 1Mbyte of RAM,
+a generic disk controller at TILINE base >1ff800, a generic tape controller
+at TILINE base >1ff880, and a 911 VDT at CRU base >0100.
+
+This is enough to build DX10 or DNOS. I have been able to build a working DX10
+3.7 or 3.6 system from the relevant build and backup tapes. (Tape loaded as
+tape unit #1 and a blank disk image as disk unit #1 (with the SCOSTA flag
+at offset >A4 set to >0002, so that the build tape does not try to format the
+disk)). I have even managed to install the fun and games tape, and play pacman.
+
+
+History and Trivia:
+
+Texas Instruments has been building minicomputers since the late 1960s through
+the 1980s.
+
+Around the summer of 1973, they started to design the TI990 as a successor to
+the 960 and 980 computers they were building at the time. In 1974, TI started
+to build the prototype of the TI990 series, the TI990/9.
+
+In 1975, they released the first commercial system, the TI990/10. It was
+a minicomputer built with TTL logic. Although it was a 16-bit CPU,
+it supported an optional mapper to expand address space from 64kbytes
+to 2Mbytes.
+
+The TI990 series development continued. In 1975 or 1976, TI started shipping
+the TMS9900 microprocessor, which implemented a subset of the TI990/10 feature
+set. Two CPU boards were built around the TMS9900: the TI990/4 (1976) and
+the improved TI990/5 (date unknown). These boards were much cheaper than the
+TI990/10, but they could only address 64kbytes, did not implement the memory
+bus fully (no DMA support), and could not run the DX10 OS.
+
+Around 1978, TI released the TI990/12, a higher-end TTL implementation, which
+was faster, and supported many additional instructions and features when
+compared to TI990/10. It was replaced with a revised but similar TI990/12LR
+computer in 1982 or 1983.
+
+In 1981, TI released the new TMS99000 microprocessor. In 1982, they replaced
+the TI990/10 CPU with a cheaper, smaller, faster, and more energy-efficient
+TI990/10A board built around the TMS99000 CPU. Additionally, they released
+an all-in-one Business System 300 (1982), later replaced with the Business
+System 300A (1984). Both computers included the CPU, RAM, video terminal, and
+hard disk/tape interface in a terminal case.
+
+The TI990 series must have been abandoned around 1985, when TI introduced
+the S1500 series built around a 68020.
+
+The TI990 computers were primarily used for business applications.
+
+Two disk-based OS were available. DX10 was a multi-tasking, multi-user OS.
+DNOS (released around 1981) was similar to DX10 and mostly compatible with it:
+it supported extra features but it was bigger and slower. Neither OS could run
+on the lower-end 990/4 and /5 systems, but a kernel and various OS utilities
+were available as static-link libraries for embedded applications.
+
+$end
+
+#---------------------------------------------------------------------------------------------#
+
+$info=tutor
+$bio
+Tomy Tutor (a.k.a. Grandstand Tutor)
+
+
+Known Issues:
+
+
+Cassette emulation does not work.
+
+
+
+Usage:
+
+
+The Tutor has three built-in programs:
+
+* Graphic is a Picture drawing program.  It enables you to create 256*192
+pictures in 16 colors, but the interface is awkward and I don't think the
+pictures drawn in this program can be saved.
+
+* Basic is a Basic interpreter derived from the TI99 Extended Basic.  Quite
+unfortunately, Basic lacks I/O routines and a serious graphic library.
+
+* GBasic is another Basic interpreter that is hidden in Graphic.  It is
+probably faster than Basic and has better graphic capabilities, but the
+language itself is unfortunately lacking.  And the editor simply sucks.
+
+
+A few cartridges were released: almost 40 games and a few educational programs.
+9 cartridges are known to have been dumped (8 games and an educational title).
+
+
+
+History and Trivia:
+
+
+This computer is known as Tomy Tutor in US, and as Grandstand Tutor in UK.  It
+was initially released in Japan in 1982 or 1983 under the name of Pyuuta
+(Pi-yu-u-ta, with a Kanji for the "ta").  The Japanese versions are different
+from the English-language versions, as they have different ROMs with Japanese
+messages and support for the katakana syllabus.  There are at least 4 versions:
+
+* original Pyuuta (1982 or 1983) with title screens in Japanese but no Basic
+(only the toy-like Gbasic interpreter is available)
+
+* Pyuuta Jr. (1983?) which is a console with a simplified keyboard
+
+* Tomy/Grandstand Tutor (circa October 1983?) with title screens in English and
+integrated Basic
+
+* Pyuuta Mk. 2 (1984?) with a better-looking keyboard and integrated Basic
+
+
+The Tutor was not extremely successful, probably due to the fact that little
+software was available (and that the software that was available was not varied
+enough).
+
+
+One question that remains open is the relationship between the Tutor and the
+TI-99 series.  From a hardware point of view, the Tutor has a lot in common
+with TI-99/4(a) (though the two computers are NOT compatible).  From a
+software point of view, the Tutor Basic is directly derived from TI Extended
+Basic (there is even a GPL interpreter in ROM, though the Tutor variant of GPL
+is quite different from TI GPL).  However, other Tutor software do not seem to
+be derived from TI-99 software.  It is therefore likely that Matsushita
+designed the Tutor independently from TI and licenced the TI Basic from TI as
+an afterthought; OTOH, the whole design might have originated from TI, as the
+computer really looks like a "TI-99/3" (the hardware is similar to the TI-99/4
+series, whereas the concept is very close to the TI-99/2).
+
+$end
+
+#---------------------------------------------------------------------------------------------#
+
+$info=trs80
+$bio
+Tandy/Radio Shack TRS-80 Model I
+
+
+Usage:
+
+keyboard - relatively close to the original layout.
+
+Take a look into the "Options" menu, accessible by hitting TAB, and choose "Keys (This 
+Machine)" to  find out more about the key mapping.
+
+
+cassette - emulation of virtual tapes supported.
+
+Use SYSTEM or CLOAD commands to read images.
+
+SYSTEM supports 6 character filenames and loads the corresponding FILENM.CAS image.
+
+CLOAD loads a file named BASIC(N).CAS, where (N) is the character you supplied 
+(e.g. CLOAD"M" loads BASICM.CAS)
+
+
+floppies - emulation of virtual floppy discs supported. 
+
+Use a NEWDOS/80 boot disk for drive 0 and set up correct PDRIVE parameters for the other drives. If only drives 0 to 2 are used they can be double sided by interpreting drive select 3 as head select bit.
+
+
+Under the "Options" menu, accessible by hitting TAB, there are three settings.
+
+"Floppy Disc Drives"  - enable or disable floppy disc controller.
+
+"Video RAM"           - enable upper case only or upper/lower font.
+
+"Virtual E000-EFFF"   - enable 4K Extension ROM or make it RAM.
+
+
+The TRS-80 driver should run most of the known programs out there. It supports a WD 179x 
+floppy disc controller with up to four virtual floppy disc drives contained in image files.
+
+
+History and Trivia:
+
+The Tandy TRS-80 model 1, released in August 1977 at a US retail price of $399 for just the 
+keyboard/computer or $599 including display and cassette storage unit, was the first member 
+of one of the most famous computer families.The earliest models used a poor BASIC interpreter 
+called Basic Level 1 (the interpreter and the OS fit in the 4 KB ROM) which had no instruction 
+to save the program! It was replaced later with the Basic Level 2 which needed a 12 KB ROM. 
+To offset its poor characteristics, Tandy developed a device called the Expansion Interface 
+which brought a lot of new features: 16, 32 or 48 KB RAM, two tape unit connectors, a printer 
+port, a floppy disk controller, a serial port and a real time clock.
+
+
+When it was connected to a floppy disk unit, the TRS 80 used the TRS DOS operating system, it 
+was pretty bugged and most of the TRS80 users preferred NEW DOS, it is an operating system 
+done by a third-party company called Apparat. This OS was the real TRS 80 operating system.
+
+
+The Model 1 was followed with the TRS 80 model II and model III (the model III had almost the 
+same characteristics as the model I).
+
+
+
+$end
+
+#---------------------------------------------------------------------------------------------#
+
+$info=uk101
+$bio
+Compukit UK101 (1979)
+
+
+Features:
+
+
+MESS Emulation State:
+
+
+$end
+
+#---------------------------------------------------------------------------------------------#
+
+$info=vc4000
+$bio
+Interton VC4000
+
+
+Console for TV connection (PAL only?)
+
+seams to be prequel of the arcadia 2001
+technical something between channel f and odyssey2
+
+sold from several firms with different names
+grundig super play computer 4000
+acetronic mpu1000/mpu2000
+prinztronic vc6000?
+radofin 1201?
+fountain 1392?
+hanimex?
+
+
+Features:
+
+grid 
+4 8x10 single color sprites
+single channel sound
+special << load/reset button (must be pressed after power up)
+special > select button
+special start button
+2 controller with analog joystick and 14 key keypad
+
+
+controller keypad:
+
+(keys do not have a label)
+a   b
+c d e
+f g h
+i j k
+l m n
+
+a,b,d are the same: fire
+
+
+Dumping Cartridges:
+
+9316 type roms are commonly used in these cartridges
+(a little bit different to 2716)
+look into messroms for a pinout of it
+
+MESS Emulation State:
+
+Based on info by Paul Robson, Christian Windler
+sponsored by Andreas W.
+
+
+$end
+
+#---------------------------------------------------------------------------------------------#
+
+$info=vcg
+$bio
+Palladium Video - Computer - Game
+
+
+Console
+
+emerson arcadia clone with different cartridge connector/pinout
+and 4 additional keys per controller
+
+look into messroms for cartridge pinout
+
+german version known with PAL video
+
+controller layout:
+
+(no labels)
+
+   2/fire
+x1   x2   x3
+ 1   x4    3
+ 4    5    6
+ 7    8    9
+Del   0  Enter
+
+
+MESS Emulation State:
+
+sponsored by Ward Shrake, Stefan P.
+same as arcadia
+additional keys supported
+
+$end
+
+#---------------------------------------------------------------------------------------------#
+
+$info=vectrex
+$bio
+GCE Vectrex
+
+
+Usage:
+
+Though the Vectrex emulation can be loaded with a cartridge image, starting without one will
+allow you to access the built-in game Minestorm (provided the system.img bios is present).
+
+
+Known Issues:
+
+No light pen support.
+
+
+Almost every cartridge is playable, except those requiring the light pen. See vectrex.crc for 
+a current compatibility list. Overlays are supported in .png format, using the same name as 
+the cartridge image being loaded. Place overlays in the artwork directory. The overlay for
+the built in minestorm game must be named "mine.png" to load when no image is selected.
+
+Current Bug -- The vectrex overlays have not worked in the 37 beta cycle. This is being 
+looked into.
+
+
+History and Trivia:
+
+The Vectrex was released in the US late in 1982 by General Consumer Electric (GCE) at a 
+suggested retail price of $199. The Vectrex differed from other consoles in that it had 
+it's own built in nine inch by eleven inch vector monitor, and thus didn't require (or 
+even allow) the use of a television set. The system even contained a built in game, the 
+Asteroids-like "Minestorm". 
+
+
+The monochrome Vectrex used screen overlays to give the illusion of colour, and also to 
+reduce the severity of the inherent flickering caused by the vector monitor.
+
+
+In 1983, GCE was merged into Milton Bradley, who expanded the Vectrex's market to include 
+Europe. As the video game market declined and then crashed, the Vectrex exited the market 
+in early 1984. The rights to the system reverted to it's developers, Smith Engineering. 
+
+
+Smith Engineering briefly considered designing a handheld version of the device in 1988, 
+though the success of the Nintendo Game Boy made such a project too risky. In the mid-1990s, 
+Smith Engineering condoned the duplication of the Vectrex system image and cartridges for 
+non-commercial uses.
+
+
+$end
+
+#---------------------------------------------------------------------------------------------#
+
+$info=vic20
+$bio
+Commodore VIC20 and VC20
+
+
+Cartridge Usage:
+
+Cartridges may have any of the following extensions: .bin .rom .a0 .20 .40 .60 .prg
+Files with boot-sign in it are recognized as roms. Some cartridges require more than one 
+image (for example, defender.60 defender.a0).
+
+
+.20 files loaded at 0x2000 
+
+.40 files loaded at 0x4000
+
+.60 files loaded at 0x6000
+
+.a0 files loaded at 0xa000
+
+.prg files loaded at address in its first two bytes
+
+.bin and .rom files are loaded at 0x4000 when 0x4000 bytes long, 
+otherwise they are loaded at 0xa000
+
+Note that .prg files are assigned to the quickloader (so you have to use 
+the -cart switch when loading rom images).
+
+
+Cassette Usage:
+
+Cassette images with the .wav or .prg extensions as well as multiple .prg files 
+contained within a zip file can be loaded. Zip files must be placed in the current directory, 
+and the contained prg files are played in sequential order.
+
+
+The format for WAVs are: 
+8 bit (16 bit may work, but hasn't been tested), mono, 12500 Hz minimum. This has the same 
+problems as an original Datasette tape drive (the tone head must be adjusted to get working 
+(no load error...) wav-files)
+
+
+Note that tape volume is DAC1 volume within the MESS UI On Screen Display Options (accessed
+with the tilde (~) key in the DOS version.
+
+
+Within the emulation, use LOAD or LOAD"" or LOAD"",1 for loading normal programs. Use 
+LOAD"",1,1 for loading programs to a special address.
+
+
+Diskette Usage:
+
+Disk drives are simulated at the moment, and only file loads from drive 8 and 9 
+are implemented. You can load a program file from the rom directory (*.prg,*.p00)
+(This must NOT be specified on command line, start the vc20 emulation with no images specified)
+ 
+
+You can also load a file from a d64 image (The directory command LOAD"$",8 is supported when 
+using d64 images).
+
+
+Within the emulation, basic programs can be loaded with: 
+
+LOAD"filename",8 
+
+
+Machine language programs can be loaded to their address with: 
+
+LOAD"filename",8,1
+
+
+When a program is loaded, type RUN or the appropriate SYS call to start it. 
+
+
+Note that several programs rely on more features not currently emulated (such as 
+loading other file types, writing...) Some games also rely on starting programs in the 
+floppy drive's processor (and therefore CPU level emulation of the 1541 is needed).
+
+
+Quickloader Usage:
+
+A quickloader is available via the f8 key. It supports program image files 
+with the .prg extension. This loads the program into memory and sets the program end 
+pointer. It works with most programs. The program can be started by entering "RUN" in 
+the emulation.
+
+
+Miscellaneous Usage Notes:
+
+Note that the pixel ratio for the PAL version is about 13/10 ! Resolution 1024x768 is good, 
+but only part of the screen is filled. 800x600 is acceptable. Better to define own display 
+mode (when the graphic driver supports this). For an acceptable display under XMESS, you can 
+use the following switches: 
+
+-scalewidth 3 -scaleheight 2
+
+
+If you run into difficulty, be sure to start the emulation with the -log switch, and look into
+the error.log file that is created in your mess directory.
+
+
+See "Keys (This Machine)" in the TAB/Options menu for key assignments. Some key usages of note: 
+
+stop-restore in many cases will cause the prompt to reappear.
+
+shift-cbm switches between upper-only and normal character set (if wrong characters are on 
+screen this often can help)
+
+run (shift-stop) load and start program from tape.
+
+
+The emulated light pen uses Paddle 3 x-axe and Paddle 4 y-axe.
+
+
+While a normal or well written program will work regardless of the video system (PAL or 
+NTSC), if the screen is too wide right or low, or the screen doesn't fit in visible 
+area or gameplay is too fast try using the PAL (vc20) version, instead.
+
+
+Known Issues:
+
+Some PC-Keyboards do not behave well when two or more special keys are pressed at the same 
+time (with my keyboard printscreen clears the pressed pause key!)
+
+The timer system only 98% accurate.
+
+The serial bus allows simple disk support, but no printer or other devices at present.
+
+No userport, no rs232/v.24 interface.
+
+No special expansion modules like ieee488 interface are supported in the expansion port.
+
+
+Image compatibility is quite high, see vic20.crc for a partial list. The emulation features a
+rasterline based video system which should be enough for all vic20 games and programs. The 
+emulation supports the keyboard, as well as joysticks, paddles and lightpen, via the emulated
+gameport, and simple Disk and Tape support. The expansion slot supports ram and rom 
+cartridges, though not special expansion modules (see known issues). For a more complete vic20 
+emulation, take a look at the very good vice emulator.
+
+
+History and Trivia:
+
+The Commodore VIC 20 was the successor of the CBM PET. It was designed by Bob Yannes at CBM, 
+he later designed the SID chip for the C64 and then went to Ensoniq to design synthesizers. 
+The VIC 20 used the same microprocessor and the same Basic language as the PET. It was very 
+popular in the early 80's. Commodore sold more than 1 million of this computer! A great range 
+of peripherals were developed for this computer as well as a lot of software. When it became 
+obsolete, Commodore replaced it by the Commodore 16 which had no success.
+
+Note that its name came from the name of its video chip VIC (Video Interface Chip) and 
+its memory size : 5 KB RAM + 15 KB ROM = 20 KB ! The European VC20 stands for VolksComputer.
+
+
+$end
+
+#---------------------------------------------------------------------------------------------#
+
+$info=vip
+$bio
+RCA Cosmac VIP (1977)
+
+
+very early home computer for TV connection
+
+
+Features:
+
+tape interface
+TV output
+integrated speaker
+
+
+MESS Emulation State:
+
+display, keyboard working
+Stopped. For me it is much too cryptic to operate and therefore not interesting.
+( I did it because it is the same hardware as in the studio2)
+
+
+$end
+
+#---------------------------------------------------------------------------------------------#
+
+$info=z88
+$bio
+Acorn Z88
+
+
+The Z88 is a portable system, with a LCD screen display and good sized keyboard.
+
+$end
+
+#---------------------------------------------------------------------------------------------#
+
+$info=zx80
+$bio
+Sinclair ZX 80 (1980)
+
+
+A home computer built in the United Kingdom.
+
+
+History and Trivia:
+
+The Sinclair ZX 80 is the ancestor of the Sinclair ZX 81. It had a short life (less than one 
+year) and was replaced with the ZX 81 which was more integrated and cheaper.
+
+
+$end
+
+#---------------------------------------------------------------------------------------------#
+
+$info=zx81
+$bio
+Sinclair ZX 81 / Timex Sinclair 1000 (1981)
+
+
+A home computer built in the United Kingdom.
+
+
+History and Trivia:
+
+The Sinclair ZX 81 was the successor of the ZX 80. It had the same characteristics as the 
+ZX 80, it's main difference (except for the colour) was its higher level of integration: the 
+ZX 80 used about 12 chips which had been replaced with a ULA in the ZX 81. This computer was 
+very successful in Europe at the beginning of the 80's. A large range of peripherals were 
+developed for the ZX-81, among them: 3.5" floppy disk units, high resolution graphic cards, 
+RS232 or Centronics interfaces, and RAM extensions. The ZX 81 was sold as the Timex-Sinclair 
+1000 in the USA. 
+
+
+$end
diff --git a/src/unix/doc/mess/windows.txt b/src/unix/doc/mess/windows.txt
new file mode 100644
index 0000000..f01c53b
--- /dev/null
+++ b/src/unix/doc/mess/windows.txt
@@ -0,0 +1,995 @@
+
+Using the program
+-----------------
+
+mame [name of the game to run] [options]
+
+For example:
+
+   mame mspacman -nosound
+
+...will run Ms Pac Man without sound
+
+
+Configuration options
+---------------------
+
+-createconfig / -cc
+
+	Creates the default MAME.INI file. All the following configuration
+	options can be permanently changed by editing this configuration file.
+
+-showconfig / -sc
+
+	Displays the current configuration settings. If you route this to a
+	file, you can use it as an INI file. For example, the command:
+
+		mame -showconfig >mame.ini
+
+	is equivalent to -createconfig.
+
+-showusage / -su
+
+	Displays a summary of all the command line options. For options that
+	are not mentioned here, the short summary given by "mame -showusage" is
+	usually sufficient.
+
+-[no]readconfig / -[no]rc
+
+	Enables or disables the reading of the config files. When enabled
+	(which is the default), MAME reads the following config files in order:
+
+		- MAME.INI
+		- $MY_MAME.INI (i.e. if MAME was renamed MAME060.EXE, MAME
+				parses MAME060.INI here)
+		- MAMED.INI  (if this is a debug build, i.e. MAMED.EXE)
+		- VECTOR.INI (for vector games only)
+		- DRIVER.INI (based on the source filename of the driver)
+		- PARENT.INI (for clones only, may be called recursively)
+		- GAMENAME.INI
+
+	The settings in the later ini's override those in the earlier ini's.
+	So, for example, if you wanted to disable hardware stretch in the
+	vector games, you can create a VECTOR.INI with the "hwstretch 0" line
+	in it, and it will override whatever hwstretch value you have in your
+	MAME.INI.
+
+-[no]verbose / -[no]v
+
+	Displays some diagnostic information at startup. IMPORTANT: when
+	reporting bugs, please run with mame -verbose and include the resulting
+	information. It can be very helpful in tracking down problems. The
+	default is off (-noverbose)
+
+
+Windows path and directory options
+----------------------------------
+
+IMPORTANT: Please use the path, directory and file options ONLY in MAME.INI.
+Otherwise, the outcome may be unpredictable and not consistent across releases.
+
+-rompath / -rp
+
+	You can give a path (list of directories seperated by semicolons) of
+	directories to be searched for roms. The default is ROMS (that is, a
+	directory "roms" in the current directory).
+
+-samplepath / -sp
+
+	You can give a path (list of directories seperated by semicolons) of
+	directories to be searched for samples. The default is SAMPLES (that
+	is, a directory "samples" in the current directory).
+
+-inipath
+
+	You can give a path (list of directories seperated by semicolons) of
+	directories to be searched for INI-files. The default is .;ini (that
+	is, search in the current directory first, and then in the directory
+	"ini" in the current directory).
+
+-cfg_directory
+
+	After running a game, MAME stores some user changeable settings into
+	cfg_directory/gamename.cfg. Additionally, on the first start of MAME a
+	cfg_directory/default.cfg is created. The default is CFG.
+
+-nvram_directory
+
+	The original hardware of some games use non-volative ram chips to save
+	their configuration. The contents of these are saved into this
+	directory. The default is NVRAM.
+
+-memcard_directory
+
+	The original hardware of some games supports so-called memory cards.
+	The contents of these are stored here. The default is MEMCARD.
+
+-input_directory
+
+	Input recordings created by "-record" will be saved here and loaded by
+	"-playback". The default is INP.
+
+-hiscore_directory
+
+	If there exists a file HISCORE.DAT in the MAME directory, highscores
+	may also be saved for games that do not have the original hardware to
+	support this. The quality of this feature depends on the accuracy of
+	the externally available file HISCORE.DAT. The default is HI.
+
+-state_directory
+
+	MAME supports state saving for some games. These states will be saved
+	here. The default is STATE.
+
+-artwork_directory
+
+	Some games used extra artwork not created by electical circuits. MAME
+	supports such artwork in PNG image format, located in this directory.
+	The default is ARTWORK.
+
+-snapshot_directory
+
+	Screenshots will go here. The default is SNAP.
+
+-diff_directory
+
+	Directory for hard drive image difference files. The default is DIFF.
+
+-ctrlr_directory
+
+	This directory holds controller-specific input port mapping .ini files.
+	The default is CTRLR.
+
+-history_file
+
+	The default is HISTORY.DAT. Modifying the default may not work at the
+	moment.
+
+-mameinfo_file
+
+	The default is MAMEINFO.DAT. Modifying the default may not work at the
+	moment.
+
+-cheat_file
+
+	The default is CHEAT.DAT. Modifying the default may not work at the
+	moment.
+
+
+Windows video options
+---------------------
+
+-[no]autoframeskip / -[no]afs
+
+	Automatically determines the frameskip level while you're playing the
+	game, adjusting it constantly in a frantic attempt to keep the game
+	running at full speed. Turning this on overrides the value you have set
+	for -frameskip above. The default is ON (-autoframeskip).
+
+-frameskip / -fs
+
+	Specifies the frameskip value. This is the number of frames out of
+	every 12 to drop when running. For example, if you say -frameskip 2,
+	then MAME will display 10 out of every 12 frames. By skipping those
+	frames, you may be able to get full speed in a game that requires more
+	horsepower than your computer has. The default value is -frameskip 0,
+	which skips no frames.
+
+-[no]waitvsync
+
+	Waits for the refresh period on your computer's monitor to finish
+	before starting to draw video to your screen. If this option is off,
+	MAME will just draw to the screen at any old time, even in the middle
+	of a refresh cycle. This can cause "tearing" artifacts, where the top
+	portion of the screen is out of sync with the bottom portion. Tearing
+	is not noticeable on all games, and some people hate it more than
+	others. However, if you turn this option on, you will waste more of
+	your CPU cycles waiting for the proper time to draw, so you will see a
+	performance hit. The default is OFF (-nowaitvsync). This option
+	requires -ddraw.
+
+-[no]triplebuffer / -[no]tb
+
+	Enables or disables "triple buffering". Normally, MAME just draws
+	directly to the screen, without any fancy buffering. But with this
+	option enabled, MAME creates three buffers to draw to, and cycles
+	between them in order. It attempts to keep things flowing such that one
+	buffer is currently displayed, the second buffer is waiting to be
+	displayed, and the third buffer is being drawn to. Unfortunately, due
+	to some DirectDraw issues, this doesn't always work out as well as it
+	should. This is still being investigated. The default is OFF
+	(-notriplebuffer). This option required -ddraw and -nowindow.
+
+-[no]window
+
+	Run MAME in either in a window or full screen. The default is OFF
+	(-nowindow).
+
+-[no]ddraw / -[no]dd
+
+	This is really just for testing. It disables the use of DirectDraw,
+	which removes a lot of the features of the video system (-triplebuffer,
+	-waitvsync, -resolution, -refresh, -switchres, -switchbpp, -resolution,
+	-hwstretch all won't work). It will generally run really slowly. If
+	anyone has a legitimate use for this option, we'd be curious to know.
+	The default is ON (-ddraw).
+
+-[no]hwstretch / -[no]hws
+
+	MAME uses the hardware stretching abilities of modern graphic cards to
+	scale the game image to the requested resolution. Depending on the
+	quality of your graphic card and its drivers, this may be a fractional,
+	antialiased scaling (nice) or an integer, blocky scaling (not so nice).
+	In any case, you can disable this stretching altogether and let MAME do
+	the scaling in software, which is probably slower, though. The default
+	is ON (-hwstretch). Note: Vector games may actually look better with
+	"-nohws".
+
+-cleanstretch [option] / -cs [option]
+
+	Stretch the image to integer ratios only. This may leave a black border
+	around the image in fullscreen mode. The options are:
+
+		none	    disable. This will cause artifacts when using
+			    scanlines.
+		auto	    let the blitter decide. The d3d module will select
+			    the best option.
+		full	    always stretch to integer ratios both horizontally
+			    and vertically.
+		horizontal  always stretch to integer ratios horizontally.
+		vertical    always stretch to integer ratios vertically.
+
+	The default is AUTO (-cleanstretch auto). This option requires -ddraw
+	or -direct3d.
+
+-resolution wxh[xd] / -r wxh[xd]
+
+	Specifies an exact resolution to run in. In full screen mode, MAME will
+	try to use the specific resolution you request. The width (w) and
+	height (h) are required; the color depth (d) is optional. If omitted or
+	set to 0, MAME will determine the mode auomatically. For example,
+	-resolution 640x480 will force 640x480 resolution, but MAME is free to
+	choose the color depth. Similarly, -resolution 0x0x32 will force 32-bit
+	color depth, but allows MAME to choose the resolution. The string
+	"auto" is also supported, and is equivalent to 0x0x0. In window mode,
+	this resolution is used as a maximum size for the window. The default
+	is auto (-resolution auto). This option requires -ddraw for full screen
+	resolution switching.
+
+-refresh
+
+	Specifies a particular refresh rate to set your monitor to. If the
+	refresh rate is not found, or if this parameter is 0, the default
+	DirectDraw refresh rate is used. The default is -refresh 0. This option
+	requires -ddraw and -nowindow.
+
+-[no]scanlines / -[no]sl
+
+	Enables the classic MAME "scanlines" effect. The default is OFF
+	(-noscanlines). This option requires -nohwstretch.
+
+-[no]switchres
+
+	Enables resolution switching. This option is required for the
+	-resolution option to switch resolutions in full screen mode. On many
+	modern video cards with hardware stretching support, there is little
+	performance penalty at higher resolutions, so it is nice to be able to
+	get rid of the monitor resync time when you run in full screen mode.
+	This is also useful on LCD displays with a fixed resolution. The
+	default is ON (-switchres). This option requires -ddraw.
+
+-[no]switchbpp
+
+	Enables color depth switching. This option is required for the
+	-resolution option to switch color depths in full screen mode. This
+	option is useful if you normally run at 16, 24, or 32 bit color depth
+	on your desktop, and want to keep that color depth when you run MAME.
+	The default is ON (-switchbpp). This option requires -ddraw.
+
+-[no]maximize / -[no]max
+
+	Controls initial window size in windowed mode. If it is set on, the
+	window will initially stretch to the maximum supported size when you
+	start MAME. If it is turned off, the window will start out at the
+	smallest supported size. The default is ON (-maximize). This option
+	requires -window.
+
+-[no]keepaspect / -[no]ka
+
+	Enables aspect ratio enforcement. When this option is on, the game's
+	proper aspect ratio (generally 4:3 or 3:4) is enforced, so you get the
+	game looking like it should. When running in a window with this option
+	on, you can only resize the window to the proper aspect ratio, unless
+	you are holding down the CONTROL key. By turning the option off, the
+	aspect ratio is allowed to float. In full screen mode, this means that
+	all games will stretch to the full screen size (even vertical games).
+	In window mode, it means that you can freely resize the window without
+	any constraints. The default is ON (-keepaspect).
+
+-[no]matchrefresh
+
+	Enables refresh rate matching. When enabled, MAME will try to find the
+	closest refresh rate match that is greater than the game's refresh
+	rate. For example, if the game runs at 57fps, and you have 60, 70, 75Hz
+	refresh rates, MAME will choose 60Hz. If the game runs at 61fps, then
+	it will choose 70Hz. This is intended mainly for those who have tweaked
+	their video card's settings to provide carefully matched refresh rate
+	options. The default is OFF (-nomatchrefresh). This option requires
+	-ddraw and -nowindow.
+
+-[no]syncrefresh
+
+	Enables speed throttling only to the refresh of your monitor. This
+	means that the game's actual refresh rate is ignored; however, the
+	sound code still attempts to keep up with the game's original refresh
+	rate, so you may encounter sound problems. Again, this is intended
+	mainly for those who have tweaked their video card's settings to
+	provide carefully matched refresh rate options. The default is OFF
+	(-nosyncrefresh). This option requires -ddraw.
+
+-[no]throttle
+
+	Configures the default thottling setting. When throttling is on, MAME
+	attempts to keep the game running at the game's intended speed. When
+	throttling is off, MAME runs the game as fast as it can. The default is
+	ON (-throttle).
+
+-full_screen_brightness / -fsb
+
+	Some video cards adjust the brightness/gamma when they switch into full
+	screen mode. To counteract this, you can specify the
+	-full_screen_brightness value, which is a number between 0.1 and 2. 0.1
+	means 1/10th as bright as the default, and 2 means twice as bright.
+	Note that the hardware support for this option is not present on all
+	video cards. If you set a non-zero value, you may get a warning if MAME
+	was unable to set the brightness on your card. The default is 0, which
+	means that MAME will not attempt to adjust the brightness on your video
+	card at all. This option requires -ddraw and -nowindow.
+
+-frames_to_run / -ftr
+
+	This option can be used for benchmarking. It tells MAME to stop
+	execution after a fixed number of frames. By combining this with a
+	fixed set of other command line options, you can set up a consistent
+	environment for benchmarking MAME performance.
+
+-effect
+
+	Apply various blitting effects to emulate the look of Arcade monitors.
+	Using these modes comes at the cost of reduced emulation speed, which
+	is inherent to these modes. The current implementation is already as
+	fast as possible, using self-modifying assembly code. For some of
+	these, MMX is required. Possible values:
+
+		none	    no effect (this is the default)
+		sharp	    no effect, but gives a sharper image
+		scan25	    25% scanlines
+		scan50	    50% scanlines
+		scan75	    75% scanlines
+		scan75v     75% scanlines (vertical)
+		rgb3	    a certain "monitor mask"
+		rgb4	    another one
+		rgb4v	    another one (vertical)
+		rgb6	    another one
+		rgb16	    another one
+		rgbtiny     another one. Choose the one you like best.
+
+-screen_aspect
+
+	Give a screen aspect ration in the form X:Y where X is the horizontal
+	and Y the vertical part. Examples are 4:3 for most resolution settings
+	on computer monitors, 5:4 for the 1280x1024 resolution or 3:4 for
+	turnable LCD's in the turned position. The default is 4:3.
+
+
+Windows video options (Direct3D)
+--------------------------------
+
+-[no]direct3d / -[no]d3d
+
+	Use Direct3D to display the image. This does not render 3D games using
+	3D hardware, it just uses 3D hardware to display the image, and apply
+	effects to it. -triplebuffer, -waitvsync, -resolution, -refresh,
+	-switchres, -switchbpp, -resolution all work with this option. This
+	option overrides -ddraw and implies -hwstretch. The default is OFF
+	(-nodirect3d).
+
+-[no]d3dtexmanage
+
+	Let Direct3D handle conversion of the image to a texture (required to
+	display it with Direct3D). This is more compatible, but can be
+	(significantly) slower on some hardware. The default is ON
+	(-d3dtexmanage). Using -nod3dtexmanage can eliminate a loss of
+	performance that may occur with some graphics cards when using
+	-direct3d. This option requires -direct3d.
+
+-zoom [z] / -z [z]
+
+	Try to get a resolution that enlarges the emulated game z times. The
+	default is -zoom 2. MAME determines the resolution automatically. This
+	option only works with -direct3d.
+
+-d3dfilter [f] / -flt [f]
+
+	Select the type of filtering to apply to the image when stretching. 0
+	is point filtering, 1 is bi-linear filtering, 2 is bi-cubic filtering
+	(flat kernel), 3 is bi-cubic filtering gaussian kernel), 4 is
+	anisotropic filtering. Note that very few graphics cards support
+	bi-cubic filtering, and that older graphics cards may not support
+	anisotropic filtering. The default is bi-linear filtering (-d3dfilter
+	1). This option requires -direct3d.
+
+-d3dscan [i]
+
+	Select the scanline effect intensity in percentages. 0 is black lines
+	between scanlines, 100 is disable scanline effect. The default is
+	DISABLE (-d3dscan 100). This option requires -direct3d.
+
+-d3dfeedback [i]
+
+	Select the feedback effect intensity in percentages. 0 is disable,
+	higher values feed back the previous frame to the current one at the
+	specified intensity. The default is DISABLE (-d3dfeedback 0). This
+	option requires -direct3d.
+
+-d3dprescale [option]
+
+	Pre-scale up the image with point filtering before fitting the image to
+	the screen. This gives an only slightly fuzzy image even at high
+	display resolutions. The options are:
+
+		none	    disable.
+		auto	    adaptively apply a moderate pre-scale effect,
+			    depending on other efects used.
+		full	    adaptively apply an agressive pre-scale effect.
+		n	    (where 2 <= n <= 4) pre-scale the image n times.
+
+	The default is AUTO (-d3dprescale auto). This option requires
+	-direct3d.
+
+-d3deffect [preset]
+
+	Select an effect preset. Valid presets are:
+
+		none		no effect (this is the default)
+		sharp		no effect, but gives a sharper image
+		scan25		25% scanlines
+		scan50		50% scanlines
+		scan75		75% scanlines
+		scan75v 	75% scanlines (vertical)
+		rgbmicro	a certain "monitor mask"
+		rgbtiny 	another one
+		rgb3		another one
+		rgb4		another one
+		rgb4v		another one (vertical)
+		rgb6		another one
+		rgb16		another one
+		rgbminmask	another one
+		dotmedmask	another one
+		rgbmedmask	another one
+		dotmedbright	another one (extra bright)
+		rgbmaxbright	another one (extra bright)
+		aperturegrille	another one. Choose the one you like best.
+		auto		adaptively selects a special preset based on
+				zoom level.
+
+	The default is none (-d3deffect none). This option requires -direct3d.
+
+-d3dcustom [custom preset]
+
+	Supply a custom preset. The format is <-d3dcustom
+	1,0,0x0100,0xC0,0,0,0,0x22,-1,8x8_mame_rgbtiny.rgb>. The meaning
+	of the mumbers is:
+
+		1	    RGB effects mode: 0 is off, 1 is multiply mode, 2
+			    is add and multiply mode.
+		2,3,4,5     pattern preprocessing; use mask, white level, black
+			    level, desaturation, respectively.
+		6	    image attenuation
+		7	    feedback (0 is don't use)
+		8	    prescale. bit 4: prescale horizontally, bit 0:
+			    prescale vertically.
+		9	    maximum scanline intensity.
+		10	    pattern filename, including path.
+
+	The filename must start with XxY, where X and Y are the dimensions of
+	the pattern in pixels. Each pixel is represented by 4 bytes, red,
+	green, blue, and mask, respectively. mask is an on/off value, where 0
+	is off. This option requires -direct3d.
+
+-d3dexpert [settings]
+
+	Undocumented settings intended mostly for developers. This option
+	requires -direct3d.
+
+
+Windows sound options
+---------------------
+
+-audio_latency
+
+	This controls the amount of latency built into the audio streaming. By
+	default MAME tries to keep the DirectSound audio buffer between 1/5 and
+	2/5 full. On some systems, this is pushing it too close to the edge,
+	and you get poor sound sometimes. The latency parameter controls the
+	lower threshold. The default is 1 (meaning lower=1/5 and upper=2/5).
+	Set it to 2 (-audio_latency 2) to keep the sound buffer between 2/5 and
+	3/5 full. If you crank it up to 4, you can definitely notice the lag.
+
+
+Windows misc options
+--------------------
+
+-[no]sleep
+
+	Since MAME is running in a multitasking environment, it should be nice
+	to its fellow processes. Therefore, if MAME does not need all
+	processing power to emulate a game, it gives back already granted
+	processor time to the operating system. This may not work in every
+	case, so it can be disabled and MAME turned once again into a CPU hog.
+	The default is ON (-sleep).
+
+-[no]high_priority
+
+	Increases the thread priority so MAME runs better. The default is OFF
+	(-nohigh_priority).
+
+-[no]rdtsc
+
+	Prefer RDTSC over QueryPerformanceCounter for timing. The default is
+	OFF (-nordtsc). -rdtsc sometimes causes problems on laptops, and
+	-nordtsc may cause problems on desktop computers. If MAME does not
+	operate smoothly (and you are sure you have enough CPU power for
+	the emulation), try toggling this.
+
+
+Input device options
+--------------------
+
+-[no]mouse
+
+	Controls whether or not MAME looks for a mouse controller to use. When
+	this is enabled, you will not be able to use your mouse in Windows
+	while playing a game. If you want to get control of your computer back,
+	you will need to pause the game, or quit. The default is OFF
+	(-nomouse).
+
+-[no]joystick / -[no]joy
+
+	Controls whether or not MAME looks for joystick/gamepad controllers.
+	When this is enabled, MAME will ask DirectInput about which controllers
+	are connected. The default is OFF (-nojoystick).
+
+-[no]steadykey / -[no]steady
+
+	Some games require two or more buttons to be pressed at exactly the
+	same time to make special moves. Due to limitations in the PC keyboard
+	hardware, it can be difficult or even impossible to accomplish that
+	using the standard keyboard handling. This option selects a different
+	handling that makes it easier to register simultaneous button presses,
+	but has the disadvantage of making controls less responsive. The
+	default is OFF (-nosteadykey)
+
+-[no]keyboard_leds / -[no]leds
+
+	Since MAME uses an input device (keyboard) for output, this sort of
+	belongs here. Using this option enabes/disables simulation of the game
+	LEDs by the keyboard LEDs. This works fine, but can lead to problems
+	after exiting MAME (i.e. CAPS LOCK remains ON), so you can disable it
+	here. The default is ON (-keyboard_leds).
+
+-ctrlr <controller>
+
+	Enables support for special controllers. Configuration files are
+	provided for:
+
+		hotrod	    HotRod
+		hotrodse    HotRod SE
+		slikstik    SlikStik
+		xarcade     X-Arcade
+
+	There is extra documentation available about this in the file
+	ctrlr.txt.
+
+-a2d_deadzone / -a2d
+
+	If you play with an analog joystick, but the game requires digital
+	input, MAME needs to convert the signals. Here you can give the ratio
+	of movement along an axis that accounts for a digital signal. This
+	option expects a float in the range of 0.0 to 1.0. The default is 0.3.
+	Note: the current handling is not precise, as it does also implicitely
+	set the size of the arc which is interpreted as diagonal movement. This
+	is a known problem but it requires some major rework of the input
+	handling code to fix it.
+
+
+MAME core video options
+-----------------------
+
+-[no]norotate
+-[no]autorol
+-[no]autoror
+-[no]rol
+-[no]ror
+-[no]flipx
+-[no]flipy
+
+	These are the standard MAME rotation options. They are all OFF by
+	default.
+
+-debug_resolution wxh / -dr wxh
+
+	Specifies the resolution of the debugger bitmap in the debug build.
+	This controls how big the debugger window will be, and therefore, how
+	many rows/columns it will display. The default value is 0x0, which sets
+	the automatic 640x480 default debugger size. Note that the debugger is
+	only available when running in a window.
+
+-gamma
+
+	This controls the global gamma correction in the game. It is the same
+	gamma that is applied when you bring up the on-screen-display within
+	MAME. The default is 1.0.
+
+-brightness / -bright
+
+	This controls the global brightness correction in the game. It is the
+	same brightness that is applied when you bring up the on-screen-display
+	within MAME. The default is 1.0.
+
+-pause_brightness
+
+	This controls the brightness level when MAME is paused. The default
+	value is 0.65.
+
+
+MAME core vector options
+------------------------
+
+-[no]antialias / -[no]aa
+
+	Antialiasing for vector games. The default is ON (-antialias).
+
+-[no]translucency / -[no]tl
+
+	Enables or disables vector translucency. Colors of crossing vector
+	beams will be merged. The default is ON (-translucency).
+
+-beam
+
+	Sets the width in pixels of the vectors. This option expects a float in
+	the range of 1.00 through 16.00 as argument. The default is 1 (1 pixel
+	wide).
+
+-flicker
+
+	Makes the vectors flicker. This option requires a float argument in the
+	range of 0.00 - 100.00 (0=none, 100=maximum). The default is 0.
+
+-intensity
+
+	Sets the intensity correction for the beam. Higher values give a
+	brighter beam. This option expects a float in the range of 0.5 through
+	3.0 as argument.  The default is 1.5.
+
+
+MAME core sound options
+-----------------------
+
+-[no]sound
+
+	Enable or disable sound altogether. The default is ON (-sound).
+
+-[no]samples
+
+	Use samples if available. The default is ON (-samples).
+
+-volume / -vol
+
+	Sets the startup volume. It can later be changed with the On Screen
+	Display (see Keys section). The volume is an attenuation in dB: e.g.,
+	"-volume -12" will start with -12dB attenuation. The default is 0.
+
+-samplerate / -sr
+
+	Sets the audio sample rate. Smaller values (e.g. 11025) cause lower
+	audio quality but faster emulation speed. Higher values (e.g. 44100)
+	cause higher audio quality but slower emulation speed. The default is
+	44100.
+
+-[no]resamplefilter
+
+	If the samplerate of the original hardware does not match the
+	samplerate actually used by an integer factor, apply a filter. This is
+	more faithful to the original sound, however, the sound may not be as
+	crisp. The default is ON (-resamplefilter).
+
+
+MAME core misc options
+----------------------
+
+-[no]artwork / -[no]art
+
+	Enable or disable usage of additional artwork (backdrops, overlays,
+	etc.). The default is ON (-artwork).
+
+-[no]use_backdrops / -[no]backdrop
+
+	Enables/disables the display of backdrops. The default is ON
+	(-use_backdrops).
+
+-[no]use_overlays / -[no]overlay
+
+	Enables/disables the display of overlays. The default is ON
+	(-use_overlays).
+
+-[no]use_bezels / -[no]bezel
+
+	Enables/disables the display of bezels. The default is ON
+	(-use_bezels).
+
+-[no]artwork_crop / -[no]artcrop
+
+	This will crop the artwork to the game screen area only. The default is
+	OFF (-noartwork_crop).
+
+-artworkresolution / -artres
+
+	Scale the game by this factor to accommodate for higher resolution
+	artwork. The default is 0 (auto).
+
+-bios
+
+	Expects a BIOS name as the parameter. -listinfo/xml will list the
+	possible BIOS names for a game/system.
+
+-[no]skip_disclaimer
+
+	Forces MAME to skip displaying the disclaimer screen. The default is
+	OFF (-noskip_disclaimer).
+
+-[no]skip_gameinfo
+
+	Forces MAME to skip displaying the game info screen. The default is OFF
+	(-noskip_gameinfo).
+
+-[no]cheat / -[no]c
+
+	Cheats, like the speedup in Pac Man or the level-skip in many other
+	games, are disabled by default. Use this switch to turn them on. The
+	default is OFF (-nocheat).
+
+-[no]debug
+
+	Activates the integrated debugger.  During emulation, press the tilde
+	key (~) to activate the debugger. This is available only if the program
+	is compiled with MAME_DEBUG defined. The default is OFF (-nodebug).
+
+-playback / -pb
+
+	Expects a filename as parameter. Play back all game inputs from from
+	file INP/filename.inp. The gamename is contained in this file,
+	therefore a gamename needs not be given on the commandline.
+
+-record / -rec
+
+	Expects a filename as parameter. All game inputs are written to the
+	file INP/filename.inp.
+
+-[no]log
+
+	Creates a log of illegal memory accesses in ERROR.LOG. The default is
+	OFF (-nolog).
+
+-maxlogsize
+
+	Expects a number as parameter. If the size of error.log (in kilobytes)
+	hits that number, MAME will exit. By default, this is set fairly low
+	(10 MB). This is in effect only if you are actually generating the
+	error.log file.
+
+
+Other MAME frontend options
+----------------------------
+
+Note: By default, all the '-list' commands below write info to the screen. If
+you wish to write the info to a textfile instead, add this to the end of your
+command:
+
+  > filename
+
+...where 'filename' is the textfile's path and name (e.g., c:\mame\list.txt).
+
+-help / -?
+
+	Displays current MAME version and copyright notice
+
+-[no]clones
+
+	Used together with the list commands, enables/disables listing of
+	alternate ("cloned") versions of the same game. The default is ON.
+
+-list / -ls
+
+	Displays a list of currently supported games.
+
+-listfull / -ll
+
+	Displays a list of game directory names + descriptions.
+
+-listgames
+
+	List the supported games, year, manufacturer.
+
+-listdetails
+
+	Displays a detailed list of drivers and the hardware they use.
+
+-listsourcefile
+
+	Displays the source file (in the drivers directory) containing the
+	driver for the specified game. Useful for finding which driver a game
+	runs on in order to fix bugs.
+
+-listinfo / -li
+
+	List comprehensive details for all of the supported games. The output
+	is quite long, so better redirect this into a file. The output is in
+	MAME's own format, see listinfo.txt for details.
+
+-listxml / -lx
+
+	List comprehensive details for all of the supported games. The output
+	is quite long, so better redirect this into a file. The output is in
+	XML format.
+
+-listclones / -lc
+
+	Lists clones of the specified game. When no game is specified, this
+	generates a list of all MAME-supported clones.
+
+-listsamdir
+
+	List directory names for samples. Some clones can share their samples
+	with their parents (no pun intended).
+
+-listcrc
+
+	List CRC32 checksums of rom files
+
+-listdupcrc
+
+	Find romfiles with same CRC32 (for developers).
+
+-listroms
+
+	Displays ROMs required by the specified game.
+
+-listsamples
+
+	Displays samples required by the specified game.
+
+-verifyroms
+
+	Checks specified game(s) for missing and invalid ROMs.	Adding "*"
+	checks all available games.
+
+-verifysets
+
+	Checks specified game(s) and reports its status. Adding "*" checks all
+	available games. Terse output.
+
+-vset
+
+	Checks specified game(s) and reports its status. Adding "*" checks all
+	available games. Slightly more verbose output.
+
+-verifysamples
+
+	Check selected game for missing samples. Adding "*" checks all
+	available samples.
+
+-vsam
+
+	Check selected game for missing samples. Adding "*" checks all
+	available samples.
+
+-romident
+
+	Attempts to identify ROM files, if they are known to MAME, in the
+	specified .zip file. Can be used to try and identify ROM sets taken
+	from unknown boards.
+
+-isknown
+
+	Very terse romident.
+
+-crconly
+
+	Uses only CRC-32 for all integrity checks. Disables the use of SHA-1
+	checks when loading the ROMs.
+
+-gamelist
+
+	Used internally to create gamelist.txt
+
+-sortname
+-sortdriver
+
+	Used internally for creating gamelist.txt
+
+-listcpu
+-listcpuclass
+-listgamespersourcefile
+-listnosound
+-listnvram
+-listpalettesize / -lps
+-listromdistribution
+-listromnumber
+-listromsize / -lrs
+-listsound
+
+	Lists various statistical data.
+
+-listwrongmerge / -lwm
+-wrongfps
+-wrongorientation
+
+	Attempts to catch careless developers.
+
+
+Keys
+----
+
+Tab	     Toggles the configuration menu
+
+Tilde	     Toggles the On Screen Display. Use the up and down arrow keys to
+	     select the parameter (global volume, mixing level, gamma
+	     correction etc.), left and right to arrow keys to modify it.
+
+P	     Pauses the game
+
+Shift+P      While paused, advances to next frame
+
+F1	     toggle raster effects in some games
+
+F2	     Service Mode
+
+F3	     Resets the game
+
+F4	     Shows the game palette, decoded GFX, and any tilemaps
+	     Cursor left/right changes between palette, GFX and tilemaps
+	     Cursor up/down cycle through valid palettes
+	     Page up/down scroll through the palette and GFX
+	     Page up/down, D, G scroll the tilemap display
+	     Ctrl & Shift are modifiers to change movement speed.
+	     F4 or Esc returns to the emulation.
+	     Note: Not all games have decoded graphics and/or tilemaps.
+
+F5	     Toggle debugger (only in debug build)
+
+F6	     Toggle cheat mode (if started with "-cheat")
+
+F7	     Load a 'Save State'. You will be requested to press a key to
+	     determine which Save State you wish to load. Note that the 'Save
+	     State' feature is for developing drivers and not intended for
+	     users. It is incomplete and works only on a number of drivers. Use
+	     at own risk.
+
+Shift+F7     Create a 'Save State'. Requires an additional keypress to identify
+	     the state.
+
+F8	     Decrease frame skip on the fly
+
+F9	     Increase frame skip on the fly
+
+F10	     Toggles speed throttling
+
+F11	     Toggles speed display
+
+Shift+F11    Toggles profiler display (debug builds only)
+
+F12	     Saves a screen snapshot. The default target directory is SNAP.
+
+ESC	     Exits emulator
+
diff --git a/src/unix/doc/multiplayer-readme.txt b/src/unix/doc/multiplayer-readme.txt
new file mode 100644
index 0000000..2b6c190
--- /dev/null
+++ b/src/unix/doc/multiplayer-readme.txt
@@ -0,0 +1,163 @@
+	Multiplayer Network XMame N0.5
+	(Rewrite by Steve Freeland, caucasatron@yahoo.ca)
+	------------------------------
+	mame version 0.60.1
+
+Usage (for an n-player game):
+-----
+Start a master:
+    xmame.<display method> -master <n> <other options> <game name>
+Start n - 1 slaves:
+    xmame.<display method> -slave <master hostname> <other options> <game name>
+Currently there can only be one slave per machine, although a slave
+can share a machine with the master.
+Optional, uh, options:
+-netmapkey:  When the slave is invoked with this switch, it will remap
+control so that regardless of whatever player number the slave is
+assigned, the controls used are those configured for player 1
+(which you're likely to have configured to something convenient).
+-parallelsync:  This option (given to the master) improves overall
+performance at the price of responsiveness:  Your input will be
+processed with a delay of roughly 16 milliseconds.  If your reflexes
+are fast enough to make that a noticeable problem, may I suggest a
+career in professional table tennis?
+
+Message format
+--------------
+Each UDP packet has a 4-byte header followed by a body.
+The header has a 3-byte magic string "XNM" followed by a 1-byte message type.
+The contents of the message body depends on the message type, and
+there may in fact not be a body.
+
+Message types:  See enum msg_type_t in src/unix/network.c in case
+-------------   this doc is out of date
+JOIN:  This is the first message the slaves send to the master for
+handshaking.  The body contains a string identifying the slave
+(<hostname>/<pid>), the slave's MAME build version and net protocol
+version, and the name of the game being played.  If any of the latter
+3 do not match the master's information, the master will refuse the
+join.  The slave id string is currently only used for logging.
+
+ACCEPT:  This is the master's reply to the slave if the protocol
+versions and game name match.  The body contains is the player number
+assigned to the slave (usually 2 to 4; the master is always player 1),
+the id strings and IP addresses for all the other slaves, and any
+extra information required about the protocol (currently: whether
+parallelsync is enabled)
+
+REFUSE:  This is the master's reply to the slave if the protocol
+versions and/or game name do not match.  There is no body.
+
+LOCAL_STATE:  This message is sent out each frame (when osd_net_sync() is
+invoked) by each peer to all the other peers.  It contains a
+sequence number (see Protocol below) and a byte order-normalized copy
+of the slave's current input_port_values[] array.  Each peer uses
+incoming messages of this type to compute the input global state.
+
+QUIT:  Sent when a client or the master exits and allows the remaining
+participants to handle the exit gracefully without having wait for a timeout.
+
+ACKs and ACKable messages:  Certain message types are designated
+"ACKable":  these are intermixed with the regular LOCAL_STATE messages
+which make up the bulk of the traffic.  An ACKable is sent out by a
+peer at the beginning of a frame *instead* of a LOCAL_STATE message.
+The peer then waits for the recipient to send an ACK (acknowledgement)
+message in response, at which point the LOCAL_STATE can be sent out.
+Currently the following message types are "ACKable":  ACCEPT and QUIT.
+
+Protocol
+--------
+Each frame, upon invocation of osd_net_sync(), each peer sends its
+local input state to each of the other peers, then waits for the
+incoming messages containing the local input state for each of the other
+peers to arrive.  When all have been received the global input state
+is computed, osd_net_sync() exits and emulation proceeds exactly as if
+the input had been received through a local input device rather than
+the network.
+Since the protocol uses UDP messages rather than TCP (in order to
+minimize the impact of latency) there is no guarantee that a message
+sent will arrive at its destination, or how long it will take even if
+it does arrive.  Therefore a peer may need to re-send a local input
+state if conditions arise which indicate the previous message did not
+reach its destination in time.
+
+                               +--------+
+			       | SYNCED |
+			       +--------+
+                                    |
+== Frame n begins ==================+======================================
+                                    |
+                 +------------------+-----------------+
+  Send ACKable n |		                      | Send state n
+                 v                                    v
+     +----------------------+              +----------------------+
+     | ack_expected   = yes | rcv ACK n    | ack_expected   = no  |
+     | state_expected = yes |------------->| state_expected = yes |
+     +----------------------+ send STATE n +----------------------+
+          |  ^   |   ^  |                      |  ^   |   ^  |
+      rcv |  |   |   |  | rcv STATE        rcv |  |   |   |  | rcv STATE
+  ACKable |  |   |   |  | n - 1        ACKable |  |   |   |  | n - 1
+        n |  |   |   |  |                    n |  |   |   |  |
+          v  |   |   |  v                      v  |   |   |  v 
+ send ACK |  |   |   |  | send STATE  send ACK |  |   |   |  | send STATE
+        n |  |   |   |  | n - 1              n |  |   |   |  | n - 1
+          +--+   |   +--+                      +--+   |   +--+
+                 |                                    |
+     rcv STATE n |                                    |
+                 v                                    |
+     +----------------------+                         |
+     | ack_expected   = yes |                         | rcv
+     | state_expected = no  |                         | STATE
+     +----------------------+           +--+          | n
+                 |                      |  |          |
+             rcv |         send STATE n |  |          |
+             ACK |                      |  |          |
+               n |                      ^  |          |
+                 v          rcv STATE n |  |          |
+            send |                      |  v          |
+           STATE |       +---------------------+      |
+               n |       | ack_expected = no   |      |
+		 +------>| state_expected = no |<-----+
+                         +---------------------+
+                                    |
+                                    | Other peers sync
+                                    |
+== Frame n ends ====================+======================================
+                                    |                  
+                                    v
+                               +--------+              
+	                       | SYNCED |              
+			       +--------+
+
+    "Parallel sync" mode works by using the input state from the frame
+before the current one.  The local input state collected by the MAME
+core is backed up temporarily at the beginning of frame n and
+the previously stored state (from frame n - 1) is retrieved and mixed
+with the peers' input states for frame n - 1.  That's where the slight
+loss of responsiveness comes from.  The advantage of this is that
+because the remote input states used for a given frame were send out
+on the network during *previous* frame, they have had a full frame
+(16 ms for most games) to cross the network.  In non-parallel sync
+mode, the time available for network latency is 16 ms minus however
+much time it takes to emulate the game for that frame, which on slower
+machines could leave almost nothing.  The tradeoff should be
+advantageous on all but very fast machines (relative to the game
+being emulated) on very fast networks.
+
+TODO
+----
+. Adjust for high latency -- coarser sync frequency?	
+. Handle factors which may cause a variance in the initial state in the
+  different emulated machines -- NVRAM and high scores.  Anything else?
+. Sync analog controls
+. Handle UI-originated events, eg pause, reset
+. More flexible network port config?
+. Talk to the core team about integrating the protocol-level stuff
+  into the platform-independant network.c
+
+This version of netmame is based on Eric Totel's old version (also
+specific to xmame), which is no longer maintained, and most especially
+on a lot of network code from the core which also seems to have been
+abandoned, and for which I can't seem to find the appropriate
+attribution.
+
diff --git a/src/unix/doc/xmame-doc-1.html b/src/unix/doc/xmame-doc-1.html
new file mode 100644
index 0000000..dbe8bb2
--- /dev/null
+++ b/src/unix/doc/xmame-doc-1.html
@@ -0,0 +1,97 @@
+<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
+<HTML>
+<HEAD>
+ <META NAME="GENERATOR" CONTENT="LinuxDoc-Tools 0.9.11">
+ <TITLE>XMAME/XMESS DOCUMENTATION: Introduction</TITLE>
+ <LINK HREF="xmame-doc-2.html" REL=next>
+
+ <LINK HREF="xmame-doc.html#toc1" REL=contents>
+<link rel="stylesheet" href="xmame.css" type="text/css" >
+</HEAD>
+<BODY BACKGROUND="img/xmame.jpg" BGPROPERTIES="fixed" >
+<A HREF="xmame-doc-2.html">Next</A>
+Previous
+<A HREF="xmame-doc.html#toc1">Contents</A>
+<HR>
+<H2><A NAME="Introduction"></A> <A NAME="s1">1.</A> <A HREF="xmame-doc.html#toc1">Introduction</A></H2>
+
+<H2><A NAME="ss1.1">1.1</A> <A HREF="xmame-doc.html#toc1.1">Welcome to XMAME</A>
+</H2>
+
+<P>This the the *nix port of the almost legendary mame. Mame is
+an arcade machine emulator, started in 1997 by Nicola Salmoria. It
+started out as a series of emulators for  individual games. This
+series of emulators was combined into a  simgle multi-game emulator.
+This is the current form of mame; no longer a one-man show, there
+are over 100 contributors to the project.</P>
+
+<H2><A NAME="ss1.2">1.2</A> <A HREF="xmame-doc.html#toc1.2">Keep everything up-to-date!</A>
+</H2>
+
+<P>The most recent copy of this guide, the xmame-sources and many
+more can be found on the xmame project homepage at 
+<A HREF="http://x.mame.net/">http://x.mame.net/</A></P>
+
+<H2><A NAME="ss1.3">1.3</A> <A HREF="xmame-doc.html#toc1.3">Pending Jobs - or TODO</A>
+</H2>
+
+<P>If you think you can help with the todo list or you can make
+a  contribution that you feel is interesting, please send mail to
+the xmame/xmess coordinator. See 
+<A HREF="xmame-doc-5.html#Mail">Mail</A> for contact information.</P>
+
+<P>
+<UL>
+<LI>Optimise mouse warping.</LI>
+<LI>Remove osd_input_init_post, add display ready flag.</LI>
+<LI>Updating of fps is off (dirty marking problem) with vector games.</LI>
+<LI>Update porting.txt.</LI>
+<LI>Convert all remaining sound drivers to plugins.</LI>
+<LI>Rewrite display/input code to be more modular, oo-ish, and usable
+as a separate library.</LI>
+<LI>Split <CODE>-[no]scanline</CODE> option into emulated and real scanline
+options.</LI>
+<LI>Add an option to specify which resolution to use, add clipping
+and panning if it doesn't fit and use it anyway.</LI>
+<LI>Use Pentium TSC for uclock where available.</LI>
+<LI>Network:
+<UL>
+<LI>Fix since the dos team broke it, find out if the dosnet team
+is still alive.</LI>
+<LI>Add mouse/joystick support to network play</LI>
+<LI>Try converting network support to tcp, currently we have no error
+correction.</LI>
+<LI>Make network code more robust, version check, input settings
+check, etc.
+</LI>
+</UL>
+</LI>
+<LI>Check x11-joystick. Rumor has it it's broken, but then again
+there's only one bug-report, so it seems no one is using it.</LI>
+<LI>fm soundhack for linux-i386.</LI>
+<LI>Make which messages are emitted and when configurable (log-type's
+and log-level), make fileio emit messages about which files it tries
+to open, to help debug rom-loading problems, and walk through all
+messages xmame emits giving them all a standard format like:
+<PRE>
+OSD:        Info:    bla
+X11-window: Warning: bla
+Svgalib:    Error:   bla
+
+ 
+</PRE>
+</LI>
+<LI>Add scancode 128-255 for non-PC keys like F13 -- F24, more keypad
+keys, etc., update all display targets to use this.</LI>
+<LI>Also see the text todo file, kept around to quickly enter stuff
+while hacking: 
+<A HREF="todo">todo</A>.
+</LI>
+</UL>
+</P>
+<HR>
+<A HREF="xmame-doc-2.html">Next</A>
+Previous
+<A HREF="xmame-doc.html#toc1">Contents</A>
+</BODY>
+</HTML>
diff --git a/src/unix/doc/xmame-doc-2.html b/src/unix/doc/xmame-doc-2.html
new file mode 100644
index 0000000..8f67be7
--- /dev/null
+++ b/src/unix/doc/xmame-doc-2.html
@@ -0,0 +1,456 @@
+<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
+<HTML>
+<HEAD>
+ <META NAME="GENERATOR" CONTENT="LinuxDoc-Tools 0.9.11">
+ <TITLE>XMAME/XMESS DOCUMENTATION: Compiling, Setting Up and Starting Xmame/Xmess</TITLE>
+ <LINK HREF="xmame-doc-3.html" REL=next>
+ <LINK HREF="xmame-doc-1.html" REL=previous>
+ <LINK HREF="xmame-doc.html#toc2" REL=contents>
+<link rel="stylesheet" href="xmame.css" type="text/css" >
+</HEAD>
+<BODY BACKGROUND="img/xmame.jpg" BGPROPERTIES="fixed" >
+<A HREF="xmame-doc-3.html">Next</A>
+<A HREF="xmame-doc-1.html">Previous</A>
+<A HREF="xmame-doc.html#toc2">Contents</A>
+<HR>
+<H2><A NAME="s2">2.</A> <A HREF="xmame-doc.html#toc2">Compiling, Setting Up and Starting Xmame/Xmess</A></H2>
+
+<P>Note: This section is not a Unix tutorial. You need to know some
+basic  Unix commands to compile and install xmame/xmess.</P>
+
+<H2><A NAME="ss2.1">2.1</A> <A HREF="xmame-doc.html#toc2.1">Requirements </A>
+</H2>
+
+<P>
+<UL>
+<LI>GNU make is MANDATORY in ALL Systems, even if you use a different
+compiler. </LI>
+<LI>On all platforms zlib is now needed since the core uses it. If
+you don't have zlib, a stripped version is included with xmame. See:
+<A HREF="xmame-doc-3.html#FAQ: Why do I get gz_open symbol not found while compiling?">FAQ: Why do I get gz_open symbol not while compiling?</A> and 
+<A HREF="xmame-doc-3.html#FAQ: Why do I get zlib.h not found?">FAQ: Why do I get zlib.h not found?</A></LI>
+<LI>You are encouraged to use a GNU development environment: gcc,
+gmake, gnu- ar. Lots of problems are found due to the very permissive
+syntax in gcc, so if you use a strictly ANSI C compiler, you'll get
+lots of warnings, and if the version of xmame/xmess is not fully
+debugged, compilation errors.</LI>
+<LI>Xmame compilation breaks when using egcs-1.1.x or gcc-2.95, use
+<CODE>-fno-strict-aliasing</CODE> to fix it. gcc-2.95.1 does work with <CODE>-fstrict-aliasing</CODE>,
+and gives a nice speed increase.</LI>
+<LI>Xmame compilation also breaks when using Red Hat 7's latest (as
+of 16 January 2001) update for gcc. If you experience problems, please
+either downgrade your compiler to the one included on the Red Hat
+7 CD-ROM, or try replacing "gcc" in the Makefile with "kgcc", which will
+invoke egcs-1.1.2. (But please see above about the <CODE>-fstrict-aliasing</CODE>flag.)
+</LI>
+</UL>
+</P>
+<H2><A NAME="ss2.2">2.2</A> <A HREF="xmame-doc.html#toc2.2">Follow these steps to compile xmame/xmess</A>
+</H2>
+
+<P>
+<OL>
+<LI>See 
+<A HREF="#Compile Notes for Specific Operating Systems">Compile Notes for Specific Operating Systems</A> for platform specific compiling information.</LI>
+<LI>See 
+<A HREF="xmame-doc-4.html#Display subsystem specific comments and notes">Display subsystem specific comments and notes</A> for special display methods information.</LI>
+<LI>Download the xmame/xmess source files archive.</LI>
+<LI>Move the xmame/xmess source files archive to a suitable work
+directory. When you extract the archive, sub directories will be
+created under the  work directory.</LI>
+<LI>Rename the source files archive so its extension is .gz, so that
+gzip doesn't complain. For example, change <CODE>xmame-0.34b1.1.tgz</CODE> to
+<CODE>xmame-0.34b1.1.tar.gz</CODE></LI>
+<LI>Use gzip -d to uncompress the archive. For example, type:
+<PRE>
+gzip -d xmame-0.34b1.1.tar.gz
+
+ 
+</PRE>
+</LI>
+<LI>Extract the files with tar. For example, type:
+<PRE>
+tar xvf xmame-0.34b1.1.tar
+
+ 
+</PRE>
+</LI>
+<LI>After extracting the archive, change to the subdirectory created
+by  the extraction process. For example, after extracting the xmame-0.34b1.1.tar
+archive, a directory named <CODE>xmame-0.34b1.1</CODE> is created. Change to it.
+This directory is the top of the source tree.</LI>
+<LI>Copy makefile.unix to Makefile, the distributed Makefile is used
+for development and is not a good starting point!</LI>
+<LI>Edit the <CODE>Makefile</CODE> and change the settings according to your system.
+The default <CODE>makefile.unix</CODE> is preconfigured to run under X11/Linux.
+Be careful editing this file.
+<UL>
+<LI>If you intend to compile in X11 joystick support, type the following
+to see the available Xdevice list:
+<PRE>
+make xlistdev; ./xlistdev
+
+  
+</PRE>
+</LI>
+<LI>Choose the desired device and re-edit Makefile, setting the option
+X11_JOYNAME to the correct device.
+</LI>
+</UL>
+</LI>
+<LI>Compile xmame/xmess by typing:
+<PRE>
+make
+
+ 
+</PRE>
+</LI>
+<LI>If the compile fails, report the problem to the author.</LI>
+<LI><B>*** YOU MAY NEED TO BE root TO PERFORM THIS STEP ***</B> To install
+xmame/xmess, type:
+<PRE>
+make install
+
+ 
+</PRE>
+</LI>
+<LI>If you want you can now build xmame/xmess for another target/display
+method, otherwise skip to the next step.
+<OL>
+<LI>If you want to also build for another target repeat repeat the
+<CODE>"make"</CODE> and <CODE>"make install"</CODE> steps adding <CODE>"TARGET=&lt;target&gt;"</CODE> to the make
+command for example:
+<PRE>
+make TARGET=mess
+make install
+
+  
+</PRE>
+</LI>
+<LI>If you want to also build for another display method repeat the
+<CODE>"make"</CODE> and <CODE>"make install"</CODE> steps adding <CODE>"DISPLAY_METHOD=&lt;method&gt;"</CODE>
+to the make command for example:
+<PRE>
+make DISPLAY_METHOD=svgalib
+make install
+
+  
+</PRE>
+</LI>
+<LI>You can also combine the 2 above for example:
+<PRE>
+make TARGET=mess DISPLAY_METHOD=svgalib
+make install
+
+  
+</PRE>
+
+</LI>
+</OL>
+</LI>
+<LI>In your home directory, create a subdirectory called .xmame.</LI>
+<LI>From the top of the source tree, copy the file doc/xmamerc.dist
+to the ${HOME}/.xmame/ directory. (For xmess do
+this for xmessrc)</LI>
+<LI>If desired, copy xmamerc.dist to the global xmamerc location
+as &quot;xmamerc&quot; (for xmess, copy xmamerc.dist to xmessrc).
+The global xmamerc location is defined in the Makefile.</LI>
+<LI>Edit ${HOME}/.xmame/xmamerc to match your preferences.
+(For xmess, edit ${HOME}/.xmess/xmessrc)</LI>
+<LI>Be sure that the DISPLAY and PATH environment variables are 
+set correctly.</LI>
+<LI>Make sure your ROM images are installed.</LI>
+<LI>Start the X-Window System. (Unless you compiled for a different
+display method in which case you skip this step.)</LI>
+<LI>Start xmame/xmess. For example:
+<PRE>
+/usr/games/xmame.x11 dkong
+
+ 
+</PRE>
+
+</LI>
+</OL>
+</P>
+<H2><A NAME="ss2.3">2.3</A> <A HREF="xmame-doc.html#toc2.3">If you have problems compiling, installing and starting xmame/xmess...</A>
+</H2>
+
+<P>
+<UL>
+<LI>Read  
+<A HREF="xmame-doc-3.html#Xmame frequently asked questions">Xmame frequently asked questions</A></LI>
+<LI>Read (the recent parts of) 
+<A HREF="xmame-doc-8.html#ChangeLogs">Changelogs</A>. They might contain some hints about
+recent changes which aren't fully documented yet.</LI>
+<LI>Check 
+<A HREF="#Compile Notes for Specific Operating Systems">Compile Notes for Specific Operating Systems</A> for operating system-specific notes. You may need to do
+something special for your operating system.</LI>
+<LI>Check 
+<A HREF="xmame-doc-4.html#Display subsystem specific comments and notes">Display subsystem specific comments and notes</A> for display subsystem-specific notes. You may need to
+do something special for your display system.</LI>
+<LI>If you get an error about gz_open and a bunch of other functions
+not found during linking, read: 
+<A HREF="xmame-doc-3.html#FAQ: Why do I get gz_open symbol not found while compiling?">FAQ: Why do I get gz_open symbol not while compiling?</A> and 
+<A HREF="xmame-doc-3.html#FAQ: Why do I get zlib.h not found?">FAQ: Why do I get zlib.h not found?</A>.</LI>
+<LI>Be sure that the rompath in your xmamerc/xmessrc is correct;
+see 
+<A HREF="xmame-doc-3.html#FAQ: Where do roms, images, samples, highscores, configfiles, etc go?">FAQ: Where do roms.images.etc go?</A>.</LI>
+<LI>Check xmamerc/xmessrc: Is it configured correctly?</LI>
+<LI>Are you getting messages that you are missing files? Maybe you
+are missing PROMs; see 
+<A HREF="xmame-doc-3.html#FAQ: Why doesn't a game work?">FAQ: Why doesn't a game work?</A> and 
+<A HREF="xmame-doc-3.html#FAQ: What are PROMs?">FAQ: What are PROMs?</A></LI>
+<LI>Is the program in your PATH?</LI>
+<LI>The svgalib/xf86_dga build of xmame/xmess requires setuid root.
+Are your permissions correct?</LI>
+<LI>Try asking the friendly folks at the newsgroup alt.game.mame
+to see if anyone else has experienced the same problem as you.</LI>
+<LI>Try mailing to the xmame mailinglist, see 
+<A HREF="xmame-doc-5.html#Mail">Mail</A> for more information.
+</LI>
+</UL>
+</P>
+<P>If all else fails, send email to the current maintainer of the
+xmame/xmess project. See 
+<A HREF="xmame-doc-5.html#Mail">Mail</A> for contact information.</P>
+
+<H2><A NAME="Compile Notes for Specific Operating Systems"></A> <A NAME="ss2.4">2.4</A> <A HREF="xmame-doc.html#toc2.4">Compile Notes for Specific Operating Systems </A>
+</H2>
+
+<H3>Linux i386</H3>
+
+<P>Linux i386 is the platform I (Hans) use, so xmame should compile
+without any hassles on Linux i386. (Note: The same is true for Lawrence
+Gold.)</P>
+
+<P>Some bugs have been found and worked around when using gcc27x,
+please use egcs if available. If more gcc bugs popup, egcs will be
+made mandatory, but I hope that won't be necessary.</P>
+
+<P>It has been reported that some SoundBlaster AWE32 and VIA-82cxxx
+(onboard) cards do not  correctly manage get_freespace(). If so,
+you'll get some audio_ioctl() calls failed messages in console, and
+if everything goes right a message that xmame/xmess is falling back
+to timer based audio. If  this doesn't happen and sound isn't right,
+try forcing timer-based  audio by starting xmame/xmess with <CODE>-timer</CODE>.</P>
+
+<P>SB64/128PCI cards (Ensoniq 137x-based cards) also do not correctly
+manage get_freespace(). Unfortunately, this doesn't result in failed
+ioctl's; instead, they just ignore the calls. Xmame tries to autodetect
+this and to fall back to timer-based audio. If this doesn't happen
+and sound isn't right, try forcing timer based audio by starting
+xmame/xmess with <CODE>-timer</CODE>.</P>
+
+<P>Some have reported success using ALSA with OSS emulation (see
+<A HREF="http://www.alsa-project.org/">http://www.alsa-project.org/</A>). If you experience the above problems, this would certainly be
+worth a try.</P>
+
+<P>Also, I've tested sound using the PC-Speaker driver module. It
+works!! But it needs <CODE>-timer.</CODE> Again, it should do this  automagically,
+but you know what to do if it doesn't.</P>
+
+<P>Distribution-Specific Comments:</P>
+
+<P>
+<UL>
+<LI>S.u.S.E. Linux: Besides the gcc compiler and libc libraries,
+which are both from the &quot;d&quot; series, other packages  need
+to be installed or the build will fail. If compiling for svgalib,
+the svgalib package from series &quot;d&quot; installed. If compiling
+for the X-Window System, you must have xdevel package from series
+&quot;x&quot; installed. These packages can be installed using the
+&quot;yast&quot; utility included in the S.u.S.E. distribution.</LI>
+<LI>Red Hat Linux is the operating system used by the author. xmame/xmess
+should build correctly under Red Hat Linux. :-)
+</LI>
+</UL>
+</P>
+<H3>Linux PowerPC</H3>
+
+<P>Linux PowerPC should work from now on. Here's an email from Andreas
+Varga <CODE>
+<A HREF="mailto:sid@skater.htu.tuwien.ac.at">sid@skater.htu.tuwien.ac.at</A></CODE>, the Linux/PowerPC maintainer, describing the necessary steps:</P>
+
+<P>Required changes to compile xmame 0.34b3.1 on Linux/PowerPC with
+SVGALIB</P>
+
+<P>Makefile:</P>
+
+<P>
+<UL>
+<LI>enable CFLAGS for linux/ppc </LI>
+<LI>enable DISPLAY_METHOD = svgalib </LI>
+<LI>enable ARCH = linux </LI>
+<LI>remove -lvgagl from LIBS.svgalib in src/unix/unix.mak (only -lvga
+is required)
+</LI>
+</UL>
+</P>
+<P>Required changes to compile xmame 0.34b3.1 on Linux/PowerPC with
+X11 </P>
+
+<P>Makefile: </P>
+
+<P>
+<UL>
+<LI>enable CFLAGS for linux/ppc </LI>
+<LI>enable DISPLAY_METHOD = x11 </LI>
+<LI>enable ARCH = linux 
+</LI>
+</UL>
+</P>
+<P>Another thing... sound is not working, because sound drivers
+support is currently under development in Linux/PPC kernels...there
+is an old driver that is a hacked Soundblaster driver, and newer
+2.1.1xx kernels have a sound drivers based on Amiga DMA sound drivers...
+Once this issues are settled there should be a full OSS-compatible
+driver... sound should work then...</P>
+
+<P>I can't speak about Joystick support...</P>
+
+<P>The original Linux/PPC target changes in the Makefile were done
+by me, but there are some other changes required to get it to compile...
+Starting from October I will have some more time to work on this,
+and I'll keep you updated...</P>
+
+<P>Cheers, Andreas</P>
+
+<H3>IRIX</H3>
+
+<P>Use the generic unix arch for those machines that have no  sound
+support installed (xmame/xmess uses the dmedia package or the newer
+AL package on IRIX systems).</P>
+
+<P>Silicon Graphics provides several native compilers. xmame/xmess
+has  been compiled and tested with the normal cc. There were some
+problems with this when using -n32 for new style 32bit code. It does
+work when using -o32 for oldstyle 32 bit code. It should now also
+work with -n32 which is much faster.</P>
+
+<P>The use of DCC is not recommended (anymore) since it's a C++
+compiler and thus won't even compile xmame/xmess out of the box
+due to uncasted mallocs. Changing all these mallocs would be crazy,
+esp. since they are not only in the osd part, but also in the core
+which is not under our control. Besides that, mame is normal C, so
+please compile it with a normal C compiler.</P>
+
+<P>Some problems have been reported using the GNU linker. It's recommended
+that you use the native one.</P>
+
+<H3>HPUX</H3>
+
+<P>Use the generic unix arch. In HP-UX, gcc and gnu-make are MANDATORY.</P>
+
+<H3>ULTRIX </H3>
+
+<P>Use the generic unix arch.</P>
+
+<P>Notes received from Danny <CODE>
+<A HREF="mailto:dboxhoor@iso.vilspa.esa.es">dboxhoor@iso.vilspa.esa.es</A></CODE></P>
+
+<P><B>VERY IMPORTANT!!!</B></P>
+
+<P>The xmame/xmess CPU emulators access memory through pointers
+which are sometimes cast to illegal addresses - as far as the MIPS
+CPU is concerned. The Ultrix operating system is aware of that and
+fixes this &quot;unaligned data access&quot;.</P>
+
+<P>Depending on your system setup, lots of warnings are generated
+for certain games. Fortunately these messages can be disabled by
+executing the command &quot;uac p 0&quot; in the same shell where
+xmame/xmess  will be running.</P>
+
+<P>UPDATE: The new <CODE>-DALIGN_INTS</CODE> switch in the makefile fixes these
+unaligned accesses in the source which is probably a lot faster than
+hot fixing them in the kernel segfault handler.</P>
+
+<P>Use gnu make.</P>
+
+<P>Compile with the `c89' compiler. Though `gcc' has no problems
+with compiling and optimizing xmame/xmess, the resulting `c89' 
+executable is faster on an empty machine (read: xmame can use all
+cpu &amp; memory without competing with other high priority  processes),
+so you can set `frameskip' to 1.</P>
+
+<P>When compiling with `c89 -O2' don't forget to also use `-Olimit
+1000'. If 1000 is not enough, the compiler will tell you to  increase
+it.</P>
+
+<H3>SunOS &amp; Solaris</H3>
+
+<P>There are 2 relevant architecture options available in the makefile:</P>
+
+
+<P>
+<PRE>
+    ARCH = generic : use this for old SunOs running on Sparcs,
+                     but a Sparc running Solaris will usually
+                     handle this option too.
+    ARCH = solaris : this is the one you should use for Sparcs
+                     running Solaris.        
+</PRE>
+</P>
+<P>Currently sound is not supported under sunos. The solaris arch
+does support audio.</P>
+
+<P>If you are using Sun's OpenWindows implementation of X11, then
+make sure that the X11INC and X11LIB variables in the X11 Options
+section of the makefile are set properly. (There are already entries
+for the standard OpenWin directory there that you can uncomment.)</P>
+
+<P>Of course, if you are compiling for X11 then you need to set
+these variables properly, no matter what implementation of X11 you
+are using!  :)</P>
+
+<P>If you are using Sun's SunPro cc compiler, then the following
+optimisation flags have been reported to be good:</P>
+
+<P>
+<PRE>
+    OPTFLAGS    = -fast -xO4 -native
+</PRE>
+</P>
+<P>Finally, there has been a case of the xmame compilation processes
+breaking over the &quot;ar&quot; program. Most Solaris installations
+will include a set of utilities that conform to the XPG4 standard,
+usually in the &quot;/usr/xpg4/bin&quot; directory. The XPG4 version
+of &quot;ar&quot; should be avoided like the plague. Ensure that
+the &quot;/usr/ccs/bin&quot; appears in your path before the &quot;/usr/xpg4/bin&quot;
+directory and everything should go smoothly.</P>
+
+<P>PLEASE NOTE : There is currently not much support for SunOS/Solaris.
+If you have any trouble, try to fix it yourself. If you succeed,
+send a message to the mailing list detailing what you did. If you
+don't succeed, send a message anyway and someone _may_ be able to
+help you. Either way, this is the only way that problems with xmame
+on SunOS/Solaris will get fixed.</P>
+
+<H3>Openstep</H3>
+
+<P>You must use the OpenStep gnumake, not make. You must also use
+the NeXT/Apple cc rather than gcc. Also use only the optimisation
+options as recommended for OpenStep in the makefile, others will
+cause the resulting executable to crash. The OpenStep assembler on
+i386 architectures is incompatible with the mame assembler CPU cores
+and thus you must use the C versions (Use i386-noasm instead of i386
+when compiling for i386).</P>
+
+<P>The supplied complier is based on gcc 2.7.2.1 which will not
+compile src/profiler.c without crashing. To get around this you must
+turn off + optimisation when this crash occurs, re-make to compile
+this file only, then stop the make, re-enable optimisation, and continue.</P>
+
+<P>On an OpenStep keyboard the functions keys do not all operate
+as expected. Using the command key in conjuction with a number key
+generates the equivalent function key within xmame, with 0, - and
+= + representing F10, F11 and F12 resepectively. Also note that the
+ALT + keys cannot be mapped. As most games tend to use this as the
+default fire button it is exteremly useful to remap this globally
+the first time you run xmame.</P>
+
+<HR>
+<A HREF="xmame-doc-3.html">Next</A>
+<A HREF="xmame-doc-1.html">Previous</A>
+<A HREF="xmame-doc.html#toc2">Contents</A>
+</BODY>
+</HTML>
diff --git a/src/unix/doc/xmame-doc-3.html b/src/unix/doc/xmame-doc-3.html
new file mode 100644
index 0000000..c5af25f
--- /dev/null
+++ b/src/unix/doc/xmame-doc-3.html
@@ -0,0 +1,1220 @@
+<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
+<HTML>
+<HEAD>
+ <META NAME="GENERATOR" CONTENT="LinuxDoc-Tools 0.9.11">
+ <TITLE>XMAME/XMESS DOCUMENTATION: Xmame Frequently Asked Questions</TITLE>
+ <LINK HREF="xmame-doc-4.html" REL=next>
+ <LINK HREF="xmame-doc-2.html" REL=previous>
+ <LINK HREF="xmame-doc.html#toc3" REL=contents>
+<link rel="stylesheet" href="xmame.css" type="text/css" >
+</HEAD>
+<BODY BACKGROUND="img/xmame.jpg" BGPROPERTIES="fixed" >
+<A HREF="xmame-doc-4.html">Next</A>
+<A HREF="xmame-doc-2.html">Previous</A>
+<A HREF="xmame-doc.html#toc3">Contents</A>
+<HR>
+<H2><A NAME="Xmame frequently asked questions"></A> <A NAME="s3">3.</A> <A HREF="xmame-doc.html#toc3">Xmame Frequently Asked Questions</A></H2>
+
+<H2><A NAME="ss3.1">3.1</A> <A HREF="xmame-doc.html#toc3.1">What is mame?</A>
+</H2>
+
+<P>Mame is an arcade machine emulator. Started in 1997 by Nicola
+Salmoria, mame started out as a series of emulators for  individual
+games. This series of emulators was combined into a  simgle multi-game
+emulator. This is the current form of mame; no longer a one-man show,
+there are over 100 contributors to the project.</P>
+
+<P>Mame was created by Nicola Salmoria.</P>
+
+<P>Also see 
+<A HREF="readme.mame">the official mame readme file (readme.mame)</A></P>
+
+<H2><A NAME="ss3.2">3.2</A> <A HREF="xmame-doc.html#toc3.2">What is mess?</A>
+</H2>
+
+<P>Mess is just like mame---a virtual machine emulator, only it
+doesn't emulate arcade machines but rather computers and consoles.</P>
+
+<P>Also see 
+<A HREF="readme.mess">the official mess readme file (readme.mess)</A></P>
+
+<H2><A NAME="ss3.3">3.3</A> <A HREF="xmame-doc.html#toc3.3">What is xmame/xmess?</A>
+</H2>
+
+<P>Xmame/xmess are the Unix/X11 ports of the mame and mess projects.
+It makes mame/mess available on *ix machines using the X11R6 X-Window
+System (and SVGAlib/ggi/XF86-DGA/OpenGL/SDL too).</P>
+
+<P>Mame was orginally ported by Allard Van Der Bas, Dick the Ridder,
+Juan Antonio Martinez, and Hans de Goede.</P>
+
+<P>Xmame/xmess is currently maintained by Lawrence Gold.</P>
+
+<H2><A NAME="ss3.4">3.4</A> <A HREF="xmame-doc.html#toc3.4">What are the differences between mame/mess and xmame/xmess?</A>
+</H2>
+
+<P>None significant.</P>
+
+<P>Xmame/xmess is based on the mame/mess source code. Due to technical
+reasons beyond the scope of this document, the mame/mess source may
+not compile under Unix. That's why the xmame/xmess project exists.
+Each time mame/mess is updated, the code is tested  (and patched
+if needed) under Unix. This way xmame/xmess releases are always the
+same as their mame counterparts.</P>
+
+<P>There are no plans for the independent development of xmame/xmess.</P>
+
+<H2><A NAME="ss3.5">3.5</A> <A HREF="xmame-doc.html#toc3.5">What hardware and operating systems are supported? </A>
+</H2>
+
+<P>Xmame runs on both little-endian and big-endian CPUs, using aligned
+integer access if needed and is compatible with 64 bit CPUs. The
+current list of supported CPUs in the makefile is:</P>
+
+<P>
+<UL>
+<LI>i386 + gnu-asm</LI>
+<LI>i386 no asm</LI>
+<LI>alpha</LI>
+<LI>ia64 (merced)</LI>
+<LI>m68k</LI>
+<LI>generic risc (PowerPC, Sparc, HPPA, IBM)</LI>
+<LI>generic risc, lsb-first (RISC (Ultrix machines))</LI>
+<LI>mips (generic risc + SGI compiler bug workarounds)
+</LI>
+</UL>
+</P>
+<P>Adding support for another cpu (if necessary) should be trivial.</P>
+
+<P>The following Unix platforms are specifically supported:</P>
+
+<P>
+<UL>
+<LI>Linux</LI>
+<LI>FreeBSD</LI>
+<LI>NetBSD</LI>
+<LI>Solaris (SunOS)</LI>
+<LI>OpenStep (noasm only on i386)</LI>
+<LI>IRIX with sound using the dmedia package or the new al package
+(sound currently broken)</LI>
+<LI>AIX (sound currently broken)</LI>
+<LI>generic unix, no sound
+</LI>
+</UL>
+</P>
+<P>The generic unix entry should work for any reasonable standard
+Unix variant, but lacks sound since there is no single Unix sound
+standard.</P>
+
+<P>On all platforms, zlib is now needed since the core uses it.
+Ff you don't have zlib, use the included one by uncommenting the
+appropriate line in Makefile.</P>
+
+<P>The following display methods are supported. X11 is the only
+one which works on all platforms, except for OpenStep which only
+works with Openstep bitmaps:</P>
+
+<P>
+<UL>
+<LI>X11 (X-Window System)</LI>
+<LI>svgalib</LI>
+<LI>GGI (Generic Graphics Interface)</LI>
+<LI>OpenGL using X11 for input</LI>
+<LI>glide using X11 for input (3DFX)</LI>
+<LI>glide using svgalib for input (3DFX)</LI>
+<LI>OpenStep bitmaps</LI>
+<LI>SDL (Simple Direct Medialayer)
+</LI>
+</UL>
+</P>
+<P>The following is a list of arch/os/display combinations, with
+maintainers, for arch/os/display combinations which are actively
+supported. Please mail the maintainer of the arch/os/display combination
+for compilation and other arch/os/display specific problems. Mail
+Lawrence <CODE>
+<A HREF="mailto:gold@aros.net">gold@aros.net</A></CODE> for generic (e.g., X11) problems.</P>
+
+<P>
+<UL>
+<LI>i386/linux/x11 (+DGA) -&gt; Lawrence <CODE>
+<A HREF="mailto:gold@aros.net">&lt;gold@aros.net></A></CODE></LI>
+<LI>i386/linux/svgalib -&gt; Lawrence <CODE>
+<A HREF="mailto:gold@aros.net">&lt;gold@aros.net></A></CODE></LI>
+<LI>i386/linux/xgl -&gt; Sven Goethel <CODE>
+<A HREF="mailto:sgoethel@jausoft.com">&lt;sgoethel@jausoft.com></A></CODE></LI>
+<LI>i386/linux/xfx -&gt; Lawrence <CODE>
+<A HREF="mailto:gold@aros.net">&lt;gold@aros.net></A></CODE></LI>
+<LI>i386/linux/svgafx -&gt; Lawrence <CODE>
+<A HREF="mailto:gold@aros.net">&lt;gold@aros.net></A></CODE></LI>
+<LI>i386/linux/ggi -&gt; Christian <CODE>
+<A HREF="mailto:cpg@aladdin.de">&lt;cpg@aladdin.de></A></CODE></LI>
+<LI>alpha/linux/x11 -&gt; Christian <CODE>
+<A HREF="mailto:cpg@aladdin.de">&lt;cpg@aladdin.de></A></CODE></LI>
+<LI>alpha/digital unix/x11 * -&gt; Leandro <CODE>
+<A HREF="mailto:gold@aros.net">&lt;gold@aros.net></A></CODE></LI>
+<LI>powerpc/linux/x11 -&gt; Andreas <CODE>
+<A HREF="mailto:sid@skater.htu.tuwien.ac.at">&lt;sid@skater.htu.tuwien.ac.at></A></CODE></LI>
+<LI>powerpc/linux/svgalib -&gt; Andreas <CODE>
+<A HREF="mailto:sid@skater.htu.tuwien.ac.at">&lt;sid@skater.htu.tuwien.ac.at></A></CODE></LI>
+<LI>i386/freebsd/x11 -&gt; Jacob A. Hart <CODE>
+<A HREF="mailto:c9710216@studentmail.newcastle.edu.au">&lt;c9710216@studentmail.newcastle.edu.au></A></CODE></LI>
+<LI>i386/netbsd/x11 -&gt; Dave <CODE>
+<A HREF="mailto:dave@dtsp.co.nz">&lt;dave@dtsp.co.nz></A></CODE></LI>
+<LI>alpha/netbsd/x11 -&gt; Christian <CODE>
+<A HREF="mailto:cpg@aladdin.de">&lt;cpg@aladdin.de></A></CODE></LI>
+<LI>Sparc/Solaris/x11 -&gt; Lawrence <CODE>
+<A HREF="mailto:gold@aros.net">&lt;gold@aros.net></A></CODE></LI>
+<LI>i386/Unixware7/x11 * -&gt; Richard <CODE>
+<A HREF="mailto:xmame@frogface.ddns.org">&lt;xmame@frogface.ddns.org></A></CODE></LI>
+<LI>i386/openstep -&gt; Pete French <CODE>
+<A HREF="mailto:pete@toybox.twisted.org.uk">&lt;pete@toybox.twisted.org.uk></A></CODE></LI>
+<LI>Sparc/SunOs -&gt; Saga <CODE>
+<A HREF="mailto:jolletx@cybercable.fr">&lt;jolletx@cybercable.fr></A></CODE></LI>
+<LI>mips/irix/x11 -&gt; Dingus Family <CODE>
+<A HREF="mailto:ddingus@uswest.net">&lt;ddingus@uswest.net></A></CODE>
+</LI>
+</UL>
+</P>
+<P>* These are supported using the generic unix entry of the makefile,
+and thus lack sound.</P>
+
+<P>We are always looking for people willing to test and answer questions
+about xmame on a new arch/os/display. This takes very little work
+and could help other people tremendously. If you're interested, mail
+Lawrence <CODE>
+<A HREF="mailto:gold@aros.net">gold@aros.net</A></CODE>.</P>
+
+<H2><A NAME="ss3.6">3.6</A> <A HREF="xmame-doc.html#toc3.6">My system is supported but xmame/xmess gives me errors and fails.</A>
+ Why?</H2>
+
+<P>Xmame/xmess should run on 16, 24 and 32bpp true color displays.
+If your X server does not support any  of these display types, xmame/xmess
+will not run. Support for 8bpp pseudo color displays may return in
+future versions.</P>
+
+<P>You can verify your X server support by starting your X server
+and running the xdpyinfo program. See the xdpyinfo manual page 
+for more information.</P>
+
+<H2><A NAME="ss3.7">3.7</A> <A HREF="xmame-doc.html#toc3.7">What is the role of the xmamerc/xmessrc file?</A>
+</H2>
+
+<P>A normal xmame/xmess invocation looks like:</P>
+
+<P>
+<PRE>
+    xmame pacman -sound -nojoy -frameskip 2 -heightscale 3 \   
+        -widthscale 2
+</PRE>
+</P>
+<P>Most of the time, you will want to use the same configuration
+for  each game. xmame/xmess will read this file for default values
+for the  parameters that you can set. This way the only parameters
+you  need to express on the command line are the ones you want to
+override.</P>
+
+<P>Another reason for xmamerc/xmessrc is keyboard remapping. Some
+Unix  keyboards are very different than their PC counterparts. To
+compensate for the changes, xmame/xmess allows you to remap keys
+that  are not available on Unix keyboards to keys that are available.</P>
+
+<H2><A NAME="ss3.8">3.8</A> <A HREF="xmame-doc.html#toc3.8">What is the syntax of the xmamerc/xmessrc file.</A>
+</H2>
+
+<P>The syntax is quite simple:</P>
+
+<P>
+<PRE>
+   &quot;keyword value&quot;
+</PRE>
+</P>
+<P>See 
+<A HREF="xmamerc.dist">xmamerc.dist</A> for most keywords. Allmost all commandline options can be
+used as keywords (without the -), use value 0 or 1 for commandline
+options which have a negating (-no[option]) counterpart.
+As usual lines begining with &quot;#&quot; are comments.</P>
+
+<P>You can also generate a configfile with all the current settings
+to use as a template by typing:</P>
+
+<P>
+<PRE>
+   xmame -showconfig &gt; ~/.xmame/xmamerc
+</PRE>
+</P>
+<H2><A NAME="FAQ: Where do roms, images, samples, highscores, configfiles, etc go?"></A> <A NAME="ss3.9">3.9</A> <A HREF="xmame-doc.html#toc3.9">Where do roms, images, samples, highscores, configfiles, etc</A>
+ go? </H2>
+
+<H3>Roms/Samples</H3>
+
+<P>Xmame/xmess uses a &quot;:&quot; seperated rompath to find out
+which dirs to search for roms/samples.</P>
+
+<P>The default rompath is XMAMEROOT as defined in Makefile during
+compile.</P>
+
+<P>This is overwritten by any rompath in xmamerc/xmessrc, which
+can be overwritten again with the -rompath commandline option.</P>
+
+<P>Xmame/xmess searches every dir in this path for roms/samples
+in the following way:</P>
+
+<P>
+<PRE>
+    &lt;dir&gt;/gamename.zip             (containing filename.ext)
+    &lt;dir&gt;/gamename/filename.ext
+    &lt;dir&gt;/gamename/filename.ext.gz (containing filename.ext)
+    &lt;dir&gt;/gamename/filename.zip    (containing filename.ext)
+</PRE>
+</P>
+<P>So let's say that we are searching for rom0001.1, which is part
+of pacman. Then xmame/xmess would search every dir in your rompath
+for</P>
+
+<P>
+<PRE>
+    &lt;dir&gt;/pacman.zip               (containing rom0001.1)
+    &lt;dir&gt;/pacman/rom0001.1
+    &lt;dir&gt;/pacman/rom0001.1.gz      (containing rom0001.1)
+    &lt;dir&gt;/pacman/rom0001.zip       (containing rom0001.1)
+</PRE>
+</P>
+<P>Note: If your neogeo games can't find neogeo.rom, put it in a
+dir called neogeo somewhere in your rompath, or put it in neogeo.zip
+somewhere in your rompath.</P>
+
+<H3>Read/write Diskette Images</H3>
+
+<P>This section only applies to xmess emulations which support read/write
+diskette images and thus try to open the image read/write.</P>
+
+<P>Xmess first searches for read/write images with the name specified
+on the commandline:</P>
+
+<P>
+<PRE>
+    &lt;path&gt;/image.ext
+</PRE>
+</P>
+<P>where path is the path specified with the image on the commandline.
+This way, absolute and relative filenames can be used directly on
+the commandline for an image which is not in the rompath.</P>
+
+<P>Then xmess searches every dir in the rompath for roms/samples
+in the following way:</P>
+
+<P>
+<PRE>
+    &lt;dir&gt;/image.ext
+</PRE>
+</P>
+<P>Note that (g)zipped images are not supported for r/w images.</P>
+
+<H3>Rom Cartridges/Read Only Diskette Images</H3>
+
+<P>Xmess begins by searching for cartdriges/disks from the current
+dir in the following way:</P>
+
+<P>
+<PRE>
+    &lt;path&gt;/image.ext
+    &lt;path&gt;/image.ext.gz            (containing image.ext)
+    &lt;path&gt;/image.zip               (containing image.ext)
+</PRE>
+</P>
+<P>where path is the path specified with the image on the commandline.
+This way, absolute and relative filenames can be used directly on
+the commandline for an image which is not in the rompath.</P>
+
+<P>Then xmess searches every dir in the rompath for carts/images
+in the following way:</P>
+
+<P>
+<PRE>
+    &lt;dir&gt;/image.ext
+    &lt;dir&gt;/image.ext.gz             (containing image.ext)
+    &lt;dir&gt;/image.zip                (containing image.ext)
+</PRE>
+</P>
+<P>Finally, xmess searches the rompath as desribed above using the
+systemtype for gamename.</P>
+
+<P>So let's say we want to play mario.nes on the nes emulation of
+xmess. We would then type: &quot;xmess nes mario.nes&quot;. Xmess
+then begins by searching the current dir for</P>
+
+<P>
+<PRE>
+    mario.nes
+    mario.nes.gz                   (containing mario.nes)
+    mario.zip                      (containing mario.nes)
+</PRE>
+</P>
+<P>After that, xmess searches each dir in your rompath for</P>
+
+<P>
+<PRE>
+    &lt;dir&gt;/mario.nes
+    &lt;dir&gt;/mario.nes.gz             (containing mario.nes)
+    &lt;dir&gt;/mario.zip                (containing mario.nes)
+</PRE>
+</P>
+<P>And finally, xmess searches each dir in your rompath for</P>
+
+<P>
+<PRE>
+    &lt;dir&gt;/nes.zip                  (containing mario.nes)
+    &lt;dir&gt;/nes/mario.nes
+    &lt;dir&gt;/nes/mario.nes.gz         (containing mario.nes)
+    &lt;dir&gt;/nes/mario.zip            (containing mario.nes)
+</PRE>
+</P>
+<P>Since xmess first searches for cartridges/disks from the current
+dir you can also specify cartridges/disks not in your rompath. For
+example:</P>
+
+<P>
+<PRE>
+    &quot;xmess nes ../mario.nes&quot;
+</PRE>
+</P>
+<P>Xmess then searches for</P>
+
+<P>
+<PRE>
+    ../mario.nes
+    ../mario.nes.gz                (containing mario.nes)
+    ../mario.zip                   (containing mario.nes)
+</PRE>
+</P>
+<P>and will also search the rompath as described above with ../mario.nes
+as the image name but this is not that useful.</P>
+
+<H3>Artwork</H3>
+
+<P>Xmame/xmess searches every dir in the rompath for artwork in
+the following way:</P>
+
+<P>
+<PRE>
+    &lt;dir&gt;/artwork.png
+    &lt;dir&gt;/artwork.png.gz           (containing artwork.png)
+    &lt;dir&gt;/artwork.zip              (containing artwork.png)
+</PRE>
+</P>
+<P>Then xmame/xmess searches the rompath as in roms/samples.</P>
+
+<P>So let's say we want to play foo which uses bar.png. Xmame/xmess
+then begins searching each dir in your rompath for</P>
+
+<P>
+<PRE>
+    &lt;dir&gt;/bar.png
+    &lt;dir&gt;/bar.png.gz               (containing bar.png)
+    &lt;dir&gt;/bar.zip                  (containing bar.png)
+</PRE>
+</P>
+<P>And then xmame/xmess searches each dir in your rompath for</P>
+
+<P>
+<PRE>
+    &lt;dir&gt;/foo.zip                  (containing bar.png)
+    &lt;dir&gt;/foo/bar.png
+    &lt;dir&gt;/foo/bar.png.gz           (containing bar.png)
+    &lt;dir&gt;/foo/bar.zip              (containing bar.png)
+</PRE>
+</P>
+<H3>Xmame configuration</H3>
+
+<P>Xmame looks for the following configuration files and parses
+each one found. Files parsed later can overwrite options in previously
+parsed files:</P>
+
+<P>
+<PRE>
+    XMAMEROOT/xmamerc
+    XMAMEROOT/xmame-DISPLAY_METHODrc
+    ${HOME}/.xmame/xmamerc
+    ${HOME}/.xmame/xmame-DISPLAY_METHODrc
+    ${HOME}/.xmame/rc/&lt;gamename&gt;rc
+</PRE>
+</P>
+<P><CODE>XMAMEROOT</CODE> is defined during compile time, see Makefile.</P>
+
+<P><CODE>DISPLAY_METHOD</CODE> is the <CODE>DISPLAY_METHOD</CODE> for which xmame was compiled,
+this can be one of: x11, svgalib, ggi, xgl, xfx, svgafx, openstep,
+SDL.</P>
+
+<P>For xmess of course replace xmame by xmess. ;)</P>
+
+<H3>Game configuration</H3>
+
+<P>Game configuration files are kept on a per-user base in:</P>
+
+<P>
+<PRE>
+    ${HOME}/.xmame/cfg/&lt;game&gt;.cfg resp
+    ${HOME}/.xmess/cfg/&lt;game&gt;.cfg
+</PRE>
+</P>
+<H3>Game state</H3>
+
+<P>Game state files are kept on a per-user base in:</P>
+
+<P>
+<PRE>
+    ${HOME}/.xmame/sta/&lt;game&gt;.sta resp
+    ${HOME}/.xmess/sta/&lt;game&gt;.sta
+</PRE>
+</P>
+<H3>NVram</H3>
+
+<P>NVram files are kept on a per-user base in:</P>
+
+<P>
+<PRE>
+    ${HOME}/.xmame/nvram/&lt;game&gt;.nv resp
+    ${HOME}/.xmess/nvram/&lt;game&gt;.nv
+</PRE>
+</P>
+<H3>Mem cards</H3>
+
+<P>Mem cards files are kept on a per-user base in:</P>
+
+<P>
+<PRE>
+    ${HOME}/.xmame/mem/&lt;filename&gt;.mem resp
+    ${HOME}/.xmess/mem/&lt;filename&gt;.mem
+</PRE>
+</P>
+<P>Where &lt;filename&gt; is given by the game-driver. </P>
+
+<H3>Screenshots</H3>
+
+<P>Screenshots, which can be made by pressing F12, are saved as
+png files in the directory from where xmame is started (cwd).</P>
+
+<P>This can be overidden by the screenshotdir entry in xmamerc/xmessrc,
+which can again be overidden by the <CODE>-screenshotdir</CODE> cmdline-option.</P>
+
+<P>They are saved as:</P>
+
+<P>
+<PRE>
+    &lt;screenshotdir&gt;/&lt;game&gt;xxxx.png
+    Where xxxx is a number.
+</PRE>
+</P>
+<H3>Highscores</H3>
+
+<P>Highscores are stored in XMAMEROOT as defined in Makefile when
+building. This can be overidden by the spooldir entry in xmamerc/xmessrc,
+which can again be overidden by the <CODE>-spooldir</CODE> cmdline-option.</P>
+
+<P>So only give a </P>
+
+<P>
+<PRE>
+    drwxrwsr-x root games &lt;spooldir&gt;
+</PRE>
+</P>
+<P>permission and setgid xmame/xmess to &quot;games&quot; to get
+it to work. Note this doesn't work with suid root versions (svgalib
+&amp; XF86-DGA), suggestions welcome.</P>
+
+<P>For now use <CODE>${HOME}/.xmame</CODE> or <CODE>$ {HOME}/.xmess</CODE>
+as the spooldir in xmamerc/xmessrc for  suid root versions.</P>
+
+<P>Note: For highscores to work, xmame must also be able to find
+hiscore.dat.</P>
+
+<H3>hiscore.dat</H3>
+
+<P>If you want to use highscores mame needs to load hiscore.dat
+to get highscore info.</P>
+
+<P>The default is <CODE>XMAMEROOT</CODE>/hiscore.dat . XMAMEROOT is set during
+compile-time; see the Makefile. This can be overridden by the hiscorefile
+entry in xmamerc if present, which can again be overridden by the
+cmdline-option <CODE>-hiscorefile</CODE>.</P>
+
+<P><CODE>hiscore.dat</CODE> is available from the mame homepage: 
+<A HREF="http://www.mame.net">http://www.mame.net</A></P>
+
+<H3>cheat.dat</H3>
+
+<P>If you want to use cheats mame needs to load cheat.dat to get
+cheat info.</P>
+
+<P>The default is XMAMEROOT/cheat.dat . XMAMEROOT is set during
+compile-time; see the Makefile. This can be overridden by the cheatfile
+entry in xmamerc if present, which can again be overridden by the
+cmdline-option <CODE>-cheatfile</CODE>.</P>
+
+<P><CODE>cheat.dat</CODE> is available from the mame homepage: 
+<A HREF="http://www.mame.net">http://www.mame.net</A></P>
+
+<H3>history.dat</H3>
+
+<P>If you want to display some nice background info on games, mame
+needs to load history.dat.</P>
+
+<P>The default is XMAMEROOT/history.dat . XMAMEROOT is set during
+compile-time, see the Makefile. This can be overridden by the historyfile
+entry in xmamerc if present, which can again be overridden by the
+cmdline-option <CODE>-historyfile</CODE>.</P>
+
+<P><CODE>history.dat</CODE> is available from the mame homepage: 
+<A HREF="http://www.mame.net">http://www.mame.net</A></P>
+
+<H3>Input logs</H3>
+
+<P>Input logs are saved/read under the name specified after the
+<CODE>-record / -playback</CODE> option; this name is relative to the current
+path.</P>
+
+<H3>Xmame/xmess still can't find files/store highscores</H3>
+
+<P>Type <CODE>&quot;xmame/xmess -showconfig | more&quot;</CODE> and check that
+the rompath and spooldir shown are correct and readable/writable.
+Otherwise recheck xmamerc/xmessrc. Remember that xmess also searches
+the current dir.</P>
+
+<H2><A NAME="ss3.10">3.10</A> <A HREF="xmame-doc.html#toc3.10">How do I start xmess/xmame ?</A>
+</H2>
+
+<P>To start xmame, type</P>
+
+<P>
+<PRE>
+    xmame [options] &lt;gamename&gt; [more options]
+</PRE>
+</P>
+<P>For xmess, type</P>
+
+<P>
+<PRE>
+    xmess [options] &lt;systemname&gt; [more options] \
+    &lt;disk/romimage(s)&gt; [more options]
+</PRE>
+</P>
+<P>All options are optional. ;)</P>
+
+<P>Xmame/xmess supports most dos command line options (see readme.mame
+/ readme.mess) as well as a few of its own: Type xmame -help |  more
+for a complete list.</P>
+
+<P>With xmess, some systems don't require a disk/romimage, but most
+do.</P>
+
+<H2><A NAME="ss3.11">3.11</A> <A HREF="xmame-doc.html#toc3.11">What are the command line parameters for xmame/xmess?</A>
+</H2>
+
+<P>To see a list of available parameters, type:</P>
+
+<P>
+<PRE>
+    /usr/games/xmame -help | more
+</PRE>
+</P>
+<P>Xmame/xmess supports most of the command line parameters as the
+DOS  version as well a some of its own.</P>
+
+<P>See the file readme.mame / readme.mess for more information about
+the command line parameters.</P>
+
+<H2><A NAME="FAQ: What keys does xmame/xmess use?"></A> <A NAME="ss3.12">3.12</A> <A HREF="xmame-doc.html#toc3.12">What keys does xmame/xmess use?</A>
+</H2>
+
+<P>Xmame/xmess uses the same key-bindings as the DOS version of
+mame: The following keys work in all emulators:</P>
+
+<P>
+<PRE>
+    `  or ~      Enter On screen display to change volume, brightness etc.
+    Tab          Enter configuration menu. Press Tab or Esc to get back to
+                 the emulation.
+    P            Pause
+    F3           Reset
+    F4           Show the game graphics. Use cursor keys to change set/color,
+                 F4 or Esc to return to the emulation.
+    F8           Reduce frame skip
+    F9           Increase frameskip
+    F10          Toggle speed throttling
+    F10 + shift  Toggle idle sleeping
+    F11          Toggle speed display
+    F11 + shift  Toggle profiler display
+    F12          Save a screen snapshot
+    ESC          Exit emulator
+</PRE>
+</P>
+<P>Xmame has 2 different auto frameskipping algorithms. These can
+be selected with the -frameskipper option and with key combos:</P>
+
+<P>
+<PRE>
+    Key combo:             Gives you the:
+    left-ctrl + insert     standard dos frameskipper
+    left-ctrl + home       William Barath's frameskipper
+</PRE>
+</P>
+<P>Xmame's display scaling can be controlled on the fly with the
+following key combos:</P>
+
+<P>
+<PRE>
+    Key combo:             Result:
+    left-shift + insert    Increase widthscale
+    left-shift + delete    Decrease widthscale
+    left-shift + home      Increase heightscale
+    left-shift + end       Decrease heightscale
+    left-shift + pageup    Increase scale
+    left-shift + pagedown  Decrease scale
+</PRE>
+</P>
+<P>Under X11, xmame can switch to and from different modes during
+runtime: </P>
+
+<P>
+<PRE>
+    Key combo:             Warps you to:
+    left-alt + insert      Normal window
+    left-alt + home        DGA fullscreen mode
+</PRE>
+</P>
+<P>Under SDL, xmame can switch to and from different modes during
+runtime:</P>
+
+<P>
+<PRE>
+    Key combo:             Result:
+    left-alt + enter       Toggles between windowed and
+                           fullscreen modes.
+</PRE>
+</P>
+<P>Under X11 in a window, you can also grab the mouse. To be able
+to play with the mouse, press left-alt + page-down to grab the mouse,
+and press it again to release it.</P>
+
+<H2><A NAME="ss3.13">3.13</A> <A HREF="xmame-doc.html#toc3.13">Why doesn't a game have sound?</A>
+</H2>
+
+<P>
+<UL>
+<LI>First check that sound is working in other applications.</LI>
+<LI>Check that sound is supported for the game that has no sound;
+not all games have sound.</LI>
+<LI>For xmame, take a look at gamelist.mame: Is the sound for the
+game emulated?</LI>
+<LI>For xmess take a look at readme.mess: Is the sound for the system
+emulated?</LI>
+<LI>Check the operating system support chart in the earlier part
+of  this file: Does xmame/xmess support sound on your system?
+</LI>
+</UL>
+</P>
+<H2><A NAME="ss3.14">3.14</A> <A HREF="xmame-doc.html#toc3.14">My sound seems lagged. / My sound Clicks. / What does -bufsize</A>
+ do?</H2>
+
+<P>With the <CODE>-bufsize</CODE> commandline option or the bufsize configfile
+keyword, you can specify the number of frames of audio to buffer.
+The default is 2 frames.</P>
+
+<P>This value should be ok for everyone, but if you still have problems,
+read on.</P>
+
+<P>If the buffersize is to small, this causes the buffer to get
+empty between frames which in turn causes clicks/pauses in the sound.
+If this is the case, increasing the -bufsize value to, for example,
+2.5 should help.</P>
+
+<P>If, however, you make the buffersize too large, then so much
+audio becomes buffered, that the sound could become lagged. E.g.,
+you would hear the coin drop sound 0.5 seconds after pressing the
+insert coin key. In this case, lower the bufsize to, for example,
+1.5.</P>
+
+<P>Please let me know if you need to change this setting, since
+I'm planning on removing it in a future release.</P>
+
+<H2><A NAME="FAQ: Why doesn't a game work?"></A> <A NAME="ss3.15">3.15</A> <A HREF="xmame-doc.html#toc3.15">Why doesn't a game work? </A>
+</H2>
+
+<P>
+<UL>
+<LI>Do you have the right roms or did you get checksum failures?</LI>
+<LI>Xmame version 0.34 and higher require PROM files that were not
+included in ROM images released before version 0.34. See the question
+on PROMs  below for more information.</LI>
+<LI>For xmame, check the file gamelist.mame to see if the game is
+playable. Just because a game is included doesn't mean it is working
+yet.</LI>
+<LI>For xmess, take a look at readme.mess. Maybe the system isn't
+emulated all that well yet.</LI>
+<LI>Some games require sound support. If you don't have sound  support
+under your Unix installation or sound isn't supported by xmame/xmess
+for you, try the <CODE>-fakesound</CODE> command line parameter.
+</LI>
+</UL>
+</P>
+<H2><A NAME="FAQ: What are PROMs?"></A> <A NAME="ss3.16">3.16</A> <A HREF="xmame-doc.html#toc3.16">What are PROMs? </A>
+</H2>
+
+<P>PROMs contain game-specific information that used to be built
+in  to mame in versions prior to 0.34. This information has been
+extracted and is now included with new versions of ROM files for
+games that require this information.</P>
+
+<P>If you want to use your current ROM files, you can obtain just
+the PROM images in one large file at:</P>
+
+<P>
+<A HREF="http://mame.retrogames.com/">http://mame.retrogames.com/</A></P>
+
+<H2><A NAME="ss3.17">3.17</A> <A HREF="xmame-doc.html#toc3.17">Why is xmame/xmess slow?</A>
+</H2>
+
+<P>Xmame/xmess is a compiled C program that is emulating hardware.
+Software emulation of hardware always incurs a speed penalty. Here
+are some things you can do:</P>
+
+<P>
+<UL>
+<LI>Try using the -frameskip command line parameter.</LI>
+<LI>Try pressing F8 while running xmame/xmess to alter the frame
+rate.</LI>
+<LI>Try disabling the throttle with the -nothrottle command line
+parameter or by pressing F10 while running xmame/xmess.</LI>
+<LI>While running xmame/xmess, press F11 to check the speed of xmame/xmess.
+If you never get a display of 100%, you need a faster computer.
+</LI>
+</UL>
+</P>
+<P>You can also try recompiling xmame/xmess with more optimal settings.
+The following suggestions may not work or may not be appropriate
+on some machines and in some installations.  However, in cases where
+they do work, there can be a noticeable increase in overall performance
+of xmame/xmess.</P>
+
+<P>These &quot;enhancements&quot; simply require editing the Makefile
+that is distributed with xmame, and then recompiling the source.
+If you are compiling the source for the second time you will need
+to do:</P>
+
+<P>
+<PRE>
+    make clean
+    make
+    make install
+</PRE>
+</P>
+<P>after editing the Makefile to set your new settings.</P>
+
+<H3>SPEEDUP # 1 - Inline compiling</H3>
+
+<P>Try enabling inline compiling by commenting and uncommenting
+the following lines:</P>
+
+<P>
+<PRE>
+    # IL    = '-DINLINE=static inline'
+    IL     = -DINLINE=static
+</PRE>
+</P>
+<H3>SPEEDUP # 2 - Direct Graphics Access</H3>
+
+<P>For a big boost, try enabling DGA by uncommenting the following
+line:</P>
+
+<P>
+<PRE>
+    DGA = 1
+</PRE>
+</P>
+<P>Then start xmame as root, and press left-alt + home to switch
+to dga mode; that should be a lot faster, and doesn't need/use xsync.
+;) </P>
+
+<P>To get back to a window without exiting, press left-alt + insert.</P>
+
+<P>The benefit of DGA is that it is Direct Graphics Access and therefore
+writes directly to the framebuffer (think DirectX versus GDI under
+MS Windows). So it should be a tad faster, unless you've got a really
+really well accelerated X server, which could be just as fast. Try
+pressing F11 to see the actual framerate, although it might be hardly
+noticable (visually, at least), it should give you some speed increase.</P>
+
+<P>Besides that, it automatically switches to the right mode and
+removes any window manager stuff, but that can be done without DGA
+too. (I might add such a feature later, since it allows easy fullscreen
+without running as root.)</P>
+
+<P>Adding a 320x240 mode will most definitely get you a very nice
+fullscreen display at scale = 1. ;)</P>
+
+<P>Don't forget that you still need to set up the Modes line of
+the   &quot;Display&quot; subsection of the &quot;Screen&quot; section
+in your X11 config file if you want the games to fill the screen
+in DGA mode. Xmame will pick the best mode it can find, so if you
+have a line like</P>
+
+<P>
+<PRE>
+    Modes  &quot;1024x768&quot; &quot;800x600&quot; &quot;640x480&quot; &quot;320x240&quot; &quot;256x224&quot;
+</PRE>
+</P>
+<P>then any game which fits into a 320x240 screen can be displayed
+in that resolution, and so on. Don't forget your X11 config file
+might have a number of different &quot;Screen&quot; sections in it,
+and you will need to add Modes to the one that is actually active
+with your Xserver is running. And of course it's not always that
+easy, since you also need to tell X which monitor settings are required
+for these resolution modes. This is done through Modeline entries
+in the &quot;Monitor&quot; section of your X config file.</P>
+
+<P>You can check out the <CODE>/contrib/tools/modelines</CODE> file for a set
+of crazy modes made especially for xmame in DGA mode. They should
+work on any reasonable multisync monitor, but don't use them on an
+old fixed-frequency monitor. (And if you can't resist trying, I won't
+pay for a new one!)</P>
+
+<H3>SPEEDUP # 3 - NASM</H3>
+
+<P>You can also try installing nasm and compiling the asm core,
+that helps a bit too.</P>
+
+<H3>SPEEDUP # 4 - ICC</H3>
+
+<P>If you are running on an intel architecture machine, you could
+try to compile xmame with the Intel C Compiler. Some people have
+reported speed gains from +10%.</P>
+
+<H2><A NAME="ss3.18">3.18</A> <A HREF="xmame-doc.html#toc3.18">I've got a dual processor machine. What can I do to take full</A>
+ advantage of this?</H2>
+
+<P>Not much. Xmame is a single-threaded port of a single-threaded
+DOS app. Some degree of speedup will hopefully be found on an SMP
+machine since xmame is more likely to get to hog its one CPU for
+longer. But of course the same applies to any CPU-intensive program.
+And all the things one would normally do to any application to give
+it more CPU time (higher priority, kill or renice unecessary process,
+etc.) will work with xmame.</P>
+
+<P>Now you may at this point be thinking, "Surely you could have
+one thread doing emulation and another thead doing graphics to get
+a speedup." Yes, but there are some serious issues to consider. The
+first is synchronisation between the threads, which needs to be pretty
+tight. If not done smoothly. the overhead will blow most of the benefit
+away. Also, it needs to be implemented with a portable threads interface
+... which basically means POSIX threads. In a nutshell, it's a lot
+of effort for probably not much gain. But of course if you are feeling
+particulary energetic and in the mood to code, then patches can always
+be submitted to the xmame devel mailing list ... :)</P>
+
+<H2><A NAME="ss3.19">3.19</A> <A HREF="xmame-doc.html#toc3.19">Why doesn't my joystick handle diagonal movement correctly on</A>
+ my Intel x86 system?</H2>
+
+<P>Xmame/xmess uses autocalibrating, but you could try to use specific
+programs to calibrate it (jscal that comes with joystick  module
+works fine....).</P>
+
+<H2><A NAME="ss3.20">3.20</A> <A HREF="xmame-doc.html#toc3.20">How do I enable XinputExtensions X11 based joystick in Xfree86?</A>
+</H2>
+
+<P>You need to edit XF86Config to enable the XInput section. See
+the  manual page for XF86Config.</P>
+
+<H2><A NAME="ss3.21">3.21</A> <A HREF="xmame-doc.html#toc3.21">How do I read a manual page?</A>
+</H2>
+
+<P>Easy. If you want to read the manual page for XF86Config, type:
+man XF86Config</P>
+
+<H2><A NAME="FAQ: Why do I get gz_open symbol not found while compiling?"></A> <A NAME="ss3.22">3.22</A> <A HREF="xmame-doc.html#toc3.22">Why do I get gz_open symbol not found while compiling? </A>
+</H2>
+
+<P>Xmame/xmess versions newer than 0.35 use zlib for some compression
+routines. Unfortunately, a lot of Linux distributions have an old
+version of zlib installed as /usr/X11R6/lib/libz.a, and the new version
+installed as /usr/lib/libz.a. If this is the case, it's harmless
+to remove /usr/X11R6/lib/libz.a. If you're not sure whether this
+is the case, just move /usr/X11R6/lib/libz.a to another location.</P>
+
+<P>Removing or just moving /usr/X11R6/lib/libz.a should fix this
+problem.</P>
+
+<P>Also see: 
+<A HREF="#FAQ: Why do I get zlib.h not found?">FAQ: Why do I get zlib.h not found?</A></P>
+
+<H2><A NAME="FAQ: Why do I get zlib.h not found?"></A> <A NAME="ss3.23">3.23</A> <A HREF="xmame-doc.html#toc3.23">Why do I get zlib.h not found? </A>
+</H2>
+
+<P>Xmame/xmess versions newer than 0.35 use zlib for some compression
+routines.</P>
+
+<P>Zlib is standard on most Unix versions. For those who don't ship
+with zlib or ship with a version that is too old, xmame/xmess now
+comes with a stripped-down version of zlib. Uncomment the appropriate
+line in the Makefile to use this.</P>
+
+<H2><A NAME="ss3.24">3.24</A> <A HREF="xmame-doc.html#toc3.24">When I run xmame.x11, nothing happens---no window pops up or</A>
+ anything. Help!</H2>
+
+<P>Are you running a recent version of KDE, such as 2.1.1? It appears
+that there's a bug with KDE's window manager that prevents some X11
+apps from popping up their main window. You can either run the SDL
+version of xmame, or try the following workaround, which several
+people have reported as being successful:</P>
+
+<P>
+<PRE>
+xmame.x11 -rid `xwininfo -root | grep xwininfo: | awk '{print $4}'`
+</PRE>
+</P>
+<H2><A NAME="ss3.25">3.25</A> <A HREF="xmame-doc.html#toc3.25">Can I run xmame fullscreen?</A>
+</H2>
+
+<P>Yes, of course you can. There are several ways to accomplish
+this, each with its own advantages and disadvantages.</P>
+
+<P>To enable the fullscreen support, you will need to change some
+settings in the makefile and recompile xmame.</P>
+
+<P>Besides the x11 and SDL drivers, the FX and GL drivers are also
+capable of playing games full screen. There is a separate chapter
+for these later on.</P>
+
+<H3>xmame.x11/DGA</H3>
+
+<P>First, before recompiling, make sure you have an xserver with
+the "xfree-dga&quot; extension enabled (do a "xdpyinfo" and see if you've
+got the "xfree-dga&quot; extension); any recent release of XFree86
+should have it.</P>
+
+<P>Select DISPLAY_METHOD = x11 and uncomment the line "DGA=1&quot;
+in the makefile.</P>
+
+<P>Now build xmame and give the xmame.x11 file permanent root permissions
+so that you don't need to start xmame as root (do a "chown root xmame.x11&quot;
+and a "chmod u+s xmame.x11&quot;).</P>
+
+<P>If you want to start immediately in fullscreen mode, start xmame.x11
+with the &quot;-x11 1&quot; argument or specify &quot;x11-mode 1&quot;
+in your xmamerc file.</P>
+
+<P>During play you can switch between windowed and fullscreen mode.
+See 
+<A HREF="#FAQ: What keys does xmame/xmess use?">What keys does xmame/xmess use?</A></P>
+
+<H3>xmame.x11/Xv</H3>
+
+<P>Xv is the X Window System video extension. Among other things,
+it supports hardware scaling if your graphics card (and X driver)
+is capable of doing so. You can achieve a very nice fullscreen display
+without taxing your cpu very much because the scaling will all be
+done by your video card.</P>
+
+<P>To determine if your video card supports the Xv extension, you
+may use this command:</P>
+
+<P>
+<PRE>
+xvinfo
+</PRE>
+</P>
+<P>If you don't see a message indicating "no screens found", then
+the Xv extension is supported by your machine.</P>
+
+<P>To compile this into xmame, select DISPLAY_METHOD = x11 and uncomment
+the line "X11_XV = 1" in the makefile.</P>
+
+<P>Build xmame, and use the -fullscreen parameter when loading a
+game to get a nice fullscreen display.</P>
+
+<P>If the colors seem messed up and/or you only see half of the
+game image, try using "-yuv" or "-yv12". By default, the Xv extension
+attempts to use RGB mode if your driver supports it, but some cards'
+drivers are broken.</P>
+
+<P>If your screen goes blank or gets full of little green vertical
+lines, then your graphics card does not support the Xv extension
+and you're out of luck.</P>
+
+<H3>xmame.SDL</H3>
+
+<P>The SDL library was meant to make it easy for programmers to
+make full screen applications. To start SDL in fullscreen mode, just
+run xmame.SDL with the option '-fullscreen'. If you want to know
+the resolutions that SDL can use, run "xmame.SDL -listmodes", choose
+the resolution you want, and start "xmame.SDL -modenumber &lt;insert
+chosen number here&gt;".</P>
+
+<P>You can add "fullscreen 1" to your xmamerc file if you want SDL
+to start fullscreen automatically; the modenumber line can also be
+used in the xmamerc. :-)</P>
+
+<P>Most problems experienced by people who are trying to use SDL
+for fullscreen are related to the section 
+<A HREF="#FAQ: xmame.sdl / xmame.x11 fullscreen has a large border around the game.">fullscreen has a large border</A></P>
+
+<P>During play you can switch between windowed and fullscreen mode.
+See 
+<A HREF="#FAQ: What keys does xmame/xmess use?">What keys does xmame/xmess use?</A></P>
+
+<H2><A NAME="FAQ: xmame.sdl / xmame.x11 fullscreen has a large border around the game."></A> <A NAME="ss3.26">3.26</A> <A HREF="xmame-doc.html#toc3.26">xmame.SDL / fullscreen has a large border around the game. </A>
+</H2>
+
+<P>If the game runs in fullscreen but occupies only a small area
+in the center of the screen, then your xserver does not have access
+to low resolutions (320x240, 400x300, and 512x384, for instance).
+In the case of SDL, the window will be in the resolution of closest
+matching resolution that SDL can switch to for full screen display.</P>
+
+<P>In this case, you have to add &quot;Modelines&quot; for these
+resolutions in your XF86config file and add these resolutions to
+the resolutions list of your display somewhere in your XF86config
+file (you know, the list of resolutions you can switch to using ctrl-+).</P>
+
+<P>You should find modelines that works with most graphic cards
+in the xmame contrib subdirectory.</P>
+
+<P>If you don't want to alter your XF86config file, another solution
+is to run xmame.x11 with the &quot;-scale 2&quot; argument. In this
+case, the emulator will use 640x480 instead of 320x240, 800x600 instead
+of 400x300, etc. But I don't recommend it. The scaling uses cpu and
+the games will run more slowly.</P>
+
+<P>However, if your cpu is fast enough, a better option is to use
+the effects "-ef 1". This introduces advanced render methods to create
+a nicer looking effect than the simple scaling. On the website you
+can see 
+<A HREF="http://x.mame.net/gamescreenshots.html">screenshots</A> of the different effects.</P>
+
+<H2><A NAME="ss3.27">3.27</A> <A HREF="xmame-doc.html#toc3.27">I only use some of the emulation parts (Neo Geo / CPS-2 /...).</A>
+ Do I need the entire xmame? </H2>
+
+<P>If you are interested in compiling only some of the games you,
+can compile xmame with an alternate target. Edit the makefile.unix
+and change the target line to accomplish the desired effect. Using
+this approach, only the CPUs, sound devices, and other chips needed
+for that particular target are compiled, resulting in a much smaller
+executable.</P>
+
+<P>
+<UL>
+<LI>'TARGET = cpmame' makes a mame version that will only emulate
+the CPS-1 and CPS-2 games</LI>
+<LI>'TARGET = neomame' makes a mame version that will only emulate
+the Neo Geo system
+</LI>
+</UL>
+</P>
+<P>There are some other targets but they are really only useful
+for the mame developers who create new drivers.</P>
+
+<H2><A NAME="ss3.28">3.28</A> <A HREF="xmame-doc.html#toc3.28">Why does xmame freeze and lock up when I hit &lt;ESC&gt; to exit</A>
+ the game or P to pause the game?</H2>
+
+<P>There appears to be a bug in the &quot;timer based audio&quot;
+code that xmame/oss uses on at least one motherboard that we are
+aware of. Specifically, the ATX 845Pro (Intel Pentium 4 processor)
+with an integrated i810 soundchip.</P>
+
+<P>To get around this bug use EsounD (Enlightened Sound Daemon),
+found as esd with Gnome distributions, instead of the oss sound drivers.</P>
+
+<P>Compile ESOUND support into the xmame executable by uncommenting
+the appropriate line in makefile.unix. Tell xmame to use esound by
+specifying &quot;esound&quot; on the &quot;dsp-plugin&quot; line
+in xmamerc, or use the -dp command line parameter to select esound.
+Also see the next section below.</P>
+
+<H2><A NAME="ss3.29">3.29</A> <A HREF="xmame-doc.html#toc3.29">Why does xmame report &quot;can't resolve host name '/dev/dsp'</A>
+ when trying to use esound?</H2>
+
+<P>Remove the words &quot;/dev/dsp&quot; from the &quot;audiodevice&quot;
+line in xmamerc. In other words, you want to have the word &quot;audiodevice&quot;
+on a line all by itself, with no audiodevice specified.</P>
+
+<H2><A NAME="ss3.30">3.30</A> <A HREF="xmame-doc.html#toc3.30">Where can I get the latest version of xmame/xmess?</A>
+</H2>
+
+<P>The xmame/xmess Home Page always has the most up-to-date version.
+The address is</P>
+
+<P>
+<A HREF="http://x.mame.net/">http://x.mame.net/</A></P>
+
+<H2><A NAME="ss3.31">3.31</A> <A HREF="xmame-doc.html#toc3.31">I upgraded xmame and now some games do not work anymore.</A>
+</H2>
+
+<P>This can happen, especially if the drivers are in full development
+or some internal core routines have changed and the drivers have
+to be updated to accomodate for these core changes. Sometimes a new
+romdump has been made from the game and you still have the old version,
+or the zipfile has changed names and you need to rename yours (or
+any combination of these factors :-).</P>
+
+<P>Here are some things you can do:</P>
+
+<P>
+<OL>
+<LI>Clear all the old configuration files, nvram files, etc. Also
+delete the content of the directories mem, nvram, cfg, and try to
+run the game again. Don't forget to delete the default.cfg file!</LI>
+<LI>If that fails, check to see if the name of the zipfile is still
+in the list of supported games. If you enter an invalid game name,
+xmame will take a guess to determine which game you wanted; look
+at the first lines of output to see if it tries to load a different
+game than the one you want. To know if your game is still supported,
+try 'xmame.x11 -list gamename'. If you do not pass a game name, the
+complete list of supported games is printed, and you can search for
+the new game name (better use 'xmame.x11 -listfull').</LI>
+<LI>If the name hasn't changed, check to see if you have the correct
+romdump. Run 'xmame.x11 -verifyroms gamename' to check your romset.
+If this fails you will need to download a newer romdump. Also check
+your parent roms as a possible cause of this romset failure.</LI>
+<LI>Read the documentation!! Or like the experts would say, "RTFM!"
+:-) Chances are that if the driver is broken, the developer has noted
+this in the documentation.</LI>
+<LI>If the above steps don't solve the problem, then check to see
+if it is a known problem; if necessary, report it to the mame testers
+project.
+</LI>
+</OL>
+</P>
+<P>If none of these fixes the problem, then try using the older
+version of xmame you have backed up somewhere to play the game. (You
+did back-up, didn't you?)</P>
+
+<H2><A NAME="ss3.32">3.32</A> <A HREF="xmame-doc.html#toc3.32">Where can I send fixes, bug reports, suggestions, or money?  :-)</A>
+</H2>
+
+<P>See 
+<A HREF="xmame-doc-5.html#Mail">Mail</A> of this document.</P>
+
+<H2><A NAME="ss3.33">3.33</A> <A HREF="xmame-doc.html#toc3.33">What if my question is still not answered?</A>
+</H2>
+
+<P>Please check the offical mame and mess readme files to see if
+that answers your question:</P>
+
+<P>
+<UL>
+<LI>
+<A HREF="readme.mame">The official mame readme file (readme.mame)</A></LI>
+<LI>
+<A HREF="readme.mess">The official mess readme file (readme.mess)</A>
+</LI>
+</UL>
+</P>
+<P>If that doesn't help, then ask your question on the mailing list
+or send it to the xmame/xmess maintainer, see  
+<A HREF="xmame-doc-5.html#Mail">Mail</A> for contact information.</P>
+
+<HR>
+<A HREF="xmame-doc-4.html">Next</A>
+<A HREF="xmame-doc-2.html">Previous</A>
+<A HREF="xmame-doc.html#toc3">Contents</A>
+</BODY>
+</HTML>
diff --git a/src/unix/doc/xmame-doc-4.html b/src/unix/doc/xmame-doc-4.html
new file mode 100644
index 0000000..f9ac0f5
--- /dev/null
+++ b/src/unix/doc/xmame-doc-4.html
@@ -0,0 +1,711 @@
+<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
+<HTML>
+<HEAD>
+ <META NAME="GENERATOR" CONTENT="LinuxDoc-Tools 0.9.11">
+ <TITLE>XMAME/XMESS DOCUMENTATION: Display Subsystem-Specific Comments and Notes </TITLE>
+ <LINK HREF="xmame-doc-5.html" REL=next>
+ <LINK HREF="xmame-doc-3.html" REL=previous>
+ <LINK HREF="xmame-doc.html#toc4" REL=contents>
+<link rel="stylesheet" href="xmame.css" type="text/css" >
+</HEAD>
+<BODY BACKGROUND="img/xmame.jpg" BGPROPERTIES="fixed" >
+<A HREF="xmame-doc-5.html">Next</A>
+<A HREF="xmame-doc-3.html">Previous</A>
+<A HREF="xmame-doc.html#toc4">Contents</A>
+<HR>
+<H2><A NAME="Display subsystem specific comments and notes"></A> <A NAME="s4">4.</A> <A HREF="xmame-doc.html#toc4">Display Subsystem-Specific Comments and Notes </A></H2>
+
+<H2><A NAME="ss4.1">4.1</A> <A HREF="xmame-doc.html#toc4.1">FXmame, a glide driver for xmame</A>
+</H2>
+
+<P>The latest version of this driver can be obtained at 
+<A HREF="http://glmame.linuxgames.com">http://glmame.linuxgames.com</A>.</P>
+
+<H3>Requirements</H3>
+
+<P>To run FXmame, you must have:</P>
+
+<P>
+<UL>
+<LI>A 3Dfx card</LI>
+<LI>Glide 2x</LI>
+<LI>The xmame distribution
+</LI>
+</UL>
+</P>
+<H3>Compiling and Installing</H3>
+
+<P>FXmame comes in two flavours---xfx and svgafx. The xfx version
+is designed to run under X11. It uses an X window for input. The
+svgafx version runs from the console, and uses svgalib for input.
+Both use the 3Dfx hardware for rendering.</P>
+
+<P>To install FXmame, follow the general instructions for installing
+xmame. To specify the glide driver, do the following to the Makefile:</P>
+
+<P>
+<UL>
+<LI>Select either &quot;xfx&quot; or &quot;svgafx&quot; as your display
+method</LI>
+<LI>Configure the glide variables to correspond to your glide setup
+</LI>
+</UL>
+</P>
+<P>The FXmame executables are called &quot;xmame.xfx&quot; and &quot;xmame.svgafx&quot;</P>
+
+<H3>Running</H3>
+
+<P>FXmame runs with the same parameters and uses the same keyboard
+commands that xmame.x11 does.</P>
+
+<P>A few extra keyboard commands have been added in the glide driver:</P>
+
+<P>
+<UL>
+<LI>RIGHTCTRL-A -- toggle antialiasing in vector games </LI>
+<LI>RIGHTCTRL-B -- toggle bilinear filtering
+</LI>
+</UL>
+</P>
+<P>The glide driver also adds several command-line options:</P>
+
+<P>
+<PRE>
+    -fxgama &lt;value&gt; 3Dfx gamma correction value
+</PRE>
+</P>
+<P>Note that in order to display the game options or the fps display
+in vector games, I have to overlay the game bitmap over the vector
+display. This is because I circumvent the bitmap entirely in vector
+games. Drawing the bitmap is a big cpu hog, so you'll notice that
+the game slows down when you turn on the fps display (I know, not
+ideal when you want to find out the frame rate...).</P>
+
+<H3>Common Questions (FAQ)</H3>
+
+<P>Q: When I run FXmame, it just dumps core.</P>
+
+<P>A: Make sure you are running FXmame as root. Root privileges
+are required to access the 3Dfx hardware</P>
+
+<P>Q: When I run xmame.xfx, it just hangs at the initial game screen.</P>
+
+<P>A: Are you running KDE? For some reason, I can't get keyboard
+input under KDE. If you have this problem, switch window managers
+or use xmame.svgafx instead.</P>
+
+<H3>Present Limitations/Bugs</H3>
+
+<P>
+<UL>
+<LI>Antialiasing isn't working quite as well as it should</LI>
+<LI>Input problems under KDE
+</LI>
+</UL>
+</P>
+<H3>Future Work</H3>
+
+<P>
+<UL>
+<LI>Optimize the drawing code to update only the changed portions
+of the game bitmap.
+</LI>
+</UL>
+</P>
+<H3>License</H3>
+
+<P>The FXmame code is Copyright 1998 by Mike Oliphant. It may be
+used and distributed under the terms of the MAME license.</P>
+
+<H3>Version History</H3>
+
+<P>v0.5 -- December 11th, 1998 ---------------------------</P>
+
+<P>
+<UL>
+<LI>implemented long copies in screen update</LI>
+<LI>added dirty handling. this greatly increases the speed of games
+that support the dirty update strategy (although most of them are
+older games that already ran at full speed on modern hardware)</LI>
+<LI>merged source with xmame b8.1
+</LI>
+</UL>
+</P>
+<P>v0.4 -- October 30th, 1998 --------------------------</P>
+
+<P>
+<UL>
+<LI>improved alpha handling in vector games - now bitmapped overlays
+do not dim the screen o added svgalib support (xmame.svgafx) o fixed
+a tiling bug that gave artifacts on texture tile boundaries
+</LI>
+</UL>
+</P>
+<P>v0.3 -- October 29th, 1998 --------------------------</P>
+
+<P>
+<UL>
+<LI>got rid of extra lines in vector games o added bitmap overlay
+in vector games to show options/fps o added antialiasing in vector
+games
+</LI>
+</UL>
+</P>
+<P>v0.2 -- October 28th, 1998 --------------------------</P>
+
+<P>
+<UL>
+<LI>added screenshots o added 3Dfx gamma adjustment o added direct
+acceleration of vector games (still buggy)
+</LI>
+</UL>
+</P>
+<P>v0.1 -- October 27th, 1998 --------------------------</P>
+
+<P>
+<UL>
+<LI>first public release
+</LI>
+</UL>
+</P>
+<H3>Author</H3>
+
+<P>Mike Oliphant <CODE>
+<A HREF="mailto:oliphant@ling.ed.ac.uk">(oliphant@ling.ed.ac.uk)</A></CODE> 
+<A HREF="http://glmame.linuxgames.com">http://glmame.linuxgames.com</A></P>
+
+<H2><A NAME="ss4.2">4.2</A> <A HREF="xmame-doc.html#toc4.2">GLmame, an OpenGL driver for xmame</A>
+</H2>
+
+<P>The latest version of this driver can be obtained at: 
+<A HREF="http://www.jausoft.com/glmame.html">http://www.jausoft.com/glmame.html</A></P>
+
+<H3>Requirements</H3>
+
+<P>To run GLmame you must have:</P>
+
+<P>
+<UL>
+<LI>An OpenGL implementation</LI>
+<LI>libjpeg</LI>
+<LI>hardware 3D acceleration (if you want any kind of framerate)</LI>
+<LI>the xmame distribution
+</LI>
+</UL>
+</P>
+<H3>Compiling and Installing</H3>
+
+<P>Follow the general instructions for installing xmame. To specify
+the OpenGL driver, do the following in the Makefile:</P>
+
+<P>
+<UL>
+<LI>Select &quot;xgl&quot; as your display method.</LI>
+<LI>For runtime printed debug info, add "-DGLDEBUG" to the "GLCFLAGS&quot;
+variable.</LI>
+<LI>GLU version 1.2 is recommended (e.g., from SGI). If you use Mesa's
+GLU, you may have to add "-DGLU_VERSION_1_2" to the "GLCFLAGS".
+</LI>
+</UL>
+</P>
+<P>The GLmame executable is called &quot;xmame.xgl&quot;.</P>
+
+<H3>Running</H3>
+
+<P>xmame.xgl runs with the same parameters and uses the same keyboard
+commands that xmame.x11 does.</P>
+
+<P>The program starts up in cabinet mode. While this is pretty,
+and cool, you'll probably want to actually play in fullscreen mode.</P>
+
+<P>A few extra keyboard commands have been added in the OpenGL driver:</P>
+
+<P>
+<UL>
+<LI>RIGHT_ALT-A -- toggle antialias filtering (vector)</LI>
+<LI>RIGHT_ALT-B -- toggle bilinear filtering (raster)</LI>
+<LI>RIGHT_ALT-C -- toggle cabinet/fullscreen display (both)</LI>
+<LI>RIGHT_ALT-F -- toggle between fullscreen (max window size) and
+startup window size (both)</LI>
+<LI>RIGHT_ALT-O -- toggle draw-bitmap (both; nonsense for raster
+games, speedup for vector games)</LI>
+<LI>RIGHT_ALT-T -- toggle phosphor trails (vector)</LI>
+<LI>RIGHT_ALT-PLUS_PAD -- incr. beam size (vector)</LI>
+<LI>RIGHT_ALT-MINUS_PAD -- decr. beam size (vector)
+</LI>
+</UL>
+</P>
+<P>The OpenGL driver also adds several command-line options:</P>
+
+<P>
+<PRE>
+    -[no]fullscreen         Start in fullscreen mode
+                            (default: disabled)
+
+    -[no]gldblbuffer        Disable/enable double buffering
+                            (default: enabled)
+
+    -gltexture_size &lt;int&gt;   Force the max width and height of one 
+                            texture segment (default: autosize)
+
+    -[no]glforceblitmode /  Force blitter for true color modes 15/32bpp
+    -[no]glblit             (default: enabled)
+
+    -[no]glext78 /          Force the usage of GL extension number 78,
+    -[no]glext              if available (palletted texture)
+                            (default: enabled)
+
+    -[no]glbilinear /       Disable/enable bilinear filtering
+    -[no]glbilin            (default: enabled)
+
+    -[no]gldrawbitmap /     Disable/enable drawing the bitmap; e.g., 
+    -[no]glbitmap           disable within vector games for a speedup
+                            (default: enabled)
+
+    -[no]glcolormod         Disable/enable color modulation (intensity,
+    -[no]glcmod             gamma)
+                            (default: enabled)
+
+    -glbeam &lt;float&gt;         Set the beam size for vector games
+                            (default: 1.0)
+
+    -[no]glalphablending /  Disable/enable alpha blending if available
+    -[no]glalpha            (default: enabled)
+
+    -[no]glantialias /      Disable/enable antialiasing
+    -[no]glaa               (default: enabled)
+
+    -gllibname /            Choose the dynamically loaded OpenGL
+    -gllib &lt;string&gt;         library
+                            (default: libGL.so)
+
+    -glulibname /           Choose the dynamically loaded GLU library
+    -glulib &lt;string&gt;        (default: libGLU.so)
+
+    -[no]cabview            Don't start/start in cabinet view mode
+                            (default: don't start in this mode)
+
+    -cabinet &lt;cabname&gt;      Specify which cabinet model to use
+                            (default: glmamejau)
+ 
+   -glres &lt;string&gt;          Always scale games to &lt;Xres&gt;x&lt;Yres&gt;, 
+                            keeping their aspect ratio. 
+                            This overrides the scale options.
+                            Use this e.g. for the Vodoo1 gfx cards
+                            with: &quot;-glres 640x480&quot;
+
+
+
+</PRE>
+</P>
+<P>Three cabinet models are provided. The default, &quot;glmamejau&quot;,
+is designed to look like a standard arcade cabinet, like &quot;glmame&quot;.
+The last one, &quot;trans&quot;, is a box with a transparent game
+screen.</P>
+
+<P>Note that in order to display the game options or the fps display
+in vector games, the game's bitmap is overlaid above the vector display.
+Drawing the bitmap is a big cpu hog for some low-end hardware accelerated
+OpenGL implementations, so you'll notice that the game slows down
+when the bitmap is overlaid.</P>
+
+<P>Because bitmap overlaying is the default, you can toggle it on
+and off by pressing the &quot;RIGHT_ALT-O&quot; key, or turn it off
+at startup by using the command line option &quot;-noglbitmap&quot;.</P>
+
+<P>A problem with vector games and the cabinet mode is that some
+vector points do not reside within the screen coordinates, so you
+may see some vectors outside of the cabinet's mame display.</P>
+
+<P><B>*** IMPORTANT! ***</B></P>
+
+<P>If you have trouble with GLmame, or it is slow, read the &quot;Common
+Questions&quot; section. Most of the questions people email me are
+answered here.</P>
+
+<H3>Cabinet Models</H3>
+
+<P>Cabinet model information is stored in the &quot;cab&quot; subdirectory
+of the directory you specified with the ROMPATH variable in the Makefile.
+Path information specified in xmamerc or with the 'rompath' shell
+environment variable is currently not used. Each cabinet model has
+it's own subdirectory. GLmame will first try to load either the user-specified
+cabinet model (using the -cabinet command-line option), or a model
+corresponding to the current game name. Failing that, it will use
+the generic &quot;glmame&quot; model.</P>
+
+<P>A cabinet model directory must contain a geometry file &lt;modelname&gt;.cab,
+and any .jpg files used for textures on the model. The format of
+the .cab file will be familiar if you have ever programmed using
+OpenGL -- it looks much like an OpenGL display list. The format is
+as follows:</P>
+
+<P>
+<PRE>
+    cabv1.1
+</PRE>
+</P>
+<P>This header must be the first 7 characters of the file.</P>
+
+<P>
+<PRE>
+    #&lt;text&gt;
+</PRE>
+</P>
+<P>Comment lines begin with '#'</P>
+
+<P>
+<PRE>
+    begin &lt;type&gt;
+</PRE>
+</P>
+<P>Begins a geometry object, where type is one of (points, polygon,
+quads, quad_strip, screen). Each &quot;begin&quot; must be paired
+with an &quot;end&quot; statement. A &quot;polygon&quot; is specified
+using one vertex per, well... vertex. &quot;quads&quot; are four-sided
+polygons, each specified by four vertices in order around the polygon.
+A &quot;quad_strip&quot; is a series of four-sided polygons, each
+of which shares an edge with the polygons before and after it in
+the strip. A &quot;screen&quot; is a quad that defines the actual
+area in 3D space where the game will be displayed. only one of these
+should be defined. For more info, look at any description of OpenGL
+geometry.</P>
+
+<P>
+<PRE>
+    end
+</PRE>
+</P>
+<P>Ends the geometry object begun with &quot;begin&quot;.</P>
+
+<P>
+<PRE>
+    pointsize &lt;s&gt;
+</PRE>
+</P>
+<P>Changes the current pointsize to the corresponding size value
+(specified as a floating point number between 0.0 and, e.g., 20.0).
+Note: You cannot use this statement between begin and end!</P>
+
+<P>
+<PRE>
+    color4 &lt;r&gt; &lt;g&gt; &lt;b&gt;
+</PRE>
+</P>
+<P>Changes the current color to the corresponding rgb value (specified
+as floating point numbers between 0 and 1).</P>
+
+<P>
+<PRE>
+    color4 &lt;r&gt; &lt;g&gt; &lt;b&gt; &lt;a&gt;
+</PRE>
+</P>
+<P>Changes the current color to the corresponding rgba value (specified
+as floating point numbers between 0 and 1).</P>
+
+<P>
+<PRE>
+    shading &lt;type&gt;
+</PRE>
+</P>
+<P>Sets the shading type. available types are &quot;smooth&quot;
+(which blends colors from one vertex to the next) or &quot;flat&quot;
+(which doesn't).</P>
+
+<P>
+<PRE>
+    vertex &lt;x&gt; &lt;y&gt; &lt;z&gt;
+</PRE>
+</P>
+<P>Specifies a vertex for the current geometry object as a point
+in 3-space.</P>
+
+<P>
+<PRE>
+    numtex &lt;num&gt;
+</PRE>
+</P>
+<P>Specifies the number of different textures to be loaded. This
+declaration must precede any &quot;loadtex&quot; call.</P>
+
+<P>
+<PRE>
+    loadtex &lt;num&gt; &lt;width&gt; &lt;height&gt; &lt;filename&gt;
+</PRE>
+</P>
+<P>Loads texture number &lt;num&gt; from .jpg file &lt;filename&gt;.
+The .jpg file *must* be &lt;width&gt; by &lt;height&gt; pixels, and
+both &lt;width&gt; and &lt;height&gt; must be powers of two (and
+must conform to the hardware requirements of any 3D card you want
+the cabinet to work with -- 256x256 for 3Dfx).</P>
+
+<P>
+<PRE>
+    texcoord &lt;xcoord&gt; &lt;ycoord&gt;
+</PRE>
+</P>
+<P>Sets the texture coordinate of the next vertex. This specifies
+where in 2D texture space the vertex lies.</P>
+
+<P>
+<PRE>
+    enable texture
+</PRE>
+</P>
+<P>Enables texture mapping (using the currently-selected texture).</P>
+
+<P>
+<PRE>
+    disable texture
+</PRE>
+</P>
+<P>Turns off texture mapping.</P>
+
+<P>
+<PRE>
+    settex &lt;num&gt;
+</PRE>
+</P>
+<P>Select texture &lt;num&gt; for doing texturing. The texture must
+previously have been loaded using &quot;loadtex&quot;.</P>
+
+<P>
+<PRE>
+    camerapan &lt;num&gt;
+</PRE>
+</P>
+<P>Starts the camera pan definition that will be followed by &lt;num&gt;
+camera transistions. After the last transision definition, the pan
+sequence must be ended with an &quot;end&quot; statement.</P>
+
+<P>
+<PRE>
+    goto &lt;lx&gt; &lt;ly&gt; &lt;lz&gt; &lt;px&gt; &lt;py&gt; &lt;pz&gt; &lt;nx&gt; &lt;ny&gt; &lt;nz&gt;
+</PRE>
+</P>
+<P>Relocates and reorients the camera. The arguments are the same
+as are used by the OpenGL command &quot;gluLookAt()&quot;. The camera
+is positioned at point &lt;lx,ly,lz&gt;, pointing along vector &lt;px,py,pz&gt;,
+with &quot;up&quot; normal (the direction that is &quot;up&quot;
+for the camera) &lt;nx,ny,nz&gt;.</P>
+
+<P>
+<PRE>
+    moveto &lt;lx&gt; &lt;ly&gt; &lt;lz&gt; &lt;px&gt; &lt;py&gt; &lt;pz&gt; &lt;nx&gt; &lt;ny&gt; &lt;nz&gt; &lt;frames&gt;
+</PRE>
+</P>
+<P>Moves the camera to a new location (specified as in &quot;goto&quot;).
+The transition occurs over &lt;frames&gt; frames.</P>
+
+<P>All commands must be on separate lines. Use the (somewhat) commented
+glmamejau cabinet as an example to work from.</P>
+
+<H3>Common Questions (FAQ)</H3>
+
+<P>Q: I am only getting a few frames-per-second. This sucks! What
+gives? </P>
+
+<P>A1: You're probably running Mesa in software mode. You should
+read the &quot;README.3Dfx&quot; file in the Mesa distro. Specifically,
+you need to &quot;setenv MESA_GLX_FX fullscreen&quot;.</P>
+
+<P>A2: You don't have a 3D graphics card. Go buy one (see below)!</P>
+
+<P>Q: When I run xmame.xgl, it just dumps core. That's not as much
+fun as 3D Pacman, now is it?</P>
+
+<P>A1: If you are using a 3Dfx card, make sure you are running xmame.xgl
+as root. Root privileges are required to access the 3Dfx hardware.</P>
+
+<P>A2: If you're using Mesa and haven't upgraded to v3.0, do so.</P>
+
+
+<P>Q: When I run xmame.xgl, it just hangs at the initial game screen.</P>
+
+<P>A: Are you running KDE? For some reason, I can't get keyboard
+input under KDE. If you have this problem, switch window managers.</P>
+
+<P>Q: Which graphics cards are usable with xmame.xgl? </P>
+
+<P>A: We have the following experiences (date 20010713):</P>
+
+<P>
+<UL>
+<LI>Vodoo3 + DRI OpenGL driver (XFree86 4.0.2), with command line
+options &quot;-noglaa&quot; and 16bpp X11 server color depth.</LI>
+<LI>Vodoo1 + Mesa 3.4 + Glide, with command line options "-glres 640x480"!</LI>
+<LI>GeForce + NVIDIA OpenGL driver + XFree86 4.0.2 with default command
+line options and 16/24bpp X11 server color depth.</LI>
+<LI>NVIDIA TNT2 + NVIDIA OpenGL driver + XFree86 4.0.2 with command
+line options &quot;-bpp 16&quot; and 16bpp (may be 24bpp also ???)
+X11 server color depth (OpenGL colortable mapping is buggy).</LI>
+<LI>NVIDIA TNT + NVIDIA OpenGL driver + XFree86 4.0.2 with command
+line options &quot;-bpp 16&quot; and 16bpp (may be 24bpp also ???)
+X11 server color depth (OpenGL colortable mapping is buggy).</LI>
+<LI>Matrox MGA 400 + DRI OpenGL driver (XFree86 4.0.2) with command
+line options &quot;-bpp 16&quot;, &quot;-noglaa&quot; (???) and 16bpp
+(may be 24bpp also ???) X11 server color depth (OpenGL colortable
+mapping is buggy).</LI>
+<LI>ATI R128 + DRI OpenGL driver (XFree86 4.1.0) with command line
+options "-noglext78 -noglaa" or "-bpp 16 -noglaa", where the latter options
+are a bit slower (about 5 fps). </LI>
+<LI>LinuxPPC - Powerbook-Firewire + ATI R128: see above!
+</LI>
+</UL>
+</P>
+<P>All of the above drivers work with the option &quot;-bpp 16&quot;
+and/or &quot;-noglext78&quot;, the latter of which is very slow,
+of course! So it looks like an OpenGL implementation bug is causing
+these driver/hardware combinations to only work with these command
+line options. The bug may lie within these OpenGL functions:</P>
+
+<P>
+<UL>
+<LI>glColorTableEXT </LI>
+<LI>glColorSubTableEXT
+</LI>
+</UL>
+</P>
+<P>Currently fast and funny driver/hardware combinations are:</P>
+
+<P>
+<UL>
+<LI>NVIDIA GeForce + NVIDIA OpenGL driver + XFree86 4.0.2; I have
+tested the GeForce256 (AGP) hardware. </LI>
+<LI>Vodoo + DRI OpenGL driver (XFree86 4.0.2); I have tested the
+Vodoo3 hardware.
+</LI>
+</UL>
+</P>
+<P>Q: When I run xmame.xgl, everything is messed up.</P>
+
+<P>A: Read the above experiences ... and try</P>
+
+<P>
+<UL>
+<LI>switching your X server's bpp value, e.g. switch from 32bpp or
+24bpp to 16bpp; </LI>
+<LI>the command line option &quot;-bpp 16&quot;;</LI>
+<LI>the command line option &quot;-noglaa&quot;;</LI>
+<LI>the command line option &quot;-noglext&quot;.
+</LI>
+</UL>
+</P>
+<H3>Present Limitations/Bugs</H3>
+
+<P>
+<UL>
+<LI>No clipping of vector games (most noticeable in cabinet mode).</LI>
+<LI>No preservation of game aspect ratio in cabinet mode.
+</LI>
+</UL>
+</P>
+<H3>Future Work</H3>
+
+<P>
+<UL>
+<LI>Fixing existing bugs .. are there any ? Or are there some unknown
+features only ;-) ? </LI>
+<LI>Optimize the drawing code to update only the changed portions
+of the game bitmap. Optimizing the dirty code ..
+</LI>
+</UL>
+</P>
+<H3>License</H3>
+
+<P>The GLmame code is based upon Mike Oliphant's GLmame code version
+0.6. </P>
+
+<P>The GLMame code is Copyright 1998 by Mike Oliphant. It may be
+used and distributed under the terms of the MAME license. </P>
+
+<P>Since GLmame version 0.7, the code has been changed and improved
+heavily by Sven Goethel --- no license change, of course!</P>
+
+<H3>Version History</H3>
+
+<P>v0.83 -- March 29th, 2001 ---------------------------</P>
+
+<P>
+<UL>
+<LI>Changed the code heavily to improve compatibility and speed.
+The new code is a re-merge of the GLMame32 code, which is a branch
+of Mike Oliphant's GLmame code version 0.6. </LI>
+<LI>For a detailed list, please consult the file changes.opengl within
+the distribution's documentation directory! You can also view the
+current changes.opengl here: 
+<A HREF="http://www.jausoft.com/glmame.html">http://www.jausoft.com/glmame.html</A>
+</LI>
+</UL>
+</P>
+<P>v0.6 -- December 14th, 1998 ---------------------------</P>
+
+<P>
+<UL>
+<LI>added support for systems that do not support paletted textures
+(SGI and solaris OpenGL implementations, for example)</LI>
+<LI>merged source with xmame b8.1
+</LI>
+</UL>
+</P>
+<P>v0.5 -- October 30th, 1998 --------------------------</P>
+
+<P>
+<UL>
+<LI>fixed a bug with texturing being left on in bad places</LI>
+<LI>added 3Dfx gamma adjustment
+</LI>
+</UL>
+</P>
+<P>v0.4 -- October 21st, 1998 --------------------------</P>
+
+<P>
+<UL>
+<LI>updated to work with xmame v0.34b5.2
+</LI>
+</UL>
+</P>
+<P>v0.3 -- October 12th, 1998 --------------------------</P>
+
+<P>
+<UL>
+<LI>fixed verticle screen centering in fullscreen mode</LI>
+<LI>moved cabinet and camera panning information into a user-editable
+configuration file</LI>
+<LI>added 'trans' cabinet model o added double buffer, view type,
+and cabinet selection command-line options
+</LI>
+</UL>
+</P>
+<P>v0.2 -- October 6th, 1998 -------------------------</P>
+
+<P>
+<UL>
+<LI>adding missing 'cab' directory
+</LI>
+</UL>
+</P>
+<P>v0.1 -- October 5th, 1998 -------------------------</P>
+
+<P>
+<UL>
+<LI>first public release
+</LI>
+</UL>
+</P>
+<H3>Authors</H3>
+
+<P>Since GLmame version 0.7: Sven Goethel 
+<A HREF="mailto:sgoethel@jausoft.com">(sgoethel@jausoft.com)</A> 
+<A HREF="http://www.jausoft.com/glmame.html">http://www.jausoft.com/glmame.html</A></P>
+
+<P>Till GLmame version 0.6: Mike Oliphant <CODE>
+<A HREF="mailto:oliphant@ling.ed.ac.uk">(oliphant@ling.ed.ac.uk)</A></CODE> 
+<A HREF="http://glmame.linuxgames.com">http://glmame.linuxgames.com</A></P>
+
+<HR>
+<A HREF="xmame-doc-5.html">Next</A>
+<A HREF="xmame-doc-3.html">Previous</A>
+<A HREF="xmame-doc.html#toc4">Contents</A>
+</BODY>
+</HTML>
diff --git a/src/unix/doc/xmame-doc-5.html b/src/unix/doc/xmame-doc-5.html
new file mode 100644
index 0000000..25e6403
--- /dev/null
+++ b/src/unix/doc/xmame-doc-5.html
@@ -0,0 +1,314 @@
+<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
+<HTML>
+<HEAD>
+ <META NAME="GENERATOR" CONTENT="LinuxDoc-Tools 0.9.11">
+ <TITLE>XMAME/XMESS DOCUMENTATION: Contact Information and Credits</TITLE>
+ <LINK HREF="xmame-doc-6.html" REL=next>
+ <LINK HREF="xmame-doc-4.html" REL=previous>
+ <LINK HREF="xmame-doc.html#toc5" REL=contents>
+<link rel="stylesheet" href="xmame.css" type="text/css" >
+</HEAD>
+<BODY BACKGROUND="img/xmame.jpg" BGPROPERTIES="fixed" >
+<A HREF="xmame-doc-6.html">Next</A>
+<A HREF="xmame-doc-4.html">Previous</A>
+<A HREF="xmame-doc.html#toc5">Contents</A>
+<HR>
+<H2><A NAME="s5">5.</A> <A HREF="xmame-doc.html#toc5">Contact Information and Credits</A></H2>
+
+<H2><A NAME="Mail"></A> <A NAME="ss5.1">5.1</A> <A HREF="xmame-doc.html#toc5.1">Mail </A>
+</H2>
+
+<P>There is an official xmame/xmess mailing list. All operations
+related to this list are performed via email to <CODE>
+<A HREF="mailto:Xmame-request@toybox.twisted.org.uk">Xmame-request@toybox.twisted.org.uk</A></CODE></P>
+
+<P>
+<UL>
+<LI>To subscribe, send mail to: 
+<A HREF="mailto:Xmame-request@toybox.twisted.org.uk">Xmame-request@toybox.twisted.org.uk</A> with the keyword &quot;subscribe&quot;
+in the body. </LI>
+<LI>To unsubscribe, send a mail to: 
+<A HREF="mailto:Xmame-request@toybox.twisted.org.uk">Xmame-request@toybox.twisted.org.uk</A> with the keyword &quot;unsubscribe&quot;
+in the body.</LI>
+<LI>To change your subscription, get a password reminder, etc., go
+to 
+<A HREF="http://toybox.twisted.org.uk/mailman/listinfo/xmame">http://toybox.twisted.org.uk/mailman/listinfo/xmame</A>.</LI>
+<LI>To send mail to the list, use: 
+<A HREF="mailto:xmame@toybox.twisted.org.uk">xmame@toybox.twisted.org.uk</A> </LI>
+<LI>To ask specific questions about the xmame mailing list, send
+mail to: 
+<A HREF="mailto:Xmame-request@toybox.twisted.org.uk">Xmame-request@toybox.twisted.org.uk</A>
+</LI>
+</UL>
+</P>
+<P>If you're just curious, and only want to take a look at the mailing
+list without subscribing, you can use the web-based archive at 
+<A HREF="http://www.mail-archive.com/xmame%40toybox.twisted.org.uk/">http://www.mail-archive.com/xmame%40toybox.twisted.org.uk/</A> or
+<A HREF="http://toybox.twisted.org.uk/pipermail/xmame/">http://toybox.twisted.org.uk/pipermail/xmame/</A>. (The latter was activated on 5 January 2002.) To read even older
+messages, see 
+<A HREF="http://www.mail-archive.com/xmame@locutus.csres.utexas.edu">http://www.mail-archive.com/xmame@locutus.csres.utexas.edu</A>.</P>
+
+<P>To ask UNIX-specific xmame/xmess questions, you could send mail
+to: 
+<A HREF="mailto:gold@aros.net">Lawrence's folder</A>, but you're better off sending mail to the list. </P>
+
+<P>To ask general questions about MAME, send mail to: Mirko (Mix)
+Buffoni
+<A HREF="mailto:mix@lim.dsi.unimi.it">Mirko (Mix) Buffoni</A> </P>
+
+<P>Also see (and post) articles on USENET group 
+<A HREF="news:comp.emulators.misc">comp.emulators.misc</A>comp.emulators.misc&nbsp;</P>
+
+<P>with a proper keyword in the body.</P>
+
+<P>Other proper keywords currently recognized as commands by 
+<A HREF="mailto:Xmame-request@toybox.twisted.org.uk">Xmame-request@toybox.twisted.org.uk</A> are:</P>
+
+<P>
+<PRE>
+    who             - see everyone who is on the list
+    info            - view the introductory information for this list
+    help            - list all recognized commands
+    
+</PRE>
+</P>
+<P>Xmame Mailing List </P>
+
+<P>
+<UL>
+<LI>The xmame mailing list is intended to be a technical forum for
+xmame developers, that is,
+<UL>
+<LI>To exchange ideas for producing a better xmame.</LI>
+<LI>To share patches and bug notifications.</LI>
+<LI>To study new design strategies.</LI>
+<LI>To expose problems and learn know-how.
+</LI>
+</UL>
+</LI>
+<LI>The Xmame mailing list <B>is not</B> a forum about playing games (but
+everyone on the list plays...); so please
+<UL>
+<LI><B>Don't use the list to ask about ROMs.</B></LI>
+<LI><B>Don't ask about non-UNIX ports of MAME, just about MAME and xmame.</B></LI>
+<LI><B>Don't ask about implementing a game. Just search the docs and
+contribute yourself (you'll enjoy twice: programming and playing...).</B></LI>
+<LI><B>Don't show your last high score in xxx game (we are interested
+in programming, and then playing, in this order).</B>
+</LI>
+</UL>
+</LI>
+<LI><B>Copyright notice: NEVER, I repeat NEVER send ROM images to the
+list.</B> (But you can tell us where to retrieve them... ;-) )</LI>
+<LI>At this moment, the xmame list is <B>unmoderated</B>; that is, everyone
+subscribed will receive everything sent to the list. We foresee a
+need to change this policy since the list starts to suffer from spam
+:-(.
+</LI>
+</UL>
+</P>
+<P>If you want to send a personal mail to the xmame/xmess coordinator,
+send to the address below. Everyone who contributes to xmame/xmess
+should subscribe to the xmame/xmess mailing list.</P>
+
+<P>
+<UL>
+<LI>Mailing list:<CODE>
+<A HREF="mailto:Xmame-request@toybox.twisted.org.uk">Xmame-request@toybox.twisted.org.uk</A></CODE></LI>
+<LI>Xmame/xmess coordinator: <CODE>
+<A HREF="mailto:gold@aros.net">gold@aros.net</A></CODE>
+</LI>
+</UL>
+</P>
+<P>That's all. Enjoy xmame!</P>
+
+<H2><A NAME="ss5.2">5.2</A> <A HREF="xmame-doc.html#toc5.2">Bugzilla</A>
+</H2>
+
+<P>In addition to/instead of posting bugs to the mailing list, you
+can report them to the MESS Bugzilla database at 
+<A HREF="http://bugzilla.mess.org/">http://bugzilla.mess.org/</A>, under the "XMAME/XMESS"
+category.</P>
+
+<H2><A NAME="ss5.3">5.3</A> <A HREF="xmame-doc.html#toc5.3">Credits</A>
+</H2>
+
+<P>Lots and lots and lots of thanks to everyone for their great
+help on the xmame project. I would like to thank the following people
+and of course anyone I've forgotten.</P>
+
+<P>Thank you all,</P>
+
+<P>Hans</P>
+
+<P>(Addendum: I'd like to send a big thanks to Hans for his fantastic
+work as longtime xmame/xmess maintainer, and also to those on the
+mailing list who have been most helpful during my transition to official
+maintainer. --Lawrence Gold)</P>
+
+<P>
+<OL>
+<LI>Fathers of the MAME-creature (main version)
+<UL>
+<LI>Nicola Salmoria</LI>
+<LI>Allard van der Bas</LI>
+<LI>Mirko (Mix) Buffoni (General Mantainer during Nicola's national
+service)
+</LI>
+</UL>
+</LI>
+<LI>Fathers of MESS
+<UL>
+<LI>Brad Oliver </LI>
+<LI>Richard Bannister</LI>
+<LI>Ben Bruscella</LI>
+<LI>Nathan Woods (current coordinator)
+</LI>
+</UL>
+</LI>
+<LI>Original UNIX/X11 port
+<UL>
+<LI>Allard van der Bas</LI>
+<LI>Dick the Ridder</LI>
+<LI>Juan Antonio Martinez
+</LI>
+</UL>
+</LI>
+<LI>Semi-retired Unix maintainer extraordinaire
+<UL>
+<LI>Hans de Goede
+</LI>
+</UL>
+</LI>
+<LI>Alpha-specific issues
+<UL>
+<LI>Christian Groessler
+</LI>
+</UL>
+</LI>
+<LI>Sun-specific issues
+<UL>
+<LI>Keith Hargrove</LI>
+<LI>Mathis Rosenhau
+</LI>
+</UL>
+</LI>
+<LI>Irix-specific issues
+<UL>
+<LI>Tristram Scott
+</LI>
+</UL>
+</LI>
+<LI>QNX-specific issues
+<UL>
+<LI>Travis Coady
+</LI>
+</UL>
+</LI>
+<LI>GGI maintainance
+<UL>
+<LI>Gabriele Boccone (original port)</LI>
+<LI>Christian Groessler (current maintainer)
+</LI>
+</UL>
+</LI>
+<LI>OpenGL code &amp; maintainance
+<UL>
+<LI>Mike Oliphant (original creator)</LI>
+<LI>Sven Goethel (from GLmame 0.7 to the present)
+</LI>
+</UL>
+</LI>
+<LI>Network code
+<UL>
+<LI>Eric Totel
+</LI>
+</UL>
+</LI>
+<LI>Perl scripts for automation of some porting issues
+<UL>
+<LI>Bill Adams
+</LI>
+</UL>
+</LI>
+<LI>Xmame RPMs
+<UL>
+<LI>Jeremy Hansen
+</LI>
+</UL>
+</LI>
+<LI>Mailing list maintainer
+<UL>
+<LI>Chris McCraw (retired)</LI>
+<LI>Pete French
+</LI>
+</UL>
+</LI>
+<LI>Bits and pieces
+<UL>
+<LI>Christian Groessler</LI>
+<LI>Torsten Paul</LI>
+<LI>Jack Patton</LI>
+<LI>David Black
+</LI>
+</UL>
+</LI>
+<LI>AIX Sound code
+<UL>
+<LI>Chris Sharpp
+</LI>
+</UL>
+</LI>
+<LI>IRIX Sound Code
+<UL>
+<LI><CODE>
+<A HREF="mailto:entropy@zippy.bernstein.com">entropy@zippy.bernstein.com</A></CODE> (original code)</LI>
+<LI>Brandon Corey (current code)
+</LI>
+</UL>
+</LI>
+<LI>PS2 Linux support
+<UL>
+<LI>Joan Sarah Touzet
+</LI>
+</UL>
+</LI>
+<LI>Xv support
+<UL>
+<LI>Alastair Robinson
+</LI>
+</UL>
+</LI>
+<LI>NetMAME Support
+<UL>
+<LI>Steve Freeland
+</LI>
+</UL>
+</LI>
+<LI>German readme
+<UL>
+<LI>Robert Hamberger
+</LI>
+</UL>
+</LI>
+<LI>Documentation (SGML, HTML, MAN)
+<UL>
+<LI>Rene Herrmann
+</LI>
+</UL>
+</LI>
+<LI>Bugzilla bug database
+<UL>
+<LI>Sean Young
+</LI>
+</UL>
+
+</LI>
+</OL>
+</P>
+<HR>
+<A HREF="xmame-doc-6.html">Next</A>
+<A HREF="xmame-doc-4.html">Previous</A>
+<A HREF="xmame-doc.html#toc5">Contents</A>
+</BODY>
+</HTML>
diff --git a/src/unix/doc/xmame-doc-6.html b/src/unix/doc/xmame-doc-6.html
new file mode 100644
index 0000000..f20d214
--- /dev/null
+++ b/src/unix/doc/xmame-doc-6.html
@@ -0,0 +1,42 @@
+<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
+<HTML>
+<HEAD>
+ <META NAME="GENERATOR" CONTENT="LinuxDoc-Tools 0.9.11">
+ <TITLE>XMAME/XMESS DOCUMENTATION: Legal Issues and Copyrights Concerning MAME/MESS</TITLE>
+ <LINK HREF="xmame-doc-7.html" REL=next>
+ <LINK HREF="xmame-doc-5.html" REL=previous>
+ <LINK HREF="xmame-doc.html#toc6" REL=contents>
+<link rel="stylesheet" href="xmame.css" type="text/css" >
+</HEAD>
+<BODY BACKGROUND="img/xmame.jpg" BGPROPERTIES="fixed" >
+<A HREF="xmame-doc-7.html">Next</A>
+<A HREF="xmame-doc-5.html">Previous</A>
+<A HREF="xmame-doc.html#toc6">Contents</A>
+<HR>
+<H2><A NAME="s6">6.</A> <A HREF="xmame-doc.html#toc6">Legal Issues and Copyrights Concerning MAME/MESS</A></H2>
+
+<P>
+<UL>
+<LI><B>Please read the MAME/MESS readme-files first!</B></LI>
+<LI>Xmame/xmess should be distributed under terms of the license
+in 
+<A HREF="readme.mame">readme.mame</A></LI>
+<LI>And if you are interested in mess, take a look in 
+<A HREF="readme.mess">readme.mess</A></LI>
+<LI>The main issue involves ROM images. ROM images are protected
+under the copyrights of their authors, and CANNOT be distributed
+in the same package as xmame/xmess. Download any ROM images at your
+own risk and responsibility.</LI>
+<LI>XInputExtensions-based Joystick support. Source code is entirely
+pure hack work. No sample code, no info at all was found (only library
+reference manual) and is copyrighted by me (Juan Antonio Martinez).
+Use it under terms of GNU General Public License.
+</LI>
+</UL>
+</P>
+<HR>
+<A HREF="xmame-doc-7.html">Next</A>
+<A HREF="xmame-doc-5.html">Previous</A>
+<A HREF="xmame-doc.html#toc6">Contents</A>
+</BODY>
+</HTML>
diff --git a/src/unix/doc/xmame-doc-7.html b/src/unix/doc/xmame-doc-7.html
new file mode 100644
index 0000000..9f32cde
--- /dev/null
+++ b/src/unix/doc/xmame-doc-7.html
@@ -0,0 +1,151 @@
+<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
+<HTML>
+<HEAD>
+ <META NAME="GENERATOR" CONTENT="LinuxDoc-Tools 0.9.11">
+ <TITLE>XMAME/XMESS DOCUMENTATION: Some Links</TITLE>
+ <LINK HREF="xmame-doc-8.html" REL=next>
+ <LINK HREF="xmame-doc-6.html" REL=previous>
+ <LINK HREF="xmame-doc.html#toc7" REL=contents>
+<link rel="stylesheet" href="xmame.css" type="text/css" >
+</HEAD>
+<BODY BACKGROUND="img/xmame.jpg" BGPROPERTIES="fixed" >
+<A HREF="xmame-doc-8.html">Next</A>
+<A HREF="xmame-doc-6.html">Previous</A>
+<A HREF="xmame-doc.html#toc7">Contents</A>
+<HR>
+<H2><A NAME="s7">7.</A> <A HREF="xmame-doc.html#toc7">Some Links</A></H2>
+
+<H2><A NAME="ss7.1">7.1</A> <A HREF="xmame-doc.html#toc7.1">Unix sources and docs</A>
+</H2>
+
+<P>
+<UL>
+<LI>The xmame/xmess sources
+<P>
+<A HREF="download/xmame-0.74.1.tar.bz2">xmame/xmess-0.74.1 sources</A></P>
+
+</LI>
+<LI>xmame/xmess FAQ &amp; Installation Guide:
+<P>
+<A HREF="download/xmame-doc.pdf">xmame-doc (pdf format)</A></P>
+
+</LI>
+<LI>xmame/xmess known bug list:
+<P>
+<A HREF="open_issues.html">open issues</A></P>
+
+
+</LI>
+</UL>
+</P>
+<H2><A NAME="ss7.2">7.2</A> <A HREF="xmame-doc.html#toc7.2">Unix binaries</A>
+</H2>
+
+<P>
+<UL>
+<LI>
+<A HREF="http://www.forte-intl.com/~ronald/xmame/">xmame RPMs</A></LI>
+<LI>
+<A HREF="http://www.beimborn.com/cps2/linux/rpms">xmame+CPS2 RPMs</A></LI>
+<LI>
+<A HREF="http://come.to/georgie">Source and binary for Solaris UltraSPARC</A></LI>
+<LI>
+<A HREF="http://www.kwyxz.org/linux/xmame/index.html">AMD-optimized builds for various targets</A>
+</LI>
+</UL>
+</P>
+<H2><A NAME="ss7.3">7.3</A> <A HREF="xmame-doc.html#toc7.3">Xmame/xmess download mirrors</A>
+</H2>
+
+<P>
+<UL>
+<LI>
+<A HREF="ftp://cps2:cps2@wingnut.beimborn.com">ftp://cps2:cps2@wingnut.beimborn.com</A>(US)</LI>
+<LI>
+<A HREF="http://www.mame.dk">http://www.mame.dk</A>(Denmark)</LI>
+<LI>
+<A HREF="ftp://ftp.kaupp.cx/pub/xmame">ftp://ftp.kaupp.cx/pub/xmame</A>(US)
+</LI>
+</UL>
+</P>
+<H2><A NAME="ss7.4">7.4</A> <A HREF="xmame-doc.html#toc7.4">(X)Mame front-ends</A>
+</H2>
+
+<P>
+<UL>
+<LI>
+<A HREF="http://www.mame.net/frontend.html">The official mame frontend page </A></LI>
+<LI>
+<A HREF="http://digilander.libero.it/stefanobolli/index.html">Romeo</A>, a Java front-end</LI>
+<LI>
+<A HREF="http://www.mameworld.net/mamecat/">Mamecat</A></LI>
+<LI>
+<A HREF="http://gxmame.sourceforge.net/">GXMame</A>, a GTK front-end striving for MAME32 compatibility</LI>
+<LI>
+<A HREF="http://gnomame.sourceforge.net/">GnoMame</A>, a GNOME front-end</LI>
+<LI>
+<A HREF="ftp://ftp.sad.it/pub/kde/local/">Kmamerun</A></LI>
+<LI>
+<A HREF="http://user.cs.tu-berlin.de/~gator/mame/">GrokMame</A></LI>
+<LI>
+<A HREF="http://www.geocities.com/SiliconValley/Mouse/1570/">StartXmame</A></LI>
+<LI>
+<A HREF="http://grustibus.sourceforge.net">gRustibus</A>, a GNOME front-end </LI>
+<LI>
+<A HREF="http://it-mame.sourceforge.net/index2.html">it-mame</A></LI>
+<LI>
+<A HREF="http://www.sourceforge.net/projects/iqf/">IQF</A></LI>
+<LI>
+<A HREF="http://lanzamame.mameworld.net/">LANZAMAME</A></LI>
+<LI>
+<A HREF="http://ant.eelinux.com/ptkmame/">ptkmame</A></LI>
+<LI>
+<A HREF="http://kemulator.sourceforge.net/">Kemulator</A>, a KDE front-end with MESS and Stella support</LI>
+<LI>
+<A HREF="http://www.foxbox.org/adam/code/flynn/index.html">Flynn</A>, a front-end primarily for converted arcade cabinets</LI>
+<LI>
+<A HREF="www.xs4all.nl/~phulshof/mame.html">MAMEd</A>, a new front-end for arcade cabinets</LI>
+<LI>
+<A HREF="http://www.swentelomania.be/swentel/module.php?boxcontent=35=40">Playmame &amp; Playmess</A> (perl-based menu makers)</LI>
+<LI>
+<A HREF="http://www.voicenet.com/~jceklosk/">jMame</A>, a Java front-end (requires JDE 1.4.0)</LI>
+<LI>
+<A HREF="http://yeeking.net/cxmame/">CXmame</A>, a simple console-based front-end</LI>
+<LI>
+<A HREF="http://designs.stormheart.com/kmameleon/">KMameleon</A>, a KDE front-end</LI>
+<LI>
+<A HREF="http://tkmame.retrogames.com/icons">Mamu_'s Icons for X</A>
+</LI>
+</UL>
+</P>
+<H2><A NAME="ss7.5">7.5</A> <A HREF="xmame-doc.html#toc7.5">Some other links</A>
+</H2>
+
+<P>
+<UL>
+<LI>The official M.A.M.E home is at 
+<A HREF="http://www.mame.net">http://www.mame.net</A></LI>
+<LI>The official mess site is 
+<A HREF="http://www.mess.org">http://www.mess.org</A></LI>
+<LI>Some other emulation sites are 
+<A HREF="http://www.vg-network.com">http://www.vg-network.com</A> and 
+<A HREF="http://www.retrogames.com">http://www.retrogames.com</A></LI>
+<LI>The very best ROM site on this planet is at 
+<A HREF="http://www.mame.dk/">http://www.mame.dk/</A></LI>
+<LI>A couple of sites with CPS2 and other patches 
+<A HREF="http://www.beimborn.com/cps2/linux/">Dan Beimborn's Linux CPS2Mame page</A> and 
+<A HREF="http://www.win.tue.nl/~stijn/xmame/">Stijn Hoop's xmame patches </A></LI>
+<LI><B>MAME</B> <B>A</B>ction <B>R</B>eplay <B>P</B>age for those who want to have a  look at
+other monitors at 
+<A HREF="http://marp.retrogames.com/">http://marp.retrogames.com/</A></LI>
+<LI>And, of course, don't forget our project homepage at <B>
+<A HREF="http://x.mame.net/">http://x.mame.net/</A></B>
+</LI>
+</UL>
+</P>
+<HR>
+<A HREF="xmame-doc-8.html">Next</A>
+<A HREF="xmame-doc-6.html">Previous</A>
+<A HREF="xmame-doc.html#toc7">Contents</A>
+</BODY>
+</HTML>
diff --git a/src/unix/doc/xmame-doc-8.html b/src/unix/doc/xmame-doc-8.html
new file mode 100644
index 0000000..4006ccb
--- /dev/null
+++ b/src/unix/doc/xmame-doc-8.html
@@ -0,0 +1,56 @@
+<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
+<HTML>
+<HEAD>
+ <META NAME="GENERATOR" CONTENT="LinuxDoc-Tools 0.9.11">
+ <TITLE>XMAME/XMESS DOCUMENTATION: ChangeLogs</TITLE>
+ <LINK HREF="xmame-doc-7.html" REL=previous>
+ <LINK HREF="xmame-doc.html#toc8" REL=contents>
+<link rel="stylesheet" href="xmame.css" type="text/css" >
+</HEAD>
+<BODY BACKGROUND="img/xmame.jpg" BGPROPERTIES="fixed" >
+Next
+<A HREF="xmame-doc-7.html">Previous</A>
+<A HREF="xmame-doc.html#toc8">Contents</A>
+<HR>
+<H2><A NAME="ChangeLogs"></A> <A NAME="s8">8.</A> <A HREF="xmame-doc.html#toc8">ChangeLogs</A></H2>
+
+<H2><A NAME="ss8.1">8.1</A> <A HREF="xmame-doc.html#toc8.1">The MAME/MESS ChangeLogs</A>
+</H2>
+
+<P>These are the changelogs of the offical MAME and MESS release,
+the core of xmame/xmess.</P>
+
+<P>
+<UL>
+<LI>
+<A HREF="changes-mame.html">The MAME changelog (changes.mame)</A></LI>
+<LI>
+<A HREF="changes.mess">The MESS changelog (changes.mess)</A>
+</LI>
+</UL>
+</P>
+<H2><A NAME="ss8.2">8.2</A> <A HREF="xmame-doc.html#toc8.2">The Unix ChangeLog</A>
+</H2>
+
+<P>And now here is the HISTORY of the xmame project (of course that's
+why you are here :;-)) ... Ren</P>
+
+<P>
+<UL>
+<LI>
+<A HREF="changes-unix.html">The Unix port changelog (changes.unix)</A></LI>
+<LI>The OpenGL display driver changelog: 
+<A HREF="changes.opengl">changes.opengl</A> or 
+<A HREF="http://www.jausoft.com/glmame.html">http://www.jausoft.com/glmame.html</A>
+</LI>
+</UL>
+</P>
+
+
+
+<HR>
+Next
+<A HREF="xmame-doc-7.html">Previous</A>
+<A HREF="xmame-doc.html#toc8">Contents</A>
+</BODY>
+</HTML>
diff --git a/src/unix/doc/xmame-doc.html b/src/unix/doc/xmame-doc.html
new file mode 100644
index 0000000..210ad33
--- /dev/null
+++ b/src/unix/doc/xmame-doc.html
@@ -0,0 +1,125 @@
+<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
+<HTML>
+<HEAD>
+ <META NAME="GENERATOR" CONTENT="LinuxDoc-Tools 0.9.11">
+ <TITLE>XMAME/XMESS DOCUMENTATION</TITLE>
+ <LINK HREF="xmame-doc-1.html" REL=next>
+
+
+<link rel="stylesheet" href="xmame.css" type="text/css" >
+</HEAD>
+<BODY BACKGROUND="img/xmame.jpg" BGPROPERTIES="fixed" >
+<A HREF="xmame-doc-1.html">Next</A>
+Previous
+Contents
+<HR>
+<H1>XMAME/XMESS DOCUMENTATION</H1>
+
+<H2>Juan Antonio Martinez <CODE>
+<A HREF="mailto:jantonio@dit.upm.es">jantonio@dit.upm.es</A></CODE> and Hans de Goede <CODE>
+<A HREF="mailto:hans@highrise.nl">hans@highrise.nl</A></CODE> and Rene' Herrmann
+ (4 doc/sgml) <CODE>
+<A HREF="mailto:rene.herrmann@berlin.de">rene.herrmann@berlin.de</A></CODE> and Lawrence Gold (minor editing) <CODE>
+<A HREF="mailto:gold@aros.net">gold@aros.net</A> and David Heremans
+(minor editing)</CODE></H2>v2.1.33, 15 September 2003
+<HR>
+<EM>xmame/xmess documentation with an installation guide, the FAQ
+ (frequently asked questions), hints, tips and tricks, the changes
+ to the code, and much more!</EM>
+<HR>
+<P>
+<H2><A NAME="toc1">1.</A> <A HREF="xmame-doc-1.html">Introduction</A></H2>
+
+<UL>
+<LI><A NAME="toc1.1">1.1</A> <A HREF="xmame-doc-1.html#ss1.1">Welcome to XMAME</A>
+<LI><A NAME="toc1.2">1.2</A> <A HREF="xmame-doc-1.html#ss1.2">Keep everything up-to-date!</A>
+<LI><A NAME="toc1.3">1.3</A> <A HREF="xmame-doc-1.html#ss1.3">Pending Jobs - or TODO</A>
+</UL>
+<P>
+<H2><A NAME="toc2">2.</A> <A HREF="xmame-doc-2.html">Compiling, Setting Up and Starting Xmame/Xmess</A></H2>
+
+<UL>
+<LI><A NAME="toc2.1">2.1</A> <A HREF="xmame-doc-2.html#ss2.1">Requirements </A>
+<LI><A NAME="toc2.2">2.2</A> <A HREF="xmame-doc-2.html#ss2.2">Follow these steps to compile xmame/xmess</A>
+<LI><A NAME="toc2.3">2.3</A> <A HREF="xmame-doc-2.html#ss2.3">If you have problems compiling, installing and starting xmame/xmess...</A>
+<LI><A NAME="toc2.4">2.4</A> <A HREF="xmame-doc-2.html#ss2.4">Compile Notes for Specific Operating Systems </A>
+</UL>
+<P>
+<H2><A NAME="toc3">3.</A> <A HREF="xmame-doc-3.html">Xmame Frequently Asked Questions</A></H2>
+
+<UL>
+<LI><A NAME="toc3.1">3.1</A> <A HREF="xmame-doc-3.html#ss3.1">What is mame?</A>
+<LI><A NAME="toc3.2">3.2</A> <A HREF="xmame-doc-3.html#ss3.2">What is mess?</A>
+<LI><A NAME="toc3.3">3.3</A> <A HREF="xmame-doc-3.html#ss3.3">What is xmame/xmess?</A>
+<LI><A NAME="toc3.4">3.4</A> <A HREF="xmame-doc-3.html#ss3.4">What are the differences between mame/mess and xmame/xmess?</A>
+<LI><A NAME="toc3.5">3.5</A> <A HREF="xmame-doc-3.html#ss3.5">What hardware and operating systems are supported? </A>
+<LI><A NAME="toc3.6">3.6</A> <A HREF="xmame-doc-3.html#ss3.6">My system is supported but xmame/xmess gives me errors and fails.</A>
+<LI><A NAME="toc3.7">3.7</A> <A HREF="xmame-doc-3.html#ss3.7">What is the role of the xmamerc/xmessrc file?</A>
+<LI><A NAME="toc3.8">3.8</A> <A HREF="xmame-doc-3.html#ss3.8">What is the syntax of the xmamerc/xmessrc file.</A>
+<LI><A NAME="toc3.9">3.9</A> <A HREF="xmame-doc-3.html#ss3.9">Where do roms, images, samples, highscores, configfiles, etc</A>
+<LI><A NAME="toc3.10">3.10</A> <A HREF="xmame-doc-3.html#ss3.10">How do I start xmess/xmame ?</A>
+<LI><A NAME="toc3.11">3.11</A> <A HREF="xmame-doc-3.html#ss3.11">What are the command line parameters for xmame/xmess?</A>
+<LI><A NAME="toc3.12">3.12</A> <A HREF="xmame-doc-3.html#ss3.12">What keys does xmame/xmess use?</A>
+<LI><A NAME="toc3.13">3.13</A> <A HREF="xmame-doc-3.html#ss3.13">Why doesn't a game have sound?</A>
+<LI><A NAME="toc3.14">3.14</A> <A HREF="xmame-doc-3.html#ss3.14">My sound seems lagged. / My sound Clicks. / What does -bufsize</A>
+<LI><A NAME="toc3.15">3.15</A> <A HREF="xmame-doc-3.html#ss3.15">Why doesn't a game work? </A>
+<LI><A NAME="toc3.16">3.16</A> <A HREF="xmame-doc-3.html#ss3.16">What are PROMs? </A>
+<LI><A NAME="toc3.17">3.17</A> <A HREF="xmame-doc-3.html#ss3.17">Why is xmame/xmess slow?</A>
+<LI><A NAME="toc3.18">3.18</A> <A HREF="xmame-doc-3.html#ss3.18">I've got a dual processor machine. What can I do to take full</A>
+<LI><A NAME="toc3.19">3.19</A> <A HREF="xmame-doc-3.html#ss3.19">Why doesn't my joystick handle diagonal movement correctly on</A>
+<LI><A NAME="toc3.20">3.20</A> <A HREF="xmame-doc-3.html#ss3.20">How do I enable XinputExtensions X11 based joystick in Xfree86?</A>
+<LI><A NAME="toc3.21">3.21</A> <A HREF="xmame-doc-3.html#ss3.21">How do I read a manual page?</A>
+<LI><A NAME="toc3.22">3.22</A> <A HREF="xmame-doc-3.html#ss3.22">Why do I get gz_open symbol not found while compiling? </A>
+<LI><A NAME="toc3.23">3.23</A> <A HREF="xmame-doc-3.html#ss3.23">Why do I get zlib.h not found? </A>
+<LI><A NAME="toc3.24">3.24</A> <A HREF="xmame-doc-3.html#ss3.24">When I run xmame.x11, nothing happens---no window pops up or</A>
+<LI><A NAME="toc3.25">3.25</A> <A HREF="xmame-doc-3.html#ss3.25">Can I run xmame fullscreen?</A>
+<LI><A NAME="toc3.26">3.26</A> <A HREF="xmame-doc-3.html#ss3.26">xmame.SDL / fullscreen has a large border around the game. </A>
+<LI><A NAME="toc3.27">3.27</A> <A HREF="xmame-doc-3.html#ss3.27">I only use some of the emulation parts (Neo Geo / CPS-2 /...).</A>
+<LI><A NAME="toc3.28">3.28</A> <A HREF="xmame-doc-3.html#ss3.28">Why does xmame freeze and lock up when I hit &lt;ESC&gt; to exit</A>
+<LI><A NAME="toc3.29">3.29</A> <A HREF="xmame-doc-3.html#ss3.29">Why does xmame report &quot;can't resolve host name '/dev/dsp'</A>
+<LI><A NAME="toc3.30">3.30</A> <A HREF="xmame-doc-3.html#ss3.30">Where can I get the latest version of xmame/xmess?</A>
+<LI><A NAME="toc3.31">3.31</A> <A HREF="xmame-doc-3.html#ss3.31">I upgraded xmame and now some games do not work anymore.</A>
+<LI><A NAME="toc3.32">3.32</A> <A HREF="xmame-doc-3.html#ss3.32">Where can I send fixes, bug reports, suggestions, or money?  :-)</A>
+<LI><A NAME="toc3.33">3.33</A> <A HREF="xmame-doc-3.html#ss3.33">What if my question is still not answered?</A>
+</UL>
+<P>
+<H2><A NAME="toc4">4.</A> <A HREF="xmame-doc-4.html">Display Subsystem-Specific Comments and Notes </A></H2>
+
+<UL>
+<LI><A NAME="toc4.1">4.1</A> <A HREF="xmame-doc-4.html#ss4.1">FXmame, a glide driver for xmame</A>
+<LI><A NAME="toc4.2">4.2</A> <A HREF="xmame-doc-4.html#ss4.2">GLmame, an OpenGL driver for xmame</A>
+</UL>
+<P>
+<H2><A NAME="toc5">5.</A> <A HREF="xmame-doc-5.html">Contact Information and Credits</A></H2>
+
+<UL>
+<LI><A NAME="toc5.1">5.1</A> <A HREF="xmame-doc-5.html#ss5.1">Mail </A>
+<LI><A NAME="toc5.2">5.2</A> <A HREF="xmame-doc-5.html#ss5.2">Bugzilla</A>
+<LI><A NAME="toc5.3">5.3</A> <A HREF="xmame-doc-5.html#ss5.3">Credits</A>
+</UL>
+<P>
+<H2><A NAME="toc6">6.</A> <A HREF="xmame-doc-6.html">Legal Issues and Copyrights Concerning MAME/MESS</A></H2>
+
+<P>
+<H2><A NAME="toc7">7.</A> <A HREF="xmame-doc-7.html">Some Links</A></H2>
+
+<UL>
+<LI><A NAME="toc7.1">7.1</A> <A HREF="xmame-doc-7.html#ss7.1">Unix sources and docs</A>
+<LI><A NAME="toc7.2">7.2</A> <A HREF="xmame-doc-7.html#ss7.2">Unix binaries</A>
+<LI><A NAME="toc7.3">7.3</A> <A HREF="xmame-doc-7.html#ss7.3">Xmame/xmess download mirrors</A>
+<LI><A NAME="toc7.4">7.4</A> <A HREF="xmame-doc-7.html#ss7.4">(X)Mame front-ends</A>
+<LI><A NAME="toc7.5">7.5</A> <A HREF="xmame-doc-7.html#ss7.5">Some other links</A>
+</UL>
+<P>
+<H2><A NAME="toc8">8.</A> <A HREF="xmame-doc-8.html">ChangeLogs</A></H2>
+
+<UL>
+<LI><A NAME="toc8.1">8.1</A> <A HREF="xmame-doc-8.html#ss8.1">The MAME/MESS ChangeLogs</A>
+<LI><A NAME="toc8.2">8.2</A> <A HREF="xmame-doc-8.html#ss8.2">The Unix ChangeLog</A>
+</UL>
+<HR>
+<A HREF="xmame-doc-1.html">Next</A>
+Previous
+Contents
+</BODY>
+</HTML>
diff --git a/src/unix/doc/xmame-doc.lyx b/src/unix/doc/xmame-doc.lyx
new file mode 100644
index 0000000..3ee81ad
--- /dev/null
+++ b/src/unix/doc/xmame-doc.lyx
@@ -0,0 +1,4847 @@
+#LyX 1.3 created this file. For more info see http://www.lyx.org/
+\lyxformat 221
+\textclass linuxdoc
+\language english
+\inputencoding default
+\fontscheme default
+\graphics default
+\paperfontsize default
+\spacing single 
+\papersize a4paper
+\paperpackage a4
+\use_geometry 0
+\use_amsmath 0
+\use_natbib 0
+\use_numerical_citations 0
+\paperorientation portrait
+\secnumdepth 3
+\tocdepth 3
+\paragraph_separation skip
+\defskip medskip
+\quotes_language english
+\quotes_times 2
+\papercolumns 1
+\papersides 1
+\paperpagestyle default
+
+\layout Title
+
+XMAME/XMESS DOCUMENTATION
+\layout Author
+
+Juan Antonio Martinez 
+\family typewriter 
+
+\begin_inset LatexCommand \url[jantonio@dit.upm.es]{mailto:jantonio@dit.upm.es}
+
+\end_inset 
+
+
+\family default 
+ and Hans de Goede 
+\family typewriter 
+
+\begin_inset LatexCommand \url[hans@highrise.nl]{mailto:hans@highrise.nl}
+
+\end_inset 
+
+
+\family default 
+ and Rene' Herrmann (4 doc/sgml) 
+\family typewriter 
+
+\begin_inset LatexCommand \url[rene.herrmann@berlin.de]{mailto:rene.herrmann@berlin.de}
+
+\end_inset 
+
+
+\family default 
+ and Lawrence Gold (minor editing) 
+\family typewriter 
+
+\begin_inset LatexCommand \url[gold@aros.net]{mailto:gold@aros.net}
+
+\end_inset 
+
+ and David Heremans (minor editing)
+\layout Date
+
+v2.1.33, 15 September 2003
+\layout Abstract
+
+xmame/xmess documentation with an installation guide, the FAQ (frequently
+ asked questions), hints, tips and tricks, the changes to the code, and
+ much more!
+\layout Standard
+
+
+\begin_inset LatexCommand \tableofcontents{}
+
+\end_inset 
+
+
+\layout Section
+
+Introduction
+\begin_inset LatexCommand \label{Introduction}
+
+\end_inset 
+
+
+\layout Subsection
+
+Welcome to XMAME
+\layout Standard
+
+This the the *nix port of the almost legendary mame.
+ Mame is an arcade machine emulator, started in 1997 by Nicola Salmoria.
+ It started out as a series of emulators for  individual games.
+ This series of emulators was combined into a  simgle multi-game emulator.
+ This is the current form of mame; no longer a one-man show, there are over
+ 100 contributors to the project.
+\layout Subsection
+
+Keep everything up-to-date!
+\layout Standard
+
+The most recent copy of this guide, the xmame-sources and many more can
+ be found on the xmame project homepage at 
+\begin_inset LatexCommand \url[http://x.mame.net/]{http://x.mame.net/}
+
+\end_inset 
+
+
+\layout Subsection
+
+Pending Jobs - or TODO
+\layout Standard
+
+If you think you can help with the todo list or you can make a  contribution
+ that you feel is interesting, please send mail to the xmame/xmess coordinator.
+ See 
+\begin_inset LatexCommand \ref[Mail]{Mail}
+
+\end_inset 
+
+ for contact information.
+\layout Itemize
+
+Optimise mouse warping.
+\layout Itemize
+
+Remove osd_input_init_post, add display ready flag.
+\layout Itemize
+
+Updating of fps is off (dirty marking problem) with vector games.
+\layout Itemize
+
+Update porting.txt.
+\layout Itemize
+
+Convert all remaining sound drivers to plugins.
+\layout Itemize
+
+Rewrite display/input code to be more modular, oo-ish, and usable as a separate
+ library.
+\layout Itemize
+
+Split 
+\family typewriter 
+-[no]scanline
+\family default 
+ option into emulated and real scanline options.
+\layout Itemize
+
+Add an option to specify which resolution to use, add clipping and panning
+ if it doesn't fit and use it anyway.
+\layout Itemize
+
+Use Pentium TSC for uclock where available.
+\layout Itemize
+
+Network:
+\begin_deeper 
+\layout Itemize
+
+Fix since the dos team broke it, find out if the dosnet team is still alive.
+\layout Itemize
+
+Add mouse/joystick support to network play
+\layout Itemize
+
+Try converting network support to tcp, currently we have no error correction.
+\layout Itemize
+
+Make network code more robust, version check, input settings check, etc.
+\end_deeper 
+\layout Itemize
+
+Check x11-joystick.
+ Rumor has it it's broken, but then again there's only one bug-report, so
+ it seems no one is using it.
+\layout Itemize
+
+fm soundhack for linux-i386.
+\layout Itemize
+
+Make which messages are emitted and when configurable (log-type's and log-level)
+, make fileio emit messages about which files it tries to open, to help
+ debug rom-loading problems, and walk through all messages xmame emits giving
+ them all a standard format like:
+\begin_deeper 
+\layout Verbatim
+
+OSD:        Info:    bla
+\newline 
+X11-window: Warning: bla
+\newline 
+Svgalib:    Error:   bla
+\end_deeper 
+\layout Itemize
+
+Add scancode 128-255 for non-PC keys like F13 -- F24, more keypad keys,
+ etc., update all display targets to use this.
+\layout Itemize
+
+Also see the text todo file, kept around to quickly enter stuff while hacking:
+ 
+\begin_inset LatexCommand \url[todo]{todo}
+
+\end_inset 
+
+.
+\layout Section
+
+Compiling, Setting Up and Starting Xmame/Xmess
+\layout Standard
+
+Note: This section is not a Unix tutorial.
+ You need to know some basic  Unix commands to compile and install xmame/xmess.
+\layout Subsection
+
+Requirements     
+\layout Itemize
+
+GNU make is MANDATORY in ALL Systems, even if you use a different  compiler.
+ 
+\layout Itemize
+
+On all platforms zlib is now needed since the core uses it.
+ If you don't have zlib, a stripped version is included with xmame.
+ See: 
+\begin_inset LatexCommand \ref[FAQ: Why do I get gz_open symbol not while compiling?]{FAQ: Why do I get gz_open symbol not found while compiling?}
+
+\end_inset 
+
+ and 
+\begin_inset LatexCommand \ref[FAQ: Why do I get zlib.h not found?]{FAQ: Why do I get zlib.h not found?}
+
+\end_inset 
+
+
+\layout Itemize
+
+You are encouraged to use a GNU development environment: gcc, gmake, gnu-
+ ar.
+ Lots of problems are found due to the very permissive syntax in gcc, so
+ if you use a strictly ANSI C compiler, you'll get lots of warnings, and
+ if the version of xmame/xmess is not fully debugged, compilation errors.
+\layout Itemize
+
+Xmame compilation breaks when using egcs-1.1.x or gcc-2.95, use 
+\family typewriter 
+-fno-strict-aliasing
+\family default 
+ to fix it.
+ gcc-2.95.1 does work with 
+\family typewriter 
+-fstrict-aliasing
+\family default 
+, and gives a nice speed increase.
+\layout Itemize
+
+Xmame compilation also breaks when using Red Hat 7's latest (as of 16 January
+ 2001) update for gcc.
+ If you experience problems, please either downgrade your compiler to the
+ one included on the Red Hat 7 CD-ROM, or try replacing 
+\begin_inset Quotes eld
+\end_inset 
+
+gcc
+\begin_inset Quotes erd
+\end_inset 
+
+ in the Makefile with 
+\begin_inset Quotes eld
+\end_inset 
+
+kgcc
+\begin_inset Quotes erd
+\end_inset 
+
+, which will invoke egcs-1.1.2.
+ (But please see above about the 
+\family typewriter 
+-fstrict-aliasing 
+\family default 
+flag.)
+\layout Subsection
+
+Follow these steps to compile xmame/xmess
+\layout Enumerate
+
+See 
+\begin_inset LatexCommand \ref[Compile Notes for Specific Operating Systems]{Compile Notes for Specific Operating Systems}
+
+\end_inset 
+
+ for platform specific compiling information.
+\layout Enumerate
+
+See 
+\begin_inset LatexCommand \ref[Display subsystem specific comments and notes]{Display subsystem specific comments and notes}
+
+\end_inset 
+
+ for special display methods information.
+\layout Enumerate
+
+Download the xmame/xmess source files archive.
+\layout Enumerate
+
+Move the xmame/xmess source files archive to a suitable work directory.
+ When you extract the archive, sub directories will be created under the
+  work directory.
+\layout Enumerate
+
+Rename the source files archive so its extension is .gz, so that gzip doesn't
+ complain.
+ For example, change 
+\family typewriter 
+xmame-0.34b1.1.tgz
+\family default 
+ to 
+\family typewriter 
+xmame-0.34b1.1.tar.gz
+\layout Enumerate
+
+Use gzip -d to uncompress the archive.
+ For example, type:
+\begin_deeper 
+\layout Verbatim
+
+gzip -d xmame-0.34b1.1.tar.gz
+\end_deeper 
+\layout Enumerate
+
+Extract the files with tar.
+ For example, type:
+\begin_deeper 
+\layout Verbatim
+
+tar xvf xmame-0.34b1.1.tar
+\end_deeper 
+\layout Enumerate
+
+After extracting the archive, change to the subdirectory created by  the
+ extraction process.
+ For example, after extracting the xmame-0.34b1.1.tar archive, a directory
+ named 
+\family typewriter 
+xmame-0.34b1.1
+\family default 
+ is created.
+ Change to it.
+ This directory is the top of the source tree.
+\layout Enumerate
+
+Copy makefile.unix to Makefile, the distributed Makefile is used for development
+ and is not a good starting point!
+\layout Enumerate
+
+Edit the 
+\family typewriter 
+Makefile
+\family default 
+ and change the settings according to your system.
+ The default 
+\family typewriter 
+makefile.unix
+\family default 
+ is preconfigured to run under X11/Linux.
+ Be careful editing this file.
+\begin_deeper 
+\layout Itemize
+
+If you intend to compile in X11 joystick support, type the following to
+ see the available Xdevice list:
+\begin_deeper 
+\layout Verbatim
+
+make xlistdev; ./xlistdev
+\end_deeper 
+\layout Itemize
+
+Choose the desired device and re-edit Makefile, setting the option X11_JOYNAME
+ to the correct device.
+\end_deeper 
+\layout Enumerate
+
+Compile xmame/xmess by typing:
+\begin_deeper 
+\layout Verbatim
+
+make
+\end_deeper 
+\layout Enumerate
+
+If the compile fails, report the problem to the author.
+\layout Enumerate
+
+
+\series bold 
+*** YOU MAY NEED TO BE root TO PERFORM THIS STEP ***
+\series default 
+\lang american
+ 
+\lang english
+To install xmame/xmess, type:
+\begin_deeper 
+\layout Verbatim
+
+make install
+\end_deeper 
+\layout Enumerate
+
+If you want you can now build xmame/xmess for another target/display method,
+ otherwise skip to the next step.
+\begin_deeper 
+\layout Enumerate
+
+If you want to also build for another target repeat repeat the 
+\family typewriter 
+
+\begin_inset Quotes eld
+\end_inset 
+
+make
+\begin_inset Quotes erd
+\end_inset 
+
+
+\family default 
+ and 
+\family typewriter 
+
+\begin_inset Quotes eld
+\end_inset 
+
+make install
+\begin_inset Quotes erd
+\end_inset 
+
+
+\family default 
+ steps adding 
+\family typewriter 
+
+\begin_inset Quotes eld
+\end_inset 
+
+TARGET=<target>
+\begin_inset Quotes erd
+\end_inset 
+
+
+\family default 
+ to the make command for example:
+\begin_deeper 
+\layout Verbatim
+
+make TARGET=mess
+\newline 
+make install
+\end_deeper 
+\layout Enumerate
+
+If you want to also build for another display method repeat the 
+\family typewriter 
+
+\begin_inset Quotes eld
+\end_inset 
+
+make
+\begin_inset Quotes erd
+\end_inset 
+
+
+\family default 
+ and 
+\family typewriter 
+
+\begin_inset Quotes eld
+\end_inset 
+
+make install
+\begin_inset Quotes erd
+\end_inset 
+
+
+\family default 
+ steps adding 
+\family typewriter 
+
+\begin_inset Quotes eld
+\end_inset 
+
+DISPLAY_METHOD=<method>
+\begin_inset Quotes erd
+\end_inset 
+
+
+\family default 
+ to the make command for example:
+\begin_deeper 
+\layout Verbatim
+
+make DISPLAY_METHOD=svgalib
+\newline 
+make install
+\end_deeper 
+\layout Enumerate
+
+You can also combine the 2 above for example:
+\begin_deeper 
+\layout Verbatim
+
+make TARGET=mess DISPLAY_METHOD=svgalib
+\newline 
+make install
+\end_deeper 
+\end_deeper 
+\layout Enumerate
+
+In your home directory, create a subdirectory called .xmame.
+\layout Enumerate
+
+From the top of the source tree, copy the file doc/xmamerc.dist to the ${HOME}/.xm
+ame/ directory.
+ (For xmess do this for xmessrc)
+\layout Enumerate
+
+If desired, copy xmamerc.dist to the global xmamerc location as "xmamerc"
+ (for xmess, copy xmamerc.dist to xmessrc).
+ The global xmamerc location is defined in the Makefile.
+\layout Enumerate
+
+Edit ${HOME}/.xmame/xmamerc to match your preferences.
+ (For xmess, edit ${HOME}/.xmess/xmessrc)
+\layout Enumerate
+
+Be sure that the DISPLAY and PATH environment variables are  set correctly.
+\layout Enumerate
+
+Make sure your ROM images are installed.
+\layout Enumerate
+
+Start the X-Window System.
+ (Unless you compiled for a different display method in which case you skip
+ this step.)
+\layout Enumerate
+
+Start xmame/xmess.
+ For example:
+\begin_deeper 
+\layout Verbatim
+
+/usr/games/xmame.x11 dkong
+\end_deeper 
+\layout Subsection
+
+If you have problems compiling, installing and starting xmame/xmess...
+     
+\layout Itemize
+
+Read  
+\begin_inset LatexCommand \ref[Xmame frequently asked questions]{Xmame frequently asked questions}
+
+\end_inset 
+
+
+\layout Itemize
+
+Read (the recent parts of) 
+\begin_inset LatexCommand \ref[Changelogs]{ChangeLogs}
+
+\end_inset 
+
+.
+ They might contain some hints about recent changes which aren't fully documente
+d yet.
+\layout Itemize
+
+Check 
+\begin_inset LatexCommand \ref[Compile Notes for Specific Operating Systems]{Compile Notes for Specific Operating Systems}
+
+\end_inset 
+
+ for operating system-specific notes.
+ You may need to do something special for your operating system.
+\layout Itemize
+
+Check 
+\begin_inset LatexCommand \ref[Display subsystem specific comments and notes]{Display subsystem specific comments and notes}
+
+\end_inset 
+
+ for display subsystem-specific notes.
+ You may need to do something special for your display system.
+\layout Itemize
+
+If you get an error about gz_open and a bunch of other functions not found
+ during linking, read: 
+\begin_inset LatexCommand \ref[FAQ: Why do I get gz_open symbol not while compiling?]{FAQ: Why do I get gz_open symbol not found while compiling?}
+
+\end_inset 
+
+ and 
+\begin_inset LatexCommand \ref[FAQ: Why do I get zlib.h not found?]{FAQ: Why do I get zlib.h not found?}
+
+\end_inset 
+
+.
+\layout Itemize
+
+Be sure that the rompath in your xmamerc/xmessrc is correct; see 
+\begin_inset LatexCommand \ref[FAQ: Where do roms.images.etc go?]{FAQ: Where do roms, images, samples, highscores, configfiles, etc go?}
+
+\end_inset 
+
+.
+\layout Itemize
+
+Check xmamerc/xmessrc: Is it configured correctly?
+\layout Itemize
+
+Are you getting messages that you are missing files? Maybe you are missing
+ PROMs; see 
+\begin_inset LatexCommand \ref[FAQ: Why doesn't a game work?]{FAQ: Why doesn't a game work?}
+
+\end_inset 
+
+ and 
+\begin_inset LatexCommand \ref[FAQ: What are PROMs?]{FAQ: What are PROMs?}
+
+\end_inset 
+
+
+\layout Itemize
+
+Is the program in your PATH?
+\layout Itemize
+
+The svgalib/xf86_dga build of xmame/xmess requires setuid root.
+ Are your permissions correct?
+\layout Itemize
+
+Try asking the friendly folks at the newsgroup alt.game.mame to see if anyone
+ else has experienced the same problem as you.
+\layout Itemize
+
+Try mailing to the xmame mailinglist, see 
+\begin_inset LatexCommand \ref[Mail]{Mail}
+
+\end_inset 
+
+ for more information.
+\layout Standard
+
+If all else fails, send email to the current maintainer of the xmame/xmess
+ project.
+ See 
+\begin_inset LatexCommand \ref[Mail]{Mail}
+
+\end_inset 
+
+ for contact information.
+\layout Subsection
+
+Compile Notes for Specific Operating Systems 
+\begin_inset LatexCommand \label{Compile Notes for Specific Operating Systems}
+
+\end_inset 
+
+
+\layout Subsubsection
+
+Linux i386
+\layout Standard
+
+Linux i386 is the platform I (Hans) use, so xmame should compile without
+ any hassles on Linux i386.
+ (Note: The same is true for Lawrence Gold.)
+\layout Standard
+
+Some bugs have been found and worked around when using gcc27x, please use
+ egcs if available.
+ If more gcc bugs popup, egcs will be  made mandatory, but I hope that won't
+ be necessary.
+\layout Standard
+
+It has been reported that some SoundBlaster AWE32 and VIA-82cxxx (onboard)
+ cards do not  correctly manage get_freespace().
+ If so, you'll get some audio_ioctl() calls failed messages in console,
+ and if everything goes right a message that xmame/xmess is falling back
+ to timer based audio.
+ If  this doesn't happen and sound isn't right, try forcing timer-based
+  audio by starting xmame/xmess with 
+\family typewriter 
+-timer
+\family default 
+.
+\layout Standard
+
+SB64/128PCI cards (Ensoniq 137x-based cards) also do not correctly manage
+ get_freespace().
+ Unfortunately, this doesn't result in failed ioctl's; instead, they just
+ ignore the calls.
+ Xmame tries to autodetect this and to fall back to timer-based audio.
+ If this doesn't happen and sound isn't right, try forcing timer based audio
+ by starting xmame/xmess with 
+\family typewriter 
+-timer
+\family default 
+.
+\layout Standard
+
+Some have reported success using ALSA with OSS emulation (see 
+\begin_inset LatexCommand \url[http://www.alsa-project.org/]{http://www.alsa-project.org/}
+
+\end_inset 
+
+).
+ If you experience the above problems, this would certainly be worth a try.
+\layout Standard
+
+Also, I've tested sound using the PC-Speaker driver module.
+ It works!! But it needs 
+\family typewriter 
+-timer.
+
+\family default 
+ Again, it should do this  automagically, but you know what to do if it
+ doesn't.
+\layout Standard
+
+Distribution-Specific Comments:
+\layout Itemize
+
+S.u.S.E.
+ Linux: Besides the gcc compiler and libc libraries, which are both from
+ the "d" series, other packages  need to be installed or the build will
+ fail.
+ If compiling for svgalib, the svgalib package from series "d" installed.
+ If compiling for the X-Window System, you must have xdevel package from
+ series "x" installed.
+ These packages can be installed using the "yast" utility included in the
+ S.u.S.E.
+ distribution.
+\layout Itemize
+
+Red Hat Linux is the operating system used by the author.
+ xmame/xmess  should build correctly under Red Hat Linux.
+ :-)
+\layout Subsubsection
+
+Linux PowerPC
+\layout Standard
+
+Linux PowerPC should work from now on.
+ Here's an email from Andreas Varga 
+\family typewriter 
+
+\begin_inset LatexCommand \url[sid@skater.htu.tuwien.ac.at]{mailto:sid@skater.htu.tuwien.ac.at}
+
+\end_inset 
+
+
+\family default 
+, the Linux/PowerPC maintainer, describing the necessary steps:
+\layout Standard
+
+Required changes to compile xmame 0.34b3.1 on Linux/PowerPC with SVGALIB
+\layout Standard
+
+Makefile:
+\layout Itemize
+
+enable CFLAGS for linux/ppc 
+\layout Itemize
+
+enable DISPLAY_METHOD = svgalib 
+\layout Itemize
+
+enable ARCH = linux 
+\layout Itemize
+
+remove -lvgagl from LIBS.svgalib in src/unix/unix.mak (only -lvga is required)
+\layout Standard
+
+Required changes to compile xmame 0.34b3.1 on Linux/PowerPC with X11 
+\layout Standard
+
+Makefile: 
+\layout Itemize
+
+enable CFLAGS for linux/ppc 
+\layout Itemize
+
+enable DISPLAY_METHOD = x11 
+\layout Itemize
+
+enable ARCH = linux 
+\layout Standard
+
+Another thing...
+ sound is not working, because sound drivers support is currently under
+ development in Linux/PPC kernels...there is an old driver that is a hacked
+ Soundblaster driver, and newer 2.1.1xx kernels have a sound drivers based
+ on Amiga DMA sound drivers...
+ Once this issues are settled there should be a full OSS-compatible driver...
+ sound should work then...
+\layout Standard
+
+I can't speak about Joystick support...
+\layout Standard
+
+The original Linux/PPC target changes in the Makefile were done by me, but
+ there are some other changes required to get it to compile...
+ Starting from October I will have some more time to work on this, and I'll
+ keep you updated...
+\layout Standard
+
+Cheers, Andreas
+\layout Subsubsection
+
+IRIX
+\layout Standard
+
+Use the generic unix arch for those machines that have no  sound support
+ installed (xmame/xmess uses the dmedia package or the newer AL package
+ on IRIX systems).
+\layout Standard
+
+Silicon Graphics provides several native compilers.
+ xmame/xmess has  been compiled and tested with the normal cc.
+ There were some problems with this when using -n32 for new style 32bit
+ code.
+ It does work when using -o32 for oldstyle 32 bit code.
+ It should now also work with -n32 which is much faster.
+\layout Standard
+
+The use of DCC is not recommended (anymore) since it's a C++  compiler and
+ thus won't even compile xmame/xmess out of the box due to uncasted mallocs.
+ Changing all these mallocs would be crazy, esp.
+ since they are not only in the osd part, but also in the core which is
+ not under our control.
+ Besides that, mame is normal C, so please compile it with a normal C compiler.
+\layout Standard
+
+Some problems have been reported using the GNU linker.
+ It's recommended that you use the native one.
+\layout Subsubsection
+
+HPUX
+\layout Standard
+
+Use the generic unix arch.
+ In HP-UX, gcc and gnu-make are MANDATORY.
+\layout Subsubsection
+
+ULTRIX 
+\layout Standard
+
+Use the generic unix arch.
+\layout Standard
+
+Notes received from Danny 
+\family typewriter 
+
+\begin_inset LatexCommand \url[dboxhoor@iso.vilspa.esa.es]{mailto:dboxhoor@iso.vilspa.esa.es}
+
+\end_inset 
+
+
+\layout Standard
+
+
+\series bold 
+VERY IMPORTANT!!!
+\layout Standard
+
+The xmame/xmess CPU emulators access memory through pointers which are sometimes
+ cast to illegal addresses - as far as the MIPS CPU is concerned.
+ The Ultrix operating system is aware of that and fixes this "unaligned
+ data access".
+\layout Standard
+
+Depending on your system setup, lots of warnings are generated for certain
+ games.
+ Fortunately these messages can be disabled by  executing the command "uac
+ p 0" in the same shell where xmame/xmess  will be running.
+\layout Standard
+
+UPDATE: The new 
+\family typewriter 
+-DALIGN_INTS
+\family default 
+ switch in the makefile fixes these unaligned accesses in the source which
+ is probably a lot faster than hot fixing them in the kernel segfault handler.
+\layout Standard
+
+Use gnu make.
+\layout Standard
+
+Compile with the `c89' compiler.
+ Though `gcc' has no problems  with compiling and optimizing xmame/xmess,
+ the resulting `c89'  executable is faster on an empty machine (read: xmame
+ can use all  cpu & memory without competing with other high priority  processes
+), so you can set `frameskip' to 1.
+\layout Standard
+
+When compiling with `c89 -O2' don't forget to also use `-Olimit  1000'.
+ If 1000 is not enough, the compiler will tell you to  increase it.
+\layout Subsubsection
+
+SunOS & Solaris
+\layout Standard
+
+There are 2 relevant architecture options available in the makefile: 
+\layout Verbatim
+
+    ARCH = generic : use this for old SunOs running on Sparcs,
+\newline 
+                     but a Sparc running Solaris will usually
+\newline 
+                     handle this option too.
+\newline 
+    ARCH = solaris : this is the one you should use for Sparcs
+\newline 
+                     running Solaris.
+        
+\layout Standard
+
+Currently sound is not supported under sunos.
+ The solaris arch does support audio.
+\layout Standard
+
+If you are using Sun's OpenWindows implementation of X11, then make sure
+ that the X11INC and X11LIB variables in the X11 Options section of the
+ makefile are set properly.
+ (There are already entries for the standard OpenWin directory there that
+ you can uncomment.)
+\layout Standard
+
+Of course, if you are compiling for X11 then you need to set these variables
+ properly, no matter what implementation of X11 you are using!  :)
+\layout Standard
+
+If you are using Sun's SunPro cc compiler, then the following optimisation
+ flags have been reported to be good:
+\layout Verbatim
+
+    OPTFLAGS    = -fast -xO4 -native
+\layout Standard
+
+Finally, there has been a case of the xmame compilation processes breaking
+ over the "ar" program.
+ Most Solaris installations will include a set of utilities that conform
+ to the XPG4 standard, usually in the "/usr/xpg4/bin" directory.
+ The XPG4 version of "ar" should be avoided like the plague.
+ Ensure that the "/usr/ccs/bin" appears in your path before the "/usr/xpg4/bin"
+ directory and everything should go smoothly.
+\layout Standard
+
+PLEASE NOTE : There is currently not much support for SunOS/Solaris.
+ If you have any trouble, try to fix it yourself.
+ If you succeed, send a message to the mailing list detailing what you did.
+ If you don't succeed, send a message anyway and someone _may_ be able to
+ help you.
+ Either way, this is the only way that problems with xmame on SunOS/Solaris
+ will get fixed.
+\layout Subsubsection
+
+Openstep
+\layout Standard
+
+You must use the OpenStep gnumake, not make.
+ You must also use the NeXT/Apple cc rather than gcc.
+ Also use only the optimisation options as recommended for OpenStep in the
+ makefile, others will cause the resulting executable to crash.
+ The OpenStep assembler on i386 architectures is incompatible with the mame
+ assembler CPU cores and thus you must use the C versions (Use i386-noasm
+ instead of i386 when compiling for i386).
+\layout Standard
+
+The supplied complier is based on gcc 2.7.2.1 which will not compile src/profiler.c
+ without crashing.
+ To get around this you must turn off + optimisation when this crash occurs,
+ re-make to compile this file only, then stop the make, re-enable optimisation,
+ and continue.
+\layout Standard
+
+On an OpenStep keyboard the functions keys do not all operate as expected.
+ Using the command key in conjuction with a number key generates the equivalent
+ function key within xmame, with 0, - and = + representing F10, F11 and
+ F12 resepectively.
+ Also note that the ALT + keys cannot be mapped.
+ As most games tend to use this as the default fire button it is exteremly
+ useful to remap this globally the first time you run xmame.
+\layout Section
+
+Xmame Frequently Asked Questions
+\begin_inset LatexCommand \label{Xmame frequently asked questions}
+
+\end_inset 
+
+
+\layout Subsection
+
+What is mame?
+\layout Standard
+
+Mame is an arcade machine emulator.
+ Started in 1997 by Nicola  Salmoria, mame started out as a series of emulators
+ for  individual games.
+ This series of emulators was combined into a  simgle multi-game emulator.
+ This is the current form of mame; no longer a one-man show, there are over
+ 100 contributors to the project.
+\layout Standard
+
+Mame was created by Nicola Salmoria.
+\layout Standard
+
+Also see 
+\begin_inset LatexCommand \url[the official mame readme file (readme.mame)]{readme.mame}
+
+\end_inset 
+
+
+\layout Subsection
+
+What is mess?
+\layout Standard
+
+Mess is just like mame---a virtual machine emulator, only it doesn't emulate
+ arcade machines but rather computers and consoles.
+\layout Standard
+
+Also see 
+\begin_inset LatexCommand \url[the official mess readme file (readme.mess)]{readme.mess}
+
+\end_inset 
+
+
+\layout Subsection
+
+What is xmame/xmess?
+\layout Standard
+
+Xmame/xmess are the Unix/X11 ports of the mame and mess projects.
+ It makes mame/mess available on *ix machines using the X11R6 X-Window System
+ (and SVGAlib/ggi/XF86-DGA/OpenGL/SDL too).
+\layout Standard
+
+Mame was orginally ported by Allard Van Der Bas, Dick the Ridder, Juan Antonio
+ Martinez, and Hans de Goede.
+\layout Standard
+
+Xmame/xmess is currently maintained by Lawrence Gold.
+\layout Subsection
+
+What are the differences between mame/mess and xmame/xmess?
+\layout Standard
+
+None significant.
+\layout Standard
+
+Xmame/xmess is based on the mame/mess source code.
+ Due to technical reasons beyond the scope of this document, the mame/mess
+ source may not compile under Unix.
+ That's why the xmame/xmess project exists.
+ Each time mame/mess is updated, the code is tested  (and patched if needed)
+ under Unix.
+ This way xmame/xmess releases are always the same as their mame counterparts.
+\layout Standard
+
+There are no plans for the independent development of xmame/xmess.
+\layout Subsection
+
+What hardware and operating systems are supported?     
+\layout Standard
+
+Xmame runs on both little-endian and big-endian CPUs, using aligned integer
+ access if needed and is compatible with 64 bit CPUs.
+ The current list of supported CPUs in the makefile is:
+\layout Itemize
+
+i386 + gnu-asm
+\layout Itemize
+
+i386 no asm
+\layout Itemize
+
+alpha
+\layout Itemize
+
+ia64 (merced)
+\layout Itemize
+
+m68k
+\layout Itemize
+
+generic risc (PowerPC, Sparc, HPPA, IBM)
+\layout Itemize
+
+generic risc, lsb-first (RISC (Ultrix machines))
+\layout Itemize
+
+mips (generic risc + SGI compiler bug workarounds)
+\layout Standard
+
+Adding support for another cpu (if necessary) should be trivial.
+\layout Standard
+
+The following Unix platforms are specifically supported:
+\layout Itemize
+
+Linux
+\layout Itemize
+
+FreeBSD
+\layout Itemize
+
+NetBSD
+\layout Itemize
+
+Solaris (SunOS)
+\layout Itemize
+
+OpenStep (noasm only on i386)
+\layout Itemize
+
+IRIX with sound using the dmedia package or the new al package (sound currently
+ broken)
+\layout Itemize
+
+AIX (sound currently broken)
+\layout Itemize
+
+generic unix, no sound
+\layout Standard
+
+The generic unix entry should work for any reasonable standard Unix variant,
+ but lacks sound since there is no single Unix sound standard.
+\layout Standard
+
+On all platforms, zlib is now needed since the core uses it.
+ Ff you don't have zlib, use the included one by uncommenting the appropriate
+ line in Makefile.
+\layout Standard
+
+The following display methods are supported.
+ X11 is the only one which works on all platforms, except for OpenStep which
+ only works with Openstep bitmaps:
+\layout Itemize
+
+X11 (X-Window System)
+\layout Itemize
+
+svgalib
+\layout Itemize
+
+GGI (Generic Graphics Interface)
+\layout Itemize
+
+OpenGL using X11 for input
+\layout Itemize
+
+glide using X11 for input (3DFX)
+\layout Itemize
+
+glide using svgalib for input (3DFX)
+\layout Itemize
+
+OpenStep bitmaps
+\layout Itemize
+
+SDL (Simple Direct Medialayer)
+\layout Standard
+
+The following is a list of arch/os/display combinations, with maintainers,
+ for arch/os/display combinations which are actively supported.
+ Please mail the maintainer of the arch/os/display combination for compilation
+ and other arch/os/display specific problems.
+ Mail Lawrence 
+\family typewriter 
+
+\begin_inset LatexCommand \url[gold@aros.net]{mailto:gold@aros.net}
+
+\end_inset 
+
+
+\family default 
+ for generic (e.g., X11) problems.
+\layout Itemize
+
+i386/linux/x11 (+DGA)
+\hfill 
+ -> Lawrence 
+\family typewriter 
+
+\begin_inset LatexCommand \url[<gold@aros.net>]{mailto:gold@aros.net}
+
+\end_inset 
+
+
+\layout Itemize
+
+i386/linux/svgalib
+\hfill 
+ -> Lawrence 
+\family typewriter 
+
+\begin_inset LatexCommand \url[<gold@aros.net>]{mailto:gold@aros.net}
+
+\end_inset 
+
+
+\layout Itemize
+
+i386/linux/xgl
+\hfill 
+ -> Sven Goethel 
+\family typewriter 
+
+\begin_inset LatexCommand \url[<sgoethel@jausoft.com>]{mailto:sgoethel@jausoft.com}
+
+\end_inset 
+
+
+\layout Itemize
+
+i386/linux/xfx
+\hfill 
+ -> Lawrence 
+\family typewriter 
+
+\begin_inset LatexCommand \url[<gold@aros.net>]{mailto:gold@aros.net}
+
+\end_inset 
+
+
+\layout Itemize
+
+i386/linux/svgafx
+\hfill 
+ -> Lawrence 
+\family typewriter 
+
+\begin_inset LatexCommand \url[<gold@aros.net>]{mailto:gold@aros.net}
+
+\end_inset 
+
+
+\layout Itemize
+
+i386/linux/ggi
+\hfill 
+ -> Christian 
+\family typewriter 
+
+\begin_inset LatexCommand \url[<cpg@aladdin.de>]{mailto:cpg@aladdin.de}
+
+\end_inset 
+
+
+\layout Itemize
+
+alpha/linux/x11
+\hfill 
+ -> Christian 
+\family typewriter 
+
+\begin_inset LatexCommand \url[<cpg@aladdin.de>]{mailto:cpg@aladdin.de}
+
+\end_inset 
+
+
+\layout Itemize
+
+alpha/digital unix/x11 *
+\hfill 
+ -> Leandro 
+\family typewriter 
+
+\begin_inset LatexCommand \url[<gold@aros.net>]{mailto:gold@aros.net}
+
+\end_inset 
+
+
+\layout Itemize
+
+powerpc/linux/x11
+\hfill 
+ -> Andreas 
+\family typewriter 
+
+\begin_inset LatexCommand \url[<sid@skater.htu.tuwien.ac.at>]{mailto:sid@skater.htu.tuwien.ac.at}
+
+\end_inset 
+
+
+\layout Itemize
+
+powerpc/linux/svgalib
+\hfill 
+ -> Andreas 
+\family typewriter 
+
+\begin_inset LatexCommand \url[<sid@skater.htu.tuwien.ac.at>]{mailto:sid@skater.htu.tuwien.ac.at}
+
+\end_inset 
+
+
+\layout Itemize
+
+i386/freebsd/x11
+\hfill 
+ -> Jacob A.
+ Hart 
+\family typewriter 
+
+\begin_inset LatexCommand \url[<c9710216@studentmail.newcastle.edu.au>]{mailto:c9710216@studentmail.newcastle.edu.au}
+
+\end_inset 
+
+
+\layout Itemize
+
+i386/netbsd/x11
+\hfill 
+ -> Dave 
+\family typewriter 
+
+\begin_inset LatexCommand \url[<dave@dtsp.co.nz>]{mailto:dave@dtsp.co.nz}
+
+\end_inset 
+
+
+\layout Itemize
+
+alpha/netbsd/x11
+\hfill 
+ -> Christian 
+\family typewriter 
+
+\begin_inset LatexCommand \url[<cpg@aladdin.de>]{mailto:cpg@aladdin.de}
+
+\end_inset 
+
+
+\layout Itemize
+
+Sparc/Solaris/x11
+\hfill 
+ -> Lawrence 
+\family typewriter 
+
+\begin_inset LatexCommand \url[<gold@aros.net>]{mailto:gold@aros.net}
+
+\end_inset 
+
+
+\layout Itemize
+
+i386/Unixware7/x11 *
+\hfill 
+ -> Richard 
+\family typewriter 
+
+\begin_inset LatexCommand \url[<xmame@frogface.ddns.org>]{mailto:xmame@frogface.ddns.org}
+
+\end_inset 
+
+
+\layout Itemize
+
+i386/openstep
+\hfill 
+ -> Pete French 
+\family typewriter 
+
+\begin_inset LatexCommand \url[<pete@toybox.twisted.org.uk>]{mailto:pete@toybox.twisted.org.uk}
+
+\end_inset 
+
+
+\layout Itemize
+
+Sparc/SunOs
+\hfill 
+ -> Saga 
+\family typewriter 
+
+\begin_inset LatexCommand \url[<jolletx@cybercable.fr>]{mailto:jolletx@cybercable.fr}
+
+\end_inset 
+
+
+\layout Itemize
+
+mips/irix/x11
+\hfill 
+ -> Dingus Family 
+\family typewriter 
+
+\begin_inset LatexCommand \url[<ddingus@uswest.net>]{mailto:ddingus@uswest.net}
+
+\end_inset 
+
+
+\layout Standard
+
+* These are supported using the generic unix entry of the makefile, and
+ thus lack sound.
+\layout Standard
+
+We are always looking for people willing to test and answer questions about
+ xmame on a new arch/os/display.
+ This takes very little work and could help other people tremendously.
+ If you're interested, mail Lawrence 
+\family typewriter 
+
+\begin_inset LatexCommand \url[gold@aros.net]{mailto:gold@aros.net}
+
+\end_inset 
+
+
+\family default 
+.
+\layout Subsection
+
+My system is supported but xmame/xmess gives me errors and fails.
+ Why?
+\layout Standard
+
+Xmame/xmess should run on 16, 24 and 32bpp true color displays.
+ If your X server does not support any  of these display types, xmame/xmess
+ will not run.
+ Support for 8bpp pseudo color displays may return in future versions.
+\layout Standard
+
+You can verify your X server support by starting your X server  and running
+ the xdpyinfo program.
+ See the xdpyinfo manual page  for more information.
+\layout Subsection
+
+What is the role of the xmamerc/xmessrc file?
+\layout Standard
+
+A normal xmame/xmess invocation looks like:
+\layout Verbatim
+
+    xmame pacman -sound -nojoy -frameskip 2 -heightscale 3 
+\backslash 
+   
+\newline 
+        -widthscale 2
+\layout Standard
+
+Most of the time, you will want to use the same configuration for  each
+ game.
+ xmame/xmess will read this file for default values for the  parameters
+ that you can set.
+ This way the only parameters you  need to express on the command line are
+ the ones you want to  override.
+\layout Standard
+
+Another reason for xmamerc/xmessrc is keyboard remapping.
+ Some Unix  keyboards are very different than their PC counterparts.
+ To  compensate for the changes, xmame/xmess allows you to remap keys that
+  are not available on Unix keyboards to keys that are available.
+\layout Subsection
+
+What is the syntax of the xmamerc/xmessrc file.
+\layout Standard
+
+The syntax is quite simple:
+\layout Verbatim
+
+   "keyword value"
+\layout Standard
+
+See 
+\begin_inset LatexCommand \url[xmamerc.dist]{xmamerc.dist}
+
+\end_inset 
+
+ for most keywords.
+ Allmost all commandline options can be used as keywords (without the -),
+ use value 0 or 1 for commandline options which have a negating (-no[option])
+ counterpart.
+ As usual lines begining with "#" are comments.
+\layout Standard
+
+You can also generate a configfile with all the current settings to use
+ as a template by typing:
+\layout Verbatim
+
+   xmame -showconfig > ~/.xmame/xmamerc
+\layout Subsection
+
+Where do roms, images, samples, highscores, configfiles, etc go? 
+\begin_inset LatexCommand \label{FAQ: Where do roms, images, samples, highscores, configfiles, etc go?}
+
+\end_inset 
+
+
+\layout Subsubsection
+
+Roms/Samples
+\layout Standard
+
+Xmame/xmess uses a ":" seperated rompath to find out which dirs to search
+ for roms/samples.
+\layout Standard
+
+The default rompath is XMAMEROOT as defined in Makefile during compile.
+\layout Standard
+
+This is overwritten by any rompath in xmamerc/xmessrc, which can be overwritten
+ again with the -rompath commandline option.
+\layout Standard
+
+Xmame/xmess searches every dir in this path for roms/samples in the following
+ way:
+\layout Verbatim
+
+    <dir>/gamename.zip             (containing filename.ext)
+\newline 
+    <dir>/gamename/filename.ext
+\newline 
+    <dir>/gamename/filename.ext.gz (containing filename.ext)
+\newline 
+    <dir>/gamename/filename.zip    (containing filename.ext)
+\layout Standard
+
+So let's say that we are searching for rom0001.1, which is part of pacman.
+ Then xmame/xmess would search every dir in your rompath for
+\layout Verbatim
+
+    <dir>/pacman.zip               (containing rom0001.1)
+\newline 
+    <dir>/pacman/rom0001.1
+\newline 
+    <dir>/pacman/rom0001.1.gz      (containing rom0001.1)
+\newline 
+    <dir>/pacman/rom0001.zip       (containing rom0001.1)
+\layout Standard
+
+Note: If your neogeo games can't find neogeo.rom, put it in a dir called
+ neogeo somewhere in your rompath, or put it in neogeo.zip somewhere in your
+ rompath.
+\layout Subsubsection
+
+Read/write Diskette Images
+\layout Standard
+
+This section only applies to xmess emulations which support read/write diskette
+ images and thus try to open the image read/write.
+\layout Standard
+
+Xmess first searches for read/write images with the name specified on the
+ commandline:
+\layout Verbatim
+
+    <path>/image.ext
+\layout Standard
+
+where path is the path specified with the image on the commandline.
+ This way, absolute and relative filenames can be used directly on the commandli
+ne for an image which is not in the rompath.
+\layout Standard
+
+Then xmess searches every dir in the rompath for roms/samples in the following
+ way:
+\layout Verbatim
+
+    <dir>/image.ext
+\layout Standard
+
+Note that (g)zipped images are not supported for r/w images.
+\layout Subsubsection
+
+Rom Cartridges/Read Only Diskette Images
+\layout Standard
+
+Xmess begins by searching for cartdriges/disks from the current dir in the
+ following way:
+\layout Verbatim
+
+    <path>/image.ext
+\newline 
+    <path>/image.ext.gz            (containing image.ext)
+\newline 
+    <path>/image.zip               (containing image.ext)
+\layout Standard
+
+where path is the path specified with the image on the commandline.
+ This way, absolute and relative filenames can be used directly on the commandli
+ne for an image which is not in the rompath.
+\layout Standard
+
+Then xmess searches every dir in the rompath for carts/images in the following
+ way:
+\layout Verbatim
+
+    <dir>/image.ext
+\newline 
+    <dir>/image.ext.gz             (containing image.ext)
+\newline 
+    <dir>/image.zip                (containing image.ext)
+\layout Standard
+
+Finally, xmess searches the rompath as desribed above using the systemtype
+ for gamename.
+\layout Standard
+
+So let's say we want to play mario.nes on the nes emulation of xmess.
+ We would then type: "xmess nes mario.nes".
+ Xmess then begins by searching the current dir for
+\layout Verbatim
+
+    mario.nes
+\newline 
+    mario.nes.gz                   (containing mario.nes)
+\newline 
+    mario.zip                      (containing mario.nes)
+\layout Standard
+
+After that, xmess searches each dir in your rompath for
+\layout Verbatim
+
+    <dir>/mario.nes
+\newline 
+    <dir>/mario.nes.gz             (containing mario.nes)
+\newline 
+    <dir>/mario.zip                (containing mario.nes)
+\layout Standard
+
+And finally, xmess searches each dir in your rompath for
+\layout Verbatim
+
+    <dir>/nes.zip                  (containing mario.nes)
+\newline 
+    <dir>/nes/mario.nes
+\newline 
+    <dir>/nes/mario.nes.gz         (containing mario.nes)
+\newline 
+    <dir>/nes/mario.zip            (containing mario.nes)
+\layout Standard
+
+Since xmess first searches for cartridges/disks from the current dir you
+ can also specify cartridges/disks not in your rompath.
+ For example:
+\layout Verbatim
+
+    "xmess nes ../mario.nes"
+\layout Standard
+
+Xmess then searches for
+\layout Verbatim
+
+    ../mario.nes
+\newline 
+    ../mario.nes.gz                (containing mario.nes)
+\newline 
+    ../mario.zip                   (containing mario.nes)
+\layout Standard
+
+and will also search the rompath as described above with ../mario.nes as the
+ image name but this is not that useful.
+\layout Subsubsection
+
+Artwork
+\layout Standard
+
+Xmame/xmess searches every dir in the rompath for artwork in the following
+ way:
+\layout Verbatim
+
+    <dir>/artwork.png
+\newline 
+    <dir>/artwork.png.gz           (containing artwork.png)
+\newline 
+    <dir>/artwork.zip              (containing artwork.png)
+\layout Standard
+
+Then xmame/xmess searches the rompath as in roms/samples.
+\layout Standard
+
+So let's say we want to play foo which uses bar.png.
+ Xmame/xmess then begins searching each dir in your rompath for
+\layout Verbatim
+
+    <dir>/bar.png
+\newline 
+    <dir>/bar.png.gz               (containing bar.png)
+\newline 
+    <dir>/bar.zip                  (containing bar.png)
+\layout Standard
+
+And then xmame/xmess searches each dir in your rompath for
+\layout Verbatim
+
+    <dir>/foo.zip                  (containing bar.png)
+\newline 
+    <dir>/foo/bar.png
+\newline 
+    <dir>/foo/bar.png.gz           (containing bar.png)
+\newline 
+    <dir>/foo/bar.zip              (containing bar.png)
+\layout Subsubsection
+
+Xmame configuration
+\layout Standard
+
+Xmame looks for the following configuration files and parses each one found.
+ Files parsed later can overwrite options in previously parsed files:
+\layout Verbatim
+
+    XMAMEROOT/xmamerc
+\newline 
+    XMAMEROOT/xmame-DISPLAY_METHODrc
+\newline 
+    ${HOME}/.xmame/xmamerc
+\newline 
+    ${HOME}/.xmame/xmame-DISPLAY_METHODrc
+\newline 
+    ${HOME}/.xmame/rc/<gamename>rc
+\layout Standard
+
+
+\family typewriter 
+XMAMEROOT
+\family default 
+ is defined during compile time, see Makefile.
+\layout Standard
+
+
+\family typewriter 
+DISPLAY_METHOD
+\family default 
+ is the 
+\family typewriter 
+DISPLAY_METHOD
+\family default 
+ for which xmame was compiled, this can be one of: x11, svgalib, ggi, xgl,
+ xfx, svgafx, openstep, SDL.
+\layout Standard
+
+For xmess of course replace xmame by xmess.
+ ;)
+\layout Subsubsection
+
+Game configuration
+\layout Standard
+
+Game configuration files are kept on a per-user base in:
+\layout Verbatim
+
+    ${HOME}/.xmame/cfg/<game>.cfg resp
+\newline 
+    ${HOME}/.xmess/cfg/<game>.cfg
+\layout Subsubsection
+
+Game state
+\layout Standard
+
+Game state files are kept on a per-user base in:
+\layout Verbatim
+
+    ${HOME}/.xmame/sta/<game>.sta resp
+\newline 
+    ${HOME}/.xmess/sta/<game>.sta
+\layout Subsubsection
+
+NVram
+\layout Standard
+
+NVram files are kept on a per-user base in:
+\layout Verbatim
+
+    ${HOME}/.xmame/nvram/<game>.nv resp
+\newline 
+    ${HOME}/.xmess/nvram/<game>.nv
+\layout Subsubsection
+
+Mem cards
+\layout Standard
+
+Mem cards files are kept on a per-user base in:
+\layout Verbatim
+
+    ${HOME}/.xmame/mem/<filename>.mem resp
+\newline 
+    ${HOME}/.xmess/mem/<filename>.mem
+\layout Standard
+
+Where <filename> is given by the game-driver.
+ 
+\layout Subsubsection
+
+Screenshots
+\layout Standard
+
+Screenshots, which can be made by pressing F12, are saved as png files in
+ the directory from where xmame is started (cwd).
+\layout Standard
+
+This can be overidden by the screenshotdir entry in xmamerc/xmessrc, which
+ can again be overidden by the 
+\family typewriter 
+-screenshotdir
+\family default 
+ cmdline-option.
+\layout Standard
+
+They are saved as:
+\layout Verbatim
+
+    <screenshotdir>/<game>xxxx.png
+\newline 
+    Where xxxx is a number.
+\layout Subsubsection
+
+Highscores
+\layout Standard
+
+Highscores are stored in XMAMEROOT as defined in Makefile when building.
+ This can be overidden by the spooldir entry in xmamerc/xmessrc, which can
+ again be overidden by the 
+\family typewriter 
+-spooldir
+\family default 
+ cmdline-option.
+\layout Standard
+
+So only give a 
+\layout Verbatim
+
+    drwxrwsr-x root games <spooldir>
+\layout Standard
+
+permission and setgid xmame/xmess to "games" to get it to work.
+ Note this doesn't work with suid root versions (svgalib & XF86-DGA), suggestion
+s welcome.
+\layout Standard
+
+For now use 
+\family typewriter 
+${HOME}/.xmame
+\family default 
+ or 
+\family typewriter 
+$ {HOME}/.xmess
+\family default 
+ as the spooldir in xmamerc/xmessrc for  suid root versions.
+\layout Standard
+
+Note: For highscores to work, xmame must also be able to find hiscore.dat.
+\layout Subsubsection
+
+hiscore.dat
+\layout Standard
+
+If you want to use highscores mame needs to load hiscore.dat to get highscore
+ info.
+\layout Standard
+
+The default is 
+\family typewriter 
+XMAMEROOT
+\family default 
+/hiscore.dat .
+ XMAMEROOT is set during compile-time; see the Makefile.
+ This can be overridden by the hiscorefile entry in xmamerc if present,
+ which can again be overridden by the cmdline-option 
+\family typewriter 
+-hiscorefile
+\family default 
+.
+\layout Standard
+
+
+\family typewriter 
+hiscore.dat
+\family default 
+ is available from the mame homepage: 
+\begin_inset LatexCommand \url[http://www.mame.net]{http://www.mame.net}
+
+\end_inset 
+
+
+\layout Subsubsection
+
+cheat.dat
+\layout Standard
+
+If you want to use cheats mame needs to load cheat.dat to get cheat info.
+\layout Standard
+
+The default is XMAMEROOT/cheat.dat .
+ XMAMEROOT is set during compile-time; see the Makefile.
+ This can be overridden by the cheatfile entry in xmamerc if present, which
+ can again be overridden by the cmdline-option 
+\family typewriter 
+-cheatfile
+\family default 
+.
+\layout Standard
+
+
+\family typewriter 
+cheat.dat
+\family default 
+ is available from the mame homepage: 
+\begin_inset LatexCommand \url[http://www.mame.net]{http://www.mame.net}
+
+\end_inset 
+
+
+\layout Subsubsection
+
+history.dat
+\layout Standard
+
+If you want to display some nice background info on games, mame needs to
+ load history.dat.
+\layout Standard
+
+The default is XMAMEROOT/history.dat .
+ XMAMEROOT is set during compile-time, see the Makefile.
+ This can be overridden by the historyfile entry in xmamerc if present,
+ which can again be overridden by the cmdline-option 
+\family typewriter 
+-historyfile
+\family default 
+.
+\layout Standard
+
+
+\family typewriter 
+history.dat
+\family default 
+ is available from the mame homepage: 
+\begin_inset LatexCommand \url[http://www.mame.net]{http://www.mame.net}
+
+\end_inset 
+
+
+\layout Subsubsection
+
+Input logs
+\layout Standard
+
+Input logs are saved/read under the name specified after the 
+\family typewriter 
+-record / -playback
+\family default 
+ option; this name is relative to the current path.
+\layout Subsubsection
+
+Xmame/xmess still can't find files/store highscores
+\layout Standard
+
+Type 
+\family typewriter 
+"xmame/xmess -showconfig | more"
+\family default 
+ and check that the rompath and spooldir shown are correct and readable/writable.
+ Otherwise recheck xmamerc/xmessrc.
+ Remember that xmess also searches the current dir.
+\layout Subsection
+
+How do I start xmess/xmame ?
+\layout Standard
+
+To start xmame, type
+\layout Verbatim
+
+    xmame [options] <gamename> [more options]
+\layout Standard
+
+For xmess, type
+\layout Verbatim
+
+    xmess [options] <systemname> [more options] 
+\backslash 
+
+\newline 
+    <disk/romimage(s)> [more options]
+\layout Standard
+
+All options are optional.
+ ;)
+\layout Standard
+
+Xmame/xmess supports most dos command line options (see readme.mame / readme.mess)
+ as well as a few of its own: Type xmame -help |  more for a complete list.
+\layout Standard
+
+With xmess, some systems don't require a disk/romimage, but most do.
+\layout Subsection
+
+What are the command line parameters for xmame/xmess?
+\layout Standard
+
+To see a list of available parameters, type:
+\layout Verbatim
+
+    /usr/games/xmame -help | more
+\layout Standard
+
+Xmame/xmess supports most of the command line parameters as the DOS  version
+ as well a some of its own.
+\layout Standard
+
+See the file readme.mame / readme.mess for more information about the command
+ line parameters.
+\layout Subsection
+
+What keys does xmame/xmess use?
+\begin_inset LatexCommand \label{FAQ: What keys does xmame/xmess use?}
+
+\end_inset 
+
+
+\layout Standard
+
+Xmame/xmess uses the same key-bindings as the DOS version of mame: The following
+ keys work in all emulators:
+\layout Verbatim
+
+    `  or ~      Enter On screen display to change volume, brightness etc.
+\newline 
+    Tab          Enter configuration menu.
+ Press Tab or Esc to get back to
+\newline 
+                 the emulation.
+\newline 
+    P            Pause
+\newline 
+    F3           Reset
+\newline 
+    F4           Show the game graphics.
+ Use cursor keys to change set/color,
+\newline 
+                 F4 or Esc to return to the emulation.
+\newline 
+    F8           Reduce frame skip
+\newline 
+    F9           Increase frameskip
+\newline 
+    F10          Toggle speed throttling
+\newline 
+    F10 + shift  Toggle idle sleeping
+\newline 
+    F11          Toggle speed display
+\newline 
+    F11 + shift  Toggle profiler display
+\newline 
+    F12          Save a screen snapshot
+\newline 
+    ESC          Exit emulator
+\layout Standard
+
+Xmame has 2 different auto frameskipping algorithms.
+ These can be selected with the -frameskipper option and with key combos:
+\layout Verbatim
+
+    Key combo:             Gives you the:
+\newline 
+    left-ctrl + insert     standard dos frameskipper
+\newline 
+    left-ctrl + home       William Barath's frameskipper
+\layout Standard
+
+Xmame's display scaling can be controlled on the fly with the following
+ key combos:
+\layout Verbatim
+
+    Key combo:             Result:
+\newline 
+    left-shift + insert    Increase widthscale
+\newline 
+    left-shift + delete    Decrease widthscale
+\newline 
+    left-shift + home      Increase heightscale
+\newline 
+    left-shift + end       Decrease heightscale
+\newline 
+    left-shift + pageup    Increase scale
+\newline 
+    left-shift + pagedown  Decrease scale
+\layout Standard
+
+Under X11, xmame can switch to and from different modes during runtime:
+ 
+\layout Verbatim
+
+    Key combo:             Warps you to:
+\newline 
+    left-alt + insert      Normal window
+\newline 
+    left-alt + home        DGA fullscreen mode
+\layout Standard
+
+Under SDL, xmame can switch to and from different modes during runtime:
+\layout Verbatim
+
+    Key combo:             Result:
+\layout Verbatim
+
+    left-alt + enter       Toggles between windowed and
+\layout Verbatim
+
+                           fullscreen modes.
+\layout Standard
+
+Under X11 in a window, you can also grab the mouse.
+ To be able to play with the mouse, press left-alt + page-down to grab the
+ mouse, and press it again to release it.
+\layout Subsection
+
+Why doesn't a game have sound?
+\layout Itemize
+
+First check that sound is working in other applications.
+\layout Itemize
+
+Check that sound is supported for the game that has no sound; not all games
+ have sound.
+\layout Itemize
+
+For xmame, take a look at gamelist.mame: Is the sound for the game emulated?
+\layout Itemize
+
+For xmess take a look at readme.mess: Is the sound for the system emulated?
+\layout Itemize
+
+Check the operating system support chart in the earlier part of  this file:
+ Does xmame/xmess support sound on your system?
+\layout Subsection
+
+My sound seems lagged.
+ / My sound Clicks.
+ / What does -bufsize do?
+\layout Standard
+
+With the 
+\family typewriter 
+-bufsize
+\family default 
+ commandline option or the bufsize configfile keyword, you can specify the
+ number of frames of audio to buffer.
+ The default is 2 frames.
+\layout Standard
+
+This value should be ok for everyone, but if you still have problems, read
+ on.
+\layout Standard
+
+If the buffersize is to small, this causes the buffer to get empty between
+ frames which in turn causes clicks/pauses in the sound.
+ If this is the case, increasing the -bufsize value to, for example, 2.5
+ should help.
+\layout Standard
+
+If, however, you make the buffersize too large, then so much audio becomes
+ buffered, that the sound could become lagged.
+ E.g., you would hear the coin drop sound 0.5 seconds after pressing the insert
+ coin key.
+ In this case, lower the bufsize to, for example, 1.5.
+\layout Standard
+
+Please let me know if you need to change this setting, since I'm planning
+ on removing it in a future release.
+\layout Subsection
+
+Why doesn't a game work? 
+\begin_inset LatexCommand \label{FAQ: Why doesn't a game work?}
+
+\end_inset 
+
+
+\layout Itemize
+
+Do you have the right roms or did you get checksum failures?
+\layout Itemize
+
+Xmame version 0.34 and higher require PROM files that were not included in
+ ROM images released before version 0.34.
+ See the question on PROMs  below for more information.
+\layout Itemize
+
+For xmame, check the file gamelist.mame to see if the game is playable.
+ Just because a game is included doesn't mean it is working yet.
+\layout Itemize
+
+For xmess, take a look at readme.mess.
+ Maybe the system isn't emulated all that well yet.
+\layout Itemize
+
+Some games require sound support.
+ If you don't have sound  support under your Unix installation or sound
+ isn't supported by xmame/xmess for you, try the 
+\family typewriter 
+-fakesound
+\family default 
+ command line parameter.
+\layout Subsection
+
+What are PROMs? 
+\begin_inset LatexCommand \label{FAQ: What are PROMs?}
+
+\end_inset 
+
+
+\layout Standard
+
+PROMs contain game-specific information that used to be built in  to mame
+ in versions prior to 0.34.
+ This information has been  extracted and is now included with new versions
+ of ROM files for  games that require this information.
+\layout Standard
+
+If you want to use your current ROM files, you can obtain just the PROM
+ images in one large file at:
+\layout Standard
+
+
+\begin_inset LatexCommand \url[http://mame.retrogames.com/]{http://mame.retrogames.com/}
+
+\end_inset 
+
+
+\layout Subsection
+
+Why is xmame/xmess slow?
+\layout Standard
+
+Xmame/xmess is a compiled C program that is emulating hardware.
+  Software emulation of hardware always incurs a speed penalty.
+ Here  are some things you can do:
+\layout Itemize
+
+Try using the -frameskip command line parameter.
+\layout Itemize
+
+Try pressing F8 while running xmame/xmess to alter the frame rate.
+\layout Itemize
+
+Try disabling the throttle with the -nothrottle command line  parameter
+ or by pressing F10 while running xmame/xmess.
+\layout Itemize
+
+While running xmame/xmess, press F11 to check the speed of xmame/xmess.
+  If you never get a display of 100%, you need a faster computer.
+\layout Standard
+
+You can also try recompiling xmame/xmess with more optimal settings.
+ The following suggestions may not work or may not be appropriate on some
+ machines and in some installations.
+  However, in cases where they do work, there can be a noticeable increase
+ in overall performance of xmame/xmess.
+\layout Standard
+
+These "enhancements" simply require editing the Makefile that is distributed
+ with xmame, and then recompiling the source.
+  If you are compiling the source for the second time you will need to do:
+\layout Verbatim
+
+    make clean
+\newline 
+    make
+\newline 
+    make install
+\layout Standard
+
+after editing the Makefile to set your new settings.
+\layout Subsubsection
+
+SPEEDUP # 1 - Inline compiling
+\layout Standard
+
+Try enabling inline compiling by commenting and uncommenting the following
+ lines:
+\layout Verbatim
+
+    # IL    = '-DINLINE=static inline'
+\newline 
+    IL     = -DINLINE=static
+\layout Subsubsection
+
+SPEEDUP # 2 - Direct Graphics Access
+\layout Standard
+
+For a big boost, try enabling DGA by uncommenting the following line:
+\layout Verbatim
+
+    DGA = 1
+\layout Standard
+
+Then start xmame as root, and press left-alt + home to switch to dga mode;
+ that should be a lot faster, and doesn't need/use xsync.
+ ;) 
+\layout Standard
+
+To get back to a window without exiting, press left-alt + insert.
+\layout Standard
+
+The benefit of DGA is that it is Direct Graphics Access and therefore writes
+ directly to the framebuffer (think DirectX versus GDI under MS Windows).
+ So it should be a tad faster, unless you've got a really really well accelerate
+d X server, which could be just as fast.
+ Try pressing F11 to see the actual framerate, although it might be hardly
+ noticable (visually, at least), it should give you some speed increase.
+\layout Standard
+
+Besides that, it automatically switches to the right mode and removes any
+ window manager stuff, but that can be done without DGA too.
+ (I might add such a feature later, since it allows easy fullscreen without
+ running as root.)
+\layout Standard
+
+Adding a 320x240 mode will most definitely get you a very nice fullscreen
+ display at scale = 1.
+ ;)
+\layout Standard
+
+Don't forget that you still need to set up the Modes line of the   "Display"
+ subsection of the "Screen" section in your X11 config file if you want
+ the games to fill the screen in DGA mode.
+ Xmame will pick the best mode it can find, so if you have a line like
+\layout Verbatim
+
+    Modes  "1024x768" "800x600" "640x480" "320x240" "256x224"
+\layout Standard
+
+then any game which fits into a 320x240 screen can be displayed in that
+ resolution, and so on.
+ Don't forget your X11 config file might have a number of different "Screen"
+ sections in it, and you will need to add Modes to the one that is actually
+ active with your Xserver is running.
+ And of course it's not always that easy, since you also need to tell X
+ which monitor settings are required for these resolution modes.
+ This is done through Modeline entries in the "Monitor" section of your
+ X config file.
+\layout Standard
+
+You can check out the 
+\family typewriter 
+/contrib/tools/modelines
+\family default 
+ file for a set of crazy modes made especially for xmame in DGA mode.
+ They should work on any reasonable multisync monitor, but don't use them
+ on an old fixed-frequency monitor.
+ (And if you can't resist trying, I won't pay for a new one!)
+\layout Subsubsection
+
+SPEEDUP # 3 - NASM
+\layout Standard
+
+You can also try installing nasm and compiling the asm core, that helps
+ a bit too.
+\layout Subsubsection
+
+SPEEDUP # 4 - ICC
+\layout Standard
+
+If you are running on an intel architecture machine, you could try to compile
+ xmame with the Intel C Compiler.
+ Some people have reported speed gains from +10%.
+\layout Subsection
+
+I've got a dual processor machine.
+ What can I do to take full advantage of this?
+\layout Standard
+
+Not much.
+ Xmame is a single-threaded port of a single-threaded DOS app.
+ Some degree of speedup will hopefully be found on an SMP machine since
+ xmame is more likely to get to hog its one CPU for longer.
+ But of course the same applies to any CPU-intensive program.
+ And all the things one would normally do to any application to give it
+ more CPU time (higher priority, kill or renice unecessary process, etc.)
+ will work with xmame.
+\layout Standard
+
+Now you may at this point be thinking, 
+\begin_inset Quotes eld
+\end_inset 
+
+Surely you could have one thread doing emulation and another thead doing
+ graphics to get a speedup.
+\begin_inset Quotes erd
+\end_inset 
+
+ Yes, but there are some serious issues to consider.
+ The first is synchronisation between the threads, which needs to be pretty
+ tight.
+ If not done smoothly.
+ the overhead will blow most of the benefit away.
+ Also, it needs to be implemented with a portable threads interface ...
+ which basically means POSIX threads.
+ In a nutshell, it's a lot of effort for probably not much gain.
+ But of course if you are feeling particulary energetic and in the mood
+ to code, then patches can always be submitted to the xmame devel mailing
+ list ...
+ :)
+\layout Subsection
+
+Why doesn't my joystick handle diagonal movement correctly on my Intel x86
+ system?
+\layout Standard
+
+Xmame/xmess uses autocalibrating, but you could try to use specific programs
+ to calibrate it (jscal that comes with joystick  module works fine....).
+\layout Subsection
+
+How do I enable XinputExtensions X11 based joystick in Xfree86?
+\layout Standard
+
+You need to edit XF86Config to enable the XInput section.
+ See the  manual page for XF86Config.
+\layout Subsection
+
+How do I read a manual page?
+\layout Standard
+
+Easy.
+ If you want to read the manual page for XF86Config, type: man XF86Config
+\layout Subsection
+
+Why do I get gz_open symbol not found while compiling? 
+\begin_inset LatexCommand \label{FAQ: Why do I get gz_open symbol not found while compiling?}
+
+\end_inset 
+
+
+\layout Standard
+
+Xmame/xmess versions newer than 0.35 use zlib for some compression routines.
+ Unfortunately, a lot of Linux distributions have an old version of zlib
+ installed as /usr/X11R6/lib/libz.a, and the new version installed as /usr/lib/li
+bz.a.
+ If this is the case, it's harmless to remove /usr/X11R6/lib/libz.a.
+ If you're not sure whether this is the case, just move /usr/X11R6/lib/libz.a
+ to another location.
+\layout Standard
+
+Removing or just moving /usr/X11R6/lib/libz.a should fix this problem.
+\layout Standard
+
+Also see: 
+\begin_inset LatexCommand \ref[FAQ: Why do I get zlib.h not found?]{FAQ: Why do I get zlib.h not found?}
+
+\end_inset 
+
+
+\layout Subsection
+
+Why do I get zlib.h not found? 
+\begin_inset LatexCommand \label{FAQ: Why do I get zlib.h not found?}
+
+\end_inset 
+
+
+\layout Standard
+
+Xmame/xmess versions newer than 0.35 use zlib for some compression routines.
+\layout Standard
+
+Zlib is standard on most Unix versions.
+ For those who don't ship with zlib or ship with a version that is too old,
+ xmame/xmess now comes with a stripped-down version of zlib.
+ Uncomment the appropriate line in the Makefile to use this.
+\layout Subsection
+
+When I run xmame.x11, nothing happens---no window pops up or anything.
+ Help!
+\layout Standard
+
+Are you running a recent version of KDE, such as 2.1.1? It appears that there's
+ a bug with KDE's window manager that prevents some X11 apps from popping
+ up their main window.
+ You can either run the SDL version of xmame, or try the following workaround,
+ which several people have reported as being successful:
+\layout Verbatim
+
+xmame.x11 -rid `xwininfo -root | grep xwininfo: | awk '{print $4}'`
+\layout Subsection
+
+Can I run xmame fullscreen?
+\layout Standard
+
+Yes, of course you can.
+ There are several ways to accomplish this, each with its own advantages
+ and disadvantages.
+\layout Standard
+
+To enable the fullscreen support, you will need to change some settings
+ in the makefile and recompile xmame.
+\layout Standard
+
+Besides the x11 and SDL drivers, the FX and GL drivers are also capable
+ of playing games full screen.
+ There is a separate chapter for these later on.
+\layout Subsubsection
+
+xmame.x11/DGA
+\layout Standard
+
+First, before recompiling, make sure you have an xserver with the 
+\begin_inset Quotes eld
+\end_inset 
+
+xfree-dga" extension enabled (do a 
+\begin_inset Quotes eld
+\end_inset 
+
+xdpyinfo
+\begin_inset Quotes erd
+\end_inset 
+
+ and see if you've got the 
+\begin_inset Quotes eld
+\end_inset 
+
+xfree-dga" extension); any recent release of XFree86 should have it.
+\layout Standard
+
+Select DISPLAY_METHOD = x11 and uncomment the line 
+\begin_inset Quotes eld
+\end_inset 
+
+DGA=1" in the makefile.
+\layout Standard
+
+Now build xmame and give the xmame.x11 file permanent root permissions so
+ that you don't need to start xmame as root (do a 
+\begin_inset Quotes eld
+\end_inset 
+
+chown root xmame.x11" and a 
+\begin_inset Quotes eld
+\end_inset 
+
+chmod u+s xmame.x11").
+\layout Standard
+
+If you want to start immediately in fullscreen mode, start xmame.x11 with
+ the "-x11 1" argument or specify "x11-mode 1" in your xmamerc file.
+\layout Standard
+
+During play you can switch between windowed and fullscreen mode.
+ See 
+\begin_inset LatexCommand \ref[What keys does xmame/xmess use?]{FAQ: What keys does xmame/xmess use?}
+
+\end_inset 
+
+
+\layout Subsubsection
+
+xmame.x11/Xv
+\layout Standard
+
+Xv is the X Window System video extension.
+ Among other things, it supports hardware scaling if your graphics card
+ (and X driver) is capable of doing so.
+ You can achieve a very nice fullscreen display without taxing your cpu
+ very much because the scaling will all be done by your video card.
+\layout Standard
+
+To determine if your video card supports the Xv extension, you may use this
+ command:
+\layout Verbatim
+
+xvinfo
+\layout Standard
+
+If you don't see a message indicating 
+\begin_inset Quotes eld
+\end_inset 
+
+no screens found
+\begin_inset Quotes erd
+\end_inset 
+
+, then the Xv extension is supported by your machine.
+\layout Standard
+
+To compile this into xmame, select DISPLAY_METHOD = x11 and uncomment the
+ line 
+\begin_inset Quotes eld
+\end_inset 
+
+X11_XV = 1
+\begin_inset Quotes erd
+\end_inset 
+
+ in the makefile.
+\layout Standard
+
+Build xmame, and use the -fullscreen parameter when loading a game to get
+ a nice fullscreen display.
+\layout Standard
+
+If the colors seem messed up and/or you only see half of the game image,
+ try using 
+\begin_inset Quotes eld
+\end_inset 
+
+-yuv
+\begin_inset Quotes erd
+\end_inset 
+
+ or 
+\begin_inset Quotes eld
+\end_inset 
+
+-yv12
+\begin_inset Quotes erd
+\end_inset 
+
+.
+ By default, the Xv extension attempts to use RGB mode if your driver supports
+ it, but some cards' drivers are broken.
+\layout Standard
+
+If your screen goes blank or gets full of little green vertical lines, then
+ your graphics card does not support the Xv extension and you're out of
+ luck.
+\layout Subsubsection
+
+xmame.SDL
+\layout Standard
+
+The SDL library was meant to make it easy for programmers to make full screen
+ applications.
+ To start SDL in fullscreen mode, just run xmame.SDL with the option '-fullscreen
+'.
+ If you want to know the resolutions that SDL can use, run 
+\begin_inset Quotes eld
+\end_inset 
+
+xmame.SDL -listmodes
+\begin_inset Quotes erd
+\end_inset 
+
+, choose the resolution you want, and start 
+\begin_inset Quotes erd
+\end_inset 
+
+xmame.SDL -modenumber <insert chosen number here>
+\begin_inset Quotes erd
+\end_inset 
+
+.
+\layout Standard
+
+You can add 
+\begin_inset Quotes eld
+\end_inset 
+
+fullscreen 1
+\begin_inset Quotes erd
+\end_inset 
+
+ to your xmamerc file if you want SDL to start fullscreen automatically;
+ the modenumber line can also be used in the xmamerc.
+ :-)
+\layout Standard
+
+Most problems experienced by people who are trying to use SDL for fullscreen
+ are related to the section 
+\begin_inset LatexCommand \ref[fullscreen has a large border]{FAQ: xmame.sdl / xmame.x11 fullscreen has a large border around the game.}
+
+\end_inset 
+
+
+\layout Standard
+
+During play you can switch between windowed and fullscreen mode.
+ See 
+\begin_inset LatexCommand \ref[What keys does xmame/xmess use?]{FAQ: What keys does xmame/xmess use?}
+
+\end_inset 
+
+
+\layout Subsection
+
+xmame.SDL / fullscreen has a large border around the game.
+ 
+\begin_inset LatexCommand \label{FAQ: xmame.sdl / xmame.x11 fullscreen has a large border around the game.}
+
+\end_inset 
+
+
+\layout Standard
+
+If the game runs in fullscreen but occupies only a small area in the center
+ of the screen, then your xserver does not have access to low resolutions
+ (320x240, 400x300, and 512x384, for instance).
+ In the case of SDL, the window will be in the resolution of closest matching
+ resolution that SDL can switch to for full screen display.
+\layout Standard
+
+In this case, you have to add "Modelines" for these resolutions in your
+ XF86config file and add these resolutions to the resolutions list of your
+ display somewhere in your XF86config file (you know, the list of resolutions
+ you can switch to using ctrl-+).
+\layout Standard
+
+You should find modelines that works with most graphic cards in the xmame
+ contrib subdirectory.
+\layout Standard
+
+If you don't want to alter your XF86config file, another solution is to
+ run xmame.x11 with the "-scale 2" argument.
+ In this case, the emulator will use 640x480 instead of 320x240, 800x600
+ instead of 400x300, etc.
+ But I don't recommend it.
+ The scaling uses cpu and the games will run more slowly.
+\layout Standard
+
+However, if your cpu is fast enough, a better option is to use the effects
+ 
+\begin_inset Quotes erd
+\end_inset 
+
+-ef 1
+\begin_inset Quotes erd
+\end_inset 
+
+.
+ This introduces advanced render methods to create a nicer looking effect
+ than the simple scaling.
+ On the website you can see 
+\begin_inset LatexCommand \url[screenshots]{http://x.mame.net/gamescreenshots.html}
+
+\end_inset 
+
+ of the different effects.
+\layout Subsection
+
+I only use some of the emulation parts (Neo Geo / CPS-2 /...).
+ Do I need the entire xmame? 
+\layout Standard
+
+If you are interested in compiling only some of the games you, can compile
+ xmame with an alternate target.
+ Edit the makefile.unix and change the target line to accomplish the desired
+ effect.
+ Using this approach, only the CPUs, sound devices, and other chips needed
+ for that particular target are compiled, resulting in a much smaller executable.
+\layout Itemize
+
+'TARGET = cpmame' makes a mame version that will only emulate the CPS-1
+ and CPS-2 games
+\layout Itemize
+
+'TARGET = neomame' makes a mame version that will only emulate the Neo Geo
+ system
+\layout Standard
+
+There are some other targets but they are really only useful for the mame
+ developers who create new drivers.
+\layout Subsection
+
+Why does xmame freeze and lock up when I hit <ESC> to exit the game or P
+ to pause the game?
+\layout Standard
+
+There appears to be a bug in the "timer based audio" code that xmame/oss
+ uses on at least one motherboard that we are aware of.
+ Specifically, the ATX 845Pro (Intel Pentium 4 processor) with an integrated
+ i810 soundchip.
+\layout Standard
+
+To get around this bug use EsounD (Enlightened Sound Daemon), found as esd
+ with Gnome distributions, instead of the oss sound drivers.
+\layout Standard
+
+Compile ESOUND support into the xmame executable by uncommenting the appropriate
+ line in makefile.unix.
+ Tell xmame to use esound by specifying "esound" on the "dsp-plugin" line
+ in xmamerc, or use the -dp command line parameter to select esound.
+ Also see the next section below.
+\layout Subsection
+
+Why does xmame report "can't resolve host name '/dev/dsp' when trying to
+ use esound?
+\layout Standard
+
+Remove the words "/dev/dsp" from the "audiodevice" line in xmamerc.
+ In other words, you want to have the word "audiodevice" on a line all by
+ itself, with no audiodevice specified.
+\layout Subsection
+
+Where can I get the latest version of xmame/xmess?
+\layout Standard
+
+The xmame/xmess Home Page always has the most up-to-date version.
+ The address is
+\layout Standard
+
+
+\begin_inset LatexCommand \url[http://x.mame.net/]{http://x.mame.net/}
+
+\end_inset 
+
+
+\layout Subsection
+
+I upgraded xmame and now some games do not work anymore.
+\layout Standard
+
+This can happen, especially if the drivers are in full development or some
+ internal core routines have changed and the drivers have to be updated
+ to accomodate for these core changes.
+ Sometimes a new romdump has been made from the game and you still have
+ the old version, or the zipfile has changed names and you need to rename
+ yours (or any combination of these factors :-).
+\layout Standard
+
+Here are some things you can do:
+\layout Enumerate
+
+Clear all the old configuration files, nvram files, etc.
+ Also delete the content of the directories mem, nvram, cfg, and try to
+ run the game again.
+ Don't forget to delete the default.cfg file!
+\layout Enumerate
+
+If that fails, check to see if the name of the zipfile is still in the list
+ of supported games.
+ If you enter an invalid game name, xmame will take a guess to determine
+ which game you wanted; look at the first lines of output to see if it tries
+ to load a different game than the one you want.
+ To know if your game is still supported, try 'xmame.x11 -list gamename'.
+ If you do not pass a game name, the complete list of supported games is
+ printed, and you can search for the new game name (better use 'xmame.x11
+ -listfull').
+\layout Enumerate
+
+If the name hasn't changed, check to see if you have the correct romdump.
+ Run 'xmame.x11 -verifyroms gamename' to check your romset.
+ If this fails you will need to download a newer romdump.
+ Also check your parent roms as a possible cause of this romset failure.
+\layout Enumerate
+
+Read the documentation!! Or like the experts would say, 
+\begin_inset Quotes eld
+\end_inset 
+
+RTFM!
+\begin_inset Quotes erd
+\end_inset 
+
+ :-) Chances are that if the driver is broken, the developer has noted this
+ in the documentation.
+\layout Enumerate
+
+If the above steps don't solve the problem, then check to see if it is a
+ known problem; if necessary, report it to the mame testers project.
+\layout Standard
+
+If none of these fixes the problem, then try using the older version of
+ xmame you have backed up somewhere to play the game.
+ (You did back-up, didn't you?)
+\layout Subsection
+
+Where can I send fixes, bug reports, suggestions, or money?  :-)
+\layout Standard
+
+See 
+\begin_inset LatexCommand \ref[Mail]{Mail}
+
+\end_inset 
+
+ of this document.
+\layout Subsection
+
+What if my question is still not answered?
+\layout Standard
+
+Please check the offical mame and mess readme files to see if that answers
+ your question:
+\layout Itemize
+
+
+\begin_inset LatexCommand \url[The official mame readme file (readme.mame)]{readme.mame}
+
+\end_inset 
+
+
+\layout Itemize
+
+
+\begin_inset LatexCommand \url[The official mess readme file (readme.mess)]{readme.mess}
+
+\end_inset 
+
+
+\layout Standard
+
+If that doesn't help, then ask your question on the mailing list or send
+ it to the xmame/xmess maintainer, see  
+\begin_inset LatexCommand \ref[Mail]{Mail}
+
+\end_inset 
+
+ for contact information.
+\layout Section
+
+Display Subsystem-Specific Comments and Notes 
+\begin_inset LatexCommand \label{Display subsystem specific comments and notes}
+
+\end_inset 
+
+
+\layout Subsection
+
+FXmame, a glide driver for xmame
+\layout Standard
+
+The latest version of this driver can be obtained at 
+\begin_inset LatexCommand \url[http://glmame.linuxgames.com]{http://glmame.linuxgames.com}
+
+\end_inset 
+
+.
+\layout Subsubsection
+
+Requirements
+\layout Standard
+
+To run FXmame, you must have:
+\layout Itemize
+
+A 3Dfx card
+\layout Itemize
+
+Glide 2x
+\layout Itemize
+
+The xmame distribution
+\layout Subsubsection
+
+Compiling and Installing
+\layout Standard
+
+FXmame comes in two flavours---xfx and svgafx.
+ The xfx version is designed to run under X11.
+ It uses an X window for input.
+ The svgafx version runs from the console, and uses svgalib for input.
+ Both use the 3Dfx hardware for rendering.
+\layout Standard
+
+To install FXmame, follow the general instructions for installing xmame.
+ To specify the glide driver, do the following to the Makefile:
+\layout Itemize
+
+Select either "xfx" or "svgafx" as your display method
+\layout Itemize
+
+Configure the glide variables to correspond to your glide setup
+\layout Standard
+
+The FXmame executables are called "xmame.xfx" and "xmame.svgafx"
+\layout Subsubsection
+
+Running
+\layout Standard
+
+FXmame runs with the same parameters and uses the same keyboard commands
+ that xmame.x11 does.
+\layout Standard
+
+A few extra keyboard commands have been added in the glide driver:
+\layout Itemize
+
+RIGHTCTRL-A -- toggle antialiasing in vector games 
+\layout Itemize
+
+RIGHTCTRL-B -- toggle bilinear filtering
+\layout Standard
+
+The glide driver also adds several command-line options:
+\layout Verbatim
+
+    -fxgama <value> 3Dfx gamma correction value
+\layout Standard
+
+Note that in order to display the game options or the fps display in vector
+ games, I have to overlay the game bitmap over the vector display.
+ This is because I circumvent the bitmap entirely in vector games.
+ Drawing the bitmap is a big cpu hog, so you'll notice that the game slows
+ down when you turn on the fps display (I know, not ideal when you want
+ to find out the frame rate...).
+\layout Subsubsection
+
+Common Questions (FAQ)
+\layout Standard
+
+Q: When I run FXmame, it just dumps core.
+\layout Standard
+
+A: Make sure you are running FXmame as root.
+ Root privileges are required to access the 3Dfx hardware
+\layout Standard
+
+Q: When I run xmame.xfx, it just hangs at the initial game screen.
+\layout Standard
+
+A: Are you running KDE? For some reason, I can't get keyboard input under
+ KDE.
+ If you have this problem, switch window managers or use xmame.svgafx instead.
+\layout Subsubsection
+
+Present Limitations/Bugs
+\layout Itemize
+
+Antialiasing isn't working quite as well as it should
+\layout Itemize
+
+Input problems under KDE
+\layout Subsubsection
+
+Future Work
+\layout Itemize
+
+Optimize the drawing code to update only the changed portions of the game
+ bitmap.
+\layout Subsubsection
+
+License
+\layout Standard
+
+The FXmame code is Copyright 1998 by Mike Oliphant.
+ It may be used and distributed under the terms of the MAME license.
+\layout Subsubsection
+
+Version History
+\layout Standard
+
+v0.5 -- December 11th, 1998 ---------------------------
+\layout Itemize
+
+implemented long copies in screen update
+\layout Itemize
+
+added dirty handling.
+ this greatly increases the speed of games that support the dirty update
+ strategy (although most of them are older games that already ran at full
+ speed on modern hardware)
+\layout Itemize
+
+merged source with xmame b8.1
+\layout Standard
+
+v0.4 -- October 30th, 1998 --------------------------
+\layout Itemize
+
+improved alpha handling in vector games - now bitmapped overlays do not
+ dim the screen o added svgalib support (xmame.svgafx) o fixed a tiling bug
+ that gave artifacts on texture tile boundaries
+\layout Standard
+
+v0.3 -- October 29th, 1998 --------------------------
+\layout Itemize
+
+got rid of extra lines in vector games o added bitmap overlay in vector
+ games to show options/fps o added antialiasing in vector games
+\layout Standard
+
+v0.2 -- October 28th, 1998 --------------------------
+\layout Itemize
+
+added screenshots o added 3Dfx gamma adjustment o added direct acceleration
+ of vector games (still buggy)
+\layout Standard
+
+v0.1 -- October 27th, 1998 --------------------------
+\layout Itemize
+
+first public release
+\layout Subsubsection
+
+Author
+\layout Standard
+
+Mike Oliphant 
+\family typewriter 
+
+\begin_inset LatexCommand \url[(oliphant@ling.ed.ac.uk)]{mailto:oliphant@ling.ed.ac.uk}
+
+\end_inset 
+
+
+\family default 
+ 
+\begin_inset LatexCommand \url[http://glmame.linuxgames.com]{http://glmame.linuxgames.com}
+
+\end_inset 
+
+
+\layout Subsection
+
+GLmame, an OpenGL driver for xmame
+\layout Standard
+
+The latest version of this driver can be obtained at: 
+\begin_inset LatexCommand \url[http://www.jausoft.com/glmame.html]{http://www.jausoft.com/glmame.html}
+
+\end_inset 
+
+
+\layout Subsubsection
+
+Requirements
+\layout Standard
+
+To run GLmame you must have:
+\layout Itemize
+
+An OpenGL implementation
+\layout Itemize
+
+libjpeg
+\layout Itemize
+
+hardware 3D acceleration (if you want any kind of framerate)
+\layout Itemize
+
+the xmame distribution
+\layout Subsubsection
+
+Compiling and Installing
+\layout Standard
+
+Follow the general instructions for installing xmame.
+ To specify the OpenGL driver, do the following in the Makefile:
+\layout Itemize
+
+Select "xgl" as your display method.
+\layout Itemize
+
+For runtime printed debug info, add 
+\begin_inset Quotes eld
+\end_inset 
+
+-DGLDEBUG
+\begin_inset Quotes erd
+\end_inset 
+
+ to the 
+\begin_inset Quotes eld
+\end_inset 
+
+GLCFLAGS" variable.
+\layout Itemize
+
+GLU version 1.2 is recommended (e.g., from SGI).
+ If you use Mesa's GLU, you may have to add 
+\begin_inset Quotes eld
+\end_inset 
+
+-DGLU_VERSION_1_2
+\begin_inset Quotes erd
+\end_inset 
+
+ to the 
+\begin_inset Quotes eld
+\end_inset 
+
+GLCFLAGS
+\begin_inset Quotes erd
+\end_inset 
+
+.
+\layout Standard
+
+The GLmame executable is called "xmame.xgl".
+\layout Subsubsection
+
+Running
+\layout Standard
+
+xmame.xgl runs with the same parameters and uses the same keyboard commands
+ that xmame.x11 does.
+\layout Standard
+
+The program starts up in cabinet mode.
+ While this is pretty, and cool, you'll probably want to actually play in
+ fullscreen mode.
+\layout Standard
+
+A few extra keyboard commands have been added in the OpenGL driver:
+\layout Itemize
+
+RIGHT_ALT-A -- toggle antialias filtering (vector)
+\layout Itemize
+
+RIGHT_ALT-B -- toggle bilinear filtering (raster)
+\layout Itemize
+
+RIGHT_ALT-C -- toggle cabinet/fullscreen display (both)
+\layout Itemize
+
+RIGHT_ALT-F -- toggle between fullscreen (max window size) and startup window
+ size (both)
+\layout Itemize
+
+RIGHT_ALT-O -- toggle draw-bitmap (both; nonsense for raster games, speedup
+ for vector games)
+\layout Itemize
+
+RIGHT_ALT-T -- toggle phosphor trails (vector)
+\layout Itemize
+
+RIGHT_ALT-PLUS_PAD -- incr.
+ beam size (vector)
+\layout Itemize
+
+RIGHT_ALT-MINUS_PAD -- decr.
+ beam size (vector)
+\layout Standard
+
+The OpenGL driver also adds several command-line options:
+\layout Verbatim
+
+    -[no]fullscreen         Start in fullscreen mode
+\layout Verbatim
+
+                            (default: disabled)
+\layout Verbatim
+
+\layout Verbatim
+
+    -[no]gldblbuffer        Disable/enable double buffering
+\layout Verbatim
+
+                            (default: enabled)
+\layout Verbatim
+
+\layout Verbatim
+
+    -gltexture_size <int>   Force the max width and height of one 
+\layout Verbatim
+
+                            texture segment (default: autosize)
+\layout Verbatim
+
+\layout Verbatim
+
+    -[no]glforceblitmode /  Force blitter for true color modes 15/32bpp
+\layout Verbatim
+
+    -[no]glblit             (default: enabled)
+\layout Verbatim
+
+\layout Verbatim
+
+    -[no]glext78 /          Force the usage of GL extension number 78,
+\layout Verbatim
+
+    -[no]glext              if available (palletted texture)
+\layout Verbatim
+
+                            (default: enabled)
+\layout Verbatim
+
+\layout Verbatim
+
+    -[no]glbilinear /       Disable/enable bilinear filtering
+\layout Verbatim
+
+    -[no]glbilin            (default: enabled)
+\layout Verbatim
+
+\layout Verbatim
+
+    -[no]gldrawbitmap /     Disable/enable drawing the bitmap; e.g., 
+\layout Verbatim
+
+    -[no]glbitmap           disable within vector games for a speedup
+\layout Verbatim
+
+                            (default: enabled)
+\layout Verbatim
+
+\layout Verbatim
+
+    -[no]glcolormod         Disable/enable color modulation (intensity,
+\layout Verbatim
+
+    -[no]glcmod             gamma)
+\layout Verbatim
+
+                            (default: enabled)
+\layout Verbatim
+
+\layout Verbatim
+
+    -glbeam <float>         Set the beam size for vector games
+\layout Verbatim
+
+                            (default: 1.0)
+\layout Verbatim
+
+\layout Verbatim
+
+    -[no]glalphablending /  Disable/enable alpha blending if available
+\layout Verbatim
+
+    -[no]glalpha            (default: enabled)
+\layout Verbatim
+
+\layout Verbatim
+
+    -[no]glantialias /      Disable/enable antialiasing
+\layout Verbatim
+
+    -[no]glaa               (default: enabled)
+\layout Verbatim
+
+\layout Verbatim
+
+    -gllibname /            Choose the dynamically loaded OpenGL
+\layout Verbatim
+
+    -gllib <string>         library
+\layout Verbatim
+
+                            (default: libGL.so)
+\layout Verbatim
+
+\layout Verbatim
+
+    -glulibname /           Choose the dynamically loaded GLU library
+\layout Verbatim
+
+    -glulib <string>        (default: libGLU.so)
+\layout Verbatim
+
+\layout Verbatim
+
+    -[no]cabview            Don't start/start in cabinet view mode
+\layout Verbatim
+
+                            (default: don't start in this mode)
+\layout Verbatim
+
+\layout Verbatim
+
+    -cabinet <cabname>      Specify which cabinet model to use
+\layout Verbatim
+
+                            (default: glmamejau)
+\layout Verbatim
+
+ 
+\layout Verbatim
+
+   -glres <string>          Always scale games to <Xres>x<Yres>, 
+\layout Verbatim
+
+                            keeping their aspect ratio.
+ 
+\layout Verbatim
+
+                            This overrides the scale options.
+\layout Verbatim
+
+                            Use this e.g.
+ for the Vodoo1 gfx cards
+\layout Verbatim
+
+                            with: "-glres 640x480"
+\layout Verbatim
+
+\layout Verbatim
+
+\layout Verbatim
+
+\layout Standard
+
+Three cabinet models are provided.
+ The default, "glmamejau", is designed to look like a standard arcade cabinet,
+ like "glmame".
+ The last one, "trans", is a box with a transparent game screen.
+\layout Standard
+
+Note that in order to display the game options or the fps display in vector
+ games, the game's bitmap is overlaid above the vector display.
+ Drawing the bitmap is a big cpu hog for some low-end hardware accelerated
+ OpenGL implementations, so you'll notice that the game slows down when
+ the bitmap is overlaid.
+\layout Standard
+
+Because bitmap overlaying is the default, you can toggle it on and off by
+ pressing the "RIGHT_ALT-O" key, or turn it off at startup by using the
+ command line option "-noglbitmap".
+\layout Standard
+
+A problem with vector games and the cabinet mode is that some vector points
+ do not reside within the screen coordinates, so you may see some vectors
+ outside of the cabinet's mame display.
+\layout Standard
+
+
+\series bold 
+*** IMPORTANT! ***
+\layout Standard
+
+If you have trouble with GLmame, or it is slow, read the "Common Questions"
+ section.
+ Most of the questions people email me are answered here.
+\layout Subsubsection
+
+Cabinet Models
+\layout Standard
+
+Cabinet model information is stored in the "cab" subdirectory of the directory
+ you specified with the ROMPATH variable in the Makefile.
+ Path information specified in xmamerc or with the 'rompath' shell environment
+ variable is currently not used.
+ Each cabinet model has it's own subdirectory.
+ GLmame will first try to load either the user-specified cabinet model (using
+ the -cabinet command-line option), or a model corresponding to the current
+ game name.
+ Failing that, it will use the generic "glmame" model.
+\layout Standard
+
+A cabinet model directory must contain a geometry file <modelname>.cab, and
+ any .jpg files used for textures on the model.
+ The format of the .cab file will be familiar if you have ever programmed
+ using OpenGL -- it looks much like an OpenGL display list.
+ The format is as follows:
+\layout Verbatim
+
+    cabv1.1
+\layout Standard
+
+This header must be the first 7 characters of the file.
+\layout Verbatim
+
+    #<text>
+\layout Standard
+
+Comment lines begin with '#'
+\layout Verbatim
+
+    begin <type>
+\layout Standard
+
+Begins a geometry object, where type is one of (points, polygon, quads,
+ quad_strip, screen).
+ Each "begin" must be paired with an "end" statement.
+ A "polygon" is specified using one vertex per, well...
+ vertex.
+ "quads" are four-sided polygons, each specified by four vertices in order
+ around the polygon.
+ A "quad_strip" is a series of four-sided polygons, each of which shares
+ an edge with the polygons before and after it in the strip.
+ A "screen" is a quad that defines the actual area in 3D space where the
+ game will be displayed.
+ only one of these should be defined.
+ For more info, look at any description of OpenGL geometry.
+\layout Verbatim
+
+    end
+\layout Standard
+
+Ends the geometry object begun with "begin".
+\layout Verbatim
+
+    pointsize <s>
+\layout Standard
+
+Changes the current pointsize to the corresponding size value (specified
+ as a floating point number between 0.0 and, e.g., 20.0).
+ Note: You cannot use this statement between begin and end!
+\layout Verbatim
+
+    color4 <r> <g> <b>
+\layout Standard
+
+Changes the current color to the corresponding rgb value (specified as floating
+ point numbers between 0 and 1).
+\layout Verbatim
+
+    color4 <r> <g> <b> <a>
+\layout Standard
+
+Changes the current color to the corresponding rgba value (specified as
+ floating point numbers between 0 and 1).
+\layout Verbatim
+
+    shading <type>
+\layout Standard
+
+Sets the shading type.
+ available types are "smooth" (which blends colors from one vertex to the
+ next) or "flat" (which doesn't).
+\layout Verbatim
+
+    vertex <x> <y> <z>
+\layout Standard
+
+Specifies a vertex for the current geometry object as a point in 3-space.
+\layout Verbatim
+
+    numtex <num>
+\layout Standard
+
+Specifies the number of different textures to be loaded.
+ This declaration must precede any "loadtex" call.
+\layout Verbatim
+
+    loadtex <num> <width> <height> <filename>
+\layout Standard
+
+Loads texture number <num> from .jpg file <filename>.
+ The .jpg file *must* be <width> by <height> pixels, and both <width> and
+ <height> must be powers of two (and must conform to the hardware requirements
+ of any 3D card you want the cabinet to work with -- 256x256 for 3Dfx).
+\layout Verbatim
+
+    texcoord <xcoord> <ycoord>
+\layout Standard
+
+Sets the texture coordinate of the next vertex.
+ This specifies where in 2D texture space the vertex lies.
+\layout Verbatim
+
+    enable texture
+\layout Standard
+
+Enables texture mapping (using the currently-selected texture).
+\layout Verbatim
+
+    disable texture
+\layout Standard
+
+Turns off texture mapping.
+\layout Verbatim
+
+    settex <num>
+\layout Standard
+
+Select texture <num> for doing texturing.
+ The texture must previously have been loaded using "loadtex".
+\layout Verbatim
+
+    camerapan <num>
+\layout Standard
+
+Starts the camera pan definition that will be followed by <num> camera transisti
+ons.
+ After the last transision definition, the pan sequence must be ended with
+ an "end" statement.
+\layout Verbatim
+
+    goto <lx> <ly> <lz> <px> <py> <pz> <nx> <ny> <nz>
+\layout Standard
+
+Relocates and reorients the camera.
+ The arguments are the same as are used by the OpenGL command "gluLookAt()".
+ The camera is positioned at point <lx,ly,lz>, pointing along vector <px,py,pz>,
+ with "up" normal (the direction that is "up" for the camera) <nx,ny,nz>.
+\layout Verbatim
+
+    moveto <lx> <ly> <lz> <px> <py> <pz> <nx> <ny> <nz> <frames>
+\layout Standard
+
+Moves the camera to a new location (specified as in "goto").
+ The transition occurs over <frames> frames.
+\layout Standard
+
+All commands must be on separate lines.
+ Use the (somewhat) commented glmamejau cabinet as an example to work from.
+\layout Subsubsection
+
+Common Questions (FAQ)
+\layout Standard
+
+Q: I am only getting a few frames-per-second.
+ This sucks! What gives? 
+\layout Standard
+
+A1: You're probably running Mesa in software mode.
+ You should read the "README.3Dfx" file in the Mesa distro.
+ Specifically, you need to "setenv MESA_GLX_FX fullscreen".
+\layout Standard
+
+A2: You don't have a 3D graphics card.
+ Go buy one (see below)!
+\layout Standard
+
+Q: When I run xmame.xgl, it just dumps core.
+ That's not as much fun as 3D Pacman, now is it?
+\layout Standard
+
+A1: If you are using a 3Dfx card, make sure you are running xmame.xgl as
+ root.
+ Root privileges are required to access the 3Dfx hardware.
+\layout Standard
+
+A2: If you're using Mesa and haven't upgraded to v3.0, do so.
+ 
+\layout Standard
+
+Q: When I run xmame.xgl, it just hangs at the initial game screen.
+\layout Standard
+
+A: Are you running KDE? For some reason, I can't get keyboard input under
+ KDE.
+ If you have this problem, switch window managers.
+\layout Standard
+
+Q: Which graphics cards are usable with xmame.xgl? 
+\layout Standard
+
+A: We have the following experiences (date 20010713):
+\layout Itemize
+
+Vodoo3 + DRI OpenGL driver (XFree86 4.0.2), with command line options "-noglaa"
+ and 16bpp X11 server color depth.
+\layout Itemize
+
+Vodoo1 + Mesa 3.4 + Glide, with command line options 
+\begin_inset Quotes eld
+\end_inset 
+
+-glres 640x480
+\begin_inset Quotes erd
+\end_inset 
+
+!
+\layout Itemize
+
+GeForce + NVIDIA OpenGL driver + XFree86 4.0.2 with default command line options
+ and 16/24bpp X11 server color depth.
+\layout Itemize
+
+NVIDIA TNT2 + NVIDIA OpenGL driver + XFree86 4.0.2 with command line options
+ "-bpp 16" and 16bpp (may be 24bpp also ???) X11 server color depth (OpenGL
+ colortable mapping is buggy).
+\layout Itemize
+
+NVIDIA TNT + NVIDIA OpenGL driver + XFree86 4.0.2 with command line options
+ "-bpp 16" and 16bpp (may be 24bpp also ???) X11 server color depth (OpenGL
+ colortable mapping is buggy).
+\layout Itemize
+
+Matrox MGA 400 + DRI OpenGL driver (XFree86 4.0.2) with command line options
+ "-bpp 16", "-noglaa" (???) and 16bpp (may be 24bpp also ???) X11 server
+ color depth (OpenGL colortable mapping is buggy).
+\layout Itemize
+
+ATI R128 + DRI OpenGL driver (XFree86 4.1.0) with command line options 
+\begin_inset Quotes eld
+\end_inset 
+
+-noglext78 -noglaa
+\begin_inset Quotes erd
+\end_inset 
+
+ or 
+\begin_inset Quotes eld
+\end_inset 
+
+-bpp 16 -noglaa
+\begin_inset Quotes erd
+\end_inset 
+
+, where the latter options are a bit slower (about 5 fps).
+ 
+\layout Itemize
+
+LinuxPPC - Powerbook-Firewire + ATI R128: see above!
+\layout Standard
+
+All of the above drivers work with the option "-bpp 16" and/or "-noglext78",
+ the latter of which is very slow, of course! So it looks like an OpenGL
+ implementation bug is causing these driver/hardware combinations to only
+ work with these command line options.
+ The bug may lie within these OpenGL functions:
+\layout Itemize
+
+glColorTableEXT 
+\layout Itemize
+
+glColorSubTableEXT
+\layout Standard
+
+Currently fast and funny driver/hardware combinations are:
+\layout Itemize
+
+NVIDIA GeForce + NVIDIA OpenGL driver + XFree86 4.0.2; I have tested the GeForce25
+6 (AGP) hardware.
+ 
+\layout Itemize
+
+Vodoo + DRI OpenGL driver (XFree86 4.0.2); I have tested the Vodoo3 hardware.
+\layout Standard
+
+Q: When I run xmame.xgl, everything is messed up.
+\layout Standard
+
+A: Read the above experiences ...
+ and try
+\layout Itemize
+
+switching your X server's bpp value, e.g.
+ switch from 32bpp or 24bpp to 16bpp; 
+\layout Itemize
+
+the command line option "-bpp 16";
+\layout Itemize
+
+the command line option "-noglaa";
+\layout Itemize
+
+the command line option "-noglext".
+\layout Subsubsection
+
+Present Limitations/Bugs
+\layout Itemize
+
+No clipping of vector games (most noticeable in cabinet mode).
+\layout Itemize
+
+No preservation of game aspect ratio in cabinet mode.
+\layout Subsubsection
+
+Future Work
+\layout Itemize
+
+Fixing existing bugs ..
+ are there any ? Or are there some unknown features only ;-) ? 
+\layout Itemize
+
+Optimize the drawing code to update only the changed portions of the game
+ bitmap.
+ Optimizing the dirty code ..
+\layout Subsubsection
+
+License
+\layout Standard
+
+The GLmame code is based upon Mike Oliphant's GLmame code version 0.6.
+ 
+\layout Standard
+
+The GLMame code is Copyright 1998 by Mike Oliphant.
+ It may be used and distributed under the terms of the MAME license.
+ 
+\layout Standard
+
+Since GLmame version 0.7, the code has been changed and improved heavily
+ by Sven Goethel --- no license change, of course!
+\layout Subsubsection
+
+Version History
+\layout Standard
+
+v0.83 -- March 29th, 2001 ---------------------------
+\layout Itemize
+
+Changed the code heavily to improve compatibility and speed.
+ The new code is a re-merge of the GLMame32 code, which is a branch of Mike
+ Oliphant's GLmame code version 0.6.
+ 
+\layout Itemize
+
+For a detailed list, please consult the file changes.opengl within the distributi
+on's documentation directory! You can also view the current changes.opengl
+ here: 
+\begin_inset LatexCommand \url[http://www.jausoft.com/glmame.html]{http://www.jausoft.com/glmame.html}
+
+\end_inset 
+
+
+\layout Standard
+
+v0.6 -- December 14th, 1998 ---------------------------
+\layout Itemize
+
+added support for systems that do not support paletted textures (SGI and
+ solaris OpenGL implementations, for example)
+\layout Itemize
+
+merged source with xmame b8.1
+\layout Standard
+
+v0.5 -- October 30th, 1998 --------------------------
+\layout Itemize
+
+fixed a bug with texturing being left on in bad places
+\layout Itemize
+
+added 3Dfx gamma adjustment
+\layout Standard
+
+v0.4 -- October 21st, 1998 --------------------------
+\layout Itemize
+
+updated to work with xmame v0.34b5.2
+\layout Standard
+
+v0.3 -- October 12th, 1998 --------------------------
+\layout Itemize
+
+fixed verticle screen centering in fullscreen mode
+\layout Itemize
+
+moved cabinet and camera panning information into a user-editable configuration
+ file
+\layout Itemize
+
+added 'trans' cabinet model o added double buffer, view type, and cabinet
+ selection command-line options
+\layout Standard
+
+v0.2 -- October 6th, 1998 -------------------------
+\layout Itemize
+
+adding missing 'cab' directory
+\layout Standard
+
+v0.1 -- October 5th, 1998 -------------------------
+\layout Itemize
+
+first public release
+\layout Subsubsection
+
+Authors
+\layout Standard
+
+Since GLmame version 0.7: Sven Goethel 
+\begin_inset LatexCommand \url[(sgoethel@jausoft.com)]{mailto:sgoethel@jausoft.com}
+
+\end_inset 
+
+ 
+\begin_inset LatexCommand \url[http://www.jausoft.com/glmame.html]{http://www.jausoft.com/glmame.html}
+
+\end_inset 
+
+
+\layout Standard
+
+Till GLmame version 0.6: Mike Oliphant 
+\family typewriter 
+
+\begin_inset LatexCommand \url[(oliphant@ling.ed.ac.uk)]{mailto:oliphant@ling.ed.ac.uk}
+
+\end_inset 
+
+
+\family default 
+ 
+\begin_inset LatexCommand \url[http://glmame.linuxgames.com]{http://glmame.linuxgames.com}
+
+\end_inset 
+
+
+\layout Section
+
+Contact Information and Credits
+\layout Subsection
+
+Mail 
+\begin_inset LatexCommand \label{Mail}
+
+\end_inset 
+
+
+\layout Standard
+
+There is an official xmame/xmess mailing list.
+ All operations related to this list are performed via email to 
+\family typewriter 
+
+\begin_inset LatexCommand \url[Xmame-request@toybox.twisted.org.uk]{mailto:Xmame-request@toybox.twisted.org.uk}
+
+\end_inset 
+
+
+\layout Itemize
+
+To subscribe, send mail to: 
+\begin_inset LatexCommand \url[Xmame-request@toybox.twisted.org.uk]{mailto:Xmame-request@toybox.twisted.org.uk}
+
+\end_inset 
+
+ with the keyword "subscribe" in the body.
+ 
+\layout Itemize
+
+To unsubscribe, send a mail to: 
+\begin_inset LatexCommand \url[Xmame-request@toybox.twisted.org.uk]{mailto:Xmame-request@toybox.twisted.org.uk}
+
+\end_inset 
+
+ with the keyword "unsubscribe" in the body.
+\layout Itemize
+
+To change your subscription, get a password reminder, etc., go to 
+\begin_inset LatexCommand \url[http://toybox.twisted.org.uk/mailman/listinfo/xmame]{http://toybox.twisted.org.uk/mailman/listinfo/xmame}
+
+\end_inset 
+
+.
+\layout Itemize
+
+To send mail to the list, use: 
+\begin_inset LatexCommand \url[xmame@toybox.twisted.org.uk]{mailto:xmame@toybox.twisted.org.uk}
+
+\end_inset 
+
+ 
+\layout Itemize
+
+To ask specific questions about the xmame mailing list, send mail to: 
+\begin_inset LatexCommand \url[Xmame-request@toybox.twisted.org.uk]{mailto:Xmame-request@toybox.twisted.org.uk}
+
+\end_inset 
+
+
+\layout Standard
+
+If you're just curious, and only want to take a look at the mailing list
+ without subscribing, you can use the web-based archive at 
+\begin_inset LatexCommand \url[http://www.mail-archive.com/xmame%40toybox.twisted.org.uk/]{http://www.mail-archive.com/xmame%40toybox.twisted.org.uk/}
+
+\end_inset 
+
+ or 
+\begin_inset LatexCommand \url[http://toybox.twisted.org.uk/pipermail/xmame/]{http://toybox.twisted.org.uk/pipermail/xmame/}
+
+\end_inset 
+
+.
+ (The latter was activated on 5 January 2002.) To read even older messages,
+ see 
+\begin_inset LatexCommand \url[http://www.mail-archive.com/xmame@locutus.csres.utexas.edu]{http://www.mail-archive.com/xmame@locutus.csres.utexas.edu}
+
+\end_inset 
+
+.
+\layout Standard
+
+To ask UNIX-specific xmame/xmess questions, you could send mail to: 
+\begin_inset LatexCommand \url[Lawrence's folder]{mailto:gold@aros.net}
+
+\end_inset 
+
+, but you're better off sending mail to the list.
+ 
+\layout Standard
+
+To ask general questions about MAME, send mail to: Mirko (Mix) Buffoni
+\begin_inset LatexCommand \url[Mirko (Mix) Buffoni]{mailto:mix@lim.dsi.unimi.it}
+
+\end_inset 
+
+ 
+\layout Standard
+
+Also see (and post) articles on USENET group 
+\begin_inset LatexCommand \url[comp.emulators.misc]{news:comp.emulators.misc}
+
+\end_inset 
+
+comp.emulators.misc\SpecialChar ~
+
+\layout Standard
+
+with a proper keyword in the body.
+\layout Standard
+
+Other proper keywords currently recognized as commands by 
+\begin_inset LatexCommand \url[Xmame-request@toybox.twisted.org.uk]{mailto:Xmame-request@toybox.twisted.org.uk}
+
+\end_inset 
+
+ are:
+\layout Verbatim
+
+    who             - see everyone who is on the list
+\layout Verbatim
+
+    info            - view the introductory information for this list
+\layout Verbatim
+
+    help            - list all recognized commands
+\layout Verbatim
+
+    
+\layout Standard
+
+Xmame Mailing List 
+\layout Itemize
+
+The xmame mailing list is intended to be a technical forum for xmame developers,
+ that is,
+\begin_deeper 
+\layout Itemize
+
+To exchange ideas for producing a better xmame.
+\layout Itemize
+
+To share patches and bug notifications.
+\layout Itemize
+
+To study new design strategies.
+\layout Itemize
+
+To expose problems and learn know-how.
+\end_deeper 
+\layout Itemize
+
+The Xmame mailing list 
+\series bold 
+is not
+\series default 
+ a forum about playing games (but everyone on the list plays...); so please
+\begin_deeper 
+\layout Itemize
+
+
+\series bold 
+Don't use the list to ask about ROMs.
+\layout Itemize
+
+
+\series bold 
+Don't ask about non-UNIX ports of MAME, just about MAME and xmame.
+\layout Itemize
+
+
+\series bold 
+Don't ask about implementing a game.
+ Just search the docs and contribute yourself (you'll enjoy twice: programming
+ and playing...).
+\layout Itemize
+
+
+\series bold 
+Don't show your last high score in xxx game (we are interested in programming,
+ and then playing, in this order).
+\end_deeper 
+\layout Itemize
+
+
+\series bold 
+Copyright notice: NEVER, I repeat NEVER send ROM images to the  list.
+
+\series default 
+ (But you can tell us where to retrieve them...
+ ;-) )
+\layout Itemize
+
+At this moment, the xmame list is 
+\series bold 
+unmoderated
+\series default 
+; that is, everyone subscribed will receive everything sent to the list.
+ We foresee a need to change this policy since the list starts to suffer
+ from spam :-(.
+\layout Standard
+
+If you want to send a personal mail to the xmame/xmess coordinator, send
+ to the address below.
+ Everyone who contributes to xmame/xmess should subscribe to the xmame/xmess
+ mailing list.
+\layout Itemize
+
+Mailing list:
+\family typewriter 
+
+\begin_inset LatexCommand \url[Xmame-request@toybox.twisted.org.uk]{mailto:Xmame-request@toybox.twisted.org.uk}
+
+\end_inset 
+
+
+\layout Itemize
+
+Xmame/xmess coordinator: 
+\family typewriter 
+
+\begin_inset LatexCommand \url[gold@aros.net]{mailto:gold@aros.net}
+
+\end_inset 
+
+
+\layout Standard
+
+That's all.
+ Enjoy xmame!
+\layout Subsection
+
+Bugzilla
+\layout Standard
+
+In addition to/instead of posting bugs to the mailing list, you can report
+ them to the MESS Bugzilla database at 
+\begin_inset LatexCommand \url[http://bugzilla.mess.org/]{http://bugzilla.mess.org/}
+
+\end_inset 
+
+, under the 
+\begin_inset Quotes eld
+\end_inset 
+
+XMAME/XMESS
+\begin_inset Quotes erd
+\end_inset 
+
+ category.
+\layout Subsection
+
+Credits
+\layout Standard
+
+Lots and lots and lots of thanks to everyone for their great help on the
+ xmame project.
+ I would like to thank the following people and of course anyone I've forgotten.
+\layout Standard
+
+Thank you all,
+\layout Standard
+
+Hans
+\layout Standard
+
+(Addendum: I'd like to send a big thanks to Hans for his fantastic work
+ as longtime xmame/xmess maintainer, and also to those on the mailing list
+ who have been most helpful during my transition to official maintainer.
+ --Lawrence Gold)
+\layout Enumerate
+
+Fathers of the MAME-creature (main version)
+\begin_deeper 
+\layout Itemize
+
+Nicola Salmoria
+\layout Itemize
+
+Allard van der Bas
+\layout Itemize
+
+Mirko (Mix) Buffoni (General Mantainer during Nicola's national service)
+\end_deeper 
+\layout Enumerate
+
+Fathers of MESS
+\begin_deeper 
+\layout Itemize
+
+Brad Oliver 
+\layout Itemize
+
+Richard Bannister
+\layout Itemize
+
+Ben Bruscella
+\layout Itemize
+
+Nathan Woods (current coordinator)
+\end_deeper 
+\layout Enumerate
+
+Original UNIX/X11 port
+\begin_deeper 
+\layout Itemize
+
+Allard van der Bas
+\layout Itemize
+
+Dick the Ridder
+\layout Itemize
+
+Juan Antonio Martinez
+\end_deeper 
+\layout Enumerate
+
+Semi-retired Unix maintainer extraordinaire
+\begin_deeper 
+\layout Itemize
+
+Hans de Goede
+\end_deeper 
+\layout Enumerate
+
+Alpha-specific issues
+\begin_deeper 
+\layout Itemize
+
+Christian Groessler
+\end_deeper 
+\layout Enumerate
+
+Sun-specific issues
+\begin_deeper 
+\layout Itemize
+
+Keith Hargrove
+\layout Itemize
+
+Mathis Rosenhau
+\end_deeper 
+\layout Enumerate
+
+Irix-specific issues
+\begin_deeper 
+\layout Itemize
+
+Tristram Scott
+\end_deeper 
+\layout Enumerate
+
+QNX-specific issues
+\begin_deeper 
+\layout Itemize
+
+Travis Coady
+\end_deeper 
+\layout Enumerate
+
+GGI maintainance
+\begin_deeper 
+\layout Itemize
+
+Gabriele Boccone (original port)
+\layout Itemize
+
+Christian Groessler (current maintainer)
+\end_deeper 
+\layout Enumerate
+
+OpenGL code & maintainance
+\begin_deeper 
+\layout Itemize
+
+Mike Oliphant (original creator)
+\layout Itemize
+
+Sven Goethel (from GLmame 0.7 to the present)
+\end_deeper 
+\layout Enumerate
+
+Network code
+\begin_deeper 
+\layout Itemize
+
+Eric Totel
+\end_deeper 
+\layout Enumerate
+
+Perl scripts for automation of some porting issues
+\begin_deeper 
+\layout Itemize
+
+Bill Adams
+\end_deeper 
+\layout Enumerate
+
+Xmame RPMs
+\begin_deeper 
+\layout Itemize
+
+Jeremy Hansen
+\end_deeper 
+\layout Enumerate
+
+Mailing list maintainer
+\begin_deeper 
+\layout Itemize
+
+Chris McCraw (retired)
+\layout Itemize
+
+Pete French
+\end_deeper 
+\layout Enumerate
+
+Bits and pieces
+\begin_deeper 
+\layout Itemize
+
+Christian Groessler
+\layout Itemize
+
+Torsten Paul
+\layout Itemize
+
+Jack Patton
+\layout Itemize
+
+David Black
+\end_deeper 
+\layout Enumerate
+
+AIX Sound code
+\begin_deeper 
+\layout Itemize
+
+Chris Sharpp
+\end_deeper 
+\layout Enumerate
+
+IRIX Sound Code
+\begin_deeper 
+\layout Itemize
+
+
+\family typewriter 
+
+\begin_inset LatexCommand \url[entropy@zippy.bernstein.com]{mailto:entropy@zippy.bernstein.com}
+
+\end_inset 
+
+
+\family default 
+ (original code)
+\layout Itemize
+
+Brandon Corey (current code)
+\end_deeper 
+\layout Enumerate
+
+PS2 Linux support
+\begin_deeper 
+\layout Itemize
+
+Joan Sarah Touzet
+\end_deeper 
+\layout Enumerate
+
+Xv support
+\begin_deeper 
+\layout Itemize
+
+Alastair Robinson
+\end_deeper 
+\layout Enumerate
+
+NetMAME Support
+\begin_deeper 
+\layout Itemize
+
+Steve Freeland
+\end_deeper 
+\layout Enumerate
+
+German readme
+\begin_deeper 
+\layout Itemize
+
+Robert Hamberger
+\end_deeper 
+\layout Enumerate
+
+Documentation (SGML, HTML, MAN)
+\begin_deeper 
+\layout Itemize
+
+Rene Herrmann
+\end_deeper 
+\layout Enumerate
+
+Bugzilla bug database
+\begin_deeper 
+\layout Itemize
+
+Sean Young
+\end_deeper 
+\layout Section
+
+Legal Issues and Copyrights Concerning MAME/MESS
+\layout Itemize
+
+
+\series bold 
+Please read the MAME/MESS readme-files first!
+\layout Itemize
+
+Xmame/xmess should be distributed under terms of the license in 
+\begin_inset LatexCommand \url[readme.mame]{readme.mame}
+
+\end_inset 
+
+
+\layout Itemize
+
+And if you are interested in mess, take a look in 
+\begin_inset LatexCommand \url[readme.mess]{readme.mess}
+
+\end_inset 
+
+
+\layout Itemize
+
+The main issue involves ROM images.
+ ROM images are protected under the copyrights of their authors, and CANNOT
+ be distributed in the same package as xmame/xmess.
+ Download any ROM images at your own risk and responsibility.
+\layout Itemize
+
+XInputExtensions-based Joystick support.
+ Source code is entirely pure hack work.
+ No sample code, no info at all was found (only library  reference manual)
+ and is copyrighted by me (Juan Antonio Martinez).
+ Use it under terms of GNU General Public License.
+\layout Section
+
+Some Links
+\layout Subsection
+
+Unix sources and docs
+\layout Itemize
+
+The xmame/xmess sources
+\begin_deeper 
+\layout Standard
+
+
+\begin_inset LatexCommand \url[xmame/xmess-0.74.1 sources]{download/xmame-0.74.1.tar.bz2}
+
+\end_inset 
+
+
+\end_deeper 
+\layout Itemize
+
+xmame/xmess FAQ & Installation Guide:
+\begin_deeper 
+\layout Standard
+
+
+\begin_inset LatexCommand \htmlurl[xmame-doc (pdf format)]{download/xmame-doc.pdf}
+
+\end_inset 
+
+
+\end_deeper 
+\layout Itemize
+
+xmame/xmess known bug list:
+\begin_deeper 
+\layout Standard
+
+
+\begin_inset LatexCommand \htmlurl[open issues]{open_issues.html}
+
+\end_inset 
+
+
+\end_deeper 
+\layout Subsection
+
+Unix binaries
+\layout Itemize
+
+
+\begin_inset LatexCommand \url[xmame RPMs]{http://www.forte-intl.com/~ronald/xmame/}
+
+\end_inset 
+
+
+\layout Itemize
+
+
+\begin_inset LatexCommand \url[xmame+CPS2 RPMs]{http://www.beimborn.com/cps2/linux/rpms}
+
+\end_inset 
+
+
+\layout Itemize
+
+
+\begin_inset LatexCommand \url[Source and binary for Solaris UltraSPARC]{http://come.to/georgie}
+
+\end_inset 
+
+
+\layout Itemize
+
+
+\begin_inset LatexCommand \url[AMD-optimized builds for various targets]{http://www.kwyxz.org/linux/xmame/index.html}
+
+\end_inset 
+
+
+\layout Subsection
+
+Xmame/xmess download mirrors
+\layout Itemize
+
+
+\begin_inset LatexCommand \url[ftp://cps2:cps2@wingnut.beimborn.com]{ftp://cps2:cps2@wingnut.beimborn.com}
+
+\end_inset 
+
+(US)
+\layout Itemize
+
+
+\begin_inset LatexCommand \url[http://www.mame.dk]{http://www.mame.dk}
+
+\end_inset 
+
+(Denmark)
+\layout Itemize
+
+
+\begin_inset LatexCommand \url[ftp://ftp.kaupp.cx/pub/xmame]{ftp://ftp.kaupp.cx/pub/xmame}
+
+\end_inset 
+
+(US)
+\layout Subsection
+
+(X)Mame front-ends
+\layout Itemize
+
+
+\begin_inset LatexCommand \url[The official mame frontend page ]{http://www.mame.net/frontend.html}
+
+\end_inset 
+
+
+\layout Itemize
+
+
+\begin_inset LatexCommand \url[Romeo]{http://digilander.libero.it/stefanobolli/index.html}
+
+\end_inset 
+
+, a Java front-end
+\layout Itemize
+
+
+\begin_inset LatexCommand \url[Mamecat]{http://www.mameworld.net/mamecat/}
+
+\end_inset 
+
+
+\layout Itemize
+
+
+\begin_inset LatexCommand \url[GXMame]{http://gxmame.sourceforge.net/}
+
+\end_inset 
+
+, a GTK front-end striving for MAME32 compatibility
+\layout Itemize
+
+
+\begin_inset LatexCommand \url[GnoMame]{http://gnomame.sourceforge.net/}
+
+\end_inset 
+
+, a GNOME front-end
+\layout Itemize
+
+
+\begin_inset LatexCommand \url[Kmamerun]{ftp://ftp.sad.it/pub/kde/local/}
+
+\end_inset 
+
+
+\layout Itemize
+
+
+\begin_inset LatexCommand \url[GrokMame]{http://user.cs.tu-berlin.de/~gator/mame/}
+
+\end_inset 
+
+
+\layout Itemize
+
+
+\begin_inset LatexCommand \url[StartXmame]{http://www.geocities.com/SiliconValley/Mouse/1570/}
+
+\end_inset 
+
+
+\layout Itemize
+
+
+\begin_inset LatexCommand \url[gRustibus]{http://grustibus.sourceforge.net}
+
+\end_inset 
+
+, a GNOME front-end 
+\layout Itemize
+
+
+\begin_inset LatexCommand \url[it-mame]{http://it-mame.sourceforge.net/index2.html}
+
+\end_inset 
+
+
+\layout Itemize
+
+
+\begin_inset LatexCommand \url[IQF]{http://www.sourceforge.net/projects/iqf/}
+
+\end_inset 
+
+
+\layout Itemize
+
+
+\begin_inset LatexCommand \url[LANZAMAME]{http://lanzamame.mameworld.net/}
+
+\end_inset 
+
+
+\layout Itemize
+
+
+\begin_inset LatexCommand \url[ptkmame]{http://ant.eelinux.com/ptkmame/}
+
+\end_inset 
+
+
+\layout Itemize
+
+
+\begin_inset LatexCommand \url[Kemulator]{http://kemulator.sourceforge.net/}
+
+\end_inset 
+
+, a KDE front-end with MESS and Stella support
+\layout Itemize
+
+
+\begin_inset LatexCommand \url[Flynn]{http://www.foxbox.org/adam/code/flynn/index.html}
+
+\end_inset 
+
+, a front-end primarily for converted arcade cabinets
+\layout Itemize
+
+
+\begin_inset LatexCommand \url[MAMEd]{www.xs4all.nl/~phulshof/mame.html}
+
+\end_inset 
+
+, a new front-end for arcade cabinets
+\layout Itemize
+
+
+\begin_inset LatexCommand \url[Playmame & Playmess]{http://www.swentelomania.be/swentel/module.php?boxcontent=35&page=40}
+
+\end_inset 
+
+ (perl-based menu makers)
+\layout Itemize
+
+
+\begin_inset LatexCommand \url[jMame]{http://www.voicenet.com/~jceklosk/}
+
+\end_inset 
+
+, a Java front-end (requires JDE 1.4.0)
+\layout Itemize
+
+
+\begin_inset LatexCommand \url[CXmame]{http://yeeking.net/cxmame/}
+
+\end_inset 
+
+, a simple console-based front-end
+\layout Itemize
+
+
+\begin_inset LatexCommand \url[KMameleon]{http://designs.stormheart.com/kmameleon/}
+
+\end_inset 
+
+, a KDE front-end
+\layout Itemize
+
+
+\begin_inset LatexCommand \url[Mamu_'s Icons for X]{http://tkmame.retrogames.com/icons}
+
+\end_inset 
+
+
+\layout Subsection
+
+Some other links
+\layout Itemize
+
+The official M.A.M.E home is at 
+\begin_inset LatexCommand \url[http://www.mame.net]{http://www.mame.net}
+
+\end_inset 
+
+
+\layout Itemize
+
+The official mess site is 
+\begin_inset LatexCommand \url[http://www.mess.org]{http://www.mess.org}
+
+\end_inset 
+
+
+\layout Itemize
+
+Some other emulation sites are 
+\begin_inset LatexCommand \url[http://www.vg-network.com]{http://www.vg-network.com}
+
+\end_inset 
+
+ and 
+\begin_inset LatexCommand \url[http://www.retrogames.com]{http://www.retrogames.com}
+
+\end_inset 
+
+
+\layout Itemize
+
+The very best ROM site on this planet is at 
+\begin_inset LatexCommand \url[http://www.mame.dk/]{http://www.mame.dk/}
+
+\end_inset 
+
+
+\layout Itemize
+
+A couple of sites with CPS2 and other patches 
+\begin_inset LatexCommand \url[Dan Beimborn's Linux CPS2Mame page]{http://www.beimborn.com/cps2/linux/}
+
+\end_inset 
+
+ and 
+\begin_inset LatexCommand \url[Stijn Hoop's xmame patches ]{http://www.win.tue.nl/~stijn/xmame/}
+
+\end_inset 
+
+
+\layout Itemize
+
+
+\series bold 
+MAME
+\series default 
+ 
+\series bold 
+A
+\series default 
+ction 
+\series bold 
+R
+\series default 
+eplay 
+\series bold 
+P
+\series default 
+age for those who want to have a  look at other monitors at 
+\begin_inset LatexCommand \url[http://marp.retrogames.com/]{http://marp.retrogames.com/}
+
+\end_inset 
+
+
+\layout Itemize
+
+And, of course, don't forget our project homepage at 
+\series bold 
+
+\begin_inset LatexCommand \url[http://x.mame.net/]{http://x.mame.net/}
+
+\end_inset 
+
+
+\layout Section
+
+ChangeLogs
+\begin_inset LatexCommand \label{ChangeLogs}
+
+\end_inset 
+
+
+\layout Subsection
+
+The MAME/MESS ChangeLogs
+\layout Standard
+
+These are the changelogs of the offical MAME and MESS release, the core
+ of xmame/xmess.
+\layout Itemize
+
+
+\begin_inset LatexCommand \url[The MAME changelog (changes.mame)]{changes-mame.html}
+
+\end_inset 
+
+
+\layout Itemize
+
+
+\begin_inset LatexCommand \url[The MESS changelog (changes.mess)]{changes.mess}
+
+\end_inset 
+
+
+\layout Subsection
+
+The Unix ChangeLog
+\layout Standard
+
+And now here is the HISTORY of the xmame project (of course that's why you
+ are here :;-)) ...
+ Ren
+\layout Itemize
+
+
+\begin_inset LatexCommand \url[The Unix port changelog (changes.unix)]{changes-unix.html}
+
+\end_inset 
+
+
+\layout Itemize
+
+The OpenGL display driver changelog: 
+\begin_inset LatexCommand \url[changes.opengl]{changes.opengl}
+
+\end_inset 
+
+ or 
+\begin_inset LatexCommand \url[http://www.jausoft.com/glmame.html]{http://www.jausoft.com/glmame.html}
+
+\end_inset 
+
+
+\the_end
diff --git a/src/unix/doc/xmame-doc.man.skel b/src/unix/doc/xmame-doc.man.skel
new file mode 100644
index 0000000..7268e28
--- /dev/null
+++ b/src/unix/doc/xmame-doc.man.skel
@@ -0,0 +1,74 @@
+.\"  -*- nroff -*-
+.\"
+.\" xmame.6
+.\"
+.\" Done by Ren Herrmann <rene.herrmann@berlin.de>, September 2000
+.\"
+.\" xmame should be distributed under terms of the license in
+.\" readme.mame.
+.\" The main issue involves ROM images. ROM images are protected under the
+.\" copyrights of their authors, and CANNOT be distributed in the same
+.\" package as xmame. Download any ROM images at your own risk and
+.\" responsibility.
+.\"
+.Dd 22. March 2001
+.Dt Xmame 6
+.Os
+.Sh NAME
+.Nm xmame
+.Nd THE Arcade game machine emulator for UNIX/X
+.Sh SYNOPSIS
+.Nm xmame[.x11|svga|xgl|sdl]
+.Op Fl options
+.Ar gamename
+.Sh EXAMPLES
+Some examples for those who are in a hurry.
+
+If you don't have/want a frontend, you'll mostly use
+.Nm xmame
+(with a well defined xmamerc) in the following way:
+
+.Nm xmame
+.Ar ladybug
+
+Plays Ladybug with all options defined in xmamerc. If there is no xmamerc the 
+game starts with the buildin defaults.
+
+.Nm xmame
+.Ar defender
+.Fl frameskip Ar 1
+.Fl cheat
+
+Starts
+.Ar defender
+using a frameskip of 1 and cheat is enabled.
+Useful for slower computers, if the game is running really slowly.
+And of course if you want (have?) to cheat. ;-)
+.Sh LEGAL NOTICE
+The main issue involves ROM images. ROM images are protected under the
+copyrights of their authors, and CANNOT be distributed in the same
+package as xmame. Download any ROM images at your own risk and
+responsibility.
+
+.Nm xmame
+should be distributed under terms of the license in doc/readme.mame
+
+XInputExtensions based Joystick support. Source code is entirely pure 
+hack work. No sample code, no info at all was found (only library 
+reference manual) and is copyrighted by me (Juan Antonio Marmnez).
+Use it under terms of GNU General Public License.
+
+PLEASE BE AWARE OF THE POSSIBLE LEGAL RAMIFICATIONS OF DOWNLOADING ROM
+IMAGES, BEFORE YOU ACTUALLY DO SO!  YOU HAVE BEEN WARNED, AND WE TAKE NO
+RESPONSIBILITY FOR YOUR ACTIONS -- YOU ARE ON YOUR OWN!
+
+Also, the
+.Nm xmame 
+authors ask that you DO NOT distribute any ROM images with either source
+code or binaries of the
+.Nm xmame
+emulator.
+.Sh DESCRIPTION
+.Nm xmame 
+is the (M)ulti (A)rcade (M)achine (E)mulator for UNIX-(X).  It emulates
+the hardware of realy many classic arcade game machines.
diff --git a/src/unix/doc/xmame-doc.sgml b/src/unix/doc/xmame-doc.sgml
new file mode 100644
index 0000000..5735525
--- /dev/null
+++ b/src/unix/doc/xmame-doc.sgml
@@ -0,0 +1,3704 @@
+<!doctype linuxdoc system>
+
+<article>
+<!-- LyX 1.3 created this file. For more info see http://www.lyx.org/ -->
+<title>
+XMAME/XMESS DOCUMENTATION
+
+</title>
+<author>
+Juan Antonio Martinez <tt><url url="mailto:jantonio@dit.upm.es" name="jantonio@dit.upm.es"></tt> and Hans de Goede <tt><url url="mailto:hans@highrise.nl" name="hans@highrise.nl"></tt> and Rene' Herrmann
+ (4 doc/sgml) <tt><url url="mailto:rene.herrmann@berlin.de" name="rene.herrmann@berlin.de"></tt> and Lawrence Gold (minor editing) <tt><url url="mailto:gold@aros.net" name="gold@aros.net"> and David Heremans
+ (minor editing)</tt>
+
+</author>
+<date>
+v2.1.33, 15 September 2003
+
+</date>
+<abstract>
+xmame/xmess documentation with an installation guide, the FAQ
+ (frequently asked questions), hints, tips and tricks, the changes
+ to the code, and much more!
+
+</abstract>
+<toc>
+<sect>
+Introduction<label id="Introduction" >
+<sect1>
+Welcome to XMAME
+<p>
+This the the *nix port of the almost legendary mame. Mame is
+ an arcade machine emulator, started in 1997 by Nicola Salmoria. It
+ started out as a series of emulators for  individual games. This
+ series of emulators was combined into a  simgle multi-game emulator.
+ This is the current form of mame; no longer a one-man show, there
+ are over 100 contributors to the project.
+
+</p>
+<sect1>
+Keep everything up-to-date!
+<p>
+The most recent copy of this guide, the xmame-sources and many
+ more can be found on the xmame project homepage at <url url="http://x.mame.net/" name="http://x.mame.net/">
+
+</p>
+<sect1>
+Pending Jobs - or TODO
+<p>
+If you think you can help with the todo list or you can make
+ a  contribution that you feel is interesting, please send mail to
+ the xmame/xmess coordinator. See <ref id="Mail" name="Mail" > for contact information.
+
+</p>
+
+<p>
+<itemize>
+ <item>
+Optimise mouse warping.
+ <item>
+Remove osd_input_init_post, add display ready flag.
+ <item>
+Updating of fps is off (dirty marking problem) with vector games.
+ <item>
+Update porting.txt.
+ <item>
+Convert all remaining sound drivers to plugins.
+ <item>
+Rewrite display/input code to be more modular, oo-ish, and usable
+ as a separate library.
+ <item>
+Split <tt>-&lsqb;no&rsqb;scanline</tt> option into emulated and real scanline
+ options.
+ <item>
+Add an option to specify which resolution to use, add clipping
+ and panning if it doesn't fit and use it anyway.
+ <item>
+Use Pentium TSC for uclock where available.
+ <item>
+Network:
+ <itemize>
+  <item>
+Fix since the dos team broke it, find out if the dosnet team
+ is still alive.
+  <item>
+Add mouse/joystick support to network play
+  <item>
+Try converting network support to tcp, currently we have no error
+ correction.
+  <item>
+Make network code more robust, version check, input settings
+ check, etc.
+
+ </itemize>
+ <item>
+Check x11-joystick. Rumor has it it's broken, but then again
+ there's only one bug-report, so it seems no one is using it.
+ <item>
+fm soundhack for linux-i386.
+ <item>
+Make which messages are emitted and when configurable (log-type's
+ and log-level), make fileio emit messages about which files it tries
+ to open, to help debug rom-loading problems, and walk through all
+ messages xmame emits giving them all a standard format like:
+ <verb>
+OSD:        Info:    bla
+X11-window: Warning: bla
+Svgalib:    Error:   bla
+
+ </verb>
+ <item>
+Add scancode 128-255 for non-PC keys like F13 -- F24, more keypad
+ keys, etc., update all display targets to use this.
+ <item>
+Also see the text todo file, kept around to quickly enter stuff
+ while hacking: <url url="todo" name="todo">.
+
+</itemize>
+</p><sect>
+Compiling, Setting Up and Starting Xmame/Xmess
+<p>
+Note: This section is not a Unix tutorial. You need to know some
+ basic  Unix commands to compile and install xmame/xmess.
+
+</p>
+<sect1>
+Requirements     
+
+<p>
+<itemize>
+ <item>
+GNU make is MANDATORY in ALL Systems, even if you use a different
+  compiler. 
+ <item>
+On all platforms zlib is now needed since the core uses it. If
+ you don't have zlib, a stripped version is included with xmame. See:
+ <ref id="FAQ: Why do I get gz_open symbol not found while compiling?" name="FAQ: Why do I get gz_open symbol not while compiling?" > and <ref id="FAQ: Why do I get zlib.h not found?" name="FAQ: Why do I get zlib.h not found?" >
+ <item>
+You are encouraged to use a GNU development environment: gcc,
+ gmake, gnu- ar. Lots of problems are found due to the very permissive
+ syntax in gcc, so if you use a strictly ANSI C compiler, you'll get
+ lots of warnings, and if the version of xmame/xmess is not fully
+ debugged, compilation errors.
+ <item>
+Xmame compilation breaks when using egcs-1.1.x or gcc-2.95, use
+ <tt>-fno-strict-aliasing</tt> to fix it. gcc-2.95.1 does work with <tt>-fstrict-aliasing</tt>,
+ and gives a nice speed increase.
+ <item>
+Xmame compilation also breaks when using Red Hat 7's latest (as
+ of 16 January 2001) update for gcc. If you experience problems, please
+ either downgrade your compiler to the one included on the Red Hat
+ 7 CD-ROM, or try replacing "gcc" in the Makefile with "kgcc", which will
+ invoke egcs-1.1.2. (But please see above about the <tt>-fstrict-aliasing
+ </tt>flag.)
+
+</itemize>
+</p><sect1>
+Follow these steps to compile xmame/xmess
+
+<p>
+<enum>
+ <item>
+See <ref id="Compile Notes for Specific Operating Systems" name="Compile Notes for Specific Operating Systems" > for platform specific compiling information.
+ <item>
+See <ref id="Display subsystem specific comments and notes" name="Display subsystem specific comments and notes" > for special display methods information.
+ <item>
+Download the xmame/xmess source files archive.
+ <item>
+Move the xmame/xmess source files archive to a suitable work
+ directory. When you extract the archive, sub directories will be
+ created under the  work directory.
+ <item>
+Rename the source files archive so its extension is .gz, so that
+ gzip doesn't complain. For example, change <tt>xmame-0.34b1.1.tgz</tt> to
+ <tt>xmame-0.34b1.1.tar.gz</tt>
+ <item>
+Use gzip -d to uncompress the archive. For example, type:
+ <verb>
+gzip -d xmame-0.34b1.1.tar.gz
+
+ </verb>
+ <item>
+Extract the files with tar. For example, type:
+ <verb>
+tar xvf xmame-0.34b1.1.tar
+
+ </verb>
+ <item>
+After extracting the archive, change to the subdirectory created
+ by  the extraction process. For example, after extracting the xmame-0.34b1.1.tar
+ archive, a directory named <tt>xmame-0.34b1.1</tt> is created. Change to it.
+ This directory is the top of the source tree.
+ <item>
+Copy makefile.unix to Makefile, the distributed Makefile is used
+ for development and is not a good starting point!
+ <item>
+Edit the <tt>Makefile</tt> and change the settings according to your system.
+ The default <tt>makefile.unix</tt> is preconfigured to run under X11/Linux.
+ Be careful editing this file.
+ <itemize>
+  <item>
+If you intend to compile in X11 joystick support, type the following
+ to see the available Xdevice list:
+  <verb>
+make xlistdev; ./xlistdev
+
+  </verb>
+  <item>
+Choose the desired device and re-edit Makefile, setting the option
+ X11_JOYNAME to the correct device.
+
+ </itemize>
+ <item>
+Compile xmame/xmess by typing:
+ <verb>
+make
+
+ </verb>
+ <item>
+If the compile fails, report the problem to the author.
+ <item>
+<bf>*** YOU MAY NEED TO BE root TO PERFORM THIS STEP ***</bf> To install
+ xmame/xmess, type:
+ <verb>
+make install
+
+ </verb>
+ <item>
+If you want you can now build xmame/xmess for another target/display
+ method, otherwise skip to the next step.
+ <enum>
+  <item>
+If you want to also build for another target repeat repeat the
+ <tt>"make"</tt> and <tt>"make install"</tt> steps adding <tt>"TARGET=&lt;target&gt;"</tt> to the make
+ command for example:
+  <verb>
+make TARGET=mess
+make install
+
+  </verb>
+  <item>
+If you want to also build for another display method repeat the
+ <tt>"make"</tt> and <tt>"make install"</tt> steps adding <tt>"DISPLAY_METHOD=&lt;method&gt;"</tt>
+ to the make command for example:
+  <verb>
+make DISPLAY_METHOD=svgalib
+make install
+
+  </verb>
+  <item>
+You can also combine the 2 above for example:
+  <verb>
+make TARGET=mess DISPLAY_METHOD=svgalib
+make install
+
+  </verb>
+
+ </enum>
+ <item>
+In your home directory, create a subdirectory called .xmame.
+ <item>
+From the top of the source tree, copy the file doc/xmamerc.dist
+ to the &dollar;&lcub;HOME&rcub;/.xmame/ directory. (For xmess do
+ this for xmessrc)
+ <item>
+If desired, copy xmamerc.dist to the global xmamerc location
+ as &quot;xmamerc&quot; (for xmess, copy xmamerc.dist to xmessrc).
+ The global xmamerc location is defined in the Makefile.
+ <item>
+Edit &dollar;&lcub;HOME&rcub;/.xmame/xmamerc to match your preferences.
+ (For xmess, edit &dollar;&lcub;HOME&rcub;/.xmess/xmessrc)
+ <item>
+Be sure that the DISPLAY and PATH environment variables are 
+ set correctly.
+ <item>
+Make sure your ROM images are installed.
+ <item>
+Start the X-Window System. (Unless you compiled for a different
+ display method in which case you skip this step.)
+ <item>
+Start xmame/xmess. For example:
+ <verb>
+/usr/games/xmame.x11 dkong
+
+ </verb>
+
+</enum>
+</p><sect1>
+If you have problems compiling, installing and starting xmame/xmess...
+     
+
+<p>
+<itemize>
+ <item>
+Read  <ref id="Xmame frequently asked questions" name="Xmame frequently asked questions" >
+ <item>
+Read (the recent parts of) <ref id="ChangeLogs" name="Changelogs" >. They might contain some hints about
+ recent changes which aren't fully documented yet.
+ <item>
+Check <ref id="Compile Notes for Specific Operating Systems" name="Compile Notes for Specific Operating Systems" > for operating system-specific notes. You may need to do
+ something special for your operating system.
+ <item>
+Check <ref id="Display subsystem specific comments and notes" name="Display subsystem specific comments and notes" > for display subsystem-specific notes. You may need to
+ do something special for your display system.
+ <item>
+If you get an error about gz_open and a bunch of other functions
+ not found during linking, read: <ref id="FAQ: Why do I get gz_open symbol not found while compiling?" name="FAQ: Why do I get gz_open symbol not while compiling?" > and <ref id="FAQ: Why do I get zlib.h not found?" name="FAQ: Why do I get zlib.h not found?" >.
+ <item>
+Be sure that the rompath in your xmamerc/xmessrc is correct;
+ see <ref id="FAQ: Where do roms, images, samples, highscores, configfiles, etc go?" name="FAQ: Where do roms.images.etc go?" >.
+ <item>
+Check xmamerc/xmessrc: Is it configured correctly?
+ <item>
+Are you getting messages that you are missing files? Maybe you
+ are missing PROMs; see <ref id="FAQ: Why doesn't a game work?" name="FAQ: Why doesn't a game work?" > and <ref id="FAQ: What are PROMs?" name="FAQ: What are PROMs?" >
+ <item>
+Is the program in your PATH?
+ <item>
+The svgalib/xf86_dga build of xmame/xmess requires setuid root.
+ Are your permissions correct?
+ <item>
+Try asking the friendly folks at the newsgroup alt.game.mame
+ to see if anyone else has experienced the same problem as you.
+ <item>
+Try mailing to the xmame mailinglist, see <ref id="Mail" name="Mail" > for more information.
+
+</itemize>
+</p><p>
+If all else fails, send email to the current maintainer of the
+ xmame/xmess project. See <ref id="Mail" name="Mail" > for contact information.
+
+</p>
+<sect1>
+Compile Notes for Specific Operating Systems <label id="Compile Notes for Specific Operating Systems" >
+<sect2>
+Linux i386
+<p>
+Linux i386 is the platform I (Hans) use, so xmame should compile
+ without any hassles on Linux i386. (Note: The same is true for Lawrence
+ Gold.)
+
+</p>
+<p>
+Some bugs have been found and worked around when using gcc27x,
+ please use egcs if available. If more gcc bugs popup, egcs will be
+  made mandatory, but I hope that won't be necessary.
+
+</p>
+<p>
+It has been reported that some SoundBlaster AWE32 and VIA-82cxxx
+ (onboard) cards do not  correctly manage get_freespace(). If so,
+ you'll get some audio_ioctl() calls failed messages in console, and
+ if everything goes right a message that xmame/xmess is falling back
+ to timer based audio. If  this doesn't happen and sound isn't right,
+ try forcing timer-based  audio by starting xmame/xmess with <tt>-timer</tt>.
+
+</p>
+<p>
+SB64/128PCI cards (Ensoniq 137x-based cards) also do not correctly
+ manage get_freespace(). Unfortunately, this doesn't result in failed
+ ioctl's; instead, they just ignore the calls. Xmame tries to autodetect
+ this and to fall back to timer-based audio. If this doesn't happen
+ and sound isn't right, try forcing timer based audio by starting
+ xmame/xmess with <tt>-timer</tt>.
+
+</p>
+<p>
+Some have reported success using ALSA with OSS emulation (see
+ <url url="http://www.alsa-project.org/" name="http://www.alsa-project.org/">). If you experience the above problems, this would certainly be
+ worth a try.
+
+</p>
+<p>
+Also, I've tested sound using the PC-Speaker driver module. It
+ works!! But it needs <tt>-timer.</tt> Again, it should do this  automagically,
+ but you know what to do if it doesn't.
+
+</p>
+<p>
+Distribution-Specific Comments:
+
+</p>
+
+<p>
+<itemize>
+ <item>
+S.u.S.E. Linux: Besides the gcc compiler and libc libraries,
+ which are both from the &quot;d&quot; series, other packages  need
+ to be installed or the build will fail. If compiling for svgalib,
+ the svgalib package from series &quot;d&quot; installed. If compiling
+ for the X-Window System, you must have xdevel package from series
+ &quot;x&quot; installed. These packages can be installed using the
+ &quot;yast&quot; utility included in the S.u.S.E. distribution.
+ <item>
+Red Hat Linux is the operating system used by the author. xmame/xmess
+  should build correctly under Red Hat Linux. :-)
+
+</itemize>
+</p><sect2>
+Linux PowerPC
+<p>
+Linux PowerPC should work from now on. Here's an email from Andreas
+ Varga <tt><url url="mailto:sid@skater.htu.tuwien.ac.at" name="sid@skater.htu.tuwien.ac.at"></tt>, the Linux/PowerPC maintainer, describing the necessary steps:
+
+</p>
+<p>
+Required changes to compile xmame 0.34b3.1 on Linux/PowerPC with
+ SVGALIB
+
+</p>
+<p>
+Makefile:
+
+</p>
+
+<p>
+<itemize>
+ <item>
+enable CFLAGS for linux/ppc 
+ <item>
+enable DISPLAY_METHOD = svgalib 
+ <item>
+enable ARCH = linux 
+ <item>
+remove -lvgagl from LIBS.svgalib in src/unix/unix.mak (only -lvga
+ is required)
+
+</itemize>
+</p><p>
+Required changes to compile xmame 0.34b3.1 on Linux/PowerPC with
+ X11 
+
+</p>
+<p>
+Makefile: 
+
+</p>
+
+<p>
+<itemize>
+ <item>
+enable CFLAGS for linux/ppc 
+ <item>
+enable DISPLAY_METHOD = x11 
+ <item>
+enable ARCH = linux 
+
+</itemize>
+</p><p>
+Another thing... sound is not working, because sound drivers
+ support is currently under development in Linux/PPC kernels...there
+ is an old driver that is a hacked Soundblaster driver, and newer
+ 2.1.1xx kernels have a sound drivers based on Amiga DMA sound drivers...
+ Once this issues are settled there should be a full OSS-compatible
+ driver... sound should work then...
+
+</p>
+<p>
+I can't speak about Joystick support...
+
+</p>
+<p>
+The original Linux/PPC target changes in the Makefile were done
+ by me, but there are some other changes required to get it to compile...
+ Starting from October I will have some more time to work on this,
+ and I'll keep you updated...
+
+</p>
+<p>
+Cheers, Andreas
+
+</p>
+<sect2>
+IRIX
+<p>
+Use the generic unix arch for those machines that have no  sound
+ support installed (xmame/xmess uses the dmedia package or the newer
+ AL package on IRIX systems).
+
+</p>
+<p>
+Silicon Graphics provides several native compilers. xmame/xmess
+ has  been compiled and tested with the normal cc. There were some
+ problems with this when using -n32 for new style 32bit code. It does
+ work when using -o32 for oldstyle 32 bit code. It should now also
+ work with -n32 which is much faster.
+
+</p>
+<p>
+The use of DCC is not recommended (anymore) since it's a C++
+  compiler and thus won't even compile xmame/xmess out of the box
+ due to uncasted mallocs. Changing all these mallocs would be crazy,
+ esp. since they are not only in the osd part, but also in the core
+ which is not under our control. Besides that, mame is normal C, so
+ please compile it with a normal C compiler.
+
+</p>
+<p>
+Some problems have been reported using the GNU linker. It's recommended
+ that you use the native one.
+
+</p>
+<sect2>
+HPUX
+<p>
+Use the generic unix arch. In HP-UX, gcc and gnu-make are MANDATORY.
+
+</p>
+<sect2>
+ULTRIX 
+<p>
+Use the generic unix arch.
+
+</p>
+<p>
+Notes received from Danny <tt><url url="mailto:dboxhoor@iso.vilspa.esa.es" name="dboxhoor@iso.vilspa.esa.es"></tt>
+
+</p>
+<p>
+<bf>VERY IMPORTANT!!!</bf>
+
+</p>
+<p>
+The xmame/xmess CPU emulators access memory through pointers
+ which are sometimes cast to illegal addresses - as far as the MIPS
+ CPU is concerned. The Ultrix operating system is aware of that and
+ fixes this &quot;unaligned data access&quot;.
+
+</p>
+<p>
+Depending on your system setup, lots of warnings are generated
+ for certain games. Fortunately these messages can be disabled by
+  executing the command &quot;uac p 0&quot; in the same shell where
+ xmame/xmess  will be running.
+
+</p>
+<p>
+UPDATE: The new <tt>-DALIGN_INTS</tt> switch in the makefile fixes these
+ unaligned accesses in the source which is probably a lot faster than
+ hot fixing them in the kernel segfault handler.
+
+</p>
+<p>
+Use gnu make.
+
+</p>
+<p>
+Compile with the `c89' compiler. Though `gcc' has no problems
+  with compiling and optimizing xmame/xmess, the resulting `c89' 
+ executable is faster on an empty machine (read: xmame can use all
+  cpu &amp; memory without competing with other high priority  processes),
+ so you can set `frameskip' to 1.
+
+</p>
+<p>
+When compiling with `c89 -O2' don't forget to also use `-Olimit
+  1000'. If 1000 is not enough, the compiler will tell you to  increase
+ it.
+
+</p>
+<sect2>
+SunOS &amp; Solaris
+<p>
+There are 2 relevant architecture options available in the makefile:
+ 
+
+</p>
+
+<p>
+<verb>
+    ARCH = generic : use this for old SunOs running on Sparcs,
+                     but a Sparc running Solaris will usually
+                     handle this option too.
+    ARCH = solaris : this is the one you should use for Sparcs
+                     running Solaris.        
+
+</verb>
+</p><p>
+Currently sound is not supported under sunos. The solaris arch
+ does support audio.
+
+</p>
+<p>
+If you are using Sun's OpenWindows implementation of X11, then
+ make sure that the X11INC and X11LIB variables in the X11 Options
+ section of the makefile are set properly. (There are already entries
+ for the standard OpenWin directory there that you can uncomment.)
+
+</p>
+<p>
+Of course, if you are compiling for X11 then you need to set
+ these variables properly, no matter what implementation of X11 you
+ are using!  :)
+
+</p>
+<p>
+If you are using Sun's SunPro cc compiler, then the following
+ optimisation flags have been reported to be good:
+
+</p>
+
+<p>
+<verb>
+    OPTFLAGS    = -fast -xO4 -native
+
+</verb>
+</p><p>
+Finally, there has been a case of the xmame compilation processes
+ breaking over the &quot;ar&quot; program. Most Solaris installations
+ will include a set of utilities that conform to the XPG4 standard,
+ usually in the &quot;/usr/xpg4/bin&quot; directory. The XPG4 version
+ of &quot;ar&quot; should be avoided like the plague. Ensure that
+ the &quot;/usr/ccs/bin&quot; appears in your path before the &quot;/usr/xpg4/bin&quot;
+ directory and everything should go smoothly.
+
+</p>
+<p>
+PLEASE NOTE : There is currently not much support for SunOS/Solaris.
+ If you have any trouble, try to fix it yourself. If you succeed,
+ send a message to the mailing list detailing what you did. If you
+ don't succeed, send a message anyway and someone _may_ be able to
+ help you. Either way, this is the only way that problems with xmame
+ on SunOS/Solaris will get fixed.
+
+</p>
+<sect2>
+Openstep
+<p>
+You must use the OpenStep gnumake, not make. You must also use
+ the NeXT/Apple cc rather than gcc. Also use only the optimisation
+ options as recommended for OpenStep in the makefile, others will
+ cause the resulting executable to crash. The OpenStep assembler on
+ i386 architectures is incompatible with the mame assembler CPU cores
+ and thus you must use the C versions (Use i386-noasm instead of i386
+ when compiling for i386).
+
+</p>
+<p>
+The supplied complier is based on gcc 2.7.2.1 which will not
+ compile src/profiler.c without crashing. To get around this you must
+ turn off + optimisation when this crash occurs, re-make to compile
+ this file only, then stop the make, re-enable optimisation, and continue.
+
+</p>
+<p>
+On an OpenStep keyboard the functions keys do not all operate
+ as expected. Using the command key in conjuction with a number key
+ generates the equivalent function key within xmame, with 0, - and
+ = + representing F10, F11 and F12 resepectively. Also note that the
+ ALT + keys cannot be mapped. As most games tend to use this as the
+ default fire button it is exteremly useful to remap this globally
+ the first time you run xmame.
+
+</p>
+<sect>
+Xmame Frequently Asked Questions<label id="Xmame frequently asked questions" >
+<sect1>
+What is mame?
+<p>
+Mame is an arcade machine emulator. Started in 1997 by Nicola
+  Salmoria, mame started out as a series of emulators for  individual
+ games. This series of emulators was combined into a  simgle multi-game
+ emulator. This is the current form of mame; no longer a one-man show,
+ there are over 100 contributors to the project.
+
+</p>
+<p>
+Mame was created by Nicola Salmoria.
+
+</p>
+<p>
+Also see <url url="readme.mame" name="the official mame readme file (readme.mame)">
+
+</p>
+<sect1>
+What is mess?
+<p>
+Mess is just like mame---a virtual machine emulator, only it
+ doesn't emulate arcade machines but rather computers and consoles.
+
+</p>
+<p>
+Also see <url url="readme.mess" name="the official mess readme file (readme.mess)">
+
+</p>
+<sect1>
+What is xmame/xmess?
+<p>
+Xmame/xmess are the Unix/X11 ports of the mame and mess projects.
+ It makes mame/mess available on *ix machines using the X11R6 X-Window
+ System (and SVGAlib/ggi/XF86-DGA/OpenGL/SDL too).
+
+</p>
+<p>
+Mame was orginally ported by Allard Van Der Bas, Dick the Ridder,
+ Juan Antonio Martinez, and Hans de Goede.
+
+</p>
+<p>
+Xmame/xmess is currently maintained by Lawrence Gold.
+
+</p>
+<sect1>
+What are the differences between mame/mess and xmame/xmess?
+<p>
+None significant.
+
+</p>
+<p>
+Xmame/xmess is based on the mame/mess source code. Due to technical
+ reasons beyond the scope of this document, the mame/mess source may
+ not compile under Unix. That's why the xmame/xmess project exists.
+ Each time mame/mess is updated, the code is tested  (and patched
+ if needed) under Unix. This way xmame/xmess releases are always the
+ same as their mame counterparts.
+
+</p>
+<p>
+There are no plans for the independent development of xmame/xmess.
+
+</p>
+<sect1>
+What hardware and operating systems are supported?     
+<p>
+Xmame runs on both little-endian and big-endian CPUs, using aligned
+ integer access if needed and is compatible with 64 bit CPUs. The
+ current list of supported CPUs in the makefile is:
+
+</p>
+
+<p>
+<itemize>
+ <item>
+i386 + gnu-asm
+ <item>
+i386 no asm
+ <item>
+alpha
+ <item>
+ia64 (merced)
+ <item>
+m68k
+ <item>
+generic risc (PowerPC, Sparc, HPPA, IBM)
+ <item>
+generic risc, lsb-first (RISC (Ultrix machines))
+ <item>
+mips (generic risc + SGI compiler bug workarounds)
+
+</itemize>
+</p><p>
+Adding support for another cpu (if necessary) should be trivial.
+
+</p>
+<p>
+The following Unix platforms are specifically supported:
+
+</p>
+
+<p>
+<itemize>
+ <item>
+Linux
+ <item>
+FreeBSD
+ <item>
+NetBSD
+ <item>
+Solaris (SunOS)
+ <item>
+OpenStep (noasm only on i386)
+ <item>
+IRIX with sound using the dmedia package or the new al package
+ (sound currently broken)
+ <item>
+AIX (sound currently broken)
+ <item>
+generic unix, no sound
+
+</itemize>
+</p><p>
+The generic unix entry should work for any reasonable standard
+ Unix variant, but lacks sound since there is no single Unix sound
+ standard.
+
+</p>
+<p>
+On all platforms, zlib is now needed since the core uses it.
+ Ff you don't have zlib, use the included one by uncommenting the
+ appropriate line in Makefile.
+
+</p>
+<p>
+The following display methods are supported. X11 is the only
+ one which works on all platforms, except for OpenStep which only
+ works with Openstep bitmaps:
+
+</p>
+
+<p>
+<itemize>
+ <item>
+X11 (X-Window System)
+ <item>
+svgalib
+ <item>
+GGI (Generic Graphics Interface)
+ <item>
+OpenGL using X11 for input
+ <item>
+glide using X11 for input (3DFX)
+ <item>
+glide using svgalib for input (3DFX)
+ <item>
+OpenStep bitmaps
+ <item>
+SDL (Simple Direct Medialayer)
+
+</itemize>
+</p><p>
+The following is a list of arch/os/display combinations, with
+ maintainers, for arch/os/display combinations which are actively
+ supported. Please mail the maintainer of the arch/os/display combination
+ for compilation and other arch/os/display specific problems. Mail
+ Lawrence <tt><url url="mailto:gold@aros.net" name="gold@aros.net"></tt> for generic (e.g., X11) problems.
+
+</p>
+
+<p>
+<itemize>
+ <item>
+i386/linux/x11 (+DGA) -&gt; Lawrence <tt><url url="mailto:gold@aros.net" name="<gold@aros.net>"></tt>
+ <item>
+i386/linux/svgalib -&gt; Lawrence <tt><url url="mailto:gold@aros.net" name="<gold@aros.net>"></tt>
+ <item>
+i386/linux/xgl -&gt; Sven Goethel <tt><url url="mailto:sgoethel@jausoft.com" name="<sgoethel@jausoft.com>"></tt>
+ <item>
+i386/linux/xfx -&gt; Lawrence <tt><url url="mailto:gold@aros.net" name="<gold@aros.net>"></tt>
+ <item>
+i386/linux/svgafx -&gt; Lawrence <tt><url url="mailto:gold@aros.net" name="<gold@aros.net>"></tt>
+ <item>
+i386/linux/ggi -&gt; Christian <tt><url url="mailto:cpg@aladdin.de" name="<cpg@aladdin.de>"></tt>
+ <item>
+alpha/linux/x11 -&gt; Christian <tt><url url="mailto:cpg@aladdin.de" name="<cpg@aladdin.de>"></tt>
+ <item>
+alpha/digital unix/x11 * -&gt; Leandro <tt><url url="mailto:gold@aros.net" name="<gold@aros.net>"></tt>
+ <item>
+powerpc/linux/x11 -&gt; Andreas <tt><url url="mailto:sid@skater.htu.tuwien.ac.at" name="<sid@skater.htu.tuwien.ac.at>"></tt>
+ <item>
+powerpc/linux/svgalib -&gt; Andreas <tt><url url="mailto:sid@skater.htu.tuwien.ac.at" name="<sid@skater.htu.tuwien.ac.at>"></tt>
+ <item>
+i386/freebsd/x11 -&gt; Jacob A. Hart <tt><url url="mailto:c9710216@studentmail.newcastle.edu.au" name="<c9710216@studentmail.newcastle.edu.au>"></tt>
+ <item>
+i386/netbsd/x11 -&gt; Dave <tt><url url="mailto:dave@dtsp.co.nz" name="<dave@dtsp.co.nz>"></tt>
+ <item>
+alpha/netbsd/x11 -&gt; Christian <tt><url url="mailto:cpg@aladdin.de" name="<cpg@aladdin.de>"></tt>
+ <item>
+Sparc/Solaris/x11 -&gt; Lawrence <tt><url url="mailto:gold@aros.net" name="<gold@aros.net>"></tt>
+ <item>
+i386/Unixware7/x11 * -&gt; Richard <tt><url url="mailto:xmame@frogface.ddns.org" name="<xmame@frogface.ddns.org>"></tt>
+ <item>
+i386/openstep -&gt; Pete French <tt><url url="mailto:pete@toybox.twisted.org.uk" name="<pete@toybox.twisted.org.uk>"></tt>
+ <item>
+Sparc/SunOs -&gt; Saga <tt><url url="mailto:jolletx@cybercable.fr" name="<jolletx@cybercable.fr>"></tt>
+ <item>
+mips/irix/x11 -&gt; Dingus Family <tt><url url="mailto:ddingus@uswest.net" name="<ddingus@uswest.net>"></tt>
+
+</itemize>
+</p><p>
+* These are supported using the generic unix entry of the makefile,
+ and thus lack sound.
+
+</p>
+<p>
+We are always looking for people willing to test and answer questions
+ about xmame on a new arch/os/display. This takes very little work
+ and could help other people tremendously. If you're interested, mail
+ Lawrence <tt><url url="mailto:gold@aros.net" name="gold@aros.net"></tt>.
+
+</p>
+<sect1>
+My system is supported but xmame/xmess gives me errors and fails.
+ Why?
+<p>
+Xmame/xmess should run on 16, 24 and 32bpp true color displays.
+ If your X server does not support any  of these display types, xmame/xmess
+ will not run. Support for 8bpp pseudo color displays may return in
+ future versions.
+
+</p>
+<p>
+You can verify your X server support by starting your X server
+  and running the xdpyinfo program. See the xdpyinfo manual page 
+ for more information.
+
+</p>
+<sect1>
+What is the role of the xmamerc/xmessrc file?
+<p>
+A normal xmame/xmess invocation looks like:
+
+</p>
+
+<p>
+<verb>
+    xmame pacman -sound -nojoy -frameskip 2 -heightscale 3 &bsol;   
+        -widthscale 2
+
+</verb>
+</p><p>
+Most of the time, you will want to use the same configuration
+ for  each game. xmame/xmess will read this file for default values
+ for the  parameters that you can set. This way the only parameters
+ you  need to express on the command line are the ones you want to
+  override.
+
+</p>
+<p>
+Another reason for xmamerc/xmessrc is keyboard remapping. Some
+ Unix  keyboards are very different than their PC counterparts. To
+  compensate for the changes, xmame/xmess allows you to remap keys
+ that  are not available on Unix keyboards to keys that are available.
+
+</p>
+<sect1>
+What is the syntax of the xmamerc/xmessrc file.
+<p>
+The syntax is quite simple:
+
+</p>
+
+<p>
+<verb>
+   &quot;keyword value&quot;
+
+</verb>
+</p><p>
+See <url url="xmamerc.dist" name="xmamerc.dist"> for most keywords. Allmost all commandline options can be
+ used as keywords (without the -), use value 0 or 1 for commandline
+ options which have a negating (-no&lsqb;option&rsqb;) counterpart.
+ As usual lines begining with &quot;&num;&quot; are comments.
+
+</p>
+<p>
+You can also generate a configfile with all the current settings
+ to use as a template by typing:
+
+</p>
+
+<p>
+<verb>
+   xmame -showconfig &gt; &tilde;/.xmame/xmamerc
+
+</verb>
+</p><sect1>
+Where do roms, images, samples, highscores, configfiles, etc
+ go? <label id="FAQ: Where do roms, images, samples, highscores, configfiles, etc go?" >
+<sect2>
+Roms/Samples
+<p>
+Xmame/xmess uses a &quot;:&quot; seperated rompath to find out
+ which dirs to search for roms/samples.
+
+</p>
+<p>
+The default rompath is XMAMEROOT as defined in Makefile during
+ compile.
+
+</p>
+<p>
+This is overwritten by any rompath in xmamerc/xmessrc, which
+ can be overwritten again with the -rompath commandline option.
+
+</p>
+<p>
+Xmame/xmess searches every dir in this path for roms/samples
+ in the following way:
+
+</p>
+
+<p>
+<verb>
+    &lt;dir&gt;/gamename.zip             (containing filename.ext)
+    &lt;dir&gt;/gamename/filename.ext
+    &lt;dir&gt;/gamename/filename.ext.gz (containing filename.ext)
+    &lt;dir&gt;/gamename/filename.zip    (containing filename.ext)
+
+</verb>
+</p><p>
+So let's say that we are searching for rom0001.1, which is part
+ of pacman. Then xmame/xmess would search every dir in your rompath
+ for
+
+</p>
+
+<p>
+<verb>
+    &lt;dir&gt;/pacman.zip               (containing rom0001.1)
+    &lt;dir&gt;/pacman/rom0001.1
+    &lt;dir&gt;/pacman/rom0001.1.gz      (containing rom0001.1)
+    &lt;dir&gt;/pacman/rom0001.zip       (containing rom0001.1)
+
+</verb>
+</p><p>
+Note: If your neogeo games can't find neogeo.rom, put it in a
+ dir called neogeo somewhere in your rompath, or put it in neogeo.zip
+ somewhere in your rompath.
+
+</p>
+<sect2>
+Read/write Diskette Images
+<p>
+This section only applies to xmess emulations which support read/write
+ diskette images and thus try to open the image read/write.
+
+</p>
+<p>
+Xmess first searches for read/write images with the name specified
+ on the commandline:
+
+</p>
+
+<p>
+<verb>
+    &lt;path&gt;/image.ext
+
+</verb>
+</p><p>
+where path is the path specified with the image on the commandline.
+ This way, absolute and relative filenames can be used directly on
+ the commandline for an image which is not in the rompath.
+
+</p>
+<p>
+Then xmess searches every dir in the rompath for roms/samples
+ in the following way:
+
+</p>
+
+<p>
+<verb>
+    &lt;dir&gt;/image.ext
+
+</verb>
+</p><p>
+Note that (g)zipped images are not supported for r/w images.
+
+</p>
+<sect2>
+Rom Cartridges/Read Only Diskette Images
+<p>
+Xmess begins by searching for cartdriges/disks from the current
+ dir in the following way:
+
+</p>
+
+<p>
+<verb>
+    &lt;path&gt;/image.ext
+    &lt;path&gt;/image.ext.gz            (containing image.ext)
+    &lt;path&gt;/image.zip               (containing image.ext)
+
+</verb>
+</p><p>
+where path is the path specified with the image on the commandline.
+ This way, absolute and relative filenames can be used directly on
+ the commandline for an image which is not in the rompath.
+
+</p>
+<p>
+Then xmess searches every dir in the rompath for carts/images
+ in the following way:
+
+</p>
+
+<p>
+<verb>
+    &lt;dir&gt;/image.ext
+    &lt;dir&gt;/image.ext.gz             (containing image.ext)
+    &lt;dir&gt;/image.zip                (containing image.ext)
+
+</verb>
+</p><p>
+Finally, xmess searches the rompath as desribed above using the
+ systemtype for gamename.
+
+</p>
+<p>
+So let's say we want to play mario.nes on the nes emulation of
+ xmess. We would then type: &quot;xmess nes mario.nes&quot;. Xmess
+ then begins by searching the current dir for
+
+</p>
+
+<p>
+<verb>
+    mario.nes
+    mario.nes.gz                   (containing mario.nes)
+    mario.zip                      (containing mario.nes)
+
+</verb>
+</p><p>
+After that, xmess searches each dir in your rompath for
+
+</p>
+
+<p>
+<verb>
+    &lt;dir&gt;/mario.nes
+    &lt;dir&gt;/mario.nes.gz             (containing mario.nes)
+    &lt;dir&gt;/mario.zip                (containing mario.nes)
+
+</verb>
+</p><p>
+And finally, xmess searches each dir in your rompath for
+
+</p>
+
+<p>
+<verb>
+    &lt;dir&gt;/nes.zip                  (containing mario.nes)
+    &lt;dir&gt;/nes/mario.nes
+    &lt;dir&gt;/nes/mario.nes.gz         (containing mario.nes)
+    &lt;dir&gt;/nes/mario.zip            (containing mario.nes)
+
+</verb>
+</p><p>
+Since xmess first searches for cartridges/disks from the current
+ dir you can also specify cartridges/disks not in your rompath. For
+ example:
+
+</p>
+
+<p>
+<verb>
+    &quot;xmess nes ../mario.nes&quot;
+
+</verb>
+</p><p>
+Xmess then searches for
+
+</p>
+
+<p>
+<verb>
+    ../mario.nes
+    ../mario.nes.gz                (containing mario.nes)
+    ../mario.zip                   (containing mario.nes)
+
+</verb>
+</p><p>
+and will also search the rompath as described above with ../mario.nes
+ as the image name but this is not that useful.
+
+</p>
+<sect2>
+Artwork
+<p>
+Xmame/xmess searches every dir in the rompath for artwork in
+ the following way:
+
+</p>
+
+<p>
+<verb>
+    &lt;dir&gt;/artwork.png
+    &lt;dir&gt;/artwork.png.gz           (containing artwork.png)
+    &lt;dir&gt;/artwork.zip              (containing artwork.png)
+
+</verb>
+</p><p>
+Then xmame/xmess searches the rompath as in roms/samples.
+
+</p>
+<p>
+So let's say we want to play foo which uses bar.png. Xmame/xmess
+ then begins searching each dir in your rompath for
+
+</p>
+
+<p>
+<verb>
+    &lt;dir&gt;/bar.png
+    &lt;dir&gt;/bar.png.gz               (containing bar.png)
+    &lt;dir&gt;/bar.zip                  (containing bar.png)
+
+</verb>
+</p><p>
+And then xmame/xmess searches each dir in your rompath for
+
+</p>
+
+<p>
+<verb>
+    &lt;dir&gt;/foo.zip                  (containing bar.png)
+    &lt;dir&gt;/foo/bar.png
+    &lt;dir&gt;/foo/bar.png.gz           (containing bar.png)
+    &lt;dir&gt;/foo/bar.zip              (containing bar.png)
+
+</verb>
+</p><sect2>
+Xmame configuration
+<p>
+Xmame looks for the following configuration files and parses
+ each one found. Files parsed later can overwrite options in previously
+ parsed files:
+
+</p>
+
+<p>
+<verb>
+    XMAMEROOT/xmamerc
+    XMAMEROOT/xmame-DISPLAY_METHODrc
+    &dollar;&lcub;HOME&rcub;/.xmame/xmamerc
+    &dollar;&lcub;HOME&rcub;/.xmame/xmame-DISPLAY_METHODrc
+    &dollar;&lcub;HOME&rcub;/.xmame/rc/&lt;gamename&gt;rc
+
+</verb>
+</p><p>
+<tt>XMAMEROOT</tt> is defined during compile time, see Makefile.
+
+</p>
+<p>
+<tt>DISPLAY_METHOD</tt> is the <tt>DISPLAY_METHOD</tt> for which xmame was compiled,
+ this can be one of: x11, svgalib, ggi, xgl, xfx, svgafx, openstep,
+ SDL.
+
+</p>
+<p>
+For xmess of course replace xmame by xmess. ;)
+
+</p>
+<sect2>
+Game configuration
+<p>
+Game configuration files are kept on a per-user base in:
+
+</p>
+
+<p>
+<verb>
+    &dollar;&lcub;HOME&rcub;/.xmame/cfg/&lt;game&gt;.cfg resp
+    &dollar;&lcub;HOME&rcub;/.xmess/cfg/&lt;game&gt;.cfg
+
+</verb>
+</p><sect2>
+Game state
+<p>
+Game state files are kept on a per-user base in:
+
+</p>
+
+<p>
+<verb>
+    &dollar;&lcub;HOME&rcub;/.xmame/sta/&lt;game&gt;.sta resp
+    &dollar;&lcub;HOME&rcub;/.xmess/sta/&lt;game&gt;.sta
+
+</verb>
+</p><sect2>
+NVram
+<p>
+NVram files are kept on a per-user base in:
+
+</p>
+
+<p>
+<verb>
+    &dollar;&lcub;HOME&rcub;/.xmame/nvram/&lt;game&gt;.nv resp
+    &dollar;&lcub;HOME&rcub;/.xmess/nvram/&lt;game&gt;.nv
+
+</verb>
+</p><sect2>
+Mem cards
+<p>
+Mem cards files are kept on a per-user base in:
+
+</p>
+
+<p>
+<verb>
+    &dollar;&lcub;HOME&rcub;/.xmame/mem/&lt;filename&gt;.mem resp
+    &dollar;&lcub;HOME&rcub;/.xmess/mem/&lt;filename&gt;.mem
+
+</verb>
+</p><p>
+Where &lt;filename&gt; is given by the game-driver. 
+
+</p>
+<sect2>
+Screenshots
+<p>
+Screenshots, which can be made by pressing F12, are saved as
+ png files in the directory from where xmame is started (cwd).
+
+</p>
+<p>
+This can be overidden by the screenshotdir entry in xmamerc/xmessrc,
+ which can again be overidden by the <tt>-screenshotdir</tt> cmdline-option.
+
+</p>
+<p>
+They are saved as:
+
+</p>
+
+<p>
+<verb>
+    &lt;screenshotdir&gt;/&lt;game&gt;xxxx.png
+    Where xxxx is a number.
+
+</verb>
+</p><sect2>
+Highscores
+<p>
+Highscores are stored in XMAMEROOT as defined in Makefile when
+ building. This can be overidden by the spooldir entry in xmamerc/xmessrc,
+ which can again be overidden by the <tt>-spooldir</tt> cmdline-option.
+
+</p>
+<p>
+So only give a 
+
+</p>
+
+<p>
+<verb>
+    drwxrwsr-x root games &lt;spooldir&gt;
+
+</verb>
+</p><p>
+permission and setgid xmame/xmess to &quot;games&quot; to get
+ it to work. Note this doesn't work with suid root versions (svgalib
+ &amp; XF86-DGA), suggestions welcome.
+
+</p>
+<p>
+For now use <tt>&dollar;&lcub;HOME&rcub;/.xmame</tt> or <tt>&dollar; &lcub;HOME&rcub;/.xmess</tt>
+ as the spooldir in xmamerc/xmessrc for  suid root versions.
+
+</p>
+<p>
+Note: For highscores to work, xmame must also be able to find
+ hiscore.dat.
+
+</p>
+<sect2>
+hiscore.dat
+<p>
+If you want to use highscores mame needs to load hiscore.dat
+ to get highscore info.
+
+</p>
+<p>
+The default is <tt>XMAMEROOT</tt>/hiscore.dat . XMAMEROOT is set during
+ compile-time; see the Makefile. This can be overridden by the hiscorefile
+ entry in xmamerc if present, which can again be overridden by the
+ cmdline-option <tt>-hiscorefile</tt>.
+
+</p>
+<p>
+<tt>hiscore.dat</tt> is available from the mame homepage: <url url="http://www.mame.net" name="http://www.mame.net">
+
+</p>
+<sect2>
+cheat.dat
+<p>
+If you want to use cheats mame needs to load cheat.dat to get
+ cheat info.
+
+</p>
+<p>
+The default is XMAMEROOT/cheat.dat . XMAMEROOT is set during
+ compile-time; see the Makefile. This can be overridden by the cheatfile
+ entry in xmamerc if present, which can again be overridden by the
+ cmdline-option <tt>-cheatfile</tt>.
+
+</p>
+<p>
+<tt>cheat.dat</tt> is available from the mame homepage: <url url="http://www.mame.net" name="http://www.mame.net">
+
+</p>
+<sect2>
+history.dat
+<p>
+If you want to display some nice background info on games, mame
+ needs to load history.dat.
+
+</p>
+<p>
+The default is XMAMEROOT/history.dat . XMAMEROOT is set during
+ compile-time, see the Makefile. This can be overridden by the historyfile
+ entry in xmamerc if present, which can again be overridden by the
+ cmdline-option <tt>-historyfile</tt>.
+
+</p>
+<p>
+<tt>history.dat</tt> is available from the mame homepage: <url url="http://www.mame.net" name="http://www.mame.net">
+
+</p>
+<sect2>
+Input logs
+<p>
+Input logs are saved/read under the name specified after the
+ <tt>-record / -playback</tt> option; this name is relative to the current
+ path.
+
+</p>
+<sect2>
+Xmame/xmess still can't find files/store highscores
+<p>
+Type <tt>&quot;xmame/xmess -showconfig | more&quot;</tt> and check that
+ the rompath and spooldir shown are correct and readable/writable.
+ Otherwise recheck xmamerc/xmessrc. Remember that xmess also searches
+ the current dir.
+
+</p>
+<sect1>
+How do I start xmess/xmame ?
+<p>
+To start xmame, type
+
+</p>
+
+<p>
+<verb>
+    xmame &lsqb;options&rsqb; &lt;gamename&gt; &lsqb;more options&rsqb;
+
+</verb>
+</p><p>
+For xmess, type
+
+</p>
+
+<p>
+<verb>
+    xmess &lsqb;options&rsqb; &lt;systemname&gt; &lsqb;more options&rsqb; &bsol;
+    &lt;disk/romimage(s)&gt; &lsqb;more options&rsqb;
+
+</verb>
+</p><p>
+All options are optional. ;)
+
+</p>
+<p>
+Xmame/xmess supports most dos command line options (see readme.mame
+ / readme.mess) as well as a few of its own: Type xmame -help |  more
+ for a complete list.
+
+</p>
+<p>
+With xmess, some systems don't require a disk/romimage, but most
+ do.
+
+</p>
+<sect1>
+What are the command line parameters for xmame/xmess?
+<p>
+To see a list of available parameters, type:
+
+</p>
+
+<p>
+<verb>
+    /usr/games/xmame -help | more
+
+</verb>
+</p><p>
+Xmame/xmess supports most of the command line parameters as the
+ DOS  version as well a some of its own.
+
+</p>
+<p>
+See the file readme.mame / readme.mess for more information about
+ the command line parameters.
+
+</p>
+<sect1>
+What keys does xmame/xmess use?<label id="FAQ: What keys does xmame/xmess use?" >
+<p>
+Xmame/xmess uses the same key-bindings as the DOS version of
+ mame: The following keys work in all emulators:
+
+</p>
+
+<p>
+<verb>
+    `  or &tilde;      Enter On screen display to change volume, brightness etc.
+    Tab          Enter configuration menu. Press Tab or Esc to get back to
+                 the emulation.
+    P            Pause
+    F3           Reset
+    F4           Show the game graphics. Use cursor keys to change set/color,
+                 F4 or Esc to return to the emulation.
+    F8           Reduce frame skip
+    F9           Increase frameskip
+    F10          Toggle speed throttling
+    F10 + shift  Toggle idle sleeping
+    F11          Toggle speed display
+    F11 + shift  Toggle profiler display
+    F12          Save a screen snapshot
+    ESC          Exit emulator
+
+</verb>
+</p><p>
+Xmame has 2 different auto frameskipping algorithms. These can
+ be selected with the -frameskipper option and with key combos:
+
+</p>
+
+<p>
+<verb>
+    Key combo:             Gives you the:
+    left-ctrl + insert     standard dos frameskipper
+    left-ctrl + home       William Barath's frameskipper
+
+</verb>
+</p><p>
+Xmame's display scaling can be controlled on the fly with the
+ following key combos:
+
+</p>
+
+<p>
+<verb>
+    Key combo:             Result:
+    left-shift + insert    Increase widthscale
+    left-shift + delete    Decrease widthscale
+    left-shift + home      Increase heightscale
+    left-shift + end       Decrease heightscale
+    left-shift + pageup    Increase scale
+    left-shift + pagedown  Decrease scale
+
+</verb>
+</p><p>
+Under X11, xmame can switch to and from different modes during
+ runtime: 
+
+</p>
+
+<p>
+<verb>
+    Key combo:             Warps you to:
+    left-alt + insert      Normal window
+    left-alt + home        DGA fullscreen mode
+
+</verb>
+</p><p>
+Under SDL, xmame can switch to and from different modes during
+ runtime:
+
+</p>
+
+<p>
+<verb>
+    Key combo:             Result:
+    left-alt + enter       Toggles between windowed and
+                           fullscreen modes.
+
+</verb>
+</p><p>
+Under X11 in a window, you can also grab the mouse. To be able
+ to play with the mouse, press left-alt + page-down to grab the mouse,
+ and press it again to release it.
+
+</p>
+<sect1>
+Why doesn't a game have sound?
+
+<p>
+<itemize>
+ <item>
+First check that sound is working in other applications.
+ <item>
+Check that sound is supported for the game that has no sound;
+ not all games have sound.
+ <item>
+For xmame, take a look at gamelist.mame: Is the sound for the
+ game emulated?
+ <item>
+For xmess take a look at readme.mess: Is the sound for the system
+ emulated?
+ <item>
+Check the operating system support chart in the earlier part
+ of  this file: Does xmame/xmess support sound on your system?
+
+</itemize>
+</p><sect1>
+My sound seems lagged. / My sound Clicks. / What does -bufsize
+ do?
+<p>
+With the <tt>-bufsize</tt> commandline option or the bufsize configfile
+ keyword, you can specify the number of frames of audio to buffer.
+ The default is 2 frames.
+
+</p>
+<p>
+This value should be ok for everyone, but if you still have problems,
+ read on.
+
+</p>
+<p>
+If the buffersize is to small, this causes the buffer to get
+ empty between frames which in turn causes clicks/pauses in the sound.
+ If this is the case, increasing the -bufsize value to, for example,
+ 2.5 should help.
+
+</p>
+<p>
+If, however, you make the buffersize too large, then so much
+ audio becomes buffered, that the sound could become lagged. E.g.,
+ you would hear the coin drop sound 0.5 seconds after pressing the
+ insert coin key. In this case, lower the bufsize to, for example,
+ 1.5.
+
+</p>
+<p>
+Please let me know if you need to change this setting, since
+ I'm planning on removing it in a future release.
+
+</p>
+<sect1>
+Why doesn't a game work? <label id="FAQ: Why doesn't a game work?" >
+
+<p>
+<itemize>
+ <item>
+Do you have the right roms or did you get checksum failures?
+ <item>
+Xmame version 0.34 and higher require PROM files that were not
+ included in ROM images released before version 0.34. See the question
+ on PROMs  below for more information.
+ <item>
+For xmame, check the file gamelist.mame to see if the game is
+ playable. Just because a game is included doesn't mean it is working
+ yet.
+ <item>
+For xmess, take a look at readme.mess. Maybe the system isn't
+ emulated all that well yet.
+ <item>
+Some games require sound support. If you don't have sound  support
+ under your Unix installation or sound isn't supported by xmame/xmess
+ for you, try the <tt>-fakesound</tt> command line parameter.
+
+</itemize>
+</p><sect1>
+What are PROMs? <label id="FAQ: What are PROMs?" >
+<p>
+PROMs contain game-specific information that used to be built
+ in  to mame in versions prior to 0.34. This information has been
+  extracted and is now included with new versions of ROM files for
+  games that require this information.
+
+</p>
+<p>
+If you want to use your current ROM files, you can obtain just
+ the PROM images in one large file at:
+
+</p>
+<p>
+<url url="http://mame.retrogames.com/" name="http://mame.retrogames.com/">
+
+</p>
+<sect1>
+Why is xmame/xmess slow?
+<p>
+Xmame/xmess is a compiled C program that is emulating hardware.
+  Software emulation of hardware always incurs a speed penalty. Here
+  are some things you can do:
+
+</p>
+
+<p>
+<itemize>
+ <item>
+Try using the -frameskip command line parameter.
+ <item>
+Try pressing F8 while running xmame/xmess to alter the frame
+ rate.
+ <item>
+Try disabling the throttle with the -nothrottle command line
+  parameter or by pressing F10 while running xmame/xmess.
+ <item>
+While running xmame/xmess, press F11 to check the speed of xmame/xmess.
+  If you never get a display of 100&percnt;, you need a faster computer.
+
+</itemize>
+</p><p>
+You can also try recompiling xmame/xmess with more optimal settings.
+ The following suggestions may not work or may not be appropriate
+ on some machines and in some installations.  However, in cases where
+ they do work, there can be a noticeable increase in overall performance
+ of xmame/xmess.
+
+</p>
+<p>
+These &quot;enhancements&quot; simply require editing the Makefile
+ that is distributed with xmame, and then recompiling the source.
+  If you are compiling the source for the second time you will need
+ to do:
+
+</p>
+
+<p>
+<verb>
+    make clean
+    make
+    make install
+
+</verb>
+</p><p>
+after editing the Makefile to set your new settings.
+
+</p>
+<sect2>
+SPEEDUP &num; 1 - Inline compiling
+<p>
+Try enabling inline compiling by commenting and uncommenting
+ the following lines:
+
+</p>
+
+<p>
+<verb>
+    &num; IL    = '-DINLINE=static inline'
+    IL     = -DINLINE=static
+
+</verb>
+</p><sect2>
+SPEEDUP &num; 2 - Direct Graphics Access
+<p>
+For a big boost, try enabling DGA by uncommenting the following
+ line:
+
+</p>
+
+<p>
+<verb>
+    DGA = 1
+
+</verb>
+</p><p>
+Then start xmame as root, and press left-alt + home to switch
+ to dga mode; that should be a lot faster, and doesn't need/use xsync.
+ ;) 
+
+</p>
+<p>
+To get back to a window without exiting, press left-alt + insert.
+
+</p>
+<p>
+The benefit of DGA is that it is Direct Graphics Access and therefore
+ writes directly to the framebuffer (think DirectX versus GDI under
+ MS Windows). So it should be a tad faster, unless you've got a really
+ really well accelerated X server, which could be just as fast. Try
+ pressing F11 to see the actual framerate, although it might be hardly
+ noticable (visually, at least), it should give you some speed increase.
+
+</p>
+<p>
+Besides that, it automatically switches to the right mode and
+ removes any window manager stuff, but that can be done without DGA
+ too. (I might add such a feature later, since it allows easy fullscreen
+ without running as root.)
+
+</p>
+<p>
+Adding a 320x240 mode will most definitely get you a very nice
+ fullscreen display at scale = 1. ;)
+
+</p>
+<p>
+Don't forget that you still need to set up the Modes line of
+ the   &quot;Display&quot; subsection of the &quot;Screen&quot; section
+ in your X11 config file if you want the games to fill the screen
+ in DGA mode. Xmame will pick the best mode it can find, so if you
+ have a line like
+
+</p>
+
+<p>
+<verb>
+    Modes  &quot;1024x768&quot; &quot;800x600&quot; &quot;640x480&quot; &quot;320x240&quot; &quot;256x224&quot;
+
+</verb>
+</p><p>
+then any game which fits into a 320x240 screen can be displayed
+ in that resolution, and so on. Don't forget your X11 config file
+ might have a number of different &quot;Screen&quot; sections in it,
+ and you will need to add Modes to the one that is actually active
+ with your Xserver is running. And of course it's not always that
+ easy, since you also need to tell X which monitor settings are required
+ for these resolution modes. This is done through Modeline entries
+ in the &quot;Monitor&quot; section of your X config file.
+
+</p>
+<p>
+You can check out the <tt>/contrib/tools/modelines</tt> file for a set
+ of crazy modes made especially for xmame in DGA mode. They should
+ work on any reasonable multisync monitor, but don't use them on an
+ old fixed-frequency monitor. (And if you can't resist trying, I won't
+ pay for a new one!)
+
+</p>
+<sect2>
+SPEEDUP &num; 3 - NASM
+<p>
+You can also try installing nasm and compiling the asm core,
+ that helps a bit too.
+
+</p>
+<sect2>
+SPEEDUP &num; 4 - ICC
+<p>
+If you are running on an intel architecture machine, you could
+ try to compile xmame with the Intel C Compiler. Some people have
+ reported speed gains from +10&percnt;.
+
+</p>
+<sect1>
+I've got a dual processor machine. What can I do to take full
+ advantage of this?
+<p>
+Not much. Xmame is a single-threaded port of a single-threaded
+ DOS app. Some degree of speedup will hopefully be found on an SMP
+ machine since xmame is more likely to get to hog its one CPU for
+ longer. But of course the same applies to any CPU-intensive program.
+ And all the things one would normally do to any application to give
+ it more CPU time (higher priority, kill or renice unecessary process,
+ etc.) will work with xmame.
+
+</p>
+<p>
+Now you may at this point be thinking, "Surely you could have
+ one thread doing emulation and another thead doing graphics to get
+ a speedup." Yes, but there are some serious issues to consider. The
+ first is synchronisation between the threads, which needs to be pretty
+ tight. If not done smoothly. the overhead will blow most of the benefit
+ away. Also, it needs to be implemented with a portable threads interface
+ ... which basically means POSIX threads. In a nutshell, it's a lot
+ of effort for probably not much gain. But of course if you are feeling
+ particulary energetic and in the mood to code, then patches can always
+ be submitted to the xmame devel mailing list ... :)
+
+</p>
+<sect1>
+Why doesn't my joystick handle diagonal movement correctly on
+ my Intel x86 system?
+<p>
+Xmame/xmess uses autocalibrating, but you could try to use specific
+ programs to calibrate it (jscal that comes with joystick  module
+ works fine....).
+
+</p>
+<sect1>
+How do I enable XinputExtensions X11 based joystick in Xfree86?
+<p>
+You need to edit XF86Config to enable the XInput section. See
+ the  manual page for XF86Config.
+
+</p>
+<sect1>
+How do I read a manual page?
+<p>
+Easy. If you want to read the manual page for XF86Config, type:
+ man XF86Config
+
+</p>
+<sect1>
+Why do I get gz_open symbol not found while compiling? <label id="FAQ: Why do I get gz_open symbol not found while compiling?" >
+<p>
+Xmame/xmess versions newer than 0.35 use zlib for some compression
+ routines. Unfortunately, a lot of Linux distributions have an old
+ version of zlib installed as /usr/X11R6/lib/libz.a, and the new version
+ installed as /usr/lib/libz.a. If this is the case, it's harmless
+ to remove /usr/X11R6/lib/libz.a. If you're not sure whether this
+ is the case, just move /usr/X11R6/lib/libz.a to another location.
+
+</p>
+<p>
+Removing or just moving /usr/X11R6/lib/libz.a should fix this
+ problem.
+
+</p>
+<p>
+Also see: <ref id="FAQ: Why do I get zlib.h not found?" name="FAQ: Why do I get zlib.h not found?" >
+
+</p>
+<sect1>
+Why do I get zlib.h not found? <label id="FAQ: Why do I get zlib.h not found?" >
+<p>
+Xmame/xmess versions newer than 0.35 use zlib for some compression
+ routines.
+
+</p>
+<p>
+Zlib is standard on most Unix versions. For those who don't ship
+ with zlib or ship with a version that is too old, xmame/xmess now
+ comes with a stripped-down version of zlib. Uncomment the appropriate
+ line in the Makefile to use this.
+
+</p>
+<sect1>
+When I run xmame.x11, nothing happens---no window pops up or
+ anything. Help!
+<p>
+Are you running a recent version of KDE, such as 2.1.1? It appears
+ that there's a bug with KDE's window manager that prevents some X11
+ apps from popping up their main window. You can either run the SDL
+ version of xmame, or try the following workaround, which several
+ people have reported as being successful:
+
+</p>
+
+<p>
+<verb>
+xmame.x11 -rid `xwininfo -root | grep xwininfo: | awk '&lcub;print &dollar;4&rcub;'`
+
+</verb>
+</p><sect1>
+Can I run xmame fullscreen?
+<p>
+Yes, of course you can. There are several ways to accomplish
+ this, each with its own advantages and disadvantages.
+
+</p>
+<p>
+To enable the fullscreen support, you will need to change some
+ settings in the makefile and recompile xmame.
+
+</p>
+<p>
+Besides the x11 and SDL drivers, the FX and GL drivers are also
+ capable of playing games full screen. There is a separate chapter
+ for these later on.
+
+</p>
+<sect2>
+xmame.x11/DGA
+<p>
+First, before recompiling, make sure you have an xserver with
+ the "xfree-dga&quot; extension enabled (do a "xdpyinfo" and see if you've
+ got the "xfree-dga&quot; extension); any recent release of XFree86
+ should have it.
+
+</p>
+<p>
+Select DISPLAY_METHOD = x11 and uncomment the line "DGA=1&quot;
+ in the makefile.
+
+</p>
+<p>
+Now build xmame and give the xmame.x11 file permanent root permissions
+ so that you don't need to start xmame as root (do a "chown root xmame.x11&quot;
+ and a "chmod u+s xmame.x11&quot;).
+
+</p>
+<p>
+If you want to start immediately in fullscreen mode, start xmame.x11
+ with the &quot;-x11 1&quot; argument or specify &quot;x11-mode 1&quot;
+ in your xmamerc file.
+
+</p>
+<p>
+During play you can switch between windowed and fullscreen mode.
+ See <ref id="FAQ: What keys does xmame/xmess use?" name="What keys does xmame/xmess use?" >
+
+</p>
+<sect2>
+xmame.x11/Xv
+<p>
+Xv is the X Window System video extension. Among other things,
+ it supports hardware scaling if your graphics card (and X driver)
+ is capable of doing so. You can achieve a very nice fullscreen display
+ without taxing your cpu very much because the scaling will all be
+ done by your video card.
+
+</p>
+<p>
+To determine if your video card supports the Xv extension, you
+ may use this command:
+
+</p>
+
+<p>
+<verb>
+xvinfo
+
+</verb>
+</p><p>
+If you don't see a message indicating "no screens found", then
+ the Xv extension is supported by your machine.
+
+</p>
+<p>
+To compile this into xmame, select DISPLAY_METHOD = x11 and uncomment
+ the line "X11_XV = 1" in the makefile.
+
+</p>
+<p>
+Build xmame, and use the -fullscreen parameter when loading a
+ game to get a nice fullscreen display.
+
+</p>
+<p>
+If the colors seem messed up and/or you only see half of the
+ game image, try using "-yuv" or "-yv12". By default, the Xv extension
+ attempts to use RGB mode if your driver supports it, but some cards'
+ drivers are broken.
+
+</p>
+<p>
+If your screen goes blank or gets full of little green vertical
+ lines, then your graphics card does not support the Xv extension
+ and you're out of luck.
+
+</p>
+<sect2>
+xmame.SDL
+<p>
+The SDL library was meant to make it easy for programmers to
+ make full screen applications. To start SDL in fullscreen mode, just
+ run xmame.SDL with the option '-fullscreen'. If you want to know
+ the resolutions that SDL can use, run "xmame.SDL -listmodes", choose
+ the resolution you want, and start "xmame.SDL -modenumber &lt;insert
+ chosen number here&gt;".
+
+</p>
+<p>
+You can add "fullscreen 1" to your xmamerc file if you want SDL
+ to start fullscreen automatically; the modenumber line can also be
+ used in the xmamerc. :-)
+
+</p>
+<p>
+Most problems experienced by people who are trying to use SDL
+ for fullscreen are related to the section <ref id="FAQ: xmame.sdl / xmame.x11 fullscreen has a large border around the game." name="fullscreen has a large border" >
+
+</p>
+<p>
+During play you can switch between windowed and fullscreen mode.
+ See <ref id="FAQ: What keys does xmame/xmess use?" name="What keys does xmame/xmess use?" >
+
+</p>
+<sect1>
+xmame.SDL / fullscreen has a large border around the game. <label id="FAQ: xmame.sdl / xmame.x11 fullscreen has a large border around the game." >
+<p>
+If the game runs in fullscreen but occupies only a small area
+ in the center of the screen, then your xserver does not have access
+ to low resolutions (320x240, 400x300, and 512x384, for instance).
+ In the case of SDL, the window will be in the resolution of closest
+ matching resolution that SDL can switch to for full screen display.
+
+</p>
+<p>
+In this case, you have to add &quot;Modelines&quot; for these
+ resolutions in your XF86config file and add these resolutions to
+ the resolutions list of your display somewhere in your XF86config
+ file (you know, the list of resolutions you can switch to using ctrl-+).
+
+</p>
+<p>
+You should find modelines that works with most graphic cards
+ in the xmame contrib subdirectory.
+
+</p>
+<p>
+If you don't want to alter your XF86config file, another solution
+ is to run xmame.x11 with the &quot;-scale 2&quot; argument. In this
+ case, the emulator will use 640x480 instead of 320x240, 800x600 instead
+ of 400x300, etc. But I don't recommend it. The scaling uses cpu and
+ the games will run more slowly.
+
+</p>
+<p>
+However, if your cpu is fast enough, a better option is to use
+ the effects "-ef 1". This introduces advanced render methods to create
+ a nicer looking effect than the simple scaling. On the website you
+ can see <url url="http://x.mame.net/gamescreenshots.html" name="screenshots"> of the different effects.
+
+</p>
+<sect1>
+I only use some of the emulation parts (Neo Geo / CPS-2 /...).
+ Do I need the entire xmame? 
+<p>
+If you are interested in compiling only some of the games you,
+ can compile xmame with an alternate target. Edit the makefile.unix
+ and change the target line to accomplish the desired effect. Using
+ this approach, only the CPUs, sound devices, and other chips needed
+ for that particular target are compiled, resulting in a much smaller
+ executable.
+
+</p>
+
+<p>
+<itemize>
+ <item>
+'TARGET = cpmame' makes a mame version that will only emulate
+ the CPS-1 and CPS-2 games
+ <item>
+'TARGET = neomame' makes a mame version that will only emulate
+ the Neo Geo system
+
+</itemize>
+</p><p>
+There are some other targets but they are really only useful
+ for the mame developers who create new drivers.
+
+</p>
+<sect1>
+Why does xmame freeze and lock up when I hit &lt;ESC&gt; to exit
+ the game or P to pause the game?
+<p>
+There appears to be a bug in the &quot;timer based audio&quot;
+ code that xmame/oss uses on at least one motherboard that we are
+ aware of. Specifically, the ATX 845Pro (Intel Pentium 4 processor)
+ with an integrated i810 soundchip.
+
+</p>
+<p>
+To get around this bug use EsounD (Enlightened Sound Daemon),
+ found as esd with Gnome distributions, instead of the oss sound drivers.
+
+</p>
+<p>
+Compile ESOUND support into the xmame executable by uncommenting
+ the appropriate line in makefile.unix. Tell xmame to use esound by
+ specifying &quot;esound&quot; on the &quot;dsp-plugin&quot; line
+ in xmamerc, or use the -dp command line parameter to select esound.
+ Also see the next section below.
+
+</p>
+<sect1>
+Why does xmame report &quot;can't resolve host name '/dev/dsp'
+ when trying to use esound?
+<p>
+Remove the words &quot;/dev/dsp&quot; from the &quot;audiodevice&quot;
+ line in xmamerc. In other words, you want to have the word &quot;audiodevice&quot;
+ on a line all by itself, with no audiodevice specified.
+
+</p>
+<sect1>
+Where can I get the latest version of xmame/xmess?
+<p>
+The xmame/xmess Home Page always has the most up-to-date version.
+ The address is
+
+</p>
+<p>
+<url url="http://x.mame.net/" name="http://x.mame.net/">
+
+</p>
+<sect1>
+I upgraded xmame and now some games do not work anymore.
+<p>
+This can happen, especially if the drivers are in full development
+ or some internal core routines have changed and the drivers have
+ to be updated to accomodate for these core changes. Sometimes a new
+ romdump has been made from the game and you still have the old version,
+ or the zipfile has changed names and you need to rename yours (or
+ any combination of these factors :-).
+
+</p>
+<p>
+Here are some things you can do:
+
+</p>
+
+<p>
+<enum>
+ <item>
+Clear all the old configuration files, nvram files, etc. Also
+ delete the content of the directories mem, nvram, cfg, and try to
+ run the game again. Don't forget to delete the default.cfg file!
+ <item>
+If that fails, check to see if the name of the zipfile is still
+ in the list of supported games. If you enter an invalid game name,
+ xmame will take a guess to determine which game you wanted; look
+ at the first lines of output to see if it tries to load a different
+ game than the one you want. To know if your game is still supported,
+ try 'xmame.x11 -list gamename'. If you do not pass a game name, the
+ complete list of supported games is printed, and you can search for
+ the new game name (better use 'xmame.x11 -listfull').
+ <item>
+If the name hasn't changed, check to see if you have the correct
+ romdump. Run 'xmame.x11 -verifyroms gamename' to check your romset.
+ If this fails you will need to download a newer romdump. Also check
+ your parent roms as a possible cause of this romset failure.
+ <item>
+Read the documentation!! Or like the experts would say, "RTFM!"
+ :-) Chances are that if the driver is broken, the developer has noted
+ this in the documentation.
+ <item>
+If the above steps don't solve the problem, then check to see
+ if it is a known problem; if necessary, report it to the mame testers
+ project.
+
+</enum>
+</p><p>
+If none of these fixes the problem, then try using the older
+ version of xmame you have backed up somewhere to play the game. (You
+ did back-up, didn't you?)
+
+</p>
+<sect1>
+Where can I send fixes, bug reports, suggestions, or money? 
+ :-)
+<p>
+See <ref id="Mail" name="Mail" > of this document.
+
+</p>
+<sect1>
+What if my question is still not answered?
+<p>
+Please check the offical mame and mess readme files to see if
+ that answers your question:
+
+</p>
+
+<p>
+<itemize>
+ <item>
+<url url="readme.mame" name="The official mame readme file (readme.mame)">
+ <item>
+<url url="readme.mess" name="The official mess readme file (readme.mess)">
+
+</itemize>
+</p><p>
+If that doesn't help, then ask your question on the mailing list
+ or send it to the xmame/xmess maintainer, see  <ref id="Mail" name="Mail" > for contact information.
+
+</p>
+<sect>
+Display Subsystem-Specific Comments and Notes <label id="Display subsystem specific comments and notes" >
+<sect1>
+FXmame, a glide driver for xmame
+<p>
+The latest version of this driver can be obtained at <url url="http://glmame.linuxgames.com" name="http://glmame.linuxgames.com">.
+
+</p>
+<sect2>
+Requirements
+<p>
+To run FXmame, you must have:
+
+</p>
+
+<p>
+<itemize>
+ <item>
+A 3Dfx card
+ <item>
+Glide 2x
+ <item>
+The xmame distribution
+
+</itemize>
+</p><sect2>
+Compiling and Installing
+<p>
+FXmame comes in two flavours---xfx and svgafx. The xfx version
+ is designed to run under X11. It uses an X window for input. The
+ svgafx version runs from the console, and uses svgalib for input.
+ Both use the 3Dfx hardware for rendering.
+
+</p>
+<p>
+To install FXmame, follow the general instructions for installing
+ xmame. To specify the glide driver, do the following to the Makefile:
+
+</p>
+
+<p>
+<itemize>
+ <item>
+Select either &quot;xfx&quot; or &quot;svgafx&quot; as your display
+ method
+ <item>
+Configure the glide variables to correspond to your glide setup
+
+</itemize>
+</p><p>
+The FXmame executables are called &quot;xmame.xfx&quot; and &quot;xmame.svgafx&quot;
+
+</p>
+<sect2>
+Running
+<p>
+FXmame runs with the same parameters and uses the same keyboard
+ commands that xmame.x11 does.
+
+</p>
+<p>
+A few extra keyboard commands have been added in the glide driver:
+
+</p>
+
+<p>
+<itemize>
+ <item>
+RIGHTCTRL-A -- toggle antialiasing in vector games 
+ <item>
+RIGHTCTRL-B -- toggle bilinear filtering
+
+</itemize>
+</p><p>
+The glide driver also adds several command-line options:
+
+</p>
+
+<p>
+<verb>
+    -fxgama &lt;value&gt; 3Dfx gamma correction value
+
+</verb>
+</p><p>
+Note that in order to display the game options or the fps display
+ in vector games, I have to overlay the game bitmap over the vector
+ display. This is because I circumvent the bitmap entirely in vector
+ games. Drawing the bitmap is a big cpu hog, so you'll notice that
+ the game slows down when you turn on the fps display (I know, not
+ ideal when you want to find out the frame rate...).
+
+</p>
+<sect2>
+Common Questions (FAQ)
+<p>
+Q: When I run FXmame, it just dumps core.
+
+</p>
+<p>
+A: Make sure you are running FXmame as root. Root privileges
+ are required to access the 3Dfx hardware
+
+</p>
+<p>
+Q: When I run xmame.xfx, it just hangs at the initial game screen.
+
+</p>
+<p>
+A: Are you running KDE? For some reason, I can't get keyboard
+ input under KDE. If you have this problem, switch window managers
+ or use xmame.svgafx instead.
+
+</p>
+<sect2>
+Present Limitations/Bugs
+
+<p>
+<itemize>
+ <item>
+Antialiasing isn't working quite as well as it should
+ <item>
+Input problems under KDE
+
+</itemize>
+</p><sect2>
+Future Work
+
+<p>
+<itemize>
+ <item>
+Optimize the drawing code to update only the changed portions
+ of the game bitmap.
+
+</itemize>
+</p><sect2>
+License
+<p>
+The FXmame code is Copyright 1998 by Mike Oliphant. It may be
+ used and distributed under the terms of the MAME license.
+
+</p>
+<sect2>
+Version History
+<p>
+v0.5 -- December 11th, 1998 ---------------------------
+
+</p>
+
+<p>
+<itemize>
+ <item>
+implemented long copies in screen update
+ <item>
+added dirty handling. this greatly increases the speed of games
+ that support the dirty update strategy (although most of them are
+ older games that already ran at full speed on modern hardware)
+ <item>
+merged source with xmame b8.1
+
+</itemize>
+</p><p>
+v0.4 -- October 30th, 1998 --------------------------
+
+</p>
+
+<p>
+<itemize>
+ <item>
+improved alpha handling in vector games - now bitmapped overlays
+ do not dim the screen o added svgalib support (xmame.svgafx) o fixed
+ a tiling bug that gave artifacts on texture tile boundaries
+
+</itemize>
+</p><p>
+v0.3 -- October 29th, 1998 --------------------------
+
+</p>
+
+<p>
+<itemize>
+ <item>
+got rid of extra lines in vector games o added bitmap overlay
+ in vector games to show options/fps o added antialiasing in vector
+ games
+
+</itemize>
+</p><p>
+v0.2 -- October 28th, 1998 --------------------------
+
+</p>
+
+<p>
+<itemize>
+ <item>
+added screenshots o added 3Dfx gamma adjustment o added direct
+ acceleration of vector games (still buggy)
+
+</itemize>
+</p><p>
+v0.1 -- October 27th, 1998 --------------------------
+
+</p>
+
+<p>
+<itemize>
+ <item>
+first public release
+
+</itemize>
+</p><sect2>
+Author
+<p>
+Mike Oliphant <tt><url url="mailto:oliphant@ling.ed.ac.uk" name="(oliphant@ling.ed.ac.uk)"></tt> <url url="http://glmame.linuxgames.com" name="http://glmame.linuxgames.com">
+
+</p>
+<sect1>
+GLmame, an OpenGL driver for xmame
+<p>
+The latest version of this driver can be obtained at: <url url="http://www.jausoft.com/glmame.html" name="http://www.jausoft.com/glmame.html">
+
+</p>
+<sect2>
+Requirements
+<p>
+To run GLmame you must have:
+
+</p>
+
+<p>
+<itemize>
+ <item>
+An OpenGL implementation
+ <item>
+libjpeg
+ <item>
+hardware 3D acceleration (if you want any kind of framerate)
+ <item>
+the xmame distribution
+
+</itemize>
+</p><sect2>
+Compiling and Installing
+<p>
+Follow the general instructions for installing xmame. To specify
+ the OpenGL driver, do the following in the Makefile:
+
+</p>
+
+<p>
+<itemize>
+ <item>
+Select &quot;xgl&quot; as your display method.
+ <item>
+For runtime printed debug info, add "-DGLDEBUG" to the "GLCFLAGS&quot;
+ variable.
+ <item>
+GLU version 1.2 is recommended (e.g., from SGI). If you use Mesa's
+ GLU, you may have to add "-DGLU_VERSION_1_2" to the "GLCFLAGS".
+
+</itemize>
+</p><p>
+The GLmame executable is called &quot;xmame.xgl&quot;.
+
+</p>
+<sect2>
+Running
+<p>
+xmame.xgl runs with the same parameters and uses the same keyboard
+ commands that xmame.x11 does.
+
+</p>
+<p>
+The program starts up in cabinet mode. While this is pretty,
+ and cool, you'll probably want to actually play in fullscreen mode.
+
+</p>
+<p>
+A few extra keyboard commands have been added in the OpenGL driver:
+
+</p>
+
+<p>
+<itemize>
+ <item>
+RIGHT_ALT-A -- toggle antialias filtering (vector)
+ <item>
+RIGHT_ALT-B -- toggle bilinear filtering (raster)
+ <item>
+RIGHT_ALT-C -- toggle cabinet/fullscreen display (both)
+ <item>
+RIGHT_ALT-F -- toggle between fullscreen (max window size) and
+ startup window size (both)
+ <item>
+RIGHT_ALT-O -- toggle draw-bitmap (both; nonsense for raster
+ games, speedup for vector games)
+ <item>
+RIGHT_ALT-T -- toggle phosphor trails (vector)
+ <item>
+RIGHT_ALT-PLUS_PAD -- incr. beam size (vector)
+ <item>
+RIGHT_ALT-MINUS_PAD -- decr. beam size (vector)
+
+</itemize>
+</p><p>
+The OpenGL driver also adds several command-line options:
+
+</p>
+
+<p>
+<verb>
+    -&lsqb;no&rsqb;fullscreen         Start in fullscreen mode
+                            (default: disabled)
+
+    -&lsqb;no&rsqb;gldblbuffer        Disable/enable double buffering
+                            (default: enabled)
+
+    -gltexture_size &lt;int&gt;   Force the max width and height of one 
+                            texture segment (default: autosize)
+
+    -&lsqb;no&rsqb;glforceblitmode /  Force blitter for true color modes 15/32bpp
+    -&lsqb;no&rsqb;glblit             (default: enabled)
+
+    -&lsqb;no&rsqb;glext78 /          Force the usage of GL extension number 78,
+    -&lsqb;no&rsqb;glext              if available (palletted texture)
+                            (default: enabled)
+
+    -&lsqb;no&rsqb;glbilinear /       Disable/enable bilinear filtering
+    -&lsqb;no&rsqb;glbilin            (default: enabled)
+
+    -&lsqb;no&rsqb;gldrawbitmap /     Disable/enable drawing the bitmap; e.g., 
+    -&lsqb;no&rsqb;glbitmap           disable within vector games for a speedup
+                            (default: enabled)
+
+    -&lsqb;no&rsqb;glcolormod         Disable/enable color modulation (intensity,
+    -&lsqb;no&rsqb;glcmod             gamma)
+                            (default: enabled)
+
+    -glbeam &lt;float&gt;         Set the beam size for vector games
+                            (default: 1.0)
+
+    -&lsqb;no&rsqb;glalphablending /  Disable/enable alpha blending if available
+    -&lsqb;no&rsqb;glalpha            (default: enabled)
+
+    -&lsqb;no&rsqb;glantialias /      Disable/enable antialiasing
+    -&lsqb;no&rsqb;glaa               (default: enabled)
+
+    -gllibname /            Choose the dynamically loaded OpenGL
+    -gllib &lt;string&gt;         library
+                            (default: libGL.so)
+
+    -glulibname /           Choose the dynamically loaded GLU library
+    -glulib &lt;string&gt;        (default: libGLU.so)
+
+    -&lsqb;no&rsqb;cabview            Don't start/start in cabinet view mode
+                            (default: don't start in this mode)
+
+    -cabinet &lt;cabname&gt;      Specify which cabinet model to use
+                            (default: glmamejau)
+ 
+   -glres &lt;string&gt;          Always scale games to &lt;Xres&gt;x&lt;Yres&gt;, 
+                            keeping their aspect ratio. 
+                            This overrides the scale options.
+                            Use this e.g. for the Vodoo1 gfx cards
+                            with: &quot;-glres 640x480&quot;
+
+
+
+
+</verb>
+</p><p>
+Three cabinet models are provided. The default, &quot;glmamejau&quot;,
+ is designed to look like a standard arcade cabinet, like &quot;glmame&quot;.
+ The last one, &quot;trans&quot;, is a box with a transparent game
+ screen.
+
+</p>
+<p>
+Note that in order to display the game options or the fps display
+ in vector games, the game's bitmap is overlaid above the vector display.
+ Drawing the bitmap is a big cpu hog for some low-end hardware accelerated
+ OpenGL implementations, so you'll notice that the game slows down
+ when the bitmap is overlaid.
+
+</p>
+<p>
+Because bitmap overlaying is the default, you can toggle it on
+ and off by pressing the &quot;RIGHT_ALT-O&quot; key, or turn it off
+ at startup by using the command line option &quot;-noglbitmap&quot;.
+
+</p>
+<p>
+A problem with vector games and the cabinet mode is that some
+ vector points do not reside within the screen coordinates, so you
+ may see some vectors outside of the cabinet's mame display.
+
+</p>
+<p>
+<bf>*** IMPORTANT! ***</bf>
+
+</p>
+<p>
+If you have trouble with GLmame, or it is slow, read the &quot;Common
+ Questions&quot; section. Most of the questions people email me are
+ answered here.
+
+</p>
+<sect2>
+Cabinet Models
+<p>
+Cabinet model information is stored in the &quot;cab&quot; subdirectory
+ of the directory you specified with the ROMPATH variable in the Makefile.
+ Path information specified in xmamerc or with the 'rompath' shell
+ environment variable is currently not used. Each cabinet model has
+ it's own subdirectory. GLmame will first try to load either the user-specified
+ cabinet model (using the -cabinet command-line option), or a model
+ corresponding to the current game name. Failing that, it will use
+ the generic &quot;glmame&quot; model.
+
+</p>
+<p>
+A cabinet model directory must contain a geometry file &lt;modelname&gt;.cab,
+ and any .jpg files used for textures on the model. The format of
+ the .cab file will be familiar if you have ever programmed using
+ OpenGL -- it looks much like an OpenGL display list. The format is
+ as follows:
+
+</p>
+
+<p>
+<verb>
+    cabv1.1
+
+</verb>
+</p><p>
+This header must be the first 7 characters of the file.
+
+</p>
+
+<p>
+<verb>
+    &num;&lt;text&gt;
+
+</verb>
+</p><p>
+Comment lines begin with '&num;'
+
+</p>
+
+<p>
+<verb>
+    begin &lt;type&gt;
+
+</verb>
+</p><p>
+Begins a geometry object, where type is one of (points, polygon,
+ quads, quad_strip, screen). Each &quot;begin&quot; must be paired
+ with an &quot;end&quot; statement. A &quot;polygon&quot; is specified
+ using one vertex per, well... vertex. &quot;quads&quot; are four-sided
+ polygons, each specified by four vertices in order around the polygon.
+ A &quot;quad_strip&quot; is a series of four-sided polygons, each
+ of which shares an edge with the polygons before and after it in
+ the strip. A &quot;screen&quot; is a quad that defines the actual
+ area in 3D space where the game will be displayed. only one of these
+ should be defined. For more info, look at any description of OpenGL
+ geometry.
+
+</p>
+
+<p>
+<verb>
+    end
+
+</verb>
+</p><p>
+Ends the geometry object begun with &quot;begin&quot;.
+
+</p>
+
+<p>
+<verb>
+    pointsize &lt;s&gt;
+
+</verb>
+</p><p>
+Changes the current pointsize to the corresponding size value
+ (specified as a floating point number between 0.0 and, e.g., 20.0).
+ Note: You cannot use this statement between begin and end!
+
+</p>
+
+<p>
+<verb>
+    color4 &lt;r&gt; &lt;g&gt; &lt;b&gt;
+
+</verb>
+</p><p>
+Changes the current color to the corresponding rgb value (specified
+ as floating point numbers between 0 and 1).
+
+</p>
+
+<p>
+<verb>
+    color4 &lt;r&gt; &lt;g&gt; &lt;b&gt; &lt;a&gt;
+
+</verb>
+</p><p>
+Changes the current color to the corresponding rgba value (specified
+ as floating point numbers between 0 and 1).
+
+</p>
+
+<p>
+<verb>
+    shading &lt;type&gt;
+
+</verb>
+</p><p>
+Sets the shading type. available types are &quot;smooth&quot;
+ (which blends colors from one vertex to the next) or &quot;flat&quot;
+ (which doesn't).
+
+</p>
+
+<p>
+<verb>
+    vertex &lt;x&gt; &lt;y&gt; &lt;z&gt;
+
+</verb>
+</p><p>
+Specifies a vertex for the current geometry object as a point
+ in 3-space.
+
+</p>
+
+<p>
+<verb>
+    numtex &lt;num&gt;
+
+</verb>
+</p><p>
+Specifies the number of different textures to be loaded. This
+ declaration must precede any &quot;loadtex&quot; call.
+
+</p>
+
+<p>
+<verb>
+    loadtex &lt;num&gt; &lt;width&gt; &lt;height&gt; &lt;filename&gt;
+
+</verb>
+</p><p>
+Loads texture number &lt;num&gt; from .jpg file &lt;filename&gt;.
+ The .jpg file *must* be &lt;width&gt; by &lt;height&gt; pixels, and
+ both &lt;width&gt; and &lt;height&gt; must be powers of two (and
+ must conform to the hardware requirements of any 3D card you want
+ the cabinet to work with -- 256x256 for 3Dfx).
+
+</p>
+
+<p>
+<verb>
+    texcoord &lt;xcoord&gt; &lt;ycoord&gt;
+
+</verb>
+</p><p>
+Sets the texture coordinate of the next vertex. This specifies
+ where in 2D texture space the vertex lies.
+
+</p>
+
+<p>
+<verb>
+    enable texture
+
+</verb>
+</p><p>
+Enables texture mapping (using the currently-selected texture).
+
+</p>
+
+<p>
+<verb>
+    disable texture
+
+</verb>
+</p><p>
+Turns off texture mapping.
+
+</p>
+
+<p>
+<verb>
+    settex &lt;num&gt;
+
+</verb>
+</p><p>
+Select texture &lt;num&gt; for doing texturing. The texture must
+ previously have been loaded using &quot;loadtex&quot;.
+
+</p>
+
+<p>
+<verb>
+    camerapan &lt;num&gt;
+
+</verb>
+</p><p>
+Starts the camera pan definition that will be followed by &lt;num&gt;
+ camera transistions. After the last transision definition, the pan
+ sequence must be ended with an &quot;end&quot; statement.
+
+</p>
+
+<p>
+<verb>
+    goto &lt;lx&gt; &lt;ly&gt; &lt;lz&gt; &lt;px&gt; &lt;py&gt; &lt;pz&gt; &lt;nx&gt; &lt;ny&gt; &lt;nz&gt;
+
+</verb>
+</p><p>
+Relocates and reorients the camera. The arguments are the same
+ as are used by the OpenGL command &quot;gluLookAt()&quot;. The camera
+ is positioned at point &lt;lx,ly,lz&gt;, pointing along vector &lt;px,py,pz&gt;,
+ with &quot;up&quot; normal (the direction that is &quot;up&quot;
+ for the camera) &lt;nx,ny,nz&gt;.
+
+</p>
+
+<p>
+<verb>
+    moveto &lt;lx&gt; &lt;ly&gt; &lt;lz&gt; &lt;px&gt; &lt;py&gt; &lt;pz&gt; &lt;nx&gt; &lt;ny&gt; &lt;nz&gt; &lt;frames&gt;
+
+</verb>
+</p><p>
+Moves the camera to a new location (specified as in &quot;goto&quot;).
+ The transition occurs over &lt;frames&gt; frames.
+
+</p>
+<p>
+All commands must be on separate lines. Use the (somewhat) commented
+ glmamejau cabinet as an example to work from.
+
+</p>
+<sect2>
+Common Questions (FAQ)
+<p>
+Q: I am only getting a few frames-per-second. This sucks! What
+ gives? 
+
+</p>
+<p>
+A1: You're probably running Mesa in software mode. You should
+ read the &quot;README.3Dfx&quot; file in the Mesa distro. Specifically,
+ you need to &quot;setenv MESA_GLX_FX fullscreen&quot;.
+
+</p>
+<p>
+A2: You don't have a 3D graphics card. Go buy one (see below)!
+
+</p>
+<p>
+Q: When I run xmame.xgl, it just dumps core. That's not as much
+ fun as 3D Pacman, now is it?
+
+</p>
+<p>
+A1: If you are using a 3Dfx card, make sure you are running xmame.xgl
+ as root. Root privileges are required to access the 3Dfx hardware.
+
+</p>
+<p>
+A2: If you're using Mesa and haven't upgraded to v3.0, do so.
+ 
+
+</p>
+<p>
+Q: When I run xmame.xgl, it just hangs at the initial game screen.
+
+</p>
+<p>
+A: Are you running KDE? For some reason, I can't get keyboard
+ input under KDE. If you have this problem, switch window managers.
+
+</p>
+<p>
+Q: Which graphics cards are usable with xmame.xgl? 
+
+</p>
+<p>
+A: We have the following experiences (date 20010713):
+
+</p>
+
+<p>
+<itemize>
+ <item>
+Vodoo3 + DRI OpenGL driver (XFree86 4.0.2), with command line
+ options &quot;-noglaa&quot; and 16bpp X11 server color depth.
+ <item>
+Vodoo1 + Mesa 3.4 + Glide, with command line options "-glres 640x480"!
+ <item>
+GeForce + NVIDIA OpenGL driver + XFree86 4.0.2 with default command
+ line options and 16/24bpp X11 server color depth.
+ <item>
+NVIDIA TNT2 + NVIDIA OpenGL driver + XFree86 4.0.2 with command
+ line options &quot;-bpp 16&quot; and 16bpp (may be 24bpp also ???)
+ X11 server color depth (OpenGL colortable mapping is buggy).
+ <item>
+NVIDIA TNT + NVIDIA OpenGL driver + XFree86 4.0.2 with command
+ line options &quot;-bpp 16&quot; and 16bpp (may be 24bpp also ???)
+ X11 server color depth (OpenGL colortable mapping is buggy).
+ <item>
+Matrox MGA 400 + DRI OpenGL driver (XFree86 4.0.2) with command
+ line options &quot;-bpp 16&quot;, &quot;-noglaa&quot; (???) and 16bpp
+ (may be 24bpp also ???) X11 server color depth (OpenGL colortable
+ mapping is buggy).
+ <item>
+ATI R128 + DRI OpenGL driver (XFree86 4.1.0) with command line
+ options "-noglext78 -noglaa" or "-bpp 16 -noglaa", where the latter options
+ are a bit slower (about 5 fps). 
+ <item>
+LinuxPPC - Powerbook-Firewire + ATI R128: see above!
+
+</itemize>
+</p><p>
+All of the above drivers work with the option &quot;-bpp 16&quot;
+ and/or &quot;-noglext78&quot;, the latter of which is very slow,
+ of course! So it looks like an OpenGL implementation bug is causing
+ these driver/hardware combinations to only work with these command
+ line options. The bug may lie within these OpenGL functions:
+
+</p>
+
+<p>
+<itemize>
+ <item>
+glColorTableEXT 
+ <item>
+glColorSubTableEXT
+
+</itemize>
+</p><p>
+Currently fast and funny driver/hardware combinations are:
+
+</p>
+
+<p>
+<itemize>
+ <item>
+NVIDIA GeForce + NVIDIA OpenGL driver + XFree86 4.0.2; I have
+ tested the GeForce256 (AGP) hardware. 
+ <item>
+Vodoo + DRI OpenGL driver (XFree86 4.0.2); I have tested the
+ Vodoo3 hardware.
+
+</itemize>
+</p><p>
+Q: When I run xmame.xgl, everything is messed up.
+
+</p>
+<p>
+A: Read the above experiences ... and try
+
+</p>
+
+<p>
+<itemize>
+ <item>
+switching your X server's bpp value, e.g. switch from 32bpp or
+ 24bpp to 16bpp; 
+ <item>
+the command line option &quot;-bpp 16&quot;;
+ <item>
+the command line option &quot;-noglaa&quot;;
+ <item>
+the command line option &quot;-noglext&quot;.
+
+</itemize>
+</p><sect2>
+Present Limitations/Bugs
+
+<p>
+<itemize>
+ <item>
+No clipping of vector games (most noticeable in cabinet mode).
+ <item>
+No preservation of game aspect ratio in cabinet mode.
+
+</itemize>
+</p><sect2>
+Future Work
+
+<p>
+<itemize>
+ <item>
+Fixing existing bugs .. are there any ? Or are there some unknown
+ features only ;-) ? 
+ <item>
+Optimize the drawing code to update only the changed portions
+ of the game bitmap. Optimizing the dirty code ..
+
+</itemize>
+</p><sect2>
+License
+<p>
+The GLmame code is based upon Mike Oliphant's GLmame code version
+ 0.6. 
+
+</p>
+<p>
+The GLMame code is Copyright 1998 by Mike Oliphant. It may be
+ used and distributed under the terms of the MAME license. 
+
+</p>
+<p>
+Since GLmame version 0.7, the code has been changed and improved
+ heavily by Sven Goethel --- no license change, of course!
+
+</p>
+<sect2>
+Version History
+<p>
+v0.83 -- March 29th, 2001 ---------------------------
+
+</p>
+
+<p>
+<itemize>
+ <item>
+Changed the code heavily to improve compatibility and speed.
+ The new code is a re-merge of the GLMame32 code, which is a branch
+ of Mike Oliphant's GLmame code version 0.6. 
+ <item>
+For a detailed list, please consult the file changes.opengl within
+ the distribution's documentation directory! You can also view the
+ current changes.opengl here: <url url="http://www.jausoft.com/glmame.html" name="http://www.jausoft.com/glmame.html">
+
+</itemize>
+</p><p>
+v0.6 -- December 14th, 1998 ---------------------------
+
+</p>
+
+<p>
+<itemize>
+ <item>
+added support for systems that do not support paletted textures
+ (SGI and solaris OpenGL implementations, for example)
+ <item>
+merged source with xmame b8.1
+
+</itemize>
+</p><p>
+v0.5 -- October 30th, 1998 --------------------------
+
+</p>
+
+<p>
+<itemize>
+ <item>
+fixed a bug with texturing being left on in bad places
+ <item>
+added 3Dfx gamma adjustment
+
+</itemize>
+</p><p>
+v0.4 -- October 21st, 1998 --------------------------
+
+</p>
+
+<p>
+<itemize>
+ <item>
+updated to work with xmame v0.34b5.2
+
+</itemize>
+</p><p>
+v0.3 -- October 12th, 1998 --------------------------
+
+</p>
+
+<p>
+<itemize>
+ <item>
+fixed verticle screen centering in fullscreen mode
+ <item>
+moved cabinet and camera panning information into a user-editable
+ configuration file
+ <item>
+added 'trans' cabinet model o added double buffer, view type,
+ and cabinet selection command-line options
+
+</itemize>
+</p><p>
+v0.2 -- October 6th, 1998 -------------------------
+
+</p>
+
+<p>
+<itemize>
+ <item>
+adding missing 'cab' directory
+
+</itemize>
+</p><p>
+v0.1 -- October 5th, 1998 -------------------------
+
+</p>
+
+<p>
+<itemize>
+ <item>
+first public release
+
+</itemize>
+</p><sect2>
+Authors
+<p>
+Since GLmame version 0.7: Sven Goethel <url url="mailto:sgoethel@jausoft.com" name="(sgoethel@jausoft.com)"> <url url="http://www.jausoft.com/glmame.html" name="http://www.jausoft.com/glmame.html">
+
+</p>
+<p>
+Till GLmame version 0.6: Mike Oliphant <tt><url url="mailto:oliphant@ling.ed.ac.uk" name="(oliphant@ling.ed.ac.uk)"></tt> <url url="http://glmame.linuxgames.com" name="http://glmame.linuxgames.com">
+
+</p>
+<sect>
+Contact Information and Credits
+<sect1>
+Mail <label id="Mail" >
+<p>
+There is an official xmame/xmess mailing list. All operations
+ related to this list are performed via email to <tt><url url="mailto:Xmame-request@toybox.twisted.org.uk" name="Xmame-request@toybox.twisted.org.uk"></tt>
+
+</p>
+
+<p>
+<itemize>
+ <item>
+To subscribe, send mail to: <url url="mailto:Xmame-request@toybox.twisted.org.uk" name="Xmame-request@toybox.twisted.org.uk"> with the keyword &quot;subscribe&quot;
+ in the body. 
+ <item>
+To unsubscribe, send a mail to: <url url="mailto:Xmame-request@toybox.twisted.org.uk" name="Xmame-request@toybox.twisted.org.uk"> with the keyword &quot;unsubscribe&quot;
+ in the body.
+ <item>
+To change your subscription, get a password reminder, etc., go
+ to <url url="http://toybox.twisted.org.uk/mailman/listinfo/xmame" name="http://toybox.twisted.org.uk/mailman/listinfo/xmame">.
+ <item>
+To send mail to the list, use: <url url="mailto:xmame@toybox.twisted.org.uk" name="xmame@toybox.twisted.org.uk"> 
+ <item>
+To ask specific questions about the xmame mailing list, send
+ mail to: <url url="mailto:Xmame-request@toybox.twisted.org.uk" name="Xmame-request@toybox.twisted.org.uk">
+
+</itemize>
+</p><p>
+If you're just curious, and only want to take a look at the mailing
+ list without subscribing, you can use the web-based archive at <url url="http://www.mail-archive.com/xmame%40toybox.twisted.org.uk/" name="http://www.mail-archive.com/xmame%40toybox.twisted.org.uk/"> or
+ <url url="http://toybox.twisted.org.uk/pipermail/xmame/" name="http://toybox.twisted.org.uk/pipermail/xmame/">. (The latter was activated on 5 January 2002.) To read even older
+ messages, see <url url="http://www.mail-archive.com/xmame@locutus.csres.utexas.edu" name="http://www.mail-archive.com/xmame@locutus.csres.utexas.edu">.
+
+</p>
+<p>
+To ask UNIX-specific xmame/xmess questions, you could send mail
+ to: <url url="mailto:gold@aros.net" name="Lawrence's folder">, but you're better off sending mail to the list. 
+
+</p>
+<p>
+To ask general questions about MAME, send mail to: Mirko (Mix)
+ Buffoni<url url="mailto:mix@lim.dsi.unimi.it" name="Mirko (Mix) Buffoni"> 
+
+</p>
+<p>
+Also see (and post) articles on USENET group <url url="news:comp.emulators.misc" name="comp.emulators.misc">comp.emulators.misc&nbsp;
+
+</p>
+<p>
+with a proper keyword in the body.
+
+</p>
+<p>
+Other proper keywords currently recognized as commands by <url url="mailto:Xmame-request@toybox.twisted.org.uk" name="Xmame-request@toybox.twisted.org.uk"> are:
+
+</p>
+
+<p>
+<verb>
+    who             - see everyone who is on the list
+    info            - view the introductory information for this list
+    help            - list all recognized commands
+    
+
+</verb>
+</p><p>
+Xmame Mailing List 
+
+</p>
+
+<p>
+<itemize>
+ <item>
+The xmame mailing list is intended to be a technical forum for
+ xmame developers, that is,
+ <itemize>
+  <item>
+To exchange ideas for producing a better xmame.
+  <item>
+To share patches and bug notifications.
+  <item>
+To study new design strategies.
+  <item>
+To expose problems and learn know-how.
+
+ </itemize>
+ <item>
+The Xmame mailing list <bf>is not</bf> a forum about playing games (but
+ everyone on the list plays...); so please
+ <itemize>
+  <item>
+<bf>Don't use the list to ask about ROMs.</bf>
+  <item>
+<bf>Don't ask about non-UNIX ports of MAME, just about MAME and xmame.</bf>
+  <item>
+<bf>Don't ask about implementing a game. Just search the docs and
+ contribute yourself (you'll enjoy twice: programming and playing...).</bf>
+  <item>
+<bf>Don't show your last high score in xxx game (we are interested
+ in programming, and then playing, in this order).</bf>
+
+ </itemize>
+ <item>
+<bf>Copyright notice: NEVER, I repeat NEVER send ROM images to the
+  list.</bf> (But you can tell us where to retrieve them... ;-) )
+ <item>
+At this moment, the xmame list is <bf>unmoderated</bf>; that is, everyone
+ subscribed will receive everything sent to the list. We foresee a
+ need to change this policy since the list starts to suffer from spam
+ :-(.
+
+</itemize>
+</p><p>
+If you want to send a personal mail to the xmame/xmess coordinator,
+ send to the address below. Everyone who contributes to xmame/xmess
+ should subscribe to the xmame/xmess mailing list.
+
+</p>
+
+<p>
+<itemize>
+ <item>
+Mailing list:<tt><url url="mailto:Xmame-request@toybox.twisted.org.uk" name="Xmame-request@toybox.twisted.org.uk"></tt>
+ <item>
+Xmame/xmess coordinator: <tt><url url="mailto:gold@aros.net" name="gold@aros.net"></tt>
+
+</itemize>
+</p><p>
+That's all. Enjoy xmame!
+
+</p>
+<sect1>
+Bugzilla
+<p>
+In addition to/instead of posting bugs to the mailing list, you
+ can report them to the MESS Bugzilla database at <url url="http://bugzilla.mess.org/" name="http://bugzilla.mess.org/">, under the "XMAME/XMESS"
+ category.
+
+</p>
+<sect1>
+Credits
+<p>
+Lots and lots and lots of thanks to everyone for their great
+ help on the xmame project. I would like to thank the following people
+ and of course anyone I've forgotten.
+
+</p>
+<p>
+Thank you all,
+
+</p>
+<p>
+Hans
+
+</p>
+<p>
+(Addendum: I'd like to send a big thanks to Hans for his fantastic
+ work as longtime xmame/xmess maintainer, and also to those on the
+ mailing list who have been most helpful during my transition to official
+ maintainer. --Lawrence Gold)
+
+</p>
+
+<p>
+<enum>
+ <item>
+Fathers of the MAME-creature (main version)
+ <itemize>
+  <item>
+Nicola Salmoria
+  <item>
+Allard van der Bas
+  <item>
+Mirko (Mix) Buffoni (General Mantainer during Nicola's national
+ service)
+
+ </itemize>
+ <item>
+Fathers of MESS
+ <itemize>
+  <item>
+Brad Oliver 
+  <item>
+Richard Bannister
+  <item>
+Ben Bruscella
+  <item>
+Nathan Woods (current coordinator)
+
+ </itemize>
+ <item>
+Original UNIX/X11 port
+ <itemize>
+  <item>
+Allard van der Bas
+  <item>
+Dick the Ridder
+  <item>
+Juan Antonio Martinez
+
+ </itemize>
+ <item>
+Semi-retired Unix maintainer extraordinaire
+ <itemize>
+  <item>
+Hans de Goede
+
+ </itemize>
+ <item>
+Alpha-specific issues
+ <itemize>
+  <item>
+Christian Groessler
+
+ </itemize>
+ <item>
+Sun-specific issues
+ <itemize>
+  <item>
+Keith Hargrove
+  <item>
+Mathis Rosenhau
+
+ </itemize>
+ <item>
+Irix-specific issues
+ <itemize>
+  <item>
+Tristram Scott
+
+ </itemize>
+ <item>
+QNX-specific issues
+ <itemize>
+  <item>
+Travis Coady
+
+ </itemize>
+ <item>
+GGI maintainance
+ <itemize>
+  <item>
+Gabriele Boccone (original port)
+  <item>
+Christian Groessler (current maintainer)
+
+ </itemize>
+ <item>
+OpenGL code &amp; maintainance
+ <itemize>
+  <item>
+Mike Oliphant (original creator)
+  <item>
+Sven Goethel (from GLmame 0.7 to the present)
+
+ </itemize>
+ <item>
+Network code
+ <itemize>
+  <item>
+Eric Totel
+
+ </itemize>
+ <item>
+Perl scripts for automation of some porting issues
+ <itemize>
+  <item>
+Bill Adams
+
+ </itemize>
+ <item>
+Xmame RPMs
+ <itemize>
+  <item>
+Jeremy Hansen
+
+ </itemize>
+ <item>
+Mailing list maintainer
+ <itemize>
+  <item>
+Chris McCraw (retired)
+  <item>
+Pete French
+
+ </itemize>
+ <item>
+Bits and pieces
+ <itemize>
+  <item>
+Christian Groessler
+  <item>
+Torsten Paul
+  <item>
+Jack Patton
+  <item>
+David Black
+
+ </itemize>
+ <item>
+AIX Sound code
+ <itemize>
+  <item>
+Chris Sharpp
+
+ </itemize>
+ <item>
+IRIX Sound Code
+ <itemize>
+  <item>
+<tt><url url="mailto:entropy@zippy.bernstein.com" name="entropy@zippy.bernstein.com"></tt> (original code)
+  <item>
+Brandon Corey (current code)
+
+ </itemize>
+ <item>
+PS2 Linux support
+ <itemize>
+  <item>
+Joan Sarah Touzet
+
+ </itemize>
+ <item>
+Xv support
+ <itemize>
+  <item>
+Alastair Robinson
+
+ </itemize>
+ <item>
+NetMAME Support
+ <itemize>
+  <item>
+Steve Freeland
+
+ </itemize>
+ <item>
+German readme
+ <itemize>
+  <item>
+Robert Hamberger
+
+ </itemize>
+ <item>
+Documentation (SGML, HTML, MAN)
+ <itemize>
+  <item>
+Rene Herrmann
+
+ </itemize>
+ <item>
+Bugzilla bug database
+ <itemize>
+  <item>
+Sean Young
+
+ </itemize>
+
+</enum>
+</p><sect>
+Legal Issues and Copyrights Concerning MAME/MESS
+
+<p>
+<itemize>
+ <item>
+<bf>Please read the MAME/MESS readme-files first!</bf>
+ <item>
+Xmame/xmess should be distributed under terms of the license
+ in <url url="readme.mame" name="readme.mame">
+ <item>
+And if you are interested in mess, take a look in <url url="readme.mess" name="readme.mess">
+ <item>
+The main issue involves ROM images. ROM images are protected
+ under the copyrights of their authors, and CANNOT be distributed
+ in the same package as xmame/xmess. Download any ROM images at your
+ own risk and responsibility.
+ <item>
+XInputExtensions-based Joystick support. Source code is entirely
+ pure hack work. No sample code, no info at all was found (only library
+  reference manual) and is copyrighted by me (Juan Antonio Martinez).
+ Use it under terms of GNU General Public License.
+
+</itemize>
+</p><sect>
+Some Links
+<sect1>
+Unix sources and docs
+
+<p>
+<itemize>
+ <item>
+The xmame/xmess sources
+<p>
+<url url="download/xmame-0.74.1.tar.bz2" name="xmame/xmess-0.74.1 sources">
+
+</p>
+ <item>
+xmame/xmess FAQ &amp; Installation Guide:
+<p>
+<htmlurl url="download/xmame-doc.pdf" name="xmame-doc (pdf format)">
+
+</p>
+ <item>
+xmame/xmess known bug list:
+<p>
+<htmlurl url="open_issues.html" name="open issues">
+
+</p>
+
+</itemize>
+</p><sect1>
+Unix binaries
+
+<p>
+<itemize>
+ <item>
+<url url="http://www.forte-intl.com/~ronald/xmame/" name="xmame RPMs">
+ <item>
+<url url="http://www.beimborn.com/cps2/linux/rpms" name="xmame+CPS2 RPMs">
+ <item>
+<url url="http://come.to/georgie" name="Source and binary for Solaris UltraSPARC">
+ <item>
+<url url="http://www.kwyxz.org/linux/xmame/index.html" name="AMD-optimized builds for various targets">
+
+</itemize>
+</p><sect1>
+Xmame/xmess download mirrors
+
+<p>
+<itemize>
+ <item>
+<url url="ftp://cps2:cps2@wingnut.beimborn.com" name="ftp://cps2:cps2@wingnut.beimborn.com">(US)
+ <item>
+<url url="http://www.mame.dk" name="http://www.mame.dk">(Denmark)
+ <item>
+<url url="ftp://ftp.kaupp.cx/pub/xmame" name="ftp://ftp.kaupp.cx/pub/xmame">(US)
+
+</itemize>
+</p><sect1>
+(X)Mame front-ends
+
+<p>
+<itemize>
+ <item>
+<url url="http://www.mame.net/frontend.html" name="The official mame frontend page ">
+ <item>
+<url url="http://digilander.libero.it/stefanobolli/index.html" name="Romeo">, a Java front-end
+ <item>
+<url url="http://www.mameworld.net/mamecat/" name="Mamecat">
+ <item>
+<url url="http://gxmame.sourceforge.net/" name="GXMame">, a GTK front-end striving for MAME32 compatibility
+ <item>
+<url url="http://gnomame.sourceforge.net/" name="GnoMame">, a GNOME front-end
+ <item>
+<url url="ftp://ftp.sad.it/pub/kde/local/" name="Kmamerun">
+ <item>
+<url url="http://user.cs.tu-berlin.de/~gator/mame/" name="GrokMame">
+ <item>
+<url url="http://www.geocities.com/SiliconValley/Mouse/1570/" name="StartXmame">
+ <item>
+<url url="http://grustibus.sourceforge.net" name="gRustibus">, a GNOME front-end 
+ <item>
+<url url="http://it-mame.sourceforge.net/index2.html" name="it-mame">
+ <item>
+<url url="http://www.sourceforge.net/projects/iqf/" name="IQF">
+ <item>
+<url url="http://lanzamame.mameworld.net/" name="LANZAMAME">
+ <item>
+<url url="http://ant.eelinux.com/ptkmame/" name="ptkmame">
+ <item>
+<url url="http://kemulator.sourceforge.net/" name="Kemulator">, a KDE front-end with MESS and Stella support
+ <item>
+<url url="http://www.foxbox.org/adam/code/flynn/index.html" name="Flynn">, a front-end primarily for converted arcade cabinets
+ <item>
+<url url="www.xs4all.nl/~phulshof/mame.html" name="MAMEd">, a new front-end for arcade cabinets
+ <item>
+<url url="http://www.swentelomania.be/swentel/module.php?boxcontent=35&page=40" name="Playmame & Playmess"> (perl-based menu makers)
+ <item>
+<url url="http://www.voicenet.com/~jceklosk/" name="jMame">, a Java front-end (requires JDE 1.4.0)
+ <item>
+<url url="http://yeeking.net/cxmame/" name="CXmame">, a simple console-based front-end
+ <item>
+<url url="http://designs.stormheart.com/kmameleon/" name="KMameleon">, a KDE front-end
+ <item>
+<url url="http://tkmame.retrogames.com/icons" name="Mamu_'s Icons for X">
+
+</itemize>
+</p><sect1>
+Some other links
+
+<p>
+<itemize>
+ <item>
+The official M.A.M.E home is at <url url="http://www.mame.net" name="http://www.mame.net">
+ <item>
+The official mess site is <url url="http://www.mess.org" name="http://www.mess.org">
+ <item>
+Some other emulation sites are <url url="http://www.vg-network.com" name="http://www.vg-network.com"> and <url url="http://www.retrogames.com" name="http://www.retrogames.com">
+ <item>
+The very best ROM site on this planet is at <url url="http://www.mame.dk/" name="http://www.mame.dk/">
+ <item>
+A couple of sites with CPS2 and other patches <url url="http://www.beimborn.com/cps2/linux/" name="Dan Beimborn's Linux CPS2Mame page"> and <url url="http://www.win.tue.nl/~stijn/xmame/" name="Stijn Hoop's xmame patches ">
+ <item>
+<bf>MAME</bf> <bf>A</bf>ction <bf>R</bf>eplay <bf>P</bf>age for those who want to have a  look at
+ other monitors at <url url="http://marp.retrogames.com/" name="http://marp.retrogames.com/">
+ <item>
+And, of course, don't forget our project homepage at <bf><url url="http://x.mame.net/" name="http://x.mame.net/"></bf>
+
+</itemize>
+</p><sect>
+ChangeLogs<label id="ChangeLogs" >
+<sect1>
+The MAME/MESS ChangeLogs
+<p>
+These are the changelogs of the offical MAME and MESS release,
+ the core of xmame/xmess.
+
+</p>
+
+<p>
+<itemize>
+ <item>
+<url url="changes-mame.html" name="The MAME changelog (changes.mame)">
+ <item>
+<url url="changes.mess" name="The MESS changelog (changes.mess)">
+
+</itemize>
+</p><sect1>
+The Unix ChangeLog
+<p>
+And now here is the HISTORY of the xmame project (of course that's
+ why you are here :;-)) ... Ren
+
+</p>
+
+<p>
+<itemize>
+ <item>
+<url url="changes-unix.html" name="The Unix port changelog (changes.unix)">
+ <item>
+The OpenGL display driver changelog: <url url="changes.opengl" name="changes.opengl"> or <url url="http://www.jausoft.com/glmame.html" name="http://www.jausoft.com/glmame.html">
+
+</itemize>
+
+
+
+</article>
diff --git a/src/unix/doc/xmame-doc.txt b/src/unix/doc/xmame-doc.txt
new file mode 100644
index 0000000..f12f349
--- /dev/null
+++ b/src/unix/doc/xmame-doc.txt
@@ -0,0 +1,2795 @@
+XMAME/XMESS DOCUMENTATION
+
+Juan Antonio Martinez [mailto:jantonio@dit.upm.es||jantonio@dit.upm.es] and Hans de Goede [mailto:hans@highrise.nl||hans@highrise.nl] and Rene' 
+Herrmann (4 doc/sgml) [mailto:rene.herrmann@berlin.de||rene.herrmann@berlin.de] and Lawrence Gold (minor 
+editing) [mailto:gold@aros.net||gold@aros.net] and David Heremans (minor editing)
+
+v2.1.32, 14 August 2003
+
+Abstract
+
+xmame/xmess documentation with an installation guide, 
+the FAQ (frequently asked questions), hints, tips and 
+tricks, the changes to the code, and much more!
+
+Table of Contents
+
+Introduction
+    Welcome to XMAME
+    Keep everything up-to-date!
+    Pending Jobs - or TODO
+Compiling, Setting Up and Starting Xmame/Xmess
+    Requirements     
+    Follow these steps to compile xmame/xmess
+    If you have problems compiling, installing and starting xmame/xmess...     
+    Compile Notes for Specific Operating Systems 
+        Linux i386
+        Linux PowerPC
+        IRIX
+        HPUX
+        ULTRIX 
+        SunOS & Solaris
+        Openstep
+Xmame Frequently Asked Questions
+    What is mame?
+    What is mess?
+    What is xmame/xmess?
+    What are the differences between mame/mess and xmame/xmess?
+    What hardware and operating systems are supported?     
+    My system is supported but xmame/xmess gives me errors and fails. Why?
+    What is the role of the xmamerc/xmessrc file?
+    What is the syntax of the xmamerc/xmessrc file.
+    Where do roms, images, samples, highscores, configfiles, etc go? 
+        Roms/Samples
+        Read/write Diskette Images
+        Rom Cartridges/Read Only Diskette Images
+        Artwork
+        Xmame configuration
+        Game configuration
+        Game state
+        NVram
+        Mem cards
+        Screenshots
+        Highscores
+        hiscore.dat
+        cheat.dat
+        history.dat
+        Input logs
+        Xmame/xmess still can't find files/store highscores
+    How do I start xmess/xmame ?
+    What are the command line parameters for xmame/xmess?
+    What keys does xmame/xmess use?
+    Why doesn't a game have sound?
+    My sound seems lagged. / My sound Clicks. / What does -bufsize do?
+    Why doesn't a game work? 
+    What are PROMs? 
+    Why is xmame/xmess slow?
+        SPEEDUP # 1 - Inline compiling
+        SPEEDUP # 2 - Direct Graphics Access
+        SPEEDUP # 3 - NASM
+        SPEEDUP # 4 - ICC
+    I've got a dual processor machine. What can I do to take full advantage of this?
+    Why doesn't my joystick handle diagonal movement correctly on my Intel x86 system?
+    How do I enable XinputExtensions X11 based joystick in Xfree86?
+    How do I read a manual page?
+    Why do I get gz_open symbol not found while compiling? 
+    Why do I get zlib.h not found? 
+    When I run xmame.x11, nothing happens---no window pops up or anything. Help!
+    Can I run xmame fullscreen?
+        xmame.x11/DGA
+        xmame.x11/Xv
+        xmame.SDL
+    xmame.SDL / fullscreen has a large border around the game. 
+    I only use some of the emulation parts (Neo Geo / CPS-2 /...). Do I need the entire xmame? 
+    Why does xmame freeze and lock up when I hit <ESC> to exit the game or P to pause the game?
+    Why does xmame report "can't resolve host name '/dev/dsp' when trying to use esound?
+    Where can I get the latest version of xmame/xmess?
+    I upgraded xmame and now some games do not work anymore.
+    Where can I send fixes, bug reports, suggestions, or money?  :-)
+    What if my question is still not answered?
+Display Subsystem-Specific Comments and Notes 
+    FXmame, a glide driver for xmame
+        Requirements
+        Compiling and Installing
+        Running
+        Common Questions (FAQ)
+        Present Limitations/Bugs
+        Future Work
+        License
+        Version History
+        Author
+    GLmame, an OpenGL driver for xmame
+        Requirements
+        Compiling and Installing
+        Running
+        Cabinet Models
+        Common Questions (FAQ)
+        Present Limitations/Bugs
+        Future Work
+        License
+        Version History
+        Authors
+Contact Information and Credits
+    Mail 
+    Bugzilla
+    Credits
+Legal Issues and Copyrights Concerning MAME/MESS
+Some Links
+    Unix sources and docs
+    Unix binaries
+    Xmame/xmess download mirrors
+    (X)Mame front-ends
+    Some other links
+ChangeLogs
+    The MAME/MESS ChangeLogs
+    The Unix ChangeLog
+
+
+
+ Introduction<Introduction>
+
+ Welcome to XMAME
+
+This the the *nix port of the almost legendary mame. 
+Mame is an arcade machine emulator, started in 1997 by 
+Nicola Salmoria. It started out as a series of 
+emulators for  individual games. This series of 
+emulators was combined into a  simgle multi-game 
+emulator. This is the current form of mame; no longer a 
+one-man show, there are over 100 contributors to the project.
+
+ Keep everything up-to-date!
+
+The most recent copy of this guide, the xmame-sources 
+and many more can be found on the xmame project 
+homepage at [http://x.mame.net/||http://x.mame.net/]
+
+ Pending Jobs - or TODO
+
+If you think you can help with the todo list or you can 
+make a  contribution that you feel is interesting, 
+please send mail to the xmame/xmess coordinator. See [Mail] 
+for contact information.
+
+* Optimise mouse warping.
+
+* Remove osd_input_init_post, add display ready flag.
+
+* Updating of fps is off (dirty marking problem) with 
+  vector games.
+
+* Update porting.txt.
+
+* Convert all remaining sound drivers to plugins.
+
+* Rewrite display/input code to be more modular, 
+  oo-ish, and usable as a separate library.
+
+* Split -[no]scanline option into emulated and real 
+  scanline options.
+
+* Add an option to specify which resolution to use, add 
+  clipping and panning if it doesn't fit and use it anyway.
+
+* Use Pentium TSC for uclock where available.
+
+* Network:
+
+  * Fix since the dos team broke it, find out if the 
+    dosnet team is still alive.
+
+  * Add mouse/joystick support to network play
+
+  * Try converting network support to tcp, currently we 
+    have no error correction.
+
+  * Make network code more robust, version check, input 
+    settings check, etc.
+
+* Check x11-joystick. Rumor has it it's broken, but 
+  then again there's only one bug-report, so it seems 
+  no one is using it.
+
+* fm soundhack for linux-i386.
+
+* Make which messages are emitted and when configurable 
+  (log-type's and log-level), make fileio emit messages 
+  about which files it tries to open, to help debug 
+  rom-loading problems, and walk through all messages 
+  xmame emits giving them all a standard format like:
+
+  OSD:        Info:    bla
+  X11-window: Warning: bla
+  Svgalib:    Error:   bla
+
+* Add scancode 128-255 for non-PC keys like F13 -- F24, 
+  more keypad keys, etc., update all display targets to 
+  use this.
+
+* Also see the text todo file, kept around to quickly 
+  enter stuff while hacking: [todo||todo].
+
+ Compiling, Setting Up and Starting Xmame/Xmess
+
+Note: This section is not a Unix tutorial. You need to 
+know some basic  Unix commands to compile and install 
+xmame/xmess.
+
+ Requirements     
+
+* GNU make is MANDATORY in ALL Systems, even if you use 
+  a different  compiler. 
+
+* On all platforms zlib is now needed since the core 
+  uses it. If you don't have zlib, a stripped version 
+  is included with xmame. See: [FAQ: Why do I get gz_open symbol not found while compiling?] and [FAQ: Why do I get zlib.h not found?]
+
+* You are encouraged to use a GNU development 
+  environment: gcc, gmake, gnu- ar. Lots of problems 
+  are found due to the very permissive syntax in gcc, 
+  so if you use a strictly ANSI C compiler, you'll get 
+  lots of warnings, and if the version of xmame/xmess 
+  is not fully debugged, compilation errors.
+
+* Xmame compilation breaks when using egcs-1.1.x or 
+  gcc-2.95, use -fno-strict-aliasing to fix it. 
+  gcc-2.95.1 does work with -fstrict-aliasing, and 
+  gives a nice speed increase.
+
+* Xmame compilation also breaks when using Red Hat 7's 
+  latest (as of 16 January 2001) update for gcc. If you 
+  experience problems, please either downgrade your 
+  compiler to the one included on the Red Hat 7 CD-ROM, 
+  or try replacing "gcc" in the Makefile with "kgcc", which 
+  will invoke egcs-1.1.2. (But please see above about 
+  the -fstrict-aliasing flag.)
+
+ Follow these steps to compile xmame/xmess
+
+1. See [Compile Notes for Specific Operating Systems] for platform specific compiling information.
+
+2. See [Display subsystem specific comments and notes] for special display methods information.
+
+3. Download the xmame/xmess source files archive.
+
+4. Move the xmame/xmess source files archive to a 
+  suitable work directory. When you extract the 
+  archive, sub directories will be created under the  
+  work directory.
+
+5. Rename the source files archive so its extension is 
+  .gz, so that gzip doesn't complain. For example, 
+  change xmame-0.34b1.1.tgz to xmame-0.34b1.1.tar.gz
+
+6. Use gzip -d to uncompress the archive. For example, type:
+
+  gzip -d xmame-0.34b1.1.tar.gz
+
+7. Extract the files with tar. For example, type:
+
+  tar xvf xmame-0.34b1.1.tar
+
+8. After extracting the archive, change to the 
+  subdirectory created by  the extraction process. For 
+  example, after extracting the xmame-0.34b1.1.tar 
+  archive, a directory named xmame-0.34b1.1 is created. 
+  Change to it. This directory is the top of the source tree.
+
+9. Copy makefile.unix to Makefile, the distributed 
+  Makefile is used for development and is not a good 
+  starting point!
+
+10. Edit the Makefile and change the settings according 
+  to your system. The default makefile.unix is 
+  preconfigured to run under X11/Linux. Be careful 
+  editing this file.
+
+  * If you intend to compile in X11 joystick support, 
+    type the following to see the available Xdevice list:
+
+    make xlistdev; ./xlistdev
+
+  * Choose the desired device and re-edit Makefile, 
+    setting the option X11_JOYNAME to the correct device.
+
+11. Compile xmame/xmess by typing:
+
+  make
+
+12. If the compile fails, report the problem to the author.
+
+13. *** YOU MAY NEED TO BE root TO PERFORM THIS STEP 
+  *** To install xmame/xmess, type:
+
+  make install
+
+14. If you want you can now build xmame/xmess for 
+  another target/display method, otherwise skip to the 
+  next step.
+
+  (a) If you want to also build for another target 
+    repeat repeat the "make" and "make install" steps 
+    adding "TARGET=<target>" to the make command for example:
+
+    make TARGET=mess
+    make install
+
+  (b) If you want to also build for another display 
+    method repeat the "make" and "make install" steps 
+    adding "DISPLAY_METHOD=<method>" to the make command 
+    for example:
+
+    make DISPLAY_METHOD=svgalib
+    make install
+
+  (c) You can also combine the 2 above for example:
+
+    make TARGET=mess DISPLAY_METHOD=svgalib
+    make install
+
+15. In your home directory, create a subdirectory 
+  called .xmame.
+
+16. From the top of the source tree, copy the file 
+  doc/xmamerc.dist to the ${HOME}/.xmame/ directory. 
+  (For xmess do this for xmessrc)
+
+17. If desired, copy xmamerc.dist to the global xmamerc 
+  location as "xmamerc" (for xmess, copy xmamerc.dist 
+  to xmessrc). The global xmamerc location is defined 
+  in the Makefile.
+
+18. Edit ${HOME}/.xmame/xmamerc to match your 
+  preferences. (For xmess, edit ${HOME}/.xmess/xmessrc)
+
+19. Be sure that the DISPLAY and PATH environment 
+  variables are  set correctly.
+
+20. Make sure your ROM images are installed.
+
+21. Start the X-Window System. (Unless you compiled for 
+  a different display method in which case you skip 
+  this step.)
+
+22. Start xmame/xmess. For example:
+
+  /usr/games/xmame.x11 dkong
+
+ If you have problems compiling, installing and 
+  starting xmame/xmess...     
+
+* Read  [Xmame frequently asked questions]
+
+* Read (the recent parts of) [ChangeLogs]. They might contain some 
+  hints about recent changes which aren't fully 
+  documented yet.
+
+* Check [Compile Notes for Specific Operating Systems] for operating system-specific notes. You may 
+  need to do something special for your operating system.
+
+* Check [Display subsystem specific comments and notes] for display subsystem-specific notes. You may 
+  need to do something special for your display system.
+
+* If you get an error about gz_open and a bunch of 
+  other functions not found during linking, read: [FAQ: Why do I get gz_open symbol not found while compiling?] and [FAQ: Why do I get zlib.h not found?].
+
+* Be sure that the rompath in your xmamerc/xmessrc is 
+  correct; see [FAQ: Where do roms, images, samples, highscores, configfiles, etc go?].
+
+* Check xmamerc/xmessrc: Is it configured correctly?
+
+* Are you getting messages that you are missing files? 
+  Maybe you are missing PROMs; see [FAQ: Why doesn't a game work?] and [FAQ: What are PROMs?]
+
+* Is the program in your PATH?
+
+* The svgalib/xf86_dga build of xmame/xmess requires 
+  setuid root. Are your permissions correct?
+
+* Try asking the friendly folks at the newsgroup 
+  alt.game.mame to see if anyone else has experienced 
+  the same problem as you.
+
+* Try mailing to the xmame mailinglist, see [Mail] for more 
+  information.
+
+If all else fails, send email to the current maintainer 
+of the xmame/xmess project. See [Mail] for contact information.
+
+ Compile Notes for Specific Operating Systems <Compile Notes for Specific Operating Systems>
+
+ Linux i386
+
+Linux i386 is the platform I (Hans) use, so xmame 
+should compile without any hassles on Linux i386. 
+(Note: The same is true for Lawrence Gold.)
+
+Some bugs have been found and worked around when using 
+gcc27x, please use egcs if available. If more gcc bugs 
+popup, egcs will be  made mandatory, but I hope that 
+won't be necessary.
+
+It has been reported that some SoundBlaster AWE32 and 
+VIA-82cxxx (onboard) cards do not  correctly manage 
+get_freespace(). If so, you'll get some audio_ioctl() 
+calls failed messages in console, and if everything 
+goes right a message that xmame/xmess is falling back 
+to timer based audio. If  this doesn't happen and sound 
+isn't right, try forcing timer-based  audio by starting 
+xmame/xmess with -timer.
+
+SB64/128PCI cards (Ensoniq 137x-based cards) also do 
+not correctly manage get_freespace(). Unfortunately, 
+this doesn't result in failed ioctl's; instead, they 
+just ignore the calls. Xmame tries to autodetect this 
+and to fall back to timer-based audio. If this doesn't 
+happen and sound isn't right, try forcing timer based 
+audio by starting xmame/xmess with -timer.
+
+Some have reported success using ALSA with OSS 
+emulation (see [http://www.alsa-project.org/||http://www.alsa-project.org/]). If you experience the above problems, 
+this would certainly be worth a try.
+
+Also, I've tested sound using the PC-Speaker driver 
+module. It works!! But it needs -timer. Again, it 
+should do this  automagically, but you know what to do 
+if it doesn't.
+
+Distribution-Specific Comments:
+
+* S.u.S.E. Linux: Besides the gcc compiler and libc 
+  libraries, which are both from the "d" series, other 
+  packages  need to be installed or the build will 
+  fail. If compiling for svgalib, the svgalib package 
+  from series "d" installed. If compiling for the 
+  X-Window System, you must have xdevel package from 
+  series "x" installed. These packages can be installed 
+  using the "yast" utility included in the S.u.S.E. distribution.
+
+* Red Hat Linux is the operating system used by the 
+  author. xmame/xmess  should build correctly under Red 
+  Hat Linux. :-)
+
+ Linux PowerPC
+
+Linux PowerPC should work from now on. Here's an email 
+from Andreas Varga [mailto:sid@skater.htu.tuwien.ac.at||sid@skater.htu.tuwien.ac.at], the Linux/PowerPC maintainer, 
+describing the necessary steps:
+
+Required changes to compile xmame 0.34b3.1 on 
+Linux/PowerPC with SVGALIB
+
+Makefile:
+
+* enable CFLAGS for linux/ppc 
+
+* enable DISPLAY_METHOD = svgalib 
+
+* enable ARCH = linux 
+
+* remove -lvgagl from LIBS.svgalib in src/unix/unix.mak 
+  (only -lvga is required)
+
+Required changes to compile xmame 0.34b3.1 on 
+Linux/PowerPC with X11 
+
+Makefile: 
+
+* enable CFLAGS for linux/ppc 
+
+* enable DISPLAY_METHOD = x11 
+
+* enable ARCH = linux 
+
+Another thing... sound is not working, because sound 
+drivers support is currently under development in 
+Linux/PPC kernels...there is an old driver that is a 
+hacked Soundblaster driver, and newer 2.1.1xx kernels 
+have a sound drivers based on Amiga DMA sound 
+drivers... Once this issues are settled there should be 
+a full OSS-compatible driver... sound should work then...
+
+I can't speak about Joystick support...
+
+The original Linux/PPC target changes in the Makefile 
+were done by me, but there are some other changes 
+required to get it to compile... Starting from October 
+I will have some more time to work on this, and I'll 
+keep you updated...
+
+Cheers, Andreas
+
+ IRIX
+
+Use the generic unix arch for those machines that have 
+no  sound support installed (xmame/xmess uses the 
+dmedia package or the newer AL package on IRIX systems).
+
+Silicon Graphics provides several native compilers. 
+xmame/xmess has  been compiled and tested with the 
+normal cc. There were some problems with this when 
+using -n32 for new style 32bit code. It does work when 
+using -o32 for oldstyle 32 bit code. It should now also 
+work with -n32 which is much faster.
+
+The use of DCC is not recommended (anymore) since it's 
+a C++  compiler and thus won't even compile xmame/xmess 
+out of the box due to uncasted mallocs. Changing all 
+these mallocs would be crazy, esp. since they are not 
+only in the osd part, but also in the core which is not 
+under our control. Besides that, mame is normal C, so 
+please compile it with a normal C compiler.
+
+Some problems have been reported using the GNU linker. 
+It's recommended that you use the native one.
+
+ HPUX
+
+Use the generic unix arch. In HP-UX, gcc and gnu-make 
+are MANDATORY.
+
+ ULTRIX 
+
+Use the generic unix arch.
+
+Notes received from Danny [mailto:dboxhoor@iso.vilspa.esa.es||dboxhoor@iso.vilspa.esa.es]
+
+VERY IMPORTANT!!!
+
+The xmame/xmess CPU emulators access memory through 
+pointers which are sometimes cast to illegal addresses 
+- as far as the MIPS CPU is concerned. The Ultrix 
+operating system is aware of that and fixes this 
+"unaligned data access".
+
+Depending on your system setup, lots of warnings are 
+generated for certain games. Fortunately these messages 
+can be disabled by  executing the command "uac p 0" in 
+the same shell where xmame/xmess  will be running.
+
+UPDATE: The new -DALIGN_INTS switch in the makefile 
+fixes these unaligned accesses in the source which is 
+probably a lot faster than hot fixing them in the 
+kernel segfault handler.
+
+Use gnu make.
+
+Compile with the `c89' compiler. Though `gcc' has no 
+problems  with compiling and optimizing xmame/xmess, 
+the resulting `c89'  executable is faster on an empty 
+machine (read: xmame can use all  cpu & memory without 
+competing with other high priority  processes), so you 
+can set `frameskip' to 1.
+
+When compiling with `c89 -O2' don't forget to also use 
+`-Olimit  1000'. If 1000 is not enough, the compiler 
+will tell you to  increase it.
+
+ SunOS & Solaris
+
+There are 2 relevant architecture options available in 
+the makefile: 
+
+    ARCH = generic : use this for old SunOs running on Sparcs,
+                     but a Sparc running Solaris will usually
+                     handle this option too.
+    ARCH = solaris : this is the one you should use for Sparcs
+                     running Solaris.        
+
+Currently sound is not supported under sunos. The 
+solaris arch does support audio.
+
+If you are using Sun's OpenWindows implementation of 
+X11, then make sure that the X11INC and X11LIB 
+variables in the X11 Options section of the makefile 
+are set properly. (There are already entries for the 
+standard OpenWin directory there that you can uncomment.)
+
+Of course, if you are compiling for X11 then you need 
+to set these variables properly, no matter what 
+implementation of X11 you are using!  :)
+
+If you are using Sun's SunPro cc compiler, then the 
+following optimisation flags have been reported to be good:
+
+    OPTFLAGS    = -fast -xO4 -native
+
+Finally, there has been a case of the xmame compilation 
+processes breaking over the "ar" program. Most Solaris 
+installations will include a set of utilities that 
+conform to the XPG4 standard, usually in the 
+"/usr/xpg4/bin" directory. The XPG4 version of "ar" 
+should be avoided like the plague. Ensure that the 
+"/usr/ccs/bin" appears in your path before the 
+"/usr/xpg4/bin" directory and everything should go smoothly.
+
+PLEASE NOTE : There is currently not much support for 
+SunOS/Solaris. If you have any trouble, try to fix it 
+yourself. If you succeed, send a message to the mailing 
+list detailing what you did. If you don't succeed, send 
+a message anyway and someone _may_ be able to help you. 
+Either way, this is the only way that problems with 
+xmame on SunOS/Solaris will get fixed.
+
+ Openstep
+
+You must use the OpenStep gnumake, not make. You must 
+also use the NeXT/Apple cc rather than gcc. Also use 
+only the optimisation options as recommended for 
+OpenStep in the makefile, others will cause the 
+resulting executable to crash. The OpenStep assembler 
+on i386 architectures is incompatible with the mame 
+assembler CPU cores and thus you must use the C 
+versions (Use i386-noasm instead of i386 when compiling 
+for i386).
+
+The supplied complier is based on gcc 2.7.2.1 which 
+will not compile src/profiler.c without crashing. To 
+get around this you must turn off + optimisation when 
+this crash occurs, re-make to compile this file only, 
+then stop the make, re-enable optimisation, and continue.
+
+On an OpenStep keyboard the functions keys do not all 
+operate as expected. Using the command key in 
+conjuction with a number key generates the equivalent 
+function key within xmame, with 0, - and = + 
+representing F10, F11 and F12 resepectively. Also note 
+that the ALT + keys cannot be mapped. As most games 
+tend to use this as the default fire button it is 
+exteremly useful to remap this globally the first time 
+you run xmame.
+
+ Xmame Frequently Asked Questions<Xmame frequently asked questions>
+
+ What is mame?
+
+Mame is an arcade machine emulator. Started in 1997 by 
+Nicola  Salmoria, mame started out as a series of 
+emulators for  individual games. This series of 
+emulators was combined into a  simgle multi-game 
+emulator. This is the current form of mame; no longer a 
+one-man show, there are over 100 contributors to the project.
+
+Mame was created by Nicola Salmoria.
+
+Also see [readme.mame||the official mame readme file (readme.mame)]
+
+ What is mess?
+
+Mess is just like mame---a virtual machine emulator, 
+only it doesn't emulate arcade machines but rather 
+computers and consoles.
+
+Also see [readme.mess||the official mess readme file (readme.mess)]
+
+ What is xmame/xmess?
+
+Xmame/xmess are the Unix/X11 ports of the mame and mess 
+projects. It makes mame/mess available on *ix machines 
+using the X11R6 X-Window System (and 
+SVGAlib/ggi/XF86-DGA/OpenGL/SDL too).
+
+Mame was orginally ported by Allard Van Der Bas, Dick 
+the Ridder, Juan Antonio Martinez, and Hans de Goede.
+
+Xmame/xmess is currently maintained by Lawrence Gold.
+
+ What are the differences between mame/mess and xmame/xmess?
+
+None significant.
+
+Xmame/xmess is based on the mame/mess source code. Due 
+to technical reasons beyond the scope of this document, 
+the mame/mess source may not compile under Unix. That's 
+why the xmame/xmess project exists. Each time mame/mess 
+is updated, the code is tested  (and patched if needed) 
+under Unix. This way xmame/xmess releases are always 
+the same as their mame counterparts.
+
+There are no plans for the independent development of 
+xmame/xmess.
+
+ What hardware and operating systems are supported?     
+
+Xmame runs on both little-endian and big-endian CPUs, 
+using aligned integer access if needed and is 
+compatible with 64 bit CPUs. The current list of 
+supported CPUs in the makefile is:
+
+* i386 + gnu-asm
+
+* i386 no asm
+
+* alpha
+
+* ia64 (merced)
+
+* m68k
+
+* generic risc (PowerPC, Sparc, HPPA, IBM)
+
+* generic risc, lsb-first (RISC (Ultrix machines))
+
+* mips (generic risc + SGI compiler bug workarounds)
+
+Adding support for another cpu (if necessary) should be trivial.
+
+The following Unix platforms are specifically supported:
+
+* Linux
+
+* FreeBSD
+
+* NetBSD
+
+* Solaris (SunOS)
+
+* OpenStep (noasm only on i386)
+
+* IRIX with sound using the dmedia package or the new 
+  al package (sound currently broken)
+
+* AIX (sound currently broken)
+
+* generic unix, no sound
+
+The generic unix entry should work for any reasonable 
+standard Unix variant, but lacks sound since there is 
+no single Unix sound standard.
+
+On all platforms, zlib is now needed since the core 
+uses it. Ff you don't have zlib, use the included one 
+by uncommenting the appropriate line in Makefile.
+
+The following display methods are supported. X11 is the 
+only one which works on all platforms, except for 
+OpenStep which only works with Openstep bitmaps:
+
+* X11 (X-Window System)
+
+* svgalib
+
+* GGI (Generic Graphics Interface)
+
+* OpenGL using X11 for input
+
+* glide using X11 for input (3DFX)
+
+* glide using svgalib for input (3DFX)
+
+* OpenStep bitmaps
+
+* SDL (Simple Direct Medialayer)
+
+The following is a list of arch/os/display 
+combinations, with maintainers, for arch/os/display 
+combinations which are actively supported. Please mail 
+the maintainer of the arch/os/display combination for 
+compilation and other arch/os/display specific 
+problems. Mail Lawrence [mailto:gold@aros.net||gold@aros.net] for generic (e.g., X11) problems.
+
+* i386/linux/x11 (+DGA)	 -> Lawrence [mailto:gold@aros.net||<gold@aros.net>]
+
+* i386/linux/svgalib	 -> Lawrence [mailto:gold@aros.net||<gold@aros.net>]
+
+* i386/linux/xgl	 -> Sven Goethel [mailto:sgoethel@jausoft.com||<sgoethel@jausoft.com>]
+
+* i386/linux/xfx	 -> Lawrence [mailto:gold@aros.net||<gold@aros.net>]
+
+* i386/linux/svgafx	 -> Lawrence [mailto:gold@aros.net||<gold@aros.net>]
+
+* i386/linux/ggi	 -> Christian [mailto:cpg@aladdin.de||<cpg@aladdin.de>]
+
+* alpha/linux/x11	 -> Christian [mailto:cpg@aladdin.de||<cpg@aladdin.de>]
+
+* alpha/digital unix/x11 *	 -> Leandro [mailto:gold@aros.net||<gold@aros.net>]
+
+* powerpc/linux/x11	 -> Andreas [mailto:sid@skater.htu.tuwien.ac.at||<sid@skater.htu.tuwien.ac.at>]
+
+* powerpc/linux/svgalib	 -> Andreas [mailto:sid@skater.htu.tuwien.ac.at||<sid@skater.htu.tuwien.ac.at>]
+
+* i386/freebsd/x11	 -> Jacob A. Hart [mailto:c9710216@studentmail.newcastle.edu.au||<c9710216@studentmail.newcastle.edu.au>]
+
+* i386/netbsd/x11	 -> Dave [mailto:dave@dtsp.co.nz||<dave@dtsp.co.nz>]
+
+* alpha/netbsd/x11	 -> Christian [mailto:cpg@aladdin.de||<cpg@aladdin.de>]
+
+* Sparc/Solaris/x11	 -> Lawrence [mailto:gold@aros.net||<gold@aros.net>]
+
+* i386/Unixware7/x11 *	 -> Richard [mailto:xmame@frogface.ddns.org||<xmame@frogface.ddns.org>]
+
+* i386/openstep	 -> Pete French [mailto:pete@toybox.twisted.org.uk||<pete@toybox.twisted.org.uk>]
+
+* Sparc/SunOs	 -> Saga [mailto:jolletx@cybercable.fr||<jolletx@cybercable.fr>]
+
+* mips/irix/x11	 -> Dingus Family [mailto:ddingus@uswest.net||<ddingus@uswest.net>]
+
+* These are supported using the generic unix entry of 
+the makefile, and thus lack sound.
+
+We are always looking for people willing to test and 
+answer questions about xmame on a new arch/os/display. 
+This takes very little work and could help other people 
+tremendously. If you're interested, mail Lawrence [mailto:gold@aros.net||gold@aros.net].
+
+ My system is supported but xmame/xmess gives me errors 
+  and fails. Why?
+
+Xmame/xmess should run on 8bpp Pseudo Color displays 
+and on 16, 24 and 32bpp True Color displays. If your 
+X-Server does not support any  of these display types, 
+xmame/xmess will not run.
+
+You can verify your X-Server support by starting your 
+X-Server  and running the xdpyinfo program. See the 
+xdpyinfo manual page  for more information.
+
+ What is the role of the xmamerc/xmessrc file?
+
+A normal xmame/xmess invocation looks like:
+
+    xmame pacman -sound -nojoy -frameskip 2 
+-heightscale 3 \   
+        -widthscale 2
+
+Most of the time, you will want to use the same 
+configuration for  each game. xmame/xmess will read 
+this file for default values for the  parameters that 
+you can set. This way the only parameters you  need to 
+express on the command line are the ones you want to  override.
+
+Another reason for xmamerc/xmessrc is keyboard 
+remapping. Some Unix  keyboards are very different than 
+their PC counterparts. To  compensate for the changes, 
+xmame/xmess allows you to remap keys that  are not 
+available on Unix keyboards to keys that are available.
+
+ What is the syntax of the xmamerc/xmessrc file.
+
+The syntax is quite simple:
+
+   "keyword value"
+
+See [xmamerc.dist||xmamerc.dist] for most keywords. Allmost all commandline options 
+can be used as keywords (without the -), use value 0 or 
+1 for commandline options which have a negating 
+(-no[option]) counterpart. As usual lines begining with 
+"#" are comments.
+
+You can also generate a configfile with all the current 
+settings to use as a template by typing:
+
+   xmame -showconfig > ~/.xmame/xmamerc
+
+ Where do roms, images, samples, highscores, 
+  configfiles, etc go? <FAQ: Where do roms, images, samples, highscores, configfiles, etc go?>
+
+ Roms/Samples
+
+Xmame/xmess uses a ":" seperated rompath to find out 
+which dirs to search for roms/samples.
+
+The default rompath is XMAMEROOT as defined in Makefile 
+during compile.
+
+This is overwritten by any rompath in xmamerc/xmessrc, 
+which can be overwritten again with the -rompath 
+commandline option.
+
+Xmame/xmess searches every dir in this path for 
+roms/samples in the following way:
+
+    <dir>/gamename.zip             (containing filename.ext)
+    <dir>/gamename/filename.ext
+    <dir>/gamename/filename.ext.gz (containing filename.ext)
+    <dir>/gamename/filename.zip    (containing filename.ext)
+
+So let's say that we are searching for rom0001.1, which 
+is part of pacman. Then xmame/xmess would search every 
+dir in your rompath for
+
+    <dir>/pacman.zip               (containing rom0001.1)
+    <dir>/pacman/rom0001.1
+    <dir>/pacman/rom0001.1.gz      (containing rom0001.1)
+    <dir>/pacman/rom0001.zip       (containing rom0001.1)
+
+Note: If your neogeo games can't find neogeo.rom, put 
+it in a dir called neogeo somewhere in your rompath, or 
+put it in neogeo.zip somewhere in your rompath.
+
+ Read/write Diskette Images
+
+This section only applies to xmess emulations which 
+support read/write diskette images and thus try to open 
+the image read/write.
+
+Xmess first searches for read/write images with the 
+name specified on the commandline:
+
+    <path>/image.ext
+
+where path is the path specified with the image on the 
+commandline. This way, absolute and relative filenames 
+can be used directly on the commandline for an image 
+which is not in the rompath.
+
+Then xmess searches every dir in the rompath for 
+roms/samples in the following way:
+
+    <dir>/image.ext
+
+Note that (g)zipped images are not supported for r/w images.
+
+ Rom Cartridges/Read Only Diskette Images
+
+Xmess begins by searching for cartdriges/disks from the 
+current dir in the following way:
+
+    <path>/image.ext
+    <path>/image.ext.gz            (containing image.ext)
+    <path>/image.zip               (containing image.ext)
+
+where path is the path specified with the image on the 
+commandline. This way, absolute and relative filenames 
+can be used directly on the commandline for an image 
+which is not in the rompath.
+
+Then xmess searches every dir in the rompath for 
+carts/images in the following way:
+
+    <dir>/image.ext
+    <dir>/image.ext.gz             (containing image.ext)
+    <dir>/image.zip                (containing image.ext)
+
+Finally, xmess searches the rompath as desribed above 
+using the systemtype for gamename.
+
+So let's say we want to play mario.nes on the nes 
+emulation of xmess. We would then type: "xmess nes 
+mario.nes". Xmess then begins by searching the current 
+dir for
+
+    mario.nes
+    mario.nes.gz                   (containing mario.nes)
+    mario.zip                      (containing mario.nes)
+
+After that, xmess searches each dir in your rompath for
+
+    <dir>/mario.nes
+    <dir>/mario.nes.gz             (containing mario.nes)
+    <dir>/mario.zip                (containing mario.nes)
+
+And finally, xmess searches each dir in your rompath for
+
+    <dir>/nes.zip                  (containing mario.nes)
+    <dir>/nes/mario.nes
+    <dir>/nes/mario.nes.gz         (containing mario.nes)
+    <dir>/nes/mario.zip            (containing mario.nes)
+
+Since xmess first searches for cartridges/disks from 
+the current dir you can also specify cartridges/disks 
+not in your rompath. For example:
+
+    "xmess nes ../mario.nes"
+
+Xmess then searches for
+
+    ../mario.nes
+    ../mario.nes.gz                (containing mario.nes)
+    ../mario.zip                   (containing mario.nes)
+
+and will also search the rompath as described above 
+with ../mario.nes as the image name but this is not 
+that useful.
+
+ Artwork
+
+Xmame/xmess searches every dir in the rompath for 
+artwork in the following way:
+
+    <dir>/artwork.png
+    <dir>/artwork.png.gz           (containing artwork.png)
+    <dir>/artwork.zip              (containing artwork.png)
+
+Then xmame/xmess searches the rompath as in roms/samples.
+
+So let's say we want to play foo which uses bar.png. 
+Xmame/xmess then begins searching each dir in your 
+rompath for
+
+    <dir>/bar.png
+    <dir>/bar.png.gz               (containing bar.png)
+    <dir>/bar.zip                  (containing bar.png)
+
+And then xmame/xmess searches each dir in your rompath for
+
+    <dir>/foo.zip                  (containing bar.png)
+    <dir>/foo/bar.png
+    <dir>/foo/bar.png.gz           (containing bar.png)
+    <dir>/foo/bar.zip              (containing bar.png)
+
+ Xmame configuration
+
+Xmame looks for the following configuration files and 
+parses each one found. Files parsed later can overwrite 
+options in previously parsed files:
+
+    XMAMEROOT/xmamerc
+    XMAMEROOT/xmame-DISPLAY_METHODrc
+    ${HOME}/.xmame/xmamerc
+    ${HOME}/.xmame/xmame-DISPLAY_METHODrc
+    ${HOME}/.xmame/rc/<gamename>rc
+
+XMAMEROOT is defined during compile time, see Makefile.
+
+DISPLAY_METHOD is the DISPLAY_METHOD for which xmame 
+was compiled, this can be one of: x11, svgalib, ggi, 
+xgl, xfx, svgafx, openstep, SDL.
+
+For xmess of course replace xmame by xmess. ;)
+
+ Game configuration
+
+Game configuration files are kept on a per-user base in:
+
+    ${HOME}/.xmame/cfg/<game>.cfg resp
+    ${HOME}/.xmess/cfg/<game>.cfg
+
+ Game state
+
+Game state files are kept on a per-user base in:
+
+    ${HOME}/.xmame/sta/<game>.sta resp
+    ${HOME}/.xmess/sta/<game>.sta
+
+ NVram
+
+NVram files are kept on a per-user base in:
+
+    ${HOME}/.xmame/nvram/<game>.nv resp
+    ${HOME}/.xmess/nvram/<game>.nv
+
+ Mem cards
+
+Mem cards files are kept on a per-user base in:
+
+    ${HOME}/.xmame/mem/<filename>.mem resp
+    ${HOME}/.xmess/mem/<filename>.mem
+
+Where <filename> is given by the game-driver. 
+
+ Screenshots
+
+Screenshots, which can be made by pressing F12, are 
+saved as png files in the directory from where xmame is 
+started (cwd).
+
+This can be overidden by the screenshotdir entry in 
+xmamerc/xmessrc, which can again be overidden by the 
+-screenshotdir cmdline-option.
+
+They are saved as:
+
+    <screenshotdir>/<game>xxxx.png
+    Where xxxx is a number.
+
+ Highscores
+
+Highscores are stored in XMAMEROOT as defined in 
+Makefile when building. This can be overidden by the 
+spooldir entry in xmamerc/xmessrc, which can again be 
+overidden by the -spooldir cmdline-option.
+
+So only give a 
+
+    drwxrwsr-x root games <spooldir>
+
+permission and setgid xmame/xmess to "games" to get it 
+to work. Note this doesn't work with suid root versions 
+(svgalib & XF86-DGA), suggestions welcome.
+
+For now use ${HOME}/.xmame or $ {HOME}/.xmess as the 
+spooldir in xmamerc/xmessrc for  suid root versions.
+
+Note: For highscores to work, xmame must also be able 
+to find hiscore.dat.
+
+ hiscore.dat
+
+If you want to use highscores mame needs to load 
+hiscore.dat to get highscore info.
+
+The default is XMAMEROOT/hiscore.dat . XMAMEROOT is set 
+during compile-time; see the Makefile. This can be 
+overridden by the hiscorefile entry in xmamerc if 
+present, which can again be overridden by the 
+cmdline-option -hiscorefile.
+
+hiscore.dat is available from the mame homepage: [http://www.mame.net||http://www.mame.net]
+
+ cheat.dat
+
+If you want to use cheats mame needs to load cheat.dat 
+to get cheat info.
+
+The default is XMAMEROOT/cheat.dat . XMAMEROOT is set 
+during compile-time; see the Makefile. This can be 
+overridden by the cheatfile entry in xmamerc if 
+present, which can again be overridden by the 
+cmdline-option -cheatfile.
+
+cheat.dat is available from the mame homepage: [http://www.mame.net||http://www.mame.net]
+
+ history.dat
+
+If you want to display some nice background info on 
+games, mame needs to load history.dat.
+
+The default is XMAMEROOT/history.dat . XMAMEROOT is set 
+during compile-time, see the Makefile. This can be 
+overridden by the historyfile entry in xmamerc if 
+present, which can again be overridden by the 
+cmdline-option -historyfile.
+
+history.dat is available from the mame homepage: [http://www.mame.net||http://www.mame.net]
+
+ Input logs
+
+Input logs are saved/read under the name specified 
+after the -record / -playback option; this name is 
+relative to the current path.
+
+ Xmame/xmess still can't find files/store highscores
+
+Type "xmame/xmess -showconfig | more" and check that 
+the rompath and spooldir shown are correct and 
+readable/writable. Otherwise recheck xmamerc/xmessrc. 
+Remember that xmess also searches the current dir.
+
+ How do I start xmess/xmame ?
+
+To start xmame, type
+
+    xmame [options] <gamename> [more options]
+
+For xmess, type
+
+    xmess [options] <systemname> [more options] \
+    <disk/romimage(s)> [more options]
+
+All options are optional. ;)
+
+Xmame/xmess supports most dos command line options (see 
+readme.mame / readme.mess) as well as a few of its own: 
+Type xmame -help |  more for a complete list.
+
+With xmess, some systems don't require a disk/romimage, 
+but most do.
+
+ What are the command line parameters for xmame/xmess?
+
+To see a list of available parameters, type:
+
+    /usr/games/xmame -help | more
+
+Xmame/xmess supports most of the command line 
+parameters as the DOS  version as well a some of its own.
+
+See the file readme.mame / readme.mess for more 
+information about the command line parameters.
+
+ What keys does xmame/xmess use?<FAQ: What keys does xmame/xmess use?>
+
+Xmame/xmess uses the same key-bindings as the DOS 
+version of mame: The following keys work in all emulators:
+
+    `  or ~      Enter On screen display to change 
+volume, brightness etc.
+    Tab          Enter configuration menu. Press Tab or 
+Esc to get back to
+                 the emulation.
+    P            Pause
+    F3           Reset
+    F4           Show the game graphics. Use cursor 
+keys to change set/color,
+                 F4 or Esc to return to the emulation.
+    F8           Reduce frame skip
+    F9           Increase frameskip
+    F10          Toggle speed throttling
+    F10 + shift  Toggle idle sleeping
+    F11          Toggle speed display
+    F11 + shift  Toggle profiler display
+    F12          Save a screen snapshot
+    ESC          Exit emulator
+
+Xmame has 2 different auto frameskipping algorithms. 
+These can be selected with the -frameskipper option and 
+with key combos:
+
+    Key combo:             Gives you the:
+    left-ctrl + insert     standard dos frameskipper
+    left-ctrl + home       William Barath's frameskipper
+
+Xmame's display scaling can be controlled on the fly 
+with the following key combos:
+
+    Key combo:             Result:
+    left-shift + insert    Increase widthscale
+    left-shift + delete    Decrease widthscale
+    left-shift + home      Increase heightscale
+    left-shift + end       Decrease heightscale
+    left-shift + pageup    Increase scale
+    left-shift + pagedown  Decrease scale
+
+Under X11, xmame can switch to and from different modes 
+during runtime: 
+
+    Key combo:             Warps you to:
+    left-alt + insert      Normal window
+    left-alt + home        DGA fullscreen mode
+
+Under SDL, xmame can switch to and from different modes 
+during runtime:
+
+    Key combo:             Result:
+
+    left-alt + enter       Toggles between windowed and
+
+                           fullscreen modes.
+
+Under X11 in a window, you can also grab the mouse. To 
+be able to play with the mouse, press left-alt + 
+page-down to grab the mouse, and press it again to 
+release it.
+
+ Why doesn't a game have sound?
+
+* First check that sound is working in other applications.
+
+* Check that sound is supported for the game that has 
+  no sound; not all games have sound.
+
+* For xmame, take a look at gamelist.mame: Is the sound 
+  for the game emulated?
+
+* For xmess take a look at readme.mess: Is the sound 
+  for the system emulated?
+
+* Check the operating system support chart in the 
+  earlier part of  this file: Does xmame/xmess support 
+  sound on your system?
+
+ My sound seems lagged. / My sound Clicks. / What does 
+  -bufsize do?
+
+With the -bufsize commandline option or the bufsize 
+configfile keyword, you can specify the number of 
+frames of audio to buffer. The default is 2 frames.
+
+This value should be ok for everyone, but if you still 
+have problems, read on.
+
+If the buffersize is to small, this causes the buffer 
+to get empty between frames which in turn causes 
+clicks/pauses in the sound. If this is the case, 
+increasing the -bufsize value to, for example, 2.5 
+should help.
+
+If, however, you make the buffersize too large, then so 
+much audio becomes buffered, that the sound could 
+become lagged. E.g., you would hear the coin drop sound 
+0.5 seconds after pressing the insert coin key. In this 
+case, lower the bufsize to, for example, 1.5.
+
+Please let me know if you need to change this setting, 
+since I'm planning on removing it in a future release.
+
+ Why doesn't a game work? <FAQ: Why doesn't a game work?>
+
+* Do you have the right roms or did you get checksum failures?
+
+* Xmame version 0.34 and higher require PROM files that 
+  were not included in ROM images released before 
+  version 0.34. See the question on PROMs  below for 
+  more information.
+
+* For xmame, check the file gamelist.mame to see if the 
+  game is playable. Just because a game is included 
+  doesn't mean it is working yet.
+
+* For xmess, take a look at readme.mess. Maybe the 
+  system isn't emulated all that well yet.
+
+* Some games require sound support. If you don't have 
+  sound  support under your Unix installation or sound 
+  isn't supported by xmame/xmess for you, try the 
+  -fakesound command line parameter.
+
+ What are PROMs? <FAQ: What are PROMs?>
+
+PROMs contain game-specific information that used to be 
+built in  to mame in versions prior to 0.34. This 
+information has been  extracted and is now included 
+with new versions of ROM files for  games that require 
+this information.
+
+If you want to use your current ROM files, you can 
+obtain just the PROM images in one large file at:
+
+[http://mame.retrogames.com/||http://mame.retrogames.com/]
+
+ Why is xmame/xmess slow?
+
+Xmame/xmess is a compiled C program that is emulating 
+hardware.  Software emulation of hardware always incurs 
+a speed penalty. Here  are some things you can do:
+
+* Try using the -frameskip command line parameter.
+
+* Try pressing F8 while running xmame/xmess to alter 
+  the frame rate.
+
+* Try disabling the throttle with the -nothrottle 
+  command line  parameter or by pressing F10 while 
+  running xmame/xmess.
+
+* While running xmame/xmess, press F11 to check the 
+  speed of xmame/xmess.  If you never get a display of 
+  100%, you need a faster computer.
+
+You can also try recompiling xmame/xmess with more 
+optimal settings. The following suggestions may not 
+work or may not be appropriate on some machines and in 
+some installations.  However, in cases where they do 
+work, there can be a noticeable increase in overall 
+performance of xmame/xmess.
+
+These "enhancements" simply require editing the 
+Makefile that is distributed with xmame, and then 
+recompiling the source.  If you are compiling the 
+source for the second time you will need to do:
+
+    make clean
+    make
+    make install
+
+after editing the Makefile to set your new settings.
+
+ SPEEDUP # 1 - Inline compiling
+
+Try enabling inline compiling by commenting and 
+uncommenting the following lines:
+
+    # IL    = '-DINLINE=static inline'
+    IL     = -DINLINE=static
+
+ SPEEDUP # 2 - Direct Graphics Access
+
+For a big boost, try enabling DGA by uncommenting the 
+following line:
+
+    DGA = 1
+
+Then start xmame as root, and press left-alt + home to 
+switch to dga mode; that should be a lot faster, and 
+doesn't need/use xsync. ;) 
+
+To get back to a window without exiting, press left-alt 
++ insert.
+
+The benefit of DGA is that it is Direct Graphics Access 
+and therefore writes directly to the framebuffer (think 
+DirectX versus GDI under MS Windows). So it should be a 
+tad faster, unless you've got a really really well 
+accelerated X-server, which could be just as fast. Try 
+pressing F11 to see the actual framerate, although it 
+might be hardly noticable (visually, at least), it 
+should give you some speed increase.
+
+Besides that, it automatically switches to the right 
+mode and removes any window manager stuff, but that can 
+be done without DGA too. (I might add such a feature 
+later, since it allows easy fullscreen without running 
+as root.)
+
+Adding a 320x240 mode will most definitely get you a 
+very nice fullscreen display at scale = 1. ;)
+
+Don't forget that you still need to set up the Modes 
+line of the   "Display" subsection of the "Screen" 
+section in your X11 config file if you want the games 
+to fill the screen in DGA mode. Xmame will pick the 
+best mode it can find, so if you have a line like
+
+    Modes  "1024x768" "800x600" "640x480" "320x240" "256x224"
+
+then any game which fits into a 320x240 screen can be 
+displayed in that resolution, and so on. Don't forget 
+your X11 config file might have a number of different 
+"Screen" sections in it, and you will need to add Modes 
+to the one that is actually active with your Xserver is 
+running. And of course it's not always that easy, since 
+you also need to tell X which monitor settings are 
+required for these resolution modes. This is done 
+through Modeline entries in the "Monitor" section of 
+your X config file.
+
+You can check out the /contrib/tools/modelines file for 
+a set of crazy modes made especially for xmame in DGA 
+mode. They should work on any reasonable multisync 
+monitor, but don't use them on an old fixed-frequency 
+monitor. (And if you can't resist trying, I won't pay 
+for a new one!)
+
+ SPEEDUP # 3 - NASM
+
+You can also try installing nasm and compiling the asm 
+core, that helps a bit too.
+
+ SPEEDUP # 4 - ICC
+
+If you are running on an intel architecture machine, 
+you could try to compile xmame with the Intel C 
+Compiler. Some people have reported speed gains from +10%.
+
+ I've got a dual processor machine. What can I do to 
+  take full advantage of this?
+
+Not much. Xmame is a single-threaded port of a 
+single-threaded DOS app. Some degree of speedup will 
+hopefully be found on an SMP machine since xmame is 
+more likely to get to hog its one CPU for longer. But 
+of course the same applies to any CPU-intensive 
+program. And all the things one would normally do to 
+any application to give it more CPU time (higher 
+priority, kill or renice unecessary process, etc.) will 
+work with xmame.
+
+Now you may at this point be thinking, "Surely you could 
+have one thread doing emulation and another thead doing 
+graphics to get a speedup." Yes, but there are some 
+serious issues to consider. The first is 
+synchronisation between the threads, which needs to be 
+pretty tight. If not done smoothly. the overhead will 
+blow most of the benefit away. Also, it needs to be 
+implemented with a portable threads interface ... which 
+basically means POSIX threads. In a nutshell, it's a 
+lot of effort for probably not much gain. But of course 
+if you are feeling particulary energetic and in the 
+mood to code, then patches can always be submitted to 
+the xmame devel mailing list ... :)
+
+ Why doesn't my joystick handle diagonal movement 
+  correctly on my Intel x86 system?
+
+Xmame/xmess uses autocalibrating, but you could try to 
+use specific programs to calibrate it (jscal that comes 
+with joystick  module works fine....).
+
+ How do I enable XinputExtensions X11 based joystick in Xfree86?
+
+You need to edit XF86Config to enable the XInput 
+section. See the  manual page for XF86Config.
+
+ How do I read a manual page?
+
+Easy. If you want to read the manual page for 
+XF86Config, type: man XF86Config
+
+ Why do I get gz_open symbol not found while compiling? <FAQ: Why do I get gz_open symbol not found while compiling?>
+
+Xmame/xmess versions newer than 0.35 use zlib for some 
+compression routines. Unfortunately, a lot of Linux 
+distributions have an old version of zlib installed as 
+/usr/X11R6/lib/libz.a, and the new version installed as 
+/usr/lib/libz.a. If this is the case, it's harmless to 
+remove /usr/X11R6/lib/libz.a. If you're not sure 
+whether this is the case, just move 
+/usr/X11R6/lib/libz.a to another location.
+
+Removing or just moving /usr/X11R6/lib/libz.a should 
+fix this problem.
+
+Also see: [FAQ: Why do I get zlib.h not found?]
+
+ Why do I get zlib.h not found? <FAQ: Why do I get zlib.h not found?>
+
+Xmame/xmess versions newer than 0.35 use zlib for some 
+compression routines.
+
+Zlib is standard on most Unix versions. For those who 
+don't ship with zlib or ship with a version that is too 
+old, xmame/xmess now comes with a stripped-down version 
+of zlib. Uncomment the appropriate line in the Makefile 
+to use this.
+
+ When I run xmame.x11, nothing happens---no window pops 
+  up or anything. Help!
+
+Are you running a recent version of KDE, such as 2.1.1? 
+It appears that there's a bug with KDE's window manager 
+that prevents some X11 apps from popping up their main 
+window. You can either run the SDL version of xmame, or 
+try the following workaround, which several people have 
+reported as being successful:
+
+xmame.x11 -rid `xwininfo -root | grep xwininfo: | awk 
+'{print $4}'`
+
+ Can I run xmame fullscreen?
+
+Yes, of course you can. There are several ways to 
+accomplish this, each with its own advantages and disadvantages.
+
+To enable the fullscreen support, you will need to 
+change some settings in the makefile and recompile xmame.
+
+Besides the x11 and SDL drivers, the FX and GL drivers 
+are also capable of playing games full screen. There is 
+a separate chapter for these later on.
+
+ xmame.x11/DGA
+
+First, before recompiling, make sure you have an 
+xserver with the "xfree-dga" extension enabled (do a "xdpyinfo"
+ and see if you've got the "xfree-dga" extension); any 
+recent release of XFree86 should have it.
+
+Select DISPLAY_METHOD = x11 and uncomment the line "
+DGA=1" in the makefile.
+
+Now build xmame and give the xmame.x11 file permanent 
+root permissions so that you don't need to start xmame 
+as root (do a "chown root xmame.x11" and a "chmod u+s xmame.x11").
+
+If you want to start immediately in fullscreen mode, 
+start xmame.x11 with the "-x11 1" argument or specify 
+"x11-mode 1" in your xmamerc file.
+
+During play you can switch between windowed and 
+fullscreen mode. See [FAQ: What keys does xmame/xmess use?]
+
+ xmame.x11/Xv
+
+Xv is the X Window System video extension. Among other 
+things, it supports hardware scaling if your graphics 
+card (and X driver) is capable of doing so. You can 
+achieve a very nice fullscreen display without taxing 
+your cpu very much because the scaling will all be done 
+by your video card.
+
+To determine if your video card supports the Xv 
+extension, you may use this command:
+
+xvinfo
+
+If you don't see a message indicating "no screens found", 
+then the Xv extension is supported by your machine.
+
+To compile this into xmame, select DISPLAY_METHOD = x11 
+and uncomment the line "X11_XV = 1" in the makefile.
+
+Build xmame, and use the -fullscreen parameter when 
+loading a game to get a nice fullscreen display.
+
+If the colors seem messed up and/or you only see half 
+of the game image, try using "-yuv" or "-yv12". By default, 
+the Xv extension attempts to use RGB mode if your 
+driver supports it, but some cards' drivers are broken.
+
+If your screen goes blank or gets full of little green 
+vertical lines, then your graphics card does not 
+support the Xv extension and you're out of luck.
+
+ xmame.SDL
+
+The SDL library was meant to make it easy for 
+programmers to make full screen applications. To start 
+SDL in fullscreen mode, just run xmame.SDL with the 
+option '-fullscreen'. If you want to know the 
+resolutions that SDL can use, run "xmame.SDL -listmodes", 
+choose the resolution you want, and start "xmame.SDL 
+-modenumber <insert chosen number here>".
+
+You can add "fullscreen 1" to your xmamerc file if you 
+want SDL to start fullscreen automatically; the 
+modenumber line can also be used in the xmamerc. :-)
+
+Most problems experienced by people who are trying to 
+use SDL for fullscreen are related to the section [FAQ: xmame.sdl / xmame.x11 fullscreen has a large border around the game.]
+
+During play you can switch between windowed and 
+fullscreen mode. See [FAQ: What keys does xmame/xmess use?]
+
+ xmame.SDL / fullscreen has a large border around the 
+  game. <FAQ: xmame.sdl / xmame.x11 fullscreen has a large border around the game.>
+
+If the game runs in fullscreen but occupies only a 
+small area in the center of the screen, then your 
+xserver does not have access to low resolutions 
+(320x240, 400x300, and 512x384, for instance). In the 
+case of SDL, the window will be in the resolution of 
+closest matching resolution that SDL can switch to for 
+full screen display.
+
+In this case, you have to add "Modelines" for these 
+resolutions in your XF86config file and add these 
+resolutions to the resolutions list of your display 
+somewhere in your XF86config file (you know, the list 
+of resolutions you can switch to using ctrl-+).
+
+You should find modelines that works with most graphic 
+cards in the xmame contrib subdirectory.
+
+If you don't want to alter your XF86config file, 
+another solution is to run xmame.x11 with the "-scale 
+2" argument. In this case, the emulator will use 
+640x480 instead of 320x240, 800x600 instead of 400x300, 
+etc. But I don't recommend it. The scaling uses cpu and 
+the games will run more slowly.
+
+However, if your cpu is fast enough, a better option is 
+to use the effects "-ef 1". This introduces advanced 
+render methods to create a nicer looking effect than 
+the simple scaling. On the website you can see [http://x.mame.net/gamescreenshots.html||screenshots] of the 
+different effects.
+
+ I only use some of the emulation parts (Neo Geo / 
+  CPS-2 /...). Do I need the entire xmame? 
+
+If you are interested in compiling only some of the 
+games you, can compile xmame with an alternate target. 
+Edit the makefile.unix and change the target line to 
+accomplish the desired effect. Using this approach, 
+only the CPUs, sound devices, and other chips needed 
+for that particular target are compiled, resulting in a 
+much smaller executable.
+
+* 'TARGET = cpmame' makes a mame version that will only 
+  emulate the CPS-1 and CPS-2 games
+
+* 'TARGET = neomame' makes a mame version that will 
+  only emulate the Neo Geo system
+
+There are some other targets but they are really only 
+useful for the mame developers who create new drivers.
+
+ Why does xmame freeze and lock up when I hit <ESC> to 
+  exit the game or P to pause the game?
+
+There appears to be a bug in the "timer based audio" 
+code that xmame/oss uses on at least one motherboard 
+that we are aware of. Specifically, the ATX 845Pro 
+(Intel Pentium 4 processor) with an integrated i810 soundchip.
+
+To get around this bug use EsounD (Enlightened Sound 
+Daemon), found as esd with Gnome distributions, instead 
+of the oss sound drivers.
+
+Compile ESOUND support into the xmame executable by 
+uncommenting the appropriate line in makefile.unix. 
+Tell xmame to use esound by specifying "esound" on the 
+"dsp-plugin" line in xmamerc, or use the -dp command 
+line parameter to select esound. Also see the next 
+section below.
+
+ Why does xmame report "can't resolve host name 
+  '/dev/dsp' when trying to use esound?
+
+Remove the words "/dev/dsp" from the "audiodevice" line 
+in xmamerc. In other words, you want to have the word 
+"audiodevice" on a line all by itself, with no 
+audiodevice specified.
+
+ Where can I get the latest version of xmame/xmess?
+
+The xmame/xmess Home Page always has the most 
+up-to-date version. The address is
+
+[http://x.mame.net/||http://x.mame.net/]
+
+ I upgraded xmame and now some games do not work anymore.
+
+This can happen, especially if the drivers are in full 
+development or some internal core routines have changed 
+and the drivers have to be updated to accomodate for 
+these core changes. Sometimes a new romdump has been 
+made from the game and you still have the old version, 
+or the zipfile has changed names and you need to rename 
+yours (or any combination of these factors :-).
+
+Here are some things you can do:
+
+1. Clear all the old configuration files, nvram files, 
+  etc. Also delete the content of the directories mem, 
+  nvram, cfg, and try to run the game again. Don't 
+  forget to delete the default.cfg file!
+
+2. If that fails, check to see if the name of the 
+  zipfile is still in the list of supported games. If 
+  you enter an invalid game name, xmame will take a 
+  guess to determine which game you wanted; look at the 
+  first lines of output to see if it tries to load a 
+  different game than the one you want. To know if your 
+  game is still supported, try 'xmame.x11 -list 
+  gamename'. If you do not pass a game name, the 
+  complete list of supported games is printed, and you 
+  can search for the new game name (better use 
+  'xmame.x11 -listfull').
+
+3. If the name hasn't changed, check to see if you have 
+  the correct romdump. Run 'xmame.x11 -verifyroms 
+  gamename' to check your romset. If this fails you 
+  will need to download a newer romdump. Also check 
+  your parent roms as a possible cause of this romset failure.
+
+4. Read the documentation!! Or like the experts would 
+  say, "RTFM!" :-) Chances are that if the driver is 
+  broken, the developer has noted this in the documentation.
+
+5. If the above steps don't solve the problem, then 
+  check to see if it is a known problem; if necessary, 
+  report it to the mame testers project.
+
+If none of these fixes the problem, then try using the 
+older version of xmame you have backed up somewhere to 
+play the game. (You did back-up, didn't you?)
+
+ Where can I send fixes, bug reports, suggestions, or 
+  money?  :-)
+
+See [Mail] of this document.
+
+ What if my question is still not answered?
+
+Please check the offical mame and mess readme files to 
+see if that answers your question:
+
+* [readme.mame||The official mame readme file (readme.mame)]
+
+* [readme.mess||The official mess readme file (readme.mess)]
+
+If that doesn't help, then ask your question on the 
+mailing list or send it to the xmame/xmess maintainer, 
+see  [Mail] for contact information.
+
+ Display Subsystem-Specific Comments and Notes <Display subsystem specific comments and notes>
+
+ FXmame, a glide driver for xmame
+
+The latest version of this driver can be obtained at [http://glmame.linuxgames.com||http://glmame.linuxgames.com].
+
+ Requirements
+
+To run FXmame, you must have:
+
+* A 3Dfx card
+
+* Glide 2x
+
+* The xmame distribution
+
+ Compiling and Installing
+
+FXmame comes in two flavours---xfx and svgafx. The xfx 
+version is designed to run under X11. It uses an X 
+window for input. The svgafx version runs from the 
+console, and uses svgalib for input. Both use the 3Dfx 
+hardware for rendering.
+
+To install FXmame, follow the general instructions for 
+installing xmame. To specify the glide driver, do the 
+following to the Makefile:
+
+* Select either "xfx" or "svgafx" as your display method
+
+* Configure the glide variables to correspond to your 
+  glide setup
+
+The FXmame executables are called "xmame.xfx" and "xmame.svgafx"
+
+ Running
+
+FXmame runs with the same parameters and uses the same 
+keyboard commands that xmame.x11 does.
+
+A few extra keyboard commands have been added in the 
+glide driver:
+
+* RIGHTCTRL-A -- toggle antialiasing in vector games 
+
+* RIGHTCTRL-B -- toggle bilinear filtering
+
+The glide driver also adds several command-line options:
+
+    -fxgama <value> 3Dfx gamma correction value
+
+Note that in order to display the game options or the 
+fps display in vector games, I have to overlay the game 
+bitmap over the vector display. This is because I 
+circumvent the bitmap entirely in vector games. Drawing 
+the bitmap is a big cpu hog, so you'll notice that the 
+game slows down when you turn on the fps display (I 
+know, not ideal when you want to find out the frame rate...).
+
+ Common Questions (FAQ)
+
+Q: When I run FXmame, it just dumps core.
+
+A: Make sure you are running FXmame as root. Root 
+privileges are required to access the 3Dfx hardware
+
+Q: When I run xmame.xfx, it just hangs at the initial 
+game screen.
+
+A: Are you running KDE? For some reason, I can't get 
+keyboard input under KDE. If you have this problem, 
+switch window managers or use xmame.svgafx instead.
+
+ Present Limitations/Bugs
+
+* Antialiasing isn't working quite as well as it should
+
+* Input problems under KDE
+
+ Future Work
+
+* Optimize the drawing code to update only the changed 
+  portions of the game bitmap.
+
+ License
+
+The FXmame code is Copyright 1998 by Mike Oliphant. It 
+may be used and distributed under the terms of the MAME license.
+
+ Version History
+
+v0.5 -- December 11th, 1998 ---------------------------
+
+* implemented long copies in screen update
+
+* added dirty handling. this greatly increases the 
+  speed of games that support the dirty update strategy 
+  (although most of them are older games that already 
+  ran at full speed on modern hardware)
+
+* merged source with xmame b8.1
+
+v0.4 -- October 30th, 1998 --------------------------
+
+* improved alpha handling in vector games - now 
+  bitmapped overlays do not dim the screen o added 
+  svgalib support (xmame.svgafx) o fixed a tiling bug 
+  that gave artifacts on texture tile boundaries
+
+v0.3 -- October 29th, 1998 --------------------------
+
+* got rid of extra lines in vector games o added bitmap 
+  overlay in vector games to show options/fps o added 
+  antialiasing in vector games
+
+v0.2 -- October 28th, 1998 --------------------------
+
+* added screenshots o added 3Dfx gamma adjustment o 
+  added direct acceleration of vector games (still buggy)
+
+v0.1 -- October 27th, 1998 --------------------------
+
+* first public release
+
+ Author
+
+Mike Oliphant [mailto:oliphant@ling.ed.ac.uk||(oliphant@ling.ed.ac.uk)] [http://glmame.linuxgames.com||http://glmame.linuxgames.com]
+
+ GLmame, an OpenGL driver for xmame
+
+The latest version of this driver can be obtained at: [http://www.jausoft.com/glmame.html||http://www.jausoft.com/glmame.html]
+
+ Requirements
+
+To run GLmame you must have:
+
+* An OpenGL implementation
+
+* libjpeg
+
+* hardware 3D acceleration (if you want any kind of framerate)
+
+* the xmame distribution
+
+ Compiling and Installing
+
+Follow the general instructions for installing xmame. 
+To specify the OpenGL driver, do the following in the Makefile:
+
+* Select "xgl" as your display method.
+
+* For runtime printed debug info, add "-DGLDEBUG" to the "
+  GLCFLAGS" variable.
+
+* GLU version 1.2 is recommended (e.g., from SGI). If 
+  you use Mesa's GLU, you may have to add "-DGLU_VERSION_1_2"
+   to the "GLCFLAGS".
+
+The GLmame executable is called "xmame.xgl".
+
+ Running
+
+xmame.xgl runs with the same parameters and uses the 
+same keyboard commands that xmame.x11 does.
+
+The program starts up in cabinet mode. While this is 
+pretty, and cool, you'll probably want to actually play 
+in fullscreen mode.
+
+A few extra keyboard commands have been added in the 
+OpenGL driver:
+
+* RIGHT_ALT-A -- toggle antialias filtering (vector)
+
+* RIGHT_ALT-B -- toggle bilinear filtering (raster)
+
+* RIGHT_ALT-C -- toggle cabinet/fullscreen display (both)
+
+* RIGHT_ALT-F -- toggle between fullscreen (max window 
+  size) and startup window size (both)
+
+* RIGHT_ALT-O -- toggle draw-bitmap (both; nonsense for 
+  raster games, speedup for vector games)
+
+* RIGHT_ALT-T -- toggle phosphor trails (vector)
+
+* RIGHT_ALT-PLUS_PAD -- incr. beam size (vector)
+
+* RIGHT_ALT-MINUS_PAD -- decr. beam size (vector)
+
+The OpenGL driver also adds several command-line options:
+
+    -[no]fullscreen         Start in fullscreen mode
+
+                            (default: disabled)
+
+
+
+    -[no]gldblbuffer        Disable/enable double buffering
+
+                            (default: enabled)
+
+
+
+    -gltexture_size <int>   Force the max width and 
+height of one 
+
+                            texture segment (default: autosize)
+
+
+
+    -[no]glforceblitmode /  Force blitter for true 
+color modes 15/32bpp
+
+    -[no]glblit             (default: enabled)
+
+
+
+    -[no]glext78 /          Force the usage of GL 
+extension number 78,
+
+    -[no]glext              if available (palletted texture)
+
+                            (default: enabled)
+
+
+
+    -[no]glbilinear /       Disable/enable bilinear filtering
+
+    -[no]glbilin            (default: enabled)
+
+
+
+    -[no]gldrawbitmap /     Disable/enable drawing the 
+bitmap; e.g., 
+
+    -[no]glbitmap           disable within vector games 
+for a speedup
+
+                            (default: enabled)
+
+
+
+    -[no]glcolormod         Disable/enable color 
+modulation (intensity,
+
+    -[no]glcmod             gamma)
+
+                            (default: enabled)
+
+
+
+    -glbeam <float>         Set the beam size for 
+vector games
+
+                            (default: 1.0)
+
+
+
+    -[no]glalphablending /  Disable/enable alpha 
+blending if available
+
+    -[no]glalpha            (default: enabled)
+
+
+
+    -[no]glantialias /      Disable/enable antialiasing
+
+    -[no]glaa               (default: enabled)
+
+
+
+    -gllibname /            Choose the dynamically 
+loaded OpenGL
+
+    -gllib <string>         library
+
+                            (default: libGL.so)
+
+
+
+    -glulibname /           Choose the dynamically 
+loaded GLU library
+
+    -glulib <string>        (default: libGLU.so)
+
+
+
+    -[no]cabview            Don't start/start in 
+cabinet view mode
+
+                            (default: don't start in 
+this mode)
+
+
+
+    -cabinet <cabname>      Specify which cabinet model 
+to use
+
+                            (default: glmamejau)
+
+ 
+
+   -glres <string>          Always scale games to 
+<Xres>x<Yres>, 
+
+                            keeping their aspect ratio. 
+
+                            This overrides the scale options.
+
+                            Use this e.g. for the 
+Vodoo1 gfx cards
+
+                            with: "-glres 640x480"
+
+
+
+
+
+
+
+Three cabinet models are provided. The default, 
+"glmamejau", is designed to look like a standard arcade 
+cabinet, like "glmame". The last one, "trans", is a box 
+with a transparent game screen.
+
+Note that in order to display the game options or the 
+fps display in vector games, the game's bitmap is 
+overlaid above the vector display. Drawing the bitmap 
+is a big cpu hog for some low-end hardware accelerated 
+OpenGL implementations, so you'll notice that the game 
+slows down when the bitmap is overlaid.
+
+Because bitmap overlaying is the default, you can 
+toggle it on and off by pressing the "RIGHT_ALT-O" key, 
+or turn it off at startup by using the command line 
+option "-noglbitmap".
+
+A problem with vector games and the cabinet mode is 
+that some vector points do not reside within the screen 
+coordinates, so you may see some vectors outside of the 
+cabinet's mame display.
+
+*** IMPORTANT! ***
+
+If you have trouble with GLmame, or it is slow, read 
+the "Common Questions" section. Most of the questions 
+people email me are answered here.
+
+ Cabinet Models
+
+Cabinet model information is stored in the "cab" 
+subdirectory of the directory you specified with the 
+ROMPATH variable in the Makefile. Path information 
+specified in xmamerc or with the 'rompath' shell 
+environment variable is currently not used. Each 
+cabinet model has it's own subdirectory. GLmame will 
+first try to load either the user-specified cabinet 
+model (using the -cabinet command-line option), or a 
+model corresponding to the current game name. Failing 
+that, it will use the generic "glmame" model.
+
+A cabinet model directory must contain a geometry file 
+<modelname>.cab, and any .jpg files used for textures 
+on the model. The format of the .cab file will be 
+familiar if you have ever programmed using OpenGL -- it 
+looks much like an OpenGL display list. The format is 
+as follows:
+
+    cabv1.1
+
+This header must be the first 7 characters of the file.
+
+    #<text>
+
+Comment lines begin with '#'
+
+    begin <type>
+
+Begins a geometry object, where type is one of (points, 
+polygon, quads, quad_strip, screen). Each "begin" must 
+be paired with an "end" statement. A "polygon" is 
+specified using one vertex per, well... vertex. "quads" 
+are four-sided polygons, each specified by four 
+vertices in order around the polygon. A "quad_strip" is 
+a series of four-sided polygons, each of which shares 
+an edge with the polygons before and after it in the 
+strip. A "screen" is a quad that defines the actual 
+area in 3D space where the game will be displayed. only 
+one of these should be defined. For more info, look at 
+any description of OpenGL geometry.
+
+    end
+
+Ends the geometry object begun with "begin".
+
+    pointsize <s>
+
+Changes the current pointsize to the corresponding size 
+value (specified as a floating point number between 0.0 
+and, e.g., 20.0). Note: You cannot use this statement 
+between begin and end!
+
+    color4 <r> <g> <b>
+
+Changes the current color to the corresponding rgb 
+value (specified as floating point numbers between 0 
+and 1).
+
+    color4 <r> <g> <b> <a>
+
+Changes the current color to the corresponding rgba 
+value (specified as floating point numbers between 0 
+and 1).
+
+    shading <type>
+
+Sets the shading type. available types are "smooth" 
+(which blends colors from one vertex to the next) or 
+"flat" (which doesn't).
+
+    vertex <x> <y> <z>
+
+Specifies a vertex for the current geometry object as a 
+point in 3-space.
+
+    numtex <num>
+
+Specifies the number of different textures to be 
+loaded. This declaration must precede any "loadtex" call.
+
+    loadtex <num> <width> <height> <filename>
+
+Loads texture number <num> from .jpg file <filename>. 
+The .jpg file *must* be <width> by <height> pixels, and 
+both <width> and <height> must be powers of two (and 
+must conform to the hardware requirements of any 3D 
+card you want the cabinet to work with -- 256x256 for 3Dfx).
+
+    texcoord <xcoord> <ycoord>
+
+Sets the texture coordinate of the next vertex. This 
+specifies where in 2D texture space the vertex lies.
+
+    enable texture
+
+Enables texture mapping (using the currently-selected texture).
+
+    disable texture
+
+Turns off texture mapping.
+
+    settex <num>
+
+Select texture <num> for doing texturing. The texture 
+must previously have been loaded using "loadtex".
+
+    camerapan <num>
+
+Starts the camera pan definition that will be followed 
+by <num> camera transistions. After the last transision 
+definition, the pan sequence must be ended with an 
+"end" statement.
+
+    goto <lx> <ly> <lz> <px> <py> <pz> <nx> <ny> <nz>
+
+Relocates and reorients the camera. The arguments are 
+the same as are used by the OpenGL command 
+"gluLookAt()". The camera is positioned at point 
+<lx,ly,lz>, pointing along vector <px,py,pz>, with "up" 
+normal (the direction that is "up" for the camera) <nx,ny,nz>.
+
+    moveto <lx> <ly> <lz> <px> <py> <pz> <nx> <ny> <nz> <frames>
+
+Moves the camera to a new location (specified as in 
+"goto"). The transition occurs over <frames> frames.
+
+All commands must be on separate lines. Use the 
+(somewhat) commented glmamejau cabinet as an example to 
+work from.
+
+ Common Questions (FAQ)
+
+Q: I am only getting a few frames-per-second. This 
+sucks! What gives? 
+
+A1: You're probably running Mesa in software mode. You 
+should read the "README.3Dfx" file in the Mesa distro. 
+Specifically, you need to "setenv MESA_GLX_FX fullscreen".
+
+A2: You don't have a 3D graphics card. Go buy one (see below)!
+
+Q: When I run xmame.xgl, it just dumps core. That's not 
+as much fun as 3D Pacman, now is it?
+
+A1: If you are using a 3Dfx card, make sure you are 
+running xmame.xgl as root. Root privileges are required 
+to access the 3Dfx hardware.
+
+A2: If you're using Mesa and haven't upgraded to v3.0, 
+do so. 
+
+Q: When I run xmame.xgl, it just hangs at the initial 
+game screen.
+
+A: Are you running KDE? For some reason, I can't get 
+keyboard input under KDE. If you have this problem, 
+switch window managers.
+
+Q: Which graphics cards are usable with xmame.xgl? 
+
+A: We have the following experiences (date 20010713):
+
+* Vodoo3 + DRI OpenGL driver (XFree86 4.0.2), with 
+  command line options "-noglaa" and 16bpp X11 server 
+  color depth.
+
+* Vodoo1 + Mesa 3.4 + Glide, with command line options "
+  -glres 640x480"!
+
+* GeForce + NVIDIA OpenGL driver + XFree86 4.0.2 with 
+  default command line options and 16/24bpp X11 server 
+  color depth.
+
+* NVIDIA TNT2 + NVIDIA OpenGL driver + XFree86 4.0.2 
+  with command line options "-bpp 16" and 16bpp (may be 
+  24bpp also ???) X11 server color depth (OpenGL 
+  colortable mapping is buggy).
+
+* NVIDIA TNT + NVIDIA OpenGL driver + XFree86 4.0.2 
+  with command line options "-bpp 16" and 16bpp (may be 
+  24bpp also ???) X11 server color depth (OpenGL 
+  colortable mapping is buggy).
+
+* Matrox MGA 400 + DRI OpenGL driver (XFree86 4.0.2) 
+  with command line options "-bpp 16", "-noglaa" (???) 
+  and 16bpp (may be 24bpp also ???) X11 server color 
+  depth (OpenGL colortable mapping is buggy).
+
+* ATI R128 + DRI OpenGL driver (XFree86 4.1.0) with 
+  command line options "-noglext78 -noglaa" or "-bpp 16 -noglaa"
+  , where the latter options are a bit slower (about 5 
+  fps). 
+
+* LinuxPPC - Powerbook-Firewire + ATI R128: see above!
+
+All of the above drivers work with the option "-bpp 16" 
+and/or "-noglext78", the latter of which is very slow, 
+of course! So it looks like an OpenGL implementation 
+bug is causing these driver/hardware combinations to 
+only work with these command line options. The bug may 
+lie within these OpenGL functions:
+
+* glColorTableEXT 
+
+* glColorSubTableEXT
+
+Currently fast and funny driver/hardware combinations are:
+
+* NVIDIA GeForce + NVIDIA OpenGL driver + XFree86 
+  4.0.2; I have tested the GeForce256 (AGP) hardware. 
+
+* Vodoo + DRI OpenGL driver (XFree86 4.0.2); I have 
+  tested the Vodoo3 hardware.
+
+Q: When I run xmame.xgl, everything is messed up.
+
+A: Read the above experiences ... and try
+
+* switching your X server's bpp value, e.g. switch from 
+  32bpp or 24bpp to 16bpp; 
+
+* the command line option "-bpp 16";
+
+* the command line option "-noglaa";
+
+* the command line option "-noglext".
+
+ Present Limitations/Bugs
+
+* No clipping of vector games (most noticeable in 
+  cabinet mode).
+
+* No preservation of game aspect ratio in cabinet mode.
+
+ Future Work
+
+* Fixing existing bugs .. are there any ? Or are there 
+  some unknown features only ;-) ? 
+
+* Optimize the drawing code to update only the changed 
+  portions of the game bitmap. Optimizing the dirty 
+  code ..
+
+ License
+
+The GLmame code is based upon Mike Oliphant's GLmame 
+code version 0.6. 
+
+The GLMame code is Copyright 1998 by Mike Oliphant. It 
+may be used and distributed under the terms of the MAME 
+license. 
+
+Since GLmame version 0.7, the code has been changed and 
+improved heavily by Sven Goethel --- no license change, 
+of course!
+
+ Version History
+
+v0.83 -- March 29th, 2001 ---------------------------
+
+* Changed the code heavily to improve compatibility and 
+  speed. The new code is a re-merge of the GLMame32 
+  code, which is a branch of Mike Oliphant's GLmame 
+  code version 0.6. 
+
+* For a detailed list, please consult the file 
+  changes.opengl within the distribution's 
+  documentation directory! You can also view the 
+  current changes.opengl here: [http://www.jausoft.com/glmame.html||http://www.jausoft.com/glmame.html]
+
+v0.6 -- December 14th, 1998 ---------------------------
+
+* added support for systems that do not support 
+  paletted textures (SGI and solaris OpenGL 
+  implementations, for example)
+
+* merged source with xmame b8.1
+
+v0.5 -- October 30th, 1998 --------------------------
+
+* fixed a bug with texturing being left on in bad places
+
+* added 3Dfx gamma adjustment
+
+v0.4 -- October 21st, 1998 --------------------------
+
+* updated to work with xmame v0.34b5.2
+
+v0.3 -- October 12th, 1998 --------------------------
+
+* fixed verticle screen centering in fullscreen mode
+
+* moved cabinet and camera panning information into a 
+  user-editable configuration file
+
+* added 'trans' cabinet model o added double buffer, 
+  view type, and cabinet selection command-line options
+
+v0.2 -- October 6th, 1998 -------------------------
+
+* adding missing 'cab' directory
+
+v0.1 -- October 5th, 1998 -------------------------
+
+* first public release
+
+ Authors
+
+Since GLmame version 0.7: Sven Goethel [mailto:sgoethel@jausoft.com||(sgoethel@jausoft.com)] [http://www.jausoft.com/glmame.html||http://www.jausoft.com/glmame.html]
+
+Till GLmame version 0.6: Mike Oliphant [mailto:oliphant@ling.ed.ac.uk||(oliphant@ling.ed.ac.uk)] [http://glmame.linuxgames.com||http://glmame.linuxgames.com]
+
+ Contact Information and Credits
+
+ Mail <Mail>
+
+There is an official xmame/xmess mailing list. All 
+operations related to this list are performed via email 
+to [mailto:Xmame-request@toybox.twisted.org.uk||Xmame-request@toybox.twisted.org.uk]
+
+* To subscribe, send mail to: [mailto:Xmame-request@toybox.twisted.org.uk||Xmame-request@toybox.twisted.org.uk] with the keyword 
+  "subscribe" in the body. 
+
+* To unsubscribe, send a mail to: [mailto:Xmame-request@toybox.twisted.org.uk||Xmame-request@toybox.twisted.org.uk] with the keyword 
+  "unsubscribe" in the body.
+
+* To change your subscription, get a password reminder, 
+  etc., go to [http://toybox.twisted.org.uk/mailman/listinfo/xmame||http://toybox.twisted.org.uk/mailman/listinfo/xmame].
+
+* To send mail to the list, use: [mailto:xmame@toybox.twisted.org.uk||xmame@toybox.twisted.org.uk] 
+
+* To ask specific questions about the xmame mailing 
+  list, send mail to: [mailto:Xmame-request@toybox.twisted.org.uk||Xmame-request@toybox.twisted.org.uk]
+
+If you're just curious, and only want to take a look at 
+the mailing list without subscribing, you can use the 
+web-based archive at [http://www.mail-archive.com/xmame%40toybox.twisted.org.uk/||http://www.mail-archive.com/xmame%40toybox.twisted.org.uk/] or [http://toybox.twisted.org.uk/pipermail/xmame/||http://toybox.twisted.org.uk/pipermail/xmame/]. (The latter was activated on 
+5 January 2002.) To read even older messages, see [http://www.mail-archive.com/xmame@locutus.csres.utexas.edu||http://www.mail-archive.com/xmame@locutus.csres.utexas.edu].
+
+To ask UNIX-specific xmame/xmess questions, you could 
+send mail to: [mailto:gold@aros.net||Lawrence's folder], but you're better off sending mail to 
+the list. 
+
+To ask general questions about MAME, send mail to: 
+Mirko (Mix) Buffoni[mailto:mix@lim.dsi.unimi.it||Mirko (Mix) Buffoni] 
+
+Also see (and post) articles on USENET group [news:comp.emulators.misc||comp.emulators.misc]comp.emulators.misc 
+
+with a proper keyword in the body.
+
+Other proper keywords currently recognized as commands 
+by [mailto:Xmame-request@toybox.twisted.org.uk||Xmame-request@toybox.twisted.org.uk] are:
+
+    who             - see everyone who is on the list
+
+    info            - view the introductory information 
+for this list
+
+    help            - list all recognized commands
+
+    
+
+Xmame Mailing List 
+
+* The xmame mailing list is intended to be a technical 
+  forum for xmame developers, that is,
+
+  * To exchange ideas for producing a better xmame.
+
+  * To share patches and bug notifications.
+
+  * To study new design strategies.
+
+  * To expose problems and learn know-how.
+
+* The Xmame mailing list is not a forum about playing 
+  games (but everyone on the list plays...); so please
+
+  * Don't use the list to ask about ROMs.
+
+  * Don't ask about non-UNIX ports of MAME, just about 
+    MAME and xmame.
+
+  * Don't ask about implementing a game. Just search 
+    the docs and contribute yourself (you'll enjoy 
+    twice: programming and playing...).
+
+  * Don't show your last high score in xxx game (we are 
+    interested in programming, and then playing, in 
+    this order).
+
+* Copyright notice: NEVER, I repeat NEVER send ROM 
+  images to the  list. (But you can tell us where to 
+  retrieve them... ;-) )
+
+* At this moment, the xmame list is unmoderated; that 
+  is, everyone subscribed will receive everything sent 
+  to the list. We foresee a need to change this policy 
+  since the list starts to suffer from spam :-(.
+
+If you want to send a personal mail to the xmame/xmess 
+coordinator, send to the address below. Everyone who 
+contributes to xmame/xmess should subscribe to the 
+xmame/xmess mailing list.
+
+* Mailing list:[mailto:Xmame-request@toybox.twisted.org.uk||Xmame-request@toybox.twisted.org.uk]
+
+* Xmame/xmess coordinator: [mailto:gold@aros.net||gold@aros.net]
+
+That's all. Enjoy xmame!
+
+ Bugzilla
+
+In addition to/instead of posting bugs to the mailing 
+list, you can report them to the MESS Bugzilla database 
+at [http://bugzilla.mess.org/||http://bugzilla.mess.org/], under the "XMAME/XMESS" category.
+
+ Credits
+
+Lots and lots and lots of thanks to everyone for their 
+great help on the xmame project. I would like to thank 
+the following people and of course anyone I've forgotten.
+
+Thank you all,
+
+Hans
+
+(Addendum: I'd like to send a big thanks to Hans for 
+his fantastic work as longtime xmame/xmess maintainer, 
+and also to those on the mailing list who have been 
+most helpful during my transition to official 
+maintainer. --Lawrence Gold)
+
+1. Fathers of the MAME-creature (main version)
+
+  * Nicola Salmoria
+
+  * Allard van der Bas
+
+  * Mirko (Mix) Buffoni (General Mantainer during 
+    Nicola's national service)
+
+2. Fathers of MESS
+
+  * Brad Oliver 
+
+  * Richard Bannister
+
+  * Ben Bruscella
+
+  * Nathan Woods (current coordinator)
+
+3. Original UNIX/X11 port
+
+  * Allard van der Bas
+
+  * Dick the Ridder
+
+  * Juan Antonio Martinez
+
+4. Semi-retired Unix maintainer extraordinaire
+
+  * Hans de Goede
+
+5. Alpha-specific issues
+
+  * Christian Groessler
+
+6. Sun-specific issues
+
+  * Keith Hargrove
+
+  * Mathis Rosenhau
+
+7. Irix-specific issues
+
+  * Tristram Scott
+
+8. QNX-specific issues
+
+  * Travis Coady
+
+9. GGI maintainance
+
+  * Gabriele Boccone (original port)
+
+  * Christian Groessler (current maintainer)
+
+10. OpenGL code & maintainance
+
+  * Mike Oliphant (original creator)
+
+  * Sven Goethel (from GLmame 0.7 to the present)
+
+11. Network code
+
+  * Eric Totel
+
+12. Perl scripts for automation of some porting issues
+
+  * Bill Adams
+
+13. Xmame RPMs
+
+  * Jeremy Hansen
+
+14. Mailing list maintainer
+
+  * Chris McCraw (retired)
+
+  * Pete French
+
+15. Bits and pieces
+
+  * Christian Groessler
+
+  * Torsten Paul
+
+  * Jack Patton
+
+  * David Black
+
+16. AIX Sound code
+
+  * Chris Sharpp
+
+17. IRIX Sound Code
+
+  * [mailto:entropy@zippy.bernstein.com||entropy@zippy.bernstein.com] (original code)
+
+  * Brandon Corey (current code)
+
+18. PS2 Linux support
+
+  * Joan Sarah Touzet
+
+19. Xv support
+
+  * Alastair Robinson
+
+20. NetMAME Support
+
+  * Steve Freeland
+
+21. German readme
+
+  * Robert Hamberger
+
+22. Documentation (SGML, HTML, MAN)
+
+  * Rene Herrmann
+
+23. Bugzilla bug database
+
+  * Sean Young
+
+ Legal Issues and Copyrights Concerning MAME/MESS
+
+* Please read the MAME/MESS readme-files first!
+
+* Xmame/xmess should be distributed under terms of the 
+  license in [readme.mame||readme.mame]
+
+* And if you are interested in mess, take a look in [readme.mess||readme.mess]
+
+* The main issue involves ROM images. ROM images are 
+  protected under the copyrights of their authors, and 
+  CANNOT be distributed in the same package as 
+  xmame/xmess. Download any ROM images at your own risk 
+  and responsibility.
+
+* XInputExtensions-based Joystick support. Source code 
+  is entirely pure hack work. No sample code, no info 
+  at all was found (only library  reference manual) and 
+  is copyrighted by me (Juan Antonio Martinez). Use it 
+  under terms of GNU General Public License.
+
+ Some Links
+
+ Unix sources and docs
+
+* The xmame/xmess sources
+
+  [download/xmame-0.72.1.tar.bz2||xmame/xmess-0.72.1 sources]
+
+* xmame/xmess FAQ & Installation Guide:
+
+  [download/xmame-doc.pdf||xmame-doc (pdf format)]
+
+* xmame/xmess known bug list:
+
+  [open_issues.html||open issues]
+
+ Unix binaries
+
+* [http://www.forte-intl.com/~ronald/xmame/||xmame RPMs]
+
+* [http://www.beimborn.com/cps2/linux/rpms||xmame+CPS2 RPMs]
+
+* [http://come.to/georgie||Source and binary for Solaris UltraSPARC]
+
+* [http://www.kwyxz.org/linux/xmame/index.html||AMD-optimized builds for various targets]
+
+ Xmame/xmess download mirrors
+
+* [ftp://cps2:cps2@wingnut.beimborn.com||ftp://cps2:cps2@wingnut.beimborn.com](US)
+
+* [http://www.mame.dk||http://www.mame.dk](Denmark)
+
+* [ftp://ftp.kaupp.cx/pub/xmame||ftp://ftp.kaupp.cx/pub/xmame](US)
+
+ (X)Mame front-ends
+
+* [http://www.mame.net/frontend.html||The official mame frontend page ]
+
+* [http://digilander.libero.it/stefanobolli/index.html||Romeo], a Java front-end
+
+* [http://www.mameworld.net/mamecat/||Mamecat]
+
+* [http://gxmame.sourceforge.net/||GXMame], a GTK front-end striving for MAME32 compatibility
+
+* [http://gnomame.sourceforge.net/||GnoMame], a GNOME front-end
+
+* [ftp://ftp.sad.it/pub/kde/local/||Kmamerun]
+
+* [http://user.cs.tu-berlin.de/~gator/mame/||GrokMame]
+
+* [http://www.geocities.com/SiliconValley/Mouse/1570/||StartXmame]
+
+* [http://grustibus.sourceforge.net||gRustibus], a GNOME front-end 
+
+* [http://it-mame.sourceforge.net/index2.html||it-mame]
+
+* [http://www.sourceforge.net/projects/iqf/||IQF]
+
+* [http://lanzamame.mameworld.net/||LANZAMAME]
+
+* [http://ant.eelinux.com/ptkmame/||ptkmame]
+
+* [http://kemulator.sourceforge.net/||Kemulator], a KDE front-end with MESS and Stella support
+
+* [http://www.foxbox.org/adam/code/flynn/index.html||Flynn](primarily for converted arcade cabinets)
+
+* [http://www.swentelomania.be/swentel/module.php?boxcontent=35&page=40||Playmame & Playmess] (perl-based menu makers)
+
+* [http://www.voicenet.com/~jceklosk/||jMame], a Java front-end (requires JDE 1.4.0)
+
+* [http://yeeking.net/cxmame/||CXmame], a simple console-based front-end
+
+* [http://designs.stormheart.com/kmameleon/||KMameleon], a KDE front-end
+
+* [http://tkmame.retrogames.com/icons||Mamu_'s Icons for X]
+
+ Some other links
+
+* The official M.A.M.E home is at [http://www.mame.net||http://www.mame.net]
+
+* The official mess site is [http://www.mess.org||http://www.mess.org]
+
+* Some other emulation sites are [http://www.vg-network.com||http://www.vg-network.com] and [http://www.retrogames.com||http://www.retrogames.com]
+
+* The very best ROM site on this planet is at [http://www.mame.dk/||http://www.mame.dk/]
+
+* A couple of sites with CPS2 and other patches [http://www.beimborn.com/cps2/linux/||Dan Beimborn's Linux CPS2Mame page] and [http://www.win.tue.nl/~stijn/xmame/||Stijn Hoop's xmame patches ]
+
+* MAME Action Replay Page for those who want to have a  
+  look at other monitors at [http://marp.retrogames.com/||http://marp.retrogames.com/]
+
+* And, of course, don't forget our project homepage at [http://x.mame.net/||http://x.mame.net/]
+
+ ChangeLogs<ChangeLogs>
+
+ The MAME/MESS ChangeLogs
+
+These are the changelogs of the offical MAME and MESS 
+release, the core of xmame/xmess.
+
+* [changes-mame.html||The MAME changelog (changes.mame)]
+
+* [changes.mess||The MESS changelog (changes.mess)]
+
+ The Unix ChangeLog
+
+And now here is the HISTORY of the xmame project (of 
+course that's why you are here :;-)) ... Ren
+
+* [changes-unix.html||The Unix port changelog (changes.unix)]
+
+* The OpenGL display driver changelog: [changes.opengl||changes.opengl] or [http://www.jausoft.com/glmame.html||http://www.jausoft.com/glmame.html]
diff --git a/src/unix/doc/xmame-gdoc-1.html b/src/unix/doc/xmame-gdoc-1.html
new file mode 100644
index 0000000..e69be7c
--- /dev/null
+++ b/src/unix/doc/xmame-gdoc-1.html
@@ -0,0 +1,83 @@
+<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
+<HTML>
+<HEAD>
+ <META NAME="GENERATOR" CONTENT="Microsoft FrontPage 4.0">
+ <TITLE>XMAME/XMESS DOKUMENTATION: Einleitung und Links </TITLE>
+ <LINK HREF="xmame-gdoc-2.html" REL=next>
+
+ <LINK HREF="xmame-gdoc.html#toc1" REL=contents>
+ <link rel="stylesheet" href="xmame.css" type="text/css" >
+ </HEAD>
+<BODY background="../img/xmame.jpg">
+<A HREF="xmame-gdoc-2.html">Weiter</A> Zurck <A HREF="xmame-gdoc.html#toc1">Inhalt</A>
+<HR>
+<H2><A NAME="Introduction and Links"></A>  <A NAME="s1">1. Einleitung und Links </A></H2>
+
+<H2><A NAME="ss1.1">1.1 Willkommen bei XMame</A>
+</H2>
+
+<P>Dies ist die *nix Portierung des regelrecht legendren Mame. Mame ist ein
+Emulator fr Arcade Gerte, begonnen 1997 von Nicola Salmoria. Es hat mit
+einer Reihe von Emulatoren fr einzelne Spiele begonnen. Diese Reihe von
+Emulatoren wurde zusammengefasst zu einem einzigen Multi-Spiele Emulator. Dies
+ist die derzeitige Form von Mame, nicht lnger nur eine Ein-Mann Show, sondern
+ber 100 Leute arbeiten an dem Projekt mit.<br>
+<H2><A NAME="ss1.2">1.2 Alles immer up-to-date halten!</A>
+</H2>
+
+<P>Die aktuellste Version dieser Anleitung, die Sourcen von XMame und vieles
+mehr kann auf der Homepage des XMame-Projektes gefunden werden unter <a href="http://x.mame.net/">http://x.mame.net/</a><P>
+<H2><A NAME="ss1.3">1.3 Hngende Arbeiten - oder TODO</A>
+</H2>
+
+<P>Wenn Du der Meinung bist, dass Du bei der TODO-Liste helfen kannst oder etwas
+anbieten kannst, was interessant ist, dann schicke bitte eine Mail an den
+XMame/XMess Koordinator. Siehe unter <A HREF="xmame-gdoc-5.html#Mail">Mail</A>
+ fr mehr Informationen.
+<P>
+<UL>
+<LI>Mausbewegungen optimieren</LI>
+<LI>Entfernen von osd_input_init_post, Flag fr display ready hinzufgen</LI>
+<LI>Aktualisieren der fps (Bilder pro Sekunde) ist inaktiv bei Vektor Spielen</LI>
+<LI>Update der porting.txt</LI>
+<LI>Alle brigen Soundtreiber in Plugins konvertieren</LI>
+<LI>Neuschreiben des display/input Codes fr mehr Modularitt, objektorientiert
+  und benutzbar als separate Library</LI>
+<LI>Aufspalten der Option <CODE>-[no]scanline</CODE>  in emulierte und echte
+  Scanline Option&nbsp;</LI>
+<LI>Hinzufgen eines Schalter zum Setzen der benutzten Auflsung, ...</LI>
+<LI>Die Pentium TSC fr uclock nutzen, falls vorhanden</LI>
+<LI>Netzwerk:
+<UL>
+<LI>Rausfinden, ob das dosnet-Team noch existiert; wieder zum Laufen bringen, da Netzwerkuntersttzung im DOS-Code nicht mehr funktioniert</LI>
+</UL>
+<UL>
+<LI>Hinzufgen von Maus/Joystick-Untersttzung bei Netzwerkspielen</LI>
+<li>Versuchen die Netzwerkuntersttzung nach tcp zu konvertieren, derzeit existiert keine Fehlerkorrektur</li>
+<li>Netzwerk Code robuster machen, Versionsprfung, Eingabeeinstellungen prfen, usw.</li>
+</UL>
+</LI>
+<LI>X11-Joystick Untersttzung prfen. Angeblich funktioniert dies nicht mehr,
+  aber bisher nur eine Fehlermeldung. Scheinbar nutzt dies niemand</LI>
+<LI>fm Soundhack fr Linux-i386</LI>
+<li>Rausfinden welche Messages ausgegeben werden und wann es einstellbar ist
+  (log-Typ und log-Level), fileio dazu bringen Messages auszugeben ber die
+  Dateien die versuchen es zu ffnen. Dies soll helfen, das Problem beim Laden
+  von Roms zu debuggen. Alles Messages durchgehen, die XMame ausgibt, und sie in
+  ein Standardformat zu bringen wie:<br>
+  <br>
+  <font face="Courier" size="2">OSD:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
+  Info:&nbsp;&nbsp;&nbsp; bla<br>
+  X11-window: Warning: bla<br>
+  Svgalib:&nbsp;&nbsp;&nbsp; Error:&nbsp;&nbsp; bla</font><br>
+  &nbsp;<br>
+</li>
+<LI>Hinzufgen Scancode 128-255 fr nicht-PC&nbsp; Tasten wie F13 - F24, mehr
+  Keypad Tasten usw., update aller Anzeigearten um dieses zu nutzen</LI>
+<li>Sieh auch im Text der TODO-Datei:&nbsp; <A HREF="todo">todo</A>
+</li>
+</UL>
+<HR>
+<A HREF="xmame-gdoc-2.html">Weiter</A> Zurck <A HREF="xmame-gdoc.html#toc1">Inhalt</A>
+</BODY>
+</HTML>
diff --git a/src/unix/doc/xmame-gdoc-2.html b/src/unix/doc/xmame-gdoc-2.html
new file mode 100644
index 0000000..0c41567
--- /dev/null
+++ b/src/unix/doc/xmame-gdoc-2.html
@@ -0,0 +1,399 @@
+<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
+<HTML>
+<HEAD>
+ <META NAME="GENERATOR" CONTENT="Microsoft FrontPage 4.0">
+ <TITLE>XMAME/XMESS DOKUMENTATION: bersetzen, Einrichten und Starten von
+ XMame/XMess</TITLE>
+ <LINK HREF="xmame-gdoc-3.html" REL=next>
+ <LINK HREF="xmame-gdoc-1.html" REL=previous>
+ <LINK HREF="xmame-gdoc.html#toc2" REL=contents>
+<link rel="stylesheet" href="xmame.css" type="text/css" >
+</HEAD>
+<BODY BACKGROUND="img/xmame.jpg" BGPROPERTIES="fixed" >
+<A HREF="xmame-gdoc-3.html">Weiter</A> <A HREF="xmame-gdoc-1.html">Zurck</A> <A HREF="xmame-gdoc.html#toc2">Inhalt</A>
+<HR>
+<H2><A NAME="s2">2. bersetzen, Einrichten und Starten von XMame/XMess</A></H2>
+
+<P><b>Anmerkung:</b> Dieses Kapitel ist kein Unix Handbuch. Du bentigst einige
+Grundkenntnisse von Unix-Befehlen um XMame/XMess bersetzen und installieren zu
+knnen.<H2><A NAME="ss2.1">2.1 Voraussetzungen</A>
+</H2>
+
+<P>
+<UL>
+<LI>GNU make ist zwingend ERFORDERLICH auf ALLEN Systemen, selbst wenn ein
+  anderer Compiler als gcc verwendet wird. </LI>
+<LI>Auf allen Plattformen wird nun die zlib bentigt, seit die DOS-Version dies
+  macht. Wenn Du keine zlib hast, dann kannst Du die abgespeckte Version
+  benutzen, die bei XMame mit dabei ist. Siehe <A HREF="xmame-gdoc-3.html#FAQ: Why do I get gz_open symbol not found while compiling?">FAQ:
+  Warum bekomme ich &quot;get gz_open symbol not found&quot; beim bersetzen ?</A>
+  und <A HREF="xmame-gdoc-3.html#FAQ: Why do I get zlib.h not found?">FAQ: Warum
+  bekomme ich &quot;zlib.h not found&quot; ?</A>
+ </LI>
+<LI>Du solltest die die GNU Entwicklungsumgebung nutzen: gcc, gmake und gnu-ar.
+  Viele Probleme tauchen durch die sehr nachlssige Syntax in gcc auf. Wenn Du also
+  einen Compiler mit strictly ANSI C verwendest, dann werden viele Warnungen
+  auftreten und, falls die Version von XMame/XMess noch nicht voll debugged ist,
+  auch bersetzungsfehler. </LI>
+<LI>Das bersetzen von XMame schlgt fehl, wenn egcs-1.1.x oder gcc-2.95
+  benutzt wird. Verwende den Schalter <CODE>-fno-strict-aliasing</CODE>  um das
+  zu Beheben. Gcc-2.95.1 funktioniert mit <CODE>-fstrict-aliasing</CODE> und
+  bringt netterweise etwas hhere Geschwindigkeit.&nbsp;</LI>
+<LI>Das bersetzen von XMame schlgt auch fehl, wenn unter Red Hat 7 der
+  neueste Update von gcc eingespielt ist (vom 16. Januar 2001). Wenn Probleme
+  auftreten, dann ersetze den Compiler wieder mit der Version, die auf den CD's
+  von Red Hat 7 mitgeliefert wurde oder ersetze im Makefile &quot;gcc&quot; mit
+  &quot;kgcc&quot;. Letzteres nutzt dann den egcs-1.1.2. (Siehe auch die Info zum
+  Flag <CODE>-fstrict-aliasing</CODE>).</LI>
+</UL>
+<H2><A NAME="ss2.2">2.2 Schritt-fr-Schritt Anleitung zum bersetzen von XMame/XMess</A>
+</H2>
+
+<P>
+<OL>
+<LI>Siehe <A HREF="#Compile Notes for Specific Operating Systems">Betriebssystemabhngige
+  Anmerkungen
+  beim bersetzen</A> fr plattformabhngige
+  Informationen zum bersetzen.</LI>
+<LI>Siehe <A HREF="xmame-gdoc-4.html#Display subsystem specific comments and notes">Kommentare
+  und Anmerkungen speziell fr die grafische Ausgabe</A> fr Informationen zu
+  speziellen Grafikausgaben.</LI>
+<LI>Lade den Sourcecode von XMame/XMess herunter.</LI>
+<LI>Verschiebe den Sourcecode in ein passendes Arbeitsverzeichnis. Wenn Du das
+  Archiv auspackst, dann werden unter dem Arbeitsverzeichnis neue
+  Unterverzeichnisse angelegt.</LI>
+<LI>Benenne das Source-Archiv um, damit die Endung .gz ist. Zum Beispiel ndere <CODE>xmame-0.34b1.1.tgz</CODE> 
+  in
+<CODE>xmame-0.34b1.1.tar.gz</CODE></LI>
+<LI>Benutze gzip -d um das Archiv zu entpacken. Versuche beispielsweise:
+<PRE>gzip -d xmame-0.34b1.1.tar.gz
+ </PRE>
+</LI>
+<LI>Extrahiere die Dateien mit tar. Tippe beispielsweise ein:
+<PRE>tar xvf xmame-0.34b1.1.tar
+</PRE>
+</LI>
+<LI>Wechsle nach dem entpacken des Archives in das Unterverzeichnis, dass beim
+  Entpacken anglegt wurde. So wurde z.B. nach dem Entpacken von&nbsp; xmame-0.34b1.1.tar
+  ein Verzeichnis mit dem Namen <CODE>xmame-0.34b1.1</CODE>  angelegt. Wechsle
+  dort hinein. Dieses Verzeichnis ist die Wurzel des Sourcen-Baumes.</LI>
+<LI>Kopiere makefile.unix zu Makefile. Das mitgelieferte Makefile wird zur
+  Entwicklung benutzt und ist kein guter Ausgangspunkt !</LI>
+<LI>Editiere das <CODE>Makefile</CODE>  und ndere die Einstellungen, die Dein
+  System betreffen. Der Standard im&nbsp; <CODE>makefile.unix</CODE> ist
+  voreingestellt um unter X11/Linux zu laufen. Bitte vorsichtig sein beim
+  Editieren dieser Datei.
+<UL>
+<LI>Wenn Du vor hast, X11 Joystickuntersttzung zu bersetzen, dann tippe
+  folgendes ein um die vorhandene Xdevice Liste zu erhalten:
+<PRE>
+make xlistdev; ./xlistdev
+  
+</PRE>
+</LI>
+<LI>Whle das gewnschte Device aus und editiere das Makefile nochmals umd bei
+  der Option
+X11_JOYNAME das korrekte Device einzutragen.<br>
+</LI>
+</UL>
+</LI>
+<LI>bersetze XMame/XMess mit dem Befehl:
+<PRE>
+make
+ </PRE>
+</LI>
+<LI>Wenn das bersetzen fehlschlgt, dann berichte dieses Problem an den
+  Author.</LI>
+<LI><B>*** DU MUSST ROOT-RECHTE HABEN UM DIESEN SCHRITT AUSZUFHREN ZU KNNEN ***</B> &nbsp;<br>
+  Um XMame/XMess zu installieren, gib folgendes ein:
+<PRE>
+make install
+ </PRE>
+</LI>
+<LI>Nun kannst Du XMame/XMess fr andere Anzeigearten bersetzen. Wenn dies
+  nicht gewnscht, dann einfach diesen Schritt bergehen.
+<OL>
+<LI>Wenn Du also fr eine anderes Ziel bersetzen willst, dann wiederhole die
+  Schritte
+<CODE>"
+make"</CODE>  und <CODE>"
+make install"</CODE>  und fge dabei <CODE>"
+TARGET=&lt;target&gt;"</CODE>  zum Kommando make hinzu. Beispiel:
+<PRE>
+make TARGET=mess
+make install
+  
+</PRE>
+</LI>
+<LI>Wenn Du fr eine andere Anzeigeart bersetzen willst, dann wiederhole die
+  Schritte <CODE>"
+make"</CODE>  und <CODE>"
+make install"</CODE>  und fge dabei <CODE>"
+DISPLAY_METHOD=&lt;method&gt;"</CODE>
+  zum Kommando make hinzu. Beispiel:
+<PRE>
+make DISPLAY_METHOD=svgalib
+make install
+  
+</PRE>
+</LI>
+<LI>Du kannst auch die beiden Mglichkeiten von oben kombinieren. Beispiel:
+<PRE>
+make TARGET=mess DISPLAY_METHOD=svgalib
+make install
+  
+</PRE>
+</LI>
+</OL>
+</LI>
+<LI>Lege in Deinem Home-Verzeichnis ein Unterverzeichnis namens .xmame an.</LI>
+<LI>Aus dem Source-Verzeichnis von XMame kopiere die Datei doc/xmamerc.dist nach ${HOME}/.xmame/
+  . (Fr XMess natrlich xmessrc)</LI>
+<LI>Falls bevorzugt kopiere xmamerc.dist in den global gltigen Platz als &quot;xmamerc&quot;
+  (fr XMess kopiere die xmamerc.dist zu xmessrc). Der global gltige Platz
+  fr xmamerc wird im Makefile definiert.</LI>
+<LI>Editiere ${HOME}/.xmame/xmamerc und passe sie an die Einstellungen an. (Fr
+  XMess, editiere ${HOME}/.xmess/xmessrc)</LI>
+<LI>Vergewissere Dich, dass die Umgebungsvariablen DISPLAY und PATH richtig
+  gesetzt sind.</LI>
+<LI>Vergewissere Dich, dass Deine ROM's installiert sind.</LI>
+<LI>Starte das X-Window System. (Wenn Du XMame/XMess fr eine andere Anzeigeart
+  bersetzt hast kann dieser Schritt ggf. entfallen.)</LI>
+<LI>Starte XMame/XMess. Beispielsweise:
+<PRE>
+/usr/games/xmame.x11 dkong
+ 
+</PRE>
+</LI>
+</OL>
+<H2><A NAME="ss2.3">2.3 Bei Problemen beim bersetzen, Einrichten und Starten
+von XMame/XMess...</A>
+</H2>
+
+<P>
+<UL>
+<LI>Lies <A HREF="xmame-gdoc-3.html#Xmame frequently asked questions">XMame
+  hufig gestellte Fragen</A>
+</LI>
+<LI>Lies (die zutreffenden Teile der) 
+<A HREF="xmame-gdoc-7.html#ChangeLogs">Changelogs</A>
+. Sie knnten einige Hinweise ber aktuelle nderungen enthalten, die noch
+  nicht in die Dokumentation aufgenommen sind.</LI>
+<LI>Prfe <A HREF="#Compile Notes for Specific Operating Systems">Betriebssystemabhngige
+  Anmerkungen
+  beim bersetzen</A>. Mglicherweise muss bei Deinem
+  Betriebssystem etwas beachtet werden.</LI>
+<LI>Prfe <A HREF="xmame-gdoc-4.html#Display subsystem specific comments and notes">Kommentare
+  und Anmerkungen speziell fr die grafische Ausgabe</A> fr Anmerkungen zu
+  Anzeigearten. Mglicherweise muss bei Deiner Anzeigeart etwas beachtet werden.</LI>
+<LI>Wenn Du einen Fehler bezglich &quot;gz_open&quot; und eine Menge anderer
+  Fehlermeldungen, dass Funktionen beim Linken nicht gefunden werden, dann lies:
+  <A HREF="xmame-gdoc-3.html#FAQ: Why do I get gz_open symbol not found while compiling?">FAQ:
+  Warum bekomme ich &quot;gz_open symbol not found&quot; beim bersetzen ?</A>
+  und <A HREF="xmame-gdoc-3.html#FAQ: Why do I get zlib.h not found?">FAQ: Warum
+  bekomme ich &quot;zlib.h not found&quot; ?</A>
+.</LI>
+<LI>berprfe, ob der Pfad zu den ROMs in xmamerc/xmessrc korrekt gesetzt ist;
+  siehe <A HREF="xmame-gdoc-3.html#FAQ: Where do roms, images, samples, highscores, configfiles, etc go?">FAQ:
+  Wo mssen roms.images usw. hin ?</A>
+.</LI>
+<LI>Prfe nochmals xmamerc/xmessrc: Ist alles richtig gesetzt ? Wirklich ?</LI>
+<LI>Bekommst Du Meldungen, dass Dateien nicht gefunden wurden ? Mglicherweise
+  fehlen PROMs. Siehe <A HREF="xmame-gdoc-3.html#FAQ: Why doesn't a game work?">FAQ:
+  Warum funktioniert ein Spiel nicht ?</A> und <A HREF="xmame-gdoc-3.html#FAQ: What are PROMs?">FAQ:
+  Was sind PROMs ?</A>
+</LI>
+<LI>Ist das Programm im Suchpfad (Umgebungsvariable $PATH) ?</LI>
+<LI>Fr die SVGAlib/xf86_DGA Version von XMame/XMess wird setuid root bentigt.
+  Sind die Zugriffsrechte korrekt gesetzt ?</LI>
+<LI>Frage die Leute in der Newsgroup alt.game.mame ob schon jemand anderes so ein
+  Problem hatte und vielleicht auch lsen konnte.</LI>
+<LI>Sende eine Mail an die XMame Mailingliste, siehe 
+<A HREF="xmame-gdoc-5.html#Mail">Mail</A>
+  fr mehr Information.</LI>
+</UL>
+<P>Wenn das alles nichts hilft, dann schicke eine Mail an den derzeitigen
+Koordinator des von XMame/XMess Projektes. Siehe 
+<A HREF="xmame-gdoc-5.html#Mail">Mail</A>
+ fr nhrere Informationen.<H2><A NAME="Compile Notes for Specific Operating Systems"></A> 
+ <A NAME="ss2.4">2.4 Betriebssystemabhngige Anmerkungen beim bersetzen</A>
+</H2>
+
+<H3>Linux i386</H3>
+
+<P>Linux i386 ist die Plattform, die ich (Hans) benutze. XMame sollte also ohne
+Probleme unter Linux i386 zu bersetzen sein (Anmerkung: dies gilt auch fr
+Lawrence Gold).<P>Einige Fehler tauchten beim Benutzen von gcc27x auf und
+konnten behoben werden. Bitte egcs benutzen falls vorhanden. Wenn noch mehr
+Fehler in gcc auftauchen sollten, dann wird egcs zwingend werden. Aber ich
+hoffe, dass das nicht notwendig ist.<br>
+<br>
+Es wurde berichtet, dass einige SoundBlaster AWE32 und VIA-82cxxx (OnBoard)
+Karten nicht korrekt mit get_freespace() umgehen knnen. Wenn dem so ist, dann
+werden einige Meldungen bzgl. audio_ioctl() failed in der Konsole auftauchen
+und, wenn alles richtig luft, eine Meldung, dass XMame/XMess auf timer-basierte Sounduntersttzung zurckfllt. Wenn dies nicht automatisch passiert
+und der Sound trotzdem nicht korrekt klingt, dann versuche XMame/XMess zur
+timer-basierten Soundausgabe zu zwingen mit dem Schalter <CODE>-timer</CODE>.<br>
+<br>
+SB64/128PCI Karten (Ensoniq 137x-basierende Karten) knnen ebenfalls
+get_freespace() nicht richtig handeln. Unglcklicherweise tauchen keine
+Meldungen bzgl. audi_ioctl() auf. Diese Karten ignorieren die Aufrufe einfach.
+XMame versucht diese Karten automatisch zu erkennen und setzt dabei auf
+timer-basierte Sounduntersttzung zurck. Wenn dies nicht automatisch
+funktioniert und der Sound nicht korrekt klingt, dann versuche XMame/XMess zur
+timer-basierten Soundausgabe zu zwingen mit dem Schalter <CODE>-timer</CODE>.<br>
+<br>
+Einige Leute haben berichtet, dass sie bei ALSA mit OSS-Emulation erfolgreich
+waren (siehe
+<A HREF="http://www.alsa-project.org/">http://www.alsa-project.org/</A>
+ ). Wenn obige Probleme auch bei Dir auftauchen, dann kann dies mglicherweise
+einen Versuch wert sein.&nbsp;<br>
+<br>
+Zustzlich habe ich das PC-Speaker Modul getestet. Es funktioniert !! Aber es
+bentigt ebenfalls <CODE>-timer.</CODE>  Nochmals, dies sollte automatisch
+passieren. Wenn nicht, dann weisst Du ja nun was zu tun ist.<P>Distributionsabhngige
+Kommentare:
+<UL>
+<LI>S.u.S.E. Linux: Neben dem gcc Compiler und den Libraries libc, beide aus der
+  Serie &quot;d&quot;, mssen noch andere Pakte installiert sein oder das
+  bersetzen wird fehlschlagen. Beim bersetzen fr die SVGAlib wird das
+  Paket svgalib aus der Serie &quot;d&quot; bentigt. Wenn fr das X-Window
+  System bersetzt wird, dann muss das Paket xdevel aus der Serie &quot;x&quot;
+  installiert sein. Diese Pakete knnen mit dem Tool &quot;yast&quot;
+  installiert werden, dass bei der S.u.S.E. Distribution dabei ist.</LI>
+<LI>Red Hat Linux ist das Betriebssystem, dass vom Author benutzt wird.
+  XMame/XMess sollten sich beide korrekt unter Red Hat Linux bersetzen lassen
+  ;-)</LI>
+</UL>
+<H3>Linux PowerPC</H3>
+
+<P>Linux PowerPC sollte von nun an funktionieren. Hier ist eine Mail von Andreas
+Varga <CODE>
+<A HREF="mailto:sid@skater.htu.tuwien.ac.at">sid@skater.htu.tuwien.ac.at</A></CODE>,
+dem Entwickler fr Linux/PowerPC, die die notwendigen Schritte
+beschreibt:&nbsp;&nbsp;&nbsp;<br>
+<br>
+Notwendige nderungen um XMame 0.34b3.1 auf Linux/PowerPC mit SVGALIB zu
+bersetzen.
+<P>Makefile:
+<UL>
+<LI>aktiviere CFLAGS fr Linux/PPC </LI>
+<LI>aktiviere DISPLAY_METHOD = svgalib </LI>
+<LI>aktiviere ARCH = linux </LI>
+<LI>entferne -lvgagl von LIBS.svgalib in src/unix/unix.mak (nur -lvga wird
+  bentigt)</LI>
+</UL>
+<P>Notwendige nderungen um XMame 0.34b3.1 auf Linux/PowerPC mit X11 zu
+bersetzen.<br>
+<br>
+Makefile:
+<UL>
+<LI>aktiviere CFLAGS fr Linux/PPC </LI>
+<LI>aktiviere DISPLAY_METHOD = x11 </LI>
+<LI>aktiviere ARCH = linux </LI>
+</UL>
+<P>Etwas anderes... Sound funktioniert nicht, weil die Untersttzung von
+Soundtreibern bei Linux/PPC Kerneln noch in der Entwicklung ist. Es gibt einen
+alten Treiber, ein gehackter Soundblaster Treiber und neuere 2.1.1xx Kernel
+haben einen Soundtreiber, der auf Amiga DMA Soundtreiber basiert. Wenn diese
+Einschrnkungen behoben sind, dann sollte ein vollwertiger OSS-kompatibler
+Soundtreiber zur Verfgung stehen.... dann sollte der Sound auch funktionieren.<br>
+<br>
+Ich kann nichts ber Joystick Untersttzung sagen ...<P>Die nderungen im
+bersetzungsziel Linux/PPC im Makefile stammen von mir selbst, aber es sind einige weitere nderungen notwendig um es bersetzen zu knnen ... Von Oktober
+ab habe ich mehr Zeit um daran zu arbeiten, und ich werde euch regelmig
+informieren...<br>
+<br>
+Cheers, Andreas
+<H3>IRIX</H3>
+
+<P>Benutze die allgemeine Unix-Architektur fr diese Maschinen, die keine
+Sounduntersttzung installiert haben (XMame/XMess nutzt das dmedia Paket oder
+das neuere AL Paket auf IRIX Systemen).<br>
+<br>
+Silicon Graphics untersttzt mehrere native Compiler. XMame/XMess wurden
+bersetzt und getestet mit dem normalen cc. Es gab einige Probleme, wenn -n32
+fr den neuen 32bit Code verwendet wird. Es funktioniert beim Benutzen von -o32
+fr den alten 32bit Code. Es sollte nun auch mit -n32 funktionieren und um
+Einiges schneller sein..<P>Die Benutzung von DCC ist (wieder mal) nicht empfohlen seit dies ein C++
+Compiler ist. Das bersetzen von XMame/XMess wird ohne nderungen im
+Sourcecode nicht klappen wegen etlicher malloc Aufrufe. Das ndern dieser
+Aufrufe wrde einen verrckt machen, weil die Fehler auch im Core-Teil
+auftauchen, der aber von der DOS-Version kommt. Ganz nebenbei, Mame ist in
+normalen C geschrieben, deshalb bitte einen normalen C-Compiler verwenden.<br>
+<br>
+Einige Probleme wurden gemeldet bei der Benutzung des GNU Linkers. Es ist
+besser, den Linker des Betriebssystems zu verwenden.
+<H3>HPUX</H3>
+
+<P>Benutze bitte die allgemeine Unix Architektur (generic unix). In HP-UX sind
+gcc und gnu-Make VORAUSSETZUNG.
+<H3>ULTRIX </H3>
+
+<P>Benutze bitte die allgemeine Unix Architektur (generic unix).
+<P>Anmerkungen von Danny <CODE><A HREF="mailto:dboxhoor@iso.vilspa.esa.es">dboxhoor@iso.vilspa.esa.es</A></CODE>
+<P><B>SEHR WICHTIG !!!</B>
+<P>Die Xmame/Xmess CPU-Emulatoren greifen auf Speicher durch Zeiger (Pointer) zu, die manchmal einen illegalen Speicherzugriff	verursachen - soweit die MIPS CPU davon betroffen ist. Das	Ultrix Betriebssystem behebt diese "unerlaubten Datenzugriffe".&nbsp;<br>
+<br>
+In Abhngigkeit der Systemeinstellung, werden jede Menge Warnungen ausgegeben bei bestimmten Spielen. Diese Meldungen knnen&nbsp;
+abgeschaltet werden, wenn man das Kommando "uac p 0" in der	selben Shell eingibt, von der aus Xmame/Xmess gestartet wird.<br>
+<br>
+UPDATE: Der neue Schalter -DALIGN_INTS im makefile.unix behebt diese unerlaubten Zugriffe im Sourcecode was natrlich viel	schneller ist, als diesen
+Fehler im Kernel segfault handler	per Hotfix zu beheben.<br>
+<br>
+	Benutze GNU make.<br>
+<br>
+	bersetze mit dem 'c89' Compiler. Obwohl gcc keine Probleme beim	bersetzen und optimieren von Xmame/Xmess macht, ist die	ausfhrbare Datei mit c89 bersetzt schneller auf einer	unbelasteten Maschine (Xmame kann die ganze CPU und den ganzen
+Speicher benutzen, ohne mit anderen hochprioren Prozessen zu	kollidieren), somit kann "frameskip 1" gesetzt werden.<br>
+<br>
+	Wenn mit "c89 -O2" bersetzt wird, dann nicht vergessen,	ebenfalls "-Olimit 1000 zu setzen. Wenn 1000 nicht genug ist,	dann teilt der Compiler mit, da der Wert erhht werden mu.<br>
+<H3>SunOS &amp; Solaris</H3>
+
+<P>Im Makefile sind zwei relevante Optionen fr die verschiedenen	Architekturen vorhanden:<br>
+<PRE>
+    ARCH = generic : dies ist fr das alte SunOS auf den Sparcs, aber
+                     eine Sparc mit Solaris darauf wird natrlich mit
+                     dieser Option auch umgehen knnen
+    ARCH = solaris : dies sollte man fr Sparcs mit Solaris benutzen
+</PRE>
+<P>Momentan wird kein Sound untersttzt unter SunOS. Die Solaris Architektur untersttzt Sound.
+<P>Wenn Sun's OpenWindows Implementation von X11 benutzt wird, dann	mssen die Variablen X11INC und X11LIB in der X11 Options Sektion
+des Makefiles korrekt gesetzt sein. (Es sind bereits Eintrge fr	das Standard OpenWin-Verzeichnis vorhanden. Diese knnen
+auskommentiert werden).<br>
+<br>
+	Wenn natrlich fr X11 bersetzt wird, dann mssen diese Variablen korrekt gesetzt sein, unabhngig von der X11-Implementation, die	verwendet wird ! :)<br>
+<br>
+Wenn der SunPro cc Compiler von Sun verwendet wird, dann haben sich	folgende Flags zum Optimieren bewhrt:
+<PRE>
+    OPTFLAGS    = -fast -xO4 -native
+</PRE>
+<P>Es sind Flle aufgetreten, bei denen die bersetzung von Xmame am Program "ar" gescheitert ist. Die meisten Solaris Installationen	haben einen Satz Utilities die mit dem XPG4-Standard konform sind,	blicherweise im Verzeichins "/usr/xpg4/bin" zu finden. Die XPG4-Version von "ar" sollte wie eine Plage gemieden werden. Es mu	sichergestellt werden, da im Suchpfad "/usr/ccs/bin" vor dem	Verzeichnis "/usr/xpg4/bin" erscheint und alles sollte sauber laufen.<br>
+<br>
+	BITTE BEACHTEN: Derzeit gibt es nicht sonderlich viel Untersttzung	fr SunOS/Solaris. Wenn ein Problem auftritt, versuche es selbst	zu lsen. Wenn Du erfolgreich bist, sende eine Mitteilung an die	Mailingliste mit den Angaben, was Du dafr getan hast. Wenn Du	keinen Erfolg hast, sende trotzdem eine Mitteilung an die
+Mailingliste und jemand _knnte_ Dir vielleicht helfen. Trotz alledem,	dies ist der einzige Weg, wie Probleme mit Xmame unter SunOS/Solaris behoben werden knnen.&nbsp;<br>
+<H3>Openstep</H3>
+
+<P>Du musst den gnumake von OpenStep benutzen, NICHT make. Ausserdem ist
+NeXT/Apple cc dem gcc vorzuziehen. Nur die Optimierung nutzen, die fr OpenStep
+im Makefile vorgesehen sind, sonst wird die ausfhrbare Datei abstrzen. Der
+OpenStep Assembler ist auf i386-Architekturen nicht kompatibel mit dem
+Assemblercode von Mame. Deshalb muss die C-Version benutzt werden (benutze
+i386-noasm anstatt i386, wenn fr i386 bersetzt wird).<br>
+<br>
+Der mitgelieferte Compiler basiert auf dem gcc 2.7.2.1 und kann src/profiler.c
+nicht ohne Absturz bersetzen. Um dies zu Umgehen gehe folgendermaen
+vor: Optimiereun abschalten, wenn der Fehler auftritt. Make fr diese Datei
+nochmals ausfhren und Make beenden. Optmierung wieder aktivieren und
+fortfahren.<br>
+<br>
+Auf einer OpenStep Tastatur funktionieren die Funktionstasten nicht wie
+vorgesehen. Das Benutzen der Kommando-Taste in Verbindung mit einer
+Ziffern-Taste erzeugt eine quivalente Funktionstaste innerhalb von XMame. Mit
+0 , - und = + wird F10, F11 und F12 erzeugt. Bitte auch beachten, dass die
+Kombinationen ALT + Taste nicht gemapped werden knnen. Da die meisten Spiele
+dies als Feuertaste voreingestellt haben ist es extrem ntzlich diese Tasten
+umzusetzen beim ersten Start von XMame.
+<HR>
+<A HREF="xmame-gdoc-3.html">Weiter</A> <A HREF="xmame-gdoc-1.html">Zurck</A> <A HREF="xmame-gdoc.html#toc2">Inhalt</A>
+</BODY>
+</HTML>
diff --git a/src/unix/doc/xmame-gdoc-3.html b/src/unix/doc/xmame-gdoc-3.html
new file mode 100644
index 0000000..8ef9308
--- /dev/null
+++ b/src/unix/doc/xmame-gdoc-3.html
@@ -0,0 +1,699 @@
+<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
+<HTML>
+<HEAD>
+ <META NAME="GENERATOR" CONTENT="Microsoft FrontPage 4.0">
+ <TITLE>XMAME/XMESS DOKUMENTATION: Xmame hufig gestellte Fragen</TITLE>
+ <LINK HREF="xmame-gdoc-4.html" REL=next>
+ <LINK HREF="xmame-gdoc-2.html" REL=previous>
+ <LINK HREF="xmame-gdoc.html#toc3" REL=contents>
+<link rel="stylesheet" href="xmame.css" type="text/css" >
+</HEAD>
+<BODY BACKGROUND="img/xmame.jpg" BGPROPERTIES="fixed" >
+<A HREF="xmame-gdoc-4.html">Weiter</A> <A HREF="xmame-gdoc-2.html">Zurck</A> <A HREF="xmame-gdoc.html#toc3">Inhalt</A>
+<HR>
+<H2><A NAME="Xmame frequently asked questions"></A>  <A NAME="s3">3. XMame
+hufig gestellte Fragen (FAQ)</A></H2>
+
+<H2><A NAME="ss3.1">3.1 Was ist Mame?</A>
+</H2>
+
+<P>Mame ist ein Emulator fr die Arcade-Maschinen aus den Spielhallen. Nicola Salmoria begann 1997 mit Mame. Es entstand	aus einer ganzen Reihe Emulatoren, die fr jeweils nur ein Spiel
+geschrieben worden waren. Diese Einzelemulatoren wurden	kombiniert zu einem "Multispiele
+Emulator&quot;. Dies ist die	aktuelle Form von Mame, kein Projekt eines Einzelnen, sondern	es arbeiten ber 100 Personen daran.<br>
+<br>
+Mame wurde geschaffen von Nicola Salmoria.<P>Siehe auch <a HREF="../download/readme.mame">das
+offizielle Mame Readme (readme.mame)</a><P>
+<H2><A NAME="ss3.2">3.2 Was ist Mess?</A>
+</H2>
+
+<P>Mess ist, wie Mame, ein Emulator fr virtuelle Maschinen. Im Unterschied zu Mame emuliert Mess Computer und Konsolen.<br>
+<br>
+Sieh auch <a HREF="../download/readme.mess">das offizielle Mess Readme (readme.mess)</a><P>
+<H2><A NAME="ss3.3">3.3 Was sind XMame/XMess?</A>
+</H2>
+
+<P>Xmame/Xmess sind die Unix/X11-Portierungen des Mame- und	Messprojektes. Somit sind Mame/Mess verfgbar auf	*ix-Maschinen, die XWindows
+X11R6 untersttzen	(ebenfalls SVGAlib/ggi/XF86-DGA/OpenGL/SDL).<br>
+<br>
+Die erste Mame-Konvertierung stammt von Allard Van Der Bas,	Dick the Ridder, Juan Antonio
+Marmnez und Hans de Goede..<br>
+<br>
+XMame/XMess wird zur Zeit gepflegt von Lawrence Gold.<br>
+<H2><A NAME="ss3.4">3.4 Was sind die Unterschiede zwischen Mame/Mess and XMame/XMess?</A>
+</H2>
+
+<P>Keine wesentlichen.
+<P>Xmame/Xmess basieren auf dem Sourcecode von Mame/Mess.	Aus technischen Grnden, die den Rahmen dieses Dokuments	sprengen wrden, kann der
+Mame/Mess-Sourcecode nicht unter	Unix bersetzt werden.	Deshalb existiert das Xmame/Xmess-Projekt. Jedes mal, wenn	Mame/Mess upgedatet wird, wird das Coding unter Unix getestet	(und gepatched, falls dies ntig ist). Somit sind die	Xmame-/Xmess-Releases immer auf dem selben Stand, wie die	Originale.<br>
+<br>
+Es existieren keinerlei Plne fr eine unabhngige	Entwicklung von Xmame/Xmess.<br>
+<H2><A NAME="ss3.5">3.5 Welche Hardware und welche Betriebssysteme werden
+untersttzt ?</A>
+</H2>
+
+<P>XMame luft auf Low-End und auf High-End CPU's, benutzt aligned Integer-Zugriff wenn ntig und ist auch	compatibel mit 64-bit CPU's.
+Die aktuelle Liste der untersttzten CPU's im Makefile ist:
+<UL>
+<LI>i386 + gnu-asm</LI>
+<LI>i386 no asm</LI>
+<LI>Alpha</LI>
+<LI>ia64 (merced)</LI>
+<LI>m68k</LI>
+<LI>generic risc (PowerPC, Sparc, HPPA, IBM)</LI>
+<LI>generic risc, lsb-first (RISC (Ultrix Maschinen))</LI>
+<LI>mips (generic risc + SGI compiler bug workarounds)</LI>
+</UL>
+<P>Das Hinzufgen von Untersttzung anderer CPU's (falls ntig) sollte einfach sein.<br>
+<br>
+Die folgenden Unix-Plattformen werden im Speziellen untersttzt:
+<UL>
+<LI>Linux</LI>
+<LI>FreeBSD</LI>
+<LI>NetBSD</LI>
+<LI>Solaris (SunOS)</LI>
+<LI>OpenStep (nur noasm auf&nbsp; i386)</LI>
+<li>IRIX mit Sound bei Verwendung des dmedia Paketes oder des neuen al Paketes (Sound funktionert derzeit noch nicht)</li>
+<LI>AIX (Sound funktioniert derzeit nicht)</LI>
+<LI>generic Unix, kein Sound</LI>
+</UL>
+<P>Der Eintrag "generic unix" sollte fr jedes Standard Unix	funktionieren, aber kein Sound, da derzeit kein einziger
+Standard fr Sound unter Unix existiert.
+<P>Auf allen Plattformen wird nun zlib bentigt, weil die DOS-Version	dies nun auch benutzt. Wenn Du die zlib nicht hast, dann kannst Du	die mitgelieferte
+benutzen. Es mssen nur die betreffenden Zeilen	im Makefile auskommentiert werden.<br>
+<br>
+Die folgenden Anzeigearten werden untersttzt, wobei X11 als	Einzige auf allen Plattformen luft, ausser OpenStep, wo nur die OpenStep
+Bitmaps funktionieren:
+<UL>
+<LI>X11 (X-Window System)</LI>
+<LI>SVGAlib</LI>
+<LI>GGI (Generic Graphics Interface)</LI>
+<LI>OpenGL mit X11 fr die Eingabe</LI>
+<LI>Glide mit X11 fr die Eingabe (3DFX)</LI>
+<LI>Glide mit SVGAlib fr die Eingabe (3DFX)</LI>
+<LI>OpenStep Bitmaps</LI>
+<LI>SDL (Simple Direct Medialayer)</LI>
+</UL>
+<P>Die folgenden Kombinationen aus Architektur/BS/Anzeige werden derzeit aktiv untersttzt. Bitte an den jeweils	Zustndigen Mailen, wenn Probleme mit einer
+bestimmten	Kombination aus Architektur/BS/Anzeige beim bersetzten	oder anderen Problemen auftreten. Eine Mail
+an
+Lawrence <CODE>
+<A HREF="mailto:gold@aros.net">gold@aros.net</A></CODE>  bei allgemeinen Problemen (z.B. X11).
+<UL>
+<LI>i386/linux/x11 (+DGA) -&gt; Lawrence <CODE>
+<A HREF="mailto:gold@aros.net">&lt;gold@aros.net></A></CODE></LI>
+<LI>i386/linux/svgalib -&gt; Lawrence <CODE>
+<A HREF="mailto:gold@aros.net">&lt;gold@aros.net></A></CODE></LI>
+<LI>i386/linux/xgl -&gt; Sven Goethel <CODE><a HREF="mailto:sgoethel@jausoft.com">&lt;sgoethel@jausoft.com&gt;</a></CODE></LI>
+<LI>i386/linux/xfx -&gt; Lawrence <CODE>
+<A HREF="mailto:gold@aros.net">&lt;gold@aros.net></A></CODE></LI>
+<LI>i386/linux/svgafx -&gt; Lawrence <CODE>
+<A HREF="mailto:gold@aros.net">&lt;gold@aros.net></A></CODE></LI>
+<LI>i386/linux/ggi -&gt; Christian <CODE>
+<A HREF="mailto:cpg@aladdin.de">&lt;cpg@aladdin.de></A></CODE></LI>
+<LI>alpha/linux/x11 -&gt; Christian <CODE>
+<A HREF="mailto:cpg@aladdin.de">&lt;cpg@aladdin.de></A></CODE></LI>
+<LI>alpha/digital unix/x11 * -&gt; Leandro <CODE>
+<A HREF="mailto:ldardini@usl4.toscana.it">&lt;ldardini@usl4.toscana.it></A></CODE></LI>
+<LI>powerpc/linux/x11 -&gt; Andreas <CODE>
+<A HREF="mailto:sid@skater.htu.tuwien.ac.at">&lt;sid@skater.htu.tuwien.ac.at></A></CODE></LI>
+<LI>powerpc/linux/svgalib -&gt; Andreas <CODE>
+<A HREF="mailto:sid@skater.htu.tuwien.ac.at">&lt;sid@skater.htu.tuwien.ac.at></A></CODE></LI>
+<LI>i386/freebsd/x11 -&gt; Jacob A. Hart <CODE>
+<A HREF="mailto:c9710216@studentmail.newcastle.edu.au">&lt;c9710216@studentmail.newcastle.edu.au></A></CODE></LI>
+<LI>i386/netbsd/x11 -&gt; Dave <CODE>
+<A HREF="mailto:dave@dtsp.co.nz">&lt;dave@dtsp.co.nz></A></CODE></LI>
+<LI>alpha/netbsd/x11 -&gt; Christian <CODE>
+<A HREF="mailto:cpg@aladdin.de">&lt;cpg@aladdin.de></A></CODE></LI>
+<LI>Sparc/Solaris/x11 -&gt; Mathis <CODE>
+<A HREF="mailto:rosenhau@mailserv.sm.go.dlr.de">&lt;rosenhau@mailserv.sm.go.dlr.de></A></CODE></LI>
+<LI>i386/Unixware7/x11 * -&gt; Richard <CODE>
+<A HREF="mailto:xmame@frogface.ddns.org">&lt;xmame@frogface.ddns.org></A></CODE></LI>
+<LI>i386/openstep -&gt; Pete French <CODE>
+<A HREF="mailto:pete@toybox.twisted.org.uk">&lt;pete@toybox.twisted.org.uk></A></CODE></LI>
+<LI>Sparc/SunOs -&gt; Saga <CODE>
+<A HREF="mailto:jolletx@cybercable.fr">&lt;jolletx@cybercable.fr></A></CODE></LI>
+<LI>mips/irix/x11 -&gt; Dingus Family <CODE>
+<A HREF="mailto:ddingus@uswest.net">&lt;ddingus@uswest.net></A></CODE></LI>
+</UL>
+<P>* Dies wird bei der Benutzung des Eintrages "generic unix" im	  Makefile untersttzt und bietet keinen Sound.
+<P>Wir suchen immer nach Leuten, die neue Kombinationen aus	Architektur/BS/Anzeigeart testen und auch aufkommende Fragen	dazu beantworten knnen. Dies kostet nicht viel Zeit und	kann anderen Leute enorm weiterhelfen. Wenn Du Interesse hast,	dann eine Mail an
+Lawrence <CODE>
+<A HREF="mailto:gold@aros.net">gold@aros.net</A></CODE>.<br>
+<H2><A NAME="ss3.6">3.6 Mein Betriebssystem wird untersttzt, aber XMame/XMess
+bringen Fehler und brechen ab. Warum ?</A></H2>
+
+<P>Xmame/Xmess sollten laufen in einem 8bpp Pseudo-Farben-Display und in einem 16, 24 oder 32bpp True Color Display.	Wenn der X-Server keine dieser "Displays" untersttzt, dann	wird Xmame/Xmess auch nicht funktionieren.<br>
+<br>
+Um herauszufinden, was der X-Server untersttzt, kann man	das Tool xdpyinfo benutzen. Mehr Info auf der Manpage	von xdpyinfo.
+<H2><A NAME="ss3.7">3.7 Wozu brauche ich die Dateien xmamerc/xmessrc ?</A>
+</H2>
+
+<P>Ein Aufruf von Xmame/Xmess kann so aussehen:<br>
+<br>
+&nbsp;&nbsp;&nbsp; xmame pacman -sound -nojoy -frameskip 2 -heightscale 3
+\&nbsp;&nbsp;&nbsp;<br>
+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -widthscale 2<br>
+<P>Meist wird man die gleiche Einstellung fr jedes Spiel	nutzen.	Xmame/Xmess liest diese Datei fr die	Grundeinstellungen der Parameter, die gesetzt werden
+knnen.	Auf diese Weise mssen nur die Parameter beim Aufruf	angegeben werden, die berschrieben werden sollen.&nbsp;<br>
+<br>
+Ein anderer Grund fr xmamerc/xmessrc ist die Umbelegung	von Tasten. Einige Unix-Tastaturen weichen stark von	PC-Tastaturen ab. Um dies abzufangen,
+kann man in	xmamerc/xmessrc Tasten belegen/umbelegen, die auf	Unix-Tastaturen nicht vorhanden sind.<br>
+<H2><A NAME="ss3.8">3.8 Was ist die Syntax in den Dateien xmamerc/xmessrc ?</A>
+</H2>
+
+<P>Die Syntax ist recht einfach:<br>
+<br>
+&nbsp;&nbsp; &quot;Schlsselwort Wert&quot;<br>
+<P>Siehe auch in 
+<A HREF="xmamerc.dist">xmamerc.dist</A> fr die meisten der	Schlsselwrter. Fast alle Kommandozeilen-Optionen	knnen als Schlsselwrter (ohne das -) benutzt
+werden,	benutze einfach den Wert 0 oder 1 fr Kommandozeilen-Optionen, die als Gegenstck die verneinende Option
+(-no[option]) haben.	blicherweise beginnen Kommentarzeilen mit einem "#".<br>
+<br>
+Du kannst natrlich eine Konfigurationsdatei erstellen mit allen Einstellungen. Eine Vorlage kann
+erzeugt werden mit
+<PRE>
+   xmame -showconfig &gt; ~/.xmame/xmamerc
+</PRE>
+<H2><A NAME="FAQ: Where do roms, images, samples, highscores, configfiles, etc go?"></A> 
+<A NAME="ss3.9">3.9 Wo mssen roms, images, samples, highscores, configfiles,
+usw. hin</A>? </H2>
+
+<H3>Roms/Samples</H3>
+
+<P>Xmame/Xmess suchen in einem durch ":" getrennten Pfad	nach Roms/Samples/Artwork.&nbsp;
+
+<P> Der Defaultpfad ist XMAMEROOT und wird	whrend des Compilierens gesetzt im Makefile.&nbsp;
+
+<P> Dieser Pfad	kann durch einen beliebigen Pfad in xmamerc/xmessrc berschrieben werden.  Dies kann wiederum durch die
+Kommandozeilen-Option -rompath berschrieben werden.<br>
+<br>
+Xmame/Xmess durchsuchen jedes Verzeichnis in dieser Pfadangabe	nach Roms/Samples auf folgende Weise:<PRE>
+    &lt;dir&gt;/spielname.zip              (enthlt Dateiname.ext)
+    &lt;dir&gt;/spielname/dateiname.ext
+    &lt;dir&gt;/spielname/dateiname.ext.gz (enthlt Dateiname.ext)
+    &lt;dir&gt;/spielname/dateiname.zip    (enthlt Dateiname.ext)
+</PRE>
+<P>Ein Beispiel: es wird nach der Datei rom0001.1 gesucht, die	ein Teil des Spiels Pacman ist. Xmame/Xmess suchen in jedem	Verzeichnis des Suchpfades nach:<PRE>
+    &lt;dir&gt;/pacman.zip               (enthlt rom0001.1)
+    &lt;dir&gt;/pacman/rom0001.1
+    &lt;dir&gt;/pacman/rom0001.1.gz      (enthlt rom0001.1)
+    &lt;dir&gt;/pacman/rom0001.zip       (enthlt rom0001.1)
+</PRE>
+<P>Bemerkung: Wenn Deine NeoGeo-Spiele die Datei neogeo.rom nicht finden,	dann kopiere es in ein Verzeichnis namens neogeo im Suchpfad nach Roms	oder packe es in die Datei neogeo.zip im Suchpfad nach Roms.<H3>Lesen/Schreiben
+von Disketten-Images</H3>
+
+<P>Diese Sektion betrifft nur XMess, dass das Lesen/Schreiben auf
+Disketten-Images untersttzt und dabei versucht das Image zum Lesen/Schreiben
+zu ffnen.<P>XMess sucht zuerst nach den Images mit dem Namen, der in der
+Kommandozeile eingegeben wurde:
+<PRE>
+    &lt;path&gt;/image.ext
+</PRE>
+<P>Dabei ist path der Pfad zu dem Image. Auf diesem Weg knnen auch absolute
+und relative Dateinamen benutzt werden von der Kommandozeile aus, die nicht im
+Suchpfad nach Images sind.<br>
+<br>
+Dann sucht XMess jedes Verzeichnis im Suchpfad fr roms/samples auf folgende
+Art und Weise:
+<PRE>
+    &lt;dir&gt;/image.ext
+</PRE>
+<P>Bemerkung: beim Lesen/Schreiben von Images darf das Image nicht gepackt sein.<br>
+<H3>Rom Cartridges/Read Only Disketten Images</H3>
+
+<P>XMess beginnt die Suche nach Cartridges/Disketten vom aktuellen Verzeichnis
+aus folgendermaen:<PRE>
+    &lt;path&gt;/image.ext
+    &lt;path&gt;/image.ext.gz            (enthlt image.ext)
+    &lt;path&gt;/image.zip               (enthlt image.ext)
+</PRE>
+<P>Dabei ist path der Pfad zu dem Image. Auf diesem Weg knnen auch absolute
+und relative Dateinamen benutzt werden von der Kommandozeile aus, die nicht im
+Suchpfad sind.<br>
+<br>
+Dann durchsucht XMess jedes Verzeichnis im Suchpfad fr Cartridges/Images auf
+folgende Art und Weise:<PRE>
+    &lt;dir&gt;/image.ext
+    &lt;dir&gt;/image.ext.gz             (enthlt image.ext)
+    &lt;dir&gt;/image.zip                (enthlt image.ext)
+</PRE>
+<P><br>
+Abschlieend sucht XMess im Rompfad wie oben beschrieben mit dem Systemtyp nach
+dem Spielenamen.<P>Beispiel: Wir wollen mario.nes spielen mit der NES Emulation
+von XMess. Wir wrden dann eintippen: &quot;xmess nes mario.nes&quot;. XMess
+beginnt die Suche im aktuellen Verzeichnis nach<PRE>
+    mario.nes
+    mario.nes.gz                   (enthlt mario.nes)
+    mario.zip                      (enthlt mario.nes)
+</PRE>
+<P>Danach sucht Xmess in jedem Verzeichnis Deines Rompfades nach
+<PRE>
+    &lt;dir&gt;/mario.nes
+    &lt;dir&gt;/mario.nes.gz             (enthlt mario.nes)
+    &lt;dir&gt;/mario.zip                (enthlt mario.nes)
+</PRE>
+<P>Abschlieend sucht XMess in jedem Verzeichnis Deines Rompfades nach
+<PRE>
+    &lt;dir&gt;/nes.zip                  (enthlt mario.nes)
+    &lt;dir&gt;/nes/mario.nes
+    &lt;dir&gt;/nes/mario.nes.gz         (enthlt mario.nes)
+    &lt;dir&gt;/nes/mario.zip            (enthlt mario.nes)
+</PRE>
+<P>Da XMess zuerst im aktuellen Verzeichnis nach Cartridges/Disketten sucht,
+kann auch eine Cartridge/Diskette angegeben werden, die nicht im Rompfad ist.
+Beispielsweise:
+<PRE>
+    &quot;xmess nes ../mario.nes&quot;
+</PRE>
+<P>XMess sucht nach
+<PRE>
+    ../mario.nes
+    ../mario.nes.gz                (enthlt mario.nes)
+    ../mario.zip                   (enthlt mario.nes)
+</PRE>
+<P>und wird ebenfalls den gesamten Rompfad wie oben beschrieben nach
+../mario.nes als Dateiname durchsuchen. Aber das ist nicht sonderlich hilfreich.
+<H3>Artwork</H3>
+
+<P>XMame/XMess durchsuchen jedes Verzeichnis im Rompfad nach Artwork auf
+folgende Art und Weise:
+<PRE>
+    &lt;dir&gt;/artwork.png
+    &lt;dir&gt;/artwork.png.gz           (enthlt artwork.png)
+    &lt;dir&gt;/artwork.zip              (enthlt artwork.png)
+</PRE>
+<P>Dann suchen XMame/XMess im Rompfad wie bei Roms/Samples.<P>Beispiel: Wir
+wollen foo spielen, dass bar.png nutzt. XMame/XMess beginnen die Suche in jedem
+Verzeichnis des Rompfades nach
+<PRE>
+    &lt;dir&gt;/bar.png
+    &lt;dir&gt;/bar.png.gz               (enthlt bar.png)
+    &lt;dir&gt;/bar.zip                  (enthlt bar.png)
+</PRE>
+<P>Danach suchen XMame/XMess in jedem Verzeichnis des Rompfades nach
+<PRE>
+    &lt;dir&gt;/foo.zip                  (enthlt bar.png)
+    &lt;dir&gt;/foo/bar.png
+    &lt;dir&gt;/foo/bar.png.gz           (enthlt bar.png)
+    &lt;dir&gt;/foo/bar.zip              (enthlt bar.png)
+</PRE>
+<H3>XMame Configuration</H3>
+
+<P>Xmame sucht nach den folgenden Konfigurationsdateien und wertet jede,	die gefunden wird, aus. Somit kann eine spter ausgewertete	Konfigurationsdatei die
+Optionen einer frher gelesenen berschreiben:
+<PRE>
+    XMAMEROOT/xmamerc
+    XMAMEROOT/xmame-DISPLAY_METHODrc
+    ${HOME}/.xmame/xmamerc
+    ${HOME}/.xmame/xmame-DISPLAY_METHODrc
+    ${HOME}/.xmame/rc/&lt;gamename&gt;rc
+</PRE>
+<P><CODE>XMAMEROOT</CODE>  wird whrend des bersetzens gesetzt, siehe
+Makefile.
+<P><CODE>ANZEIGE_METHODE (DISPLAY_METHOD), fr die XMame bersetzt wurde, dies kann sein: x11, svgalib, ggi, xgl, xfx, svgafx,
+openstep oder SDL.</CODE> <P>Fr XMess natrlich einfach XMame durch XMess
+ersetzen ;-)<H3>Spiele Configuration</H3>
+
+<P>Die Dateien zur Spiele-Konfiguration werden benutzerabhngig	abgelegt in:
+<PRE>
+    ${HOME}/.xmame/cfg/&lt;game&gt;.cfg resp
+    ${HOME}/.xmess/cfg/&lt;game&gt;.cfg
+</PRE>
+<H3>Game Status</H3>
+
+<P>Die Dateien zum Spielestatus werden userabhngig abgelegt in:
+<PRE>
+    ${HOME}/.xmame/sta/&lt;game&gt;.sta resp
+    ${HOME}/.xmess/sta/&lt;game&gt;.sta
+</PRE>
+<H3>NVram</H3>
+
+<P>NVram Dateien werden benutzerabhngig gespeichert unter:
+<PRE>
+    ${HOME}/.xmame/nvram/&lt;game&gt;.nv resp
+    ${HOME}/.xmess/nvram/&lt;game&gt;.nv
+</PRE>
+<H3>Memory Cards</H3>
+
+<P>Memory Cards werden benutzerabhngig gespeichert in
+<PRE>
+    ${HOME}/.xmame/mem/&lt;filename&gt;.mem resp
+    ${HOME}/.xmess/mem/&lt;filename&gt;.mem
+</PRE>
+<P>Wobei &lt;filename&gt; durch den Spieletreiber vorgegeben ist. 
+<H3>Screenshots</H3>
+
+<P>Screenshots knnen erzeugt werden durch Drcken von F12 und werden	im PNG-Format im aktuellen Arbeitsverzeichnis gespeichert (cwd), also	das Verzeichnis, von dem aus XMame/XMess aufgerufen wurde.
+<P>Dies kann abgendert werden durch den Eintrag screenshotdir in	xmamerc/xmessrc.
+<P>Dies kann wiederum abgendert werden durch die Kommandozeilen-Option <CODE>-screenshotdir</CODE>.&nbsp;
+<P> Die Bilder werden gespeichert als:<PRE>
+    &lt;screenshotdir&gt;/&lt;game&gt;xxxx.png
+    Dabei ist xxxx eine Zahl.
+</PRE>
+<H3>Highscores</H3>
+
+<P>Die Highscores werden gespeichert in XMAMEROOT, definiert	im Makefile beim Compilieren. Dieses Spooldirectory	kann berschrieben werden durch den
+Eintrag in xmamerc bzw.	xmessrc. Dieser Eintrag kann wiederum berschrieben werden	durch die Kommandozeilen-Option <CODE>-spooldir</CODE>.<P>Somit einfach die Berechtigung des Spoolverzeichnisses	setzen
+auf
+<PRE>
+    drwxrwsr-x root games &lt;spooldir&gt;
+</PRE>
+<P> mittels chown.	Dann noch ein setgid xmame/xmess auf game und schon&nbsp; funktioniert es. (Bei Verstndnisproblemen die Manpage	von chown und setgid lesen !!!!)
+<P>Man kann auch die Group-ID bei xmame/xmess mittels	chgrp game xmame.x11 (fr die X11-Version) setzen.	Dies funktioniert aber NICHT bei der SVGAlib
+und&nbsp; XF86-DGA Version. Diese bentigen suid root !!
+Verbesserungsvorschlge willkommen.<br>
+<br>
+	Fr diese Versionen einfach ${HOME}/.xmame oder	${HOME}/.xmess als spooldir in xmamerc/xmessrc angeben.<br>
+<br>
+Anmerkung: Damit Hiscores funktionieren, muss XMame natrlich	die Datei hiscore.dat finden knnen.<H3><br>
+hiscore.dat</H3>
+
+<P>Wenn Du die Hiscores nutzen willst, dann muss XMame die Datei	hiscore.dat laden knnen, um an die Informationen heranzukommen.<br>
+<br>
+	Der Standard ist hierbei <CODE>XMAMEROOT</CODE>/hiscore.dat . XMAMEROOT wird	whrend des Compilieren gesetzt, siehe hierzu im Makefile.	Dies kann neu gesetzt werden durch den Eintrag hiscorefile in der	Datei xmamerc, falls vorhanden. Dies kann natrlich auch wieder	neu gesetzt werden durch die
+Kommandozeilen-Option <CODE>-hiscorefile </CODE>	beim Start von XMame.<br>
+<br>
+Die Datei <CODE>hiscore.dat</CODE>  ist verfgbar auf der Mame-Homepage: <a href="http://www.mame.net">	http://www.mame.net</a>
+<H3><br>
+cheat.dat</H3>
+
+<P>Wenn Cheats benutzt werden sollen, dann mu Mame die Datei cheat.dat laden, um die Informationen zu haben.
+<P>Voreingestellt ist XMAMEROOT/cheat.dat . XMAMEROOT wird whrend des Compilierens gesetzt, siehe Makefile.	Diese Einstellung kann berschrieben
+werden durch den	Eintrag cheatfile in xmamerc, wenn vorhanden. Wiederrum	kann dies ersetzt werden durch die Kommandozeilen-Option <CODE>-cheatfile</CODE>.<br>
+<br>
+Die Datei <CODE>cheat.dat</CODE>  ist verfgbar auf der Mame-Homepage: <a href="http://www.mame.net">http://www.mame.net</a>
+<H3><br>
+history.dat</H3>
+
+<P>Wenn Du einige nette Hintergrundinformationen zu den Spielen	willst, dann mu xmame die Datei history.dat laden.&nbsp;
+
+<P>	Voreingestellt ist XMAMEROOT/history.dat . XMAMEROOT wird	whrend des bersetzens gesetzt, siehe hierzu im Makefile.	Dies kann berschrieben werden durch den Eintrag historyfile	in der xmamerc. Dieses kann wiederrum berschrieben werden durch	den Schalter <CODE>-historyfile</CODE>
+beim Aufruf von Xmame.<br>
+<br>
+Die Datei <CODE>history.dat</CODE>  ist verfgbar auf der Mame-Homepage: <a href="http://www.mame.net">	http://www.mame.net</a>
+<H3><br>
+Aufzeichnen der Eingaben (Input Logs)</H3>
+
+<P>Aufzeichnungen von den Eingaben werden unter dem Dateinamen	gespeichert, der hinter den Schaltern
+<CODE>-record / -playback</CODE>  angegeben wird, immer relativ zum aktuellen Pfad.<br>
+<H3>XMame/XMess findet immer noch nicht Dateien / Highscores werden nicht
+gespeichert</H3>
+
+<P> <CODE>&quot;xmame/xmess -showconfig | more&quot;</CODE>  eintippen und prfen, ob	der angezeigte Pfad zu den Roms und der Pfad zum spooldir
+korrekt ist und ob dort auch die Berechtigung zum Lesen und Schreiben vorhanden ist.	Andererseits noch einmal xmamerc/xmessrc prfen.&nbsp;<br>
+	Und nicht vergessen, xmess durchsucht auch das aktuelle	Verzeichnis.<br>
+<H2><A NAME="ss3.10">3.10 Wie starte ich XMame/XMess ?</A>
+</H2>
+
+<P>Um XMame zu starten:<PRE>
+    xmame [Optionen] &lt;gamename&gt; [weitere Optionen]
+</PRE>
+<P>Fr XMess:<PRE>
+    xmess [Optionen] &lt;systemname&gt; [weitere Optionen] \
+    &lt;disk/romimage(s)&gt; [weitere Optionen]
+</PRE>
+<P>Alle Optionen sind sozusagen optional ;-))<P><br>
+	Xmame/Xmess untersttzt die meisten Kommandozeilenoptionen der MSDOS-Version	(nheres siehe in readme.mame /
+readme.mess) und natrlich ein paar eigene. Tippe xmame -help | more fr die
+komplette Liste ein.<br>
+<br>
+Bei Xmess bentigen einige Systeme nicht disk/romimage,	die meisten jedoch schon.<br>
+<H2><A NAME="ss3.11">3.11 Was sind die Kommandozeilen Parameter fr XMame/XMess?</A>
+</H2>
+
+<P>Fr eine Liste der verfgbaren Parameter einfach
+<PRE>
+    /usr/games/xmame -help | more
+</PRE>
+<P> eintippen	(falls xmame in /usr/games zu finden ist)<br>
+<br>
+	Xmame/Xmess untersttzt die meisten Parameter der	MSDOS-Version und natrlich ein paar eigene.<br>
+<br>
+	In der Datei readme.mame / readme.mess ist mehr ber die	Parameter nachzulesen.<br>
+<H2><A NAME="ss3.12">3.12 Welche Tasten benutzen XMame/XMess use?</A>
+</H2>
+
+<P>Xmame/Xmess benutzen die selben Tasten wie die DOS-Version: die folgenden
+Tasten funktionieren in allen Emulatoren:<PRE>
+    `  oder ~    Einstieg in das OnScreen Display fr Lautstrkenderungen, 
+                 Helligkeitsregelung, ...
+    Tab          Einstieg ins Configurationsmen. Tab oder ESC drcken, um zurck 
+                 zur Emulation zu gelangen
+    P            Pause
+    F3           Reset
+    F4           Zeigt die Spielegrafik an. Mit den Cursor Tasten knnen die Farben 
+                 gendert werden. 
+                 F4 oder Esc um zurck zu kommen.
+    F8           Frame Skip reduzieren (Bilder auslassen)
+    F9           Frame Skip erhhen
+    F10          Throttle an oder aus
+    F10 + shift  Idle Sleeping an oder aus
+    F11          Anzeige der Frames an oder aus
+    F11 + shift  Profiler Anzeige an oder aus
+    F12          Bildschirminhalt speichern (snapshot)
+    ESC          Emulator verlassen.
+</PRE>
+<P>XMame hat zwei verschiedene Algorithmen fr auto frameskipping,	diese knnen mit der Option -frameskipper ausgewhlt werden,	und mit folgenden Tatenkombinationen:<PRE>
+    Tastenkombination:     Wirkung:
+    STRG-Links + Einfgen  Standard DOS Frameskipper
+    STRG-Linux + POS1      Frameskipper William Barath
+</PRE>
+<P>Die Anzeigeskalierung von XMame kann im laufenden Betrieb mit folgenden
+Tastenkombinationen gendert werden:<PRE>
+    Tastenkombination:     Ergebnis:
+    SHIFT-Links + Einfg    Breite erhhen
+    SHIFT-Links + Entf     Breite verringern
+    SHIFT-Links + Pos1     Hhe vergrern
+    SHIFT-Links + Ende     Hhe verringern
+    SHIFT-Links + Bild auf Anzeige vergrern
+    SHIFT-Links + Bild ab  Anzeige verkleinern
+</PRE>
+<P>Unter X11 kann XMame zwischen verschiedenen Anzeigemodi	whrend "des laufenden Betriebes" wechseln:<PRE>
+    Tastenkombination:     Bringt Dich zu:
+    ALT-Links + Einfg      Normales Fenster
+    ALT-Links + Pos1       DGA Fullscreen Modus
+</PRE>
+<P>Unter SDL kann XMame zwischen den verschienden Modi zur Laufzeit wechseln:<PRE>
+    Tastenkombination:     Ergebnis:
+    ALT-Links + Return     Schaltet zwischen Fenster- und Fullscreenmodus um
+</PRE>
+<P>Unter X11 in einem Fenster kann man nun auch die Maus	aktivieren, um sie zum Spielen
+benutzen zu knnen.	Drcke dazu Alt-Links und Bild-Ab um die Maus
+zu aktivieren	und drcke die Tastenkombination nochmals, um die Maus	wieder zu deaktivieren.<br>
+<H2><A NAME="ss3.13">3.13 Warum haben manche Spiele keinen Sound ?</A>
+</H2>
+
+<UL>
+<LI>Zuerst einmal prfen, ob Sounduntersttzung berhaupt	  funktioniert.</LI>
+<LI>Prfen, ob das gewnschte Spiel berhaupt Sounduntersttzung bietet. Nicht alle Spiele haben derzeit Sound.</LI>
+<LI>Bei Xmame einen Blick in gameslist.mame werfen. Wird	  Sound fr das Spiel emuliert ?</LI>
+<LI>Bei Xmess einen Blick in readme.mess werfen, ob fr das	  System Sound berhaupt emuliert wird.</LI>
+<LI>Prfen, ob Xmame/Xmess auf dem verwendeten System	  berhaupt Sounduntersttzung bietet. Siehe dazu weiter
+	  oben in den FAQ's.<br>
+</LI>
+</UL>
+<H2><A NAME="ss3.14">3.14 Meine Soundausgabe ist verzgert / ist abgehackt. / Was
+bewirkt -bufsize</A>?</H2>
+
+<P>Mit dem Parameter <CODE>-bufsize</CODE>  (als Kommandozeilen-Option) oder	als Schlsselwort in der Konfigurationdatei (xmamerc) kann	man die Anzahl Frames von Audio zum Buffer angeben. Die	Grundeinstellung ist 2 frames.
+<P>Dieser Wert sollte bei Jedem passen, aber wenn immer noch	Probleme auftreten, dann weiterlesen.
+<P>Wenn die Buffergre zu klein ist, dann wird der Buffer gezwungen, sich zwischen den Frames zu Leeren, was dann zu	verzgerter Soundausgabe oder zu
+abgehacktem Sound fhren kann. In diesem Fall kann das Erhhen des Wertes der
+Buffergre auf beispielsweise 2.5 helfen.
+<P>Wenn jedoch die Buffergre zu gross ist, dann werden so	viele Audiodaten gepuffert, dass die Soundausgabe verzgert	klingt. Z.B. ist das Einwerfen einer
+Mnze erst nach 0.5	Sekunden zu Hren, nachdem die Taste "Insert Coin" gedrckt	wurde. In diesem Fall verringere den Werte bei der
+Buffergre auf beispielsweise 1.5.<P>Bitte lasst mich wissen, wenn ein ndern dieser Werte
+notwendig ist, weil es geplant ist diesen Parameter in einer zuknftigen	Version von XMame wieder zu
+entfernen.<br>
+<H2><A NAME="FAQ: Why doesn't a game work?"></A>  <A NAME="ss3.15">3.15 Warum
+funktioniert ein Spiel nicht ? </A>
+</H2>
+
+<UL>
+<LI>Sind die richtigen Roms vorhanden oder treten beim	  Starten Prfsummenfehler auf ?</LI>
+<LI>Xmame Version 0.34 und hher bentigt PROM-Dateien, die	  nicht in den ROM-Files enthalten sind vor der	  Version 0.34. Siehe auch
+  die nchste Frage&nbsp; ber	  PROMs.</LI>
+<li>Bei Xmame in der Datei gamelist.mame nachsehen, ob das	  Spiel berhaupt spielbar ist. Wenn ein Spiel in der	  Liste enthalten ist bedeutet es nicht
+  automatisch, da es	  schon spielbar ist.</li>
+<li>Bei Xmess in der Datei readme.mess nachsehen. Vielleicht wird das System noch nicht komplett emuliert.</li>
+<li>Einige Spiele bentigen Sounduntersttzung. Wenn bei	  Deinem Unix-System keine Sounduntersttzung vorhanden ist	  oder Xmame/Xmess dafr keine Sounduntersttzung bietet,	  dann den Parameter <CODE>-fakesound</CODE> 
+  benutzen.</li>
+</UL>
+&nbsp;
+<H2><A NAME="FAQ: What are PROMs?"></A>  <A NAME="ss3.16">3.16 Was sind PROMs? </A>
+</H2>
+
+<P>PROMs enthalten spezielle Informationen fr Spiele. Diese	waren in Mame-Versionen &lt; 0.34 in Mame selbst enthalten.	Diese Informationen wurden wieder aus Mame entfernt und sind	in den neueren Versionen der ROM-Files, die so etwas	bentigen, schon enthalten.<P>Wenn
+Du Deine vorhandenen ROMs nutzen willst, dann knnen die PROMs in einer
+einzigen Datei gefunden werden unter:&nbsp;<P>
+<A HREF="http://mame.retrogames.com/">http://mame.retrogames.com/</A><P>
+<H2><A NAME="ss3.17">3.17 Warum sind XMame/XMess so langsam ?</A>
+</H2>
+
+<P>Xmame/Xmess ist ein bersetztes C-Programm, dass Hardware	emuliert. Software, die Hardware emuliert, ist nun mal nicht	so schnell.
+Hier sind nun einige Tipps fr hhere Geschwindigkeit:
+<UL>
+<LI>den Parameter -frameskip benutzen</LI>
+<LI>whrend des Spieles F8 drcken, um die Framerate zu erhhen</LI>
+<LI>throttle abschalten durch den Parameter -nothrottle oder durch drcken von F10 whrend Xmame/Xmess schon luft.</LI>
+<LI>wenn Xmame/Xmess luft, dann F11 drcken um die aktuelle	  Geschwindigkeit von Xmame/Xmess zu prfen.Wenn niemals 100% auftauchen, dann mu wohl ein schnellerer	Computer her.</LI>
+</UL>
+<P>Du kannst natrlich auch versuchen, XMame/XMess mit mehr optimierten	Einstellungen neu zu bersetzen. Die folgenden Ratschlge knnen	nicht funktionieren oder knnen auf einigen Maschinen oder einigen	Installationen nicht mglich sein. Natrlich kann, in den Fllen wo	es funktioniert, eine
+merklich bessere Performance bei XMame/XMess eintreten.<br>
+<br>
+Um diese "Verbesserungen" einsetzen zu knnen, muss nur die Datei	Makefile editiert werden. Diese Datei ist bei XMame mit dabei.	Anschlieend muss der Sourcecode neu bersetzt werden. Wenn der	Sourdecode zum zweiten mal bersetzt wird, dann muss nach dem	Editieren von makefile.unix
+<PRE>
+    make clean
+    make
+    make install
+</PRE>
+<P>ausgefhrt werden, um die neuen Einstellungen zu aktivieren.<br>
+<H3>SPEEDUP # 1 - Compilieren mit Inline</H3>
+
+<p>Versuche beim bersetzen inline zu aktivieren und entferne/fge den Kommentar bei diesen beiden Zeilen hinzu:</p>
+<PRE>
+    # IL    = '-DINLINE=static inline'
+    IL     = -DINLINE=static
+</PRE>
+<H3>SPEEDUP # 2 - Direct Graphics Access (DGA)</H3>
+
+<P>Fr einen gehrigen "Schub" versuche DGA zu aktivieren und entferne	den Kommentar bei folgender Zeile
+<PRE>
+    DGA = 1
+</PRE>
+<P>Starte dann XMame als Benutzer root und drcke "CursorLinks-ALT-EINFG"&nbsp;
+um in den DGA-Modus zu wechseln. Dies sollte um Einiges schneller sein
+	und bentigt/nutzt nicht xsync ;-)<br>
+<br>
+Um in den Fenstermodus zurckzukommen ohne das Spiel zu verlassen drcke
+ALT-Links + Einfg.
+<P>Der Vorteil von DGA ist, dass es Direct Grafics Access ist und somit	direkt in den Framebuffer schreibt (Denke an DircetX und GDI unter&nbsp;
+Windows). So sollte es einen Tick schneller sein, unabhngig davon, ob	Du einen wirklichen guten beschleunigten X-Server hast, was genauso	schnell sein knnte. Drcke F11 um die aktuelle Framerate anzuzeigen,	obwohl es meist schwer festzustellen ist (meist nur wahrnehmbar), es	sollte doch eine kleine Geschwindigkeitserhhung vorhanden sein.<br>
+<br>
+Nebenbei schaltet DGA automatisch in den richtigen Modus entfernt	jeglichen "Mll" der Fenstermanager, aber das kann auch ohne DGA	erreicht werden (es wird ein solches Feature mglicherweise spter	geben, weil es ganz leicht Fullscreen erlaubt, ohne dass man dazu	root sein muss).<br>
+<br>
+Fge den Modus 320x240 hinzu, der eine nette Fullscreen-Anzeige beim Scaling scale = 1 mglich macht ;-)<br>
+<br>
+Nicht vergessen, dass noch die Mode-Lines in der Section "Display"	bei "Screen" Deiner X-Config Datei gesetzt werden mssen um im DGA-Modus
+bildschirmfllend darzustellen. XMame sucht sich den besten	Modus heraus, den es finden kann. Du wirst also eine Zeile wie&nbsp;
+<PRE>
+    Modes  &quot;1024x768&quot; &quot;800x600&quot; &quot;640x480&quot; &quot;320x240&quot; &quot;256x224&quot;
+</PRE>
+<P>haben, denn jedes Spiel, das in eine 320x240-Auflsung passt	kann in dieser Auflsung dargestellt werden, usw. Nicht vergessen,	dass die X-Config Datei mehrere Stellen mit dem Namen "Screen" haben	kann. Die Modi mssen dann natrlich bei der Stelle editiert werden,	die der X-Server beim Start benutzt. Es ist natrlich nicht ganz so	einfach, da man X auch noch mitteilen muss, welche Monitoreinstellungen	fr diese Auflsungen bentigt werden. Dies geschieht in den Modeline-Eintrgen im Bereich "Monitor" der X-Config Datei.<br>
+<br>
+Siehe auch in <CODE>/contrib/tools/modelines</CODE>  fr einen Satz verckter
+Modi,        speziell fr XMame in DGA. Sie sollten auf jedem beliebigen
+Multisync Monitor funktionieren, aber benutze sie NICHT auf einem alten        Festfrequenz Monitor (gut, wenn Du es nicht lassen kannst es trotzdem        zu versuchen, ich werden NICHT fr einen neuen Monitor zahlen)&nbsp;<br>
+<H3>SPEEDUP # 3 - NASM</H3>
+
+<P>Du kannst auch versuchen, nasm zu installieren und XMame/XMess mit	ASM-Core zu bersetzen, dies hilft auch ein wenig.<br>
+	(Bemerkung fr SuSE-Besitzer: das Paket nasm-09x befindet sich in der Serie d)<br>
+<H2><A NAME="ss3.18">3.18 Ich habe eine Dual Prozessor Maschine. Wie kann ich
+davon profitieren ?</A></H2>
+
+<P>Eigentlich wenig. XMame ist eine Portierung von DOS und ist nur designed fr
+Single-Thread. Ein klein wenig schneller knnte XMame auf einer SMP-Maschine
+schon laufen, weil XMame dann lnger eine CPU fr sich hat. Aber das passiert
+mit allen CPU-intensiven Programmen. Und alles was man einstellt, dass eine
+Applikation mehr CPU-Zeit bekommt (hhere Prioritt, killen unntiger
+Prozesse, ...) funktioniert auch bei XMame.<br>
+<br>
+Nun knnte man an dieser Stelle denken, &quot;Sicherlich knnte man einen
+Thread haben fr die Emulation und einen anderen zur Beschleunigung der
+grafischen Ausgabe&quot;. Ja, aber da sind einige ernsthafte Einschrnkungen zu
+beachten. Die erste ist die Synchronisation zwischen den Threads, die aber
+bentigt wird damit alles reibungslos luft. Wenn das nicht glatt luft, dann
+frisst der Overhead jeglichen Vorteil wieder auf. Ausserdem muss das Ganze als
+portables Thread Interface implementiert werden. Das bedeutet POSIX Threads. Es
+ist somit erheblicher Aufwand fr fast keinen Effekt. Aber wenn Du der Meinung
+bist, sowas zu implementieren, dann sind Patches dazu in der XMame Mailingliste
+natrlich herzlich willkommen ... ;-)<P>&nbsp;<H2><A NAME="ss3.19">3.19 Warum
+funktionieren bei meinem Joystick die diagonalen Bewegenungen nicht richtig ? </A>(nur
+Intel x86 System)</H2>
+
+<P>Xmame/Xmess benutzt automatische Kalibrierung. Aber man kann spezielle Programme zum Kalibrieren benutzen. (jscal - beim	Joystick-Module dabei - funktioniert ausgezeichnet ...)<P>Anmerkung:
+Ab Kernel 2.4.x braucht man jscal 2.0.0. Dies findet man auf <a href="http://www.suse.cz">http://www.suse.cz</a>.<br>
+<br>
+<H2><A NAME="ss3.20">3.20 Wie kann ich die XinputExtensions fr auf X11
+basierende Joysticks in Xfree86 aktivieren ?<br>
+</A>
+</H2>
+
+<P>Die XF86Config mu editiert werden, um die XInput-Sektion zu	aktivieren. Nheres bietet die Manpage von XF86Config.<br>
+<br>
+<H2><A NAME="ss3.21">3.21 Wie lese ich eine Manual Page ?</A>
+</H2>
+
+<P>Echt einfach. Um beispielsweise die Manpage von XF86Config zu lesen, einfach man XF86Config eintippen. ;)<br>
+<H2><A NAME="FAQ: Why do I get gz_open symbol not found while compiling?"></A>  <A NAME="ss3.22">3.22
+Warum bekomme ich &quot;get gz_open symbol not found&quot; beim bersetzen ? </A>
+</H2>
+
+<P>XMame/XMess-Versionen neuer als 0.35 benutzen zlib fr einige	Packroutinen. Leider haben viele Linux Distributionen eine	veraltete Version von zlib installiert unter	/usr/X11R6/lib/libz.a und die neue Version installiert unter	/usr/lib/libz.a. Wenn dies bei Dir der Fall ist, dann kann	problemlos die Version unter
+/usr/X11R6/lib/libz.a gelscht	werden. Wenn Du Dir da nicht sicher bist, verschiebe einfach	/usr/X11R6/lib/libz.a an eine andere Stelle.<br>
+<br>
+Lschen oder nur Verschieben von /usr/X11R6/lib/libz.a sollte	dieses Problem beheben.<br>
+<br>
+Sieh auch: <A HREF="#FAQ: Why do I get zlib.h not found?">FAQ: Warum bekomme ich
+&quot;get zlib.h not found&quot; ?</A><P>
+<H2><A NAME="FAQ: Why do I get zlib.h not found?"></A>  <A NAME="ss3.23">3.23 Warum
+bekomme ich &quot;get zlib.h not found&quot; ? </A>
+</H2>
+
+<P>XMame/XMess-Versionen neuer als 0.35 benutzen zlib fr einige	Packroutinen.<br>
+<br>
+Zlib ist Standard auf den meisten Unix-Systemen. Fr Leute, die sich nicht mit zlib herumrgern wolle, oder keine veraltete Version	haben wollen, ist nun bei XMame/XMess eine abgespeckte Version von	zlib mit dabei. Entferne die Kommentare bei der betreffenden	Stelle im Makefile um dies zu benutzen.<br>
+<br>
+<H2><A NAME="ss3.24">3.24 Wenn ich xmame.x11 starte, passiert nichts --- kein
+Fenster geht auf oder irgendwas anderes. Hilfe !</A>
+</H2>
+
+<P>Luft bei Dir eine aktuelle Version von KDE, z.B. 2.1.1 ? Im KDE
+Fenstermanager ist vermutlich ein Fehler, der bei einigen X11-Anwendungen
+verhindert, dass deren Hauptfenster aufgeht. Du kannst entweder die SDL-Version
+von XMame nehmen, oder folgenden Workaround probieren, der bei etlichen Leuten
+funktioniert hat:<P><font face="Courier">xmame.x11 -rid `xwininfo -root | grep xwininfo: | awk '{print $4}'`<br>
+</font><br>
+Update: Es wurde uns mitgeteilt, dass seit KDE 2.2b1 dieser Fehler nicht mehr
+auftritt.<br>
+<H2><a NAME="ss3.25">3.25 Wo bekomme ich die neueste Version von XMame/XMess her
+?</a>
+</H2>
+
+<P>Auf der Xmame/Xmess-Homepage ist immer die aktuellste	Version verfgbar.&nbsp;<br>
+<br>
+	Adresse: <a href="http://x.mame.net"> http://x.mame.net</a><br>
+<br>
+	Auf meiner Homepage ist ebenfalls der Sourcecode	verfgbar (Ausweichadresse, falls x.mame.net berlastet	ist).&nbsp;<br>
+<br>
+	Adresse: <a href="http://www.bingo-ev.de/~rh474"> http://www.bingo-ev.de/~rh474</a><br>
+<br>
+<H2><a NAME="ss3.26">3.26 Wohin kann ich Korrekturen, Fehlermeldungen,
+Anmerkungen, Geld :-) hinschicken ?</a>
+</H2>
+
+<P>Siehe <A HREF="xmame-gdoc-5.html#Mail">Mail</A>
+ in diesem Dokument.<br>
+<H2><a NAME="ss3.27">3.27 Was kann ich tun, wenn meine Frage immer noch nicht
+beantwortet ist ?</a>
+</H2>
+
+<P>Bitte prfe die offiziellen Readme's von Mame und Mess. Vielleicht ist Deine
+Frage dort schon beantwortet:<br>
+<UL>
+<LI>
+<A HREF="readme.mame">Das offizielle Mame Readme (readme.mame)</A>
+</LI>
+<LI>
+<A HREF="readme.mess">Das offizielleMess Readme (readme.mess)</A>
+</LI>
+</UL>
+<P>Wenn das auch nicht weiterhilft, dann stelle doch Deine Frage in der Mailing
+Liste oder schicke eine Mail an den XMame/XMess Koordinator. Siehe dazu
+unter&nbsp;<br>
+<A HREF="xmame-gdoc-5.html#Mail">Mail</A>
+ fr mehr Information.
+<HR>
+<A HREF="xmame-gdoc-4.html">Weiter</A> <A HREF="xmame-gdoc-2.html">Zurck</A> <A HREF="xmame-gdoc.html#toc3">Inhalt</A>
+</BODY>
+</HTML>
diff --git a/src/unix/doc/xmame-gdoc-4.html b/src/unix/doc/xmame-gdoc-4.html
new file mode 100644
index 0000000..8a42dfc
--- /dev/null
+++ b/src/unix/doc/xmame-gdoc-4.html
@@ -0,0 +1,484 @@
+<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
+<HTML>
+<HEAD>
+ <META NAME="GENERATOR" CONTENT="Microsoft FrontPage 4.0">
+ <TITLE>XMAME/XMESS DOKUMENTATION: Kommentare und Anmerkungen zu speziellen
+ Anzeigearten </TITLE>
+ <LINK HREF="xmame-gdoc-5.html" REL=next>
+ <LINK HREF="xmame-gdoc-3.html" REL=previous>
+ <LINK HREF="xmame-gdoc.html#toc4" REL=contents>
+ <link rel="stylesheet" href="xmame.css" type="text/css" >
+</HEAD>
+<BODY BACKGROUND="img/xmame.jpg" BGPROPERTIES="fixed" >
+<A HREF="xmame-gdoc-5.html">Weiter</A> <A HREF="xmame-gdoc-3.html">Zurck</A> <A HREF="xmame-gdoc.html#toc4">Inhalt</A>
+<HR>
+<H2><A NAME="Display subsystem specific comments and notes"></A>  <A NAME="s4">4.
+Kommentare und Anmerkungen zu speziellen Anzeigearten</A></H2>
+
+<H2><A NAME="ss4.1">4.1 FXMame, ein Glide Treiber fr XMame</A>
+</H2>
+
+<P>Die neueste Version diese Treibers kann bei 
+<A HREF="http://glmame.linuxgames.com">http://glmame.linuxgames.com</A>
+ gefunden werden.<H3>Voraussetzungen</H3>
+
+<P>Um FXMame zum Laufen zu bekommen muss folgendes vorhanden sein:<br>
+<UL>
+<LI>eine 3Dfx Karte</LI>
+<LI>Glide 2x</LI>
+<LI>der XMame Sourcecode</LI>
+</UL>
+<H3>bersetzen und Installieren</H3>
+
+<P>FXMame kommt in zwei &quot;Geschmacksrichtungen&quot;: xfx unf svgafx. Die
+xfx-Version luft unter X11. Es nutzt ein X-Fenster fr die Eingabe. Die
+svgafx-Vesion kann von der Konsole aus gestartet werden und nutzt die SVGAlib
+zur Eingabe. Beide nutzen die 3Dfx-Hardware zum Rendern.<br>
+<P>Um FXMame zu installieren folge der allgemeinen Anleitung von XMame. Um den
+Glide Treiber zuzuweisen, ndere folgendes im Makefile:
+<UL>
+<LI>whle entweder &quot;xfx&quot; oder &quot;svgafx&quot; als Anzeigeart (display
+method)</LI>
+<LI>konfiguriere die Glide Variablen entsprechend Deiner Glide Installation</LI>
+</UL>
+<P>Die ausfhrbaren Dateien von FXMame heissen &quot;xmame.xfx&quot; und
+&quot;xmame.svgafx&quot;.<br>
+<H3>Starten</H3>
+
+<P>FXMame startet mit den selben Parametern und nutzt die selben
+Tastaturkommandos wie xmame.x11.<br>
+<br>
+Einige neue Tastaturkommandos wurden fr den Glidetreiber hinzugefgt:
+<UL>
+<LI>STRG-Rechts + A -- aktivieren von Antialiasing in Vector Spielen </LI>
+<LI>STRG-Rechts + B -- aktivieren der bilinearen Filterung</LI>
+</UL>
+<P>Der Glide Treiber fgt auch einige Kommandozeilen Optionen hinzu:<PRE>
+    -fxgama &lt;Wert&gt; Wert der 3Dfx Gamma Korrekur
+</PRE>
+<P>Bitte beachten, dass&nbsp;ich, um die fps in Vector Spielen anzeigen zu
+knnen, die Spielebitmap ber die Vectoranzeige legen musste. Dies geschah,
+weil ich die Bitmap in Vector Spielen umgehen musste. Das Zeichnen der Bitmap
+belastet die CPU enorm, deshalb bricht die Geschwindigkeit der Spiele beim
+Anzeigen der fps ein. (Ich weiss, nicht gerade ideal, aber wenn Du die Framerate
+rausfinden willst ....).<br>
+<H3>Allgemeine Fragen (FAQ)</H3>
+
+<P>Q: Wenn ich FXMame starte bekomme ich einen Core Dump.<P>A: Bitte
+sicherstellen, dass FXame als root gestartet wird. Root-Rechte werden fr den
+Zugriff auf 3Dfx-Hardware bentigt.<P>Q: Wenn ich xmame.xfx starte, dann hngt
+das Spiel beim Initialisieren.<P>A: Luft gerade KDE ? Manchmal funktioniert
+dann die Tastatur unter KDE nicht. Wenn Du dieses Problem hast, dann wechsle den
+Fenstermanager oder benutze stattdessen xmame.svgafx.<H3>Aktuelle
+Einschrnkungen/Bugs</H3>
+
+<UL>
+<LI>Antialiasing funktioniert nicht so gut wie es sollte</LI>
+<LI>Eingabeprobleme unter KDE</LI>
+</UL>
+<H3>Zuknftige Neuerungen&nbsp;</H3>
+
+<UL>
+<LI>Optimierung des Codes zum Zeichnen, damit nur die Teile der Bitmap neu
+  gezeichnet werden, die sich gendert haben.</LI>
+</UL>
+<H3>Lizenz</H3>
+
+<P>Der Code von FXMame steht unter dem Copyright (1998) von Mike Oliphant. Es kann
+benutzt und weitergegeben werden unter den selben Bedingungen wie in der MAME
+Lizenz beschrieben.<H3>Version History (im englischen Original)</H3>
+
+<P>v0.5 -- December 11th, 1998 ---------------------------
+<UL>
+<LI>implemented long copies in screen update</LI>
+<LI>added dirty handling. this greatly increases the speed of games
+that support the dirty update strategy (although most of them are
+older games that already ran at full speed on modern hardware)</LI>
+<LI>merged source with xmame b8.1</LI>
+</UL>
+<P>v0.4 -- October 30th, 1998 --------------------------
+<UL>
+<LI>improved alpha handling in vector games - now bitmapped overlays
+do not dim the screen o added svgalib support (xmame.svgafx) o fixed
+a tiling bug that gave artifacts on texture tile boundaries</LI>
+</UL>
+<P>v0.3 -- October 29th, 1998 --------------------------
+<UL>
+<LI>got rid of extra lines in vector games o added bitmap overlay
+in vector games to show options/fps o added antialiasing in vector
+games</LI>
+</UL>
+<P>v0.2 -- October 28th, 1998 --------------------------
+<UL>
+<LI>added screenshots o added 3Dfx gamma adjustment o added direct
+acceleration of vector games (still buggy)</LI>
+</UL>
+<P>v0.1 -- October 27th, 1998 --------------------------
+<UL>
+<LI>first public release</LI>
+</UL>
+<H3>Author</H3>
+
+<P>Mike Oliphant <CODE>
+<A HREF="mailto:oliphant@ling.ed.ac.uk">(oliphant@ling.ed.ac.uk)</A></CODE> 
+<A HREF="http://glmame.linuxgames.com">http://glmame.linuxgames.com</A><P>
+<H2><A NAME="ss4.2">4.2 GLMame, ein OPENGL Treiber fr XMame</A>
+</H2>
+
+<P>Die neueste Version dieses Treibers kann unter <a HREF="http://www.jausoft.com/glmame.html">http://www.jausoft.com/glmame.html</a>
+gefunden werden.<H3>Voraussetzungen</H3>
+
+<P>Fr GLMame ist folgendes notwendig:&nbsp;
+<UL>
+<LI>Ein OpenGL Treiber</LI>
+<LI>libjpeg</LI>
+<LI>Hardware 3D-Beschleunigung (wenn berhaupt eine vernnftige Framerate
+  rauskommen soll)</LI>
+<LI>der Source-Code von XMame</LI>
+</UL>
+<H3>bersetzen und Installieren</H3>
+
+<P>Die allgemeinen Anweisungen zur Installation von XMame beachten. Um den OpenGL
+Treiber zu verwenden muss folgendes im Makefile gendert werden:
+<UL>
+<LI>Whle &quot;xgl&quot; als Anzeigeart aus</LI>
+<LI>Fr Debug-Informationen zur Laufzeit, fge &quot;-DGLDEBUG&quot; zur
+  Variablen &quot;GLCFLAGS&quot; hinzu.</LI>
+<LI>GLU version 1.2 is recommended (e.g., from SGI). If you use Mesa's GLU, you may have to add " -DGLU_VERSION_1_2" to the " GLCFLAGS".</LI>
+<LI>GLU Version 1.2 wird bentigt (z.B. von SGI). Wenn Du Mesa-GLU benutzt,
+  dann muss ggf. " -DGLU_VERSION_1_2" bei der Variablen &quot;GLCFLAGS&quot;
+  hinzugefgt werden.</LI>
+</UL>
+<P>Die ausfhrbare Datei von GLMame heisst &quot;xmame.xgl&quot;<H3>Starten</H3>
+
+<P>xmame.xgl startet mit den selben Parametern und nutzt die selben
+Tastaturkommandos wie xmame.x11.<P>Das Programm startet im Cabinet-Modus. Weil
+es auch nett und recht &quot;cool&quot; ist, willst Du sicher von nun an im
+Fullscreen-Modus spielen.<P>
+Einige neue Tastaturkommandos wurden fr den OpenGL-Treiber hinzugefgt:
+<UL>
+<LI>ALT-Rechts + A -- Antialias Filtern ein-/ausschalten (Vektorspiele)</LI>
+<LI>ALT-Rechts + B -- Bilineares Filtern ein-/ausschalten (Rasterspiele)</LI>
+<LI>ALT-Rechts + C -- Cabinet/Fullscreen ein-/ausschalten (Beide)</LI>
+<LI>ALT-Rechts + F -- Vollbild/Startgre ein-/ausschalten (Beide)</LI>
+<LI>ALT-Rechts + O -- Draw Bitmap ein-/ausschalten (Beide, macht aber bei
+  Rasterspielen keinen Sinn, beschleunigt Vektorspiele)</LI>
+<LI>ALT-Rechts + T -- nachleuchtende Spuren ein-/ausschalten (Vektorspiele)</LI>
+<LI>ALT-Rechts + + -- Lichtstrke erhhen (Vektorspiele)</LI>
+<LI>ALT-Rechts + -&nbsp; -- Lichtstrke verringern (Vektorspiele)</LI>
+</UL>
+<P>Der OpenGL-Treiber bringt auch einige Kommandozeilen-Optionen hinzu:<PRE>    -[no]fullscreen         Starten im Vollbildmodus
+			    (default: abgeschaltet)</PRE>
+<PRE>    -[no]gldblbuffer        Doppeltes Puffern ein-/ausschalten
+                            (default: aktiviert)
+
+    -gltexture_size &lt;int&gt;   die maximale Breite und Hhe eines Texturensegments                            
+			    erzwingen (default: autosize)
+
+    -[no]glforceblitmode /  Bitter in Echtfarben-Modi 15/32bpp erzwingen
+    -[no]glblit             (default: aktiviert)
+
+    -[no]glext78 /          die Benutzung der GL extension number 78 erzwingen,
+    -[no]glext              falls vorhanden (paletted texture)
+                            (default: aktiviert)</PRE>
+<PRE>    -[no]glbilinear /       bilineares Filtern ein-/ausschalten
+    -[no]glbilin            (default: aktiviert)
+
+    -[no]gldrawbitmap /     zeichnen der Bitmap ein-/ausschalten;  
+    -[no]glbitmap           z.B. in Vektorspielen abschalten zur Geschwindigkeitserhhung
+                            (default: aktiviert)
+
+    -[no]glcolormod         Farbmodulation (Intensitt, Gamma) ein-/ausschalten
+    -[no]glcmod             (default: aktiviert)
+                            
+    -glbeam &lt;float&gt;         die Lichtstrke fr Vektorspiele setzen
+                            (default: 1.0)
+
+    -[no]glalphablending /  Alpha-Blendung ein-/ausschalten, falls vorhanden
+    -[no]glalpha            (default: aktiviert)
+
+    -[no]glantialias /      Antialiasing ein-/ausschalten
+    -[no]glaa               (default: aktiviert)
+
+    -gllibname /            die OpenGL-Bibliothek angeben, die dynamisch geladen werden soll
+    -gllib &lt;string&gt;         (default: libGL.so)
+
+    -glulibname /           die GLU-Bibliothek angeben, die dynamisch geladen werden soll
+    -glulib &lt;string&gt;        (default: libGLU.so)
+
+    -[no]cabview            im Cabinet Anzeigemodus starten/nicht starten
+                            (default: nicht in diesem modus starten)
+
+    -cabinet &lt;cabname&gt;      welches Cabinet Modell soll genutzt werden ?
+                            (default: glmamejau)
+ 
+   -glres &lt;string&gt;          Spiele immer skalieren auf &lt;Xres&gt;x&lt;Yres&gt;, 
+                            Seitenverhltnis beibehalten. 
+                            Dieses berschreibt die Scale-Option. 
+	 		    Dieses z.B. fr Voodoo1 Grafikkarten nutzen
+                            mit: &quot;-glres 640x480&quot;
+</PRE>
+<P>Drei Cabinet-Modelle werden mitgeliefert. Der Standard, &quot;glmamejau&quot;,
+sieht aus wie ein Standard Arcade Cabinet, wie &quot;glmame&quot;. Der Letzte, &quot;trans&quot;, ist
+mit einem transparenten Spiele-Bildschirm, durch den man durchschauen kann.<P>Bitte
+beachten, dass&nbsp; um die fps in Vector Spielen anzeigen zu knnen, die
+Spielebitmap ber die Vectoranzeige gelegt werden muss. Das Zeichnen der Bitmap
+geht bei einigen low-end hardwarebeschleunigten OpenGL-Implementationen voll auf
+die CPU. Man wird also leider bemerken, dass das Spiel beim berlagern der
+Bitmap langsamer wird.<P>Da das berlagen der Bitmap der Standard ist, kann man
+es an-/ausschalten mit &quot;STRG_ALT-O&quot; oder beim Starten abschalten mit
+der Kommandozeilenoption &quot;-noglbitmap&quot;.<P>Ein Problem von Vector
+Spielen und dem Cabinet Modus hngt mit einigen Vector Punkten zusammen, dei
+nicht innerhalb der Bildschirmkoordinaten liegen. Man wird einige Vectoren
+ausserhalb der Mame Cabinet Anzeige feststellen.<br>
+<P><B>*** WICHTIG ! ***</B>
+<P>Wenn Du Problem mit GLMame hast, oder es recht langsam ist, dann lese den
+Abschnitt &quot;Allgemeine Fragen&quot;. Viele der Fragen, die mich per Mail
+erreichen, sind damit schon beantwortet.<H3>Cabinet Modelle</H3>
+
+<P>Die Information des Cabinet-Modells ist im Verzeichnis &quot;cab&quot;
+abgelegt, defniert in der Variable ROMPATH im Makefile. Pfadangaben, die in
+xmamerc oder mit der Umgebungsvariablen &quot;rompath&quot; gesetzt sind, werden
+derzeit nicht untersttzt. Jedes Cabinet-Modell hat sein eigenes
+Unterverzeichnis. GLMame versucht zuerst jedes, vom Benutzer angegebene Modell,
+zu laden (mit der Kommandozeilen-Option -cabinet) oder ein passendes Modell zum
+benutzten Spielnamen. Wenn dies fehlschlgt, dann wird das allgemeine
+&quot;glmame&quot;-Modell herangezogen.<br>
+<br>
+<br>
+Das Verzeichnis eines Cabinet-Modells muss eine Geometrie-Datei enthalten
+&lt;modelname&gt;.cab und .jpg Dateien fr die Texturen auf dem Modell. Das
+Format der .cab Datei ist recht einfach zu begreifen, wenn man in der
+Programmierung mit OpenGL zu tun hatte. Es sieht wie eine Liste mit Anweisungen
+zur Anzeige unter OpenGL aus. Das Format ist folgendermaen:
+<PRE>
+    cabv1.1</PRE>
+<P>Dieser Header muss die ersten 7 Stellen der Datei sein.
+<PRE>
+    #&lt;text&gt;</PRE>
+<P>Kommentare beginnen mit einem '#'
+<PRE>
+    begin &lt;type&gt;</PRE>
+<P>Anfang eines Geometrie Objektes, und zwar eines der folgenden (points,
+polygon, quads,
+quad_strip, screen). Jedes Statement &quot;begin&quot; muss mit einem
+entsprechenden &quot;end&quot; Statement geschlossen werden. Ein
+&quot;polygon&quot; gibt an, dass ein vertex pro, nun .... vertex benutzt wird.
+&quot;quads&quot; sind vierseitige polygone, jedes definiert durch vier Vertexe
+angeordnet um das Polygon. Ein &quot;quad_strip&quot; ist eine Reihe von
+vierseitigen Polygonen. Jedes teilt sich eine Ecke mit einem anderen Polygon
+davor und danach im &quot;strip&quot;.&nbsp; Ein &quot;screen&quot; ist ein
+&quot;quad&quot;, dass den derzeit gltigen Bereich im 3D Raum beschreibt, in
+dem das Spiel angezeigt wird. Nur einer von diesen sollte definiert sein. Fr
+mehr Informationen siehe Beschreibungen zu OpenGL Geometry an.
+<PRE>
+    end</PRE>
+<P>Beendet das Geometry Objekt, dass mit &quot;begin&quot; angefangen hat.<PRE>
+    pointsize &lt;s&gt;</PRE>
+<P>ndert die aktuelle Punktgre auf die entsprechenden Wert (bestimmt durch
+eine Gleitkommazahl zwischen 0.0 und z.B. 20.0). Anmerkung: Das Statement kann
+nicht zwischen begin und end verwendet werden.<br>
+<PRE>    color4 &lt;r&gt; &lt;g&gt; &lt;b&gt;</PRE>
+<P>ndert die aktuelle Farbe zu dem angegebenen RGB-Wert (definiert durch
+Gleitkommazahlen zwischen 0 und 1).
+<PRE>
+    color4 &lt;r&gt; &lt;g&gt; &lt;b&gt; &lt;a&gt;</PRE>
+<P>ndert die aktuelle Farbe zu dem angegebenen RGBA-Wert (definiert durch
+Gleitkommazahlen zwischen 0 und 1).
+<PRE>
+    shading &lt;type&gt;</PRE>
+<P>Setzt den &quot;shading&quot; Type. Verfgbare Typen sind &quot;smooth&quot;
+(blendet Farben von einem vertex zum nchsten ber) oder &quot;flat&quot;
+(macht dies nicht).
+<PRE>
+    vertex &lt;x&gt; &lt;y&gt; &lt;z&gt;</PRE>
+<P>Definiert ein vertex des aktuellen Geometrie Objektes als einen im Punkt im
+3D-Raum.
+<PRE>
+    numtex &lt;num&gt;</PRE>
+<P>Definiert die Anzahl verschiedener Texturen die geladen werden. Diese Angabe
+muss jeglicher &quot;loadtex&quot; Anweisung vorangehen.
+<PRE>
+    loadtex &lt;num&gt; &lt;width&gt; &lt;height&gt; &lt;filename&gt;</PRE>
+<P>Ldt Texture Nummer &lt;num&gt; aus einer .jpg Datei &lt;filename&gt;. Die
+.jpg-Datei MUSS &lt;width&gt; bei &lt;height&gt; Pixeln sein und beide Angaben
+&lt;width&gt; und &lt;height&gt; mssen ein Vielfaches von 2 sein (und muss mit
+den Hardwareanforderungen jeder 3D-Karte, mit der der Cabinet-Modus
+funktionieren soll, bereinstimmen --- 256x256 fr 3Dfx).
+<PRE>
+    texcoord &lt;xcoord&gt; &lt;ycoord&gt;</PRE>
+<P>Setzt die Texturkoordinaten des nchsten vertex. Dies definiert, wo in
+2D-Texture Raum die vertex liegt.
+<PRE>
+    enable texture</PRE>
+<P>Aktiviert texture mapping (unter Benutzung der aktuell ausgwhlten Textur).
+<PRE>
+    disable texture</PRE>
+<P>Schaltet das texture mapping ab.
+<PRE>
+    settex &lt;num&gt;</PRE>
+<P>Whlt die Texture &lt;num&gt; als nchste aus. Die Texture muss vorab
+geladen sein unter Benutzung von &quot;loadtex&quot;.
+<PRE>
+    camerapan &lt;num&gt;</PRE>
+<P>Startet die Definition der camera pan gefolgt von einer Anzahl &lt;num&gt;
+von Kamera Positionen. Nach der transision Definiton muss die Sequence pan durch
+eine &quot;end&quot; Anweisung abgeschlossen werden.
+<PRE>
+    goto &lt;lx&gt; &lt;ly&gt; &lt;lz&gt; &lt;px&gt; &lt;py&gt; &lt;pz&gt; &lt;nx&gt; &lt;ny&gt; &lt;nz&gt;</PRE>
+<P>Positoniert / reorientiert die Kamera. Die Argumente sind die selben wie beim
+OpenGL Komando &quot;gluLookAt()&quot;.&nbsp; Die Kamera ist bei Punkt
+&lt;lx,ly,lz&gt; positioniert, zeigt den Vektor &lt;px,py,pz&gt; entlang, mit
+&quot;up&quot; normal (die Richtung die oben ist fr die Kamera)
+&lt;nx,ny,nz&gt;.
+<PRE>
+    moveto &lt;lx&gt; &lt;ly&gt; &lt;lz&gt; &lt;px&gt; &lt;py&gt; &lt;pz&gt; &lt;nx&gt; &lt;ny&gt; &lt;nz&gt; &lt;frames&gt;</PRE>
+<P>Bewegt die Kamera zu einer neuen Position (angegeben im Befehl
+&quot;goto&quot;). Das Versetzen geschieht ber &lt;frames&gt; Frames.<br>
+<br>
+Alle Anweisungen mssen jeweils in einer neuen Zeile stehen. Benutze die
+(teilweise) kommentierte Datei glmamejau als ein Beispiel um
+anzufangen.<br>
+<H3>Allgemeine Fragen (FAQ)</H3>
+
+<P>Q: Ich bekomme nur ein paar Frames pro Sekunde. Das ist mist ! Warum nur ?<P>A1:
+Du lsst wahrscheinlich Mesa im Softwaremodus laufen. Du solltes die Datei &quot;README.3Dfx&quot;
+in Deinem Mesa-Paket durchlesen. Mglicherweise muss die Anweisung &quot;setenv MESA_GLX_FX fullscreen&quot;
+ausgefhrt werden.<P>A2: Du brauchst eine Grafikkarte mit&nbsp;
+3D-Beschleunigung. Kauf Dir eine (siehe unten) !<P>Q: Wenn ich xmame.xgl starte, dann macht es
+nur einen Core-Dump. Das macht weniger Spass als 3D Pacman zu spielen. Und nun ?<P>A1:
+Wenn Du eine 3Dfx-Karte hast, dass muss xmame.xgl als root ausgefhrt werden.
+Es sind Root-Rechte ntig, um auf die 3Dfx-Hardware zuzugreifen<P>A2: Wenn Du
+Mesa nutzt, dann musst Du auf Version 3.0 upgraden.<P>Q: Wenn ich xmame.xgl
+starte dann hngt
+das Spiel beim Initialisieren.
+<P>A: Luft gerade KDE ? Manchmal funktioniert
+dann die Tastatur unter KDE nicht. Wenn Du dieses Problem hast, dann wechsle den
+Fenstermanager.
+<P>Q: Welche Grafikkarten funktionieren mit xmame.xgl ?<P>A: Derzeit haben wir
+folgende Erkenntnisse (Stand: 13.07.2001)
+<UL>
+<LI> Vodoo3 + DRI OpenGL Treiber (XFree86 4.0.2), mit der Kommandozeilenoption "-noglaa"
+  und 16bpp Farbtiefe beim X11 Server</LI>
+<LI> Vodoo1 + Mesa 3.4 + Glide, mit dem Aufruf " -glres 640x480" !</LI>
+<LI> GeForce + NVIDIA OpenGL Treiber + XFree86 4.0.2 und 16/24bpp Farbtiefe</LI>
+<LI>NVIDIA TNT2 + NVIDIA OpenGL Treiber + XFree86 4.0.2 mit dem Aufruf "-bpp 16"
+  und 16bpp (mglicherweise auch 24bpp&nbsp; ???) Farbtiefe (das Mapping der
+  OpenGL Farbpaletten ist fehlerhaft).</LI>
+<LI>NVIDIA TNT + NVIDIA OpenGL Treiber + XFree86 4.0.2 mit dem Aufruf "-bpp 16"
+  und 16bpp (mglicherweise auch 24bpp&nbsp; ???) Farbtiefe (das Mapping der
+  OpenGL Farbpaletten ist fehlerhaft).</LI>
+<LI> Matrox MGA 400 + DRI OpenGL Treiber (XFree86 4.0.2) mit dem Aufruf "-bpp 16", "-noglaa" (???)
+  und 16bpp (ggf.. auch 24bpp ???) Farbtiefe (das Mapping der OpenGL
+  Farbpaletten ist fehlerhaft).</LI>
+<LI> ATI R128 + DRI OpenGL Treiber (XFree86 4.1.0) mit den Aufrufen " -noglext78 -noglaa"
+  oder " -bpp 16 -noglaa" , wobei die letzteren Optionen etwas langsamer sind (ca. 5 fps).</LI>
+<li> LinuxPPC - Powerbook-Firewire + ATI R128: siehe oben !</li>
+</UL>
+<P>Alle oben angegebenen Treiber funktionieren mit der Option &quot;-bpp
+16&quot; und/oder &quot;-noglext78&quot;. Es sieht also danach aus, dass ein
+Fehler in der OpenGL Implementation verursacht, dass diese Treiber/Hardware
+Kombinationen nur mit den angegebenen Kommandozeilenoptionen funktionieren. Der
+Fehler knnte in diesen OpenGL-Funktionen liegen:
+<UL>
+<LI> glColorTableEXT</LI>
+<li> glColorSubTableEXT</li>
+</UL>
+<P>Eine derzeit schnelle und spassige Treiber/Hardware Kombination ist:
+<UL>
+<li> NVIDIA GeForce + NVIDIA OpenGL Treiber + XFree86 4.0.2; Ich habe eine GeForce256 (AGP)
+  getestet.</li>
+<li> Vodoo + DRI OpenGL Treiber (XFree86 4.0.2); Ich habe eine Vodoo3 getestet.</li>
+</UL>
+<P><br>
+Q: Wenn ich xmame.xgl starte, dann funktioniert gar nichts mehr.<br>
+<br>
+A: Lies die oben genannten Erkenntnisse ... und versuche
+<UL>
+<li>die Farbtiefe es X-Servers abndern (-bpp), z.B. mit 32bpp oder 24bpp oder
+  16bpp;</li>
+<li>die Kommandozeilenoption &quot;-bpp 16&quot;;</li>
+<li>die Kommandozeilenoption &quot;-noglaa&quot;;</li>
+<li>die Kommandozeilenoption &quot;-noglext&quot;.</li>
+</UL>
+<P>&nbsp;
+<H3>Aktuelle
+Einschrnkungen/Bugs</H3>
+
+<UL>
+<LI>kein Clipping bei Vektor Spielen (meist im Cabinet-Modus zu bemerken)</LI>
+<LI>kein Einhalten des korrekten Seitenverhltnisses im Cabinet-Modus<br>
+</LI>
+</UL>
+<H3>Zuknftige Neuerungen&nbsp;</H3>
+
+<UL>
+<LI>bestehende Fehler beheben ... sind da welche ? Oder sind da nur ein paar
+  unbekannte Features ;-) ?&nbsp;</LI>
+<LI>Optimierung des Codes zum Zeichnen, damit nur die Teile der Bitmap neu
+  gezeichnet werden, die sich gendert haben.<br>
+  Das Coding optimieren ....</LI>
+</UL>
+<H3>Lizenz</H3>
+
+<p>Der Code von GLMmame basiert auf&nbsp; Mike Oliphant's GLMame Code Version
+0.6.</p>
+<p>Der Code von GLMame steht unter dem Copyright (1998) von Mike Oliphant. Es
+kann benutzt und weitergegeben werden unter den selben Bedingungen wie in der
+MAME Lizenz beschrieben.</p>
+<p>Seit GLMame Version 0.7 wurde der Code verndert und start verbessert von
+Sven Goethel -- keine nderung der Lizenz !!</p>
+<H3><br>
+Version History (im englischen Original)</H3>
+
+<P>v0.83 -- March 29th, 2001 ---------------------------
+<UL>
+<li> Changed the code heavily to improve compatibility and speed. The new code is a re-merge of the GLMame32 code, which is a branch of Mike Oliphant's GLmame code version 0.6.</li>
+<li> For a detailed list, please consult the file changes.opengl within the distribution's documentation directory! You can also view the current changes.opengl here:
+  <a href="http://www.jausoft.com/glmame.html"> http://www.jausoft.com/glmame.html</a></li>
+</UL>
+
+<P><br>
+v0.6 -- December 14th, 1998 ---------------------------
+<UL>
+<LI>added support for systems that do not support paletted textures
+(SGI and solaris OpenGL implementations, for example)</LI>
+<LI>merged source with xmame b8.1</LI>
+</UL>
+<P>v0.5 -- October 30th, 1998 --------------------------
+<UL>
+<LI>fixed a bug with texturing being left on in bad places</LI>
+<LI>added 3Dfx gamma adjustment</LI>
+</UL>
+<P>v0.4 -- October 21st, 1998 --------------------------
+<UL>
+<LI>updated to work with xmame v0.34b5.2</LI>
+</UL>
+<P>v0.3 -- October 12th, 1998 --------------------------
+<UL>
+<LI>fixed verticle screen centering in fullscreen mode</LI>
+<LI>moved cabinet and camera panning information into a user-editable
+configuration file</LI>
+<LI>added 'trans' cabinet model o added double buffer, view type,
+and cabinet selection command-line options</LI>
+</UL>
+<P>v0.2 -- October 6th, 1998 -------------------------
+<UL>
+<LI>adding missing 'cab' directory</LI>
+</UL>
+<P>v0.1 -- October 5th, 1998 -------------------------
+<UL>
+<LI>first public release</LI>
+</UL>
+<H3>Author</H3>
+
+<P>Seit GLMame Version 0.7: Sven Goethel (<a href="mailto:sgoethel@jausoft.com">sgoethel@jausoft.com</a>)
+<a href="http://www.jausoft.com/glmame.html"> http://www.jausoft.com/glmame.html</a><br>
+<br>
+Bis GLMame Version 0.6: Mike Oliphant <CODE>
+<A HREF="mailto:oliphant@ling.ed.ac.uk">(oliphant@ling.ed.ac.uk)</A></CODE> 
+<A HREF="http://glmame.linuxgames.com">http://glmame.linuxgames.com</A><P>
+<HR>
+<A HREF="xmame-gdoc-5.html">Weiter</A> <A HREF="xmame-gdoc-3.html">Zurck</A> <A HREF="xmame-gdoc.html#toc4">Inhalt</A>
+</BODY>
+</HTML>
diff --git a/src/unix/doc/xmame-gdoc-5.html b/src/unix/doc/xmame-gdoc-5.html
new file mode 100644
index 0000000..ba4e9a0
--- /dev/null
+++ b/src/unix/doc/xmame-gdoc-5.html
@@ -0,0 +1,188 @@
+<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
+<HTML>
+<HEAD>
+ <META NAME="GENERATOR" CONTENT="Microsoft FrontPage 4.0">
+ <TITLE>XMAME/XMESS DOKUMENTATION: Kontaktinformationen und Danksagungen</TITLE>
+ <LINK HREF="xmame-gdoc-6.html" REL=next>
+ <LINK HREF="xmame-gdoc-4.html" REL=previous>
+ <LINK HREF="xmame-gdoc.html#toc5" REL=contents>
+ <link rel="stylesheet" href="xmame.css" type="text/css" >
+</HEAD>
+<BODY BACKGROUND="img/xmame.jpg" BGPROPERTIES="fixed" >
+<A HREF="xmame-gdoc-6.html">Weiter</A> <A HREF="xmame-gdoc-4.html">Zurck</A> <A HREF="xmame-gdoc.html#toc5">Inhalt</A>
+<HR>
+<H2><A NAME="s5">5. Kontaktinformationen und Danksagungen</A></H2>
+
+<H2><A NAME="Mail"></A> <A NAME="ss5.1">5.1 Mail </A>
+</H2>
+
+<P>Es gibt eine offizielle XMame/XMess Mailingliste. Alle nderungen auf diese
+Liste bezogen werden via E-Mail an <CODE><a HREF="mailto:Xmame-request@toybox.twisted.org.uk">Xmame-request@toybox.twisted.org.uk</a></CODE> 
+geschickt mit einem Schlsselwort im Body der Mail.<P>Einige der derzeit
+untersttzten Befehle:&nbsp;<PRE>    subscribe      - in die Liste eintragen
+    unsubscribe    - aus der Liste austragen
+    who            - rausfinden, wer in der Liste eingetragen ist
+    info           - die erklrenden Informationen fr diese Liste anzeigen
+    help           - alle Befehle auflisten</PRE>
+<P>XMame Mailingliste:
+<UL>
+<LI>Die XMame Mailingliste ist gedacht als ein Technikforum fr
+  XMame-Entwickler, die
+<UL>
+<LI>Ideen austauschen um ein besseres XMame zu bekommen </LI>
+<LI>Patches und Meldungen ber Fehler austauschen </LI>
+<LI>neue Designstrategien bereden</LI>
+<LI>Probleme beheben und mehr lernen wollen.</LI>
+</UL>
+</LI>
+<LI>Die XMame Mailingliste <b>ist kein</b> Forum, bei dem es um das Spielen der
+  Spiele geht (aber jeder in der XMame-Liste spielt ..).<br>
+  Deshalb bitte
+<UL>
+<LI><B>Diese Liste nicht zum betteln nach ROMs benutzen</B></LI>
+<LI><B>Frage nicht nach nicht-UNIX Portierungen von Mame, nur ber MAME und
+  XMame wird hier &quot;gesprochen&quot;</B></LI>
+<LI><B>Frage nicht, wie man ein Spiel implementieren kann. Suche dazu in den
+  Dokumentationen und teile uns das Ergebnis mit (Du hast doppelten Spass:
+  programmieren und spielen...)</B></LI>
+<LI><B>Teile uns nicht Dein letztes Highscore Ergebnis im Spiel xxx mit (wir
+  haben Interesse am Programmieren, und dann am Spielen. In DIESER Reihenfolge)</B></LI>
+</UL>
+</LI>
+<LI><B>Copyright Hinweis: NIEMALS, ich wiederhole NIEMALS drfen ROM-Dateien in
+  die Liste geschickt werden </B> (aber Du kannst uns gerne mitteilen, wo wir
+  sie bekommen knnen... ;-) )</LI>
+<LI>Zu Zeit ist die die XMame Liste <b>nicht moderiert</b>. Somit bekommt jeder,
+  der sich in die Liste eingetragen hat jeden Beitrag, der zur Liste geschickt
+  wird. Wir bevorzugen, dass das auch nicht gendert werden muss ...</LI>
+</UL>
+<P>Wenn Du lieber eine persnliche Mail an den XMame/XMess Koordinator schicken
+willst, dann benutze die Adresse, die unten angegeben ist. Jeder, der Interesse
+an XMame/XMess hat und mit dazu beitragen will, sollte sich in die XMame/XMess
+Mailingliste eintragen.
+<UL>
+<LI>Mailingliste: <CODE><a HREF="mailto:Xmame-request@toybox.twisted.org.uk">Xmame-request@toybox.twisted.org.uk</a></CODE></LI>
+<LI>XMame/XMess Koordinator: <CODE>
+<A HREF="mailto:gold@aros.net">gold@aros.net</A></CODE></LI>
+</UL>
+<P>Das ist alles. Habt Spass mit XMame!<H2><A NAME="ss5.2">5.2 Danksagungen</A>
+</H2>
+
+<P>Vielen vielen vielen Dank an jeden fr die grosse Hilfe beim XMame Projekt.
+Ich danke folgenden Personen und natrlich allen die ich vergessen habe.<br>
+<br>
+Dank an Alle,
+<P>Hans
+<P>(Nachtrag: Ein dickes Dankeschn an Hans fr seine fantastische Arbeit
+ber die lange Zeit, die er XMame/XMess Koordinator war und an alle in der
+Mailinliste, die mir geholfen haben die Koordinaton von XMame zu bernehmen. --Lawrence Gold)
+<OL>
+<LI>Vter von Mame (Hauptversion)
+<UL>
+<LI>Nicola Salmoria</LI>
+<LI>Allard van der Bas</LI>
+<LI>Mirko (Mix) Buffoni (General Mantainer)</LI>
+</UL>
+</LI>
+<LI>Vter von Mess
+<UL>
+<LI>Brad Oliver </LI>
+<LI>Richard Bannister</LI>
+<LI>Ben Bruscella (current coordinator) </LI>
+</UL>
+</LI>
+<LI>Original UNIX/X11 Portierung
+<UL>
+<LI>Allard van der Bas</LI>
+<LI>Dick the Ridder</LI>
+<LI>Juan Antonio Martinez</LI>
+</UL>
+</LI>
+<LI>Semi-retired Unix maintainer extraordinaire
+<UL>
+<LI>Hans de Goede</LI>
+</UL>
+</LI>
+<LI>Alpha specific issues
+<UL>
+<LI>Christian Groessler</LI>
+</UL>
+</LI>
+<LI>Sun specific issues
+<UL>
+<LI>Keith Hargrove</LI>
+<LI>Mathis Rosenhau</LI>
+</UL>
+</LI>
+<LI>Irix specific issues
+<UL>
+<LI>Tristram Scott</LI>
+</UL>
+</LI>
+<LI>GGI maintainance
+<UL>
+<LI>Gabriele Boccone (original port)</LI>
+<LI>Christian Groessler (current maintainer)</LI>
+</UL>
+</LI>
+<LI>OpenGL code &amp; maintainance
+<UL>
+<LI>Mike Oliphant (original creator)</LI>
+<LI>Sven Goethel (from GLmame 0.7 to the present)</LI>
+</UL>
+</LI>
+<LI>Network code
+<UL>
+<LI>Eric Totel</LI>
+</UL>
+</LI>
+<LI>Perl scripts for automation of some porting issues
+<UL>
+<LI>Bill Adams</LI>
+</UL>
+</LI>
+<LI>Xmame RPMs
+<UL>
+<LI>Jeremy Hansen</LI>
+</UL>
+</LI>
+<LI>Mailing list maintainer
+<UL>
+<LI>Chris McCraw</LI>
+</UL>
+</LI>
+<LI>Bits and pieces
+<UL>
+<LI>Christian Groessler</LI>
+<LI>Torsten Paul</LI>
+<LI>Jack Patton</LI>
+<LI>David Black</LI>
+</UL>
+</LI>
+<LI>AIX Sound code
+<UL>
+<LI>Chris Sharpp</LI>
+</UL>
+</LI>
+<LI>IRIX Sound code
+<UL>
+<LI><CODE>
+<A HREF="mailto:entropy@zippy.bernstein.com">entropy@zippy.bernstein.com</A></CODE> </LI>
+</UL>
+</LI>
+<LI>German readme
+<UL>
+<LI>Robert Hamberger</LI>
+</UL>
+</LI>
+<LI>Documentation (SGML, HTML, MAN)
+<UL>
+<LI>Rene Herrmann</LI>
+</UL>
+</LI>
+</OL>
+<HR>
+<A HREF="xmame-gdoc-6.html">Weiter</A> <A HREF="xmame-gdoc-4.html">Zurck</A> <A HREF="xmame-gdoc.html#toc5">Inhalt</A>
+<p>&nbsp;
+</BODY>
+</HTML>
diff --git a/src/unix/doc/xmame-gdoc-6.html b/src/unix/doc/xmame-gdoc-6.html
new file mode 100644
index 0000000..635eb38
--- /dev/null
+++ b/src/unix/doc/xmame-gdoc-6.html
@@ -0,0 +1,35 @@
+<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
+<HTML>
+<HEAD>
+ <META NAME="GENERATOR" CONTENT="Microsoft FrontPage 4.0">
+ <TITLE>XMAME/XMESS DOKUMENTATION: Anmerkungen zur Legalitt und Copyrights
+ fr Mame und Mess</TITLE>
+ <LINK HREF="xmame-gdoc-7.html" REL=next>
+ <LINK HREF="xmame-gdoc-5.html" REL=previous>
+ <LINK HREF="xmame-gdoc.html#toc6" REL=contents>
+<link rel="stylesheet" href="xmame.css" type="text/css" >
+</HEAD>
+<BODY BACKGROUND="img/xmame.jpg" BGPROPERTIES="fixed" >
+<A HREF="xmame-gdoc-7.html">Weiter</A> <A HREF="xmame-gdoc-5.html">Zurck</A> <A HREF="xmame-gdoc.html#toc6">Inhalt</A>
+<HR>
+<H2><A NAME="s6">6. Anmerkungen zur Legalitt und Copyrights fr MAME und MESS</A></H2>
+
+<UL>
+<LI><B>Bitte zuerst die Readme-Dateien von MAME/MESS lesen !</B></LI>
+<LI>XMame/XMess unterliegt den selben Lizenzbestimmungen wie in&nbsp; <A HREF="readme.mame">readme.mame</A>
+</LI>
+<LI>Und wenn Du an Mess interessiert bist, dann wirf einen Blick auf&nbsp; <A HREF="readme.mess">readme.mess</A>
+</LI>
+<LI>Die Haupteinschrnkungen betreffen ROM-Dateien. ROM-Dateien unterliegen dem
+  Copyright der jeweiligen Authoren und drfen KEINESFALLS im selben Paket wie
+  XMame/XMess verbreitet werden. Das runterladen von ROM-Dateien geschieht auf
+  Deine eigene Verantwortung und auf eigenes Risiko.</LI>
+<LI>Joystick-Support auf Basis der XInputExtensions. Der Sourcecode ist wirklich harte Arbeit. Keine
+  Beispielprogramme, keine Informationen waren aufzutreiben (nur ein Referenzhandbuch zu den Libraries), und der Sourcecode unterliegt meinem<br>
+  Copyright (Juan Antonio Marmnez). Er kann unter den Bestimmungen der GNU
+  General Public License (GPL) genutzt werden.</LI>
+</UL>
+<HR>
+<A HREF="xmame-gdoc-7.html">Weiter</A> <A HREF="xmame-gdoc-5.html">Zurck</A> <A HREF="xmame-gdoc.html#toc6">Inhalt</A>
+</BODY>
+</HTML>
diff --git a/src/unix/doc/xmame-gdoc-7.html b/src/unix/doc/xmame-gdoc-7.html
new file mode 100644
index 0000000..3e845c9
--- /dev/null
+++ b/src/unix/doc/xmame-gdoc-7.html
@@ -0,0 +1,154 @@
+<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
+<HTML>
+<HEAD>
+ <META NAME="GENERATOR" CONTENT="Microsoft FrontPage 4.0">
+ <TITLE>XMAME/XMESS DOCUMENTATION: Some Links</TITLE>
+ <LINK HREF="xmame-gdoc-8.html" REL=next>
+ <LINK HREF="xmame-gdoc-6.html" REL=previous>
+ <LINK HREF="xmame-gdoc.html#toc7" REL=contents>
+<link rel="stylesheet" href="xmame.css" type="text/css" >
+</HEAD>
+<BODY BACKGROUND="img/xmame.jpg" BGPROPERTIES="fixed" >
+<a HREF="xmame-gdoc-8.html">Weiter</a>  <a HREF="xmame-gdoc-6.html">Zurck</a> <a HREF="xmame-gdoc.html#toc7">Inhalt</a>
+<HR>
+<H2><A NAME="s7">7.</A>  <A HREF="xmame-gdoc.html#toc7">Einige Links</A></H2>
+
+<H2><A NAME="ss7.1">7.1</A>  <A HREF="xmame-gdoc.html#toc7.1">Unix Sourcen und
+Dokumentaion</A>
+</H2>
+
+<P>
+<UL>
+<LI>Die XMame/XMess Sourcen
+
+
+<P>
+<a HREF="../download/xmame-0.56.1.tar.bz2">xmame 0.56.2 sources (XMame und XMess)</a></P>
+
+</LI>
+<LI>XMame/XMess FAQ &amp; Installationsanweisung:
+<P>
+<a HREF="xmame-gdoc.html">xmame-gdoc (html-Format)</a></P>
+
+</LI>
+<LI>XMame/XMess Liste bekannter Fehler:<P>
+<a HREF="../open_issues.html">open issues</a> (in englisch)</P>
+
+</LI>
+</UL>
+<H2><A NAME="ss7.2">7.2</A> <A HREF="xmame-gdoc.html#toc7.2">Unix binaries</A>
+</H2>
+
+<P>
+<UL>
+<LI>
+<A HREF="http://www.forte-intl.com/~ronald/xmame/">Xmame RPMs</A>
+</LI>
+<LI>
+<A HREF="http://www.beimborn.com/cps2/linux/rpms">Xmame+CPS2 RPMs</A>
+</LI>
+</UL>
+<H2><A NAME="ss7.3">7.3</A>  <A HREF="xmame-gdoc.html#toc7.3">XMame/XMess Mirror
+zum Download</A>
+</H2>
+
+<P>
+<UL>
+<LI>
+<A HREF="ftp://cps2:cps2@wingnut.beimborn.com">ftp://cps2:cps2@wingnut.beimborn.com</A>
+(US)</LI>
+<LI>
+<A HREF="http://www.mame.dk">http://www.mame.dk</A>
+ (Dnemark)</LI>
+<LI>
+<A HREF="ftp://ftp.kaupp.cx/pub/xmame">ftp://ftp.kaupp.cx/pub/xmame</A>
+(US)</LI>
+</UL>
+<H2><A NAME="ss7.4">7.4</A>  <A HREF="xmame-gdoc.html#toc7.4">(X)Mame Frontends</A>
+</H2>
+
+<P>
+<UL>
+<LI>
+<A HREF="http://www.mame.net/frontend.html">Die offizielle MAME Frontend Seite</A>
+</LI>
+<LI>
+<A HREF="http://tkmame.retrogames.com">TkMame</A>
+, das Tcl/TK Frontend, dass unter Linux/Unix und MS Windows funktioniert</LI>
+<LI>
+<A HREF="http://www.toetag.com/~tom/xmame.html">Xmameload</A>
+</LI>
+<LI>
+<A HREF="ftp://ftp.sad.it/pub/kde/local/">Kmamerun</A>
+</LI>
+<LI>
+<A HREF="http://www.mameworld.net/mamecat/">Mamecat</A>
+</LI>
+<LI>
+<A HREF="http://user.cs.tu-berlin.de/~gator/mame/">GrokMame</A>
+</LI>
+<LI>
+<A HREF="http://members.xoom.com/gmame/">Gmame</A>
+</LI>
+<LI>
+<A HREF="http://www.geocities.com/SiliconValley/Mouse/1570/">startxmame</A>
+</LI>
+<LI>
+<A HREF="http://it-mame.sourceforge.net/index2.html">it-mame</A>
+</LI>
+<LI>
+<A HREF="http://grustibus.sourceforge.net">gRustibus</A>
+, ein <B>sehr gutes</B> Frontend (wenn man Gnome kennt) </LI>
+<LI>
+<A HREF="http://www.sourceforge.net/projects/iqf/">IQF</A>
+</LI>
+<LI>
+<A HREF="http://gnomame.sourceforge.net/">GnoMame</A>
+, ein weiteres grossartiges GNOME-basiertes Frontend </LI>
+<LI>
+<A HREF="file:/home/david/tmp/xmame-try/realsite/download/lanzamame.tar.bz2">LANZAMAME</A>
+</LI>
+<LI>
+<A HREF="http://www.terra.es/personal3/victorote/frontend/index_en.html">Victor Manuel's TCL/TK Frontend</A>
+</LI>
+<LI>
+<A HREF="http://ant.eelinux.com/ptkmame/">ptkmame</A>
+</LI>
+<LI>
+<A HREF="http://kemulator.sourceforge.net/">Kemulator</A>
+, ein KDE Frontend mit MESS and Stella Untersttzung
+</LI>
+<LI>
+<A HREF="http://www.foxbox.org/adam/code/flynn/index.html">Flynn</A>
+ (vorzugsweise fr konvertierte arcade cabinets)</LI>
+</UL>
+<H2><A NAME="ss7.5">7.5</A>  <A HREF="xmame-gdoc.html#toc7.5">Einige weitere Links</A>
+</H2>
+
+<P>
+<UL>
+<LI>Die offizielle M.A.M.E Seite ist auf <A HREF="http://www.mame.net">http://www.mame.net</A>
+</LI>
+<LI>The offizielle MESS Seite ist auf <A HREF="http://mess.emuverse.com">http://mess.emuverse.com</A>
+</LI>
+<LI>Einige weitere Emulatoren-Seiten sind hier: <A HREF="http://www.vg-network.com">http://www.vg-network.com</A>
+  und 
+<A HREF="http://www.retrogames.com">http://www.retrogames.com</A>
+</LI>
+<LI><a href="http://www.bingo-ev.de/~rh474">Meine Emu-Homepage</a>
+</LI>
+<LI>The allerbeste ROM Seite auf diesem Planeten ist auf 
+<A HREF="http://www.mame.dk/">http://www.mame.dk/</A>
+</LI>
+<LI>Ein paar Seiten mit CPS2 und anderen Patches 
+<A HREF="http://www.beimborn.com/cps2/linux/">Dan Beimborn's Linux CPS2Mame page</A>
+  und 
+<A HREF="http://www.win.tue.nl/~stijn/xmame/">Stijn Hoop's xmame patches </A>
+</LI>
+<LI>Und natrlich nicht unsere Projekt-Homepage vergessen<B><A HREF="http://x.mame.net/">
+  http://x.mame.net/</A></B></LI>
+</UL>
+<HR>
+<a HREF="xmame-gdoc-8.html">Weiter</a>  <a HREF="xmame-gdoc-6.html">Zurck</a> <a HREF="xmame-gdoc.html#toc7">Inhalt</a>
+</BODY>
+</HTML>
diff --git a/src/unix/doc/xmame-gdoc-8.html b/src/unix/doc/xmame-gdoc-8.html
new file mode 100644
index 0000000..55a811f
--- /dev/null
+++ b/src/unix/doc/xmame-gdoc-8.html
@@ -0,0 +1,47 @@
+<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
+<HTML>
+<HEAD>
+ <META NAME="GENERATOR" CONTENT="Microsoft FrontPage 4.0">
+ <TITLE>XMAME/XMESS DOCUMENTATION: ChangeLogs</TITLE>
+ <LINK HREF="xmame-gdoc-7.html" REL=previous>
+ <LINK HREF="xmame-gdoc.html#toc8" REL=contents>
+<link rel="stylesheet" href="xmame.css" type="text/css" >
+</HEAD>
+<BODY BACKGROUND="img/xmame.jpg" BGPROPERTIES="fixed" >
+Weiter <A HREF="xmame-gdoc-7.html">Zurck</A>  <a HREF="xmame-gdoc.html#toc8">Inhalt</a>
+<HR>
+<H2><A NAME="ChangeLogs"></A> <A NAME="s8">8.</A>  <A HREF="xmame-gdoc.html#toc8">nderungshistorie</A></H2>
+
+<H2><A NAME="ss8.1">8.1</A> <A HREF="xmame-gdoc.html#toc8.1">Die nderungshistorie von MAME/MESS</A>
+</H2>
+
+<P>Dies sind die nderungen in den offiziellen MAME und MESS, die Basis von
+XMame / XMess.
+<UL>
+<LI>
+<A HREF="changes.mame">Die MAME nderungshistorie (changes.mame)</A>
+</LI>
+<LI>
+<A HREF="changes.mess">Die MESS nderungshistorie (changes.mame)</A>
+</LI>
+</UL>
+<H2><A NAME="ss8.2">8.2</A>  <a href="xmame-gdoc.html#toc8.2">Die Unix nderungshistorie</a>
+</H2>
+
+<P>Und nun die HISTORIE des XMame Projektes (natrlich bist Du deshalb hier;-))
+... Ren
+<UL>
+<LI>
+<A HREF="changes.unix">Die Unix nderungshistorie (changes.unix)</A>
+</LI>
+<LI>
+Die nderungshistorie des OpenGL Treibers: <a href="http://x.mame.net/download/changes.opengl"> changes.opengl</a> or
+<a href="http://www.jausoft.com/glmame.html"> http://www.jausoft.com/glmame.html</a><br>
+</LI>
+</UL>
+
+
+<HR>
+Weiter <A HREF="xmame-gdoc-7.html">Zurck</A>  <a HREF="xmame-gdoc.html#toc8">Inhalt</a>
+</BODY>
+</HTML>
diff --git a/src/unix/doc/xmame-gdoc.html b/src/unix/doc/xmame-gdoc.html
new file mode 100644
index 0000000..4c0482a
--- /dev/null
+++ b/src/unix/doc/xmame-gdoc.html
@@ -0,0 +1,148 @@
+<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
+<HTML>
+<HEAD>
+ <META NAME="GENERATOR" CONTENT="Microsoft FrontPage 4.0">
+ <TITLE>XMAME/XMESS DOKUMENTATION</TITLE>
+ <LINK HREF="xmame-gdoc-1.html" REL=next>
+
+<link rel="stylesheet" href="xmame.css" type="text/css" >
+</HEAD>
+<BODY BACKGROUND="img/xmame.jpg" BGPROPERTIES="fixed" >
+<A HREF="xmame-gdoc-1.html">Weiter</A> Zurck Inhalt
+<HR>
+<H1>XMAME/XMESS DOKUMENTATION</H1>
+
+<H2>Juan Antonio Martinez <CODE>
+<A HREF="mailto:jantonio@dit.upm.es">jantonio@dit.upm.es</A>,</CODE> Hans de Goede <CODE>
+<A HREF="mailto:hans@highrise.nl">hans@highrise.nl</A>,</CODE> Rene' Herrmann
+ (4 doc/sgml) <CODE>
+<A HREF="mailto:rene.herrmann@berlin.de">rene.herrmann@berlin.de</A></CODE> und Lawrence Gold
+(kleine nderungen) <CODE>
+<A HREF="mailto:gold@aros.net">gold@aros.net</A></CODE></H2><p><b>Deutsche
+Anleitung von Robert Hamberger <a href="mailto:rh474@bingo-ev.de">rh474@bingo-ev.de</a></b></p>v2.1.8,
+26. November 2001
+<P><HR>
+<EM>XMame/XMess Dokumentation mit einer Installationsanleitung, FAQ (hufg
+gestellte Fragen), Hinweisen, Tipps und Tricks, die nderungen im Code und
+vieles mehr !</EM>
+<HR>
+<P>
+<H2><A NAME="toc1">1.</A>  <A HREF="xmame-gdoc-1.html">Einleitung und Links </A></H2>
+
+<UL>
+<LI><a HREF="xmame-gdoc-1.html#ss1.1" name="toc1.1">1.1 </a><A HREF="xmame-gdoc-1.html#ss1.1">Willkommen
+  bei XMame</A>
+<LI><a HREF="xmame-gdoc-1.html#ss1.2" name="toc1.2">1.2 </a><A HREF="xmame-gdoc-1.html#ss1.2">Alles
+  immer up-to-date halten!</A>
+<LI><a HREF="xmame-gdoc-1.html#ss1.3" name="toc1.3">1.3 </a><A HREF="xmame-gdoc-1.html#ss1.3"> Hngende Arbeiten - oder TODO</A>
+</UL>
+<P>
+<H2><A NAME="toc2">2.</A>  <A HREF="xmame-gdoc-2.html">bersetzen, Einrichten
+und Starten von XMame/XMess</A></H2>
+
+<UL>
+<LI><a HREF="xmame-gdoc-2.html#ss2.1" name="toc2.1">2.1 </a><A HREF="xmame-gdoc-2.html#ss2.1"> Voraussetzungen </A>
+<LI><a HREF="xmame-gdoc-2.html#ss2.2" name="toc2.2">2.2 </a><A HREF="xmame-gdoc-2.html#ss2.2"> Schritt-fr-Schritt Anleitung zum
+  bersetzen von XMame/XMess</A>
+<LI><a HREF="xmame-gdoc-2.html#ss2.3" name="toc2.3">2.3 </a><A HREF="xmame-gdoc-2.html#ss2.3"> Bei Problemen beim bersetzen,
+  Einrichten und Starten von XMame/XMess...</A>
+<LI><a HREF="xmame-gdoc-2.html#ss2.4" name="toc2.4">2.4 </a><A HREF="xmame-gdoc-2.html#ss2.4"> Betriebssystemabhngige Anmerkungen beim bersetzen</A>
+</UL>
+<P>
+<H2><A NAME="toc3">3.</A> <A HREF="xmame-gdoc-3.html">XMame hufig gestellte
+Fragen (FAQ)</A></H2>
+
+<UL>
+<LI><a HREF="xmame-gdoc-3.html#ss3.1" name="toc3.1">3.1 </a><A HREF="xmame-gdoc-3.html#ss3.1"> Was ist Mame?</A>
+<LI><a HREF="xmame-gdoc-3.html#ss3.2" name="toc3.2">3.2 </a><A HREF="xmame-gdoc-3.html#ss3.2"> Was ist Mess?</A>
+<LI><a HREF="xmame-gdoc-3.html#ss3.3" name="toc3.3">3.3 </a><A HREF="xmame-gdoc-3.html#ss3.3"> Was sind XMame/XMess?</A>
+<LI><a HREF="xmame-gdoc-3.html#ss3.4" name="toc3.4">3.4 </a><A HREF="xmame-gdoc-3.html#ss3.4"> Was sind die Unterschiede zwischen Mame/Mess
+  und XMame/XMess?</A>
+<LI><a HREF="xmame-gdoc-3.html#ss3.5" name="toc3.5">3.5 </a><A HREF="xmame-gdoc-3.html#ss3.5"> Welche Hardware und welche
+  Betriebssysteme werden untersttzt? </A>
+<LI><a HREF="xmame-gdoc-3.html#ss3.6" name="toc3.6">3.6 </a><A HREF="xmame-gdoc-3.html#ss3.6"> Mein Betriebssystem wird untersttzt,
+  aber XMame/XMess bringen Fehler und brechen ab.</A>
+<LI><a HREF="xmame-gdoc-3.html#ss3.7" name="toc3.7">3.7 </a><A HREF="xmame-gdoc-3.html#ss3.7"> Wozu brauche ich die Dateien xmamerc/xmessrc
+  ?</A>
+<LI><a HREF="xmame-gdoc-3.html#ss3.8" name="toc3.8">3.8 </a><A HREF="xmame-gdoc-3.html#ss3.8"> Was ist die Syntax in den Dateien
+  xmamerc/xmessrc ?</A>
+<LI><a HREF="xmame-gdoc-3.html#ss3.9" name="toc3.9">3.9 </a><A HREF="xmame-gdoc-3.html#ss3.9"> Wo mssen roms, images, samples, highscores, configfiles,
+  usw. hin ?</A>
+<LI><a HREF="xmame-gdoc-3.html#ss3.10" name="toc3.10">3.10 </a><A HREF="xmame-gdoc-3.html#ss3.10"> Wie starte ich XMess/XMame ?</A>
+<LI><a HREF="xmame-gdoc-3.html#ss3.11" name="toc3.11">3.11 </a><A HREF="xmame-gdoc-3.html#ss3.11"> Was sind die Kommandozeilen Parameter
+  fr XMame/XMess?</A>
+<LI><a HREF="xmame-gdoc-3.html#ss3.12" name="toc3.12">3.12 </a><A HREF="xmame-gdoc-3.html#ss3.12"> Welche Tasten benutzen XMame/XMess
+  ?</A>
+<LI><a HREF="xmame-gdoc-3.html#ss3.13" name="toc3.13">3.13 </a><A HREF="xmame-gdoc-3.html#ss3.13"> Warum haben manche Spiele keinen
+  Sound ?</A>
+<LI><a HREF="xmame-gdoc-3.html#ss3.14" name="toc3.14">3.14 </a><A HREF="xmame-gdoc-3.html#ss3.14"> Meine Soundausgabe ist verzgert /
+  ist abgehakt / Was bewirkt -bufsize ?</A>
+<LI><a HREF="xmame-gdoc-3.html#ss3.15" name="toc3.15">3.15 </a><A HREF="xmame-gdoc-3.html#ss3.15"> Warum funktioniert ein Spiel nicht ? </A>
+<LI><a HREF="xmame-gdoc-3.html#ss3.16" name="toc3.16">3.16 </a><A HREF="xmame-gdoc-3.html#ss3.16"> Was sind PROMs? </A>
+<LI><a HREF="xmame-gdoc-3.html#ss3.17" name="toc3.17">3.17 </a><A HREF="xmame-gdoc-3.html#ss3.17"> Warum sind XMame/XMess so langsam ?</A>
+<LI><a HREF="xmame-gdoc-3.html#ss3.18" name="toc3.18">3.18 </a><A HREF="xmame-gdoc-3.html#ss3.18"> Ich habe eine Dualprozessor Maschine.
+  Wie kann ich sie voll ausnutzen ?</A>
+<LI><a HREF="xmame-gdoc-3.html#ss3.19" name="toc3.19">3.19 </a><A HREF="xmame-gdoc-3.html#ss3.19"> Warum funktionieren bei meinem
+  Joystick die diagonalen Bewegungen nicht richtgig ?</A>
+<LI><a HREF="xmame-gdoc-3.html#ss3.20" name="toc3.20">3.20</a> <A HREF="xmame-gdoc-3.html#ss3.20"> Wie kann ich die XinputExtensions
+  fr auf X11 basierende Joysticks in Xfree86 aktivieren ?</A>
+<LI><a HREF="xmame-gdoc-3.html#ss3.21" name="toc3.21">3.21 </a><A HREF="xmame-gdoc-3.html#ss3.21"> Wie lese ich eine manual page?</A>
+<LI><a HREF="xmame-gdoc-3.html#ss3.22" name="toc3.22">3.22 </a><A HREF="xmame-gdoc-3.html#ss3.22"> Warum bekomme ich &quot;get gz_open symbol not found&quot;
+  beim bersetzen ? </A>
+<LI><a HREF="xmame-gdoc-3.html#ss3.23" name="toc3.23">3.23 </a><A HREF="xmame-gdoc-3.html#ss3.23"> Warum bekomme ich &quot;get zlib.h not
+  found&quot; ? </A>
+<LI><a HREF="xmame-gdoc-3.html#ss3.24" name="toc3.24">3.24 </a><a HREF="xmame-gdoc-3.html#ss3.24"> Wenn ich xmame.x11 starte, passiert
+  nichts -- kein Fenster geht auf</a>
+<LI><a HREF="xmame-gdoc-3.html#ss3.25" name="toc3.25">3.25 </a><a HREF="xmame-gdoc-3.html#ss3.25"> Wo bekomme ich die neueste Version
+  von XMame/XMess her ?</a>
+<LI><a HREF="xmame-gdoc-3.html#ss3.26" name="toc3.26">3.26</a> <a HREF="xmame-gdoc-3.html#ss3.26">Wohin kann ich Korrekturen,
+  Fehlermeldungen, Anregungen oder Geld ;-) hinschicken ?</a>
+<LI><a HREF="xmame-gdoc-3.html#ss3.27" name="toc3.27">3.27</a> <a HREF="xmame-gdoc-3.html#ss3.27">Was kann ich tun, wenn meine Frage
+  hier noch nicht beantwortet ist ?</a>
+</UL>
+<P>
+&nbsp;
+<H2><A NAME="toc4">4.</A>   <A HREF="xmame-gdoc-4.html">Kommentare und Anmerkungen
+zu speziellen Anzeigearten</A></H2>
+
+<UL>
+<LI><a HREF="xmame-gdoc-4.html#ss4.1" name="toc4.1">4.1 </a><A HREF="xmame-gdoc-4.html#ss4.1"> FXMame, ein Glide Treiber fr XMame</A>
+<LI><a HREF="xmame-gdoc-4.html#ss4.2" name="toc4.2">4.2 </a><A HREF="xmame-gdoc-4.html#ss4.2"> GLMame, ein OPENGL Treiber fr XMame</A>
+</UL>
+<P>
+<H2><A NAME="toc5">5.</A> <A HREF="xmame-gdoc-5.html">Kontaktinformationen und
+Danksagungen</A></H2>
+
+<UL>
+<LI><a name="toc5.1">5.1 </a><A HREF="xmame-gdoc-5.html#ss5.1"> Mail </A>
+<LI><a HREF="xmame-gdoc-5.html#ss5.2" name="toc5.2">5.2 </a><A HREF="xmame-gdoc-5.html#ss5.2"> Danksagungen (Credits)</A>
+</UL>
+<P>
+<H2><A NAME="toc6">6.</A>  <A HREF="xmame-gdoc-6.html">Anmerkungen zur Legalitt
+und Copyrights fr Mame/Mess</A></H2>
+
+<P>
+<H2><A NAME="toc7">7.</A>  <A HREF="xmame-gdoc-7.html">Einige Links</A></H2>
+
+<UL>
+<LI><A NAME="toc7.1">7.1</A>  <a HREF="xmame-gdoc-7.html#ss7.1">Unix Sourcen und
+  Anleitung</a>
+<LI><A NAME="toc7.2">7.2</A>  <a HREF="xmame-gdoc-7.html#ss7.2">Unix binaries</a>
+<LI><A NAME="toc7.3">7.3</A>  <a HREF="xmame-gdoc-7.html#ss7.3">XMame/XMess
+  Mirrors zum Download</a>
+<LI><A NAME="toc7.4">7.4</A>  <a HREF="xmame-gdoc-7.html#ss7.4">(X)Mame Frontends</a>
+<LI><A NAME="toc7.5">7.5</A>  <a HREF="xmame-gdoc-7.html#ss7.5">Einige andere Links<br>
+  </a>
+</UL>
+<H2><a NAME="toc8">8.</a> <a HREF="xmame-gdoc-8.html">nderungshistorie</a></H2>
+
+<UL>
+<LI><a name="toc8.1">8.1</a> <a href="xmame-gdoc-8.html#ss8.1"> Die nderungshistorie von Mame/Mess</a>
+<LI><a name="toc8.2">8.2</a> <a href="xmame-gdoc-8.html#ss8.2">Die nderungshistorie von Unix</a>
+</UL>
+<HR>
+<A HREF="xmame-gdoc-1.html"><br>
+<br>
+Weiter</A> Zurck Inhalt
+</BODY>
+</HTML>
diff --git a/src/unix/doc/xmame.6 b/src/unix/doc/xmame.6
new file mode 100644
index 0000000..f7af31e
--- /dev/null
+++ b/src/unix/doc/xmame.6
@@ -0,0 +1,527 @@
+.\"  -*- nroff -*-
+.\"
+.\" xmame.6
+.\"
+.\" Done by Ren Herrmann <rene.herrmann@berlin.de>, September 2000
+.\" Updated by Andrew Burton <burtona@gol.com>, July 2003
+.\"
+.\" xmame should be distributed under terms of the license in
+.\" readme.mame.
+.\" The main issue involves ROM images. ROM images are protected under the
+.\" copyrights of their authors, and CANNOT be distributed in the same
+.\" package as xmame. Download any ROM images at your own risk and
+.\" responsibility.
+.\"
+.TH Xmame 6 "10 July 2003" "0.71" "xmame"
+.Sh NAME
+xmame \- THE Arcade game machine emulator for UNIX/X
+.Sh SYNOPSIS
+.B xmame
+.RB [ .x11 | svga | xgl | sdl ]
+.RI [\| options \|] 
+.RI [\| rom \|]
+.PP
+Use "xmame[ .x11 | svga | xgl | sdl ] -help" to display a complete list of current options.
+.Sh DESCRIPTION
+.B xmame
+is the (M)ulti (A)rcade (M)achine (E)mulator for Unix. It emulates the hardware of many classic arcade game machines.
+.PP
+MAME is an arcade machine emulator. Started in 1997 by Nicola Salmoria, MAME started out as a series of emulators for individual games. This series of emulators was combined into a simgle multi-game emulator. This is the current form of MAME; no longer a one-man show, there are over 100 contributors to the project.
+.Sh OPTIONS
+.SS Digital sound related
+.TP
+.BI \-dp\  plugin ,\ \-dsp-plugin\  plugin
+Select which plugin to use for digital sound
+.TP
+.B \-ldp, \-list-dsp-plugins
+List available sound-dsp plugins
+.TP
+.B \-[no]ti, \-[no]timer
+Toggle timer based audio (normally it will be used automatically when necessary)
+.SS Sound mixer related
+.TP
+.BI \-smp\  plugin ,\ \-sound-mixer-plugin\  plugin
+Select which plugin to use for the sound mixer  
+.TP                                           
+.B \-lmp, \-list-mixer-plugins
+List available sound-mixer plugins
+.SS Video related
+.TP
+.BI \-b\  depth ,\ \-bpp\  depth
+Specify the colordepth the core should render, one of: auto(0), 8, 16
+.TP
+.BI \-ah\  height ,\ \-arbheight\  depth
+Scale video to exactly this height (0 = disable)
+.TP
+.BI \-heightscale\  yaspect ,\ \-hs\  yaspect
+Set Y-Scale aspect ratio
+.TP
+.BI \-ws\  xaspect ,\ \-widthscale\  xaspect
+Set X-Scale aspect ratio
+.TP
+.BI \-s\  scale ,\ \-scale\  scale
+Set X-Y Scale to the same aspect ratio. For vector games scale (and also width- and height-scale) may have value's like 1.5 and even 0.5. For scaling of regular games this will be rounded to an integer value.
+.TP
+.BI \-ef\  effect ,\ \-effect\  effect
+Video effect:
+0 = none (default)
+1 = scale2x (smooth scaling effect)
+2 = scan2 (light scanlines)
+3 = rgbstripe (3x2 rgb vertical stripes)
+4 = rgbscan (2x3 rgb horizontal scanlines)
+5 = scan3 (3x3 deluxe scanlines)
+.TP
+.B \-[no]adb, \-[no]autodouble
+Enable/disable automatic scale doubling for 1:2 pixel aspect ratio games                        
+.TP
+.B \-[no]sl, \-[no]scanlines
+Enable/disable displaying simulated scanlines
+.TP
+.B \-[no]art, \-[no]artwork
+Use additional game artwork (sets default for specific options below).
+.TP
+.B \-[no]backdrop, \-[no]use_backdrops
+Use backdrop artwork.                            
+.TP
+.B \-[no]overlay, \-[no]use_overlays
+Use overlay artwork.
+.TP
+.B \-[no]bezel, \-[no]use_bezels
+Use bezel artwork.
+.TP
+.B \-[no]artcrop, \-[no]artwork_crop
+Crop artwork to game screen only.               
+.TP
+.BI \-artres\  res ,\ \-artwork_resolution\  res
+Artwork resolution (0 for auto)
+.TP
+.BI \-fsr\  skip ,\ \-frameskipper\  skip
+Select which autoframeskip and throttle routines to use. Available choices are:
+0 DOS frameskip code
+1 Enhanced frameskip code by William A. Barath
+.TP
+.B \-[no]th, \-[no]throttle
+Enable/disable throttle
+.TP
+.BI \-ftr\  frames ,\ \-frames_to_run\  frames
+Sets the number of frames to run within the game                                            
+.TP
+.B \-[no]si, \-[no]sleepidle
+Enable/disable sleep during idle
+.TP
+.B \-[no]afs, \-[no]autoframeskip
+Enable/disable autoframeskip
+.TP
+.BI \-mafs\  maxskip ,\ \-maxautoframeskip\  maxskip
+Set highest allowed frameskip for autoframeskip
+.TP
+.BI \-fs\  skip ,\ \-frameskip\  skip
+Set frameskip when not using autoframeskip      
+.TP
+.BI \-brt\  brightness ,\ \-brightness\  brightness
+Set the brightness correction (0.5 - 2.0)       
+.TP
+.BI \-pb\  pause ,\ \-pause_brightness\  pause
+Additional pause brightness (float)                                                    
+.TP
+.BI \-gc\  gamma ,\ \-gamma\  gamma
+Set the gamma correction (0.5 - 2.0)
+.TP
+.B \-[no]nr, \-[no]norotate
+Do not apply rotation                           
+.TP
+.B \-[no]rr, \-[no]ror
+Rotate screen clockwise
+.TP
+.B \-[no]rl, \-[no]rol
+Rotate screen counter-clockwise                 
+.TP
+.B \-[no]autoror
+Automatically rotate screen clockwise for vertical games                                  
+.TP
+.B \-[no]autorol
+Automatically rotate screen counter-clockwise for vertical games                              
+.TP
+.B \-[no]fx, \-[no]flipx
+Flip screen left-right                          
+.TP
+.B \-[no]fy, \-[no]flipy
+Flip screen upside-down
+.SS Vector related
+.TP
+.BI \-vres\  vres ,\ \-vectorres\  vres
+Always scale vectorgames to XresxYres, keeping their aspect ratio. This overrides the scale options.
+.TP
+.BI \-B\  beam ,\ \-beam\  beam
+Set the beam size for vector games (float)
+.TP
+.BI \-f\  flicker ,\ \-flicker\  flicer
+Set the flicker size for vector games (float)
+.TP
+.BI \-intensity\  intensity
+Set intensity in vector games (float)
+.TP
+.B \-[no]aa, \-[no]antialias
+Enable/disable antialiasing                     
+.TP
+.B \-[no]t, \-[no]translucency
+Enable/disable tranlucency                      
+.SS X11 related
+.TP
+.BI \-x11\  mode ,\ \-x11-mode
+Select x11 video mode: (if compiled in)
+0 Normal window (hotkey left-alt + insert)
+1 Fullscreen DGA (hotkey left-alt + home)       
+.SS X11-window related
+.TP
+.B \-[no]cu, \-[no]cursor
+Show/don't show the cursor
+.TP
+.B \-[no]ms, \-[no]mitshm
+Use/don't use MIT Shared Mem (if available and compiled in)                                    
+.TP
+.B \-[no]xv, \-[no]xvext
+Use/don't use Xv extension for hardware scaling (if available and compiled in))                 
+.TP
+.B \-[no]fullscreen
+Start in fullscreen mode                        
+.TP
+.B \-[no]yuv
+Force YUV mode (for video cards with broken RGB hwscales)
+.TP
+.B \-[no]yv12
+Force YV12 mode (for video cards with broken RGB hwscales)
+.TP
+.B \-[no]xs, \-[no]xsync
+Use/don't use XSync instead of XFlush as screen refresh method                                  
+.TP
+.B \-[no]p, \-[no]privatecmap
+Enable/disable use of private color map         
+.TP
+.B \-[no]x, \-[no]xil
+Enable/disable use of XIL for scaling (if available and compiled in)                      
+.TP
+.B \-[no]mtx, \-[no]mtxil
+Enable/disable multi threading of XIL           
+.TP
+.B \-[no]root, \-[no]run-in-root-window
+Enable/disable running in root window           
+.TP
+.BI \-rid\  window ,\ \-root_window_id\  window
+Create the xmame-window in an alternate root-window, mostly useful for frontends
+.TP
+.BI \-geometry\  location ,\ \-geo\  location
+Specify the location of the window (string)
+.SS Video mode selection related
+.TP
+.B \-[no]ka, \-[no]keepaspect
+Try / don't try to keep the aspect ratio of a game when selecting the best videomode          
+.TP
+.BI \-dar\  ratio ,\ \-displayaspectratio\  ratio
+Set the display aspect ratio of your monitor (float). This is used for
+.B -keepaspect
+The default is 1.33 (4/3). Use 0.75 (3/4) for a portrait monitor
+.TP
+.BI \-dm\  disable ,\ \-disablemode\  disable
+Don't use mode XRESxYRESxDEPTH. This can be used to disable specific video modes which don't work on your system. The xDEPTH part of the string is optional. This option may be used more then once                                  
+.SS X11-input related
+.TP
+.B \-[no]gm, \-[no]grabmouse
+Enable/disable mousegrabbing (also alt + pagedown)                                       
+.TP
+.B \-[no]gkb, \-[no]grabkeyboard
+Enable/disable keyboardgrabbing (also alt + pageup)                                         
+.TP
+.B \-[no]wk, \-[no]winkeys
+Enable/disable mapping of Windows keys under X
+.TP
+.BI \-mk\  keymap ,\ \-mapkey\  keymap
+Set a specific key mapping, see xmamerc.dist
+.SS Sound related
+.TP
+.B \-[no]snd, \-[no]sound
+Enable/disable sound (if available)
+.TP
+.B \-[no]sam, \-[no]samples
+Use/don't use samples (if available)
+.TP
+.B \-fsnd, \-fakesound
+Generate sound even when sound is disabled. This is needed for some games which won't run without sound
+.TP
+.BI \-sf\  freq ,\ \-samplefreq\  freq
+Set the playback sample-frequency/rate          
+.TP
+.BI \-bs\  buffer ,\ \-bufsize\  buffer
+Number of frames of sound to buffer (float)
+.TP
+.BI \-v\  volume ,\ \-volume\  volume
+Set volume to an integer decibal level, (-32 (soft) - 0(loud))
+.TP
+.BI \-ad\  device ,\ \-audiodevice\  device
+Use an alternative audiodevice
+.TP
+.BI \-md\  mixer ,\ \-mixerdevice\  mixer
+Use an alternative mixerdevice                  
+.SS Input related
+.TP
+.BI \-jt\  joy ,\ \-joytype\  joy
+Select type of joystick support to use:
+0 No joystick
+1 i386 style joystick driver (if compiled in)
+2 Fm Town Pad support (if compiled in)
+3 X11 input extension joystick (if compiled in)
+4 new i386 linux 1.x.x joystick driver(if compiled in)
+5 NetBSD USB joystick driver (if compiled in)
+6 PS2-Linux native pad (if compiled in)
+7 SDL joystick driver                           
+.TP
+.B \-[no]as, \-[no]analogstick
+Use joystick as analog for analog controls
+.TP
+.BI \-jdev\  device ,\ \-joydevname\  device
+Joystick device prefix (defaults to /dev/js)
+.TP
+.B \-[no]m, \-[no]mouse
+Enable/disable mouse (if supported)
+.TP
+.B \-[no]ugcicoin
+Enable/disable UGCI(tm) Coin/Play support
+.TP
+.B \-[no]pspad, \-[no]usbpspad
+Enable/disable USB PS Game Pad joystick support
+.TP
+.B \-[no]rapidf, \-[no]rapidfire
+Enable/disable rapid-fire support for joysticks         
+.TP
+.B \-ctrlr\  controller
+Preconfigure for specified controller, e.g., HotRod, HotRodSE, SlikStik, XArcade
+.SS File I/O related
+.TP
+.BI \-rp\  rompath ,\ \-rompath\  rompath
+Search path for ROM files
+.TP
+.BI \-sp\  samplepath ,\ \-samplepath\  samplepath
+Search path for sample files
+.TP
+.BI \-inipath\ inipath
+Search path for ini files
+.TP
+.BI \-cfg_directory\  cfgpath
+Directory to save configurations
+.TP
+.BI \-nvram_directory\  nvrampath
+Directory to save nvram contents
+.TP
+.BI \-memcard_directory\  memcardpath
+Directory to save memory card contents
+.TP
+.BI \-input_directory\  inputpath
+Directory to save input device logs
+.TP
+.BI \-hiscore_directory\  hipath
+Directory to save hiscores
+.TP
+.BI \-state_directory\  statepath
+Directory to save states
+.TP
+.BI \-artwork_directory\  artpath
+Directory for artwork (overlays etc.)
+.TP
+.BI \-snapshot_directory\  screenshotpath
+Directory for screenshots (.png format)
+.TP
+.BI \-diff_directory\  diffpath
+Directory for hard drive image difference files
+.TP
+.BI \-ctrlr_directory\  controllerpath
+Directory to save controller definitions
+.TP
+.BI \-cheat_file\  cheatfile
+Cheat filename
+.TP
+.BI \-hiscore_file\  hifile
+.TP
+.BI \-history_file\  historyfile
+.TP
+.BI \-mameinfo_file\  mameinfofile
+.TP
+.BI \-rec\  keyfile ,\ \-record\  keyfile
+Set a file to record keypresses into
+.TP
+.BI \-pb\  playfile ,\ \-playback\  playfile
+Set a file to playback keypresses from
+.TP
+.BI \-out\  stdout ,\ \-stdout-file\  stdout
+Set a file to redirect stdout to
+.TP
+.BI \-err\  stderr ,\ \-stderr-file\  stderr
+Set a file to redirect stderr to
+.TP
+.BI \-L\  logfile ,\ \-log\  logfile
+Set a file to log debug info to                 
+.SS MAME related
+.TP
+.BI \-def\  defaultgame ,\ \-defaultgame\  defaultgame
+Set the default game started when no game is given on the commandline, only useful for the config files.
+.TP
+.BI \-lang\  language ,\ \-language\  language
+Select the language for the menus and OSD
+.TP
+.B \-[no]fc, \-[no]fuzzycmp
+Enable/disable use of fuzzy gamename matching when there is no exact match
+.TP
+.B \-[no]c, \-[no]cheat
+Enable/disable cheat subsystem
+.TP
+.B \-[no]skip_disclaimer
+Skip displaying the disclaimer screen
+.TP
+.B \-[no]skip_gameinfo
+Skip displaying the game info screen     
+.TP
+.B \-[no]crconly
+Use only CRC for all integrity checks
+.TP
+.BI \-bios\  bios
+Change system bios (int)
+.SS Frontend related
+.TP
+.B \-l, \-list
+List supported games matching gamename, or all, gamename may contain * and ? wildcards
+.TP
+.B \-lf, \-listfull
+Like -list, with full description
+.TP
+.B \-lg, \-listgames
+Like -list, with manufacturer and year
+.TP
+.B \-ld, \-listdetails
+Like -list, with detailed info
+.TP
+.B \-lgl, \-listgamelist
+Like -list, with specialy formatted extra info for generating gamelist.mame
+.TP
+.B \-lsf, \-listsourcefile
+Like -list, with driver sourcefile
+.TP
+.B \-lcol, \-listcolors
+Like -list, with the number of colors used
+.TP
+.B \-lrs, \-listromsize
+Like -list, with the year and size of the ROMs used                                            
+.TP
+.B \-lps, \-listpalettesize
+Like -list, with the year and palette size of the roms used                                   
+.TP
+.B \-lr, \-listroms
+Like -list, but lists used ROMs
+.TP
+.B \-lcrc, \-listcrc
+Like -list, but lists used ROMs with CRC-32s
+.TP
+.B \-lsha1, \-listsha1
+Like -list, but lists used ROMs with SHA-1s
+.TP
+.B \-lmd5, \-listmd5
+Like -list, but lists used ROMs with MD5s
+.TP
+.B \-ls, \-listsamples
+Like -list, but lists used audio samples
+.TP
+.B \-lsd, \-listsamdir
+Like -list, but lists dir where samples are taken from                                      
+.TP
+.B \-vr, \-verifyroms
+Verify ROMs for games matching gamename, or all, gamename may contain * and ? wildcards
+.TP
+.B \-vrs, \-verifyromsets
+Like -verifyroms, but less verbose
+.TP
+.B \-vs, \-verifysamples
+Like -verifyroms but verify audio samples instead                                         
+.TP
+.B \-vss, \-verifysamplesets
+Like -verifysamples, but less verbose
+.TP
+.B \-[no]cl, \-[no]clones
+Show / don't show bootlegs/clones in the above list commands
+.TP
+.B \-lcl, \-listclones
+Like -list, but lists the clones of the specified game
+.TP
+.B \-li, \-listinfo
+List all available info on drivers
+.TP
+.B \-lc, \-listcpu
+List CPU usage statics per year
+.SS Internal verification list commands (only for developers)
+.TP
+.B \-ldc, \-listdupcrc
+Like -list, but lists ROMs with identical CRC
+.TP
+.B \-lwo, \-listwrongorientation
+Like -list, but lists any games which use the orientation flags wrongly
+.TP
+.B \-lwm, \-listwrongmerge
+Like -list, but lists any games which use the clone_of field wrongly
+.TP
+.B \-lwf, \-listwrongfps
+Like -list, but lists any games which use the FPS field wrongly
+.TP
+.B \-srtn, \-sortname
+Sort ROMs by name
+.TP
+.B, \-srtd, \-sortdriver
+Sort ROMs by driver name
+.SS ROM identification related
+.TP
+.B \-id, \-ident
+Identify unknown ROM dump, or unknown ROM dumps in dir/zip                                      
+.TP
+.B \-ik, \-isknown
+Check if romdump or romdumps in dir/zip are known                                           
+.SS General options
+.TP
+.B \-[no]lcf, \-[no]loadconfig
+Enable/disable loading of config files                   
+.TP
+.B \-sc, \-showconfig
+Display running parameters in rc style
+.TP
+.B \-mh, \-manhelp
+Print commandline help in man format, useful for manpage creation                            
+.TP
+.B \-V, \-version
+Display version
+.TP
+.B \-?, \-help
+Show help
+.Sh EXAMPLES
+.Sh LEGAL NOTICE
+The main issue involves ROM images. ROM images are protected under the copyrights of their authors, and CANNOT be distributed in the same package as xmame. Download any ROM images at your own risk and responsibility.
+.PP
+.B PLEASE BE AWARE OF THE POSSIBLE LEGAL RAMIFICATIONS OF DOWNLOADING ROM IMAGES, BEFORE YOU ACTUALLY DO SO! YOU HAVE BEEN WARNED, AND WE TAKE NO RESPONSIBILITY FOR YOUR ACTIONS -- YOU ARE ON YOUR OWN!
+.PP
+Also, the \fBxmame\fR authors ask that you DO NOT distribute any ROM images with either source code or binaries of the \fBxmame\fR emulator.
+.Sh FILES
+Config Files are parsed in the following order:
+.TP
+.I /usr/local/share/xmame/xmamerc
+Global configuration config file
+.TP
+.I ${HOME}/.xmame/xmamerc
+User configuration config file
+.TP
+.I /usr/local/share/xmame/xmame-x11rc
+Global per display method config file
+.TP
+.I ${HOME}/.xmame/xmame-x11rc
+User per display method config file
+.TP
+.I /usr/local/share/xmame/rc/<game>rc
+Global per game config file
+.TP
+.I ${HOME}/.xmame/rc/<game>rc
+User per game config file
+.Sh "SEE ALSO"
+.Sh BUGS
diff --git a/src/unix/doc/xmame.css b/src/unix/doc/xmame.css
new file mode 100644
index 0000000..a8a23ea
--- /dev/null
+++ b/src/unix/doc/xmame.css
@@ -0,0 +1,159 @@
+/* $Id: xmame.css,v 1.1 2002/06/07 04:45:05 l_g Exp $ */
+
+/*body {
+  color:             black;
+  background:        white;
+}*/
+
+a {
+/*  background:        white; */
+  color:             #3060f0;
+  font-weight:       bold;
+}
+
+/*
+a:link {
+  background:        white;
+  color:             #3838f0;
+}
+*/
+
+a:visited {
+/*  background:        white; */
+/*  color:             #702090; */
+  color:             #3060f0;
+  font-weight:       bold;
+}
+
+/*
+a:active {
+  background:        white;
+  color:             #2828f0;
+}
+*/
+
+a:hover {
+  background:        #e0e0e0;
+  color:             #cc5555;
+  font-weight:       bold;
+}
+
+span.learnmore {
+  background:        white;
+  color:             #553344;
+}
+
+.center, #logo {
+  text-align:        center;
+}
+
+p.lastupdate {
+  font-size:         xx-small;
+  margin-left:       0pt;
+  margin-right:      40pt;
+}
+
+div.banner {
+  border:            none;
+  padding:           0.2em 0.7em;
+  text-align:        center;
+  font-weight:       bold;
+}
+
+div.banner a:link, div.banner a:visited, div.banner {
+  background:        black;
+  text-decoration:   none;
+}
+
+div.banner, div.banner a:link, div.banner a:visited {
+  color:             white;
+}
+
+div.banner a:active {
+  background:        white;
+  color:             black;
+  text-decoration:   none;
+}
+
+p.small {
+  font-size:         small;
+}
+
+p.smallcenter {
+  text-align:        center;
+  font-size:         small;
+}
+
+h1 {
+  color:             black;
+  background:        rgb(150,150,255);
+  font-weight:       bold;
+  margin-top:        5pt;
+  margin-bottom:     5pt;
+}
+
+h2, h3 {
+  color:             black;
+  background:        rgb(200,200,255);
+  font-weight:       bold;
+  margin-top:        5pt;
+  margin-bottom:     9pt;
+  margin-left:       0px;
+  margin-right:      32px;
+}
+
+h4 {
+  color:             black;
+}
+
+p {
+  margin-left:       20pt;
+  margin-right:      30pt;
+  color:             black;
+}
+
+ul {
+  margin-right:      20px;
+  margin-left:       24px;
+}
+
+li {
+  margin-left:       9px;
+  color:             black;
+}
+
+#addy {
+  text-align:        center;
+  font-size:         small;
+  margin-top:        -7px;
+  font-family:       Arial, serif;
+  color:             black;
+  background:        white;
+}
+
+span.date {
+  text-decoration:   underline;
+}
+
+span.underline {
+  text-decoration:   underline;
+}
+
+.codesample {
+  font-family:       "Courier New", Courier, mono;
+}
+
+.codesampleblock {
+  font-family:       "Courier New", Courier, mono;
+  margin-left:       96px;
+  margin-right:      32px;
+}
+
+.smalltitle {
+  font-family:       verdana, san-serif;
+}
+
+.smalltext {
+  font-size:         x-small;
+  font-family:       verdana, san-serif;
+}
diff --git a/src/unix/doc/xmamerc.dist b/src/unix/doc/xmamerc.dist
new file mode 100644
index 0000000..c3925f1
--- /dev/null
+++ b/src/unix/doc/xmamerc.dist
@@ -0,0 +1,212 @@
+### xmame running parameters ###
+
+### Digital sound related ###
+# dsp-plugin            <NULL> (not set)
+timer                   0
+
+### Sound mixer related ###
+# sound-mixer-plugin    <NULL> (not set)
+
+### Video Related ###
+bpp                     0
+heightscale             1
+widthscale              1
+autodouble              1
+scanlines               0
+artwork                 1
+frameskipper            0
+throttle                1
+sleepidle               0
+autoframeskip           1
+maxautoframeskip        8
+frameskip               0
+brightness              1.000000
+gamma                   1.000000
+
+### Vector Games Related ###
+# vectorres             <NULL> (not set)
+beam                    1.000000
+flicker                 0.000000
+antialias               1
+translucency            1
+
+### X11 Related ###
+x11-mode                0
+
+### X11-window Related ###
+cursor                  1
+mitshm                  1
+xsync                   1
+privatecmap             0
+xil                     1
+mtxil                   0
+run-in-root-window      0
+root_window_id          0
+geometry                640x480
+
+### XFree86 DGA Related ###
+
+### Video Mode Selection Related ###
+keepaspect              1
+displayaspectratio      1.330000
+
+### X11-input related ###
+grabmouse               0
+winkeys                 0
+
+### Sound Related ###
+sound                   1
+samples                 1
+samplefreq              22050
+bufsize                 3.000000
+volume                  -3
+# audiodevice           <NULL> (not set)
+# mixerdevice           <NULL> (not set)
+
+### Input Related ###
+joytype                 0
+analogstick             0
+mouse                   1
+
+### Fileio Related ###
+rompath                 /usr/local/share/xmame/roms
+snapshot_directory      .
+cheat_file              /usr/local/share/xmame/cheat.dat
+hiscore_file            /usr/local/share/xmame/hiscore.dat
+history_file            /usr/local/share/xmame/history.dat
+mameinfo_file           /usr/local/share/xmame/mameinfo.dat
+
+### Mame Related ###
+defaultgame             pacman
+language                english
+fuzzycmp                1
+cheat                   0
+# debug                   0
+
+### Frontend Related ###
+clones                  1
+
+### Internal verification list commands (only for developers) ###
+
+### Rom Identification Related ###
+
+### General Options ###
+
+### X11 keymapping ###
+#
+# mapkey	<Xcode>,<Scancode>
+#
+# Xcode means the HEX code of the key as appears in /usr/include/X11/keysymdef.h
+# Scancode means the hexadecimal code that represents the value used for Xmame
+# 	in keyboard inputs, as defined in src/unix/keyboard.h xmame source file
+# IMPORTANT: 
+#	1- Due to some limitations, only LATIN-1 X-codes ( 0x0000-0x00ff ) and
+#	Especial X-keycodes ( 0xff00-0xffff ) are supported
+#	2- Some keys are keyboard dependent: As Xmame works internally with
+#	Standard US-AT keyboard codes, you must take care in remmaping some keys
+#
+
+# An example: map space as "firebutton" (Mame predefines it as KEY_LCONTROL)
+# in symbolic Xlib/Mame notation it should be:
+#
+# mapkey XK_space,KEY_LCONTROL 
+# 
+# So, looking in X11/keysymdef.h and src/unix/keyboard.h, we'll write
+# mapkey 0x0020,0x001d
+#
+# (Other example). To use the F8 key to insert a coin, you should use
+# mapkey 0xffc5,0x0006
+
+### Suggested German keymap mods by Peter Trauner.
+#   <peter.trauner@jk.uni-linz.ac.at>
+#
+#mapkey 0xfe52,0x0029
+#mapkey 0x00df,0x000c
+#mapkey 0xfe51,0x000d
+#mapkey 0x00fc,0x001a
+#mapkey 0x002b,0x001b
+#mapkey 0x00f6,0x0027
+#mapkey 0x00e4,0x0028
+#mapkey 0x0023,0x002b
+#mapkey 0x0059,0x002c
+#mapkey 0x005a,0x0015
+#mapkey 0x002d,0x0035
+
+### SDL keymapping ###
+#
+# sdlmapkey	<SDLcode>,<Scancode>
+#
+# SDLcode means the HEX code of the key as it appears in 
+#       include/SDL/SDL_keysym.h
+# Scancode means the hexadecimal code that represents the value used for Xmame
+# 	in keyboard inputs, as defined in src/unix/keyboard.h xmame source file
+#
+
+# An example: map space as "firebutton" (Mame predefines it as KEY_LCONTROL)
+# in symbolic SDL/Mame notation it should be:
+#
+# sdlmapkey SDLK_SPACE,KEY_LCONTROL 
+# 
+# So, looking in X11/keysymdef.h and src/unix/keyboard.h, we'll write
+# sdlmapkey 0x0020,0x001d
+#
+# (Other example). To use the F8 key to insert a coin, you should use
+# sdlmapkey 0x0121,0x0006
+
+### Suggested French (azerty) SDL keymap mods by Luc Saillard.
+#
+#   SDLK_WORLD_18  => KEY_TILDE
+#sdlmapkey 0x00b2,0x0029
+#   SDLK_AMPERSAND  => KEY_1
+#sdlmapkey 0x0026,0x0002
+#   SDLK_WORLD_73  => KEY_2
+#sdlmapkey 0x00e9,0x0003
+#   SDLK_QUOTEDBL   => KEY_3
+#sdlmapkey 0x0022,0x0004
+#   SDLK_QUOTE      => KEY_4
+#sdlmapkey 0x0027,0x0005
+#   SDLK_LEFTPAREN  => KEY_5
+#sdlmapkey 0x0028,0x0006
+#   SDLK_MINUS      => KEY_6
+#sdlmapkey 0x002d,0x0007
+#   SDLK_WORLD_73  => KEY_7
+#sdlmapkey 0x00e8,0x0008
+#   SDLK_UNDERSCORE => KEY_8
+#sdlmapkey 0x005f,0x0009
+#   SDLK_WORLD_71  => KEY_9
+#sdlmapkey 0x00e7,0x000a
+#   SDLK_WORLD_64  => KEY_10
+#sdlmapkey 0x00e0,0x000b
+#   SDLK_RIGHTPAREN => KEY_11
+#sdlmapkey 0x0029,0x000c
+#   SDLK_EQUALS     => KEY_12
+#sdlmapkey 0x003d,0x000d
+
+#   SDLK_A          => KEY_Q
+#sdlmapkey 0x0041,0x0010
+#   SDLK_Z          => KEY_W
+#sdlmapkey 0x005a,0x0011
+#   SDLK_CARET      => KEY_OPENBRACE
+#sdlmapkey 0x005e,0x001a
+#   SDLK_DOLLAR     => KEY_CLOSEBRACE
+#sdlmapkey 0x0024,0x001b
+
+#   SDLK_Q          => KEY_A
+#sdlmapkey 0x0051,0x001e
+#   SDLK_M          => KEY_COLON
+#sdlmapkey 0x004d,0x0027
+#   SDLK_WORLD_89  => KEY_QUOTE
+#sdlmapkey 0x00f9,0x0028
+#   SDLK_ASTERISK   => KEY_TILDE
+#sdlmapkey 0x002a,0x0029
+
+#   SDLK_W          => KEY_Z
+#sdlmapkey 0x0057,0x002c
+#   SDLK_COMMA      => KEY_M
+#sdlmapkey 0x002c,0x0032
+#   SDLK_SEMICOLON  => KEY_COMMA
+#sdlmapkey 0x003b,0x0033
+#   SDLK_COLON      => KEY_STOP
+#sdlmapkey 0x003a,0x0034
+#   SDLK_EXCLAIM    => KEY_SLASH
+#sdlmapkey 0x0021,0x0035
diff --git a/src/unix/doc/xmess.6 b/src/unix/doc/xmess.6
new file mode 100644
index 0000000..d4d6f8c
--- /dev/null
+++ b/src/unix/doc/xmess.6
@@ -0,0 +1,581 @@
+.\"  -*- nroff -*-
+.\"
+.\" xmame.6
+.\"
+.\" Done by Ren Herrmann <rene.herrmann@berlin.de>, September 2000
+.\"
+.\" xmame should be distributed under terms of the license in
+.\" readme.mame.
+.\" The main issue involves ROM images. ROM images are protected under the
+.\" copyrights of their authors, and CANNOT be distributed in the same
+.\" package as xmame. Download any ROM images at your own risk and
+.\" responsibility.
+.\"
+.Dd 02. September 2000
+.Dt Xmame 6
+.Os
+.Sh NAME
+.Nm xmame
+.Nd THE Arcade game machine emulator for UNIX/X
+.Sh SYNOPSIS
+.Nm xmame[.x11|svga]
+.Op Fl options
+.Ar gamename
+.Sh EXAMPLES
+Some examples for those who are in a hurry.
+
+If you don't have/want a frontend, you'll mostly use
+.Nm xmame
+(with a well defined xmamerc) in the following way:
+
+.Nm xmame
+.Ar ladybug
+
+Plays Ladybug with all options defined in xmamerc. If there is no xmamerc the 
+game starts with the buildin defaults.
+
+.Nm xmame
+.Ar defender
+.Fl frameskip Ar 1
+.Fl cheat
+
+Starts
+.Ar defender
+using a frameskip of 1 and cheat is enabled.
+Useful for slower computers, if the game is running really slowly.
+And of course if you want (have?) to cheat. ;-)
+.Sh LEGAL NOTICE
+The main issue involves ROM images. ROM images are protected under the
+copyrights of their authors, and CANNOT be distributed in the same
+package as xmame. Download any ROM images at your own risk and
+responsibility.
+
+.Nm xmame
+should be distributed under terms of the license in doc/readme.mame
+
+XInputExtensions based Joystick support. Source code is entirely pure 
+hack work. No sample code, no info at all was found (only library 
+reference manual) and is copyrighted by me (Juan Antonio Marmnez).
+Use it under terms of GNU General Public License.
+
+PLEASE BE AWARE OF THE POSSIBLE LEGAL RAMIFICATIONS OF DOWNLOADING ROM
+IMAGES, BEFORE YOU ACTUALLY DO SO!  YOU HAVE BEEN WARNED, AND WE TAKE NO
+RESPONSIBILITY FOR YOUR ACTIONS -- YOU ARE ON YOUR OWN!
+
+Also, the
+.Nm xmame 
+authors ask that you DO NOT distribute any ROM images with either source
+code or binaries of the
+.Nm xmame
+emulator.
+.Sh DESCRIPTION
+.Nm xmame 
+is the (M)ulti (A)rcade (M)achine (E)mulator for UNIX-(X).  It emulates
+the hardware of realy many classic arcade game machines.
+
+Most games allow you to specify one or more options to control the behavior of
+.Nm xmame
+and the game of your choice. Below is a complete list of all the available
+options:
+.Bl -tag -width Ds
+.It \fB*** Digital sound related ***\fR
+.It Fl dsp-plugin , dp Ar string
+Select which plugin to use for digital sound
+.It Fl list-dsp-plugins , ldp
+List available sound-dsp plugins
+.It Fl [no]timer , [no]ti
+Use / don't use timer based audio (normally it will be used automagicly when nescesarry)
+.It \fB*** Sound mixer related ***\fR
+.It Fl sound-mixer-plugin , smp Ar string
+Select which plugin to use for the sound mixer
+.It Fl list-mixer-plugins , lmp
+List available sound-mixer plugins
+.It \fB*** Video Related ***\fR
+.It Fl bpp , b Ar int
+Specify the colordepth the core should render, one of: auto(0), 8, 16
+.It Fl heightscale , hs Ar int
+Set Y-Scale aspect ratio
+.It Fl widthscale , ws Ar int
+Set X-Scale aspect ratio
+.It Fl scale , s Ar arg
+Set X-Y Scale to the same aspect ratio. For vector games scale (and also width- and heightscale) may have value's like 1.5 and even 0.5. For scaling of regular games this will be rounded to an int
+.It Fl [no]autodouble , [no]adb
+Enable/disable automatic scale doubling for 1:2 pixel aspect ratio games
+.It Fl [no]dirty , [no]dt
+Enable/disable use of dirty rectangles
+.It Fl [no]scanlines , [no]sl
+Enable/disable displaying simulated scanlines
+.It Fl [no]artwork , [no]a
+Use/don't use artwork if available
+.It Fl frameskipper , fsr Ar int
+Select which autoframeskip and throttle routines to use. Available choices are:
+0 Dos frameskip code
+1 Enhanced frameskip code by William A. Barath
+.It Fl [no]throttle , [no]th
+Enable/disable throttle
+.It Fl [no]sleepidle , [no]si
+Enable/disable sleep during idle
+.It Fl [no]autoframeskip , [no]afs
+Enable/disable autoframeskip
+.It Fl maxautoframeskip , mafs Ar int
+Set highest allowed frameskip for autoframeskip
+.It Fl frameskip , fs Ar int
+Set frameskip when not using autoframeskip
+.It Fl brightness , brt Ar int
+Set the brightness (0-100%%)
+.It Fl gamma-correction , gc Ar float
+Set the gamma-correction (0.5-2.0)
+.It Fl norotate , nr
+Disable rotation
+.It Fl ror , rr
+Rotate display 90 degrees rigth
+.It Fl rol , rl
+Rotate display 90 degrees left
+.It Fl flipx , fx
+Flip X axis
+.It Fl flipy , fy
+Flip Y axis
+.It \fB*** Vector Games Related ***\fR
+.It Fl vectorres , vres Ar string
+Always scale vectorgames to XresxYres, keeping their aspect ratio. This overrides the scale options
+.It Fl beam , B Ar float
+Set the beam size for vector games
+.It Fl flicker , f Ar float
+Set the flicker for vector games
+.It Fl [no]antialias , [no]aa
+Enable/disable antialiasing
+.It Fl [no]translucency , [no]t
+Enable/disable tranlucency
+.It \fB*** X11 Related ***\fR
+.It Fl x11-mode , x11 Ar int
+Select x11 video mode: (if compiled in)
+0 Normal window  (hotkey left-alt + insert)
+1 Fullscreen DGA (hotkey left-alt + home)
+.It \fB*** X11-window Related ***\fR
+.It Fl [no]cursor , [no]cu
+Show/ don't show the cursor
+.It Fl [no]mitshm , [no]ms
+Use / don't use MIT Shared Mem (if avaiable and compiled in)
+.It Fl [no]xsync , [no]xs
+Use / don't use XSync instead of XFlush as screen refresh method
+.It Fl [no]privatecmap , [no]p
+Enable/disable use of private color map
+.It Fl [no]xil , [no]x
+Enable/disable use of XIL for scaling (if available and compiled in)
+.It Fl [no]mtxil , [no]mtx
+Enable/disable multi threading of XIL
+.It Fl [no]run-in-root-window , [no]root
+Enable/disable running in root window
+.It Fl root_window_id , rid Ar int
+Create the xmame-window in an alternate root-window, mostly usefull for frontends!
+.It Fl geometry , geo Ar string
+Specify the location of the window
+.It \fB*** XFree86 DGA Related ***\fR
+.It \fB*** Video Mode Selection Related ***\fR
+.It Fl [no]keepaspect , [no]ka
+Try / don't try to keep the aspect ratio of a game when selecting the best videomode
+.It Fl displayaspectratio , dar Ar float
+Set the display aspect ratio of your monitor. This is used for -keepaspect The default = 1.33 (4/3). Use 0.75 (3/4) for a portrait monitor
+.It Fl disablemode , dm Ar arg
+Don't use mode XRESxYRESxDEPTH this can be used to disable specific video modes which don't work on your system. The xDEPTH part of the string is optional. This option may be used more then once
+.It \fB*** X11-input related ***\fR
+.It Fl [no]grabmouse , [no]gm
+Enable/disable mousegrabbing (also alt + pagedown)
+.It Fl [no]winkeys , [no]wk
+Enable/disable mapping of windowskeys under X
+.It Fl mapkey , mk Ar arg
+Set a specific key mapping, see xmamerc.dist
+.It \fB*** Sound Related ***\fR
+.It Fl [no]sound , [no]snd
+Enable/disable sound (if available)
+.It Fl [no]samples , [no]sam
+Use/don't use samples (if available)
+.It Fl fakesound , fsnd
+Generate sound even when sound is disabled, this is needed for some games which won't run without sound
+.It Fl samplefreq , sf Ar int
+Set the playback sample-frequency/rate
+.It Fl bufsize , bs Ar float
+Number of frames of sound to buffer
+.It Fl volume , v Ar int
+Set volume to <int> db, (-32 (soft) - 0(loud) )
+.It Fl audiodevice , ad Ar string
+Use an alternative audiodevice
+.It Fl mixerdevice , md Ar string
+Use an alternative mixerdevice
+.It \fB*** Input Related ***\fR
+.It Fl joytype , jt Ar int
+Select type of joysticksupport to use:
+0 No joystick
+1 i386 style joystick driver (if compiled in)
+2 Fm Town Pad support (if compiled in)
+3 X11 input extension joystick (if compiled in)
+4 new i386 linux 1.x.x joystick driver(if compiled in)
+5 NetBSD USB joystick driver (if compiled in)
+.It Fl [no]analogstick , [no]as
+Use Joystick as analog for analog controls
+.It Fl [no]mouse , [no]m
+Enable/disable mouse (if supported)
+.It \fB*** Fileio Related ***\fR
+.It Fl rompath , rp Ar string
+Set the rom search path
+.It Fl spooldir , sd Ar string
+Set highscore spooldir
+.It Fl screenshotdir , ssd Ar string
+Set dir to store screenshots in
+.It Fl cheatdir Ar string
+Set dir to look for cheat files in
+.It Fl crcdir Ar string
+Set dir to look for crc files in
+.It Fl cheatfile , cf Ar string
+Set the file to use as cheat database
+.It Fl hiscorefile , hif Ar string
+Set the file to use as high score database
+.It Fl historyfile , hf Ar string
+Set the file to use as history database
+.It Fl mameinfofile , mf Ar string
+Set the file to use as mameinfo database
+.It Fl record , rec Ar arg
+Set a file to record keypresses into
+.It Fl playback , pb Ar arg
+Set a file to playback keypresses from
+.It Fl stdout-file , out Ar filename
+Set a file to redirect stderr to
+.It Fl stderr-file , err Ar filename
+Set a file to redirect stdout to
+.It Fl log , L Ar filename
+Set a file to log debug info to
+.It \fB*** Mess Related ***\fR
+.It Fl rom , cart
+All following images/roms are seen as carts/roms
+.It Fl floppy
+All following images/roms are seen as floppies
+.It Fl casette
+All following images/roms are seen as casettes
+.It Fl printer
+All following images/roms are seen as carts/roms
+.It Fl serial
+All following images/roms are seen as serial ports??
+.It Fl snapshot
+All following images/roms are seen as snapshots
+.It Fl language , lang Ar string
+Select the language for the menu's and osd
+.It Fl [no]fuzzycmp , [no]fc
+Enable/disable use of fuzzy gamename matching when there is no exact match
+.It Fl [no]cheat , [no]c
+Enable/disable cheat subsystem
+.It Fl [no]debug , [no]d
+Enable/disable debugger
+.It Fl debug-size , ds Ar arg
+Specify the resolution/ windowsize to use for the debugger(window) in the form of XRESxYRES (minimum size = 640x480)
+.It \fB*** Frontend Related ***\fR
+.It Fl list , l
+List supported games matching gamename, or all, gamename may contain * and ? wildcards
+.It Fl listfull , lf
+Like -list, with full description
+.It Fl listgames , lg
+Like -list, with manufacturer and year
+.It Fl listdetails , ld
+Like -list, with detailed info
+.It Fl listgamelist , lgl
+Like -list, with specialy formatted extra info for generating gamelist.mame, also see -listgamelistheader
+.It Fl listsourcefile , lsf
+Like -list, with driver sourcefile
+.It Fl listcolors , lcol
+Like -list, with the number of colors used
+.It Fl listextensions
+Like -list, with devices and image file extensions supported
+.It Fl listromsize , lrs
+Like -list, with the year and size of the roms used
+.It Fl listroms , lr
+Like -list, but lists used ROMS
+.It Fl listcrc , lcrc
+Like -list, but lists used ROMS with crc
+.It Fl listsamples , ls
+Like -list, but lists used audio samples
+.It Fl listsamdir , lsd
+Like -list, but lists dir where samples are taken from
+.It Fl verifyroms , vr
+Verify ROMS for games matching gamename, or all, gamename may contain * and ? wildcards
+.It Fl verifyromsets , vrs
+Like -verifyroms, but less verbose
+.It Fl verifysamples , vs
+Like -verifyroms but verify audio samples instead
+.It Fl verifysamplesets , vss
+Like -verifysamples, but less verbose
+.It Fl [no]clones , [no]cl
+Show / don't show bootlegs/clones in the above list commands
+.It Fl listclones , lcl
+Like -list, but lists the clones of the specified game
+.It Fl listinfo , li
+List all available info on drivers
+.It Fl listcpu , lc
+List cpu usage statics per year
+.It Fl listgamelistheader , lgh
+Print header for generating gamelist.mame, also see -listgamelist
+.It \fB*** Internal verification list commands (only for developers) ***\fR
+.It Fl listmissingroms , lmr
+Like -list, but lists ROMS missing
+.It Fl listdupcrc , ldc
+Like -list, but lists ROMS with identical crc
+.It Fl listwrongorientation , lwo
+Like -list, but lists any games which use the orientation flags wrongly
+.It Fl listwrongmerge , lwm
+Like -list, but lists any games which use the clone_of field wrongly
+.It Fl listwrongfps , lwf
+Like -list, but lists any games which use the FPS field wrongly
+.It \fB*** Rom Identification Related ***\fR
+.It Fl ident , id
+Identify unknown romdump, or unknown romdumps in dir/zip
+.It Fl isknown , ik
+Check if romdump or romdumps in dir/zip are known
+.It \fB*** General Options ***\fR
+.It Fl [no]loadconfig , [no]lc
+Load (don't load) configfiles
+.It Fl showconfig , sc
+Display Running parameters in rc style
+.It Fl manhelp , mh
+Print commandline help in man format, usefull for manpage creation
+.It Fl version , V
+Display version
+.It Fl help , ?
+Show this help
+.It \fB*** Arguments ***\fR
+.It Ar game
+the name of the game you wish to play. You better choose one. :-)
+.El
+
+Note: There are really many options. You can set the default options and / or
+options per game in
+.Nm xmames
+config files see the RCFILES section below.
+.Sh INSTALLING GAMES
+Most game ROM images come in ZIP files.  Download the ZIP files for
+the games you want, and move them to a directory of your choice (i.e. it is
+a good idea to put them all in one dir).
+
+Note: There is no need to unzip the games in a separate directory, because
+.Nm xmame
+has zip file support through zlib.
+
+.Nm xmame
+uses a ":" seperated rompath to find out which dirs to search for
+roms/samples. The default rompath is XMAMEROOT as defined in the Makefile
+during the compilation (normaly /usr/local/share/xmame). If you put all 
+the zipped-ROM-Files in this dir everything will work automagicly.
+
+The rompath will be overwritten by any rompath in xmamerc. Which can be
+overwritten again with the -rompath commandline option.
+
+.Nm xmame
+searches every dir in this path for roms (and samples) in the following way:
+
+.TS
+tab (@);
+l l.
+<dir>/gamename.zip@(containing filename.ext)
+<dir>/gamename/filename.ext
+<dir>/gamename/filename.ext.gz@(containing filename.ext)
+<dir>/gamename/filename.zip@(containing filename.ext)
+.TE
+
+Note: If your neogeo games can't find neogeo.rom put it in a dir called
+neogeo somewhere in your rompath, or put it in neogeo.zip somewhere in
+your rompath.
+.Sh PLAYING GAMES
+After running
+.Nm xmame
+i.e.
+.Nm xmame
+.Ar ladybug
+you will see two screens.
+
+The first with a copyright message (PLEASE READ THIS!). If you type (ok)
+this screen will only come up again after the cfg-file of the game
+(romname.cfg) will be deleted.
+
+Another screen shows information about the game. Hit any key to continue.
+
+Note: If you want to see this information screen again, you could press
+\fI<TAB>\fR and select \fI<Game Information>\fR or hit \fI<ESC>\fR and
+restart. ;-)
+
+The game will then go through a `hardware self-test' (remember,
+.Nm xmame
+is emulating game HARDWARE). After the self-test, you are `in' the video game.
+Feed the hungry machine with some coins (key \fI<5>\fR for one coin)
+then start (key \fI<1>\fR) it. For more coins and player read the next section
+(KEYBOARD COMMANDS).
+
+HAVE A LOT OF FUN!
+.Sh KEYBOARD COMMANDS
+While playing a game, there are certain keyboard commands available for
+you to use.
+
+.TS
+tab (@);
+l l.
+\fBKEY@Action\fR
+<1> (the number `one')@Start a 1-player game.
+<2> (the number `two')@Start a 2-player game.
+<3> (the number `three')@Start a 3-player game.
+<4> (the number `four')@Start a 4-player game.
+<5> (the number `five')@Insert coin (slot 1).
+<6> (the number `six')@Insert coin (slot 2).
+<7> (the number `seven')@Insert coin (slot 3).
+<8> (the number `eight')@Insert coin (slot 4).
+<Tab>@Toggles the configuration menu.
+<~> (Tilde)@Toggles the `On Screen Display'.
+@Use the up and down arrow keys to select
+@the parameter (global volume, mixing level,
+@gamma correction etc.), left and right to
+@modify.
+<P>@Pauses the game.
+<Shift+P>@While paused, walk to the next frame.
+<F3>@Resets the game (start with
+@`hardware self-test').
+<F4>@Shows the game graphics. Use cursor keys
+@to change set/color, F4 or Esc to return to
+@the emulation.
+<F9>@Changes frame skip on the fly.
+<F10>@Toggles speed throttling.
+<F11>@Toggles speed display.
+<Shift+F11>@Toggles profiler display.
+<F12>@Saves a screen snapshot. The default
+@target directory is SNAP. You must create
+@this directory yourself; the program will
+@not create it if it doesn't exist.
+<ESC>@Exits the emulator.
+<L-CTRL>@is mostly used as a button.
+<L-ALT>)@is also mostly used as a button.
+<arrows>@will emulate the joystick, pad or
+@trakball. If you have a joystick (pad,
+@trakball ), you can use it with the
+@Input-Related options: -joytype, -jt 
+@and/or -[no]analogstick, -[no]as
+.TE
+
+For a complete list of the usefull keys in
+.Nm xmame
+start a game, press the \fI<tab>\fR button, select \fI<Input (general)>\fR or
+\fI<Input (this game)>\fR and you see a complete list of the related keys.
+.Sh RCFILES
+You can put the most commandline options in an (r)essource (c)onfiguration
+(rc) file. To generate a `clean' xmamerc you type in your ${HOME}/.xmame
+directory:
+
+.Nm xmame
+.Fl sc
+>
+.Ar xmamerc
+
+Now you have a good base to build your specific rc-file. Here is a piece
+from this file to tell you how the syntax works.
+
+    ### X11-window Related ###
+    cursor                  1
+    mitshm                  1
+    xsync                   1
+    privatecmap             0
+    xil                     1
+    mtxil                   0
+    run-in-root-window      0
+    root_window_id          0
+    geometry                640x480
+
+    ### XFree86 DGA Related ###
+
+    ### Video Mode Selection Related ###
+    keepaspect              1
+    displayaspectratio      1.330000
+
+The number `0' is equal to `no' or `false' and `1' means `yes' or `true'.
+
+Some parameters like `geometry' needs a string `800x600' and
+some others like `displayaspectratio' use a number `1.330000'.
+.Sh ENVIRONMENT
+The following environment variables are used:
+
+.TS
+tab (@);
+l l.
+\fBENV@USE\fR
+HOME@The user's home directory.  (normally set by the login process.)
+DISPLAY@X server to display in.
+.TE
+.Sh FILES
+The config files are parsed in the following order:
+
+.TS
+tab (@);
+l l.
+\fBPATH@CONFIG FILE\fR
+/usr/local/share/xmame/xmamerc@global configuration
+${HOME}/.xmame/xmamerc@user configuration
+/usr/local/share/xmame/xmame-x11rc@global per display
+@method
+${HOME}/.xmame/xmame-x11rc@user per display
+@method
+/usr/local/share/xmame/rc/<game>rc@global per game
+${HOME}/.xmame/rc/<game>rc@user per game
+.TE
+.Sh BUGS
+There might be some bugs. Take a look in the doc-dir for more info,
+because the xmame-project is always in progress. :-)
+.Sh CREDITS
+Lots and lots and lots of thank to everyone for there great help on the
+xmame project. I would like to thank the following people and of course anyone
+I've forgotten.
+
+Thank you all,
+
+Hans
+
+  1. Fathers of the mame-creature (main version)
+        Nicola Salmoria
+        Allard van der Bas
+        Mirko (Mix) Buffoni (General Mantainer)
+  2. Fathers of mess
+        Brad Oliver
+        Richard Bannister
+        Ben Bruscella (current coordinator)
+  3. Original UNIX/X11 port
+        Allard van der Bas
+        Dick the Ridder
+        Juan Antonio Marmnez
+  4. Unix maintainer
+        Hans de Goede
+  5. Alpha specific issues
+        Christian Groessler
+  6. Sun specific issues
+        Keith Hargrove
+        Mathis Rosenhau
+  7. Irix specific issues
+        Tristram Scott
+  8. GGI maintainance
+        Gabriele Boccone (original port)
+        Christian Groessler (current maintainer)
+  9. OpenGL code & maintainance
+        Mike Oliphant
+ 10. Network code
+        Eric Totel
+ 11. Perl scripts for automation of some porting issues
+        Bill Adams
+ 12. Xmame rpms
+        Jeremy Hansen
+ 13. Mailing list maintainer
+        Chris McCraw
+ 14. Bits and pieces
+        Christian Groessler
+        Torsten Paul
+ 15. AIX Sound code
+        Chris Sharpp
+ 16. IRIX Sound code
+        entropy@zippy.bernstein.com
+ 17. German readme
+        Robert Hamberger
+ 18. Documentation (SGML, HTML, MAN ...)
+        Rene Herrmann
+
+    And now you've come to the end of this man(ual).
+    Have a lot of fun
+    Rene'
diff --git a/src/unix/doc/xmessrc.dist b/src/unix/doc/xmessrc.dist
new file mode 100644
index 0000000..91d0455
--- /dev/null
+++ b/src/unix/doc/xmessrc.dist
@@ -0,0 +1,133 @@
+### xmess running parameters ###
+
+### Digital sound related ###
+# dsp-plugin            <NULL> (not set)
+timer                   0
+
+### Sound mixer related ###
+# sound-mixer-plugin    <NULL> (not set)
+
+### Video Related ###
+bpp                     0
+heightscale             1
+widthscale              1
+autodouble              1
+scanlines               0
+artwork                 1
+frameskipper            0
+throttle                1
+sleepidle               0
+autoframeskip           1
+maxautoframeskip        8
+frameskip               0
+brightness              1.000000
+gamma                   1.000000
+
+### Vector Games Related ###
+# vectorres             <NULL> (not set)
+beam                    1.000000
+flicker                 0.000000
+antialias               1
+translucency            1
+
+### X11 Related ###
+x11-mode                0
+
+### X11-window Related ###
+cursor                  1
+mitshm                  1
+xsync                   1
+privatecmap             0
+xil                     1
+mtxil                   0
+run-in-root-window      0
+root_window_id          0
+geometry                640x480
+
+### XFree86 DGA Related ###
+
+### Video Mode Selection Related ###
+keepaspect              1
+displayaspectratio      1.330000
+
+### X11-input related ###
+grabmouse               0
+winkeys                 0
+
+### Sound Related ###
+sound                   1
+samples                 1
+samplefreq              22050
+bufsize                 3.000000
+volume                  -3
+# audiodevice           <NULL> (not set)
+# mixerdevice           <NULL> (not set)
+
+### Input Related ###
+joytype                 0
+analogstick             0
+mouse                   1
+
+### Fileio Related ###
+biospath                /usr/local/share/xmess/bios
+softwarepath            /usr/local/share/xmess/software
+CRC_directory           /usr/local/share/xmess/crc
+snapshot_directory      .
+cheat_directory         /usr/local/share/xmess/cheat
+cheatfile               cheat.cdb
+hiscore_file            /usr/local/share/xmess/hiscore.dat
+history_file            /usr/local/share/xmess/history.dat
+mameinfo_file           /usr/local/share/xmess/mameinfo.dat
+
+### Mess Related ###
+language                english
+fuzzycmp                1
+cheat                   0
+debug                   0
+
+### Frontend Related ###
+clones                  1
+
+### Internal verification list commands (only for developers) ###
+
+### Rom Identification Related ###
+
+### General Options ###
+
+### X11 keymapping ###
+#
+# mapkey	<Xcode>,<Scancode>
+#
+# Xcode means the HEX code of the key as appears in /usr/include/X11/keysymdef.h
+# Scancode means the hexadecimal code that represents the value used for Xmame
+# 	in keyboard inputs, as defined in src/osdepend.h xmame source file
+# IMPORTANT: 
+#	1- Due to some limitations, only LATIN-1 X-codes ( 0x0000-0x00ff ) and
+#	Especial X-keycodes ( 0xff00-0xffff ) are supported
+#	2- Some keys are keyboard dependent: As Xmame works internally with
+#	Standard US-AT keyboard codes, you must take care in remmaping some keys
+#
+
+# An example: map space as "firebutton" (Mame predefines it as OSD_KEY_RCONTROL)
+# in simbolic Xlib/Mame notation it should be:
+#
+# mapkey XK_space,OSD_KEY_RCONTROL 
+# 
+# So looking in X11/keysymdef.h and src/osdepend.h we'll write
+# mapkey 0x0020,0x0039
+#
+# (Other example). To use F8 key to insert coin you shoud use:
+# mapkey 0xffc5,0x0004
+
+### suggested german keymap mods by Peter Trauner <peter.trauner@jk.uni-linz.ac.at> ###
+#mapkey 0xfe52,0x0029
+#mapkey 0x00df,0x000c
+#mapkey 0xfe51,0x000d
+#mapkey 0x00fc,0x001a
+#mapkey 0x002b,0x001b
+#mapkey 0x00f6,0x0027
+#mapkey 0x00e4,0x0028
+#mapkey 0x0023,0x002b
+#mapkey 0x0059,0x002c
+#mapkey 0x005a,0x0015
+#mapkey 0x002d,0x0035
diff --git a/src/unix/effect.c b/src/unix/effect.c
new file mode 100644
index 0000000..e8afa18
--- /dev/null
+++ b/src/unix/effect.c
@@ -0,0 +1,1747 @@
+/* Video Effect Functions
+ *
+ * Ben Saylor - bsaylor@macalester.edu
+ *
+ * Each of these functions copies one line of source pixels, applying an effect.
+ * They are called through pointers from blit_core.h.
+ * There's one for every bitmap depth / display depth combination,
+ * and for direct/non-pallettized where needed.
+ *
+ *  FIXME: 24-bit, video drivers
+ *
+ * HISTORY:
+ *
+ *  2001-10-06:
+ *   - minor changes to make -effect option trump -arbheight option <adam@gimp.org>
+ *
+ *  2001-10-01:
+ *   - should now compile with all video drivers,
+ *     though effects won't work except with
+ *     aforementioned drivers
+ *
+ *  2001-09-21:
+ *   - scan3 effect (deluxe scanlines)
+ *   - small fixes & changes
+ *
+ *  2001-09-19:
+ *   - ported to xmame-0.55.1
+ *   - fixed some DGA bugs
+ *   - confirmed to work with SDL
+ *   - added ggi and svgalib support (untested)
+ *   - added two basic RGB effects (rgbstripe3x2 and rgbscan2x3)
+ *   - removed 8-bit support
+ *
+ *  2001-09-13:
+ *   - added scan2 effect (light scanlines)
+ *   - automatically scale as required by effect
+ *   - works with x11_window and dga2, and hopefully dga1 and SDL (untested)
+ *     (windowed mode is fastest)
+ *   - use doublebuffering where requested by video driver
+ *   - works on 16-bit and 32-bit displays, others untested
+ *     (16-bit recommended - it's faster)
+ *   - scale2x smooth scaling effect
+ */
+
+#define __EFFECT_C_
+#include "xmame.h"
+#include "osd_cpu.h"
+#include "effect.h"
+
+/* divide R, G, and B to darken pixels */
+#define SHADE16_HALF(P)   (((P)>>1) & 0x7bef)
+#define SHADE16_FOURTH(P) (((P)>>2) & 0x39e7)
+#define SHADE32_HALF(P)   (((P)>>1) & 0x007f7f7f)
+#define SHADE32_FOURTH(P) (((P)>>2) & 0x003f3f3f)
+
+/* straight RGB masks */
+#define RMASK16(P) ((P) & 0xf800)
+#define GMASK16(P) ((P) & 0x07e0)
+#define BMASK16(P) ((P) & 0x001f)
+#define RMASK32(P) ((P) & 0x00ff0000)
+#define GMASK32(P) ((P) & 0x0000ff00)
+#define BMASK32(P) ((P) & 0x000000ff)
+
+/* inverse RGB masks */
+#define RMASK16_INV(P) ((P) & 0x07ff)
+#define GMASK16_INV(P) ((P) & 0xf81f)
+#define BMASK16_INV(P) ((P) & 0xffe0)
+#define RMASK32_INV(P) ((P) & 0x0000ffff)
+#define GMASK32_INV(P) ((P) & 0x00ff00ff)
+#define BMASK32_INV(P) ((P) & 0x00ffff00)
+
+/* inverse RGB masks, darkened*/
+#define RMASK16_INV_HALF(P) (((P)>>1) & 0x03ef)
+#define GMASK16_INV_HALF(P) (((P)>>1) & 0x780f)
+#define BMASK16_INV_HALF(P) (((P)>>1) & 0xebe0)
+#define RMASK32_INV_HALF(P) (((P)>>1) & 0x00007f7f)
+#define GMASK32_INV_HALF(P) (((P)>>1) & 0x007f007f)
+#define BMASK32_INV_HALF(P) (((P)>>1) & 0x007f7f00)
+
+/* RGB semi-masks */
+#define RMASK16_SEMI(P) ( RMASK16(P) | RMASK16_INV_HALF(P) )
+#define GMASK16_SEMI(P) ( GMASK16(P) | GMASK16_INV_HALF(P) )
+#define BMASK16_SEMI(P) ( BMASK16(P) | BMASK16_INV_HALF(P) )
+#define RMASK32_SEMI(P) ( RMASK32(P) | RMASK32_INV_HALF(P) )
+#define GMASK32_SEMI(P) ( GMASK32(P) | GMASK32_INV_HALF(P) )
+#define BMASK32_SEMI(P) ( BMASK32(P) | BMASK32_INV_HALF(P) )
+
+/* average two pixels */
+#define MEAN16(P,Q) ( RMASK16((RMASK16(P)+RMASK16(Q))/2) | GMASK16((GMASK16(P)+GMASK16(Q))/2) | BMASK16((BMASK16(P)+BMASK16(Q))/2) )
+#define MEAN32(P,Q) ( RMASK32((RMASK32(P)+RMASK32(Q))/2) | GMASK32((GMASK32(P)+GMASK32(Q))/2) | BMASK32((BMASK32(P)+BMASK32(Q))/2) )
+
+#ifdef USE_HWSCALE
+#define FOURCC_YUY2 0x32595559
+#define FOURCC_YV12 0x32315659
+#endif
+
+/* called from config.c to set scale parameters */
+void effect_init1()
+{
+        int disable_arbscale = 0;
+
+	switch (effect) {
+		case EFFECT_SCALE2X:
+		case EFFECT_SCAN2:
+			normal_widthscale = 2;
+			normal_heightscale = 2;
+                        disable_arbscale = 1;
+			break;
+		case EFFECT_RGBSTRIPE:
+			normal_widthscale = 3;
+			normal_heightscale = 2;
+                        disable_arbscale = 1;
+			break;
+		case EFFECT_RGBSCAN:
+			normal_widthscale = 2;
+			normal_heightscale = 3;
+                        disable_arbscale = 1;
+			break;
+		case EFFECT_SCAN3:
+			normal_widthscale = 3;
+			normal_heightscale = 3;
+                        disable_arbscale = 1;
+			break;
+	}
+
+	if (yarbsize && disable_arbscale) {
+	  printf("Using effects -- disabling arbitrary scaling\n");
+	  yarbsize = 0;
+	}
+}
+
+/* called from <driver>_create_display by each video driver;
+ * initializes function pointers to correct depths
+ * and allocates buffer for doublebuffering */
+void effect_init2(int src_depth, int dst_depth, int dst_width)
+{
+	if (effect) {
+		int i,rddepth;
+
+		switch(dst_depth) {
+#ifdef USE_HWSCALE
+			case FOURCC_YUY2:
+			case FOURCC_YV12:
+				rddepth=16;
+				break;
+#endif
+			default:
+				rddepth=dst_depth;
+				break;
+		}
+
+		printf("Initializing video effect %d: bitmap depth = %d, display depth = %d\n", effect, src_depth, rddepth);
+		effect_dbbuf = malloc(dst_width*normal_heightscale*rddepth/8);
+		for (i=0; i<dst_width*normal_heightscale*rddepth/8; i++)
+			effect_dbbuf[i] = 0;
+		switch (dst_depth) {
+			case 15:
+			case 16:
+				switch (src_depth) {
+					case 16:
+						effect_scale2x_func		= effect_scale2x_16_16;
+						effect_scale2x_direct_func	= effect_scale2x_16_16_direct;
+						effect_scan2_func		= effect_scan2_16_16;
+						effect_scan2_direct_func	= effect_scan2_16_16_direct;
+						effect_rgbstripe_func		= effect_rgbstripe_16_16;
+						effect_rgbstripe_direct_func	= effect_rgbstripe_16_16_direct;
+						effect_rgbscan_func		= effect_rgbscan_16_16;
+						effect_rgbscan_direct_func	= effect_rgbscan_16_16_direct;
+						effect_scan3_func		= effect_scan3_16_16;
+						effect_scan3_direct_func	= effect_scan3_16_16_direct;
+						break;
+					case 32:
+						break;
+				}
+				break;
+			case 24:
+				switch (src_depth) {
+					case 16:
+						effect_scale2x_func		= effect_scale2x_16_24;
+						effect_scan2_func		= effect_scan2_16_24;
+						effect_rgbstripe_func		= effect_rgbstripe_16_24;
+						effect_rgbscan_func		= effect_rgbscan_16_24;
+						effect_scan3_func		= effect_scan3_16_24;
+						break;
+					case 32:
+						break;
+				}
+				break;
+			case 32:
+				switch (src_depth) {
+					case 16:
+						effect_scale2x_func		= effect_scale2x_16_32;
+						effect_scan2_func		= effect_scan2_16_32;
+						effect_rgbstripe_func		= effect_rgbstripe_16_32;
+						effect_rgbscan_func		= effect_rgbscan_16_32;
+						effect_scan3_func		= effect_scan3_16_32;
+						break;
+					case 32:
+						effect_scale2x_direct_func	= effect_scale2x_32_32_direct;
+						effect_scan2_direct_func	= effect_scan2_32_32_direct;
+						effect_rgbstripe_direct_func	= effect_rgbstripe_32_32_direct;
+						effect_rgbscan_direct_func	= effect_rgbscan_32_32_direct;
+						effect_scan3_direct_func	= effect_scan3_32_32_direct;
+						break;
+				}
+				break;
+#ifdef USE_HWSCALE
+			case FOURCC_YUY2:
+				switch(src_depth) {
+					case 16:
+						effect_scale2x_func = effect_scale2x_16_YUY2;
+						effect_scan2_func		= effect_scan2_16_YUY2;
+						effect_rgbstripe_func		= effect_rgbstripe_16_YUY2;
+						effect_rgbscan_func		= effect_rgbscan_16_YUY2;
+						effect_scan3_func		= effect_scan3_16_YUY2;
+						break;
+					case 32:
+						effect_scale2x_direct_func = effect_scale2x_32_YUY2_direct;
+						effect_scan2_direct_func	= effect_scan2_32_YUY2_direct;
+						effect_rgbstripe_direct_func	= effect_rgbstripe_32_YUY2_direct;
+						effect_rgbscan_direct_func	= effect_rgbscan_32_YUY2_direct;
+						effect_scan3_direct_func	= effect_scan3_32_YUY2_direct;
+						break;
+       				}
+				break;
+#endif
+		}
+	}
+
+	if (!blit_hardware_rotation && (blit_flipx || blit_flipy || blit_swapxy))
+	{
+		switch (src_depth) {
+		case 16:
+			rotate_func = rotate_16_16;
+			break;
+		case 32:
+			rotate_func = rotate_32_32;
+			break;
+		}
+
+		if (effect == EFFECT_SCALE2X) {
+			rotate_dbbuf0 = calloc(video_width*video_depth/8, sizeof(char));
+			rotate_dbbuf1 = calloc(video_width*video_depth/8, sizeof(char));
+			rotate_dbbuf2 = calloc(video_width*video_depth/8, sizeof(char));
+		} else {
+			rotate_dbbuf = calloc(video_width*video_depth/8, sizeof(char));
+		}
+	}
+}
+
+
+/* scale2x algorithm (Andrea Mazzoleni, http://advancemame.sourceforge.net):
+ *
+ * A 9-pixel rectangle is taken from the source bitmap:
+ *
+ *  a b c
+ *  d e f
+ *  g h i
+ *
+ * The central pixel e is expanded into four new pixels,
+ *
+ *  e0 e1
+ *  e2 e3
+ *
+ * where
+ *
+ *  e0 = (d == b && b != f && d != h) ? d : e;
+ *  e1 = (b == f && b != d && f != h) ? f : e;
+ *  e2 = (d == h && d != b && h != f) ? d : e;
+ *  e3 = (h == f && d != h && b != f) ? f : e;
+ *
+ */
+
+void effect_scale2x_16_16
+		(void *dst0, void *dst1,
+		const void *src0, const void *src1, const void *src2,
+		unsigned count, const void *lookup)
+{
+	UINT16 *u16dst0 = (UINT16 *)dst0;
+	UINT16 *u16dst1 = (UINT16 *)dst1;
+	UINT16 *u16src0 = (UINT16 *)src0;
+	UINT16 *u16src1 = (UINT16 *)src1;
+	UINT16 *u16src2 = (UINT16 *)src2;
+	UINT32 *u32lookup = (UINT32 *)lookup;
+
+	while (count) {
+
+		if (u16src1[-1] == u16src0[0] && u16src2[0] != u16src0[0] && u16src1[1] != u16src0[0])
+			*u16dst0 = u32lookup[u16src0[0]];
+		else	*u16dst0 = u32lookup[u16src1[0]];
+
+		if (u16src1[1] == u16src0[0] && u16src2[0] != u16src0[0] && u16src1[-1] != u16src0[0])
+			*(u16dst0+1) = u32lookup[u16src0[0]];
+		else	*(u16dst0+1) = u32lookup[u16src1[0]];
+
+		if (u16src1[-1] == u16src2[0] && u16src0[0] != u16src2[0] && u16src1[1] != u16src2[0])
+			*u16dst1 = u32lookup[u16src2[0]];
+		else	*u16dst1 = u32lookup[u16src1[0]];
+
+		if (u16src1[1] == u16src2[0] && u16src0[0] != u16src2[0] && u16src1[-1] != u16src2[0])
+			*(u16dst1+1) = u32lookup[u16src2[0]];
+		else	*(u16dst1+1) = u32lookup[u16src1[0]];
+
+		++u16src0;
+		++u16src1;
+		++u16src2;
+		u16dst0 += 2;
+		u16dst1 += 2;
+		--count;
+	}
+}
+
+void effect_scale2x_16_16_direct
+		(void *dst0, void *dst1,
+		const void *src0, const void *src1, const void *src2,
+		unsigned count)
+{
+	UINT16 *u16dst0 = (UINT16 *)dst0;
+	UINT16 *u16dst1 = (UINT16 *)dst1;
+	UINT16 *u16src0 = (UINT16 *)src0;
+	UINT16 *u16src1 = (UINT16 *)src1;
+	UINT16 *u16src2 = (UINT16 *)src2;
+
+	while (count) {
+
+		if (u16src1[-1] == u16src0[0] && u16src2[0] != u16src0[0] && u16src1[1] != u16src0[0])
+			*u16dst0 = u16src0[0];
+		else	*u16dst0 = u16src1[0];
+
+		if (u16src1[1] == u16src0[0] && u16src2[0] != u16src0[0] && u16src1[-1] != u16src0[0])
+			*(u16dst0+1) = u16src0[0];
+		else	*(u16dst0+1) = u16src1[0];
+
+		if (u16src1[-1] == u16src2[0] && u16src0[0] != u16src2[0] && u16src1[1] != u16src2[0])
+			*u16dst1 = u16src2[0];
+		else	*u16dst1 = u16src1[0];
+
+		if (u16src1[1] == u16src2[0] && u16src0[0] != u16src2[0] && u16src1[-1] != u16src2[0])
+			*(u16dst1+1) = u16src2[0];
+		else	*(u16dst1+1) = u16src1[0];
+
+		++u16src0;
+		++u16src1;
+		++u16src2;
+		u16dst0 += 2;
+		u16dst1 += 2;
+		--count;
+	}
+}
+
+#ifdef USE_HWSCALE
+#define RMASK 0xff0000
+#define GMASK 0xff00
+#define BMASK 0xff
+void effect_scale2x_16_YUY2
+		(void *dst0, void *dst1,
+		const void *src0, const void *src1, const void *src2,
+		unsigned count, const void *lookup)
+{
+	unsigned int *u32dst0 = (unsigned int *)dst0;
+	unsigned int *u32dst1 = (unsigned int *)dst1;
+	UINT16 *u16src0 = (UINT16 *)src0;
+	UINT16 *u16src1 = (UINT16 *)src1;
+	UINT16 *u16src2 = (UINT16 *)src2;
+	UINT32 *u32lookup = (UINT32 *)lookup;
+	INT32 y,y2,uv1,uv2;
+	UINT32 p1,p2,p3,p4;
+	while (count) {
+
+		if (u16src1[-1] == u16src0[0] && u16src2[0] != u16src0[0] && u16src1[1] != u16src0[0])
+			p1 = u32lookup[u16src0[0]];
+		else	p1 = u32lookup[u16src1[0]];
+
+		if (u16src1[1] == u16src0[0] && u16src2[0] != u16src0[0] && u16src1[-1] != u16src0[0])
+			p2 = u32lookup[u16src0[0]];
+		else	p2 = u32lookup[u16src1[0]];
+
+		if (u16src1[-1] == u16src2[0] && u16src0[0] != u16src2[0] && u16src1[1] != u16src2[0])
+			p3 = u32lookup[u16src2[0]];
+		else	p3 = u32lookup[u16src1[0]];
+
+		if (u16src1[1] == u16src2[0] && u16src0[0] != u16src2[0] && u16src1[-1] != u16src2[0])
+			p4 = u32lookup[u16src2[0]];
+		else	p4 = u32lookup[u16src1[0]];
+
+		++u16src0;
+		++u16src1;
+		++u16src2;
+
+		y=p1&0x000000ff;
+		uv1=(p1&0xff00ff00)>>1;
+		y2=p2&0x00ff0000;
+		uv2=(p2&0xff00ff00)>>1;
+		uv1=(uv1+uv2)&0xff00ff00;
+		*u32dst0++=y|y2|uv1;
+
+		y=p3&0x000000ff;
+		uv1=(p3&0xff00ff00)>>1;
+		y2=p4&0x00ff0000;
+		uv2=(p4&0xff00ff00)>>1;
+		uv1=(uv1+uv2)&0xff00ff00;
+		*u32dst1++=y|y2|uv1;		y=p1>>24;
+
+		--count;
+	}
+}
+
+void effect_scale2x_32_YUY2_direct
+		(void *dst0, void *dst1,
+		const void *src0, const void *src1, const void *src2,
+		unsigned count)
+{
+	unsigned char *u8dst0 = (unsigned char *)dst0;
+	unsigned char *u8dst1 = (unsigned char *)dst1;
+	UINT32 *u32src0 = (UINT32 *)src0;
+	UINT32 *u32src1 = (UINT32 *)src1;
+	UINT32 *u32src2 = (UINT32 *)src2;
+	INT32 r,g,b,r2,g2,b2,y,y2,u,v;
+	UINT32 p1,p2,p3,p4;
+	while (count) {
+
+		if (u32src1[-1] == u32src0[0] && u32src2[0] != u32src0[0] && u32src1[1] != u32src0[0])
+			p1 = u32src0[0];
+		else	p1 = u32src1[0];
+
+		if (u32src1[1] == u32src0[0] && u32src2[0] != u32src0[0] && u32src1[-1] != u32src0[0])
+			p2 = u32src0[0];
+		else	p2 = u32src1[0];
+
+		if (u32src1[-1] == u32src2[0] && u32src0[0] != u32src2[0] && u32src1[1] != u32src2[0])
+			p3 = u32src2[0];
+		else	p3 = u32src1[0];
+
+		if (u32src1[1] == u32src2[0] && u32src0[0] != u32src2[0] && u32src1[-1] != u32src2[0])
+			p4 = u32src2[0];
+		else	p4 = u32src1[0];
+
+		++u32src0;
+		++u32src1;
+		++u32src2;
+
+    r=p1&RMASK;  r>>=16; \
+    g=p1&GMASK;  g>>=8; \
+    b=p1&BMASK;  b>>=0; \
+
+    r2=p2&RMASK;  r2>>=16; \
+    g2=p2&GMASK;  g2>>=8; \
+    b2=p2&BMASK;  b2>>=0; \
+
+    y = (( 9897*r + 19235*g + 3736*b ) >> 15);
+    y2 = (( 9897*r2 + 19235*g2 + 3736*b2 ) >> 15);
+    r+=r2; g+=g2; b+=b2; \
+    *u8dst0++=y;
+    u = (( -5537*r - 10878*g + 16384*b ) >> 16) + 128; \
+    *u8dst0++=u;
+    v = (( 16384*r - 13730*g - 2664*b ) >> 16) + 128; \
+    *u8dst0++=y2;
+    *u8dst0++=v;
+
+    r=p3&RMASK;  r>>=16; \
+    g=p3&GMASK;  g>>=8; \
+    b=p3&BMASK;  b>>=0; \
+
+    r2=p4&RMASK;  r2>>=16; \
+    g2=p4&GMASK;  g2>>=8; \
+    b2=p4&BMASK;  b2>>=0; \
+
+    y = (( 9897*r + 19235*g + 3736*b ) >> 15);
+    y2 = (( 9897*r2 + 19235*g2 + 3736*b2 ) >> 15);
+    r+=r2; g+=g2; b+=b2; \
+    *u8dst1++=y;
+    u = (( -5537*r - 10878*g + 16384*b ) >> 16) + 128; \
+    *u8dst1++=u;
+    v = (( 16384*r - 13730*g - 2664*b ) >> 16) + 128; \
+    *u8dst1++=y2;
+    *u8dst1++=v;
+
+		--count;
+	}
+}
+
+#undef RMASK
+#undef GMASK
+#undef BMASK
+#endif
+
+
+/* FIXME: this probably doesn't work right for 24 bit */
+void effect_scale2x_16_24
+		(void *dst0, void *dst1,
+		const void *src0, const void *src1, const void *src2,
+		unsigned count, const void *lookup)
+{
+	UINT32 *u32dst0 = (UINT32 *)dst0;
+	UINT32 *u32dst1 = (UINT32 *)dst1;
+	UINT16 *u16src0 = (UINT16 *)src0;
+	UINT16 *u16src1 = (UINT16 *)src1;
+	UINT16 *u16src2 = (UINT16 *)src2;
+	UINT32 *u32lookup = (UINT32 *)lookup;
+
+	while (count) {
+
+		if (u16src1[-1] == u16src0[0] && u16src2[0] != u16src0[0] && u16src1[1] != u16src0[0])
+			*(u32dst0) = u32lookup[u16src0[0]];
+		else	*(u32dst0) = u32lookup[u16src1[0]];
+
+		if (u16src1[1] == u16src0[0] && u16src2[0] != u16src0[0] && u16src1[-1] != u16src0[0])
+			*(u32dst0+1) = u32lookup[u16src0[0]];
+		else	*(u32dst0+1) = u32lookup[u16src1[0]];
+
+		if (u16src1[-1] == u16src2[0] && u16src0[0] != u16src2[0] && u16src1[1] != u16src2[0])
+			*(u32dst1) = u32lookup[u16src2[0]];
+		else	*(u32dst1) = u32lookup[u16src1[0]];
+
+		if (u16src1[1] == u16src2[0] && u16src0[0] != u16src2[0] && u16src1[-1] != u16src2[0])
+			*(u32dst1+1) = u32lookup[u16src2[0]];
+		else	*(u32dst1+1) = u32lookup[u16src1[0]];
+
+		++u16src0;
+		++u16src1;
+		++u16src2;
+		u32dst0 += 2;
+		u32dst1 += 2;
+		--count;
+	}
+}
+
+void effect_scale2x_16_32
+		(void *dst0, void *dst1,
+		const void *src0, const void *src1, const void *src2,
+		unsigned count, const void *lookup)
+{
+	UINT32 *u32dst0 = (UINT32 *)dst0;
+	UINT32 *u32dst1 = (UINT32 *)dst1;
+	UINT16 *u16src0 = (UINT16 *)src0;
+	UINT16 *u16src1 = (UINT16 *)src1;
+	UINT16 *u16src2 = (UINT16 *)src2;
+	UINT32 *u32lookup = (UINT32 *)lookup;
+
+	while (count) {
+
+		if (u16src1[-1] == u16src0[0] && u16src2[0] != u16src0[0] && u16src1[1] != u16src0[0])
+			*(u32dst0) = u32lookup[u16src0[0]];
+		else	*(u32dst0) = u32lookup[u16src1[0]];
+
+		if (u16src1[1] == u16src0[0] && u16src2[0] != u16src0[0] && u16src1[-1] != u16src0[0])
+			*(u32dst0+1) = u32lookup[u16src0[0]];
+		else	*(u32dst0+1) = u32lookup[u16src1[0]];
+
+		if (u16src1[-1] == u16src2[0] && u16src0[0] != u16src2[0] && u16src1[1] != u16src2[0])
+			*(u32dst1) = u32lookup[u16src2[0]];
+		else	*(u32dst1) = u32lookup[u16src1[0]];
+
+		if (u16src1[1] == u16src2[0] && u16src0[0] != u16src2[0] && u16src1[-1] != u16src2[0])
+			*(u32dst1+1) = u32lookup[u16src2[0]];
+		else	*(u32dst1+1) = u32lookup[u16src1[0]];
+
+		++u16src0;
+		++u16src1;
+		++u16src2;
+		u32dst0 += 2;
+		u32dst1 += 2;
+		--count;
+	}
+}
+
+void effect_scale2x_32_32_direct
+		(void *dst0, void *dst1,
+		const void *src0, const void *src1, const void *src2,
+		unsigned count)
+{
+	UINT32 *u32dst0 = (UINT32 *)dst0;
+	UINT32 *u32dst1 = (UINT32 *)dst1;
+	UINT32 *u32src0 = (UINT32 *)src0;
+	UINT32 *u32src1 = (UINT32 *)src1;
+	UINT32 *u32src2 = (UINT32 *)src2;
+
+	while (count) {
+
+		if (u32src1[-1] == u32src0[0] && u32src2[0] != u32src0[0] && u32src1[1] != u32src0[0])
+			*u32dst0 = u32src0[0];
+		else	*u32dst0 = u32src1[0];
+
+		if (u32src1[1] == u32src0[0] && u32src2[0] != u32src0[0] && u32src1[-1] != u32src0[0])
+			*(u32dst0+1) = u32src0[0];
+		else	*(u32dst0+1) = u32src1[0];
+
+		if (u32src1[-1] == u32src2[0] && u32src0[0] != u32src2[0] && u32src1[1] != u32src2[0])
+			*u32dst1 = u32src2[0];
+		else	*u32dst1 = u32src1[0];
+
+		if (u32src1[1] == u32src2[0] && u32src0[0] != u32src2[0] && u32src1[-1] != u32src2[0])
+			*(u32dst1+1) = u32src2[0];
+		else	*(u32dst1+1) = u32src1[0];
+
+		++u32src0;
+		++u32src1;
+		++u32src2;
+		u32dst0 += 2;
+		u32dst1 += 2;
+		--count;
+	}
+}
+
+
+/**********************************
+ * scan2: light 2x2 scanlines
+ **********************************/
+
+void effect_scan2_16_16 (void *dst0, void *dst1, const void *src, unsigned count, const void *lookup)
+{
+	UINT16 *u16dst0 = (UINT16 *)dst0;
+	UINT16 *u16dst1 = (UINT16 *)dst1;
+	UINT16 *u16src = (UINT16 *)src;
+	UINT32 *u32lookup = (UINT32 *)lookup;
+
+	while (count) {
+
+		*u16dst0 = *(u16dst0+1) = u32lookup[*u16src];
+			 
+		*u16dst1 = *(u16dst1+1) = SHADE16_HALF( u32lookup[*u16src] ) + SHADE16_FOURTH( u32lookup[*u16src] );
+
+		++u16src;
+		u16dst0 += 2;
+		u16dst1 += 2;
+		--count;
+	}
+}
+
+void effect_scan2_16_16_direct (void *dst0, void *dst1, const void *src, unsigned count)
+{
+	UINT16 *u16dst0 = (UINT16 *)dst0;
+	UINT16 *u16dst1 = (UINT16 *)dst1;
+	UINT16 *u16src = (UINT16 *)src;
+
+	while (count) {
+
+		*u16dst0 = *(u16dst0+1) = *u16src;
+			 
+		*u16dst1 = *(u16dst1+1) = SHADE16_HALF( *u16src ) + SHADE16_FOURTH( *u16src );
+
+		++u16src;
+		u16dst0 += 2;
+		u16dst1 += 2;
+		--count;
+	}
+}
+
+void effect_scan2_16_24 (void *dst0, void *dst1, const void *src, unsigned count, const void *lookup)
+{
+	UINT32 *u32dst0 = (UINT32 *)dst0;
+	UINT32 *u32dst1 = (UINT32 *)dst1;
+	UINT16 *u16src = (UINT16 *)src;
+	UINT32 *u32lookup = (UINT32 *)lookup;
+
+	while (count) {
+
+		*u32dst0 = *(u32dst0+1) = u32lookup[*u16src];
+			 
+		*u32dst1 = *(u32dst1+1) = SHADE32_HALF( u32lookup[*u16src] ) + SHADE32_FOURTH( u32lookup[*u16src] );
+
+		++u16src;
+		u32dst0 += 2;
+		u32dst1 += 2;
+		--count;
+	}
+}
+
+void effect_scan2_16_32 (void *dst0, void *dst1, const void *src, unsigned count, const void *lookup)
+{
+	UINT32 *u32dst0 = (UINT32 *)dst0;
+	UINT32 *u32dst1 = (UINT32 *)dst1;
+	UINT16 *u16src = (UINT16 *)src;
+	UINT32 *u32lookup = (UINT32 *)lookup;
+
+	while (count) {
+
+		*u32dst0 = *(u32dst0+1) = u32lookup[*u16src];
+			 
+		*u32dst1 = *(u32dst1+1) = SHADE32_HALF( u32lookup[*u16src] ) + SHADE32_FOURTH( u32lookup[*u16src] );
+
+		++u16src;
+		u32dst0 += 2;
+		u32dst1 += 2;
+		--count;
+	}
+}
+
+void effect_scan2_32_32_direct (void *dst0, void *dst1, const void *src, unsigned count)
+{
+	UINT32 *u32dst0 = (UINT32 *)dst0;
+	UINT32 *u32dst1 = (UINT32 *)dst1;
+	UINT32 *u32src = (UINT32 *)src;
+
+	while (count) {
+
+		*u32dst0 = *(u32dst0+1) = *u32src;
+			 
+		*u32dst1 = *(u32dst1+1) = SHADE32_HALF( *u32src ) +  SHADE32_FOURTH( *u32src );
+
+		++u32src;
+		u32dst0 += 2;
+		u32dst1 += 2;
+		--count;
+	}
+}
+
+#ifdef USE_HWSCALE
+#define RMASK 0xff0000
+#define GMASK 0xff00
+#define BMASK 0xff
+void effect_scan2_16_YUY2 (void *dst0, void *dst1, const void *src, unsigned count, const void *lookup)
+{
+	UINT32 *u32dst0 = (UINT32 *)dst0;
+	UINT32 *u32dst1 = (UINT32 *)dst1;
+	UINT16 *u16src = (UINT16 *)src;
+	UINT32 *u32lookup = (UINT32 *)lookup;
+	UINT32 r,y,u,v;
+
+	while (count) {
+		r=u32lookup[*u16src];
+		y=r&255;
+		u=(r>>8)&255;
+		v=(r>>24);
+		*u32dst0 = (y&255)|((u&255)<<8)|((y&255)<<16)|((v&255)<<24);
+		*u32dst1 = ((y*3/4)&255)|((u&255)<<8)|(((y*3/4)&255)<<16)|((v&255)<<24);
+		++u16src;
+		u32dst0++;
+		u32dst1++;
+		--count;
+	}
+}
+
+void effect_scan2_32_YUY2_direct(void *dst0, void *dst1, const void *src, unsigned count)
+{
+	UINT32 *u32dst0 = (UINT32 *)dst0;
+	UINT32 *u32dst1 = (UINT32 *)dst1;
+	UINT32 *u32src = (UINT32 *)src;
+	UINT32 r,g,b,y,u,v;
+
+	while (count) {
+		r=*u32src&RMASK;  r>>=16;
+		g=*u32src&GMASK;  g>>=8;
+		b=*u32src&BMASK;  b>>=0;
+		y = (( 9897*r + 19235*g + 3736*b ) >> 15);
+		u = (( -5537*r - 10878*g + 16384*b ) >> 15) + 128;
+		v = (( 16384*r - 13730*g - 2664*b ) >> 15) + 128;
+
+		*u32dst0 = (y&255)|((u&255)<<8)|((y&255)<<16)|((v&255)<<24);
+		*u32dst1 = ((y*3/4)&255)|((u&255)<<8)|(((y*3/4)&255)<<16)|((v&255)<<24);
+		++u32src;
+		u32dst0++;
+		u32dst1++;
+		--count;
+	}
+}
+
+#undef RMASK
+#undef GMASK
+#undef BMASK
+#endif
+
+/**********************************
+ * rgbstripe
+ **********************************/
+
+void effect_rgbstripe_16_16 (void *dst0, void *dst1, const void *src, unsigned count, const void *lookup)
+{
+	UINT16 *u16dst0 = (UINT16 *)dst0;
+	UINT16 *u16dst1 = (UINT16 *)dst1;
+	UINT16 *u16src = (UINT16 *)src;
+	UINT32 *u32lookup = (UINT32 *)lookup;
+
+	while (count) {
+
+		*(u16dst0+0) = *(u16dst1+0) = RMASK16_SEMI(u32lookup[*u16src]);
+		*(u16dst0+1) = *(u16dst1+1) = GMASK16_SEMI(u32lookup[*u16src]);
+		*(u16dst0+2) = *(u16dst1+2) = BMASK16_SEMI(u32lookup[*u16src]);
+
+		++u16src;
+		u16dst0 += 3;
+		u16dst1 += 3;
+		--count;
+	}
+}
+
+void effect_rgbstripe_16_16_direct(void *dst0, void *dst1, const void *src, unsigned count)
+{
+	UINT16 *u16dst0 = (UINT16 *)dst0;
+	UINT16 *u16dst1 = (UINT16 *)dst1;
+	UINT16 *u16src = (UINT16 *)src;
+
+	while (count) {
+
+		*(u16dst0+0) = *(u16dst1+0) = RMASK16_SEMI(*u16src);
+		*(u16dst0+1) = *(u16dst1+1) = GMASK16_SEMI(*u16src);
+		*(u16dst0+2) = *(u16dst1+2) = BMASK16_SEMI(*u16src);
+
+		++u16src;
+		u16dst0 += 3;
+		u16dst1 += 3;
+		--count;
+	}
+}
+
+void effect_rgbstripe_16_24 (void *dst0, void *dst1, const void *src, unsigned count, const void *lookup)
+{
+	UINT32 *u32dst0 = (UINT32 *)dst0;
+	UINT32 *u32dst1 = (UINT32 *)dst1;
+	UINT16 *u16src = (UINT16 *)src;
+	UINT32 *u32lookup = (UINT32 *)lookup;
+
+	while (count) {
+
+		*(u32dst0+0) = *(u32dst1+0) = RMASK32_SEMI(u32lookup[*u16src]);
+		*(u32dst0+1) = *(u32dst1+1) = GMASK32_SEMI(u32lookup[*u16src]);
+		*(u32dst0+2) = *(u32dst1+2) = BMASK32_SEMI(u32lookup[*u16src]);
+
+		++u16src;
+		u32dst0 += 3;
+		u32dst1 += 3;
+		--count;
+	}
+}
+
+void effect_rgbstripe_16_32 (void *dst0, void *dst1, const void *src, unsigned count, const void *lookup)
+{
+	UINT32 *u32dst0 = (UINT32 *)dst0;
+	UINT32 *u32dst1 = (UINT32 *)dst1;
+	UINT16 *u16src = (UINT16 *)src;
+	UINT32 *u32lookup = (UINT32 *)lookup;
+
+	while (count) {
+
+		*(u32dst0+0) = *(u32dst1+0) = RMASK32_SEMI(u32lookup[*u16src]);
+		*(u32dst0+1) = *(u32dst1+1) = GMASK32_SEMI(u32lookup[*u16src]);
+		*(u32dst0+2) = *(u32dst1+2) = BMASK32_SEMI(u32lookup[*u16src]);
+
+		++u16src;
+		u32dst0 += 3;
+		u32dst1 += 3;
+		--count;
+	}
+}
+
+void effect_rgbstripe_32_32_direct(void *dst0, void *dst1, const void *src, unsigned count)
+{
+	UINT32 *u32dst0 = (UINT32 *)dst0;
+	UINT32 *u32dst1 = (UINT32 *)dst1;
+	UINT32 *u32src = (UINT32 *)src;
+
+	while (count) {
+
+		*(u32dst0+0) = *(u32dst1+0) = RMASK32_SEMI(*u32src);
+		*(u32dst0+1) = *(u32dst1+1) = GMASK32_SEMI(*u32src);
+		*(u32dst0+2) = *(u32dst1+2) = BMASK32_SEMI(*u32src);
+
+		++u32src;
+		u32dst0 += 3;
+		u32dst1 += 3;
+		--count;
+	}
+}
+
+#ifdef USE_HWSCALE
+#define RMASK 0xff0000
+#define GMASK 0xff00
+#define BMASK 0xff
+
+void effect_rgbstripe_16_YUY2 (void *dst0, void *dst1, const void *src, unsigned count, const void *lookup)
+{
+	UINT32 *u32dst0 = (UINT32 *)dst0;
+	UINT32 *u32dst1 = (UINT32 *)dst1;
+	UINT16 *u16src = (UINT16 *)src;
+	UINT32 *u32lookup = (UINT32 *)lookup;
+	UINT32 r,g,b,y,u,v,y2,u2,v2,s;
+	INT32 us,vs;
+	UINT16 t, t2;
+
+	s = 1;
+	while (count) {
+		if (s) {
+			r = u32lookup[*u16src];
+			y = r&255;
+			u = (r>>8)&255;
+			v = (r>>24);
+			us = u - 128;
+			vs = v - 128;
+			r = ((512*y + 718*vs) >> 9);
+			g = ((512*y - 176*us - 366*vs) >> 9);
+			b = ((512*y + 907*us) >> 9);
+			y = (( 9897*r + 19235*(g&0x7f) + 3736*(b&0x7f) ) >> 15);
+			u = (( -5537*r - 10878*(g&0x7f) + 16384*(b&0x7f) ) >> 15) + 128;
+			v = (( 16384*r - 13730*(g&0x7f) - 2664*(b&0x7f) ) >> 15) + 128;
+			y2 = (( 9897*(r&0x7f) + 19235*g + 3736*(b&0x7f) ) >> 15);
+			u2 = (( -5537*(r&0x7f) - 10878*g + 16384*(b&0x7f) ) >> 15) + 128;
+			v2 = (( 16384*(r&0x7f) - 13730*g - 2664*(b&0x7f) ) >> 15) + 128;
+			u = (((u&255)+(u2&255))>>1);
+			v = (((v&255)+(v2&255))>>1);
+			*u32dst0 = *u32dst1 = (y&255)|((u&255)<<8)|((y2&255)<<16)|((v&255)<<24);
+			if (count != 1) {
+				y = (( 9897*(r&0x7f) + 19235*(g&0x7f) + 3736*b ) >> 15);
+				u = (( -5537*(r&0x7f) - 10878*(g&0x7f) + 16384*b ) >> 15) + 128;
+				v = (( 16384*(r&0x7f) - 13730*(g&0x7f) - 2664*b ) >> 15) + 128;
+				r = u32lookup[*(u16src+1)];
+				y2 = r&255;
+				u2 = (r>>8)&255;
+				v2 = (r>>24);
+				us = u2 - 128;
+				vs = v2 - 128;
+				r = ((512*y2 + 718*vs) >> 9);
+				g = ((512*y2 - 176*us - 366*vs) >> 9);
+				b = ((512*y2 + 907*us) >> 9);
+				y2 = (( 9897*r + 19235*(g&0x7f) + 3736*(b&0x7f) ) >> 15);
+				u2 = (( -5537*r - 10878*(g&0x7f) + 16384*(b&0x7f) ) >> 15) + 128;
+				v2 = (( 16384*r - 13730*(g&0x7f) - 2664*(b&0x7f) ) >> 15) + 128;
+				u = (((u&255)+(u2&255))>>1);
+				v = (((v&255)+(v2&255))>>1);
+				*(u32dst0+1) = *(u32dst1+1) = (y&255)|((u&255)<<8)|((y2&255)<<16)|((v&255)<<24);
+			}
+		} else {
+			r = u32lookup[*u16src];
+			y = r&255;
+			u = (r>>8)&255;
+			v = (r>>24);
+			us = u - 128;
+			vs = v - 128;
+			r = ((512*y + 718*vs) >> 9);
+			g = ((512*y - 176*us - 366*vs) >> 9);
+			b = ((512*y + 907*us) >> 9);
+			y = (( 9897*(r&0x7f) + 19235*g + 3736*(b&0x7f) ) >> 15);
+			u = (( -5537*(r&0x7f) - 10878*g + 16384*(b&0x7f) ) >> 15) + 128;
+			v = (( 16384*(r&0x7f) - 13730*g - 2664*(b&0x7f) ) >> 15) + 128;
+			y2 = (( 9897*(r&0x7f) + 19235*(g&0x7f) + 3736*b ) >> 15);
+			u2 = (( -5537*(r&0x7f) - 10878*(g&0x7f) + 16384*b ) >> 15) + 128;
+			v2 = (( 16384*(r&0x7f) - 13730*(g&0x7f) - 2664*b ) >> 15) + 128;
+			u = (((u&255)+(u2&255))>>1);
+			v = (((v&255)+(v2&255))>>1);
+			*u32dst0 = *u32dst1 = (y&255)|((u&255)<<8)|((y2&255)<<16)|((v&255)<<24);
+		}
+
+		++u16src;
+		if (s) {
+			u32dst0 += 2;
+			u32dst1 += 2;
+		} else {
+			u32dst0++;
+			u32dst1++;
+		}
+		--count;
+		s = !s;
+	}
+}
+
+void effect_rgbstripe_32_YUY2_direct(void *dst0, void *dst1, const void *src, unsigned count)
+{
+	UINT32 *u32dst0 = (UINT32 *)dst0;
+	UINT32 *u32dst1 = (UINT32 *)dst1;
+	UINT32 *u32src = (UINT32 *)src;
+	UINT32 t,r,g,b,y,u,v,y2,s;
+
+	s = 1;
+	while (count) {
+		if (s) {
+			t = RMASK32_SEMI(*u32src);
+			r = t&RMASK; r>>=16;
+			g = t&GMASK; g>>=8;
+			b = t&BMASK; b>>=0;
+			y = (( 9897*r + 19235*g + 3736*b ) >> 15);
+			u = (( -5537*r - 10878*g + 16384*b ) >> 15) + 128;
+			v = (( 16384*r - 13730*g - 2664*b ) >> 15) + 128;
+			t = GMASK32_SEMI(*u32src);
+			r = t&RMASK; r>>=16;
+			g = t&GMASK; g>>=8;
+			b = t&BMASK; b>>=0;
+			y2 = (( 9897*r + 19235*g + 3736*b ) >> 15);
+			u = (u + (( -5537*r - 10878*g + 16384*b ) >> 15) + 128)/2;
+			v = (v + (( 16384*r - 13730*g - 2664*b ) >> 15) + 128)/2;
+			*u32dst0 = *u32dst1 = (y&255)|((u&255)<<8)|((y2&255)<<16)|((v&255)<<24);
+			if (count != 1) {
+				t = BMASK32_SEMI(*u32src);
+				r = t&RMASK; r>>=16;
+				g = t&GMASK; g>>=8;
+				b = t&BMASK; b>>=0;
+				y = (( 9897*r + 19235*g + 3736*b ) >> 15);
+				u = (( -5537*r - 10878*g + 16384*b ) >> 15) + 128;
+				v = (( 16384*r - 13730*g - 2664*b ) >> 15) + 128;
+				t = BMASK32_SEMI(*(u32src+1));
+				r = t&RMASK; r>>=16;
+				g = t&GMASK; g>>=8;
+				b = t&BMASK; b>>=0;
+				y2 = (( 9897*r + 19235*g + 3736*b ) >> 15);
+				u = (u + (( -5537*r - 10878*g + 16384*b ) >> 15) + 128)/2;
+				v = (v + (( 16384*r - 13730*g - 2664*b ) >> 15) + 128)/2;
+				*(u32dst0+1) = *(u32dst1+1) = (y&255)|((u&255)<<8)|((y2&255)<<16)|((v&255)<<24);
+			}
+		} else {
+			t = GMASK32_SEMI(*u32src);
+			r = t&RMASK; r>>=16;
+			g = t&GMASK; g>>=8;
+			b = t&BMASK; b>>=0;
+			y = (( 9897*r + 19235*g + 3736*b ) >> 15);
+			u = (( -5537*r - 10878*g + 16384*b ) >> 15) + 128;
+			v = (( 16384*r - 13730*g - 2664*b ) >> 15) + 128;
+			t = BMASK32_SEMI(*u32src);
+			r = t&RMASK; r>>=16;
+			g = t&GMASK; g>>=8;
+			b = t&BMASK; b>>=0;
+			y2 = (( 9897*r + 19235*g + 3736*b ) >> 15);
+			u = (u + (( -5537*r - 10878*g + 16384*b ) >> 15) + 128)/2;
+			v = (v + (( 16384*r - 13730*g - 2664*b ) >> 15) + 128)/2;
+			*u32dst0 = *u32dst1 = (y&255)|((u&255)<<8)|((y2&255)<<16)|((v&255)<<24);
+		}
+
+		++u32src;
+		if (s) {
+			u32dst0 += 2;
+			u32dst1 += 2;
+		} else {
+			u32dst0++;
+			u32dst1++;
+		}
+		--count;
+		s = !s;
+	}
+}
+
+#undef RMASK
+#undef GMASK
+#undef BMASK
+#endif
+
+
+/**********************************
+ * rgbscan
+ **********************************/
+
+void effect_rgbscan_16_16 (void *dst0, void *dst1, void *dst2, const void *src, unsigned count, const void *lookup)
+{
+	UINT16 *u16dst0 = (UINT16 *)dst0;
+	UINT16 *u16dst1 = (UINT16 *)dst1;
+	UINT16 *u16dst2 = (UINT16 *)dst2;
+	UINT16 *u16src = (UINT16 *)src;
+	UINT32 *u32lookup = (UINT32 *)lookup;
+
+	while (count) {
+
+		*(u16dst0+0) = *(u16dst0+1) = RMASK16_SEMI(u32lookup[*u16src]);
+		*(u16dst1+0) = *(u16dst1+1) = GMASK16_SEMI(u32lookup[*u16src]);
+		*(u16dst2+0) = *(u16dst2+1) = BMASK16_SEMI(u32lookup[*u16src]);
+
+		++u16src;
+		u16dst0 += 2;
+		u16dst1 += 2;
+		u16dst2 += 2;
+		--count;
+	}
+}
+
+void effect_rgbscan_16_16_direct(void *dst0, void *dst1, void *dst2, const void *src, unsigned count)
+{
+	UINT16 *u16dst0 = (UINT16 *)dst0;
+	UINT16 *u16dst1 = (UINT16 *)dst1;
+	UINT16 *u16dst2 = (UINT16 *)dst2;
+	UINT16 *u16src = (UINT16 *)src;
+
+	while (count) {
+
+		*(u16dst0+0) = *(u16dst0+1) = RMASK16_SEMI(*u16src);
+		*(u16dst1+0) = *(u16dst1+1) = GMASK16_SEMI(*u16src);
+		*(u16dst2+0) = *(u16dst2+1) = BMASK16_SEMI(*u16src);
+
+		++u16src;
+		u16dst0 += 2;
+		u16dst1 += 2;
+		u16dst2 += 2;
+		--count;
+	}
+}
+
+void effect_rgbscan_16_24 (void *dst0, void *dst1, void *dst2, const void *src, unsigned count, const void *lookup)
+{
+	UINT32 *u32dst0 = (UINT32 *)dst0;
+	UINT32 *u32dst1 = (UINT32 *)dst1;
+	UINT32 *u32dst2 = (UINT32 *)dst2;
+	UINT16 *u16src = (UINT16 *)src;
+	UINT32 *u32lookup = (UINT32 *)lookup;
+
+	while (count) {
+
+		*(u32dst0+0) = *(u32dst0+1) = RMASK32_SEMI(u32lookup[*u16src]);
+		*(u32dst1+0) = *(u32dst1+1) = GMASK32_SEMI(u32lookup[*u16src]);
+		*(u32dst2+0) = *(u32dst2+1) = BMASK32_SEMI(u32lookup[*u16src]);
+
+		++u16src;
+		u32dst0 += 2;
+		u32dst1 += 2;
+		u32dst2 += 2;
+		--count;
+	}
+}
+
+void effect_rgbscan_16_32 (void *dst0, void *dst1, void *dst2, const void *src, unsigned count, const void *lookup)
+{
+	UINT32 *u32dst0 = (UINT32 *)dst0;
+	UINT32 *u32dst1 = (UINT32 *)dst1;
+	UINT32 *u32dst2 = (UINT32 *)dst2;
+	UINT16 *u16src = (UINT16 *)src;
+	UINT32 *u32lookup = (UINT32 *)lookup;
+
+	while (count) {
+
+		*(u32dst0+0) = *(u32dst0+1) = RMASK32_SEMI(u32lookup[*u16src]);
+		*(u32dst1+0) = *(u32dst1+1) = GMASK32_SEMI(u32lookup[*u16src]);
+		*(u32dst2+0) = *(u32dst2+1) = BMASK32_SEMI(u32lookup[*u16src]);
+
+		++u16src;
+		u32dst0 += 2;
+		u32dst1 += 2;
+		u32dst2 += 2;
+		--count;
+	}
+}
+
+void effect_rgbscan_32_32_direct(void *dst0, void *dst1, void *dst2, const void *src, unsigned count)
+{
+	UINT32 *u32dst0 = (UINT32 *)dst0;
+	UINT32 *u32dst1 = (UINT32 *)dst1;
+	UINT32 *u32dst2 = (UINT32 *)dst2;
+	UINT32 *u32src = (UINT32 *)src;
+
+	while (count) {
+
+		*(u32dst0+0) = *(u32dst0+1) = RMASK32_SEMI(*u32src);
+		*(u32dst1+0) = *(u32dst1+1) = GMASK32_SEMI(*u32src);
+		*(u32dst2+0) = *(u32dst2+1) = BMASK32_SEMI(*u32src);
+
+		++u32src;
+		u32dst0 += 2;
+		u32dst1 += 2;
+		u32dst2 += 2;
+		--count;
+	}
+}
+
+#ifdef USE_HWSCALE
+#define RMASK 0xff0000
+#define GMASK 0xff00
+#define BMASK 0xff
+
+void effect_rgbscan_16_YUY2 (void *dst0, void *dst1, void *dst2, const void *src, unsigned count, const void *lookup)
+{
+	UINT32 *u32dst0 = (UINT32 *)dst0;
+	UINT32 *u32dst1 = (UINT32 *)dst1;
+	UINT32 *u32dst2 = (UINT32 *)dst2;
+	UINT16 *u16src = (UINT16 *)src;
+	UINT32 *u32lookup = (UINT32 *)lookup;
+	UINT32 r,g,b,y,u,v;
+	INT32 us,vs;
+
+	while (count) {
+		r = u32lookup[*u16src];
+		y = r&255;
+		u = (r>>8)&255;
+		v = (r>>24);
+		us = u - 128;
+		vs = v - 128;
+		r = ((512*y + 718*vs) >> 9);
+		g = ((512*y - 176*us - 366*vs) >> 9);
+		b = ((512*y + 907*us) >> 9);
+		y = (( 9897*r + 19235*(g&0x7f) + 3736*(b&0x7f) ) >> 15);
+		u = (( -5537*r - 10878*(g&0x7f) + 16384*(b&0x7f) ) >> 15) + 128;
+		v = (( 16384*r - 13730*(g&0x7f) - 2664*(b&0x7f) ) >> 15) + 128;
+		*u32dst0 = (y&255)|((u&255)<<8)|((y&255)<<16)|((v&255)<<24);
+		y = (( 9897*(r&0x7f) + 19235*g + 3736*(b&0x7f) ) >> 15);
+		u = (( -5537*(r&0x7f) - 10878*g + 16384*(b&0x7f) ) >> 15) + 128;
+		v = (( 16384*(r&0x7f) - 13730*g - 2664*(b&0x7f) ) >> 15) + 128;
+		*u32dst1 = (y&255)|((u&255)<<8)|((y&255)<<16)|((v&255)<<24);
+		y = (( 9897*(r&0x7f) + 19235*(g&0x7f) + 3736*b ) >> 15);
+		u = (( -5537*(r&0x7f) - 10878*(g&0x7f) + 16384*b ) >> 15) + 128;
+		v = (( 16384*(r&0x7f) - 13730*(g&0x7f) - 2664*b ) >> 15) + 128;
+		*u32dst2 = (y&255)|((u&255)<<8)|((y&255)<<16)|((v&255)<<24);
+		++u16src;
+		u32dst0++;
+		u32dst1++;
+		u32dst2++;
+		--count;
+	}
+}
+
+void effect_rgbscan_32_YUY2_direct(void *dst0, void *dst1, void *dst2, const void *src, unsigned count)
+{
+	UINT32 *u32dst0 = (UINT32 *)dst0;
+	UINT32 *u32dst1 = (UINT32 *)dst1;
+	UINT32 *u32dst2 = (UINT32 *)dst2;
+	UINT32 *u32src = (UINT32 *)src;
+	UINT32 r,g,b,y,u,v;
+
+	while (count) {
+		r = RMASK32_SEMI(*u32src)&RMASK; r>>=16;
+		g = RMASK32_SEMI(*u32src)&GMASK; g>>=8;
+		b = RMASK32_SEMI(*u32src)&BMASK; b>>=0;
+		y = (( 9897*r + 19235*g + 3736*b ) >> 15);
+		u = (( -5537*r - 10878*g + 16384*b ) >> 15) + 128;
+		v = (( 16384*r - 13730*g - 2664*b ) >> 15) + 128;
+		*u32dst0 = (y&255)|((u&255)<<8)|((y&255)<<16)|((v&255)<<24);
+		r = GMASK32_SEMI(*u32src)&RMASK; r>>=16;
+		g = GMASK32_SEMI(*u32src)&GMASK; g>>=8;
+		b = GMASK32_SEMI(*u32src)&BMASK; b>>=0;
+		y = (( 9897*r + 19235*g + 3736*b ) >> 15);
+		u = (( -5537*r - 10878*g + 16384*b ) >> 15) + 128;
+		v = (( 16384*r - 13730*g - 2664*b ) >> 15) + 128;
+		*u32dst1 = (y&255)|((u&255)<<8)|((y&255)<<16)|((v&255)<<24);
+		r = BMASK32_SEMI(*u32src)&RMASK; r>>=16;
+		g = BMASK32_SEMI(*u32src)&GMASK; g>>=8;
+		b = BMASK32_SEMI(*u32src)&BMASK; b>>=0;
+		y = (( 9897*r + 19235*g + 3736*b ) >> 15);
+		u = (( -5537*r - 10878*g + 16384*b ) >> 15) + 128;
+		v = (( 16384*r - 13730*g - 2664*b ) >> 15) + 128;
+		*u32dst2 = (y&255)|((u&255)<<8)|((y&255)<<16)|((v&255)<<24);
+
+		++u32src;
+		u32dst0++;
+		u32dst1++;
+		u32dst2++;
+		--count;
+	}
+}
+
+#undef RMASK
+#undef GMASK
+#undef BMASK
+#endif
+
+
+/**********************************
+ * scan3
+ **********************************/
+
+/* All 3 lines are horizontally blurred a little
+ * (the last pixel of each three in a line is averaged with the next pixel).
+ * The first line is darkened by 25%,
+ * the second line is full brightness, and
+ * the third line is darkened by 50%.
+ */
+
+void effect_scan3_16_16 (void *dst0, void *dst1, void *dst2, const void *src, unsigned count, const void *lookup)
+{
+	UINT16 *u16dst0 = (UINT16 *)dst0;
+	UINT16 *u16dst1 = (UINT16 *)dst1;
+	UINT16 *u16dst2 = (UINT16 *)dst2;
+	UINT16 *u16src = (UINT16 *)src;
+	UINT32 *u32lookup = (UINT32 *)lookup;
+
+	while (count) {
+
+		*(u16dst0+1) = *(u16dst0+0) =
+			SHADE16_HALF(u32lookup[*u16src]) + SHADE16_FOURTH(u32lookup[*u16src]);
+		*(u16dst0+2) =
+			SHADE16_HALF( MEAN16( u32lookup[*u16src], u32lookup[*u16src+1] ) )
+			+
+			SHADE16_FOURTH( MEAN16( u32lookup[*u16src], u32lookup[*u16src+1] ) );
+
+		*(u16dst1+0) = *(u16dst1+1) = u32lookup[*u16src];
+		*(u16dst1+2) = MEAN16( u32lookup[*u16src], u32lookup[*u16src+1] );
+
+		*(u16dst2+0) = *(u16dst2+1) =
+			SHADE16_HALF(u32lookup[*u16src]);
+		*(u16dst2+2) =
+			SHADE16_HALF( MEAN16( u32lookup[*u16src], u32lookup[*u16src+1] ) );
+
+		++u16src;
+		u16dst0 += 3;
+		u16dst1 += 3;
+		u16dst2 += 3;
+		--count;
+	}
+}
+
+void effect_scan3_16_16_direct(void *dst0, void *dst1, void *dst2, const void *src, unsigned count)
+{
+	UINT16 *u16dst0 = (UINT16 *)dst0;
+	UINT16 *u16dst1 = (UINT16 *)dst1;
+	UINT16 *u16dst2 = (UINT16 *)dst2;
+	UINT16 *u16src = (UINT16 *)src;
+
+	while (count) {
+
+		*(u16dst0+1) = *(u16dst0+0) =
+			SHADE16_HALF(*u16src) + SHADE16_FOURTH(*u16src);
+		*(u16dst0+2) =
+			SHADE16_HALF( MEAN16( *u16src, *u16src+1 ) )
+			+
+			SHADE16_FOURTH( MEAN16( *u16src, *u16src+1 ) );
+
+		*(u16dst1+0) = *(u16dst1+1) = *u16src;
+		*(u16dst1+2) = MEAN16( *u16src, *u16src+1 );
+
+		*(u16dst2+0) = *(u16dst2+1) =
+			SHADE16_HALF(*u16src);
+		*(u16dst2+2) =
+			SHADE16_HALF( MEAN16( *u16src, *u16src+1 ) );
+
+		++u16src;
+		u16dst0 += 3;
+		u16dst1 += 3;
+		u16dst2 += 3;
+		--count;
+	}
+}
+
+void effect_scan3_16_24 (void *dst0, void *dst1, void *dst2, const void *src, unsigned count, const void *lookup)
+{
+	UINT32 *u32dst0 = (UINT32 *)dst0;
+	UINT32 *u32dst1 = (UINT32 *)dst1;
+	UINT32 *u32dst2 = (UINT32 *)dst2;
+	UINT16 *u16src = (UINT16 *)src;
+	UINT32 *u32lookup = (UINT32 *)lookup;
+
+	while (count) {
+
+		*(u32dst0+1) = *(u32dst0+0) =
+			SHADE32_HALF(u32lookup[*u16src]) + SHADE32_FOURTH(u32lookup[*u16src]);
+		*(u32dst0+2) =
+			SHADE32_HALF( MEAN32( u32lookup[*u16src], u32lookup[*u16src+1] ) )
+			+
+			SHADE32_FOURTH( MEAN32( u32lookup[*u16src], u32lookup[*u16src+1] ) );
+
+		*(u32dst1+0) = *(u32dst1+1) = u32lookup[*u16src];
+		*(u32dst1+2) = MEAN32( u32lookup[*u16src], u32lookup[*u16src+1] );
+
+		*(u32dst2+0) = *(u32dst2+1) =
+			SHADE32_HALF(u32lookup[*u16src]);
+		*(u32dst2+2) =
+			SHADE32_HALF( MEAN32( u32lookup[*u16src], u32lookup[*u16src+1] ) );
+
+		++u16src;
+		u32dst0 += 3;
+		u32dst1 += 3;
+		u32dst2 += 3;
+		--count;
+	}
+}
+
+void effect_scan3_16_32 (void *dst0, void *dst1, void *dst2, const void *src, unsigned count, const void *lookup)
+{
+	UINT32 *u32dst0 = (UINT32 *)dst0;
+	UINT32 *u32dst1 = (UINT32 *)dst1;
+	UINT32 *u32dst2 = (UINT32 *)dst2;
+	UINT16 *u16src = (UINT16 *)src;
+	UINT32 *u32lookup = (UINT32 *)lookup;
+
+	while (count) {
+
+		*(u32dst0+1) = *(u32dst0+0) =
+			SHADE32_HALF(u32lookup[*u16src]) + SHADE32_FOURTH(u32lookup[*u16src]);
+		*(u32dst0+2) =
+			SHADE32_HALF( MEAN32( u32lookup[*u16src], u32lookup[*u16src+1] ) )
+			+
+			SHADE32_FOURTH( MEAN32( u32lookup[*u16src], u32lookup[*u16src+1] ) );
+
+		*(u32dst1+0) = *(u32dst1+1) = u32lookup[*u16src];
+		*(u32dst1+2) = MEAN32( u32lookup[*u16src], u32lookup[*u16src+1] );
+
+		*(u32dst2+0) = *(u32dst2+1) =
+			SHADE32_HALF(u32lookup[*u16src]);
+		*(u32dst2+2) =
+			SHADE32_HALF( MEAN32( u32lookup[*u16src], u32lookup[*u16src+1] ) );
+
+		++u16src;
+		u32dst0 += 3;
+		u32dst1 += 3;
+		u32dst2 += 3;
+		--count;
+	}
+}
+
+void effect_scan3_32_32_direct(void *dst0, void *dst1, void *dst2, const void *src, unsigned count)
+{
+	UINT32 *u32dst0 = (UINT32 *)dst0;
+	UINT32 *u32dst1 = (UINT32 *)dst1;
+	UINT32 *u32dst2 = (UINT32 *)dst2;
+	UINT32 *u32src = (UINT32 *)src;
+
+	while (count) {
+
+		*(u32dst0+1) = *(u32dst0+0) =
+			SHADE32_HALF(*u32src) + SHADE32_FOURTH(*u32src);
+		*(u32dst0+2) =
+			SHADE32_HALF( MEAN32( *u32src, *(u32src+1) ) )
+			+
+			SHADE32_FOURTH( MEAN32( *u32src, *(u32src+1) ) );
+
+		*(u32dst1+0) = *(u32dst1+1) = *u32src;
+		*(u32dst1+2) = MEAN32( *u32src, *(u32src+1) );
+
+		*(u32dst2+0) = *(u32dst2+1) =
+			SHADE32_HALF(*u32src);
+		*(u32dst2+2) =
+			SHADE32_HALF( MEAN32( *u32src, *(u32src+1) ) );
+
+		++u32src;
+		u32dst0 += 3;
+		u32dst1 += 3;
+		u32dst2 += 3;
+		--count;
+	}
+}
+
+#ifdef USE_HWSCALE
+#define RMASK 0xff0000
+#define GMASK 0xff00
+#define BMASK 0xff
+
+void effect_scan3_16_YUY2 (void *dst0, void *dst1, void *dst2, const void *src, unsigned count, const void *lookup)
+{
+	UINT32 *u32dst0 = (UINT32 *)dst0;
+	UINT32 *u32dst1 = (UINT32 *)dst1;
+	UINT32 *u32dst2 = (UINT32 *)dst2;
+	UINT16 *u16src = (UINT16 *)src;
+	UINT32 *u32lookup = (UINT32 *)lookup;
+	UINT32 p1,p2,y1,uv1,uv2,y2,s;
+
+	s = 1;
+	while (count) {
+		if (s) {
+			p1 = u32lookup[*u16src];
+			y1 = p1&255;
+			uv1 = p1&0xff00ff00;
+			*u32dst0 = ((y1*3/4)&255)|(((y1*3/4)&255)<<16)|uv1;
+			if (count != 1) {
+				p2 = u32lookup[*(u16src+1)];
+				y2 = p2&255;
+				y1 = ((y1>>1) + (y2>>1))&0x000000ff;
+				uv2 = p2&0xff00ff00;
+				uv1 = ((uv1>>1)+(uv2>>1))&0xff00ff00;
+				uv1 = ((uv1>>1)+(uv2>>1))&0xff00ff00;
+				*(u32dst0+1) = ((y1*3/4)&255)|(((y2*3/4)&255)<<16)|uv1;
+			}
+		} else {
+			p1 = u32lookup[*u16src];
+			y1 = p1&255;
+			uv1 = p1&0xff00ff00;
+			p2 = u32lookup[*(u16src+1)];
+			y2 = p2&255;
+			y2 = ((y1>>1) + (y2>>1))&0x000000ff;
+			uv2 = p2&0xff00ff00;
+			uv2 = ((uv1>>1)+(uv2>>1))&0xff00ff00;
+			uv1 = ((uv1>>1)+(uv2>>1))&0xff00ff00;
+			*u32dst0 = ((y1*3/4)&255)|(((y2*3/4)&255)<<16)|uv1;
+		}
+		if (s) {
+			p1 = u32lookup[*u16src];
+			y1 = p1&255;
+			uv1 = p1&0xff00ff00;
+			*u32dst1 = (y1&255)|((y1&255)<<16)|uv1;
+			if (count != 1) {
+#if 0
+				p2 = u32lookup[*(u16src+1)];
+				y2 = p2&255;
+				y1 = ((y1>>1) + (y2>>1))&0x000000ff;
+				uv2 = p2&0xff00ff00;
+				uv1 = ((uv1>>1)+(uv2>>1))&0xff00ff00;
+				uv1 = ((uv1>>1)+(uv2>>1))&0xff00ff00;
+				*(u32dst1+1) = (y1&255)|((y2&255)<<16)|uv1;
+#endif
+			}
+		} else {
+			p1 = u32lookup[*u16src];
+			y1 = p1&255;
+			uv1 = p1&0xff00ff00;
+			p2 = u32lookup[*(u16src+1)];
+			y2 = p2&255;
+			y2 = ((y1>>1) + (y2>>1))&0x000000ff;
+			uv2 = p2&0xff00ff00;
+			uv2 = ((uv1>>1)+(uv2>>1))&0xff00ff00;
+			uv1 = ((uv1>>1)+(uv2>>1))&0xff00ff00;
+			*u32dst1 = (y1&255)|((y2&255)<<16)|uv1;
+		}
+		if (s) {
+			p1 = u32lookup[*u16src];
+			y1 = p1&255;
+			uv1 = p1&0xff00ff00;
+			*u32dst2 = ((y1/2)&255)|(((y1/2)&255)<<16)|uv1;
+			if (count != 1) {
+#if 0
+				p2 = u32lookup[*(u16src+1)];
+				y2 = p2&255;
+				y1 = ((y1>>1) + (y2>>1))&0x000000ff;
+				uv2 = p2&0xff00ff00;
+				uv1 = ((uv1>>1)+(uv2>>1))&0xff00ff00;
+				uv1 = ((uv1>>1)+(uv2>>1))&0xff00ff00;
+				*(u32dst2+1) = ((y1/2)&255)|(((y2/2)&255)<<16)|uv1;
+#endif
+			}
+		} else {
+			p1 = u32lookup[*u16src];
+			y1 = p1&255;
+			uv1 = p1&0xff00ff00;
+			p2 = u32lookup[*(u16src+1)];
+			y2 = p2&255;
+			y2 = ((y1>>1) + (y2>>1))&0x000000ff;
+			uv2 = p2&0xff00ff00;
+			uv2 = ((uv1>>1)+(uv2>>1))&0xff00ff00;
+			uv1 = ((uv1>>1)+(uv2>>1))&0xff00ff00;
+			*u32dst2 = ((y1/2)&255)|(((y2/2)&255)<<16)|uv1;
+		}
+
+		++u16src;
+		if (s) {
+			u32dst0 += 2;
+			u32dst1 += 2;
+			u32dst2 += 2;
+		} else {
+			u32dst0++;
+			u32dst1++;
+			u32dst2++;
+		}
+		--count;
+		s = !s;
+	}
+}
+
+void effect_scan3_32_YUY2_direct(void *dst0, void *dst1, void *dst2, const void *src, unsigned count)
+{
+	UINT32 *u32dst0 = (UINT32 *)dst0;
+	UINT32 *u32dst1 = (UINT32 *)dst1;
+	UINT32 *u32dst2 = (UINT32 *)dst2;
+	UINT32 *u32src = (UINT32 *)src;
+	UINT32 t,r,g,b,y,u,v,y2,s;
+
+	s = 1;
+	while (count) {
+		if (s) {
+			t = SHADE32_HALF(*u32src) + SHADE32_FOURTH(*u32src);
+			r = t&RMASK; r>>=16;
+			g = t&GMASK; g>>=8;
+			b = t&BMASK; b>>=0;
+			y = (( 9897*r + 19235*g + 3736*b ) >> 15);
+			u = (( -5537*r - 10878*g + 16384*b ) >> 15) + 128;
+			v = (( 16384*r - 13730*g - 2664*b ) >> 15) + 128;
+			*u32dst0 = (y&255)|((u&255)<<8)|((y&255)<<16)|((v&255)<<24);
+			if (count != 1) {
+				t =
+					SHADE32_HALF( MEAN32( *u32src, *(u32src+1) ) )
+					+
+					SHADE32_FOURTH( MEAN32( *u32src, *(u32src+1) ) );
+				r = t&RMASK; r>>=16;
+				g = t&GMASK; g>>=8;
+				b = t&BMASK; b>>=0;
+				y = (( 9897*r + 19235*g + 3736*b ) >> 15);
+				u = (( -5537*r - 10878*g + 16384*b ) >> 15) + 128;
+				v = (( 16384*r - 13730*g - 2664*b ) >> 15) + 128;
+				t = SHADE32_HALF(*(u32src+1)) + SHADE32_FOURTH(*(u32src+1));
+				r = t&RMASK; r>>=16;
+				g = t&GMASK; g>>=8;
+				b = t&BMASK; b>>=0;
+				y2 = (( 9897*r + 19235*g + 3736*b ) >> 15);
+				u = (u + (( -5537*r - 10878*g + 16384*b ) >> 15) + 128)/2;
+				v = (v + (( 16384*r - 13730*g - 2664*b ) >> 15) + 128)/2;
+				*(u32dst0+1) = (y&255)|((u&255)<<8)|((y2&255)<<16)|((v&255)<<24);
+			}
+		} else {
+			t = SHADE32_HALF(*u32src) + SHADE32_FOURTH(*u32src);
+			r = t&RMASK; r>>=16;
+			g = t&GMASK; g>>=8;
+			b = t&BMASK; b>>=0;
+			y = (( 9897*r + 19235*g + 3736*b ) >> 15);
+			u = (( -5537*r - 10878*g + 16384*b ) >> 15) + 128;
+			v = (( 16384*r - 13730*g - 2664*b ) >> 15) + 128;
+			t =
+				SHADE32_HALF( MEAN32( *u32src, *(u32src+1) ) )
+				+
+				SHADE32_FOURTH( MEAN32( *u32src, *(u32src+1) ) );
+			r = t&RMASK; r>>=16;
+			g = t&GMASK; g>>=8;
+			b = t&BMASK; b>>=0;
+			y2 = (( 9897*r + 19235*g + 3736*b ) >> 15);
+			u = (u + (( -5537*r - 10878*g + 16384*b ) >> 15) + 128)/2;
+			v = (v + (( 16384*r - 13730*g - 2664*b ) >> 15) + 128)/2;
+			*u32dst0 = (y&255)|((u&255)<<8)|((y2&255)<<16)|((v&255)<<24);
+		}
+		if (s) {
+			r = *u32src&RMASK; r>>=16;
+			g = *u32src&GMASK; g>>=8;
+			b = *u32src&BMASK; b>>=0;
+			y = (( 9897*r + 19235*g + 3736*b ) >> 15);
+			u = (( -5537*r - 10878*g + 16384*b ) >> 15) + 128;
+			v = (( 16384*r - 13730*g - 2664*b ) >> 15) + 128;
+			*u32dst1 = (y&255)|((u&255)<<8)|((y&255)<<16)|((v&255)<<24);
+			if (count != 1) {
+				t = MEAN32( *u32src, *(u32src+1) );
+				r = t&RMASK; r>>=16;
+				g = t&GMASK; g>>=8;
+				b = t&BMASK; b>>=0;
+				y = (( 9897*r + 19235*g + 3736*b ) >> 15);
+				u = (( -5537*r - 10878*g + 16384*b ) >> 15) + 128;
+				v = (( 16384*r - 13730*g - 2664*b ) >> 15) + 128;
+				r = *(u32src+1)&RMASK; r>>=16;
+				g = *(u32src+1)&GMASK; g>>=8;
+				b = *(u32src+1)&BMASK; b>>=0;
+				y2 = (( 9897*r + 19235*g + 3736*b ) >> 15);
+				u = (u + (( -5537*r - 10878*g + 16384*b ) >> 15) + 128)/2;
+				v = (v + (( 16384*r - 13730*g - 2664*b ) >> 15) + 128)/2;
+				*(u32dst1+1) = (y&255)|((u&255)<<8)|((y2&255)<<16)|((v&255)<<24);
+			}
+		} else {
+			r = *u32src&RMASK; r>>=16;
+			g = *u32src&GMASK; g>>=8;
+			b = *u32src&BMASK; b>>=0;
+			y = (( 9897*r + 19235*g + 3736*b ) >> 15);
+			u = (( -5537*r - 10878*g + 16384*b ) >> 15) + 128;
+			v = (( 16384*r - 13730*g - 2664*b ) >> 15) + 128;
+			t = MEAN32( *u32src, *(u32src+1) );
+			r = t&RMASK; r>>=16;
+			g = t&GMASK; g>>=8;
+			b = t&BMASK; b>>=0;
+			y2 = (( 9897*r + 19235*g + 3736*b ) >> 15);
+			u = (u + (( -5537*r - 10878*g + 16384*b ) >> 15) + 128)/2;
+			v = (v + (( 16384*r - 13730*g - 2664*b ) >> 15) + 128)/2;
+			*u32dst1 = (y&255)|((u&255)<<8)|((y2&255)<<16)|((v&255)<<24);
+		}
+		if (s) {
+			t = SHADE32_HALF(*u32src);
+			r = t&RMASK; r>>=16;
+			g = t&GMASK; g>>=8;
+			b = t&BMASK; b>>=0;
+			y = (( 9897*r + 19235*g + 3736*b ) >> 15);
+			u = (( -5537*r - 10878*g + 16384*b ) >> 15) + 128;
+			v = (( 16384*r - 13730*g - 2664*b ) >> 15) + 128;
+			*u32dst2 = (y&255)|((u&255)<<8)|((y&255)<<16)|((v&255)<<24);
+			if (count != 1) {
+				t = SHADE32_HALF( MEAN32( *u32src, *(u32src+1) ) );
+				r = t&RMASK; r>>=16;
+				g = t&GMASK; g>>=8;
+				b = t&BMASK; b>>=0;
+				y = (( 9897*r + 19235*g + 3736*b ) >> 15);
+				u = (( -5537*r - 10878*g + 16384*b ) >> 15) + 128;
+				v = (( 16384*r - 13730*g - 2664*b ) >> 15) + 128;
+				t = SHADE32_HALF(*(u32src+1));
+				r = t&RMASK; r>>=16;
+				g = t&GMASK; g>>=8;
+				b = t&BMASK; b>>=0;
+				y2 = (( 9897*r + 19235*g + 3736*b ) >> 15);
+				u = (u + (( -5537*r - 10878*g + 16384*b ) >> 15) + 128)/2;
+				v = (v + (( 16384*r - 13730*g - 2664*b ) >> 15) + 128)/2;
+				*(u32dst1+1) = (y&255)|((u&255)<<8)|((y2&255)<<16)|((v&255)<<24);
+			}
+		} else {
+			t = SHADE32_HALF(*u32src);
+			r = t&RMASK; r>>=16;
+			g = t&GMASK; g>>=8;
+			b = t&BMASK; b>>=0;
+			y = (( 9897*r + 19235*g + 3736*b ) >> 15);
+			u = (( -5537*r - 10878*g + 16384*b ) >> 15) + 128;
+			v = (( 16384*r - 13730*g - 2664*b ) >> 15) + 128;
+			t = SHADE32_HALF( MEAN32( *u32src, *(u32src+1) ) );
+			r = t&RMASK; r>>=16;
+			g = t&GMASK; g>>=8;
+			b = t&BMASK; b>>=0;
+			y2 = (( 9897*r + 19235*g + 3736*b ) >> 15);
+			u = (u + (( -5537*r - 10878*g + 16384*b ) >> 15) + 128)/2;
+			v = (v + (( 16384*r - 13730*g - 2664*b ) >> 15) + 128)/2;
+			*u32dst2 = (y&255)|((u&255)<<8)|((y2&255)<<16)|((v&255)<<24);
+		}
+		++u32src;
+		if (s) {
+			u32dst0 += 2;
+			u32dst1 += 2;
+			u32dst2 += 2;
+		} else {
+			u32dst0++;
+			u32dst1++;
+			u32dst2++;
+		}
+		--count;
+		s = !s;
+	}
+}
+
+#undef RMASK
+#undef GMASK
+#undef BMASK
+#endif
+
+
+/**********************************
+ * rotate
+ **********************************/
+
+void rotate_16_16(void *dst, struct mame_bitmap *bitmap, int y)
+{
+	int x;
+	UINT16 * u16dst = (UINT16 *)dst;
+
+	if (blit_swapxy) {
+		if (blit_flipx && blit_flipy)
+			for (x = visual.min_x; x <= visual.max_x; x++)
+				u16dst[x-visual.min_x] = ((UINT16 *)bitmap->line[bitmap->height - x - 1])[bitmap->width - y - 1];
+		else if (blit_flipx)
+			for (x = visual.min_x; x <= visual.max_x; x++)
+				u16dst[x-visual.min_x] = ((UINT16 *)bitmap->line[bitmap->height - x - 1])[y];
+		else if (blit_flipy)
+			for (x = visual.min_x; x <= visual.max_x; x++)
+				u16dst[x-visual.min_x] = ((UINT16 *)bitmap->line[x])[bitmap->width - y - 1];
+		else
+			for (x = visual.min_x; x <= visual.max_x; x++)
+				u16dst[x-visual.min_x] = ((UINT16 *)bitmap->line[x])[y];
+	} else if (blit_flipx && blit_flipy)
+		for (x = visual.min_x; x <= visual.max_x; x++)
+			u16dst[x-visual.min_x] = ((UINT16 *)bitmap->line[bitmap->height - y - 1])[bitmap->width - x - 1];
+       else if (blit_flipx)
+	       for (x = visual.min_x; x <= visual.max_x; x++)
+		       u16dst[x-visual.min_x] = ((UINT16 *)bitmap->line[y])[bitmap->width - x - 1];
+       else if (blit_flipy)
+	       for (x = visual.min_x; x <= visual.max_x; x++)
+		       u16dst[x-visual.min_x] = ((UINT16 *)bitmap->line[bitmap->height - y -1])[x];
+}
+
+void rotate_32_32(void *dst, struct mame_bitmap *bitmap, int y)
+{
+	int x;
+	UINT32 * u32dst = (UINT32 *)dst;
+
+	if (blit_swapxy) {
+		if (blit_flipx && blit_flipy)
+			for (x = visual.min_x; x <= visual.max_x; x++)
+				u32dst[x-visual.min_x] = ((UINT32 *)bitmap->line[bitmap->height - x - 1])[bitmap->width - y - 1];
+		else if (blit_flipx)
+			for (x = visual.min_x; x <= visual.max_x; x++)
+				u32dst[x-visual.min_x] = ((UINT32 *)bitmap->line[bitmap->height - x - 1])[y];
+		else if (blit_flipy)
+			for (x = visual.min_x; x <= visual.max_x; x++)
+				u32dst[x-visual.min_x] = ((UINT32 *)bitmap->line[x])[bitmap->width - y - 1];
+		else
+			for (x = visual.min_x; x <= visual.max_x; x++)
+				u32dst[x-visual.min_x] = ((UINT32 *)bitmap->line[x])[y];
+	} else if (blit_flipx && blit_flipy)
+		for (x = visual.min_x; x <= visual.max_x; x++)
+			u32dst[x-visual.min_x] = ((UINT32 *)bitmap->line[bitmap->height - y - 1])[bitmap->width - x - 1];
+       else if (blit_flipx)
+	       for (x = visual.min_x; x <= visual.max_x; x++)
+		       u32dst[x-visual.min_x] = ((UINT32 *)bitmap->line[y])[bitmap->width - x - 1];
+       else if (blit_flipy)
+	       for (x = visual.min_x; x <= visual.max_x; x++)
+		       u32dst[x-visual.min_x] = ((UINT32 *)bitmap->line[bitmap->height - y -1])[x];
+}
diff --git a/src/unix/effect.h b/src/unix/effect.h
new file mode 100644
index 0000000..9041416
--- /dev/null
+++ b/src/unix/effect.h
@@ -0,0 +1,138 @@
+#ifndef __EFFECT_H
+#define __EFFECT_H
+
+#ifdef __EFFECT_C_
+#define EXTERN_EFFECT
+#else
+#define EXTERN_EFFECT extern
+#endif
+
+/* effect type */
+EXTERN_EFFECT int effect;
+enum {EFFECT_NONE, EFFECT_SCALE2X, EFFECT_SCAN2, EFFECT_RGBSTRIPE, EFFECT_RGBSCAN, EFFECT_SCAN3};
+#define EFFECT_LAST EFFECT_SCAN3
+
+/* buffer for doublebuffering */
+EXTERN_EFFECT char *effect_dbbuf;
+EXTERN_EFFECT char *rotate_dbbuf;
+EXTERN_EFFECT char *rotate_dbbuf0;
+EXTERN_EFFECT char *rotate_dbbuf1;
+EXTERN_EFFECT char *rotate_dbbuf2;
+
+/* from video.c, needed to scale the display according to the requirements of the effect */
+extern int normal_widthscale, normal_heightscale;
+
+/* called from config.c to set scale parameters */
+void effect_init1();
+
+/* called from <driver>_create_display by each video driver;
+ * initializes function pointers to correct depths
+ * and allocates buffer for doublebuffering */
+void effect_init2(int src_depth, int dst_depth, int dst_width);
+
+/*** effect function pointers (use these) ***/
+EXTERN_EFFECT void (*effect_scale2x_func)
+		(void *dst0, void *dst1,
+		const void *src0, const void *src1, const void *src2,
+		unsigned count, const void *lookup);
+EXTERN_EFFECT void (*effect_scale2x_direct_func)
+		(void *dst0, void *dst1,
+		const void *src0, const void *src1, const void *src2,
+		unsigned count);
+
+EXTERN_EFFECT void (*effect_scan2_func)(void *dst0, void *dst1, const void *src, unsigned count, const void *lookup);
+EXTERN_EFFECT void (*effect_scan2_direct_func)(void *dst0, void *dst1, const void *src, unsigned count);
+
+EXTERN_EFFECT void (*effect_rgbstripe_func)(void *dst0, void *dst1, const void *src, unsigned count, const void *lookup);
+EXTERN_EFFECT void (*effect_rgbstripe_direct_func)(void *dst0, void *dst1, const void *src, unsigned count);
+
+EXTERN_EFFECT void (*effect_rgbscan_func)(void *dst0, void *dst1, void *dst2, const void *src, unsigned count, const void *lookup);
+EXTERN_EFFECT void (*effect_rgbscan_direct_func)(void *dst0, void *dst1, void *dst2, const void *src, unsigned count);
+
+EXTERN_EFFECT void (*effect_scan3_func)(void *dst0, void *dst1, void *dst2, const void *src, unsigned count, const void *lookup);
+EXTERN_EFFECT void (*effect_scan3_direct_func)(void *dst0, void *dst1, void *dst2, const void *src, unsigned count);
+
+/********************************************/
+
+void effect_scale2x_16_16
+		(void *dst0, void *dst1,
+		const void *src0, const void *src1, const void *src2,
+		unsigned count, const void *lookup);
+
+void effect_scale2x_16_16_direct
+		(void *dst0, void *dst1,
+		const void *src0, const void *src1, const void *src2,
+		unsigned count);
+
+void effect_scale2x_16_YUY2
+		(void *dst0, void *dst1,
+		const void *src0, const void *src1, const void *src2,
+		unsigned count, const void *lookup);
+
+void effect_scale2x_32_YUY2_direct
+		(void *dst0, void *dst1,
+		const void *src0, const void *src1, const void *src2,
+		unsigned count);
+
+void effect_scale2x_16_24
+		(void *dst0, void *dst1,
+		const void *src0, const void *src1, const void *src2,
+		unsigned count, const void *lookup);
+
+void effect_scale2x_16_32
+		(void *dst0, void *dst1,
+		const void *src0, const void *src1, const void *src2,
+		unsigned count, const void *lookup);
+
+void effect_scale2x_32_32_direct
+		(void *dst0, void *dst1,
+		const void *src0, const void *src1, const void *src2,
+		unsigned count);
+
+/*****************************/
+
+void effect_scan2_16_16 (void *dst0, void *dst1, const void *src, unsigned count, const void *lookup);
+void effect_scan2_16_16_direct(void *dst0, void *dst1, const void *src, unsigned count);
+void effect_scan2_16_24 (void *dst0, void *dst1, const void *src, unsigned count, const void *lookup);
+void effect_scan2_16_32 (void *dst0, void *dst1, const void *src, unsigned count, const void *lookup);
+void effect_scan2_16_YUY2 (void *dst0, void *dst1, const void *src, unsigned count, const void *lookup);
+void effect_scan2_32_32_direct(void *dst0, void *dst1, const void *src, unsigned count);
+void effect_scan2_32_YUY2_direct(void *dst0, void *dst1, const void *src, unsigned count);
+
+/*****************************/
+
+void effect_rgbstripe_16_16 (void *dst0, void *dst1, const void *src, unsigned count, const void *lookup);
+void effect_rgbstripe_16_16_direct(void *dst0, void *dst1, const void *src, unsigned count);
+void effect_rgbstripe_16_24 (void *dst0, void *dst1, const void *src, unsigned count, const void *lookup);
+void effect_rgbstripe_16_32 (void *dst0, void *dst1, const void *src, unsigned count, const void *lookup);
+void effect_rgbstripe_16_YUY2 (void *dst0, void *dst1, const void *src, unsigned count, const void *lookup);
+void effect_rgbstripe_32_32_direct(void *dst0, void *dst1, const void *src, unsigned count);
+void effect_rgbstripe_32_YUY2_direct(void *dst0, void *dst1, const void *src, unsigned count);
+
+/*****************************/
+
+void effect_rgbscan_16_16 (void *dst0, void *dst1, void *dst2, const void *src, unsigned count, const void *lookup);
+void effect_rgbscan_16_16_direct(void *dst0, void *dst1, void *dst2, const void *src, unsigned count);
+void effect_rgbscan_16_24 (void *dst0, void *dst1, void *dst2, const void *src, unsigned count, const void *lookup);
+void effect_rgbscan_16_32 (void *dst0, void *dst1, void *dst2, const void *src, unsigned count, const void *lookup);
+void effect_rgbscan_16_YUY2 (void *dst0, void *dst1, void *dst2, const void *src, unsigned count, const void *lookup);
+void effect_rgbscan_32_32_direct(void *dst0, void *dst1, void *dst2, const void *src, unsigned count);
+void effect_rgbscan_32_YUY2_direct(void *dst0, void *dst1, void *dst2, const void *src, unsigned count);
+
+/*****************************/
+
+void effect_scan3_16_16 (void *dst0, void *dst1, void *dst2, const void *src, unsigned count, const void *lookup);
+void effect_scan3_16_16_direct(void *dst0, void *dst1, void *dst2, const void *src, unsigned count);
+void effect_scan3_16_24 (void *dst0, void *dst1, void *dst2, const void *src, unsigned count, const void *lookup);
+void effect_scan3_16_32 (void *dst0, void *dst1, void *dst2, const void *src, unsigned count, const void *lookup);
+void effect_scan3_16_YUY2 (void *dst0, void *dst1, void *dst2, const void *src, unsigned count, const void *lookup);
+void effect_scan3_32_32_direct(void *dst0, void *dst1, void *dst2, const void *src, unsigned count);
+void effect_scan3_32_YUY2_direct(void *dst0, void *dst1, void *dst2, const void *src, unsigned count);
+
+/*****************************/
+
+EXTERN_EFFECT void (*rotate_func)(void *dst, struct mame_bitmap *bitamp, int y);
+void rotate_16_16(void *dst, struct mame_bitmap *bitmap, int y);
+void rotate_32_32(void *dst, struct mame_bitmap *bitmap, int y);
+
+#endif /* __EFFECT_H */
diff --git a/src/unix/fileio.c b/src/unix/fileio.c
new file mode 100644
index 0000000..5c105d8
--- /dev/null
+++ b/src/unix/fileio.c
@@ -0,0 +1,733 @@
+/*============================================================ */
+/* */
+/*	fileio.c - Unix file access functions */
+/* */
+/*============================================================ */
+
+#include <stdarg.h>
+#include "xmame.h"
+#include "osdutils.h"
+#include "unzip.h"
+#ifdef MESS
+#include "image.h"
+#endif
+
+
+#define VERBOSE				0
+
+#define MAX_OPEN_FILES		16
+#define FILE_BUFFER_SIZE	256
+
+
+/*============================================================ */
+/*	EXTERNALS */
+/*============================================================ */
+
+extern char *rompath_extra;
+
+/* from datafile.c */
+extern const char *db_filename;
+extern const char *history_filename;
+extern const char *mameinfo_filename;
+
+/* from cheat.c */
+extern char *cheatfile;
+
+
+
+/*============================================================ */
+/*	TYPE DEFINITIONS */
+/*============================================================ */
+
+struct pathdata
+{
+	const char *rawpath;
+	const char **path;
+	int pathcount;
+};
+
+struct _osd_file
+{
+	FILE		*fileptr;
+	long		filepos;
+	long		end;
+	long		offset;
+	long		bufferbase;
+	long		bufferbytes;
+	unsigned char	buffer[FILE_BUFFER_SIZE];
+};
+
+static struct pathdata pathlist[FILETYPE_end];
+static osd_file openfile[MAX_OPEN_FILES];
+
+
+
+/*============================================================ */
+/*	GLOBAL VARIABLES */
+/*============================================================ */
+
+FILE *errorlog = NULL;
+
+#ifdef MESS
+static char crcfilename[256] = "";
+const char *crcfile = crcfilename;
+static char pcrcfilename[256] = "";
+const char *pcrcfile = pcrcfilename;
+char crcdir[256];
+#endif
+
+char *playbackname;
+char *recordname;
+
+FILE *stdout_file;
+FILE *stderr_file;
+
+
+/*============================================================ */
+/*	FILE PATH OPTIONS */
+/*============================================================ */
+
+struct rc_option fileio_opts[] =
+{
+	/* name, shortname, type, dest, deflt, min, max, func, help */
+	{ "File I/O-related", NULL, rc_seperator, NULL, NULL, 0, 0, NULL, NULL },
+#ifndef MESS
+	{ "rompath", "rp", rc_string, &pathlist[FILETYPE_ROM].rawpath, XMAMEROOT"/roms", 0, 0, NULL, "Search path for rom files" },
+#else
+	{ "biospath", "bp", rc_string, &pathlist[FILETYPE_ROM].rawpath, XMAMEROOT"/bios", 0, 0, NULL, "Search path for BIOS sets" },
+	{ "softwarepath", "swp", rc_string, &pathlist[FILETYPE_IMAGE].rawpath, XMAMEROOT"/software", 0, 0, NULL,  "Search path for software" },
+	{ "CRC_directory", "crc", rc_string, &pathlist[FILETYPE_CRC].rawpath, XMAMEROOT"/crc", 0, 0, NULL, "Directory containing CRC files" },
+#endif
+	{ "samplepath", "sp", rc_string, &pathlist[FILETYPE_SAMPLE].rawpath, XMAMEROOT"/samples", 0, 0, NULL, "Search path for sample files" },
+	{ "inipath", NULL, rc_string, &pathlist[FILETYPE_INI].rawpath, XMAMEROOT"/ini", 0, 0, NULL, "Search path for ini files" },
+	{ "cfg_directory", NULL, rc_string, &pathlist[FILETYPE_CONFIG].rawpath, "$HOME/."NAME"/cfg", 0, 0, NULL, "Directory to save configurations" },
+	{ "nvram_directory", NULL, rc_string, &pathlist[FILETYPE_NVRAM].rawpath, "$HOME/."NAME"/nvram", 0, 0, NULL, "Directory to save nvram contents" },
+	{ "memcard_directory", NULL, rc_string, &pathlist[FILETYPE_MEMCARD].rawpath, "$HOME/."NAME"/memcard", 0, 0, NULL, "Directory to save memory card contents" },
+	{ "input_directory", NULL, rc_string, &pathlist[FILETYPE_INPUTLOG].rawpath, "$HOME/."NAME"/inp", 0, 0, NULL, "Directory to save input device logs" },
+	{ "hiscore_directory", NULL, rc_string, &pathlist[FILETYPE_HIGHSCORE].rawpath, "$HOME/."NAME"/hi", 0, 0, NULL, "Directory to save hiscores" },
+	{ "state_directory", NULL, rc_string, &pathlist[FILETYPE_STATE].rawpath, "$HOME/."NAME"/sta", 0, 0, NULL, "Directory to save states" },
+	{ "artwork_directory", NULL, rc_string, &pathlist[FILETYPE_ARTWORK].rawpath, XMAMEROOT"/artwork", 0, 0, NULL, "Directory for Artwork (Overlays etc.)" },
+	{ "snapshot_directory", NULL, rc_string, &pathlist[FILETYPE_SCREENSHOT].rawpath, XMAMEROOT"/snap", 0, 0, NULL, "Directory for screenshots (.png format)" },
+	{ "diff_directory", NULL, rc_string, &pathlist[FILETYPE_IMAGE_DIFF].rawpath, "$HOME/."NAME"/diff", 0, 0, NULL, "Directory for hard drive image difference files" },
+	{ "ctrlr_directory", NULL, rc_string, &pathlist[FILETYPE_CTRLR].rawpath, XMAMEROOT"/ctrlr", 0, 0, NULL, "Directory to save controller definitions" },
+	{ "cheat_file", NULL, rc_string, &cheatfile, XMAMEROOT"/cheat.dat", 0, 0, NULL, "Cheat filename" },
+	{ "hiscore_file", NULL, rc_string, &db_filename, XMAMEROOT"/hiscore.dat", 0, 0, NULL, NULL },
+#ifdef MESS
+	{ "sysinfo_file", NULL, rc_string, &history_filename, XMAMEROOT"/sysinfo.dat", 0, 0, NULL, NULL },
+	{ "messinfo_file", NULL, rc_string, &mameinfo_filename, XMAMEROOT"/messinfo.dat", 0, 0, NULL, NULL },
+#else
+	{ "history_file", NULL, rc_string, &history_filename, XMAMEROOT"/history.dat", 0, 0, NULL, NULL },
+	{ "mameinfo_file", NULL, rc_string, &mameinfo_filename, XMAMEROOT"/mameinfo.dat", 0, 0, NULL, NULL },
+#endif
+	{ "record", "rec", rc_string, &recordname, NULL, 0, 0, NULL, "Set a file to record keypresses into" },
+	{ "playback", "pb", rc_string, &playbackname, NULL, 0, 0, NULL, "Set a file to playback keypresses from" },
+	{ "stdout-file", "out", rc_file, &stdout_file, NULL, 1,	0, NULL, "Set a file to redirect stdout to" },
+	{ "stderr-file", "err",	rc_file, &stderr_file, NULL, 1, 0, NULL, "Set a file to redirect stderr to" },
+	{ "log", "L", rc_file, &errorlog, NULL, 1, 0, NULL, "Set a file to log debug info to" },
+	{ NULL,	NULL, rc_end, NULL, NULL, 0, 0,	NULL, NULL }
+};
+
+
+
+/*============================================================ */
+/*	is_pathsep */
+/*============================================================ */
+
+INLINE int is_pathsep(char c)
+{
+	return (c == '/' || c == '\\');
+}
+
+
+
+/*============================================================ */
+/*	find_reverse_path_sep */
+/*============================================================ */
+
+static char *find_reverse_path_sep(char *name)
+{
+	char *p = name + strlen(name) - 1;
+	while (p >= name && !is_pathsep(*p))
+		p--;
+	return (p >= name) ? p : NULL;
+}
+
+
+
+/*============================================================ */
+/*	create_path */
+/*============================================================ */
+
+static void create_path(char *path, int has_filename)
+{
+	char *sep = find_reverse_path_sep(path);
+
+	/* if there's still a separator, and it's not the root, nuke it and recurse */
+	if (sep && sep > path && !is_pathsep(sep[-1]))
+	{
+		*sep = 0;
+		create_path(path, 0);
+		*sep = '/';
+	}
+
+	/* if we have a filename, we're done */
+	if (has_filename)
+		return;
+
+	/* create the path */
+	rc_check_and_create_dir(path);
+}
+
+
+
+/*============================================================ */
+/*	is_variablechar */
+/*============================================================ */
+
+INLINE int is_variablechar(char c)
+{
+	return (isalnum(c) || c == '_' || c == '-');
+}
+
+
+
+/*============================================================ */
+/*	parse_variable */
+/*============================================================ */
+
+static const char *parse_variable(const char **start, const char *end)
+{
+	const char *src = *start, *var;
+	char variable[1024];
+	char *dest = variable;
+
+	/* copy until we hit the end or until we hit a non-variable character */
+	for (src = *start; src < end && is_variablechar(*src); src++)
+		*dest++ = *src;
+
+	/* an empty variable means "$" and should not be expanded */
+	if (src == *start)
+		return "$";
+
+	/* NULL terminate and return a pointer to the end */
+	*dest = 0;
+	*start = src;
+
+	/* return the actual variable value */
+	var = getenv(variable);
+	return (var) ? var : "";
+}
+
+
+
+/*============================================================ */
+/*	copy_and_expand_variables */
+/*============================================================ */
+
+static char *copy_and_expand_variables(const char *path, int len)
+{
+	char *dst, *result;
+	const char *src;
+	int length = 0;
+
+	/* first determine the length of the expanded string */
+	for (src = path; src < path + len; )
+		if (*src++ == '$')
+			length += strlen(parse_variable(&src, path + len));
+		else
+			length++;
+
+	/* allocate a string of the appropriate length */
+	result = malloc(length + 1);
+	if (!result)
+		goto out_of_memory;
+
+	/* now actually generate the string */
+	for (src = path, dst = result; src < path + len; )
+	{
+		char c = *src++;
+		if (c == '$')
+			dst += sprintf(dst, "%s", parse_variable(&src, path + len));
+		else
+			*dst++ = c;
+	}
+
+	/* NULL terminate and return */
+	*dst = 0;
+	return result;
+
+out_of_memory:
+	fprintf(stderr, "Out of memory in variable expansion!\n");
+	exit(1);
+}
+
+
+
+/*============================================================ */
+/*	expand_pathlist */
+/*============================================================ */
+
+static void expand_pathlist(struct pathdata *list)
+{
+	const char *rawpath = (list->rawpath) ? list->rawpath : "";
+	const char *token;
+
+#if VERBOSE
+	printf("Expanding: %s\n", rawpath);
+#endif
+
+	/* free any existing paths */
+	if (list->pathcount != 0)
+	{
+		int pathindex;
+
+		for (pathindex = 0; pathindex < list->pathcount; pathindex++)
+			free((void *)list->path[pathindex]);
+		free(list->path);
+	}
+
+	/* by default, start with an empty list */
+	list->path = NULL;
+	list->pathcount = 0;
+
+	/* look for separators */
+	token = strchr(rawpath, ':');
+	if (!token)
+		token = rawpath + strlen(rawpath);
+
+	/* loop until done */
+	while (1)
+	{
+		/* allocate space for the new pointer */
+		list->path = realloc(list->path, (list->pathcount + 1) * sizeof(char *));
+		if (!list->path)
+			goto out_of_memory;
+
+		/* copy the path in */
+		list->path[list->pathcount++] = copy_and_expand_variables(rawpath, token - rawpath);
+#if VERBOSE
+		printf("  %s\n", list->path[list->pathcount - 1]);
+#endif
+
+		/* if this was the end, break */
+		if (*token == 0)
+			break;
+		rawpath = token + 1;
+
+		/* find the next separator */
+		token = strchr(rawpath, ':');
+		if (!token)
+			token = rawpath + strlen(rawpath);
+	}
+
+	/* when finished, reset the path info, so that future INI parsing will */
+	/* cause us to get called again */
+	list->rawpath = NULL;
+	return;
+
+out_of_memory:
+	fprintf(stderr, "Out of memory!\n");
+	exit(1);
+}
+
+
+
+/*============================================================ */
+/*	get_path_for_filetype */
+/*============================================================ */
+
+static const char *get_path_for_filetype(int filetype, int pathindex, int *count)
+{
+	struct pathdata *list;
+
+	/* handle aliasing of some paths */
+	switch (filetype)
+	{
+#ifndef MESS
+		case FILETYPE_IMAGE:
+			list = &pathlist[FILETYPE_ROM];
+			break;
+#endif
+
+		default:
+			list = &pathlist[filetype];
+			break;
+	}
+
+	/* if we don't have expanded paths, expand them now */
+	if (list->pathcount == 0 || list->rawpath)
+	{
+		/* special hack for ROMs */
+		if (list == &pathlist[FILETYPE_ROM] && rompath_extra)
+		{
+			/* this may leak a little memory, but it's a hack anyway! :-P */
+			const char *rawpath = (list->rawpath) ? list->rawpath : "";
+			char *newpath = malloc(strlen(rompath_extra) + strlen(rawpath) + 2);
+			sprintf(newpath, "%s:%s", rompath_extra, rawpath);
+			list->rawpath = newpath;
+		}
+
+		/* decompose the path */
+		expand_pathlist(list);
+	}
+
+	/* set the count */
+	if (count)
+		*count = list->pathcount;
+
+	/* return a valid path always */
+	return (pathindex < list->pathcount) ? list->path[pathindex] : "";
+}
+
+
+
+/*============================================================ */
+/*	compose_path */
+/*============================================================ */
+
+static void compose_path(char *output, int pathtype, int pathindex, const char *filename)
+{
+	const char *basepath = get_path_for_filetype(pathtype, pathindex, NULL);
+	char *p;
+
+#ifdef MESS
+	if (osd_is_absolute_path(filename))
+		basepath = NULL;
+#endif
+
+	/* compose the full path */
+	*output = 0;
+	if (basepath)
+		strcat(output, basepath);
+	if (*output && !is_pathsep(output[strlen(output) - 1]))
+		strcat(output, "/");
+	strcat(output, filename);
+
+	/* convert backslashes to forward slashes */
+	for (p = output; *p; p++)
+		if (*p == '\\')
+			*p = '/';
+}
+
+
+
+/*============================================================ */
+/*	osd_get_path_count */
+/*============================================================ */
+
+int osd_get_path_count(int pathtype)
+{
+	int count;
+
+	/* get the count and return it */
+	get_path_for_filetype(pathtype, 0, &count);
+	return count;
+}
+
+
+
+/*============================================================ */
+/*	osd_get_path_info */
+/*============================================================ */
+
+int osd_get_path_info(int pathtype, int pathindex, const char *filename)
+{
+	struct stat buf;
+	char fullpath[1024];
+
+	/* compose the full path */
+	compose_path(fullpath, pathtype, pathindex, filename);
+
+	/* get the file attributes */
+	if (stat(fullpath, &buf))
+		return PATH_NOT_FOUND;
+	else if (S_ISDIR(buf.st_mode))
+		return PATH_IS_DIRECTORY;
+	else
+		return PATH_IS_FILE;
+}
+
+
+
+/*============================================================ */
+/*	osd_fopen */
+/*============================================================ */
+
+osd_file *osd_fopen(int pathtype, int pathindex, const char *filename, const char *mode)
+{
+	char fullpath[1024];
+	osd_file *file;
+	int i;
+	int offs;
+
+	/* find an empty file pointer */
+	for (i = 0; i < MAX_OPEN_FILES; i++)
+		if (openfile[i].fileptr == NULL)
+			break;
+	if (i == MAX_OPEN_FILES)
+		return NULL;
+
+	/* zap the file record */
+	file = &openfile[i];
+	memset(file, 0, sizeof(*file));
+
+	/* compose the full path */
+	compose_path(fullpath, pathtype, pathindex, filename);
+
+	/* attempt to open the file */
+	file->fileptr = fopen(fullpath, mode);
+	if (file->fileptr == NULL)
+	{
+		/* if it's read-only, or if the path exists, then that's final */
+		if (!(strchr(mode, 'w')) || errno != EACCES)
+			return NULL;
+
+		/* create the path and try again */
+		create_path(fullpath, 1);
+		file->fileptr = fopen(fullpath, mode);
+
+		/* if that doesn't work, we give up */
+		if (file->fileptr == NULL)
+			return NULL;
+	}
+
+	/* get the file size */
+	offs = fseek(file->fileptr, 0, SEEK_END);
+	file->end = ftell(file->fileptr);
+	fseek(file->fileptr, offs, SEEK_SET);
+	return file;
+}
+
+
+
+/*============================================================ */
+/*	osd_fseek */
+/*============================================================ */
+
+int osd_fseek(osd_file *file, INT64 offset, int whence)
+{
+	/* convert the whence into method */
+	switch (whence)
+	{
+		default:
+		case SEEK_SET:	file->offset = offset;				break;
+		case SEEK_CUR:	file->offset += offset;				break;
+		case SEEK_END:	file->offset = file->end + offset;	break;
+	}
+	return 0;
+}
+
+
+
+/*============================================================ */
+/*	osd_ftell */
+/*============================================================ */
+
+UINT64 osd_ftell(osd_file *file)
+{
+	return file->offset;
+}
+
+
+
+/*============================================================ */
+/*	osd_feof */
+/*============================================================ */
+
+int osd_feof(osd_file *file)
+{
+	return (file->offset >= file->end);
+}
+
+
+
+/*============================================================ */
+/*	osd_fread */
+/*============================================================ */
+
+UINT32 osd_fread(osd_file *file, void *buffer, UINT32 length)
+{
+	UINT32 bytes_left = length;
+	int bytes_to_copy;
+	int result;
+
+	/* handle data from within the buffer */
+	if (file->offset >= file->bufferbase && file->offset < file->bufferbase + file->bufferbytes)
+	{
+		/* copy as much as we can */
+		bytes_to_copy = file->bufferbase + file->bufferbytes - file->offset;
+		if (bytes_to_copy > length)
+			bytes_to_copy = length;
+		memcpy(buffer, &file->buffer[file->offset - file->bufferbase], bytes_to_copy);
+
+		/* account for it */
+		bytes_left -= bytes_to_copy;
+		file->offset += bytes_to_copy;
+		buffer = (unsigned char *)buffer + bytes_to_copy;
+
+		/* if that's it, we're done */
+		if (bytes_left == 0)
+			return length;
+	}
+
+	/* attempt to seek to the current location if we're not there already */
+	if (file->offset != file->filepos)
+	{
+		result = fseek(file->fileptr, file->offset, SEEK_SET);
+		if (result && errno)
+		{
+			file->filepos = ~0;
+			return length - bytes_left;
+		}
+		file->filepos = file->offset;
+	}
+
+	/* if we have a small read remaining, do it to the buffer and copy out the results */
+	if (length < FILE_BUFFER_SIZE/2)
+	{
+		/* read as much of the buffer as we can */
+		file->bufferbase = file->offset;
+		file->bufferbytes = 0;
+		file->bufferbytes = fread(file->buffer, sizeof(unsigned char), FILE_BUFFER_SIZE, file->fileptr);
+		file->filepos += file->bufferbytes;
+
+		/* copy it out */
+		bytes_to_copy = bytes_left;
+		if (bytes_to_copy > file->bufferbytes)
+			bytes_to_copy = file->bufferbytes;
+		memcpy(buffer, file->buffer, bytes_to_copy);
+
+		/* adjust pointers and return */
+		file->offset += bytes_to_copy;
+		bytes_left -= bytes_to_copy;
+		return length - bytes_left;
+	}
+
+	/* otherwise, just read directly to the buffer */
+	else
+	{
+		/* do the read */
+		result = fread(buffer, sizeof(unsigned char), bytes_left, file->fileptr);
+		file->filepos += result;
+
+		/* adjust the pointers and return */
+		file->offset += result;
+		bytes_left -= result;
+		return length - bytes_left;
+	}
+}
+
+
+
+/*============================================================ */
+/*	osd_fwrite */
+/*============================================================ */
+
+UINT32 osd_fwrite(osd_file *file, const void *buffer, UINT32 length)
+{
+	int result;
+
+	/* invalidate any buffered data */
+	file->bufferbytes = 0;
+
+	/* attempt to seek to the current location */
+	result = fseek(file->fileptr, file->offset, SEEK_SET);
+	if (result && errno)
+		return 0;
+
+	/* do the write */
+	result = fwrite(buffer, sizeof(unsigned char), length, file->fileptr);
+	file->filepos += result;
+
+	/* adjust the pointers */
+	file->offset += result;
+	if (file->offset > file->end)
+		file->end = file->offset;
+	return result;
+}
+
+
+
+/*============================================================ */
+/*	osd_fclose */
+/*============================================================ */
+
+void osd_fclose(osd_file *file)
+{
+	/* close the handle and clear it out */
+	if (file->fileptr)
+		fclose(file->fileptr);
+	file->fileptr = NULL;
+}
+
+
+
+#ifdef MESS
+/*============================================================ */
+/*	osd_create_directory */
+/*============================================================ */
+
+int osd_create_directory(int pathtype, int pathindex, const char *dirname)
+{
+	char fullpath[1024];
+
+	/* compose the full path */
+	compose_path(fullpath, pathtype, pathindex, dirname);
+
+	return rc_check_and_create_dir(fullpath) ? 0 : 1;
+}
+#endif
+
+/*============================================================ */
+/*	osd_display_loading_rom_message */
+/*============================================================ */
+
+/* called while loading ROMs. It is called a last time with name == 0 to signal */
+/* that the ROM loading process is finished. */
+/* return non-zero to abort loading */
+int osd_display_loading_rom_message(const char *name,
+		struct rom_load_data *romdata)
+{
+	static int count = 0;
+	
+	if (name)
+		fprintf(stderr_file,"loading rom %d: %-12s\n", count, name);
+	else
+		fprintf(stderr_file,"done\n");
+	
+	fflush(stderr_file);
+	count++;
+
+	return 0;
+}
+
+
+
+#ifdef MESS
+/*============================================================ */
+/*	build_crc_database_filename */
+/*============================================================ */
+
+void build_crc_database_filename(int game_index)
+{
+	/* Build the CRC database filename */
+	sprintf(crcfilename, "%s/%s.crc", crcdir, drivers[game_index]->name);
+	if (drivers[game_index]->clone_of->name)
+		sprintf (pcrcfilename, "%s/%s.crc", crcdir, drivers[game_index]->clone_of->name);
+	else
+		pcrcfilename[0] = 0;
+}
+
+int osd_select_file(mess_image *img, char *filename)
+{
+	return 0;
+}
+
+void osd_begin_final_unloading(void)
+{
+}
+
+void osd_image_load_status_changed(mess_image *img, int is_final_unload)
+{
+}
+#endif
diff --git a/src/unix/frameskip-drivers/barath.c b/src/unix/frameskip-drivers/barath.c
new file mode 100644
index 0000000..4c10b4e
--- /dev/null
+++ b/src/unix/frameskip-drivers/barath.c
@@ -0,0 +1,166 @@
+#include <math.h>
+#include "xmame.h"
+#include "driver.h"
+#include "profiler.h"
+#include "sysdep/misc.h"
+
+/* don't define this for a production version 
+#define barath_debug
+ */
+
+#ifdef barath_debug
+static int debug_value;
+#endif
+
+static int modframe = 0;
+
+static int barath_skip_this_frame(void)
+{
+  return (modframe >= FRAMESKIP_LEVELS);
+}
+
+int barath_skip_next_frame(void)
+{
+  static uclock_t curr = 0;
+  static uclock_t prev = 0;
+  static uclock_t avg_uclocks = 0;
+  static int frames_skipped = 0;
+  static int sysload = 0;
+  static float framerate = 1;
+  static float speed = 1;
+  static float lag_rate = -30;
+
+  int skip_this_frame = barath_skip_this_frame();
+  int scratch_time = uclock();
+#ifdef barath_debug
+  static float slow_speed = 1;
+  int uclocks_per_frame = slow_speed * UCLOCKS_PER_SEC / video_fps;
+#else
+  int uclocks_per_frame = UCLOCKS_PER_SEC / video_fps;
+#endif
+  /* project target display time of this frame */
+  uclock_t target = prev + (frames_skipped + 1) * uclocks_per_frame;
+
+  /* if lagging by more than 2 frames don't try to make up for it */
+  while (scratch_time - target > uclocks_per_frame * 2) {
+    target += uclocks_per_frame;
+    lag_rate++;
+  }
+  lag_rate *= 0.99;
+
+  {
+    static float framerateavg = 0;
+    framerateavg = (framerateavg * 5 + 1 - skip_this_frame) / 6.0;
+    framerate = (framerate * 5 + framerateavg) / 6.0;
+  }
+  if (throttle) {
+    int leading = ((sysload > 33) && should_sleep_idle()) ? 0 : uclocks_per_frame;
+    int sparetime = target - scratch_time;
+
+    /* test for load-induced lags and set sysload */
+    if (autoframeskip && should_sleep_idle()) {
+      /* if lag is excessive and framerate is low then we have a system hiccup */
+      if ((sysload < 100) && (lag_rate > 3) && (frameskip < max_autoframeskip)) {
+	sysload++;
+	lag_rate = 3;
+      }
+      /* after ~2000 frames of no lag start lowering sysload */
+      else if (sysload && (fabs(lag_rate) < .00001)) {
+	sysload--;
+	lag_rate = .000011;	/* wait ~10 frames */
+      }
+    }
+    if (autoframeskip) {
+      /* this is an attempt at proportionate feedback to smooth things out */
+      int feedback = ((sparetime - uclocks_per_frame / 2) / (uclocks_per_frame / 3));
+
+      frameskip = ((1.0 - framerate) * (FRAMESKIP_LEVELS - 1)) - feedback;
+
+#ifdef barath_debug
+      debug_value = feedback;
+#endif
+      if (frameskip > max_autoframeskip)
+	frameskip = max_autoframeskip;
+      else if (frameskip < 0)
+	frameskip = 0;
+    }
+    if (sparetime > 0) {
+      /* if we're more than 2 frames ahead we need to resynch */
+      if (sparetime > uclocks_per_frame * 2)
+	target = scratch_time;
+      else {
+	/* idle until we hit frame ETA or leading */
+	profiler_mark(PROFILER_IDLE);
+	while (target - uclock() > leading)
+	  if (should_sleep_idle())
+	    usleep(100);
+	profiler_mark(PROFILER_END);
+      }
+    }
+    /* if we are behind we should force a skip: */
+    else if (autoframeskip && (frameskip < max_autoframeskip)
+	     && (frames_skipped < 1))
+      modframe = FRAMESKIP_LEVELS * 2 - frameskip;
+
+  }				/* if (throttle) */
+  if (skip_this_frame && (frames_skipped < FRAMESKIP_LEVELS))
+    frames_skipped++;
+  else {
+    /* update frame timer */
+    prev = target;
+
+    /* calculate average running speed for display purposes */
+    scratch_time = curr;
+    curr = uclock();
+    avg_uclocks = (avg_uclocks * 5 + curr - scratch_time) / (6 + frames_skipped);
+    speed = (speed * 5 + (float) uclocks_per_frame / avg_uclocks) / 6.0;
+    /* double-forward average  */
+
+    frames_skipped = 0;
+  }
+
+  /* give a little grace in case something else sets it off */
+  if (should_sleep_idle() && autoframeskip && (sysload > 33)) {
+    profiler_mark(PROFILER_IDLE);
+    usleep(100);
+    profiler_mark(PROFILER_END);
+  }
+  /* advance frameskip counter */
+  if (modframe >= FRAMESKIP_LEVELS)
+    modframe -= FRAMESKIP_LEVELS;
+  modframe += frameskip;
+
+  return barath_skip_this_frame();
+}
+
+int barath_show_fps(char *buffer)
+{
+	int chars_filled = 0;
+
+#ifdef barath_debug
+	static int showme = 0;
+
+	if (showme++ > 5)
+	{
+		int fps = (video_fps * framerate * speed + .5);
+		chars_filled = sprintf(buffer, "%2d %d %s%s%s%2d %3d%%(%3d/%3d)",
+				debug_value,
+				sysload,
+				throttle ? "T" : "",
+				(throttle && should_sleep_idle()) ? "S" : "",
+				(throttle && autoframeskip) ? "A" : "F",
+				frameskip,
+				(int) (speed * 100 + .5),
+				(int) (fps / slow_speed),
+				(int) (video_fps / slow_speed));
+
+		/* set game speed based on manual frameskip setting */
+		if (!throttle && !autoframeskip)
+			slow_speed = (.25 + 3 * frameskip 
+					/ (float) FRAMESKIP_LEVELS);
+		showme = 0;
+	}
+#endif
+
+	return chars_filled;
+}
diff --git a/src/unix/frameskip-drivers/dos.c b/src/unix/frameskip-drivers/dos.c
new file mode 100644
index 0000000..312d469
--- /dev/null
+++ b/src/unix/frameskip-drivers/dos.c
@@ -0,0 +1,140 @@
+#include "xmame.h"
+#include "driver.h"
+#include "profiler.h"
+#include "sysdep/misc.h"
+
+static int frameskip_counter = 0;
+
+int dos_skip_next_frame()
+{
+	static const int skiptable[FRAMESKIP_LEVELS][FRAMESKIP_LEVELS] =
+	{
+		{ 0,0,0,0,0,0,0,0,0,0,0,0 },
+		{ 0,0,0,0,0,0,0,0,0,0,0,1 },
+		{ 0,0,0,0,0,1,0,0,0,0,0,1 },
+		{ 0,0,0,1,0,0,0,1,0,0,0,1 },
+		{ 0,0,1,0,0,1,0,0,1,0,0,1 },
+		{ 0,1,0,0,1,0,1,0,0,1,0,1 },
+		{ 0,1,0,1,0,1,0,1,0,1,0,1 },
+		{ 0,1,0,1,1,0,1,0,1,1,0,1 },
+		{ 0,1,1,0,1,1,0,1,1,0,1,1 },
+		{ 0,1,1,1,0,1,1,1,0,1,1,1 },
+		{ 0,1,1,1,1,1,0,1,1,1,1,1 },
+		{ 0,1,1,1,1,1,1,1,1,1,1,1 }
+	};
+	static const int waittable[FRAMESKIP_LEVELS][FRAMESKIP_LEVELS] =
+	{
+		{ 1,1,1,1,1,1,1,1,1,1,1,1 },
+		{ 2,1,1,1,1,1,1,1,1,1,1,0 },
+		{ 2,1,1,1,1,0,2,1,1,1,1,0 },
+		{ 2,1,1,0,2,1,1,0,2,1,1,0 },
+		{ 2,1,0,2,1,0,2,1,0,2,1,0 },
+		{ 2,0,2,1,0,2,0,2,1,0,2,0 },
+		{ 2,0,2,0,2,0,2,0,2,0,2,0 },
+		{ 2,0,2,0,0,3,0,2,0,0,3,0 },
+		{ 3,0,0,3,0,0,3,0,0,3,0,0 },
+		{ 4,0,0,0,4,0,0,0,4,0,0,0 },
+		{ 6,0,0,0,0,0,6,0,0,0,0,0 },
+		{12,0,0,0,0,0,0,0,0,0,0,0 }
+	};
+	int i;
+	uclock_t curr;
+	static uclock_t prev_frames[FRAMESKIP_LEVELS]={0,0,0,0,0,0,0,0,0,0,0,0};
+	static uclock_t prev=0;
+	static int speed=100;
+
+	/* now wait until it's time to update the screen */
+	if (skiptable[frameskip][frameskip_counter] == 0)
+	{
+        	if (throttle)
+        	{
+        		uclock_t target,target2;
+        		profiler_mark(PROFILER_IDLE);
+
+        		/* wait until enough time has passed since last frame... */
+        		target = prev +
+        			waittable[frameskip][frameskip_counter] * UCLOCKS_PER_SEC/video_fps;
+
+        		/* ... OR since FRAMESKIP_LEVELS frames ago. This way, if a frame takes */
+        		/* longer than the allotted time, we can compensate in the following frames. */
+        		target2 = prev_frames[frameskip_counter] +
+        			FRAMESKIP_LEVELS * UCLOCKS_PER_SEC/video_fps;
+
+        		if (target - target2 > 0) target = target2;
+        		
+        		curr = uclock();
+        		
+        		/* If we need to sleep more then half a second,
+        		   we've somehow got totally out of sync. So
+        		   if this happens we reset all counters */
+        		if ((target - curr) > (UCLOCKS_PER_SEC / 2))
+        		   for (i=0; i < FRAMESKIP_LEVELS; i++)
+        		      prev_frames[i] = curr;
+        		else
+        		   while ((curr - target) < 0)
+        		   {
+        		      curr = uclock();
+        		      if ((target - curr) > (UCLOCKS_PER_SEC / 1000) &&
+        		          should_sleep_idle())
+        		         usleep(100);
+        		   }
+
+        		profiler_mark(PROFILER_END);
+        	}
+        	else curr = uclock();
+
+        	if (frameskip_counter == 0 && (curr - prev_frames[frameskip_counter]))
+        	{
+        		int divdr;
+
+        		divdr = video_fps * (curr - prev_frames[frameskip_counter]) / (100 * FRAMESKIP_LEVELS);
+        		speed = (UCLOCKS_PER_SEC + divdr/2) / divdr;
+        	}
+
+        	prev = curr;
+        	for (i = 0;i < waittable[frameskip][frameskip_counter];i++)
+        		prev_frames[(frameskip_counter + FRAMESKIP_LEVELS - i) % FRAMESKIP_LEVELS] = curr;
+
+		if (throttle && autoframeskip && frameskip_counter == 0)
+		{
+			static int frameskipadjust;
+
+			if (speed >= 100)
+			{
+				frameskipadjust++;
+				if (frameskipadjust >= 3)
+				{
+					frameskipadjust = 0;
+					if (frameskip > 0) frameskip--;
+				}
+			}
+			else
+			{
+				if (speed < 80)
+					frameskipadjust -= (90 - speed) / 5;
+				else
+				{
+					/* don't push frameskip too far if we are close to 100% speed */
+					if (frameskip < 8)
+						frameskipadjust--;
+				}
+
+				while (frameskipadjust <= -2)
+				{
+					frameskipadjust += 2;
+					if (frameskip < max_autoframeskip) frameskip++;
+				}
+			}
+		}
+	}
+	
+	frameskip_counter = (frameskip_counter + 1) % FRAMESKIP_LEVELS;
+	
+	return skiptable[frameskip][frameskip_counter];
+}
+
+int dos_show_fps(char *buffer)
+{
+	/* We'll just let the code in video.c fill in the buffer. */
+	return 0;
+}
diff --git a/src/unix/fronthlp.c b/src/unix/fronthlp.c
new file mode 100644
index 0000000..44a1aca
--- /dev/null
+++ b/src/unix/fronthlp.c
@@ -0,0 +1,1071 @@
+#include <stdarg.h> /* prolly should go in xmame.h */
+#include "xmame.h"
+#include "driver.h"
+#include "audit.h"
+#include "common.h"
+#include "info.h"
+
+static int frontend_list_clones(char *gamename);
+static int frontend_list_cpu(void);
+static int frontend_list_gamelistheader(void);
+static int frontend_list_hash(int type);
+
+static int list       = 0;
+static int showclones = 1;
+static int verbose    = 1;
+static int correct    = 0;
+static int incorrect  = 0;
+static int not_found  = 0;
+static int sortby     = 0;
+
+enum {
+	/* standard list commands */
+	LIST_LIST = 1, LIST_FULL, LIST_GAMES, LIST_DETAILS, LIST_GAMELIST,
+	LIST_SOURCEFILE, LIST_COLORS, LIST_DEVICES, LIST_ROMSIZE, LIST_PALETTESIZE,
+	LIST_ROMS, LIST_CRC, LIST_SHA1, LIST_MD5, LIST_SAMPLES, LIST_SAMDIR, 
+	VERIFY_ROMS, VERIFY_ROMSETS, VERIFY_SAMPLES, VERIFY_SAMPLESETS,
+	/* internal verification list commands (developers only) */
+	LIST_MISSINGROMS, LIST_DUPCRC, LIST_WRONGORIENTATION, LIST_WRONGMERGE,
+	LIST_WRONGFPS,
+	/* standard listcommands which require special handling */
+	LIST_CLONES, LIST_INFO, LIST_XML, LIST_CPU
+};
+   
+/* Mame frontend interface & commandline */
+/* parsing rountines by Maurizio Zanello */
+
+struct rc_option frontend_list_opts[] = {
+	/* name, shortname, type, dest, deflt, min, max, func, help */
+	{ "Frontend Related", NULL, rc_seperator, NULL, NULL, 0, 0, NULL, NULL },
+	{ "list", "l", rc_set_int, &list, NULL, LIST_LIST, 0, NULL, "List supported games matching gamename, or all, gamename may contain * and ? wildcards" },
+	{ "listfull", "lf", rc_set_int, &list, NULL, LIST_FULL, 0, NULL, "Like -list, with full description" },
+	{ "listgames", "lg", rc_set_int, &list, NULL, LIST_GAMES, 0, NULL, "Like -list, with manufacturer and year" },
+	{ "listdetails", "ld", rc_set_int, &list, NULL, LIST_DETAILS, 0, NULL, "Like -list, with detailed info" },
+	{ "listgamelist", "lgl", rc_set_int, &list, NULL, LIST_GAMELIST, 0, NULL, "Like -list, with specialy formatted extra info for generating gamelist.mame" },
+	{ "listsourcefile", "lsf", rc_set_int, &list, NULL, LIST_SOURCEFILE, 0, NULL, "Like -list, with driver sourcefile" },
+	{ "listcolors", "lcol", rc_set_int, &list, NULL, LIST_COLORS, 0, NULL, "Like -list, with the number of colors used" },
+#ifdef MESS
+	{ "listdevices", "ldev", rc_set_int, &list, NULL, LIST_DEVICES, 0, NULL, "Like -list, with devices and image file extensions supported" },
+#endif
+	{ "listromsize", "lrs", rc_set_int, &list, NULL, LIST_ROMSIZE, 0, NULL, "Like -list, with the year and size of the roms used" },
+	{ "listpalettesize", "lps", rc_set_int, &list, NULL, LIST_ROMSIZE, 0, NULL, "Like -list, with the year and palette size of the roms used" },
+	{ "listroms", "lr", rc_set_int, &list, NULL, LIST_ROMS, 0, NULL, "Like -list, but lists used ROMs" },
+	{ "listcrc", "lcrc", rc_set_int, &list, NULL, LIST_CRC, 0, NULL, "Like -list, but lists used ROMs with CRC-32s" },
+	{ "listsha1", "lsha1", rc_set_int, &list, NULL, LIST_SHA1, 0, NULL, "Like -list, but lists used ROMs with SHA-1s" },
+	{ "listmd5", "lmd5", rc_set_int, &list, NULL, LIST_MD5, 0, NULL, "Like -list, but lists used ROMs with MD5s" },
+#if (HAS_SAMPLES)
+	{ "listsamples", "ls", rc_set_int, &list, NULL, LIST_SAMPLES, 0, NULL, "Like -list, but lists used audio samples" },
+	{ "listsamdir", "lsd", rc_set_int, &list, NULL, LIST_SAMDIR, 0, NULL, "Like -list, but lists dir where samples are taken from" },
+#endif   
+	{ "verifyroms", "vr", rc_set_int, &list, NULL, VERIFY_ROMS, 0, NULL, "Verify ROMs for games matching gamename, or all, gamename may contain * and ? wildcards" },
+	{ "verifyromsets", "vrs", rc_set_int, &list, NULL, VERIFY_ROMSETS, 0, NULL, "Like -verifyroms, but less verbose" },
+#if (HAS_SAMPLES)
+	{ "verifysamples", "vs", rc_set_int, &list, NULL, VERIFY_SAMPLES, 0, NULL, "Like -verifyroms but verify audio samples instead" },
+	{ "verifysamplesets", "vss", rc_set_int, &list, NULL, VERIFY_SAMPLESETS, 0, NULL, "Like -verifysamples, but less verbose" },
+#endif
+	{ "clones", "cl", rc_bool, &showclones, "1", 0, 0, NULL, "Show / don't show bootlegs/clones in the above list commands" },
+	{ "listclones", "lcl", rc_set_int, &list, NULL, LIST_CLONES, 0, NULL, "Like -list, but lists the clones of the specified game" },
+	{ "listinfo", "li", rc_set_int, &list, NULL, LIST_INFO, 0, NULL, "List all available info on drivers" },
+	{ "listxml", "lx", rc_set_int, &list, NULL, LIST_XML, 0, NULL, "List all available info on drivers in XML format" },
+	{ "listcpu", "lc", rc_set_int, &list, NULL, LIST_CPU, 0, NULL, "List cpu usage statics per year" },
+	{ "Internal verification list commands (only for developers)", NULL, rc_seperator, NULL, NULL, 0, 0, NULL, NULL },
+#ifdef MAME_DEBUG /* do not put this into a public release! */
+	{ "listmissingroms", "lmr", rc_set_int, &list, NULL, LIST_MISSINGROMS, 0, NULL, "Like -list, but lists ROMs missing" },
+#endif
+	{ "listdupcrc", "ldc", rc_set_int, &list, NULL, LIST_DUPCRC, 0, NULL, "Like -list, but lists ROMs with identical crc" },
+	{ "listwrongorientation", "lwo", rc_set_int, &list, NULL, LIST_WRONGORIENTATION, 0, NULL, "Like -list, but lists any games which use the orientation flags wrongly" },
+	{ "listwrongmerge", "lwm", rc_set_int, &list, NULL, LIST_WRONGMERGE, 0, NULL, "Like -list, but lists any games which use the clone_of field wrongly" },
+	{ "listwrongfps", "lwf", rc_set_int, &list, NULL, LIST_WRONGFPS, 0, NULL, "Like -list, but lists any games which use the FPS field wrongly" },
+	{ "sortname", "srtn", rc_set_int, &sortby, NULL, 1, 0, NULL, "Sort roms by name" },
+	{ "sortdriver", "srtd", rc_set_int, &sortby, NULL, 2, 0, NULL, "Sort roms by driver name" },
+	{ NULL, NULL, rc_end, NULL, NULL, 0, 0, NULL, NULL }
+};
+
+int CLIB_DECL compare_names(const void *elem1, const void *elem2)
+{
+	struct GameDriver *drv1 = *(struct GameDriver **)elem1;
+	struct GameDriver *drv2 = *(struct GameDriver **)elem2;
+	return strcmp(drv1->description, drv2->description);
+}
+
+int CLIB_DECL compare_driver_names(const void *elem1, const void *elem2)
+{
+	struct GameDriver *drv1 = *(struct GameDriver **)elem1;
+	struct GameDriver *drv2 = *(struct GameDriver **)elem2;
+	return strcmp(drv1->name, drv2->name);
+}
+
+/* compare string[8] using standard(?) wildchars ('?' & '*')          */
+/* for this to work correctly, the shells internal wildcard expansion */
+/* mechanism has to be disabled, use quotes */
+int strwildcmp(const char *sp1, const char *sp2)
+{
+	char s1[9], s2[9];
+	int i, l1, l2;
+	char *p;
+
+	strncpy(s1, sp1, 8); s1[8] = 0; if (s1[0] == 0) strcpy(s1, "*");
+
+	strncpy(s2, sp2, 8); s2[8] = 0; if (s2[0] == 0) strcpy(s2, "*");
+
+	p = strchr(s1, '*');
+	if (p)
+	{
+		for (i = p - s1; i < 8; i++) s1[i] = '?';
+		s1[8] = 0;
+	}
+
+	p = strchr(s2, '*');
+	if (p)
+	{
+		for (i = p - s2; i < 8; i++) s2[i] = '?';
+		s2[8] = 0;
+	}
+
+	l1 = strlen(s1);
+	if (l1 < 8)
+	{
+		for (i = l1 + 1; i < 8; i++) s1[i] = ' ';
+		s1[8] = 0;
+	}
+
+	l2 = strlen(s2);
+	if (l2 < 8)
+	{
+		for (i = l2 + 1; i < 8; i++) s2[i] = ' ';
+		s2[8] = 0;
+	}
+
+	for (i = 0; i < 8; i++)
+	{
+		if (s1[i] == '?' && s2[i] != '?') s1[i] = s2[i];
+		if (s2[i] == '?' && s1[i] != '?') s2[i] = s1[i];
+	}
+
+	return stricmp(s1, s2);
+}
+
+static int myprintf(char *fmt, ...)
+{
+	int i = 0;
+	va_list args;
+
+	if(verbose)
+	{
+		va_start(args, fmt);
+		i = vfprintf(stdout_file, fmt, args);
+		va_end(args);
+		fflush(stdout_file);
+	}
+	return i;
+}
+
+static void frontend_verify(int driver, int rom)
+{
+	int status;
+
+	if(rom)
+		status = VerifyRomSet(driver, (verify_printf_proc)myprintf);
+	else
+		status = VerifySampleSet(driver, (verify_printf_proc)myprintf);
+
+	if (verbose)
+		fprintf(stdout_file, "%s %s ", rom? "romset":"sampleset",
+				drivers[driver]->name);
+	else
+		fprintf(stdout_file, "%-8s  ", drivers[driver]->name);
+
+	switch (status)
+	{
+		case BEST_AVAILABLE:
+			fprintf(stdout_file, "best available\n");
+			correct++;
+			break;
+		case CORRECT:
+			fprintf(stdout_file, "correct\n");
+			correct++;
+			break;
+		case NOTFOUND:
+		case CLONE_NOTFOUND:
+			fprintf(stdout_file, "not found\n");
+			not_found++;
+			break;
+		case INCORRECT:
+			fprintf(stdout_file, "incorrect\n");
+			incorrect++;
+			break;
+	}
+	fflush(stdout_file);
+}
+
+static int frontend_uses_roms(int driver)
+{
+	const struct RomModule *region, *rom;
+	int total_roms = 0;
+
+	for (region = rom_first_region(drivers[driver]); region; region = rom_next_region(region))
+	{
+		for (rom = rom_first_file(region); rom && (ROM_GETNAME(rom) ||
+					ROM_GETOFFSET(rom) || ROM_GETLENGTH(rom)); rom = rom_next_file(rom))
+		{
+			if (ROM_GETNAME(rom) && ROM_GETNAME(rom) != (char *)-1)
+			{
+				total_roms++;
+			}
+		}
+	}
+
+	return total_roms;
+}
+
+char *get_description(int driver)
+{
+	char *p;
+	char copy[BUF_SIZE];
+	static char description[BUF_SIZE];
+
+	strncpy(copy, drivers[driver]->description, BUF_SIZE);
+
+	/* Remove the additonal description if any */
+	if ((p = strstr(copy, " (")))
+		*p = 0;
+
+	/* Move leading "The" to the end */
+	if (strncmp(copy, "The ", 4) == 0)
+		snprintf(description, BUF_SIZE, "%s, The", copy+4);
+	else if (strncmp(copy, "Le ", 3) == 0)
+		snprintf(description, BUF_SIZE, "%s, Le", copy+3);
+	else
+		strncpy(description, copy, BUF_SIZE);
+
+	/* Print the additional description only if we are listing clones */
+	if (showclones && p)
+	{
+		int len = strlen(description);
+
+		*p = ' ';
+		snprintf(description + len, BUF_SIZE - len, p);
+	}
+
+	return description;
+}
+
+int frontend_list(char *gamename)
+{
+	int i, j = 0;
+	const char *header[] = {
+		/*** standard list commands ***/
+		/* list             */ NAME" currently supports:\n",
+		/* listfull         */ "name      description\n"
+			"--------  -----------\n",
+		/* listgames        */ "year manufacturer                         name\n"
+			"---- ------------------------------------ --------------------------------\n",
+		/* listdetails      */ " romname driver     cpu 1    cpu 2    cpu 3    cpu 4    cpu 5    cpu 6    cpu 7    cpu 8    sound 1     sound 2     sound 3     sound 4     sound 5     name\n"
+			"-------- ---------- -------- -------- -------- -------- -------- -------- -------- -------- ----------- ----------- ----------- ----------- ----------- --------------------------\n",
+		/* listgamelist     */ "",
+		/* listsourcefile   */ "name     sourcefile\n"
+			"-------- ----------\n",
+		/* listcolors       */ "name      colors\n"
+			"--------  ------\n",
+		/* listextensions   */ "name      device      image file extensions supported\n"
+			"--------  ----------  -------------------------------\n",
+		/* listromsize      */ "name    \tyear \tsize\n"
+			"--------\t-----\t----\n",
+		/* listpalettesize  */ "",
+		/* listroms         */ "",
+		/* listcrc          */ "CRC      filename     description\n"
+			"-------- ------------ -----------\n",
+		/* listsamples      */ "",
+		/* listsamdir       */ "name      samples dir\n"
+			"--------  -----------\n",
+		/* verifyroms       */ "",
+		/* verifyromsets    */ "name      result\n"
+			"--------  ------\n",
+		/* verifysamples    */ "",
+		/* verifysamplesets */ "name      result\n"
+			"--------  ------\n",
+		/*** internal verification list commands (developers only) ***/
+		/* listmissingroms  */ "name      clone of  description\n"
+			"--------  --------  -----------\n",
+		/* listdupcrc       */ "CRC      filename1    name1        filename2    name2\n"
+			"-------- ------------ --------     ------------ --------\n",
+		/* wrongorientation */ "",
+		/* wrongmerge       */ "",
+		/* wrongfps         */ "name      resolution  fps\n"
+			"--------  ----------  -----------\n"
+	};
+
+	struct InternalMachineDriver drv;
+	int matching     = 0;
+	int skipped      = 0;
+
+	if (!gamename)
+		gamename = "";
+
+	/* sort the list if requested */
+	if (sortby)
+	{
+		int count = 0;
+
+		/* first count the drivers */
+		while (drivers[count]) count++;
+
+		/* qsort as appropriate */
+		if (sortby == 1)
+			qsort(drivers, count, sizeof(drivers[0]), compare_names);
+		else if (sortby == 2)
+			qsort(drivers, count, sizeof(drivers[0]), compare_driver_names);
+	}
+
+	/* listcommands which require special handling */
+	switch (list)
+	{
+		/* no list requested */
+		case 0:
+			return 1234;
+			/* listclones is a special case since the strwildcmp */
+			/* also has to be done on clone_of. */
+		case LIST_CLONES:
+			return frontend_list_clones(gamename);
+			/* listinfo is handled by the core */
+		case LIST_INFO: /* list all info */
+			print_mame_info( stdout_file, drivers ); 
+			return OSD_OK;
+		case LIST_XML: /* list all info */
+			print_mame_xml( stdout_file, drivers );
+			return OSD_OK;
+		case LIST_CPU:
+			return frontend_list_cpu();
+		case LIST_CRC: /* list all crc-32 */
+			return frontend_list_hash(HASH_CRC);
+		case LIST_SHA1: /* list all sha-1 */
+			return frontend_list_hash(HASH_SHA1);
+		case LIST_MD5: /* list all md5 */
+			return frontend_list_hash(HASH_MD5);
+		case LIST_GAMELIST: /* list all of the games */
+			frontend_list_gamelistheader(); /* display the header */
+			break;
+	}
+
+	fprintf(stdout_file, header[list-1]);
+
+	for (i=0;drivers[i];i++)
+	{
+		expand_machine_driver(drivers[i]->drv, &drv);	
+		if ( (showclones || drivers[i]->clone_of == 0 ||
+					(drivers[i]->clone_of->flags & NOT_A_DRIVER)) &&
+				!strwildcmp(gamename, drivers[i]->name) )
+		{
+			matching++;
+
+			switch(list)
+			{
+				/*** standard list commands ***/
+				case LIST_LIST: /* simple games list */
+					fprintf(stdout_file, "%-8s", drivers[i]->name);
+					if (!(matching % 8))
+						fprintf(stdout_file, "\n");
+					else
+						fprintf(stdout_file, "  ");
+					break;
+				case LIST_FULL: /* games list with descriptions */
+					fprintf(stdout_file, "%-10s\"%s\"\n", drivers[i]->name,
+							get_description(i));
+					break;
+				case LIST_GAMES:
+					{
+						fprintf(stdout_file, "%-5s%-36s %s\n",
+								drivers[i]->year,
+								drivers[i]->manufacturer, get_description(i));
+						break;
+					}
+				case LIST_DETAILS: /* A detailed MAMELIST.TXT type roms lister */
+					/* First, the rom name */
+					fprintf(stdout_file, "%-8s ",drivers[i]->name);
+
+					/* source file (skip the leading path) */ 
+					fprintf(stdout_file, "%-10s ", strrchr(drivers[i]->source_file, '/') + 1);
+
+					/* Then, cpus */
+					for(j=0;j<MAX_CPU;j++)
+					{
+						const struct MachineCPU *x_cpu = drv.cpu;
+						if (x_cpu[j].cpu_flags & CPU_AUDIO_CPU)
+							fprintf(stdout_file, "[%-6s] ",cputype_name(x_cpu[j].cpu_type));
+						else
+							fprintf(stdout_file, "%-8s ",cputype_name(x_cpu[j].cpu_type));
+					}
+					fprintf(stdout_file, " ");
+
+					for(j=0;j<MAX_SOUND;j++)
+					{
+						const struct MachineSound *x_sound = drv.sound;
+						if (sound_num(&x_sound[j]))
+						{
+							fprintf(stdout_file, "%dx",sound_num(&x_sound[j]));
+							fprintf(stdout_file, "%-9s ",sound_name(&x_sound[j]));
+						}
+						else
+							fprintf(stdout_file, "%-11s ",sound_name(&x_sound[j]));
+					}
+
+					/* Lastly, the name of the game and a \newline */
+					fprintf(stdout_file, " %s\n", get_description(i));
+					break;
+				case LIST_GAMELIST:
+					{
+						fprintf(stdout_file, "| %-33.33s", get_description(i));
+
+						if (drivers[i]->flags & (GAME_NOT_WORKING | GAME_UNEMULATED_PROTECTION))
+						{
+							const struct GameDriver *maindrv;
+							int foundworking;
+
+							if (drivers[i]->clone_of && !(drivers[i]->clone_of->flags & NOT_A_DRIVER))
+								maindrv = drivers[i]->clone_of;
+							else maindrv = drivers[i];
+
+							foundworking = 0;
+							j = 0;
+							while (drivers[j])
+							{
+								if (drivers[j] == maindrv || drivers[j]->clone_of == maindrv)
+								{
+									if (!(drivers[j]->flags & (GAME_NOT_WORKING | GAME_UNEMULATED_PROTECTION)))
+									{
+										foundworking = 1;
+										break;
+									}
+								}
+								j++;
+							}
+
+							if (foundworking)
+								fprintf(stdout_file, "| No(1) ");
+							else
+								fprintf(stdout_file, "|   No  ");
+						}
+						else
+							fprintf(stdout_file, "|  Yes  ");
+
+						if (drivers[i]->flags & GAME_WRONG_COLORS)
+							fprintf(stdout_file, "|   No  ");
+						else if (drivers[i]->flags & GAME_IMPERFECT_COLORS)
+							fprintf(stdout_file, "| Close ");
+						else
+							fprintf(stdout_file, "|  Yes  ");
+
+						{
+							const char **samplenames = NULL;
+#if (HAS_SAMPLES || HAS_VLM5030)
+							for (j = 0;drv.sound[j].sound_type && j < MAX_SOUND; j++)
+							{
+#if (HAS_SAMPLES)
+								if (drv.sound[j].sound_type == SOUND_SAMPLES)
+								{
+									samplenames = ((struct Samplesinterface *)drv.sound[j].sound_interface)->samplenames;
+									break;
+								}
+#endif
+							}
+#endif
+							if (drivers[i]->flags & GAME_NO_SOUND)
+								fprintf(stdout_file, "|   No  ");
+							else if (drivers[i]->flags & GAME_IMPERFECT_SOUND)
+							{
+								if (samplenames)
+									fprintf(stdout_file, "|Part(2)");
+								else
+									fprintf(stdout_file, "|Partial");
+							}
+							else
+							{
+								if (samplenames)
+									fprintf(stdout_file, "| Yes(2)");
+								else
+									fprintf(stdout_file, "|  Yes  ");
+							}
+						}
+
+						if (drivers[i]->flags & GAME_NO_COCKTAIL)
+							fprintf(stdout_file, "|   No  ");
+						else
+							fprintf(stdout_file, "|  Yes  ");
+
+						fprintf(stdout_file, "| %-8s |\n",drivers[i]->name);
+
+					}
+					break;
+				case LIST_SOURCEFILE:
+					fprintf(stdout_file, "%-8s %s\n", drivers[i]->name,
+							drivers[i]->source_file);
+					break;
+				case LIST_COLORS:
+					fprintf(stdout_file, "%-8s  %d\n", drivers[i]->name,
+							drv.total_colors);
+					break;
+#ifdef MESS
+				case LIST_DEVICES: /* list devices */
+					if(device_first(drivers[i]))
+					{
+						const struct IODevice *dev = device_first(drivers[i]);
+
+						j = 0;
+
+						fprintf(stdout_file, "%-8s  ", drivers[i]->name);
+
+						while (dev)
+						{
+							const char *src = dev->file_extensions;
+
+							if (!j) /* first time ? */
+								fprintf(stdout_file, "%-10s  ",
+										device_typename(dev->type));
+							else
+								fprintf(stdout_file, "%-8s  %-10s  ", "",
+										device_typename(dev->type));
+
+							while (*src)
+							{
+								fprintf(stdout_file, ".%-3s  ", src);
+								src += strlen(src) + 1;
+							}
+							fprintf(stdout_file, "\n");
+							j++;
+							dev = device_next(drivers[i], dev);
+						}
+					}
+					else
+						skipped++;
+					break;
+#endif
+				case LIST_ROMSIZE:
+					{
+						const struct RomModule *region, *rom, *chunk;
+
+						j = 0;
+						for (region = rom_first_region(drivers[i]); region; region = rom_next_region(region))
+							for (rom = rom_first_file(region); rom; rom = rom_next_file(rom))
+								for (chunk = rom_first_chunk(rom); chunk; chunk = rom_next_chunk(chunk))
+									j += ROM_GETLENGTH(chunk);
+
+						printf("%-8s\t%-5s\t%u\n", drivers[i]->name, drivers[i]->year, j);
+					}
+					break;
+
+				case LIST_PALETTESIZE:
+					{
+						printf("%-8s\t%-5s\t%u\n",drivers[i]->name,drivers[i]->year,drv.total_colors); 
+					}
+
+				case LIST_ROMS: /* game roms list */
+					if(!frontend_uses_roms(i))
+					{
+						skipped++;
+						continue;
+					}
+
+					printromlist(drivers[i]->rom, drivers[i]->name);
+					fprintf(stdout_file, "\n");
+					break;
+#if (HAS_SAMPLES || HAS_VLM5030)
+				case LIST_SAMPLES: /* game samples list */
+				case LIST_SAMDIR:  /* games list with samples directories */
+					{
+						int found = 0;
+
+						for (j = 0; drv.sound[j].sound_type && j < MAX_SOUND; j++ )
+						{
+							const char **samplenames = NULL;
+#if (HAS_SAMPLES)
+							if( drv.sound[j].sound_type == SOUND_SAMPLES )
+								samplenames = ((struct Samplesinterface *)drv.sound[j].sound_interface)->samplenames;
+#endif                        
+							if (samplenames && samplenames[0])
+							{
+								found = 1;
+
+								if(list == LIST_SAMPLES)
+								{
+									int k = 0;
+
+									while (samplenames[k] != 0)
+									{
+										printf("%s\n", samplenames[k]);
+										k++;
+									}
+								}
+								else
+								{
+									printf("%-10s",drivers[i]->name);
+									if (samplenames[0][0] == '*')
+										printf("%s\n",samplenames[0]+1);
+									else
+										printf("%s\n",drivers[i]->name);
+								}
+							}
+						}
+						if (!found)
+							skipped++;
+					}
+					break;
+				case VERIFY_SAMPLESETS:
+					verbose = 0;
+					/* fall through */
+				case VERIFY_SAMPLES:
+					{
+						const char **samplenames = NULL;
+
+						for( j = 0; drv.sound[j].sound_type && j < MAX_SOUND; j++ )
+						{
+#if (HAS_SAMPLES)
+							if( drv.sound[j].sound_type == SOUND_SAMPLES )
+								samplenames = ((struct Samplesinterface *)drv.sound[j].sound_interface)->samplenames;
+#endif
+						}
+
+						/* ignore games that need no samples */
+						if (samplenames == NULL || samplenames[0] == NULL)
+							skipped++;
+						else
+							frontend_verify(i, 0);
+					}
+					break;
+#endif
+				case VERIFY_ROMSETS:
+					verbose = 0;
+					/* fall through */
+				case VERIFY_ROMS:
+					/* ignore games that need no roms */
+					if (!frontend_uses_roms(i))
+						skipped++;
+					else
+						frontend_verify(i, 1);
+					break;
+
+					/*** internal verification list commands (developers only) ***/
+				case LIST_MISSINGROMS:
+					if (RomsetMissing (i))
+					{
+						fprintf(stdout_file, "%-10s%-10s%s\n", drivers[i]->name,
+								(drivers[i]->clone_of) ? drivers[i]->clone_of->name : "",
+								get_description(i));
+						not_found++;
+					}
+					break;
+				case LIST_DUPCRC:
+					{
+						const struct RomModule *region, *rom;
+						int found = 0;
+
+						if(!frontend_uses_roms(i))
+						{
+							skipped++;
+							continue;
+						}
+
+						for (region = rom_first_region(drivers[i]); region; region = rom_next_region(region))
+							for (rom = rom_first_file(region); rom; rom = rom_next_file(rom))
+								if (!hash_data_has_info(ROM_GETHASHDATA(rom), HASH_INFO_NO_DUMP))
+									for (j = i + 1; drivers[j]; j++)
+									{
+										const struct RomModule *region1, *rom1;
+
+										for (region1 = rom_first_region(drivers[j]); region1; region1 = rom_next_region(region1))
+											for (rom1 = rom_first_file(region1); rom1; rom1 = rom_next_file(rom1))
+												if (strcmp(ROM_GETNAME(rom), ROM_GETNAME(rom1)) && hash_data_is_equal(ROM_GETHASHDATA(rom), ROM_GETHASHDATA(rom1), 0))
+												{
+													char temp[512];
+
+													/* Print only the checksums available for both the roms */
+													unsigned int functions = 
+														hash_data_used_functions(ROM_GETHASHDATA(rom)) &
+														hash_data_used_functions(ROM_GETHASHDATA(rom1));
+
+													hash_data_print(ROM_GETHASHDATA(rom), functions, temp);
+													printf("%s\n", temp);
+													printf("  %-12s %-8s\n", ROM_GETNAME(rom), drivers[i]->name);
+													printf("  %-12s %-8s\n", ROM_GETNAME(rom1),drivers[j]->name);
+													found = 1;
+												}
+									}
+
+						if (found)
+							incorrect++;
+						else
+							correct++;
+					}
+					break;
+				case LIST_WRONGORIENTATION: /* list drivers which incorrectly use the orientation and visible area fields */
+					if(!(drv.video_attributes & VIDEO_TYPE_VECTOR) &&
+							((drv.default_visible_area.max_x - drv.default_visible_area.min_x + 1) <=
+							 (drv.default_visible_area.max_y - drv.default_visible_area.min_y + 1)) &&
+							/* list of valid exceptions */
+							strcmp(drivers[i]->name,"crater") &&
+							strcmp(drivers[i]->name,"mpatrol") &&
+							strcmp(drivers[i]->name,"troangel") &&
+							strcmp(drivers[i]->name,"travrusa") &&
+							strcmp(drivers[i]->name,"kungfum") &&
+							strcmp(drivers[i]->name,"battroad") &&
+							strcmp(drivers[i]->name,"vigilant") &&
+							strcmp(drivers[i]->name,"sonson") &&
+							strcmp(drivers[i]->name,"brkthru") &&
+							strcmp(drivers[i]->name,"darwin") &&
+							strcmp(drivers[i]->name,"exprraid") &&
+							strcmp(drivers[i]->name,"sidetrac") &&
+							strcmp(drivers[i]->name,"targ") &&
+							strcmp(drivers[i]->name,"spectar") &&
+							strcmp(drivers[i]->name,"venture") &&
+							strcmp(drivers[i]->name,"mtrap") &&
+							strcmp(drivers[i]->name,"pepper2") &&
+							strcmp(drivers[i]->name,"hardhat") &&
+							strcmp(drivers[i]->name,"fax") &&
+							strcmp(drivers[i]->name,"circus") &&
+							strcmp(drivers[i]->name,"robotbwl") &&
+							strcmp(drivers[i]->name,"crash") &&
+							strcmp(drivers[i]->name,"ripcord") &&
+							strcmp(drivers[i]->name,"starfire") &&
+							strcmp(drivers[i]->name,"fireone") &&
+							strcmp(drivers[i]->name,"renegade") &&
+							strcmp(drivers[i]->name,"battlane") &&
+							strcmp(drivers[i]->name,"megatack") &&
+							strcmp(drivers[i]->name,"killcom") &&
+							strcmp(drivers[i]->name,"challeng") &&
+							strcmp(drivers[i]->name,"kaos") &&
+							strcmp(drivers[i]->name,"formatz") &&
+							strcmp(drivers[i]->name,"bankp") &&
+							strcmp(drivers[i]->name,"liberatr") &&
+							strcmp(drivers[i]->name,"toki") &&
+							strcmp(drivers[i]->name,"stactics") &&
+							strcmp(drivers[i]->name,"sprint1") &&
+							strcmp(drivers[i]->name,"sprint2") &&
+							strcmp(drivers[i]->name,"nitedrvr") &&
+							strcmp(drivers[i]->name,"punchout") &&
+							strcmp(drivers[i]->name,"spnchout") &&
+							strcmp(drivers[i]->name,"armwrest") &&
+							strcmp(drivers[i]->name,"route16") &&
+							strcmp(drivers[i]->name,"stratvox") &&
+							strcmp(drivers[i]->name,"irobot") &&
+							strcmp(drivers[i]->name,"leprechn") &&
+							strcmp(drivers[i]->name,"starcrus") &&
+							strcmp(drivers[i]->name,"astrof") &&
+							strcmp(drivers[i]->name,"tomahawk") &&
+							strcmp(drivers[i]->name,"astrocde") &&
+							strcmp(drivers[i]->name,"vic20") &&
+							strcmp(drivers[i]->name,"vc20") &&
+							strcmp(drivers[i]->name,"p2000t") &&
+							strcmp(drivers[i]->name,"kim1"))
+							{
+								fprintf(stdout_file, "%s %dx%d\n",drivers[i]->name,
+										drv.default_visible_area.max_x - drv.default_visible_area.min_x + 1,
+										drv.default_visible_area.max_y - drv.default_visible_area.min_y + 1);
+								incorrect++;
+							} else correct++;
+					break;
+				case LIST_WRONGMERGE: /* list duplicate crc-32 with different ROM name in clone sets */
+					{
+						const struct RomModule *region, *rom;
+						int found = 0;
+
+						if(!frontend_uses_roms(i))
+						{
+							skipped++;
+							continue;
+						}
+
+						for (region = rom_first_region(drivers[i]); region; region = rom_next_region(region))
+							for (rom = rom_first_file(region); rom; rom = rom_next_file(rom))
+								if (!hash_data_has_info(ROM_GETHASHDATA(rom), HASH_INFO_NO_DUMP))
+									for (j = 0; drivers[j]; j++)
+									{
+										if (j != i && drivers[j]->clone_of && (drivers[j]->clone_of->flags & NOT_A_DRIVER) == 0 && (drivers[j]->clone_of == drivers[i] || (i < j && drivers[j]->clone_of == drivers[i]->clone_of)))
+										{
+											const struct RomModule *region1, *rom1;
+											int match = 0;
+
+											for (region1 = rom_first_region(drivers[j]); region1; region1 = rom_next_region(region1))
+											{
+												for (rom1 = rom_first_file(region1); rom1; rom1 = rom_next_file(rom1))
+												{
+													if (!strcmp(ROM_GETNAME(rom), ROM_GETNAME(rom1)))
+													{
+														if (!hash_data_has_info(ROM_GETHASHDATA(rom1), HASH_INFO_NO_DUMP) &&
+																!hash_data_is_equal(ROM_GETHASHDATA(rom), ROM_GETHASHDATA(rom1), 0))
+														{
+															char temp[512];
+
+															/* Print only the checksums available for both the roms */
+															unsigned int functions = 
+																hash_data_used_functions(ROM_GETHASHDATA(rom)) &
+																hash_data_used_functions(ROM_GETHASHDATA(rom1));
+
+															fprintf(stdout_file, "%s:\n", ROM_GETNAME(rom));
+
+															hash_data_print(ROM_GETHASHDATA(rom), functions, temp);
+															fprintf(stdout_file, "  %-8s: %s\n", drivers[i]->name, temp);
+
+															hash_data_print(ROM_GETHASHDATA(rom1), functions, temp);
+															fprintf(stdout_file, "  %-8s: %s\n", drivers[j]->name, temp);
+															found = 1;
+														}
+														else
+															match = 1;
+													}
+												}
+											}
+
+											if (match == 0)
+											{
+												for (region1 = rom_first_region(drivers[j]); region1; region1 = rom_next_region(region1))
+												{
+													for (rom1 = rom_first_file(region1); rom1; rom1 = rom_next_file(rom1))
+													{
+														if (strcmp(ROM_GETNAME(rom), ROM_GETNAME(rom1)) && hash_data_is_equal(ROM_GETHASHDATA(rom), ROM_GETHASHDATA(rom1), 0))
+														{
+															char buf[512];
+
+
+															hash_data_print(ROM_GETHASHDATA(rom), 0, buf);
+															fprintf(stdout_file, "%s\n", buf);
+															fprintf(stdout_file, "    %-12s %-8s\n", ROM_GETNAME(rom),drivers[i]->name);
+														}
+													}
+												}
+											}
+
+										}
+									}
+
+						if (found)
+							incorrect++;
+						else
+							correct++;
+					}
+					break;
+				case LIST_WRONGFPS: /* list drivers with too high frame rate */
+					if ((drv.video_attributes & VIDEO_TYPE_VECTOR) == 0 &&
+							(drivers[i]->clone_of == 0 ||
+							 (drivers[i]->clone_of->flags & NOT_A_DRIVER)) &&
+							drv.frames_per_second > 57 &&
+							drv.default_visible_area.max_y - drv.default_visible_area.min_y + 1 > 244 &&
+							drv.default_visible_area.max_y - drv.default_visible_area.min_y + 1 <= 256)
+					{
+						fprintf(stdout_file, "%-8s  %-4dx%4d   %fHz\n",
+								drivers[i]->name,
+								drv.default_visible_area.max_x -
+								drv.default_visible_area.min_x + 1,
+								drv.default_visible_area.max_y -
+								drv.default_visible_area.min_y + 1,
+								drv.frames_per_second);
+						incorrect++;
+					}
+					else
+						correct++;
+					break;
+			}
+			fflush(stdout_file);
+		}
+	}
+
+	/* print footer for those -list options which need one */
+	switch(list)
+	{
+		case LIST_GAMELIST:
+			fprintf(stdout_file,
+					"+----------------------------------+-------+-------+-------+-------+----------+\n\n"
+					"(1) There are variants of the game (usually bootlegs) that work correctly\n"
+#if (HAS_SAMPLES)
+					"(2) Needs samples provided separately\n"
+#endif
+			       );
+			break;
+	}
+
+	if (matching == 0)
+	{
+		fprintf(stderr_file, "Error: \"%s\" is not supported!\n", gamename);
+		return 1;
+	}
+
+	fprintf(stdout_file, "\n\n");
+	fprintf(stdout_file, "Total Supported: %d", i);
+	if (matching != i)
+	{
+		fprintf(stdout_file, ", Matching \"%s\": %d\n", gamename, matching);
+	}
+	else
+	{
+		fprintf(stdout_file, "\n");
+	}
+	if (skipped) fprintf(stdout_file, "Displayed: %d, Skipped: %d, because they don't use any roms/samples/devices\n", matching-skipped, skipped);
+	if (correct+incorrect) fprintf(stdout_file, "Found: %d, of which %d correct and %d incorrect\n", correct+incorrect, correct, incorrect);
+	if (not_found) fprintf(stdout_file, "Not found: %d\n", not_found);
+	fflush(stdout_file);
+
+	if (incorrect > 0)
+		return 2;
+	else
+		return 0;
+}
+
+static int frontend_list_clones(char *gamename)
+{
+	/* listclones is a special case since the strwildcmp */
+	/* also has to be done on clone_of. */
+	int i;
+
+	fprintf(stdout_file, "Name:    Clone of:\n");
+	for (i=0;drivers[i];i++)
+	{
+		if(drivers[i]->clone_of &&
+				!(drivers[i]->clone_of->flags & NOT_A_DRIVER) &&
+				( !strwildcmp(gamename,drivers[i]->name) ||
+				  !strwildcmp(gamename,drivers[i]->clone_of->name)))
+			fprintf(stdout_file, "%-8s %-8s\n",drivers[i]->name,drivers[i]->clone_of->name);
+	}
+	return 0;
+}
+
+static int frontend_list_cpu(void)
+{
+	struct InternalMachineDriver drv;
+	int i, j;
+	int year;
+
+	/* for (j = 1; j < CPU_COUNT; j++) */
+	/*   fprintf(stdout_file, "\t%s", cputype_name(j)); */
+	for (j = 0; j < 3; j++)
+		printf("\t%d", 8 << j);
+
+	fprintf(stdout_file, "\n");
+
+	for (year = 1980; year <= 2000; year++)
+	{
+		int count[CPU_COUNT];
+		int count_buswidth[3];
+
+		for (j = 0; j < CPU_COUNT; j++)
+			count[j] = 0;
+		for (j = 0; j < 3; j++)
+			count_buswidth[j] = 0;
+
+		i = 0;
+
+		while (drivers[i])
+		{
+			expand_machine_driver(drivers[i]->drv, &drv);	
+			if (drivers[i]->clone_of == 0 || (drivers[i]->clone_of->flags & NOT_A_DRIVER))
+			{
+				const struct MachineCPU *x_cpu = drv.cpu;
+
+				if (atoi(drivers[i]->year) == year)
+				{
+					/*              for (j = 0; j < MAX_CPU; j++) */
+					j = 0;  /* count only the main cpu */
+					{
+						count[x_cpu[j].cpu_type]++;
+						switch (cputype_databus_width(x_cpu[j].cpu_type))
+						{
+							case  8: count_buswidth[0]++; break;
+							case 16: count_buswidth[1]++; break; 
+							case 32: count_buswidth[2]++; break;
+						}
+					}
+				}
+			}
+			i++;
+		}
+
+		fprintf(stdout_file, "%d", year);
+		/* for (j = 1; j < CPU_COUNT; j++) */
+		/*   fprintf(stdout_file, "\t%d", count[j]); */
+		for (j = 0; j < 3; j++)
+			printf("\t%d", count_buswidth[j]);
+
+		fprintf(stdout_file, "\n");
+	}
+	return OSD_OK;
+}
+
+static int frontend_list_gamelistheader(void)
+{
+	fprintf(stdout_file,
+			"This is the complete list of games supported by %s %s.\n",
+			NAME, build_version);
+	if (!showclones)
+		fprintf(stdout_file,
+				"Variants of the same game are not included, you can use the -listclones command\n"
+				"to get a list of the alternate versions of a given game.\n");
+	fprintf(stdout_file, "\n"
+			"This list is generated automatically and is not 100%% accurate (particularly in\n"
+			"the Screen Flip column). Please let us know of any errors so we can correct\n"
+			"them.\n"
+			"\n"
+			"Here are the meanings of the columns:\n");
+	fprintf(stdout_file, "\n"
+			"Working\n"
+			"=======\n"
+			"  NO: Emulation is still in progress; the game does not work correctly. This\n"
+			"  means anything from major problems to a black screen.\n");
+	fprintf(stdout_file, "\n"
+			"Correct Colors\n"
+			"==============\n"
+			"    YES: Colors should be identical to the original.\n"
+			"  CLOSE: Colors are nearly correct.\n"
+			"     NO: Colors are completely wrong. \n");
+	fprintf(stdout_file, "\n"
+			"  Note: In some cases, the color PROMs for some games are not yet available.\n"
+			"  This causes a NO GOOD DUMP KNOWN message on startup (and, of course, the game\n"
+			"  has wrong colors). The game will still say YES in this column, however,\n"
+			"  because the code to handle the color PROMs has been added to the driver. When\n"
+			"  the PROMs are available, the colors will be correct.\n");
+	fprintf(stdout_file, "\n"
+			"Sound\n"
+			"=====\n"
+			"  PARTIAL: Sound support is incomplete or not entirely accurate. \n"
+			"\n"
+			"  Note: Some original games contain analog sound circuitry, which is difficult\n"
+			"  to emulate. Thereforce, these emulated sounds may be significantly different.\n");
+	fprintf(stdout_file, "\n"
+			"Screen Flip\n"
+			"===========\n"
+			"  Many games were offered in cocktail-table models, allowing two players to sit\n"
+			"  across from each other; the game's image flips 180 degrees for each player's\n"
+			"  turn. Some games also have a \"Flip Screen\" DIP switch setting to turn the\n"
+			"  picture (particularly useful with vertical games).\n"
+			"  In many cases, this feature has not yet been emulated.\n");
+	fprintf(stdout_file, "\n"
+			"Internal Name\n"
+			"=============\n"
+			"  This is the unique name that must be used when running the game from a\n"
+			"  command line.\n"
+			"\n"
+			"  Note: Each game's ROM set must be placed in the ROM path, either in a .zip\n"
+			"  file or in a subdirectory with the game's Internal Name. The former is\n"
+			"  suggested, because the files will be identified by their CRC instead of\n"
+			"  requiring specific names.\n\n");
+	fprintf(stdout_file, "+----------------------------------+-------+-------+-------+-------+----------+\n");
+	fprintf(stdout_file, "|                                  |       |Correct|       |Screen | Internal |\n");
+	fprintf(stdout_file, "| Game Name                        |Working|Colors | Sound | Flip  |   Name   |\n");
+	fprintf(stdout_file, "+----------------------------------+-------+-------+-------+-------+----------+\n");
+	return OSD_OK;
+}
+
+static int frontend_list_hash(int type)
+{
+	int i;
+	for (i = 0; drivers[i]; i++)
+	{
+		const struct RomModule *region, *rom;
+		for (region = rom_first_region(drivers[i]); region; region = rom_next_region(region))
+			for (rom = rom_first_file(region); rom; rom = rom_next_file(rom))
+			{
+				char chksum[256];
+
+				if (hash_data_extract_printable_checksum(ROM_GETHASHDATA(rom), type, chksum))
+					fprintf(stdout_file, "%s %-12s %s\n", chksum, ROM_GETNAME(rom), drivers[i]->description);
+			}
+	}
+
+	return OSD_OK;
+}
diff --git a/src/unix/ident.c b/src/unix/ident.c
new file mode 100644
index 0000000..be37124
--- /dev/null
+++ b/src/unix/ident.c
@@ -0,0 +1,305 @@
+#include "xmame.h"
+#include "audit.h"
+#include "unzip.h"
+#include "driver.h"
+#include <dirent.h>
+
+#ifdef BSD43 /* old style directory handling */
+#include <sys/types.h>
+#include <sys/dir.h>
+#define dirent direct
+#endif
+
+unsigned int crc32 (unsigned int crc, const unsigned char *buf, unsigned int len);
+void romident(const char* name, int enter_dirs);
+
+enum { KNOWN_START, KNOWN_ALL, KNOWN_NONE, KNOWN_SOME };
+
+static int silentident = 0;
+static int knownstatus = KNOWN_START;
+static int ident = 0;
+
+enum { IDENT_IDENT = 1, IDENT_ISKNOWN };
+
+struct rc_option frontend_ident_opts[] = {
+   /* name, shortname, type, dest, deflt, min, max, func, help */
+   { "Rom Identification Related", NULL,	rc_seperator,	NULL,
+     NULL,		0,			0,		NULL,
+     NULL },
+   { "ident",		"id",			rc_set_int,	&ident,
+     NULL,		IDENT_IDENT,		0,		NULL,
+     "Identify unknown romdump, or unknown romdumps in dir/zip" },
+   { "isknown",		"ik",			rc_set_int,	&ident,
+     NULL,		IDENT_ISKNOWN,		0,		NULL,
+     "Check if romdump or romdumps in dir/zip are known"} ,
+   { NULL,		NULL,			rc_end,		NULL,
+     NULL,		0,			0,		NULL,
+     NULL }
+};
+
+
+/* Identifies a rom from from this checksum */
+static void match_roms(const struct GameDriver *driver,const char* hash,int *found)
+{
+	const struct RomModule *region, *rom;
+
+	for (region = rom_first_region(driver); region; region = rom_next_region(region))
+	{
+		for (rom = rom_first_file(region); rom; rom = rom_next_file(rom))
+		{
+			if (hash_data_is_equal(hash, ROM_GETHASHDATA(rom), 0))
+			{
+				char baddump = hash_data_has_info(ROM_GETHASHDATA(rom), HASH_INFO_BAD_DUMP);
+
+				if (!silentident)
+				{
+					if (*found != 0)
+						fprintf(stdout_file, "             ");
+					fprintf(stdout_file, "= %s%-12s  %s\n",baddump ? "(BAD) " : "",ROM_GETNAME(rom),driver->description);
+				}
+				(*found)++;
+			}
+		}
+	}
+}
+
+void identify_rom(const char* name, const char* hash, int length)
+{
+	int found = 0;
+
+	/* remove directory name */
+	int i;
+	for (i = strlen(name)-1;i >= 0;i--)
+	{
+		if (name[i] == '/' || name[i] == '\\')
+		{
+			i++;
+			break;
+		}
+	}
+	if (!silentident)
+		fprintf(stdout_file, "%s ",&name[0]);
+
+	for (i = 0; drivers[i]; i++)
+		match_roms(drivers[i],hash,&found);
+
+	for (i = 0; test_drivers[i]; i++)
+		match_roms(test_drivers[i],hash,&found);
+
+	if (found == 0)
+	{
+		unsigned size = length;
+		while (size && (size & 1) == 0) size >>= 1;
+		if (size & ~1)
+		{
+			if (!silentident)
+				fprintf(stdout_file, "NOT A ROM\n");
+		}
+		else
+		{
+			if (!silentident)
+				fprintf(stdout_file, "NO MATCH\n");
+			if (knownstatus == KNOWN_START)
+				knownstatus = KNOWN_NONE;
+			else if (knownstatus == KNOWN_ALL)
+				knownstatus = KNOWN_SOME;
+		}
+	}
+	else
+	{
+		if (knownstatus == KNOWN_START)
+			knownstatus = KNOWN_ALL;
+		else if (knownstatus == KNOWN_NONE)
+			knownstatus = KNOWN_SOME;
+	}
+}
+
+/* Identifies a file from this checksum */
+void identify_file(const char* name)
+{
+	FILE *f;
+	int length;
+	unsigned char* data;
+	char hash[HASH_BUF_SIZE];
+
+	f = fopen(name,"rb");
+	if (!f) {
+		return;
+	}
+
+	/* determine length of file */
+	if (fseek (f, 0L, SEEK_END)!=0)	{
+		fclose(f);
+		return;
+	}
+
+	length = ftell(f);
+	if (length == -1L) {
+		fclose(f);
+		return;
+	}
+
+	/* empty file */
+	if (!length) {
+		fclose(f);
+		return;
+	}
+
+	/* allocate space for entire file */
+	data = (unsigned char*)malloc(length);
+	if (!data) {
+		fclose(f);
+		return;
+	}
+
+	if (fseek (f, 0L, SEEK_SET)!=0) {
+		free(data);
+		fclose(f);
+		return;
+	}
+
+	if (fread(data, 1, length, f) != length) {
+		free(data);
+		fclose(f);
+		return;
+	}
+
+	fclose(f);
+
+	/* Compute checksum of all the available functions. Since MAME for
+	   now carries inforamtions only for CRC and SHA1, we compute only
+	   these */
+	if (options.crc_only)
+		hash_compute(hash, data, length, HASH_CRC);
+	else
+		hash_compute(hash, data, length, HASH_CRC|HASH_SHA1);
+	
+	/* Try to identify the ROM */
+	identify_rom(name, hash, length);
+
+	free(data);
+}
+
+void identify_zip(const char* zipname)
+{
+	struct zipent* ent;
+
+	ZIP* zip = openzip( FILETYPE_RAW, 0, zipname );
+	if (!zip)
+		return;
+
+	while ((ent = readzip(zip))) {
+		/* Skip empty file and directory */
+		if (ent->uncompressed_size!=0) {
+			char* buf = (char*)malloc(strlen(zipname)+1+strlen(ent->name)+1);
+			char hash[HASH_BUF_SIZE];
+			UINT8 crcs[4];
+
+/*			sprintf(buf,"%s/%s",zipname,ent->name); */
+			sprintf(buf,"%-12s",ent->name);
+
+			/* Decompress the ROM from the ZIP, and compute all the needed 
+			   checksums. Since MAME for now carries informations only for CRC and
+			   SHA1, we compute only these (actually, CRC is extracted from the
+			   ZIP header) */
+			hash_data_clear(hash);
+
+			if (!options.crc_only)
+			{
+				UINT8* data =  (UINT8*)malloc(ent->uncompressed_size);
+				readuncompresszip(zip, ent, (char *)data);
+				hash_compute(hash, data, ent->uncompressed_size, HASH_SHA1);
+				free(data);
+			}
+			
+			crcs[0] = (UINT8)(ent->crc32 >> 24);
+			crcs[1] = (UINT8)(ent->crc32 >> 16);
+			crcs[2] = (UINT8)(ent->crc32 >> 8);
+			crcs[3] = (UINT8)(ent->crc32 >> 0);
+			hash_data_insert_binary_checksum(hash, HASH_CRC, crcs);
+
+			/* Try to identify the ROM */
+			identify_rom(buf, hash, ent->uncompressed_size);
+
+			free(buf);
+		}
+	}
+
+	closezip(zip);
+}
+
+void identify_dir(const char* dirname)
+{
+	DIR *dir;
+	struct dirent *ent;
+
+	dir = opendir(dirname);
+	if (!dir) {
+		return;
+	}
+
+	ent = readdir(dir);
+	while (ent) {
+		/* Skip special files */
+		if (ent->d_name[0]!='.') {
+			char* buf = (char*)malloc(strlen(dirname)+1+strlen(ent->d_name)+1);
+			sprintf(buf,"%s/%s",dirname,ent->d_name);
+			romident(buf,0);
+			free(buf);
+		}
+
+		ent = readdir(dir);
+	}
+	closedir(dir);
+}
+
+void romident(const char* name,int enter_dirs)
+{
+	struct stat s;
+
+	if (stat(name,&s) != 0)	{
+		fprintf(stdout_file, "%s: %s\n",name,strerror(errno));
+		return;
+	}
+
+	if (S_ISDIR(s.st_mode)) {
+		if (enter_dirs)
+			identify_dir(name);
+	} else {
+		unsigned l = strlen(name);
+		if (l>=4 && stricmp(name+l-4,".zip")==0)
+			identify_zip(name);
+		else
+			identify_file(name);
+		return;
+	}
+}
+
+int frontend_ident(char *gamename)
+{
+	if (!ident)
+		return 1234;
+
+	if (!gamename)
+	{
+		fprintf(stderr_file, "-ident / -isknown requires a game- or filename as second argument\n");
+		return OSD_NOT_OK;
+	}
+
+	if (ident == IDENT_ISKNOWN)
+		silentident = 1;
+
+	romident(gamename, 1);
+
+	if (ident == IDENT_ISKNOWN)
+	{
+		switch (knownstatus)
+		{
+			case KNOWN_START: fprintf(stdout_file, "ERROR     %s\n",gamename); break;
+			case KNOWN_ALL:   fprintf(stdout_file, "KNOWN     %s\n",gamename); break;
+			case KNOWN_NONE:  fprintf(stdout_file, "UNKNOWN   %s\n",gamename); break;
+			case KNOWN_SOME:  fprintf(stdout_file, "PARTKNOWN %s\n",gamename); break;
+		}
+	}
+	return OSD_OK;
+}
diff --git a/src/unix/install-sh b/src/unix/install-sh
new file mode 100755
index 0000000..ebc6691
--- /dev/null
+++ b/src/unix/install-sh
@@ -0,0 +1,250 @@
+#! /bin/sh
+#
+# install - install a program, script, or datafile
+# This comes from X11R5 (mit/util/scripts/install.sh).
+#
+# Copyright 1991 by the Massachusetts Institute of Technology
+#
+# Permission to use, copy, modify, distribute, and sell this software and its
+# documentation for any purpose is hereby granted without fee, provided that
+# the above copyright notice appear in all copies and that both that
+# copyright notice and this permission notice appear in supporting
+# documentation, and that the name of M.I.T. not be used in advertising or
+# publicity pertaining to distribution of the software without specific,
+# written prior permission.  M.I.T. makes no representations about the
+# suitability of this software for any purpose.  It is provided "as is"
+# without express or implied warranty.
+#
+# Calling this script install-sh is preferred over install.sh, to prevent
+# `make' implicit rules from creating a file called install from it
+# when there is no Makefile.
+#
+# This script is compatible with the BSD install script, but was written
+# from scratch.  It can only install one file at a time, a restriction
+# shared with many OS's install programs.
+
+
+# set DOITPROG to echo to test this script
+
+# Don't use :- since 4.3BSD and earlier shells don't like it.
+doit="${DOITPROG-}"
+
+
+# put in absolute paths if you don't have them in your path; or use env. vars.
+
+mvprog="${MVPROG-mv}"
+cpprog="${CPPROG-cp}"
+chmodprog="${CHMODPROG-chmod}"
+chownprog="${CHOWNPROG-chown}"
+chgrpprog="${CHGRPPROG-chgrp}"
+stripprog="${STRIPPROG-strip}"
+rmprog="${RMPROG-rm}"
+mkdirprog="${MKDIRPROG-mkdir}"
+
+transformbasename=""
+transform_arg=""
+instcmd="$mvprog"
+chmodcmd="$chmodprog 0755"
+chowncmd=""
+chgrpcmd=""
+stripcmd=""
+rmcmd="$rmprog -f"
+mvcmd="$mvprog"
+src=""
+dst=""
+dir_arg=""
+
+while [ x"$1" != x ]; do
+    case $1 in
+	-c) instcmd="$cpprog"
+	    shift
+	    continue;;
+
+	-d) dir_arg=true
+	    shift
+	    continue;;
+
+	-m) chmodcmd="$chmodprog $2"
+	    shift
+	    shift
+	    continue;;
+
+	-o) chowncmd="$chownprog $2"
+	    shift
+	    shift
+	    continue;;
+
+	-g) chgrpcmd="$chgrpprog $2"
+	    shift
+	    shift
+	    continue;;
+
+	-s) stripcmd="$stripprog"
+	    shift
+	    continue;;
+
+	-t=*) transformarg=`echo $1 | sed 's/-t=//'`
+	    shift
+	    continue;;
+
+	-b=*) transformbasename=`echo $1 | sed 's/-b=//'`
+	    shift
+	    continue;;
+
+	*)  if [ x"$src" = x ]
+	    then
+		src=$1
+	    else
+		# this colon is to work around a 386BSD /bin/sh bug
+		:
+		dst=$1
+	    fi
+	    shift
+	    continue;;
+    esac
+done
+
+if [ x"$src" = x ]
+then
+	echo "install:	no input file specified"
+	exit 1
+else
+	true
+fi
+
+if [ x"$dir_arg" != x ]; then
+	dst=$src
+	src=""
+	
+	if [ -d $dst ]; then
+		instcmd=:
+	else
+		instcmd=mkdir
+	fi
+else
+
+# Waiting for this to be detected by the "$instcmd $src $dsttmp" command
+# might cause directories to be created, which would be especially bad 
+# if $src (and thus $dsttmp) contains '*'.
+
+	if [ -f $src -o -d $src ]
+	then
+		true
+	else
+		echo "install:  $src does not exist"
+		exit 1
+	fi
+	
+	if [ x"$dst" = x ]
+	then
+		echo "install:	no destination specified"
+		exit 1
+	else
+		true
+	fi
+
+# If destination is a directory, append the input filename; if your system
+# does not like double slashes in filenames, you may need to add some logic
+
+	if [ -d $dst ]
+	then
+		dst="$dst"/`basename $src`
+	else
+		true
+	fi
+fi
+
+## this sed command emulates the dirname command
+dstdir=`echo $dst | sed -e 's,[^/]*$,,;s,/$,,;s,^$,.,'`
+
+# Make sure that the destination directory exists.
+#  this part is taken from Noah Friedman's mkinstalldirs script
+
+# Skip lots of stat calls in the usual case.
+if [ ! -d "$dstdir" ]; then
+defaultIFS='	
+'
+IFS="${IFS-${defaultIFS}}"
+
+oIFS="${IFS}"
+# Some sh's can't handle IFS=/ for some reason.
+IFS='%'
+set - `echo ${dstdir} | sed -e 's@/@%@g' -e 's@^%@/@'`
+IFS="${oIFS}"
+
+pathcomp=''
+
+while [ $# -ne 0 ] ; do
+	pathcomp="${pathcomp}${1}"
+	shift
+
+	if [ ! -d "${pathcomp}" ] ;
+        then
+		$mkdirprog "${pathcomp}"
+	else
+		true
+	fi
+
+	pathcomp="${pathcomp}/"
+done
+fi
+
+if [ x"$dir_arg" != x ]
+then
+	$doit $instcmd $dst &&
+
+	if [ x"$chowncmd" != x ]; then $doit $chowncmd $dst; else true ; fi &&
+	if [ x"$chgrpcmd" != x ]; then $doit $chgrpcmd $dst; else true ; fi &&
+	if [ x"$stripcmd" != x ]; then $doit $stripcmd $dst; else true ; fi &&
+	if [ x"$chmodcmd" != x ]; then $doit $chmodcmd $dst; else true ; fi
+else
+
+# If we're going to rename the final executable, determine the name now.
+
+	if [ x"$transformarg" = x ] 
+	then
+		dstfile=`basename $dst`
+	else
+		dstfile=`basename $dst $transformbasename | 
+			sed $transformarg`$transformbasename
+	fi
+
+# don't allow the sed command to completely eliminate the filename
+
+	if [ x"$dstfile" = x ] 
+	then
+		dstfile=`basename $dst`
+	else
+		true
+	fi
+
+# Make a temp file name in the proper directory.
+
+	dsttmp=$dstdir/#inst.$$#
+
+# Move or copy the file name to the temp name
+
+	$doit $instcmd $src $dsttmp &&
+
+	trap "rm -f ${dsttmp}" 0 &&
+
+# and set any options; do chmod last to preserve setuid bits
+
+# If any of these fail, we abort the whole thing.  If we want to
+# ignore errors from any of these, just make sure not to ignore
+# errors from the above "$doit $instcmd $src $dsttmp" command.
+
+	if [ x"$chowncmd" != x ]; then $doit $chowncmd $dsttmp; else true;fi &&
+	if [ x"$chgrpcmd" != x ]; then $doit $chgrpcmd $dsttmp; else true;fi &&
+	if [ x"$stripcmd" != x ]; then $doit $stripcmd $dsttmp; else true;fi &&
+	if [ x"$chmodcmd" != x ]; then $doit $chmodcmd $dsttmp; else true;fi &&
+
+# Now rename the file to the real destination.
+
+	$doit $rmcmd -f $dstdir/$dstfile &&
+	$doit $mvcmd $dsttmp $dstdir/$dstfile 
+
+fi &&
+
+
+exit 0
diff --git a/src/unix/joystick-drivers/XInputDevices.c b/src/unix/joystick-drivers/XInputDevices.c
new file mode 100644
index 0000000..eaf01e7
--- /dev/null
+++ b/src/unix/joystick-drivers/XInputDevices.c
@@ -0,0 +1,298 @@
+#ifdef USE_XINPUT_DEVICES
+
+/*
+ * X-Mame XInput trackball code
+ *
+ */
+#include "xmame.h"
+#include "devices.h"
+#include "../video-drivers/x11.h"
+
+#include "XInputDevices.h"
+
+
+static XInputDeviceData XIdevices[XINPUT_MAX_NUM_DEVICES];
+
+/* options for XInput-devices */
+struct rc_option XInputDevices_opts[] = {
+   { "XInput-trackball1",	"XItb1",	rc_string,
+     &XIdevices[XINPUT_MOUSE_0].deviceName,
+     NULL,	1,		0,	NULL,
+     "Device name for trackball of player 1 (see XInput)" },
+   { "XInput-trackball2",	"XItb2",	rc_string,
+     &XIdevices[XINPUT_MOUSE_1].deviceName,
+     NULL,	1,		0,	NULL,
+     "Device name for trackball of player 2 (see XInput)" },
+   { "XInput-trackball3",	"XItb3",	rc_string,
+     &XIdevices[XINPUT_MOUSE_2].deviceName,
+     NULL,	1,		0,	NULL,
+     "Device name for trackball of player 3 (see XInput)" },
+   { "XInput-trackball4",	"XItb4",	rc_string,
+     &XIdevices[XINPUT_MOUSE_3].deviceName,
+     NULL,	1,		0,	NULL,
+     "Device name for trackball of player 4 (see XInput)" },
+   { NULL,		NULL,			rc_end,		NULL,
+     NULL,		0,			0,		NULL,
+     NULL }
+};
+
+/* reset XInput-Event types */
+#define INVALID_EVENT_TYPE	-1
+static int           motion_type = INVALID_EVENT_TYPE;
+static int           button_press_type = INVALID_EVENT_TYPE;
+static int           button_release_type = INVALID_EVENT_TYPE;
+static int           key_press_type = INVALID_EVENT_TYPE;
+static int           key_release_type = INVALID_EVENT_TYPE;
+static int           proximity_in_type = INVALID_EVENT_TYPE;
+static int           proximity_out_type = INVALID_EVENT_TYPE;
+
+/* reset XInput-struct */
+void
+XInput_trackballs_reset()
+{
+  int i;
+  for(i=0;i<XINPUT_MAX_NUM_DEVICES;++i) {
+    XIdevices[i].mameDevice=XMAME_NULLDEVICE;
+    XIdevices[i].deviceName=NULL;
+    XIdevices[i].info=NULL;
+    XIdevices[i].neverMoved=1;
+  }
+}
+
+/* prototypes */
+/* these two functions were taken from the source of the program 'xinput',
+   available at ftp://xxx.xxx.xxx */
+static XDeviceInfo*
+find_device_info(Display *display, char *name, Bool only_extended);
+static int
+register_events(int player_id, Display *dpy, XDeviceInfo *info, char *dev_name);
+
+
+/* initializes XInput devices */
+void
+XInputDevices_init(void)
+{
+  int i,j,k;
+  XDeviceInfoPtr list;
+
+  fprintf(stderr_file, "XInput: Initialization...\n");
+
+  if (!XQueryExtension(display,"XInputExtension",&i,&j,&k)) {
+    fprintf(stderr_file,"XInput: Your Xserver doesn't support XInput Extensions\n");
+    return;
+  }
+
+  /* parse all devicenames */
+  for(i=0;i<XINPUT_MAX_NUM_DEVICES;++i) {
+    if (XIdevices[i].deviceName) {
+      /* if not NULL, check for an existing device */
+      XIdevices[i].info=find_device_info(display,XIdevices[i].deviceName,True);
+      if (! XIdevices[i].info) {
+	fprintf(stderr_file,"XInput: Unable to find device `%s'. Ignoring it!\n",
+		XIdevices[i].deviceName);
+	XIdevices[i].deviceName=NULL;
+      } else {
+	/* ok, found a device, now register device for motion events */
+	if (i < XINPUT_JOYSTICK_1) {
+	  XIdevices[i].mameDevice=XMAME_TRACKBALL;
+	} else {
+	  /* prepared for XInput-Joysticks
+	  XIdevices[i].mameDevice=XMAME_JOYSTICK;
+	  */
+	}
+	if (! register_events(i, display,XIdevices[i].info,XIdevices[i].deviceName)) {
+	  fprintf(stderr_file,"XInput: Couldn't register device `%s' for events. Ignoring it\n",
+		  XIdevices[i].deviceName);
+	  XIdevices[i].deviceName=NULL;
+	}
+      }
+    }
+  }
+
+  /* if core pointer is used as trackball and a XInput device is also defined for player 1
+     ignore core pointer */
+  if (XIdevices[XINPUT_MOUSE_0].deviceName && use_mouse) {
+    fprintf(stderr_file,"XInput: Device `%s' takes precedence over core pointer for player 1\n",
+	    XIdevices[XINPUT_MOUSE_0].deviceName);
+    use_mouse = 0;
+  }
+
+}
+
+/* Process events generated by XInput-devices. For now, just trackballs are supported */
+int
+XInputProcessEvent(XEvent *ev)
+{
+  int i;
+
+  if (ev->type == motion_type) {
+    XDeviceMotionEvent *motion=(XDeviceMotionEvent *) ev;
+
+    for(i = 0; i < MOUSE; i++)
+      if (XIdevices[i].deviceName && motion->deviceid == XIdevices[i].info->id)
+	  break;
+
+    if (i == MOUSE)
+	return 0;
+
+    if (XIdevices[i].neverMoved) {
+	XIdevices[i].neverMoved=0;
+	XIdevices[i].previousValue[0] = motion->axis_data[0];
+	XIdevices[i].previousValue[1] = motion->axis_data[1];
+    }
+
+    mouse_data[i].deltas[0] += motion->axis_data[0] - XIdevices[i].previousValue[0];
+    mouse_data[i].deltas[1] += motion->axis_data[1] - XIdevices[i].previousValue[1];
+
+
+    XIdevices[i].previousValue[0] = motion->axis_data[0];
+    XIdevices[i].previousValue[1] = motion->axis_data[1];
+
+    return 1;
+  } else if (ev->type == button_press_type || ev->type == button_release_type) {
+    XDeviceButtonEvent *button = (XDeviceButtonEvent *)ev;
+
+    for(i = 0; i < MOUSE; i++)
+	if (XIdevices[i].deviceName && button->deviceid == XIdevices[i].info->id)
+	    break;
+
+    if (i == MOUSE)
+	return 0;
+
+    /* fprintf(stderr_file, "XInput: Player %d: Button %d %s\n",
+	    i + 1, button->button, button->state ? "released" : "pressed"); */
+
+    mouse_data[i].buttons[button->button - 1] = (ev->type == button_press_type) ? 1 : 0;
+
+    return 1;
+  }
+
+  return 0;
+}
+
+/* <jake> */
+/* call from osd_trak_read for polling trackballs */
+void
+XInputPollDevices(int player, int *deltax, int *deltay)
+{
+	int i=player;
+	if (player < MOUSE && XIdevices[player].deviceName) {
+		*deltax=mouse_data[player].deltas[0];
+		*deltay=mouse_data[player].deltas[1];
+		mouse_data[player].deltas[0] = 0;
+		mouse_data[player].deltas[1] = 0;
+	} else {
+		*deltax=0;
+		*deltay=0;
+	}
+}
+/* </jake> */
+
+/* this piece of code was taken from package xinput-1.12 */
+static XDeviceInfo*
+find_device_info(Display	*display,
+		 char		*name,
+		 Bool		only_extended)
+{
+    XDeviceInfo	*devices;
+    int		loop;
+    int		num_devices;
+    int		len = strlen(name);
+    Bool	is_id = True;
+    XID		id = 0;
+
+    for(loop=0; loop<len; loop++) {
+	if (!isdigit(name[loop])) {
+	    is_id = False;
+	    break;
+	}
+    }
+
+    if (is_id) {
+	id = atoi(name);
+    }
+
+    devices = XListInputDevices(display, &num_devices);
+
+    for(loop=0; loop<num_devices; loop++) {
+	if ((!only_extended || (devices[loop].use == IsXExtensionDevice)) &&
+	    ((!is_id && strcmp(devices[loop].name, name) == 0) ||
+	     (is_id && devices[loop].id == id))) {
+	    return &devices[loop];
+	}
+    }
+    return NULL;
+}
+
+/* this piece of code was taken from package xinput-1.12 */
+static int
+register_events(int		player_id,
+		Display		*dpy,
+		XDeviceInfo	*info,
+		char		*dev_name)
+{
+    int			number = 0;	/* number of events registered */
+    XEventClass		event_list[7];
+    int			i;
+    XAnyClassPtr	any;
+    XDevice		*device;
+    Window		root_win;
+    unsigned long	screen;
+    XInputClassInfo	*ip;
+    XButtonInfoPtr      binfo;
+    XValuatorInfoPtr    vinfo;
+
+    screen = DefaultScreen(dpy);
+    root_win = RootWindow(dpy, screen);
+
+    device = XOpenDevice(dpy, info->id);
+
+    if (!device) {
+	fprintf(stderr_file, "XInput: Unable to open XInput device `%s'\n", dev_name);
+	return 0;
+    }
+
+    fprintf(stderr_file, "XInput: Player %d using Device `%s'", player_id + 1, dev_name);
+    
+    if (device->num_classes > 0) {
+	any = (XAnyClassPtr)(info->inputclassinfo);
+
+	for (ip = device->classes, i=0; i<info->num_classes; ip++, i++) {
+	    switch (ip->input_class) {
+	    case KeyClass:
+		DeviceKeyPress(device, key_press_type, event_list[number]); number++;
+		DeviceKeyRelease(device, key_release_type, event_list[number]); number++;
+		break;
+
+	    case ButtonClass:
+		binfo = (XButtonInfoPtr) any;
+		DeviceButtonPress(device, button_press_type, event_list[number]); number++;
+		DeviceButtonRelease(device, button_release_type, event_list[number]); number++;
+		fprintf(stderr_file, ", %d buttons", binfo->num_buttons);
+		break;
+
+	    case ValuatorClass:
+		vinfo=(XValuatorInfoPtr) any;
+		DeviceMotionNotify(device, motion_type, event_list[number]); number++;
+		fprintf(stderr_file, ", %d axis", vinfo->num_axes);
+		break;
+
+	    default:
+		break;
+	    }
+	    any = (XAnyClassPtr) ((char *) any+any->length);
+	}
+
+	if (XSelectExtensionEvent(dpy, root_win, event_list, number)) {
+	    fprintf(stderr_file, ": Could not select extended events, not using");
+	    number = 0;
+	}
+    } else
+	fprintf(stderr_file, " contains no classes, not using");
+
+    fprintf(stderr_file, "\n");
+
+    return number;
+}
+
+#endif /* USE_XINPUT_DEVICES */
diff --git a/src/unix/joystick-drivers/XInputDevices.h b/src/unix/joystick-drivers/XInputDevices.h
new file mode 100644
index 0000000..16d1542
--- /dev/null
+++ b/src/unix/joystick-drivers/XInputDevices.h
@@ -0,0 +1,33 @@
+#ifndef __XINPUT_DEVICES_H__
+#define __XINPUT_DEVICES_H__
+
+#include <X11/extensions/XInput.h>
+
+enum { XMAME_NULLDEVICE, XMAME_TRACKBALL, XMAME_JOYSTICK };
+enum { XINPUT_MOUSE_0, XINPUT_MOUSE_1, XINPUT_MOUSE_2, XINPUT_MOUSE_3,
+       XINPUT_JOYSTICK_0, XINPUT_JOYSTICK_1, XINPUT_JOYSTICK_2, XINPUT_JOYSTICK_3,
+       XINPUT_MAX_NUM_DEVICES };
+
+#define XINPUT_MAX_NUM_AXIS 2
+
+/* struct which keeps all info for a XInput-devices */
+typedef struct {
+  char *deviceName;
+  XDeviceInfo *info;
+  int mameDevice;
+  int previousValue[JOY_AXIS];
+  int neverMoved;
+} XInputDeviceData;
+
+/* prototypes */
+void XInputDevices_init(void);
+int XInputProcessEvent(XEvent *);
+/* <jake> */
+#ifdef USE_XINPUT_DEVICES
+void XInputPollDevices(int, int *, int *);
+#endif
+/* </jake> */
+
+extern struct rc_option XInputDevices_opts[];
+
+#endif
diff --git a/src/unix/joystick-drivers/joy_SDL.c b/src/unix/joystick-drivers/joy_SDL.c
new file mode 100644
index 0000000..b137033
--- /dev/null
+++ b/src/unix/joystick-drivers/joy_SDL.c
@@ -0,0 +1,64 @@
+#include "xmame.h"
+#include "devices.h"
+
+struct rc_option joy_SDL_opts[] = {
+   { NULL,		NULL,			rc_end,		NULL,
+     NULL,		0,			0,		NULL,
+     NULL }
+};
+
+
+#ifdef SDL
+
+#include <SDL.h>
+
+void joy_SDL_init(void);
+void joy_SDL_poll(void);
+
+SDL_Joystick 	*joystick;
+
+void joy_SDL_init (void)
+{
+   int i,j;
+   int joy_n=0;    
+
+   if(SDL_Init(SDL_INIT_JOYSTICK ) < 0) printf ("SDL: JoyStick init Error!! ");
+   else printf("SDL: joystick interface initialization...\n");
+
+   joy_n= SDL_NumJoysticks();
+   printf("SDL: %d joysticks founds.\n", joy_n );
+
+   for (i = 0; i < joy_n; i++)
+   {
+      printf("SDL: The names of the joysticks :  %s\n", SDL_JoystickName(i));
+      joystick=SDL_JoystickOpen(i);      
+      if ( joystick == NULL)   printf("SDL:  the joystick init FAIL!!\n");
+
+      joy_data[i].num_buttons = SDL_JoystickNumButtons(joystick);
+      joy_data[i].num_axis    = SDL_JoystickNumAxes(joystick);
+
+      if (joy_data[i].num_buttons > JOY_BUTTONS)
+         joy_data[i].num_buttons = JOY_BUTTONS;
+      if (joy_data[i].num_axis > JOY_AXIS)
+         joy_data[i].num_axis = JOY_AXIS;
+
+      for (j=0; j<joy_data[i].num_axis; j++)
+      {
+         joy_data[i].axis[j].min = -32768;
+         joy_data[i].axis[j].max =  32768;
+      }
+      joy_poll_func = joy_SDL_poll;
+    }
+
+    for (; i < JOY ; i++)
+	joy_data[i].fd = -1;
+
+}
+
+
+void joy_SDL_poll (void)
+{
+    /* this function is merged to SDL.c */
+}
+
+#endif
diff --git a/src/unix/joystick-drivers/joy_i386.c b/src/unix/joystick-drivers/joy_i386.c
new file mode 100644
index 0000000..861dc8d
--- /dev/null
+++ b/src/unix/joystick-drivers/joy_i386.c
@@ -0,0 +1,224 @@
+#include "xmame.h"
+#include "devices.h"
+
+static char *joy_dev = NULL; /* name of joystick device prefix */
+
+struct rc_option joy_i386_opts[] = {
+   /* name, shortname, type, dest, deflt, min, max, func, help */
+#if defined(__ARCH_netbsd) || defined(__ARCH_freebsd) || defined(__ARCH_openbsd)
+   { "joydevname",	"jdev",			rc_string,	&joy_dev,
+     "/dev/joy",	0,			0,		NULL,
+     "Joystick device prefix (defaults to /dev/joy)" },
+#elif defined __ARCH_linux
+   { "joydevname",	"jdev",			rc_string,	&joy_dev,
+     "/dev/js",		0,			0,		NULL,
+     "Joystick device prefix (defaults to /dev/js)" },
+#endif  /* arch */
+   { NULL,		NULL,			rc_end,		NULL,
+     NULL,		0,			0,		NULL,
+     NULL }
+};
+
+#ifdef I386_JOYSTICK
+
+#include <sys/ioctl.h>
+
+/* specific joystick for PC clones */
+#if defined(__ARCH_netbsd) || defined(__ARCH_freebsd) || defined(__ARCH_openbsd)
+
+#include <machine/joystick.h>
+typedef struct joystick joy_struct;
+
+#elif defined __ARCH_linux
+
+#include <linux/joystick.h>
+typedef struct JS_DATA_TYPE joy_struct;
+
+#ifdef JS_VERSION
+#define I386NEW_JOYSTICK 1
+#endif
+
+#else
+#error "i386 style joystick only supported under linux, openbsd, netbsd & freebsd. "
+   "patches to support other arch's are welcome ;)"
+#endif
+
+/* #define JDEBUG */
+
+void joy_i386_poll(void);
+void joy_i386new_poll(void);
+static joy_struct my_joy_data;
+
+void joy_i386_init(void)
+{
+   int i, j;
+   char devname[20];
+#ifdef I386NEW_JOYSTICK
+   int version;
+#endif
+
+   int first_dev = 0;
+   int last_dev = JOY - 1;
+   
+   /* 
+    * If the device name ends with an in-range digit, then don't 
+    * loop through all possible values below.  Just extract the 
+    * device number and use it.
+    */
+   int pos = strlen(joy_dev) - 1;
+   if (pos >= 0 && isdigit(joy_dev[pos]))
+   {
+      int devnum = joy_dev[pos] - '0';
+      if (devnum < JOY)
+      {
+         first_dev = last_dev = devnum;
+         joy_dev[pos] = 0;
+      }
+   }
+
+   fprintf (stderr_file, "I386 joystick interface initialization...\n");
+   for (i = first_dev; i <= last_dev; i++)
+   {
+      sprintf (devname, "%s%d", joy_dev, i);
+      if ((joy_data[i].fd = open (devname, O_RDONLY)) >= 0)
+      {
+         if (read(joy_data[i].fd, &my_joy_data, sizeof(joy_struct)) != sizeof(joy_struct))
+         {
+            close(joy_data[i].fd);
+            joy_data[i].fd = -1;
+            continue;
+         }
+         switch(joytype)
+         {
+            case JOY_I386NEW:
+#ifdef I386NEW_JOYSTICK
+               /* new joystick driver 1.x.x API 
+                  check the running version of driver, if 1.x.x is
+                  not detected fall back to 0.8 API */
+
+               if (ioctl (joy_data[i].fd, JSIOCGVERSION, &version)==0)
+               {
+                  char name[60];
+                  ioctl (joy_data[i].fd, JSIOCGAXES, &joy_data[i].num_axis);
+                  ioctl (joy_data[i].fd, JSIOCGBUTTONS, &joy_data[i].num_buttons);
+                  ioctl (joy_data[i].fd, JSIOCGNAME (sizeof (name)), name);
+                  if (joy_data[i].num_buttons > JOY_BUTTONS)
+                     joy_data[i].num_buttons = JOY_BUTTONS;
+                  if (joy_data[i].num_axis > JOY_AXIS)
+                     joy_data[i].num_axis = JOY_AXIS;
+                  fprintf (stderr_file, "Joystick: %s is %s\n", devname, name);
+                  fprintf (stderr_file, "Joystick: Built in driver version: %d.%d.%d\n", JS_VERSION >> 16, (JS_VERSION >> 8) & 0xff, JS_VERSION & 0xff);
+                  fprintf (stderr_file, "Joystick: Kernel driver version  : %d.%d.%d\n", version >> 16, (version >> 8) & 0xff, version & 0xff);
+                  for (j=0; j<joy_data[i].num_axis; j++)
+                  {
+                     joy_data[i].axis[j].min = -32768;
+                     joy_data[i].axis[j].max =  32768;
+                  }
+                  joy_poll_func = joy_i386new_poll;
+                  break;
+               }
+               /* else we're running on a kernel with 0.8 driver */
+               fprintf (stderr_file, "Joystick: %s unknown type\n", devname);
+               fprintf (stderr_file, "Joystick: Built in driver version: %d.%d.%d\n", JS_VERSION >> 16, (JS_VERSION >> 8) & 0xff, JS_VERSION & 0xff);
+               fprintf (stderr_file, "Joystick: Kernel driver version  : 0.8 ??\n");
+               fprintf (stderr_file, "Joystick: Please update your Joystick driver !\n");
+               fprintf (stderr_file, "Joystick: Using old interface method\n");
+#else
+               fprintf (stderr_file, "New joystick driver (1.x.x) support not compiled in.\n");
+               fprintf (stderr_file, "Falling back to 0.8 joystick driver api\n");
+#endif            
+               joytype = JOY_I386;
+            case JOY_I386:
+               joy_data[i].num_axis = 2;
+#if defined(__ARCH_netbsd) || defined(__ARCH_freebsd) || defined(__ARCH_openbsd)
+               joy_data[i].num_buttons = 2;
+#else
+               joy_data[i].num_buttons = JOY_BUTTONS;
+#endif
+               joy_data[i].axis[0].center = my_joy_data.x;
+               joy_data[i].axis[1].center = my_joy_data.y;
+               joy_data[i].axis[0].min    = my_joy_data.x - 10;
+               joy_data[i].axis[1].min    = my_joy_data.y - 10;
+               joy_data[i].axis[0].max    = my_joy_data.x + 10;
+               joy_data[i].axis[1].max    = my_joy_data.y + 10;
+               
+               joy_poll_func = joy_i386_poll;
+               break;
+         }
+         fcntl (joy_data[i].fd, F_SETFL, O_NONBLOCK);
+      }
+   }
+}
+
+#ifdef I386NEW_JOYSTICK
+/* 
+ * Routine to manage PC clones joystick via new Linux driver 1.2.xxx
+ */
+void joy_i386new_poll (void)
+{
+   struct js_event js;
+   int i;
+
+   for (i=0; i<JOY; i++)
+   {
+      if (joy_data[i].fd < 0)
+         continue;
+      while ((read (joy_data[i].fd, &js, sizeof (struct js_event))) == sizeof (struct js_event))
+      {
+         switch (js.type & ~JS_EVENT_INIT)
+         {
+            case JS_EVENT_BUTTON:
+               if (js.number < JOY_BUTTONS)
+                  joy_data[i].buttons[js.number] = js.value;
+#ifdef JDEBUG
+               fprintf (stderr, "Button=%d,value=%d\n", js.number, js.value);
+#endif
+               break;
+
+            case JS_EVENT_AXIS:
+               if (js.number < JOY_AXIS)
+                  joy_data[i].axis[js.number].val = js.value;
+#ifdef JDEBUG
+               fprintf (stderr, "Axis=%d,value=%d\n", js.number, js.value);
+#endif
+               break;
+         }
+      }
+   }
+      
+   /* evaluate joystick movements */
+   joy_evaluate_moves ();
+}
+#endif
+
+/* 
+ * Routine to manage PC clones joystick via standard driver 
+ */
+void joy_i386_poll (void)
+{
+   int i, j;
+
+   for (i=0; i<JOY; i++)
+   {
+      if (joy_data[i].fd < 0)
+         continue;
+      if (read (joy_data[i].fd, &my_joy_data, sizeof (joy_struct)) != sizeof (joy_struct))
+         continue;
+      
+      /* get value of buttons */
+#if defined(__ARCH_netbsd) || defined(__ARCH_freebsd) || defined(__ARCH_openbsd)
+      joy_data[i].buttons[0] = my_joy_data.b1;
+      joy_data[i].buttons[1] = my_joy_data.b2;
+#else
+      for (j = 0; j < JOY_BUTTONS; j++)
+         joy_data[i].buttons[j] = my_joy_data.buttons & (0x01 << j);
+#endif
+      joy_data[i].axis[0].val = my_joy_data.x;
+      joy_data[i].axis[1].val = my_joy_data.y;
+   }
+
+   /* evaluate joystick movements */
+   joy_evaluate_moves ();
+}
+
+#endif
diff --git a/src/unix/joystick-drivers/joy_pad.c b/src/unix/joystick-drivers/joy_pad.c
new file mode 100644
index 0000000..2ee2101
--- /dev/null
+++ b/src/unix/joystick-drivers/joy_pad.c
@@ -0,0 +1,102 @@
+/*
+ ************************** FM TOWNS PAD specifics routines *************
+ */
+
+#include <fcntl.h>
+#include "xmame.h"
+#include "devices.h"
+#include "pad.h"
+
+/*
+ * Towns Pad control module for Xmame
+ *
+ * Author : Osamu KURATI
+ * Version : 29 apr 1997 0.000
+ */
+
+/*
+ * Joy Stick Code
+ * Up : 1
+ * Down       : 2
+ * Left       : 4
+ * Right      : 8
+ * A  : 10
+ * B  : 20
+ *
+ *
+ * PAD bit number
+ * up         : 0
+ * down               : 1
+ * left               : 2
+ * right      : 3
+ * A          : 4
+ * B          : 5
+ * RUN                : 6
+ * SELECT     : 7
+ */
+
+#ifdef LIN_FM_TOWNS
+static unsigned long lPadLastButton = 0;
+static char *towns_pad_dev = NULL; /* name of FM-TOWNS device */
+#endif
+
+struct rc_option joy_pad_opts[] = {
+   /* name, shortname, type, dest, deflt, min, max, func, help */
+#ifdef LIN_FM_TOWNS
+   { "paddevname",	NULL,			rc_string,	&towns_pad_dev,
+     "/dev/pad00",	0,			0,		NULL,
+     "Name of pad device (defaults to /dev/pad00)" },
+#endif
+   { NULL,		NULL,			rc_end,		NULL,
+     NULL,		0,			0,		NULL,
+     NULL }
+};
+
+#ifdef LIN_FM_TOWNS
+void joy_pad_poll(void);
+
+void joy_pad_init(void)
+{
+  int i;
+  
+  joy_poll_func  = joy_pad_poll;
+  lPadLastButton = 0;
+ 
+  if ((joy_data[0].fd = open(towns_pad_dev, O_NONBLOCK | O_RDONLY)) >= 0)
+  {
+    joy_data[0].num_buttons=4;
+    joy_data[0].num_axis=2;
+  }
+}
+
+static int Pad()
+{
+  struct pad_event ev;
+  if (read(joy_data[0].fd, &ev, sizeof ev) == sizeof ev){
+    lPadLastButton = ev.buttons;
+  }
+  return((int) lPadLastButton & 0xff);
+}
+
+/*
+ * Linux FM-TOWNS game pad driver based joystick emulation routine
+ */
+void joy_pad_poll(void)
+{
+      int i;
+      int res = Pad();
+
+      /* get value of buttons */
+      for (i=0; i<4; i++)
+      {
+         joy_data[0].buttons[i] = (res>>4) & (0x01<<i);
+      }
+
+      joy_data[0].axis[0].dirs[0] = res & 0x01;
+      joy_data[0].axis[0].dirs[1] = res & 0x02;
+      joy_data[0].axis[1].dirs[0] = res & 0x04;
+      joy_data[0].axis[1].dirs[1] = res & 0x08;
+}
+
+/* TOWNS_PAD */
+#endif
diff --git a/src/unix/joystick-drivers/joy_ps2.c b/src/unix/joystick-drivers/joy_ps2.c
new file mode 100644
index 0000000..6e1e0ba
--- /dev/null
+++ b/src/unix/joystick-drivers/joy_ps2.c
@@ -0,0 +1,434 @@
+/*
+ * XMame PlayStation2 controller support.  Supports standard PlayStation
+ * controllers on a PlayStation2-Linux machine with /dev/ps2padxx drivers
+ *
+ * Written by Joan Touzet <joant@ieee.org> May 2002.
+ * Release 1.0 -- "Cling Peaches"
+ * 
+ * TODO: * Consider allowing user to change controller mode during runtime
+ *         (problematic for games expecting analog input)
+ *       * Select optimal controller mode on a per-game basis
+ *         (wait for 0.60 per-game mapping module to be in place)
+ *       * Store the controller's pre-xmame state and restore on exit
+ *       * Integrate Analog+ patches for better analog support.
+ *       * Test with pure digital, analog controllers (if avail.)
+ */
+
+/* Format of data read from the PS2 Pad:
+ * 32 character-sized bytes
+ * Byte #	Data
+ * ========================================
+ *  0		0x0 = valid data, other = invalid data
+ *  		  (in fact, ps2pad_read will return -EIO if data[0] != 0)
+ *  		  
+ *  1		Packed status data
+ *                Upper byte: pad type, use PS2PAD_TYPE() to shift
+ *  		  Known types:
+ *  		    NEJICON   -- 0x2
+ *  		    DIGITAL   -- 0x4
+ *  		    ANALOG    -- 0x5
+ *  		    DUALSHOCK -- 0x7
+ *  		  (Lower byte * 2 + 2) = upper bound of data[] index
+ *  		    For DIGITAL controllers (and DUALSHOCK controllers in
+ *  		      digital mode) = 0 (only data[2] and data[3] filled)
+ *		    For DUALSHOCK controllers in analog mode = 3
+ *		      (data[4] through data[7] filled)
+ *		      
+ *  2		First half of digital button bits:
+ *  		  76543210
+ *  		  --------
+ *  		  |||||||\__ SELECT
+ *  		  ||||||\___ L3
+ *  		  |||||\____ R3
+ *  		  ||||\_____ START
+ *  		  |||\______ UP
+ *  		  ||\_______ DOWN
+ *  		  |\________ LEFT
+ *  		  \_________ RIGHT
+ *
+ *  3		Second half of digital button bits:
+ *  		  76543210
+ *  		  --------
+ *  		  |||||||\__ L2
+ *  		  ||||||\___ R2
+ *  		  |||||\____ L1
+ *  		  ||||\_____ R1
+ *  		  |||\______ TRIANGLE
+ *  		  ||\_______ CIRCLE
+ *  		  |\________ CROSS
+ *  		  \_________ SQUARE
+ *
+ * 4		(DualShock Analog Mode) Analog Right X Axis
+ * 		  8 unsigned bits ( -127 for signed data)
+ *
+ * 5		(DualShock Analog Mode) Analog Right Y Axis
+ * 		  8 unsigned bits ( -127 for signed data)
+ *
+ * 6		(DualShock Analog Mode) Analog Left X Axis
+ * 		  8 unsigned bits ( -127 for signed data)
+ *
+ * 7		(DualShock Analog Mode) Analog Left Y Axis
+ * 		  8 unsigned bits ( -127 for signed data)
+ */
+
+#ifdef PS2_JOYSTICK
+
+#include "xmame.h"
+#include "devices.h"
+#include <sys/ioctl.h>
+#include <linux/ps2/pad.h>
+
+/* define the following for PS2 driver debugging */
+#undef JDEBUG
+#define BUFSIZE 128
+/* name of ps2pad device prefix */
+#define PS2PADDEV "/dev/ps2pad"
+/* name of ps2pad status device */
+#define PS2PADSTAT "/dev/ps2padstat"
+
+/* Global definitions to make code more readable.  Taken from the actual
+ * PS2 pad kernel driver source code.
+ */
+char *pad_type_names[16] = {
+	"type 0",
+	"type 1",
+	"NEJICON",	/* PS2PAD_TYPE_NEJICON	*/
+	"type 3",
+	"DIGITAL",	/* PS2PAD_TYPE_DIGITAL	*/
+	"ANALOG",	/* PS2PAD_TYPE_ANALOG	*/
+	"type 6",
+	"DUALSHOCK",	/* PS2PAD_TYPE_DUALSHOCK*/
+	"type 8",
+	"type 9",
+	"type A",
+	"type B",
+	"type C",
+	"type D",
+	"type E",
+	"type F",
+};
+
+char *pad_stat_names[4] = {
+	"Not connected",
+	"Ready",
+	"Busy",
+	"Error",
+};
+
+char *pad_rstat_names[4] = {
+	"Complete",
+	"Failed",
+	"Busy",
+	"UNKNOWN",
+};
+
+struct rc_option joy_ps2_opts[] = {
+   /* name, shortname, type, dest, deflt, min, max, func, help */
+   { NULL,		NULL,			rc_end,		NULL,
+     NULL,		0,			0,		NULL,
+     NULL }
+};
+
+static u_char pad_data[PS2PAD_DATASIZE];
+static int numpads = 0;
+
+/* Forward declarations */
+void joy_ps2_poll(void);
+
+
+/* Lock/unlock the PS2 pad's mode. */
+static void ps2pad_lockset (
+	int fd,				/* fd pointing to pad device */
+	char padtype,			/* Controller mode/type */
+	int lock)			/* 0 = unlock, 1 = lock */
+{
+    struct ps2pad_mode padmode;
+    struct ps2pad_modeinfo modeinfo;
+    int rc, i, max;
+
+    /* First, search the controller's table of possible modes for
+     * a match with the requested mode.  If no match is found,
+     * use the current mode.
+     */
+    modeinfo.term = PS2PAD_MODETABLE;
+    modeinfo.offs = -1;
+    rc = ioctl (fd, PS2PAD_IOCMODEINFO, &modeinfo);
+    if (rc != 0)
+    {
+	fprintf(stderr_file, "Unexpected rc=%d from ps2 IOCMODEINFO ioctl!\n", rc);
+	return;
+    }
+    max = modeinfo.result;
+    for (i=0; i<max; i++)
+    {
+	modeinfo.offs = i;
+	rc = ioctl (fd, PS2PAD_IOCMODEINFO, &modeinfo);
+	if (rc != 0)
+	{
+	    fprintf(stderr_file, "Unexpected rc=%d from ps2 IOCMODEINFO ioctl!\n", rc);
+	    return;
+	}
+	if (modeinfo.result == padtype) 
+	    break;
+    }
+
+    if (i == max) {
+	/* Couldn't find our mode.  Use current mode. */
+	modeinfo.term = PS2PAD_MODECUROFFS;
+	rc = ioctl (fd, PS2PAD_IOCMODEINFO, &modeinfo);
+	i = modeinfo.result;
+	if (rc != 0)
+	{
+	    fprintf(stderr_file, "Unexpected rc=%d from ps2 IOCMODEINFO ioctl!\n", rc);
+	    return;
+	}
+    }
+	
+    /* Now lock or unlock our controller. */
+    padmode.offs = i;
+    /* Magic numbers used:  0, 1: maintain present lock status
+     *                         2: unlock switch
+     *                         3: lock switch
+     */
+    padmode.lock = ((lock == 1) ? 3 : 2);
+    rc = ioctl (fd, PS2PAD_IOCSETMODE, &padmode);
+    if (rc != 0) 
+    {
+	fprintf (stderr_file, "PS2 Pad could not be %slocked! rc=%d \n",
+			(lock == 0) ? "un" : "", rc);
+	exit(-1);
+    }
+    return;
+}
+
+
+/* Initialization routine. */
+void joy_ps2_init (void)
+{
+    int i, j, res, tempfd;
+    char devname[BUFSIZE];
+
+    fprintf (stderr_file, "PlayStation2 pad interface initialization...\n");
+
+
+    /* Check how many possible pads can be connected. */
+    /* The following code has been commented out because it seems to
+     * cause the PS2 to crash intermittently.  Until the bug is
+     * worked out, we'll assume a maximum of 2 devices (since no
+     * more are supported by the kernel anyway.
+     */
+    numpads = 2;
+#if 0
+    sprintf (devname, "%s", PS2PADSTAT);
+    tempfd = open(devname, O_RDONLY|O_NONBLOCK);
+    if (tempfd < 0) {
+	fprintf (stderr_file, "PlayStation2 padstat failed to open!\n");
+	fflush(stderr);
+	return;
+    }
+    res = ioctl(tempfd, PS2PAD_IOCGETNPADS, &numpads);
+    if (res < 0) {
+	fprintf (stderr_file, "PlayStation2 padstat ioctl failed!\n");
+	fflush(stderr);
+	return;
+    }
+    close(tempfd);
+#endif
+
+    /* Now loop through each controller. */
+    for (i = 0; i < numpads; i++)
+    {
+	sprintf (devname, "%s%1d0", PS2PADDEV, i);
+
+	if ((joy_data[i].fd = open (devname, O_RDONLY)) >= 0)
+	{
+	    int ires = PS2PAD_STAT_BUSY;
+
+	    /* We might have just woken up the pad.  Wait for READY */
+	    while (ires == PS2PAD_STAT_READY)
+	    {
+		res = ioctl(joy_data[i].fd, PS2PAD_IOCGETSTAT, &ires);
+		if (res != 0)
+		{
+		    fprintf(stderr_file,
+			"Unexpected rc=%d from ps2 IOCGETSTAT ioctl!\n", res);
+		}
+	    }
+	    if ((ires == PS2PAD_STAT_NOTCON) ||
+			(ires == PS2PAD_STAT_ERROR))
+	    {
+		if (ires == PS2PAD_STAT_ERROR)
+		    fprintf(stderr_file,
+			"PS2 Pad #%d had PS2PAD_STAT_ERROR!\n", i);
+		fprintf(stderr_file,
+			"Pad data corrupt, closing fd %d\n", joy_data[i].fd);
+		close(joy_data[i].fd);
+		joy_data[i].fd = -1;
+		continue;
+	    }
+
+	    /* Lock down the controller's mode. */
+	    ps2pad_lockset(joy_data[i].fd, PS2PAD_TYPE_DUALSHOCK, 1);
+
+	    /* Read pad data and fill in default values */
+	    res = read(joy_data[i].fd, &pad_data, PS2PAD_DATASIZE);
+	    if ((res == 0) || (pad_data[0] != 0))
+ 	    {
+	 	fprintf(stderr_file,
+			"Pad data corrupt, closing fd %d\n", joy_data[i].fd);
+		close(joy_data[i].fd);
+		joy_data[i].fd = -1;
+		continue;
+	    }
+	    
+	    switch(PS2PAD_TYPE(pad_data[1]))
+	    {
+		case PS2PAD_TYPE_DUALSHOCK:
+			/* 4 axes, 16 buttons. */
+			joy_data[i].num_axis = 4;
+			joy_data[i].num_buttons = 16;
+			break;
+		case PS2PAD_TYPE_DIGITAL:
+		default:
+			/* 0 axes, 16 buttons. */
+			joy_data[i].num_axis = 0;
+			joy_data[i].num_buttons = 16;
+	    }
+	    /* Sanity check. */
+	    if (joy_data[i].num_buttons > JOY_BUTTONS)
+		joy_data[i].num_buttons = JOY_BUTTONS;
+	    if (joy_data[i].num_axis > JOY_AXIS)
+		joy_data[i].num_axis = JOY_AXIS;
+
+	    if (PS2PAD_TYPE(pad_data[1]) == PS2PAD_TYPE_DUALSHOCK)
+	    {
+		joy_data[i].axis[0].center = (int)pad_data[6];
+		joy_data[i].axis[1].center = (int)pad_data[7];
+		joy_data[i].axis[2].center = (int)pad_data[4];
+		joy_data[i].axis[3].center = (int)pad_data[5];
+
+		/* Set min/max values to +1/-1 and let autocalibrate
+		 * take care of the rest.
+                 */
+		for (j=0; j<joy_data[i].num_axis; j++)
+		{
+		    if (joy_data[i].axis[j].center == 0)
+			joy_data[i].axis[j].center = 0x7f;
+		    joy_data[i].axis[j].min = joy_data[i].axis[j].center - 1;
+		    joy_data[i].axis[j].max = joy_data[i].axis[j].center + 1;
+		}
+	    }
+
+	    fprintf (stderr_file, "PS2 pad %s is %s\n",
+			    devname,
+			    pad_type_names[PS2PAD_TYPE(pad_data[1])]);
+	    joy_poll_func = joy_ps2_poll;
+	}
+
+    } /* for (numpads) */
+}
+
+
+void joy_ps2_poll (void)
+{
+    int i, res, ires;
+    int buttons;
+
+    for (i=0; i<numpads; i++)
+    {
+	/* Gracefully fail */
+	if (joy_data[i].fd < 0)
+	    continue;
+
+	/* We might have just woken up the pad.  Wait for READY */
+	res = ioctl(joy_data[i].fd, PS2PAD_IOCGETSTAT, &ires);
+	if (res != 0)
+	{
+	    fprintf(stderr_file,
+		"Unexpected rc=%d from ps2 IOCGETSTAT ioctl!\n", res);
+	    fflush(stderr);
+	    return;
+	}
+	if ((ires == PS2PAD_STAT_NOTCON) ||
+		(ires == PS2PAD_STAT_ERROR))
+	{
+	    if (ires == PS2PAD_STAT_ERROR)
+		fprintf(stderr_file,
+			"PS2 Pad #%d had PS2PAD_STAT_ERROR!\n", i);
+	    fprintf(stderr_file,
+		"Pad data corrupt, closing fd %d\n", joy_data[i].fd);
+	    close(joy_data[i].fd);
+	    joy_data[i].fd = -1;
+	    continue;
+	}
+
+	if (ires != PS2PAD_STAT_READY)
+	    continue;
+
+	res = read(joy_data[i].fd, &pad_data, PS2PAD_DATASIZE);
+	if ((res == 0) || (pad_data[0] != 0))
+	{
+	    fprintf(stderr_file,
+		"Pad data corrupt, closing fd %d\n", joy_data[i].fd);
+	    close(joy_data[i].fd);
+	    joy_data[i].fd = -1;
+	    continue;
+	}
+     
+	buttons = ((int)pad_data[2] << 8) | pad_data[3];
+
+#ifdef JDEBUG
+	fprintf(stderr_file, "pad: %x %02x %02x %02x %02x\n",
+			buttons,
+			pad_data[4], pad_data[5], pad_data[6],
+			pad_data[7]);
+#endif
+
+	/* get button values */
+	joy_data[i].buttons[0]  = (buttons & PS2PAD_BUTTON_SQUARE  ) ? 0 : 1;
+	joy_data[i].buttons[1]  = (buttons & PS2PAD_BUTTON_TRIANGLE) ? 0 : 1;
+	joy_data[i].buttons[2]  = (buttons & PS2PAD_BUTTON_CROSS   ) ? 0 : 1;
+	joy_data[i].buttons[3]  = (buttons & PS2PAD_BUTTON_CIRCLE  ) ? 0 : 1;
+	joy_data[i].buttons[4]  = (buttons & PS2PAD_BUTTON_L1      ) ? 0 : 1;
+	joy_data[i].buttons[5]  = (buttons & PS2PAD_BUTTON_R1      ) ? 0 : 1;
+	joy_data[i].buttons[6]  = (buttons & PS2PAD_BUTTON_SELECT  ) ? 0 : 1;
+	joy_data[i].buttons[7]  = (buttons & PS2PAD_BUTTON_START   ) ? 0 : 1;
+	joy_data[i].buttons[8]  = (buttons & PS2PAD_BUTTON_L2      ) ? 0 : 1;
+	joy_data[i].buttons[9]  = (buttons & PS2PAD_BUTTON_R2      ) ? 0 : 1;
+	joy_data[i].buttons[10]  = (buttons & PS2PAD_BUTTON_L3      ) ? 0 : 1;
+	joy_data[i].buttons[11]  = (buttons & PS2PAD_BUTTON_R3      ) ? 0 : 1;
+	joy_data[i].buttons[12]  = (buttons & PS2PAD_BUTTON_LEFT    ) ? 0 : 1;
+	joy_data[i].buttons[13]  = (buttons & PS2PAD_BUTTON_RIGHT   ) ? 0 : 1;
+	joy_data[i].buttons[14]  = (buttons & PS2PAD_BUTTON_UP      ) ? 0 : 1;
+	joy_data[i].buttons[15]  = (buttons & PS2PAD_BUTTON_DOWN    ) ? 0 : 1;
+
+	/* Only read analog data if the pad is in DualShock mode */
+	if (PS2PAD_TYPE(pad_data[1]) == PS2PAD_TYPE_DUALSHOCK)
+	{
+	    joy_data[i].axis[0].val = (int) pad_data[6];
+	    joy_data[i].axis[1].val = (int) pad_data[7];
+	    joy_data[i].axis[2].val = (int) pad_data[4];
+	    joy_data[i].axis[3].val = (int) pad_data[5];
+	}
+
+    }
+
+    /* evaluate joystick movements */
+   joy_evaluate_moves ();
+}
+
+
+void joy_ps2_exit()
+{
+
+   int i;
+   for (i=0; i<numpads; i++)
+   {
+      /* A -1 as the joytype will leave the pad in its current state,
+       * since it will never match a real joypad type
+       */
+      ps2pad_lockset(joy_data[i].fd, -1, 0);
+   }
+}
+
+#endif	/* PS2_JOYSTICK */
diff --git a/src/unix/joystick-drivers/joy_usb.c b/src/unix/joystick-drivers/joy_usb.c
new file mode 100644
index 0000000..6f51576
--- /dev/null
+++ b/src/unix/joystick-drivers/joy_usb.c
@@ -0,0 +1,291 @@
+/*
+ * X-Mame USB HID joystick driver for NetBSD.
+ *
+ * Written by Krister Walfridsson <cato@df.lth.se>
+ */
+#include "xmame.h"
+#include "devices.h"
+
+struct rc_option joy_usb_opts[] = {
+   /* name, shortname, type, dest, deflt, min, max, func, help */
+   { NULL,		NULL,			rc_end,		NULL,
+     NULL,		0,			0,		NULL,
+     NULL }
+};
+
+#ifdef USB_JOYSTICK
+
+#if !defined(__ARCH_netbsd) && !defined(__ARCH_freebsd)
+#error "USB joysticks are only supported under NetBSD and FreeBSD. "
+   "Patches to support other archs are welcome ;)"
+#endif
+
+#if defined(HAVE_USBHID_H) || defined(HAVE_LIBUSBHID_H)
+#	ifdef HAVE_USBHID_H
+#		include <usbhid.h>
+#	endif
+#	ifdef HAVE_LIBUSBHID_H
+#		include <libusbhid.h>
+#	endif
+#else
+#	ifdef __ARCH_netbsd
+#		include <usb.h>
+#	endif
+#	ifdef __ARCH_freebsd
+#		include <libusb.h>
+#	endif
+#endif
+
+#ifdef __ARCH_freebsd
+#include <osreldate.h>
+#include <sys/ioctl.h>
+#endif
+
+#include <dev/usb/usb.h>
+#include <dev/usb/usbhid.h>
+
+struct priv_joydata_struct
+{
+  struct hid_item *hids;
+  int dlen;
+  int offset;
+  char *data_buf;
+} priv_joy_data[JOY];
+
+static int joy_initialize_hid(int i);
+static void joy_usb_poll(void);
+static int joy_read(int fd, int i);
+
+
+
+void joy_usb_init(void)
+{
+  int i;
+  char devname[20];
+
+  fprintf(stderr_file, "USB joystick interface initialization...\n");
+
+  for (i = 0; i < JOY; i++)
+    {
+      sprintf(devname, "/dev/uhid%d", i);
+      if ((joy_data[i].fd = open(devname, O_RDONLY | O_NONBLOCK)) != -1)
+	{
+	  if (!joy_initialize_hid(i))
+	    {
+	      close(joy_data[i].fd);
+	      joy_data[i].fd = -1;
+	    }
+	}
+    }
+
+  joy_poll_func = joy_usb_poll;
+}
+
+
+
+static int joy_initialize_hid(int i)
+{
+  int size, is_joystick, report_id = 0;
+  struct hid_data *d;
+  struct hid_item h;
+  report_desc_t rd;
+
+  if ((rd = hid_get_report_desc(joy_data[i].fd)) == 0)
+    {
+      fprintf(stderr_file, "error: /dev/uhid%d: %s", i, strerror(errno));
+      return FALSE;
+    }
+
+  priv_joy_data[i].hids = NULL;
+
+#if defined(HAVE_USBHID_H) || defined(HAVE_LIBUSBHID_H)
+#if defined(__ARCH_netbsd) || (defined(__ARCH_freebsd) && __FreeBSD_version > 500000)
+  if (ioctl(joy_data[i].fd, USB_GET_REPORT_ID, &report_id) < 0)
+    {
+      fprintf(stderr_file, "error: /dev/uhid%d: %s", i, strerror(errno));
+      return FALSE;
+    }
+#endif
+
+  size = hid_report_size(rd, hid_input, report_id);
+  priv_joy_data[i].offset = 0;
+#else
+  size = hid_report_size(rd, hid_input, &report_id);
+  priv_joy_data[i].offset = (report_id != 0);
+#endif
+  if ((priv_joy_data[i].data_buf = malloc(size)) == NULL)
+    {
+      fprintf(stderr_file, "error: couldn't malloc %d bytes\n", size);
+      hid_dispose_report_desc(rd);
+      return FALSE;
+    }
+  priv_joy_data[i].dlen = size;
+
+  is_joystick = 0;
+#if defined(HAVE_USBHID_H)
+  for (d = hid_start_parse(rd, 1 << hid_input, report_id);
+       hid_get_item(d, &h); )
+#else
+  for (d = hid_start_parse(rd, 1 << hid_input); hid_get_item(d, &h); )
+#endif
+    {
+      int axis, usage, page, interesting_hid;
+
+      page = HID_PAGE(h.usage);
+      usage = HID_USAGE(h.usage);
+
+      /* This test is somewhat too simplistic, but this is how MicroSoft
+       * does, so I guess it works for all joysticks/game pads. */
+      is_joystick = is_joystick ||
+	(h.kind == hid_collection &&
+	 page == HUP_GENERIC_DESKTOP &&
+	 (usage == HUG_JOYSTICK || usage == HUG_GAME_PAD));
+
+      if (h.kind != hid_input)
+	continue;
+
+      if (!is_joystick)
+	continue;
+
+      interesting_hid = TRUE;
+      if (page == HUP_GENERIC_DESKTOP)
+	{
+	  if (usage == HUG_X || usage == HUG_RX)
+	    axis = 0;
+	  else if (usage == HUG_Y || usage == HUG_RY)
+	    axis = 1;
+	  else if (usage == HUG_Z || usage == HUG_RZ)
+	    axis = 2;
+	  else
+	    interesting_hid = FALSE;
+
+	  if (interesting_hid)
+	    {
+	      joy_data[i].axis[axis].min = h.logical_minimum;
+	      joy_data[i].axis[axis].max = h.logical_maximum;
+
+	      /* Set the theoretical center. This will be used in case
+	       * the heuristic below fails. */
+	      joy_data[i].axis[axis].center =
+		(h.logical_minimum + h.logical_maximum) / 2;
+
+	      if (joy_data[i].num_axis < (axis + 1))
+		joy_data[i].num_axis = axis + 1;
+	    }
+	}
+      else if (page == HUP_BUTTON)
+	{
+	  interesting_hid = (usage > 0) && (usage <= JOY_BUTTONS);
+
+	  if (interesting_hid && usage > joy_data[i].num_buttons)
+	    joy_data[i].num_buttons = usage;
+	}
+
+      if (interesting_hid)
+	{
+	  h.next = priv_joy_data[i].hids;
+	  priv_joy_data[i].hids = malloc(sizeof *(priv_joy_data[i].hids));
+	  if (priv_joy_data[i].hids == NULL)
+	    {
+	      fprintf(stderr_file, "error: Not enough memory for joystick. "
+		      "Your joystick may fail to work correctly.\n");
+	      break;
+	    }
+	  *(priv_joy_data[i].hids) = h;
+	}
+    }
+  hid_end_parse(d);
+
+  if (priv_joy_data[i].hids != NULL)
+    {
+      /* We'll approximate the center with the current joystick value if
+       * that can be read (some HID devices returns no data if the state
+       * has not changed since the last time it was read.) */
+      if (joy_read(joy_data[i].fd, i))
+	{
+	  joy_data[i].axis[0].center = joy_data[i].axis[0].val;
+	  joy_data[i].axis[1].center = joy_data[i].axis[1].val;
+	  joy_data[i].axis[2].center = joy_data[i].axis[2].val;
+	}
+      else
+	{
+	  /* Assume that the joystick is positioned in the center.
+	   * This is needed, or else the system will think that the
+	   * joystick is in position left/up (or something) until it
+	   * is moved the first time. */
+	  joy_data[i].axis[0].val = joy_data[i].axis[0].center;
+	  joy_data[i].axis[1].val = joy_data[i].axis[1].center;
+	  joy_data[i].axis[2].val = joy_data[i].axis[2].center;
+	}
+
+      /* Approximate min/max values. Observe that we cannot use the
+       * max/min values that the HID reports, since that is theoretical
+       * values that may be wrong for analogs joystics (especially if
+       * you have a joystick -> USB adaptor.) We cannot use greater delta
+       * values than +/- 1, since it is OK for a gamepad (or my USB TAC 2)
+       * to reports directions as center +/- 1. */
+      joy_data[i].axis[0].min = joy_data[i].axis[0].center - 1;
+      joy_data[i].axis[1].min = joy_data[i].axis[1].center - 1;
+      joy_data[i].axis[2].min = joy_data[i].axis[2].center - 1;
+      joy_data[i].axis[0].max = joy_data[i].axis[0].center + 1;
+      joy_data[i].axis[1].max = joy_data[i].axis[1].center + 1;
+      joy_data[i].axis[2].max = joy_data[i].axis[2].center + 1;
+    }
+
+  return (priv_joy_data[i].hids != NULL);
+}
+
+
+
+static void joy_usb_poll(void)
+{
+  int i;
+
+  for (i = 0; i < JOY; i++)
+    {
+      if (joy_data[i].fd >= 0)
+	joy_read(joy_data[i].fd, i);
+    }
+
+   /* Evaluate joystick movements. */
+   joy_evaluate_moves ();
+}
+
+
+
+static int joy_read(int fd, int i)
+{
+  int len, axis, usage, page, d;
+  struct hid_item *h;
+
+  len = read(fd, priv_joy_data[i].data_buf, priv_joy_data[i].dlen);
+  if (len != priv_joy_data[i].dlen)
+    return FALSE;
+
+  for (h = priv_joy_data[i].hids; h; h = h->next)
+    {
+      d = hid_get_data(priv_joy_data[i].data_buf + priv_joy_data[i].offset, h);
+
+      page = HID_PAGE(h->usage);
+      usage = HID_USAGE(h->usage);
+
+      if (page == HUP_GENERIC_DESKTOP)
+	{
+	  if (usage == HUG_X || usage == HUG_RX)
+	    axis = 0;
+	  else if (usage == HUG_Y || usage == HUG_RY)
+	    axis = 1;
+	  else
+	    axis = 2;
+
+	  joy_data[i].axis[axis].val = d;
+	}
+      else if (page == HUP_BUTTON)
+	{
+	  joy_data[i].buttons[usage - 1] = (d == h->logical_maximum);
+	}
+    }
+
+  return TRUE;
+}
+#endif
diff --git a/src/unix/joystick-drivers/joy_x11.c b/src/unix/joystick-drivers/joy_x11.c
new file mode 100644
index 0000000..7b8bf6e
--- /dev/null
+++ b/src/unix/joystick-drivers/joy_x11.c
@@ -0,0 +1,248 @@
+/*
+ * X-Mame x11 joystick code
+ *
+ */
+#include "xmame.h"
+#include "devices.h"
+
+#ifdef X11_JOYSTICK
+static char *x11joyname = NULL;
+#endif
+
+struct rc_option joy_x11_opts[] = {
+   /* name, shortname, type, dest, deflt, min, max, func, help */
+#ifdef X11_JOYSTICK
+   { "x11joyname",	NULL,			rc_string,	&x11joyname,
+     X11_JOYNAME,	0,			0,		NULL,
+     "Name of X-based joystick device (if compiled in)" },
+#endif
+   { NULL,		NULL,			rc_end,		NULL,
+     NULL,		0,			0,		NULL,
+     NULL }
+};
+
+#ifdef X11_JOYSTICK
+#include "../video-drivers/x11.h"
+#if !defined x11 && !defined xgl && !defined xfx
+#error "x11 joystick support only works with an x11 display method, duh !"
+#endif
+
+/* standard X input extensions based joystick */
+#include <X11/extensions/XI.h>
+#include <X11/extensions/XInput.h>
+/* event types returned by XSelecExtensionEvent() */
+static XDevice *xdevice;
+void joy_x11_poll(void);
+
+/* FIXME shouldn't X support more then 1 joystick ? */
+
+void process_x11_joy_event(XEvent *event) {
+#ifdef USE_X11_JOYEVENTS
+/* does not run yet, don't know why :-( */
+    int i;
+    /* remember that event types are not harcoded: we evaluated it in XOpenDevice() */
+    /* hack: we'll suppose that:
+	 first_axis is allways equals 0. 
+	 device_id is joystic's id
+       in a real program, should be checked... 
+     */
+    if ( (event->type==devicebuttonpress) || (event->type==devicebuttonrelease) ) {
+	XDeviceButtonEvent *dbe=(XDeviceButtonEvent *) event;	
+	/* evaluate button state */
+	for (i=0; i<joy_data[0].num_buttons; i++)
+	   joy_data[0].buttons[i] = dbe->device_state & (0x01 << i);
+	for(i=0;i<joy_data[0].num_axis;i++)
+		joy_data[0].axis[i].val = joy_data[0].axis[i].center +
+		   dbe->axis_data[i];
+    }
+    if ( (event->type==devicemotionnotify) ) {
+	XDeviceMotionEvent *dme=(XDeviceMotionEvent *) event;	
+	/* evaluate button state */
+	for (i=0; i<joy_data[0].num_buttons; i++)
+	   joy_data[0].buttons[i] = dme->device_state & (0x01 << i);
+	for(i=0;i<joy_data[0].num_axis;i++)
+		joy_data[0].axis[i].val = joy_data[0].axis[i].center +
+		   dme->axis_data[i];
+    }
+#endif
+}
+
+void joy_x11_init(void)
+{
+	int 		i,j,k;
+	int 		result;
+	XDeviceInfoPtr 	list,slist;
+	XAnyClassPtr 	any;
+	XButtonInfoPtr 	binfo;
+	XValuatorInfoPtr vinfo;
+	XInputClassInfo *classptr;
+	XEventClass 	xeventlist[8];
+	int 		xeventcount;
+	
+	joy_poll_func = joy_x11_poll;
+	
+	/* query server for input extensions */
+	result =XQueryExtension(display,"XInputExtension",&i,&j,&k);
+	if(!result) {
+	    fprintf(stderr_file,"Your server doesn't support XInput Extensions\n");
+	    fprintf(stderr_file,"X11 Joystick disabled\n");
+	    joytype=JOY_NONE;
+	    return;
+	}
+	/* now get input device list and locate desired device */
+	list = XListInputDevices(display,&result);
+	if (!list ) {
+	    fprintf(stderr_file,"No extended input devices found !!\n");
+	    fprintf(stderr_file,"X11 Joystick disabled\n");
+	    joytype=JOY_NONE;
+	    return;
+	}
+	slist=list;
+	for(i=j=0;i<result;i++,list++) 
+		if ( ! strcmp(x11joyname,list->name)  ) { j=1; break; }
+	if (!j) {
+	    fprintf(stderr_file,"Cannot locate device \"%s\" in available devices\n",x11joyname);
+	    fprintf(stderr_file,"X11 Joystick disabled\n");
+	    joytype=JOY_NONE;
+	    XFreeDeviceList(slist);
+	    return;
+	}
+	/* test for correct device ( search at least two buttons and two axis */
+	any = (XAnyClassPtr)(list->inputclassinfo);
+	result=0;
+	for(j=0;j<list->num_classes;j++) {
+	    switch(any->class) {
+		case ButtonClass:
+			binfo=(XButtonInfoPtr) any;
+			if ((joy_data[0].num_buttons=binfo->num_buttons)>=2) result |= 0x01;
+			fprintf(stderr_file,"%s: %d buttons\n",x11joyname,joy_data[0].num_buttons);
+			if (joy_data[0].num_buttons > JOY_BUTTONS) joy_data[0].num_buttons = JOY_BUTTONS;
+			break;
+		case ValuatorClass:
+			vinfo=(XValuatorInfoPtr) any;
+			if ((joy_data[0].num_axis=vinfo->num_axes)>=2) result |= 0x02;
+			fprintf(stderr_file,"%s: %d axes\n",x11joyname,joy_data[0].num_axis);
+			if (joy_data[0].num_axis > JOY_AXIS) joy_data[0].num_axis = JOY_AXIS;
+			for (i=0; i<joy_data[0].num_axis; i++)
+			{
+			   joy_data[0].axis[i].val = joy_data[0].axis[i].center =
+			      (vinfo->axes[i].max_value - vinfo->axes[i].min_value) / 2;
+			   joy_data[0].axis[i].min = vinfo->axes[i].min_value;
+			   joy_data[0].axis[i].max = vinfo->axes[i].max_value;
+			}
+			break;
+		case KeyClass: /* no sense to use a extended key device */
+			fprintf(stderr_file,"%s: Ingnoring KeyClass info\n",x11joyname);
+		default: break;  /* unnknown class: ignore */
+	    }
+	    any = (XAnyClassPtr) ((char *) any+any->length);
+	}
+	if (result != 0x03 ) {
+	    fprintf(stderr_file,"Your selected X11 device \"%s\"doesn't match X-Mame/X-Mess requirements\n",x11joyname);
+	    fprintf(stderr_file,"X11 Joystick disabled\n");
+	    joytype=JOY_NONE;
+	    XFreeDeviceList(slist);
+	    return;
+	}
+	/* once located, try to open */	
+	if ( ! (xdevice=XOpenDevice(display,list->id) ) ) {
+	    fprintf(stderr_file,"XDeviceOpen error\n");
+	    joytype=JOY_NONE;
+	    XFreeDeviceList(slist);
+	    return;
+	} 
+	/* buscamos los eventos asociados que necesitamos */
+	/* realmente el bucle for y la sentencia switch no son necesarias, pues
+	   en XInput.h se buscan automaticamente los elementos de cada dato, pero
+	   lo pongo de ejemplo para si en el futuro se quieren chequear la existencia
+           de una determinada clase antes de pedir eventos. Nosotros sabemos a 
+	   priori que no deberia fallar....
+	*/
+	xeventcount=0;
+	for (i=0,classptr=xdevice->classes;i<xdevice->num_classes;i++,classptr++ ) {
+	    switch(classptr->input_class) {
+		case KeyClass: break;
+		case ButtonClass:
+	    		DeviceButtonPress(xdevice,devicebuttonpress,xeventlist[xeventcount]);
+			if (devicebuttonpress) xeventcount++;
+	    		DeviceButtonRelease(xdevice,devicebuttonrelease,xeventlist[xeventcount]);
+			if (devicebuttonrelease) xeventcount++;
+			break;
+		case ValuatorClass:
+	    		DeviceMotionNotify(xdevice,devicemotionnotify,xeventlist[xeventcount]);
+			if (devicemotionnotify) xeventcount++;
+	    		DeviceButtonMotion(xdevice,devicebuttonmotion,xeventlist[xeventcount]);
+			if (devicebuttonmotion) xeventcount++;
+			break;
+		case FocusClass: break;
+		case ProximityClass: break;
+		case OtherClass: break;
+		default: break;
+	    }
+	}
+#if 0
+	/* 
+	NOTE: don't know why but these two items don't work in my linux
+	XInputExtension Joystick module. still working on it ...
+	*/
+
+	/* force relative motion report */
+	XSetDeviceMode(display,xdevice,Relative);
+	/* set starting point of joystick (to force joy to be centered) */
+	for(i=0; i<joy_data[0].num_axis; i++)
+	   XSetDeviceValuators(display,xdevice,&(joy_data[0].axis[i]),i,1);
+	
+#endif
+#ifdef USE_X11_JOYEVENTS
+	/* not sure why don't recognize all events type. still working... */
+	XSelectExtensionEvent(display,window,xeventlist,xeventcount);
+	fprintf(stderr_file,"X11PointerDevice: Using X-Window Events\n");
+#else
+	fprintf(stderr_file,"X11PointerDevice: Using Demand QueryState\n");
+#endif
+	fprintf(stderr_file,"Found and installed X11 pointer device \"%s\"\n",x11joyname);
+	/* and finaly free requested device list */
+	XFreeDeviceList(slist);
+}
+
+/* 
+ * Routine to manage joystick via X-Windows Input Extensions
+ * should work in any X-Server that supports them
+ */
+void joy_x11_poll(void)
+{
+#ifndef USE_X11_JOYEVENTS
+	/* perform a roudtrip query to joy device to ask state */
+	XDeviceState    *xstate;
+	XInputClass     *any;
+	XValuatorState  *vinfo;
+	XButtonState    *binfo;
+	int i,j;
+	xstate = XQueryDeviceState(display,xdevice);
+	any = (XInputClass *)(xstate->data);
+	for(j=0;j<xstate->num_classes;j++) {
+	    switch(any->class) {
+		case ButtonClass:
+			binfo=(XButtonState *) any;
+			for (i=0; i<joy_data[0].num_buttons; i++)
+			{
+			   joy_data[0].buttons[i] = (int)binfo->buttons[0] & (0x01 << i);
+			}
+			break;
+		case ValuatorClass:
+			vinfo=(XValuatorState *) any;
+			for (i=0; i<joy_data[0].num_axis; i++)
+			   joy_data[0].axis[i].val =
+			      joy_data[0].axis[i].center + vinfo->valuators[i];
+			break;
+		case KeyClass: /* no sense to use a extended key device */
+		default: break;  /* unknown class: ignore */
+	    }
+	    any = (XInputClass *) ((char *) any+any->length);
+	}
+	XFreeDeviceState(xstate);
+#endif 
+	joy_evaluate_moves();
+}
+
+#endif /* ifdef X11_JOYSTICK */
diff --git a/src/unix/joystick-drivers/pad.h b/src/unix/joystick-drivers/pad.h
new file mode 100644
index 0000000..c646a84
--- /dev/null
+++ b/src/unix/joystick-drivers/pad.h
@@ -0,0 +1,78 @@
+/*
+ * TOWNS PAD
+ *    By S.Nomura
+ */
+#ifndef TRUE
+# define TRUE (1)
+# define FALSE (0)
+#endif
+
+#define PAD_DEV_MASK    0x07
+#define PAD_MODE_MASK   0x38
+#define PAD_MODE_SHIFT  3
+
+  /* modes */
+#define PAD_NORMAL      0
+#define PAD_MARTY       1
+#define PAD_6BUTTON     2
+
+struct pad_event {
+  unsigned long buttons;
+  unsigned long stamp;
+};
+
+#define PAD_FWD    0x0001
+#define PAD_BACK   0x0002
+#define PAD_LEFT   0x0004
+#define PAD_RIGHT  0x0008
+#define PAD_RUN    0x0010
+#define PAD_SEL    0x0020
+#define PAD_ZOOM   0x0040
+#define PAD_A	   0x0100
+#define PAD_B	   0x0200
+#define PAD_C	   0x0400
+#define PAD_X	   0x0800
+#define PAD_Y	   0x1000
+#define PAD_Z	   0x2000
+
+#define PADIOCSETPARAM  0x5001
+
+#define PAD_QUE_SIZE 50
+
+struct pad_status {
+  int active;
+  int port;
+  int trig, com, mode;
+  unsigned long button, last_button;
+  struct inode *inode;
+
+  /* Queue */
+  struct wait_queue *proc;
+  struct pad_event ev[PAD_QUE_SIZE];
+  struct pad_event *put, *get, *limit;
+  int count, ovf;
+};
+
+/* I/O ports */
+#define PAD_CTRL_PORT  0x04d6
+#define PAD1_PORT      0x04d0
+#define PAD2_PORT      0x04d2
+
+ /* control */
+#define PAD1_TRIG      0x03
+#define PAD1_COM       0x10
+#define PAD2_TRIG      0x0c
+#define PAD2_COM       0x20
+
+ /* value */
+#define _PAD_FWD       0x01
+#define _PAD_BACK      0x02
+#define _PAD_LEFT      0x04
+#define _PAD_RIGHT     0x08
+#define _PAD_A         0x10
+#define _PAD_B         0x20
+#define _PAD_COM       0x40
+#define _PAD_C         0x08
+#define _PAD_X         0x04
+#define _PAD_Y         0x02
+#define _PAD_Z         0x01
diff --git a/src/unix/keyboard.c b/src/unix/keyboard.c
new file mode 100644
index 0000000..0af4f17
--- /dev/null
+++ b/src/unix/keyboard.c
@@ -0,0 +1,245 @@
+/*
+ * X-Mame keyboard specifics code
+ *
+ */
+#define __KEYBOARD_C_
+
+/*
+ * Include files.
+ */
+#include "xmame.h"
+#include "driver.h"
+#include "keyboard.h"
+#include "devices.h"
+#include "sysdep/fifo.h"
+#include "usrintrf.h"
+ 
+#if defined svgalib || defined svgafx
+#include <vgakeyboard.h>
+#define sysdep_update_keyboard keyboard_update
+#endif
+
+
+/* we use standard pc scancodes these have a one-on-one mapping for
+   svgalib, for other targets we need a lookup table anyway */
+struct KeyboardInfo keylist[] =
+{
+	{ "A",		KEY_A,		KEYCODE_A },
+	{ "B",		KEY_B,		KEYCODE_B },
+	{ "C",		KEY_C,		KEYCODE_C },
+	{ "D",		KEY_D,		KEYCODE_D },
+	{ "E",		KEY_E,		KEYCODE_E },
+	{ "F",		KEY_F,		KEYCODE_F },
+	{ "G",		KEY_G,		KEYCODE_G },
+	{ "H",		KEY_H,		KEYCODE_H },
+	{ "I",		KEY_I,		KEYCODE_I },
+	{ "J",		KEY_J,		KEYCODE_J },
+	{ "K",		KEY_K,		KEYCODE_K },
+	{ "L",		KEY_L,		KEYCODE_L },
+	{ "M",		KEY_M,		KEYCODE_M },
+	{ "N",		KEY_N,		KEYCODE_N },
+	{ "O",		KEY_O,		KEYCODE_O },
+	{ "P",		KEY_P,		KEYCODE_P },
+	{ "Q",		KEY_Q,		KEYCODE_Q },
+	{ "R",		KEY_R,		KEYCODE_R },
+	{ "S",		KEY_S,		KEYCODE_S },
+	{ "T",		KEY_T,		KEYCODE_T },
+	{ "U",		KEY_U,		KEYCODE_U },
+	{ "V",		KEY_V,		KEYCODE_V },
+	{ "W",		KEY_W,		KEYCODE_W },
+	{ "X",		KEY_X,		KEYCODE_X },
+	{ "Y",		KEY_Y,		KEYCODE_Y },
+	{ "Z",		KEY_Z,		KEYCODE_Z },
+	{ "0",		KEY_0,		KEYCODE_0 },
+	{ "1",		KEY_1,		KEYCODE_1 },
+	{ "2",		KEY_2,		KEYCODE_2 },
+	{ "3",		KEY_3,		KEYCODE_3 },
+	{ "4",		KEY_4,		KEYCODE_4 },
+	{ "5",		KEY_5,		KEYCODE_5 },
+	{ "6",		KEY_6,		KEYCODE_6 },
+	{ "7",		KEY_7,		KEYCODE_7 },
+	{ "8",		KEY_8,		KEYCODE_8 },
+	{ "9",		KEY_9,		KEYCODE_9 },
+	{ "0 PAD",	KEY_0_PAD,	KEYCODE_0_PAD },
+	{ "1 PAD",	KEY_1_PAD,	KEYCODE_1_PAD },
+	{ "2 PAD",	KEY_2_PAD,	KEYCODE_2_PAD },
+	{ "3 PAD",	KEY_3_PAD,	KEYCODE_3_PAD },
+	{ "4 PAD",	KEY_4_PAD,	KEYCODE_4_PAD },
+	{ "5 PAD",	KEY_5_PAD,	KEYCODE_5_PAD },
+	{ "6 PAD",	KEY_6_PAD,	KEYCODE_6_PAD },
+	{ "7 PAD",	KEY_7_PAD,	KEYCODE_7_PAD },
+	{ "8 PAD",	KEY_8_PAD,	KEYCODE_8_PAD },
+	{ "9 PAD",	KEY_9_PAD,	KEYCODE_9_PAD },
+	{ "F1",		KEY_F1,		KEYCODE_F1 },
+	{ "F2",		KEY_F2,		KEYCODE_F2 },
+	{ "F3",		KEY_F3,		KEYCODE_F3 },
+	{ "F4",		KEY_F4,		KEYCODE_F4 },
+	{ "F5",		KEY_F5,		KEYCODE_F5 },
+	{ "F6",		KEY_F6,		KEYCODE_F6 },
+	{ "F7",		KEY_F7,		KEYCODE_F7 },
+	{ "F8",		KEY_F8,		KEYCODE_F8 },
+	{ "F9",		KEY_F9,		KEYCODE_F9 },
+	{ "F10",	KEY_F10,	KEYCODE_F10 },
+	{ "F11",	KEY_F11,	KEYCODE_F11 },
+	{ "F12",	KEY_F12,	KEYCODE_F12 },
+	{ "ESC",	KEY_ESC,	KEYCODE_ESC },
+	{ "~",		KEY_TILDE,	KEYCODE_TILDE },
+	{ "-",		KEY_MINUS,	KEYCODE_MINUS },
+	{ "=",		KEY_EQUALS,	KEYCODE_EQUALS },
+	{ "BKSPACE",	KEY_BACKSPACE,	KEYCODE_BACKSPACE },
+	{ "TAB",	KEY_TAB,	KEYCODE_TAB },
+	{ "[",		KEY_OPENBRACE,	KEYCODE_OPENBRACE },
+	{ "]",		KEY_CLOSEBRACE,	KEYCODE_CLOSEBRACE },
+	{ "ENTER",	KEY_ENTER,	KEYCODE_ENTER },
+	{ ";",		KEY_COLON,	KEYCODE_COLON },
+	{ ":",		KEY_QUOTE,	KEYCODE_QUOTE },
+	{ "\\",		KEY_BACKSLASH,	KEYCODE_BACKSLASH },
+	{ "<",		KEY_BACKSLASH2,	KEYCODE_BACKSLASH2 },
+	{ ",",		KEY_COMMA,	KEYCODE_COMMA },
+	{ ".",		KEY_STOP,	KEYCODE_STOP },
+	{ "/",		KEY_SLASH,	KEYCODE_SLASH },
+	{ "SPACE",	KEY_SPACE,	KEYCODE_SPACE },
+	{ "INS",	KEY_INSERT,	KEYCODE_INSERT },
+	{ "DEL",	KEY_DEL,	KEYCODE_DEL },
+	{ "HOME",	KEY_HOME,	KEYCODE_HOME },
+	{ "END",	KEY_END,	KEYCODE_END },
+	{ "PGUP",	KEY_PGUP,	KEYCODE_PGUP },
+	{ "PGDN",	KEY_PGDN,	KEYCODE_PGDN },
+	{ "LEFT",	KEY_LEFT,	KEYCODE_LEFT },
+	{ "RIGHT",	KEY_RIGHT,	KEYCODE_RIGHT },
+	{ "UP",		KEY_UP,		KEYCODE_UP },
+	{ "DOWN",	KEY_DOWN,	KEYCODE_DOWN },
+	{ "/ PAD",	KEY_SLASH_PAD,	KEYCODE_SLASH_PAD },
+	{ "* PAD",	KEY_ASTERISK,	KEYCODE_ASTERISK },
+	{ "- PAD",	KEY_MINUS_PAD,	KEYCODE_MINUS_PAD },
+	{ "+ PAD",	KEY_PLUS_PAD,	KEYCODE_PLUS_PAD },
+	{ ". PAD",	KEY_DEL_PAD,	KEYCODE_DEL_PAD },
+	{ "ENTER PAD",	KEY_ENTER_PAD,	KEYCODE_ENTER_PAD },
+	{ "PRTSCR",	KEY_PRTSCR,	KEYCODE_PRTSCR },
+	{ "PAUSE",	KEY_PAUSE,	KEYCODE_PAUSE },
+	{ "PAUSE",	KEY_PAUSE_ALT,	KEYCODE_PAUSE },
+	{ "LSHIFT",	KEY_LSHIFT,	KEYCODE_LSHIFT },
+	{ "RSHIFT",	KEY_RSHIFT,	KEYCODE_RSHIFT },
+	{ "LCTRL",	KEY_LCONTROL,	KEYCODE_LCONTROL },
+	{ "RCTRL",	KEY_RCONTROL,	KEYCODE_RCONTROL },
+	{ "ALT",	KEY_ALT,	KEYCODE_LALT },
+	{ "ALTGR",	KEY_ALTGR,	KEYCODE_RALT },
+	{ "LWIN",	KEY_LWIN,	KEYCODE_OTHER },
+	{ "RWIN",	KEY_RWIN,	KEYCODE_OTHER },
+	{ "MENU",	KEY_MENU,	KEYCODE_OTHER },
+	{ "SCRLOCK",	KEY_SCRLOCK,	KEYCODE_SCRLOCK },
+	{ "NUMLOCK",	KEY_NUMLOCK,	KEYCODE_NUMLOCK },
+	{ "CAPSLOCK",	KEY_CAPSLOCK,	KEYCODE_CAPSLOCK },
+	{ 0, 0, 0 }	/* end of table */
+};
+
+struct kbd_fifo_struct;
+static struct kbd_fifo_struct *kbd_fifo = NULL;
+static char key[KEY_MAX];
+
+UINT8 trying_to_quit;
+
+/* private methods */
+FIFO(INLINE, kbd, struct xmame_keyboard_event)
+
+/* public methods (in keyboard.h / osdepend.h) */
+int xmame_keyboard_init(void)
+{
+   memset(key, 0, KEY_MAX);
+
+   kbd_fifo = kbd_fifo_create(256);
+   if(!kbd_fifo)
+      return -1;
+   
+   return 0;
+}
+
+void xmame_keyboard_exit()
+{
+   if(kbd_fifo)
+      kbd_fifo_destroy(kbd_fifo);
+}
+
+void xmame_keyboard_register_event(struct xmame_keyboard_event *event)
+{
+   /* register the event in our event fifo */
+   kbd_fifo_put(kbd_fifo, *event);
+   
+   /* and update the key array */
+   key[event->scancode] = event->press;
+}
+
+void xmame_keyboard_clear(void)
+{
+   kbd_fifo_empty(kbd_fifo);
+   memset(key, 0, KEY_MAX);
+}
+
+/* return a list of all available keys */
+const struct KeyboardInfo *osd_get_key_list(void)
+{
+   return keylist;
+}
+
+#ifndef MESS
+#ifndef TINY_COMPILE
+#ifndef CPSMAME
+extern struct GameDriver driver_neogeo;
+#endif
+#endif
+#endif
+
+int osd_is_key_pressed(int keycode)
+{
+   /* blames to the dos-people who want to check key states before
+      the display (and under X thus the keyboard) is initialised */
+   if (!kbd_fifo)
+      return 0;
+   
+   if (keycode >= KEY_MAX)
+      return 0;
+
+   /* special case: if we're trying to quit, fake up/down/up/down */
+   if (keycode == KEY_ESC && trying_to_quit)
+   {
+      static int dummy_state = 1;
+      return dummy_state ^= 1;
+   }
+
+   sysdep_update_keyboard();
+	
+   return key[keycode];
+}
+
+int osd_readkey_unicode(int flush)
+{
+   struct xmame_keyboard_event event;
+   
+   /* blames to the dos-people who want to check key states before
+      the display (and under X thus the keyboard) is initialised */
+   if (!kbd_fifo)
+      return 0;
+   
+   if (flush)
+      xmame_keyboard_clear();
+   
+   sysdep_update_keyboard();
+   
+   if (!kbd_fifo_get(kbd_fifo, &event) && event.press)
+      return event.unicode;
+   else
+      return 0;
+}
+
+extern int ui_active;
+
+int osd_keyboard_disabled()
+{
+	return 0;
+}
+
+int osd_trying_to_quit()
+{
+	return 0;
+}
+
diff --git a/src/unix/keyboard.h b/src/unix/keyboard.h
new file mode 100644
index 0000000..aee40e9
--- /dev/null
+++ b/src/unix/keyboard.h
@@ -0,0 +1,149 @@
+#ifndef __KEYBOARD_H
+#define __KEYBOARD_H
+
+struct xmame_keyboard_event {
+   unsigned char press;
+   unsigned char scancode;
+   unsigned short unicode;
+};
+
+int xmame_keyboard_init(void);
+void xmame_keyboard_exit(void);
+void xmame_keyboard_register_event(struct xmame_keyboard_event *event);
+void xmame_keyboard_clear(void);
+
+/* Defines for the standard pc-scancodes which xmame uses as keysyms.
+   The names of the defines have been kept the same as used in
+   src/msdos/input.c for easy cut and paste */
+
+#define KEY_NONE		0
+
+#define KEY_ESC			1
+
+#define KEY_1			2
+#define KEY_2			3
+#define KEY_3			4
+#define KEY_4			5
+#define KEY_5			6
+#define KEY_6			7
+#define KEY_7			8
+#define KEY_8			9
+#define KEY_9			10
+#define KEY_0			11
+
+#define KEY_MINUS		12
+#define KEY_EQUALS		13
+
+#define KEY_BACKSPACE		14
+#define KEY_TAB			15
+
+#define KEY_Q			16
+#define KEY_W			17
+#define KEY_E			18
+#define KEY_R			19
+#define KEY_T			20
+#define KEY_Y			21
+#define KEY_U			22
+#define KEY_I			23
+#define KEY_O			24
+#define KEY_P			25
+#define KEY_OPENBRACE		26
+#define KEY_CLOSEBRACE		27
+
+#define KEY_ENTER		28
+
+#define KEY_LCONTROL		29
+
+#define KEY_A			30
+#define KEY_S			31
+#define KEY_D			32
+#define KEY_F			33
+#define KEY_G			34
+#define KEY_H			35
+#define KEY_J			36
+#define KEY_K			37
+#define KEY_L			38
+#define KEY_COLON		39
+#define KEY_QUOTE		40
+#define KEY_TILDE		41
+
+#define KEY_LSHIFT		42
+#define KEY_BACKSLASH		43
+
+#define KEY_Z			44
+#define KEY_X			45
+#define KEY_C			46
+#define KEY_V			47
+#define KEY_B			48
+#define KEY_N			49
+#define KEY_M			50
+#define KEY_COMMA		51
+#define KEY_STOP		52
+#define KEY_SLASH		53
+
+#define KEY_RSHIFT		54
+#define KEY_ASTERISK		55
+
+#define KEY_ALT			56
+#define KEY_SPACE		57
+#define KEY_CAPSLOCK		58
+
+#define KEY_F1			59
+#define KEY_F2			60
+#define KEY_F3			61
+#define KEY_F4			62
+#define KEY_F5			63
+#define KEY_F6			64
+#define KEY_F7			65
+#define KEY_F8			66
+#define KEY_F9			67
+#define KEY_F10			68
+
+#define KEY_NUMLOCK		69
+#define KEY_SCRLOCK		70
+
+#define KEY_7_PAD		71
+#define KEY_8_PAD		72
+#define KEY_9_PAD		73
+#define KEY_MINUS_PAD		74
+#define KEY_4_PAD		75
+#define KEY_5_PAD		76
+#define KEY_6_PAD		77
+#define KEY_PLUS_PAD		78
+#define KEY_1_PAD		79
+#define KEY_2_PAD		80
+#define KEY_3_PAD		81
+#define KEY_0_PAD		82
+#define KEY_DEL_PAD		83
+
+#define KEY_BACKSLASH2		86
+
+#define KEY_F11			87
+#define KEY_F12			88
+
+#define KEY_ENTER_PAD		96
+#define KEY_RCONTROL		97
+#define KEY_SLASH_PAD		98
+#define KEY_PRTSCR		99
+#define KEY_ALTGR		100
+#define KEY_PAUSE		101	/* Beware: is 119     */
+#define KEY_PAUSE_ALT		119	/* on some keyboards! */
+
+#define KEY_HOME		102
+#define KEY_UP			103
+#define KEY_PGUP		104
+#define KEY_LEFT		105
+#define KEY_RIGHT		106
+#define KEY_END			107
+#define KEY_DOWN		108
+#define KEY_PGDN		109
+#define KEY_INSERT		110
+#define KEY_DEL			111
+
+#define KEY_LWIN		125
+#define KEY_RWIN		126
+#define KEY_MENU		127
+
+#define KEY_MAX			128
+
+#endif
diff --git a/src/unix/main.c b/src/unix/main.c
new file mode 100644
index 0000000..f3fbbee
--- /dev/null
+++ b/src/unix/main.c
@@ -0,0 +1,89 @@
+/*
+ * X-mame main-routine
+ */
+
+#define __MAIN_C_
+#include "xmame.h"
+
+#ifdef __QNXNTO__
+#include <sys/mman.h>
+#endif
+
+/* From video.c. */
+void osd_video_initpre();
+
+/* put here anything you need to do when the program is started. Return 0 if */
+/* initialization was successful, nonzero otherwise. */
+int osd_init(void)
+{
+	/* now invoice system-dependent initialization */
+#ifdef XMAME_NET
+	if (osd_net_init()      !=OSD_OK) return OSD_NOT_OK;
+#endif	
+	if (osd_input_initpre() !=OSD_OK) return OSD_NOT_OK;
+
+	return OSD_OK;
+}
+
+/*
+ * Cleanup routines to be executed when the program is terminated.
+ */
+void osd_exit(void)
+{
+#ifdef XMAME_NET
+	osd_net_close();
+#endif
+	osd_input_close();
+}
+
+
+int main(int argc, char **argv)
+{
+	int res, res2;
+
+#ifdef __QNXNTO__
+	printf("info: Trying to enable swapfile.... ");
+	munlockall();
+	printf("Success!\n");
+#endif
+
+	/* some display methods need to do some stuff with root rights */
+	res2 = sysdep_init();
+
+	/* to be absolutely safe force giving up root rights here in case
+	   a display method doesn't */
+	if (setuid(getuid()))
+	{
+		perror("setuid");
+		sysdep_close();
+		return OSD_NOT_OK;
+	}
+
+	/* Set the title, now auto build from defines from the makefile */
+	sprintf(title,"%s (%s) version %s", NAME, DISPLAY_METHOD,
+			build_version);
+
+	/* parse configuration file and environment */
+	if ((res = config_init(argc, argv)) != 1234 || res2 == OSD_NOT_OK)
+		goto leave;
+
+	/* Check the colordepth we're requesting */
+	if (!options.color_depth && !sysdep_display_16bpp_capable())
+		options.color_depth = 8;
+
+	/* 
+	 * Initialize whatever is needed before the display is actually 
+	 * opened, e.g., artwork setup.
+	 */
+	osd_video_initpre();
+
+	/* go for it */
+	res = run_game (game_index);
+
+leave:
+	sysdep_close();
+	/* should be done last since this also closes stdout and stderr */
+	config_exit();
+
+	return res;
+}
diff --git a/src/unix/mode.c b/src/unix/mode.c
new file mode 100644
index 0000000..39a5816
--- /dev/null
+++ b/src/unix/mode.c
@@ -0,0 +1,154 @@
+#include "xmame.h"
+#include "driver.h"
+
+static int mode_disable(struct rc_option *option, const char *s, int priority);
+
+struct rc_option mode_opts[] = {
+   /* name, shortname, type, dest, deflt, min, max, func, help */
+   { "Video Mode Selection Related", NULL,	rc_seperator,	NULL,
+     NULL,		0,			0,		NULL,
+     NULL },
+   { "keepaspect",	"ka",			rc_bool,	&normal_use_aspect_ratio,
+     "1",		0,			0,		NULL,
+     "Try / don't try to keep the aspect ratio of a game when selecting the best videomode" },
+   { "displayaspectratio", "dar",		rc_float,	&display_aspect_ratio,
+     "1.33",		0.75,			1.33,		NULL,
+     "Set the display aspect ratio of your monitor. This is used for -keepaspect The default = 1.33 (4/3). Use 0.75 (3/4) for a portrait monitor" },
+   { "disablemode",	"dm",			rc_use_function, NULL,
+     NULL,		0,			0,		mode_disable,
+     "Don't use mode XRESxYRESxDEPTH this can be used to disable specific video modes which don't work on your system. The xDEPTH part of the string is optional. This option may be used more then once" },
+   { NULL,		NULL,			rc_end,		NULL,
+     NULL,		0,			0,		NULL,
+     NULL }
+};
+
+#define MODE_DISABLED_MAX 32
+
+static int disabled_modes_count = 0;
+
+static struct 
+{
+   int width;
+   int height;
+   int depth;
+} disabled_modes[MODE_DISABLED_MAX];
+
+static int mode_disable(struct rc_option *option, const char *s, int priority)
+{
+   if (disabled_modes_count == MODE_DISABLED_MAX)
+   {
+      /* stderr_file doesn't have a valid value yet when we're called ! */
+      fprintf(stderr, "OSD: Warning: You can't disable more then %d modes. Mode %s not disabled\n",
+          MODE_DISABLED_MAX, s);
+      return OSD_OK;
+   }
+   if (sscanf(s, "%dx%dx%d",
+       &disabled_modes[disabled_modes_count].width,
+       &disabled_modes[disabled_modes_count].height,
+       &disabled_modes[disabled_modes_count].depth) < 2)
+      return OSD_NOT_OK;
+   switch (disabled_modes[disabled_modes_count].depth)
+   {
+      case 0:
+      case 256:
+      case 65536:
+         break;
+      default:
+         /* stderr_file doesn't have a valid value yet when we're called ! */
+         fprintf(stderr, "Svgalib: Warning: No such depth: %d. Mode not disabled\n",
+            disabled_modes[disabled_modes_count].depth);
+         return OSD_NOT_OK;
+   }
+   disabled_modes_count++;
+   return OSD_OK;
+}
+
+int mode_disabled(int width, int height, int depth)
+{
+   int i;
+   for(i=0; i<disabled_modes_count; i++)
+   {
+      if (disabled_modes[i].width  == width &&
+          disabled_modes[i].height == height)
+      {
+         switch (disabled_modes[disabled_modes_count].depth)
+         {
+            case 0:
+               return TRUE;
+            case 256:
+               if(depth == 8)
+                  return TRUE;
+               break;
+            case 65536:
+               if(depth == 16)
+                  return TRUE;
+               break;
+         }
+      }
+   }
+   return FALSE;
+}
+
+void mode_perfect(int *width, int *height)
+{
+   double pixel_aspect_ratio;
+   static int first_time = TRUE;
+   
+   if (use_aspect_ratio)
+   {
+      /* first of all calculate the pixel aspect_ratio the game has */
+      if (Machine->drv->video_attributes & VIDEO_TYPE_VECTOR)
+      {
+         pixel_aspect_ratio = 1.0;
+      }
+      else
+      {
+         pixel_aspect_ratio = (visual_width * widthscale) / 
+	   (yarbsize ? yarbsize :
+	    (visual_height * heightscale * aspect_ratio));
+      }
+      
+      /* should we maximize the used height, or the used width? */
+      if (display_aspect_ratio >= aspect_ratio)
+      {
+	*height = yarbsize ? yarbsize : (visual_height * heightscale);
+	*width  = *height * pixel_aspect_ratio * display_aspect_ratio;
+      }
+      else
+      {
+         *width  = visual_width  * widthscale;
+         *height = *width / (pixel_aspect_ratio * display_aspect_ratio);
+      }
+      if (first_time)
+      {
+         fprintf(stderr_file, "OSD: Info: Ideal mode for this game = %dx%d\n",
+            *width, *height);
+         first_time = FALSE;
+      }
+   }
+   else
+   {
+      *width  = visual_width;
+      *height = visual_height;
+   }
+}
+
+/* match a given mode to the needed width, height and aspect ratio to
+   perfectly display a game.
+   This function returns 0 for a not usable mode and 100 for the perfect mode.
+*/
+
+int mode_match(int width, int height)
+{
+   int wanted_width, wanted_height;
+   mode_perfect(&wanted_width, &wanted_height);
+       
+   /* does the game fit at all ? */
+   if(width  < (visual_width  * widthscale) ||
+      height < (yarbsize ? yarbsize : (visual_height * heightscale)))
+      return 0;
+   
+   return ( 100 *
+      ((float)wanted_width  / (abs(width -wanted_width )+wanted_width )) *
+      ((float)wanted_height / (abs(height-wanted_height)+wanted_height)));
+}
diff --git a/src/unix/nec765_dummy.c b/src/unix/nec765_dummy.c
new file mode 100644
index 0000000..29ed46c
--- /dev/null
+++ b/src/unix/nec765_dummy.c
@@ -0,0 +1,47 @@
+#include "xmame.h"
+#ifdef MESS
+
+int osd_fdc_init(void)
+{
+	/* this means init failed, since it isn't supported under unix */
+	return 0; 
+}
+
+void osd_fdc_exit(void)
+{
+}
+
+void osd_fdc_motors(int unit, int state)
+{
+}
+
+void osd_fdc_density(int unit, int density, int tracks, int spt, int eot, int secl)
+{
+}
+
+void osd_fdc_seek(int unit, int dir)
+{
+}
+
+void osd_fdc_format(int t, int h, int spt, UINT8 *fmt)
+{
+}
+
+void osd_fdc_put_sector(int unit, int side, int C, int H, int R, int N, UINT8 *buff, int ddma)
+{
+}
+
+void osd_fdc_get_sector(int unit, int side, int C, int H, int R, int N, UINT8 *buff, int ddma)
+{
+}
+
+void osd_fdc_read_id(int unit, int side, unsigned char *pBuffer)
+{
+}
+
+int osd_fdc_get_status(int unit)
+{
+	return 0;
+}
+
+#endif /* ifdef MESS */
diff --git a/src/unix/network.c b/src/unix/network.c
new file mode 100644
index 0000000..c40a9c1
--- /dev/null
+++ b/src/unix/network.c
@@ -0,0 +1,2337 @@
+#include "xmame.h"
+
+#ifdef XMAME_NET
+
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include <arpa/inet.h>
+#include <netdb.h>
+#include "driver.h"
+
+#define PROTOCOL_DEBUG 2
+
+#if PROTOCOL_DEBUG <= 1
+#define NDEBUG
+#endif
+#include <assert.h>
+
+#ifdef __GNUC__
+#if PROTOCOL_DEBUG >= 3
+#define _CHATTY_LOG(format, args...)       \
+    fprintf(stderr_file,                   \
+            "%s:%d: " format "\n",         \
+             __FUNCTION__,                 \
+             __LINE__ ,                    \
+             ## args)
+#else
+#define _CHATTY_LOG(format, args...)       \
+    fprintf(stderr_file, format "\n" , ## args)
+#endif
+#define _CHATTY_ERRNO_LOG(format, args...) \
+    _CHATTY_LOG(format " (errno %d: %s)" , ## args, errno, strerror(errno))
+#else
+/* Fix this at some point */
+#error "GCC required to compile NetMAME"
+#endif
+
+#define _PTR_SWAP(a, b) do { void *_scratch_ptr = a; a = b; b = _scratch_ptr; } while (0)
+#define _MAX(a, b) (a >= b ? a : b)
+
+enum net_role {
+    NONE,
+    MASTER,
+    SLAVE
+    /* SPECTATOR */ /* Future? */
+};
+
+static enum net_role _current_net_role = NONE;
+
+#define DEFAULT_BIND_PORT "9000"
+
+#define NET_MAX_PLAYERS 4
+
+#define REGISTRATION_TIMEOUT (30 * 1000) /* ms */
+#define REGISTRATION_RETRY_TIMEOUT (1 * 1000)
+#define SYNC_TIMEOUT (15 * 1000)
+#define SYNC_RETRY_TIMEOUT 50
+
+#define MSG_HEADER_LEN 12
+#define MAX_MSG_LEN 116 /* Includes header */
+#define MAX_BLOCK_PART_SIZE (MAX_MSG_LEN - MSG_HEADER_LEN - sizeof(UINT32))
+
+enum net_msg_type {
+    JOIN = 1,
+    REFUSE,
+    START,
+    BLOCK_INIT,
+    BLOCK_PART,
+    BLOCK_PROMPT,
+    SET_SYNC_SKIP,
+    ACK,
+    INPUT_STATE,
+    QUIT
+};
+
+enum net_block_type {
+    NVRAM_BLOCK = 1,
+    MACHINESTATE_BLOCK
+};
+
+/* Bitmap offsets for the master's START Message */
+#define CONFIG_BITMAP_PARALLELSYNC 0
+#define CONFIG_BITMAP_MACHINE_STATE_DEBUG 1
+
+#define MSG_MAGIC "XNM"
+#define MSG_MAGIC_LEN 3
+#define PROTOCOL_VERSION "N0.6"
+static char _truncated_build_version[10];
+
+struct net_msg_info {
+    enum net_msg_type msg_type;
+    UINT32 counter;
+    UINT32 sequence;
+    char msg[MAX_MSG_LEN];
+    char *data_start;
+    int data_len;
+};
+static struct net_msg_info _inbound_scratch_msg_info;
+static struct net_msg_info _outbound_scratch_msg_info;
+/* The _previous/_current outbound message pointers are for the regular
+   working of the protocol, after the handshaking is over.
+   Used by both master and slaves.  In the case of slaves these are
+   always INPUT_STATE message; in the master ACKables may be intermixed
+   as well. */
+static struct net_msg_info _saved_msg_info[_MAX(NET_MAX_PLAYERS - 1, 2)];
+static struct net_msg_info *_previous_outbound_msg_info;
+static struct net_msg_info *_current_outbound_msg_info;
+
+static unsigned short _saved_input_state[MAX_INPUT_PORTS];
+static unsigned short _inbound_input_state[MAX_INPUT_PORTS];
+static unsigned short _outbound_input_state[MAX_INPUT_PORTS];
+static unsigned short _new_input_state[MAX_INPUT_PORTS];
+
+
+struct net_block_info {
+    enum net_block_type type;
+    unsigned size;
+    char *buffer;
+    char *bitmap;
+    unsigned total_part_count;
+    unsigned remaining_part_count;
+};
+static struct net_block_info _block_info;
+#define MAX_REQUESTED_PARTS ((MAX_MSG_LEN - MSG_HEADER_LEN) / 4)
+
+static char *_nvram_backup = NULL;
+static unsigned _nvram_backup_len;
+
+static int _input_remap = 0;
+static int _parallel_sync = 0;
+static int _machine_state_debug = 0;
+
+#if PROTOCOL_DEBUG >= 1
+unsigned _reminder_count = 0;
+unsigned _inbound_duplicate_count = 0;
+#endif
+
+enum net_peer_state {
+    INACTIVE = 1,
+    UNSYNCED,
+    SYNCED
+};
+
+enum net_protocol_state {
+    REGISTRATION = 1,
+    INPUT_EXCHANGE,
+    ACKNOWLEDGEMENT,
+    BLOCK_TRANSFER,
+    QUITTING
+};
+static enum net_protocol_state _protocol_state;
+
+struct net_peer_info {
+    char name[MAX_MSG_LEN];
+    int player_number;
+    struct sockaddr_in addr;
+    enum net_peer_state state;
+    struct _net_send {
+	enum net_msg_type msg_type;
+	unsigned time_since;
+    } current_send, previous_send;
+    UINT32 last_outbound_sequence;
+    UINT32 outbound_counter;
+    UINT32 last_inbound_counter;
+    struct net_msg_info early_inbound_msg_info;
+};
+static struct net_peer_info _peer_info[NET_MAX_PLAYERS];
+
+static unsigned _original_player_count = 0, _current_player_count = 0;
+static unsigned char _player_number;
+static unsigned _unsynced_peer_count;
+static int _non_state_msg_since_sync;
+
+static int _bind_port;
+
+/* For slave only */
+static unsigned char _master_index;
+#define _master_info (_peer_info[_master_index])
+
+struct net_input_bit_id {
+    unsigned port_index;
+    unsigned short mask;
+};
+struct net_input_mapping {
+    struct net_input_bit_id source;
+    struct net_input_bit_id dest;
+};
+static struct net_input_mapping _input_map[MAX_INPUT_PORTS * sizeof(unsigned short)];
+static unsigned _input_mapping_count;
+
+/* FIXME:  Possible buffer overrun on read */
+/* stderr_file is uninitialized at the time this is called */
+static int
+_parse_hostport(const char *hostport, struct sockaddr_in *addr)
+{
+    int host_ok = FALSE, port_ok = FALSE;
+    struct hostent *hostent;
+    char *host_str = strdup(hostport);
+    char *port_str = strstr(host_str, ":");
+
+    addr->sin_family = AF_INET;
+
+    if (port_str != NULL) {
+	*port_str = 0;
+	port_str += 1;
+	if (port_str[0] != 0) {
+	    int scratch = atoi(port_str);
+	    if (scratch < 1 || scratch > 65535) {
+		fprintf(stderr,
+			"Bad host:port \"%s\":"
+			" port values below 1 or above 65535 are invalid\n",
+			hostport);
+	    } else {
+		_master_info.addr.sin_port =
+		    htons((unsigned short)atoi(port_str));
+		port_ok = TRUE;
+	    }
+	}
+    } else {
+	_master_info.addr.sin_port =
+	    htons((unsigned short)atoi(DEFAULT_BIND_PORT));
+	port_ok = TRUE;
+    }
+
+    /* Resolve master's IP address */
+    /* TODO:  Automatic handling of IPv6 address using hostent->h_addrtype ? */
+    hostent = gethostbyname(host_str);
+    if (hostent == NULL) {
+	fprintf(stderr,
+		"Can't resolve host \"%s\"\n",
+		host_str);
+    } else {
+	memcpy(&(addr->sin_addr.s_addr),
+	       hostent->h_addr,
+	       hostent->h_length);
+	host_ok = TRUE;
+    }
+    free(host_str);
+    return (port_ok && host_ok);
+}
+
+static int
+_parse_master_addr(struct rc_option *option, const char *arg, int priority)
+{
+    _current_net_role = SLAVE;
+    _master_index = 0;
+    _master_info.player_number = 1;
+    sprintf(_master_info.name, "Master: %s", arg);
+	
+    return (_parse_hostport(arg, &(_master_info.addr))) ? 0 : -1;
+}
+
+#endif
+struct rc_option network_opts[] = {
+   /* name, shortname, type, dest, deflt, min, max, func, help */
+#ifdef XMAME_NET
+   { "Network Related",       NULL,		rc_seperator,	 NULL,
+     NULL,		      0,		0,		 NULL,
+     NULL },
+   { "master",		      NULL,		rc_int,		 &_original_player_count,
+     NULL,		      2,		NET_MAX_PLAYERS, NULL,
+     "Enable master mode. Set number of players" },
+   { "slave",		      NULL,		rc_use_function, NULL,
+     NULL,		      0,		0,		 _parse_master_addr,
+     "Enable slave mode. Set master hostname[:port]" },
+   { "bind",                  NULL,	        rc_int,	         &_bind_port,
+     DEFAULT_BIND_PORT,       1,		65535,		 NULL,
+     "Specify a UDP port on which to accept messages" },
+   { "netmapkey",	      NULL,		rc_bool,	 &_input_remap,
+     "1",		      0,		0,		 NULL,
+     "Makes player 1 keys control whichever player number you're actually assigned by the master (for slave only)" },
+   { "parallelsync",          NULL,		rc_bool,	 &_parallel_sync,
+     "1",		      0,		0,		 NULL,
+     "Perform network input sync in advance:  Causes ~ 16 ms input delay but more suitable for relatively slow machines/networks (for master only)" },
+   { "statedebug",            NULL,             rc_bool,         &_machine_state_debug,
+     "0",		      0,		0,		 NULL,
+     "Check complete machine state against slaves at each frame -- extremely slow, for debugging (for master only)" },
+#endif
+   { NULL,		      NULL,		rc_end,		 NULL,
+     NULL,		      0,		0,		 NULL,
+     NULL }
+};
+
+#ifdef XMAME_NET
+
+static int _socket_fd;
+
+unsigned _frame_count = 0;
+unsigned _current_sync_sequence = 0;
+unsigned _min_state_sequence = 0, _prev_min_state_sequence = 0;
+
+/* Variables used by the master to keep track of sync time and
+   sync skipping -- see doc/network.txt */
+#define SYNC_SKIP_TOLERANCE 3 /* ms */
+#define SYNC_TIME_SMA_IGNORE_COUNT 5
+#define SYNC_TIME_SMA_POINTS 60 /* SMA == simple moving average */
+#define MAX_SYNC_SKIP 8
+static unsigned _minimum_frame_for_valid_sma =
+    SYNC_TIME_SMA_IGNORE_COUNT + SYNC_TIME_SMA_POINTS;
+static unsigned _sync_skip = 0;
+static unsigned _new_sync_skip = 0;
+static struct timeval _sync_start_time;
+static unsigned _sync_time[SYNC_TIME_SMA_POINTS];
+static unsigned _sync_time_cursor = 0;
+static double _sync_time_sma = 0;
+
+static void
+_net_shutdown(void);
+
+static int
+_tv_subtract(struct timeval *tv1, struct timeval *tv2)
+{
+    int result;
+    result = (tv1->tv_sec - tv2->tv_sec) * 1000000;
+    result += (tv1->tv_usec - tv2->tv_usec);
+    return result;
+}
+
+#if PROTOCOL_DEBUG >= 1
+struct timeval _start_time;
+
+unsigned _min_sync_time = 0;
+unsigned _max_sync_time = 0;
+unsigned _total_sync_time = 0;
+#endif
+
+static int
+_init_sockets(void)
+{
+    int result = FALSE;
+    int scratch;
+
+    struct sockaddr_in input_addr;
+    
+    if (_socket_fd = socket(AF_INET, SOCK_DGRAM, 0),
+	_socket_fd < 0)
+    {
+	_CHATTY_ERRNO_LOG("Can't create socket");
+    }
+    else if (scratch = fcntl(_socket_fd, F_SETFL, O_NONBLOCK),
+	     scratch == -1)
+    {
+	_CHATTY_ERRNO_LOG("Can't set socket non-blocking flag");
+    } else {
+	/* Assign domain and port number */
+	/* TODO:  Make bind port configurable */
+	input_addr.sin_family = AF_INET;
+	input_addr.sin_addr.s_addr = INADDR_ANY;
+	input_addr.sin_port = htons(_bind_port);
+
+	/* bind socket */
+	if (bind(_socket_fd,
+		 (struct sockaddr *)&input_addr,
+		 sizeof(input_addr)) == -1)
+	{
+	    _CHATTY_ERRNO_LOG("Can't bind socket");
+	} else {
+	    result = TRUE;
+	}
+    }
+    return result;
+}
+
+static void
+_prime_msg(struct net_msg_info *msg_info,
+	   enum net_msg_type msg_type,
+	   UINT32 sequence)
+{
+    memcpy(msg_info->msg, MSG_MAGIC, MSG_MAGIC_LEN);
+    msg_info->msg_type = msg_type;
+    msg_info->msg[3] = (unsigned char)msg_type;
+    msg_info->sequence = sequence;
+    (*(UINT32 *)(msg_info->msg + 8)) = ntohl(sequence);
+    msg_info->data_start = msg_info->msg + MSG_HEADER_LEN;
+    msg_info->data_len = 0;
+}
+
+static int
+_write_to_msg(struct net_msg_info *msg_info,
+	      const void *new_data,
+	      unsigned new_data_len)
+{
+    int result = FALSE;
+    if (msg_info->data_len + new_data_len + MSG_HEADER_LEN > MAX_MSG_LEN) {
+	_CHATTY_LOG("Error: message overflow");
+    } else {
+	memcpy(msg_info->data_start + msg_info->data_len,
+	       new_data,
+	       new_data_len);
+	msg_info->data_len += new_data_len;
+	result = TRUE;
+    }
+    return result;
+}
+
+static void
+_copy_msg(struct net_msg_info *src_msg,
+	  struct net_msg_info *dest_msg)
+{
+    memcpy(dest_msg, src_msg, sizeof(struct net_msg_info));
+    if (src_msg->data_start != NULL) {
+	dest_msg->data_start =
+	    dest_msg->msg + (src_msg->data_start - src_msg->msg);
+    }
+}
+
+static void
+_build_block_prompt_msg(struct net_msg_info *msg_info)
+{
+    unsigned bitmap_byte = 0, bitmap_bit = 0;
+    UINT32 block_part = 0;
+    unsigned total_parts_requested =
+	(_block_info.remaining_part_count <= MAX_REQUESTED_PARTS) ?
+	_block_info.remaining_part_count : MAX_REQUESTED_PARTS;
+    unsigned parts_requested = 0;
+
+    _prime_msg(msg_info, BLOCK_PROMPT, _current_sync_sequence);
+
+    while (block_part < _block_info.total_part_count &&
+	   parts_requested < total_parts_requested)
+    {
+	if ((_block_info.bitmap[bitmap_byte] & (1 << bitmap_bit)) == 0) {
+	    UINT32 scratch = (UINT32)ntohl(block_part);
+	    _write_to_msg(msg_info, &scratch, sizeof(UINT32));
+	    parts_requested += 1;
+	}
+	block_part += 1;
+	bitmap_bit += 1;
+	if (bitmap_bit == 8) {
+	    bitmap_bit = 0;
+	    bitmap_byte += 1;
+	}
+    }
+}
+
+static int
+_send_msg(struct net_msg_info *msg_info,
+	  struct sockaddr_in *dest)
+{
+    int result = FALSE;
+    if (sendto(_socket_fd,
+	       msg_info->msg,
+	       (msg_info->data_start - msg_info->msg) + msg_info->data_len,
+	       0,
+	       (struct sockaddr *)dest,
+	       sizeof(*dest)) < 0)
+    {
+	_CHATTY_ERRNO_LOG("Can't send message");
+    } else {
+	result = TRUE;
+    }
+    return result;
+}
+
+static struct net_peer_info *
+_peer_for_addr(struct sockaddr_in *addr)
+{
+    unsigned char i;
+    struct net_peer_info *result = NULL;
+    for (i = 0; i < _original_player_count - 1; i++) {
+	if (memcmp(addr, &(_peer_info[i].addr), sizeof(*addr)) == 0) {
+	    result = &(_peer_info[i]);
+	    break;
+	}
+    }
+    return result;
+}
+
+static struct net_peer_info *
+_new_peer_with_addr(struct sockaddr_in *addr)
+{
+    unsigned char i = 0;
+    struct net_peer_info *result = NULL;
+    while (i < _original_player_count - 1 &&
+	   _peer_info[i].state != INACTIVE)
+    {
+	i += 1;
+    }
+    if (i < _original_player_count - 1) {
+	memcpy(&(_peer_info[i].addr),
+	       addr,
+	       sizeof(_peer_info[i].addr));
+	result = &(_peer_info[i]);
+    }
+    return result;
+}
+
+static int
+_send_msg_to_peer(struct net_msg_info *msg_info,
+		  struct net_peer_info *dest)
+{
+    int result = FALSE;
+
+    msg_info->counter = dest->outbound_counter;
+    (*(UINT32 *)(msg_info->msg + 4)) = ntohl(dest->outbound_counter);
+
+    if (_send_msg(msg_info, &(dest->addr))) {
+	dest->outbound_counter += 1;
+	if (msg_info->sequence == _current_sync_sequence) {
+	    if (dest->last_outbound_sequence < msg_info->sequence) {
+		dest->last_outbound_sequence = msg_info->sequence;
+		dest->previous_send = dest->current_send;
+	    }
+	    dest->current_send.msg_type = msg_info->msg_type;
+	    dest->current_send.time_since = 0;
+	} else {
+	    dest->previous_send.msg_type = msg_info->msg_type;
+	    dest->previous_send.time_since = 0;
+	}
+	result = TRUE;
+    }
+    return result;
+}
+
+static int
+_ok_to_resend(struct net_msg_info *msg_info,
+	      struct net_peer_info *dest,
+	      unsigned minimum_time_lapse)
+{
+    int result = FALSE;
+    enum net_msg_type last_type;
+    unsigned time_lapse;
+    if (msg_info->sequence == _current_sync_sequence) {
+	last_type = dest->current_send.msg_type;
+	time_lapse = dest->current_send.time_since;
+    } else {
+	last_type = dest->previous_send.msg_type;
+	time_lapse = dest->previous_send.time_since;
+    }
+    if (msg_info->msg_type != last_type || time_lapse >= minimum_time_lapse) {
+	result = TRUE;
+    }
+    return result;
+}
+
+static unsigned
+_block_part_size(unsigned block_part) {
+    unsigned result;
+    if (block_part + 1 == _block_info.total_part_count) {
+	result = _block_info.size % MAX_BLOCK_PART_SIZE;
+    } else {
+	result = MAX_BLOCK_PART_SIZE;
+    }
+    return result;
+}
+
+static int
+_send_block_part_to_peer(unsigned block_part,
+			 struct net_peer_info *dest)
+{
+    unsigned part_size = _block_part_size(block_part);
+    UINT32 scratch = (UINT32)ntohl(block_part);
+    _prime_msg(&_outbound_scratch_msg_info,
+	       BLOCK_PART,
+	       _current_sync_sequence);
+    _write_to_msg(&_outbound_scratch_msg_info, &scratch, sizeof(scratch));
+    _write_to_msg(&_outbound_scratch_msg_info,
+		  _block_info.buffer + block_part * MAX_BLOCK_PART_SIZE,
+		  part_size);
+#if PROTOCOL_DEBUG >= 3
+    _CHATTY_LOG("Sending block part %d, seq %d to slave \"%s\"",
+		block_part,
+		_outbound_scratch_msg_info.sequence,
+		dest->name);
+#endif
+    return _send_msg_to_peer(&_outbound_scratch_msg_info, dest);
+}
+
+static int
+_rcv_msg(struct net_msg_info *msg_info, 
+	 struct sockaddr_in *source_addr,
+	 int timeout,
+	 unsigned *time_used_p)
+{
+    int result = FALSE;
+    int sel_result;
+    unsigned time_used;
+    unsigned socklen = 0;
+    fd_set scratch_fds;
+    struct timeval rcv_start_tv, rcv_end_tv, timeout_tv;
+    struct timeval *timeout_tv_p = NULL;
+    int msg_len;
+    unsigned i;
+
+    if (timeout != -1) {
+	timeout_tv.tv_sec = timeout / 1000;
+	timeout_tv.tv_usec = (timeout % 1000) * 1000;
+	timeout_tv_p = &timeout_tv;
+    }
+
+    if (source_addr != NULL) {
+	socklen = sizeof(*source_addr);
+    }
+
+    gettimeofday(&rcv_start_tv, NULL);
+    do {
+	FD_ZERO(&scratch_fds);
+	FD_SET(_socket_fd, &scratch_fds);
+	    
+	sel_result = select(_socket_fd + 1,
+			    &scratch_fds,
+			    NULL,
+			    NULL,
+			    timeout_tv_p);
+	if (sel_result < 0) {
+	    _CHATTY_ERRNO_LOG("select() failure");
+	} else if (sel_result == 0) {
+	    timeout = 0;
+	}
+	else if (msg_len = recvfrom(_socket_fd,
+				    msg_info->msg,
+				    sizeof(msg_info->msg),
+				    0,
+				    (struct sockaddr *)source_addr,
+				    &socklen),
+		 msg_len < 0)
+	{
+	    _CHATTY_ERRNO_LOG("recvfrom() failure");
+	}
+	/* Packets without the magic header are discarded without error;
+	   they are assumed to be unrelated traffic */
+	else if (msg_len >= MSG_HEADER_LEN &&
+		 memcmp(msg_info->msg, MSG_MAGIC, MSG_MAGIC_LEN) == 0)
+	{
+	    msg_info->msg_type = msg_info->msg[3];
+	    msg_info->counter =
+		(UINT32)ntohl(*((UINT32 *)(msg_info->msg + 4)));
+	    msg_info->sequence =
+		(UINT32)ntohl(*((UINT32 *)(msg_info->msg + 8)));
+	    msg_info->data_start = msg_info->msg + MSG_HEADER_LEN;
+	    msg_info->data_len = msg_len - MSG_HEADER_LEN;
+	    result = TRUE;
+	}
+    } while (! result && timeout != 0);
+
+    gettimeofday(&rcv_end_tv, NULL);
+    time_used = _tv_subtract(&rcv_end_tv, &rcv_start_tv) / 1000;
+    for (i = 0; i < _original_player_count - 1; i++) {
+	if (_peer_info[i].state != INACTIVE) {
+	    _peer_info[i].current_send.time_since += time_used;
+	    _peer_info[i].previous_send.time_since += time_used;
+	}
+    }
+    if (time_used_p != NULL) {
+	*time_used_p = time_used;
+    }
+
+    return result;
+}
+
+/* Only slaves send reminders due to timeouts, never the master.
+   This cuts down on unnecessary network traffic and simplifies
+   the protocol as well.  The master can, however, send reminders
+   if a slave gets ahead of it due to message lossage. */
+static void
+_send_reminder_msg(struct net_peer_info *dest,
+		   unsigned retry_timeout)
+{
+    struct net_msg_info *reminder_msg = NULL;
+
+    if (_current_net_role == SLAVE && dest == &(_master_info)) {
+	switch (_protocol_state) {
+	case REGISTRATION:
+	case INPUT_EXCHANGE:
+	    reminder_msg = _current_outbound_msg_info;
+	    break;
+	case ACKNOWLEDGEMENT:
+	    _prime_msg(&_outbound_scratch_msg_info,
+		       ACK,
+		       _current_sync_sequence - 1);
+	    reminder_msg = &_outbound_scratch_msg_info;
+	    break;
+	case BLOCK_TRANSFER:
+	    _build_block_prompt_msg(&_outbound_scratch_msg_info);
+	    reminder_msg = &_outbound_scratch_msg_info;
+	default:
+	    _CHATTY_LOG("Trying to send reminder message"
+			" from invalid state %d",
+			_protocol_state);
+	    break;
+	}
+    } else {
+	reminder_msg = _current_outbound_msg_info;
+    }
+    
+    if (reminder_msg != NULL &&
+	_ok_to_resend(reminder_msg, dest, retry_timeout))
+    {
+#if PROTOCOL_DEBUG >= 1
+#if PROTOCOL_DEBUG >= 2
+	_CHATTY_LOG("Sending reminder msg"
+		    " type %d, sequence %d/counter %d to peer \"%s\"",
+		    reminder_msg->msg_type,
+		    reminder_msg->sequence,
+		    dest->outbound_counter,
+		    dest->name);
+#endif
+	_reminder_count += 1;
+#endif
+	_send_msg_to_peer(reminder_msg, dest);
+    }
+}
+
+static struct net_peer_info *
+_rcv_msg_from_peer(struct net_msg_info *msg,
+		   unsigned timeout,
+		   unsigned *time_used,
+		   int allow_join)
+{
+    struct net_peer_info *source_peer = NULL;
+    struct sockaddr_in source_addr;
+
+    if (_rcv_msg(msg, &source_addr, timeout, time_used)) {
+	source_peer = _peer_for_addr(&source_addr);
+	if (source_peer == NULL) {
+	    if (msg->msg_type == JOIN && allow_join) {
+		source_peer = _new_peer_with_addr(&source_addr);
+	    } else {
+		_CHATTY_LOG("Error: Received message from unknown source");
+	    }
+	}
+    }
+    return source_peer;
+}
+
+static struct net_peer_info *
+_pushy_rcv_msg_from_peer(struct net_msg_info *msg,
+			 int retry_timeout,
+			 int giveup_timeout,
+			 unsigned *time_used,
+			 int allow_join)
+{
+    struct net_peer_info *source_peer = NULL;
+    
+    *time_used = 0;
+    do {
+	unsigned rcv_timeout;
+	unsigned try_time_used;
+	unsigned char i;
+
+	if (retry_timeout < giveup_timeout && giveup_timeout != -1) {
+	    rcv_timeout = retry_timeout;
+	} else {
+	    rcv_timeout = giveup_timeout;   /* n.b. May be zero (no timeout) */
+	}
+	source_peer = _rcv_msg_from_peer(msg,
+					 rcv_timeout,
+					 &try_time_used,
+					 allow_join);
+	*time_used += try_time_used;
+	if (giveup_timeout != -1) {
+	    if (try_time_used < giveup_timeout) {
+		giveup_timeout -= try_time_used;
+	    } else {
+		giveup_timeout = 0;
+	    }
+	}
+	if (source_peer == NULL && giveup_timeout != 0) {
+	    /* Resend messages to whichever peers are dawdling */
+	    for (i = 0; i < _original_player_count - 1; i++) {
+		if (_peer_info[i].state == UNSYNCED) {
+		    _send_reminder_msg(&(_peer_info[i]),
+				       retry_timeout);
+		}
+	    }
+	}
+    } while (source_peer == NULL && giveup_timeout != 0);
+
+    return source_peer;
+}
+
+static void
+_record_sync_start()
+{
+    gettimeofday(&_sync_start_time, NULL);
+}
+
+static void
+_record_sync_end()
+{
+    struct timeval sync_end_time;
+    unsigned sync_time;
+    gettimeofday(&sync_end_time, NULL);
+    sync_time = _tv_subtract(&sync_end_time, &_sync_start_time) / 1000;
+    
+    if (! _non_state_msg_since_sync) {
+	int is_spike = FALSE;
+	/* Smooth out the occasional unrepresentative super-long sync -- 
+	   observed in testing, but I'm unsure as to the cause.  Other
+	   processes suddenly hogging the CPU?  Dunno.  Anwyays, yay Stats
+	   101, but I'm not going to bother calculating the bloody standard
+	   deviation */
+	if (_frame_count > SYNC_TIME_SMA_IGNORE_COUNT + SYNC_TIME_SMA_POINTS &&
+	    sync_time > 4 * _sync_time_sma)
+	{
+	    is_spike = TRUE;
+	}
+	
+	if (_current_net_role == MASTER &&
+	    _frame_count > SYNC_TIME_SMA_IGNORE_COUNT &&
+	    ! is_spike)
+	{
+	    _sync_time_sma -=
+		(double)_sync_time[_sync_time_cursor] / (double)SYNC_TIME_SMA_POINTS;
+	    _sync_time[_sync_time_cursor] = sync_time;
+	    _sync_time_sma +=
+		(double)_sync_time[_sync_time_cursor] / (double)SYNC_TIME_SMA_POINTS;
+#if PROTOCOL_DEBUG >= 3
+	    _CHATTY_LOG("Sync time: %d ms; _sync_time_sma now == %f ms",
+			sync_time,
+			_sync_time_sma);
+#endif
+	    _sync_time_cursor += 1;
+	    if (_sync_time_cursor == SYNC_TIME_SMA_POINTS) {
+		_sync_time_cursor = 0;
+	    }
+	}
+    }
+    _non_state_msg_since_sync = FALSE;
+
+#if PROTOCOL_DEBUG >= 1
+    if (_min_sync_time == 0 || (sync_time < _min_sync_time)) {
+	_min_sync_time = sync_time;
+    }
+    if (_max_sync_time == 0 || (sync_time > _max_sync_time)) {
+	_max_sync_time = sync_time;
+    }
+    _total_sync_time += sync_time;
+#endif
+}
+
+static void
+_handle_duplicate_msg(struct net_msg_info *duplicate_msg_info,
+		      struct net_peer_info *source_peer,
+		      struct net_msg_info *counterpart,
+		      unsigned retry_timeout)
+				      
+{
+#if PROTOCOL_DEBUG >= 1
+#if PROTOCOL_DEBUG >= 2
+    _CHATTY_LOG("Received duplicate message"
+		" type %d sequence %d/counter %d from peer \"%s\"",
+		duplicate_msg_info->msg_type,
+		duplicate_msg_info->sequence,
+		duplicate_msg_info->counter,
+		source_peer->name);
+#endif
+    _inbound_duplicate_count += 1;
+#endif
+    /* At the time the peer sent this duplicate message, it had not yet
+       received the requisite message from the local instance to sync.
+       That can only be the current sync or the previous one, because
+       a peer can only get 1 sync ahead of any other (see protocol
+       documentation in doc/network-readme.txt).
+       It may have received a copy of the requisite message between the
+       duplicate message being sent and received, but there is no way
+       to determine that, so re-send (but limit resend frequency to
+       avoid flooding the network due to a sudden influx of duplicates) */
+    if (duplicate_msg_info->counter > source_peer->last_inbound_counter &&
+	_ok_to_resend(counterpart, source_peer, retry_timeout))
+    {
+#if PROTOCOL_DEBUG >= 2
+	_CHATTY_LOG("... re-sending message type %d sequence %d",
+		    counterpart->msg_type,
+		    counterpart->sequence);
+#endif
+	_send_msg_to_peer(counterpart, source_peer);
+    }
+}
+
+static void
+_handle_early_msg(struct net_msg_info *early_msg_info,
+		  struct net_peer_info *source_peer,
+		  unsigned retry_timeout)
+{
+    /* A peer is already at the next frame and sending its
+       state.  If that peer is synced for the current frame, the
+       local instance is presumably stuck waiting for some other
+       peer to sync.  If the early peer is not yet synced, the local
+       instance missed its message for the current frame and it
+       must be prompted to send it again.
+       In both cases, copy the early message into a temporary space
+       for later processing (unless this has already been done) */
+    if (source_peer->state == UNSYNCED) {
+	_send_reminder_msg(source_peer, retry_timeout);
+    }
+    if (early_msg_info->sequence > source_peer->early_inbound_msg_info.sequence)
+    {
+	_copy_msg(early_msg_info,
+		  &(source_peer->early_inbound_msg_info));
+    }
+}
+
+static void
+_process_new_state_msg(struct net_msg_info *msg_to_process,
+		       struct net_peer_info *source_peer,
+		       unsigned short *input_port_deviations)
+{
+    unsigned i;
+    for (i = 0; i < MAX_INPUT_PORTS; i++) {
+	/* mask in the default deviations from each peer */
+	input_port_deviations[i] |=
+	    ntohs(((unsigned short *)msg_to_process->data_start)[i]);
+    }
+    assert(_protocol_state == INPUT_EXCHANGE);
+    source_peer->state = SYNCED;
+    _unsynced_peer_count -= 1;
+    if (_unsynced_peer_count == 0 &&
+	(_current_net_role == MASTER || PROTOCOL_DEBUG >= 1))
+    {
+	_record_sync_end();
+    }
+#if PROTOCOL_DEBUG >= 3
+    _CHATTY_LOG("State of peer \"%s\" is now %d",
+		source_peer->name,
+		source_peer->state);
+#endif
+}
+
+static int
+_read_nvram(char **buffer, unsigned *len)
+{
+    int result = FALSE;
+    void *file;
+
+    file = mame_fopen(Machine->gamedrv->name,
+		     NULL,
+		     FILETYPE_NVRAM,
+		     FALSE);
+    if (file != NULL) {
+	*len = mame_fsize(file);
+	*buffer = (char *)malloc(*len);
+	mame_fread(file, *buffer, *len);
+	mame_fclose(file);
+	result = TRUE;
+    }
+    return result;
+}
+
+static int
+_write_nvram(char *buffer, unsigned len)
+{
+    int result = FALSE;
+    void *file = mame_fopen(Machine->gamedrv->name,
+			   NULL,
+			   FILETYPE_NVRAM,
+			   TRUE);
+    if (file != NULL) {
+	mame_fwrite(file, buffer, len);
+	mame_fclose(file);
+	result = TRUE;
+    }
+    return result;
+}
+
+static void
+_finalize_nvram_transfer()
+{
+    /* This depends on osd_net_init() being invoked *before*
+       the game driver's NVRAM handler */
+
+    _read_nvram(&_nvram_backup, &_nvram_backup_len);
+    if (! _write_nvram(_block_info.buffer, _block_info.size)) {
+	if (_nvram_backup != NULL) {
+	    free(_nvram_backup);
+	    _nvram_backup = NULL;
+	}
+	_CHATTY_LOG("Unable to overwrite NVRAM with network master's copy;"
+		    " this may lead to desync of the game");
+    } else {
+	_CHATTY_LOG("NVRAM transfer finalized");
+    }
+}
+
+static void
+_process_new_block_init_msg(struct net_msg_info *msg_to_process)
+{
+    _block_info.type = ntohl(*((UINT32 *)msg_to_process->data_start));
+    _block_info.size = ntohl(*((UINT32 *)(msg_to_process->data_start + 4)));
+    _block_info.buffer = malloc(_block_info.size);
+    _block_info.total_part_count = _block_info.size / MAX_BLOCK_PART_SIZE;
+    if (_block_info.size % MAX_BLOCK_PART_SIZE > 0) {
+	_block_info.total_part_count += 1;
+    }
+    _block_info.remaining_part_count = _block_info.total_part_count;
+    _block_info.bitmap = malloc((_block_info.total_part_count / 8) + 1);
+    memset(_block_info.bitmap, 0, (_block_info.total_part_count / 8) + 1);
+}
+
+static void
+_process_new_set_sync_skip_msg(struct net_msg_info *msg_to_process)
+{
+    _new_sync_skip = ntohl(*((UINT32 *)msg_to_process->data_start));
+}
+
+static void
+_process_new_block_part_msg(struct net_msg_info *msg_to_process,
+			    struct net_peer_info *source_peer)
+{
+    UINT32 block_part = ntohl(*(UINT32 *)msg_to_process->data_start);
+    assert(source_peer == &(_master_info));
+
+    assert(((_block_info.remaining_part_count == _block_info.total_part_count) && _protocol_state == ACKNOWLEDGEMENT) ||
+	   ((_block_info.remaining_part_count < _block_info.total_part_count) && _protocol_state == BLOCK_TRANSFER));
+
+    _protocol_state = BLOCK_TRANSFER;
+    if (! (_block_info.bitmap[block_part / 8] & (1 << (block_part % 8)))) {
+	memcpy(_block_info.buffer + MAX_BLOCK_PART_SIZE * block_part,
+	       msg_to_process->data_start + 4,
+	       msg_to_process->data_len - 4);
+	_block_info.bitmap[block_part / 8] |= (1 << (block_part % 8));
+	_block_info.remaining_part_count -= 1;
+#if PROTOCOL_DEBUG >= 3
+	_CHATTY_LOG("Got block part %d, seq %d; %d parts left",
+		    block_part,
+		    msg_to_process->sequence,
+		    _block_info.remaining_part_count);
+#endif
+	if (_block_info.remaining_part_count == 0) {
+	    switch (_block_info.type) {
+	    case NVRAM_BLOCK:
+		_finalize_nvram_transfer();
+		break;
+	    case MACHINESTATE_BLOCK:
+		/* _finalize_state_transfer(); */
+		break;
+	    default:
+		/* Sanity check? */
+		break;
+	    }
+	    free(_block_info.buffer);
+	    free(_block_info.bitmap);
+
+	    _protocol_state = INPUT_EXCHANGE;
+	    _prime_msg(&_outbound_scratch_msg_info,
+		       ACK,
+		       _current_sync_sequence);
+	    _send_msg_to_peer(&_outbound_scratch_msg_info,
+			      source_peer);
+	    _current_sync_sequence += 1;
+	}
+    }
+}
+
+static void
+_process_new_block_prompt_msg(struct net_msg_info *msg_to_process,
+			      struct net_peer_info *source_peer)
+{
+    unsigned block_count = msg_to_process->data_len / sizeof(UINT32);
+    unsigned i;
+    for (i = 0; i < block_count; i++) {
+	unsigned block_part = 
+	    ntohl(((UINT32 *)msg_to_process->data_start)[i]);
+	assert(block_part < _block_info.total_part_count);
+	_send_block_part_to_peer(block_part, source_peer);
+    }
+}
+
+static void
+_build_start_msg_for_peer(struct net_msg_info *msg,
+			  struct net_peer_info *peer,
+			  unsigned sync_sequence)
+{
+    unsigned i;
+    unsigned char scratch_msg_data[MAX_MSG_LEN];
+
+    _prime_msg(msg, START, sync_sequence);
+    scratch_msg_data[0] = peer->player_number;
+    scratch_msg_data[1] =
+	(_parallel_sync << CONFIG_BITMAP_PARALLELSYNC) |
+	(_machine_state_debug << CONFIG_BITMAP_MACHINE_STATE_DEBUG);
+    _write_to_msg(msg, scratch_msg_data, 2);
+    for (i = 0; i < _current_player_count - 1; i++) {
+	/* The accept message sent out to each slave includes the name and
+	   IP address for every *other* slave */
+	if (_peer_info[i].state != INACTIVE &&
+	    _peer_info[i].player_number != peer->player_number)
+	{
+	    char *ip_string = inet_ntoa(_peer_info[i].addr.sin_addr);
+	    char scratch[10];
+	    sprintf(scratch, ":%d", _peer_info[i].addr.sin_port);
+	    _write_to_msg(msg,
+			  _peer_info[i].name,
+			  strlen(_peer_info[i].name) + 1);
+	    _write_to_msg(msg,
+			  ip_string,
+			  strlen(ip_string));
+	    _write_to_msg(msg, scratch, strlen(scratch) + 1);
+	}
+    }
+}
+	    
+static void
+_inactivate_peer(struct net_peer_info *peer)
+{
+    if (peer->state == UNSYNCED) {
+	_unsynced_peer_count -= 1;
+    }
+    peer->state = INACTIVE;
+    _current_player_count -= 1;
+
+    if (_current_player_count == 1) {
+	_net_shutdown();
+    }
+    else if (peer == &(_master_info)) {
+	/* Find a new master -- pick the one with the lowest player
+	   number; since these have already been determined by the
+	   original master's START message the remaining peers will
+	   all pick the same one without needing to sync */
+	unsigned i;
+	unsigned lowest_player_number = _player_number;
+	for (i = 0; i < _original_player_count; i++) {
+	    if (_peer_info[i].state != INACTIVE &&
+		 _peer_info[i].player_number < lowest_player_number)
+	    {
+		lowest_player_number = _peer_info[i].player_number;
+		_master_index = i;
+	    }
+	}
+	if (lowest_player_number == _player_number) {
+	    _current_net_role = MASTER;
+	}
+    }
+}
+
+static void
+_process_inbound_msg(struct net_msg_info *msg_to_process,
+		     struct net_peer_info *source_peer,
+		     unsigned short *input_port_deviations,
+		     unsigned retry_timeout)
+{
+
+#if PROTOCOL_DEBUG >= 3
+    _CHATTY_LOG("Processing message type %d, sequence %d/counter %d"
+		" from peer \"%s\" (_current_sync_sequence == %d, "
+		"_min_state_sequence == %d)",
+		msg_to_process->msg_type,
+		msg_to_process->sequence,
+		msg_to_process->counter,
+		source_peer->name,
+		_current_sync_sequence,
+		_min_state_sequence);
+#endif
+
+    if (msg_to_process->msg_type == QUIT &&
+	msg_to_process->sequence <= _current_sync_sequence)
+	/* This is the only acceptable case from an inactive peer */
+    {
+	_prime_msg(&_outbound_scratch_msg_info,
+		   QUIT,
+		   msg_to_process->sequence);
+	if (source_peer->state != INACTIVE) {
+	    _CHATTY_LOG("Peer \"%s\" quit", source_peer->name);
+	    if (_protocol_state != QUITTING) {
+		_send_msg_to_peer(&_outbound_scratch_msg_info,
+				  source_peer);
+	    }
+	    _inactivate_peer(source_peer);
+	} else {
+	    _handle_duplicate_msg(msg_to_process,
+				  source_peer,
+				  &_outbound_scratch_msg_info,
+				  retry_timeout);
+	}
+    }
+    else if (source_peer->state == INACTIVE) {
+	/* Shouldn't really be receiving this message, but it
+	   could just be out of order, from a peer that quit earlier.
+	   Log an error anyways?  Maybe depending on PROTOCOL_DEBUG? */
+	/* _CHATTY_LOG("Warning: Received message (type %d)"
+		" from inactive peer \"%s\"",
+		msg_to_process->msg_type,
+		_peer_info[peer_index].name); */
+    }
+    else if (msg_to_process->sequence > _current_sync_sequence) {
+	/* Receiving an early ACK is nonsensical.  Sanity check? */
+	_handle_early_msg(msg_to_process, source_peer, retry_timeout);
+    }
+    else if (msg_to_process->msg_type == INPUT_STATE) {
+	if (msg_to_process->sequence >= _prev_min_state_sequence &&
+	    msg_to_process->sequence < _min_state_sequence)
+	{
+	    assert(_previous_outbound_msg_info->sequence < _current_sync_sequence);
+	    _handle_duplicate_msg(msg_to_process,
+				  source_peer,
+				  _previous_outbound_msg_info,
+				  retry_timeout);
+	}
+	else if (msg_to_process->sequence >= _min_state_sequence) {
+	    if (_current_net_role == MASTER &&
+		_protocol_state == ACKNOWLEDGEMENT)
+	    {
+		/* Received slave's input state before its ACK, which
+		   is to be expected */
+		_handle_early_msg(msg_to_process, source_peer, retry_timeout);
+	    }
+	    else if (_protocol_state != QUITTING) { 
+		/* Already checked for early messages,
+		   so state is for current frame */
+		if (source_peer->state == SYNCED) {
+		    _handle_duplicate_msg(msg_to_process,
+					  source_peer,
+					  _current_outbound_msg_info,
+					  retry_timeout);
+		} else { 
+		    if (_current_net_role == SLAVE) {
+			_protocol_state = INPUT_EXCHANGE;
+		    }
+		    _process_new_state_msg(msg_to_process,
+					   source_peer,
+					   input_port_deviations);
+		}
+	    }
+	} /* else message is old enough to ignore */
+    }
+    else if (msg_to_process->msg_type == BLOCK_PART) {
+	assert(_current_net_role == SLAVE && source_peer == &(_master_info));
+	/* _BLOCK messages are never repeated without a request, so
+	   anything sequenced before _current_sync_sequence must be
+	   out of order */
+	if (msg_to_process->sequence == _current_sync_sequence &&
+	    _protocol_state != QUITTING)
+	{
+	    _process_new_block_part_msg(msg_to_process, source_peer);
+	    _non_state_msg_since_sync = TRUE;
+	}
+    }
+    else if (msg_to_process->msg_type == START ||
+	     msg_to_process->msg_type == BLOCK_INIT ||
+	     msg_to_process->msg_type == SET_SYNC_SKIP)
+    {
+	/* All ACKables handled here */
+	assert(_current_net_role == SLAVE && source_peer == &(_master_info));
+	if (msg_to_process->sequence == _current_sync_sequence - 1) {
+	    _prime_msg(&_outbound_scratch_msg_info,
+		       ACK,
+		       msg_to_process->sequence);
+	    _handle_duplicate_msg(msg_to_process,
+				  source_peer,
+				  &_outbound_scratch_msg_info,
+				  retry_timeout);
+	}
+	else if (msg_to_process->sequence == _current_sync_sequence &&
+		 _protocol_state != QUITTING)
+	{
+	    /* All ACKables handled here */
+	    /* START processing performed outside _process_inbound_msg(),
+	       only BLOCK_INIT needs to be handled here.  If it's START
+	       it must be a duplicate */
+	    assert(msg_to_process->msg_type != START);
+	    /* No need to check if this has already been received for the
+	       current sync sequence as receiving an ACKable immediately
+	       sends the slave to the next sync sequence */
+	    if (msg_to_process->msg_type == BLOCK_INIT) {
+		_process_new_block_init_msg(msg_to_process);
+		_protocol_state = ACKNOWLEDGEMENT;
+	    }
+	    else if (msg_to_process->msg_type == SET_SYNC_SKIP) {
+		_process_new_set_sync_skip_msg(msg_to_process);
+		_protocol_state = INPUT_EXCHANGE;
+	    }
+	    _prime_msg(&_outbound_scratch_msg_info,
+		       ACK,
+		       _current_sync_sequence);
+	    _send_msg_to_peer(&_outbound_scratch_msg_info, source_peer);
+	    
+	    _non_state_msg_since_sync = TRUE;
+	    _current_sync_sequence += 1;
+
+	} /* else must be even older than _current_sync_sequence - 1
+	     and therefore out of order */
+    }
+    else if (msg_to_process->msg_type == ACK) {
+	assert(_current_net_role == MASTER);
+	if (msg_to_process->sequence == _current_sync_sequence - 1) {
+	    if (_protocol_state == REGISTRATION) {
+		_build_start_msg_for_peer(&_outbound_scratch_msg_info,
+					  source_peer,
+					  _current_sync_sequence - 1);
+		_handle_duplicate_msg(msg_to_process,
+				      source_peer,
+				      &_outbound_scratch_msg_info,
+				      retry_timeout);
+	    } else {
+		_handle_duplicate_msg(msg_to_process,
+				      source_peer,
+				      _previous_outbound_msg_info,
+				      retry_timeout);
+	    }
+	}
+	else if (msg_to_process->sequence == _current_sync_sequence) {
+	    /* Can't be QUITTING since an ACK implies that an ACKable
+	       was sent out for this sequence */
+	    if (source_peer->state == UNSYNCED) {
+		source_peer->state = SYNCED;
+		_unsynced_peer_count -= 1;
+		if (_unsynced_peer_count == 0 &&
+		    (_current_net_role == MASTER || PROTOCOL_DEBUG >= 1))
+		{
+		    _record_sync_end();
+		}
+	    }
+	    /* Ignore duplicate ACKs -- the master has nothing of
+	       interest to send the slave until remaining slaves
+	       sync up and the next input state goes out */
+	    _non_state_msg_since_sync = TRUE;
+	} /* else must be even older than _current_sync_sequence - 1
+	     and therefore out of order */
+    }
+    else if (msg_to_process->msg_type == BLOCK_PROMPT) {
+	/* Can't be QUITTING since a BLOCK_PROMPT implies that a block
+	   transfer was initiated during this frame */
+	assert(_current_net_role == MASTER);
+	if (msg_to_process->counter > source_peer->last_inbound_counter) {
+	    _process_new_block_prompt_msg(msg_to_process,
+					  source_peer);
+	    _non_state_msg_since_sync = TRUE;
+	}
+    } else {
+	_CHATTY_LOG("Bogus message type %d, sequence %d, counter %d"
+		    " from peer \"%s\"",
+		    msg_to_process->msg_type,
+		    msg_to_process->sequence,
+		    msg_to_process->counter,
+		    source_peer->name);
+    }
+    if (msg_to_process->counter > source_peer->last_inbound_counter) {
+	source_peer->last_inbound_counter = msg_to_process->counter;
+    }
+}
+
+static void
+_inbound_presync(unsigned short input_port_deviations[MAX_INPUT_PORTS])
+{
+    struct net_peer_info *source_peer;
+    while (source_peer = _rcv_msg_from_peer(&_inbound_scratch_msg_info,
+					    0,
+					    NULL,
+					    FALSE),
+	   source_peer != NULL)
+    {
+	_process_inbound_msg(&_inbound_scratch_msg_info,
+			     source_peer,
+			     input_port_deviations,
+			     SYNC_RETRY_TIMEOUT);
+    }
+}
+
+/* This function listens to the network and waits for LOCAL_STATE and ACK
+   messages.  It exits when all of the peers have satisfactorily reported,
+   or a timeout elapses.
+*/
+static void
+_inbound_sync(unsigned short input_port_deviations[MAX_INPUT_PORTS])
+{
+    unsigned i;
+    /* This function has the following amount of time to complete.  Any
+       peers that haven't synced up when the time is up are
+       dropped permanently. */
+    unsigned time_before_giveup = SYNC_TIMEOUT;
+
+    struct net_peer_info *source_peer;
+
+    /* 1. Process early messages and count peers without early messages */
+    for (i = 0; i < _original_player_count - 1; i++) {
+	if (_peer_info[i].state == UNSYNCED) {
+	    struct net_msg_info *early_msg =
+		&(_peer_info[i].early_inbound_msg_info);
+	    if ((_protocol_state == INPUT_EXCHANGE &&
+		 early_msg->sequence >= _min_state_sequence &&
+		 early_msg->sequence <= _current_sync_sequence) ||
+		(early_msg->sequence == _current_sync_sequence))
+	    {
+		_process_inbound_msg(&(_peer_info[i].early_inbound_msg_info),
+				     &(_peer_info[i]),
+				     input_port_deviations,
+				     SYNC_RETRY_TIMEOUT);
+	    }
+	}
+    }
+
+    /* 2. Process new messages from network until all peers sync */
+    while (_unsynced_peer_count > 0 && time_before_giveup > 0) {
+	unsigned time_used;
+	if (_current_net_role == SLAVE) {
+	    source_peer = _pushy_rcv_msg_from_peer(&_inbound_scratch_msg_info,
+						   SYNC_RETRY_TIMEOUT,
+						   time_before_giveup,
+						   &time_used,
+						   FALSE);
+	} else {
+	    /* Master never sends reminders due to timeouts */
+	    source_peer = _rcv_msg_from_peer(&_inbound_scratch_msg_info,
+					     time_before_giveup,
+					     &time_used,
+					     FALSE);
+	}
+	if (time_used >= time_before_giveup) {
+	    time_before_giveup = 0;
+	} else {
+	    time_before_giveup -= time_used;
+	}
+	if (source_peer != NULL) {
+	    /* Successfully received message before timeout; process it */
+	    _process_inbound_msg(&_inbound_scratch_msg_info,
+				 source_peer,
+				 input_port_deviations,
+				 SYNC_RETRY_TIMEOUT);
+	}
+    }
+
+    /* 3. At this point all peers have reported their states,
+       or have timed out */
+    /* TODO:  Dropping peers is susceptible to desync -- fix (if possible?) */
+    i = 0;
+    while (_unsynced_peer_count > 0 && i < _original_player_count - 1) {
+	if (_peer_info[i].state == UNSYNCED) {
+	    _CHATTY_LOG("No messages from peer \"%s\" in too long;"
+			" disconnecting it",
+			_peer_info[i].name);
+	    _inactivate_peer(&(_peer_info[i]));
+	    _unsynced_peer_count -= 1;
+	}
+	i += 1;
+    }
+
+    _current_sync_sequence += 1;
+    if (_protocol_state == INPUT_EXCHANGE) {
+	_prev_min_state_sequence = _min_state_sequence;
+	_min_state_sequence = _current_sync_sequence;
+    }
+
+#if PROTOCOL_DEBUG >= 3
+    _CHATTY_LOG("_current_sync_sequence incremented to %d",
+		_current_sync_sequence);
+#endif
+}
+
+static int
+_register_to_master(void)
+{
+    int result = FALSE;
+
+    char scratch[MAX_MSG_LEN];
+    struct net_peer_info *peer;
+    unsigned peer_index, peer_player_number;
+    unsigned msg_data_left;
+    char *msg_read_pointer;
+
+    _CHATTY_LOG("Slave Mode; Registering to \"%s\"", _master_info.name);
+        
+    _previous_outbound_msg_info = &(_saved_msg_info[0]);
+    _current_outbound_msg_info = &(_saved_msg_info[1]);
+
+    gethostname(scratch, MAX_MSG_LEN);
+	
+    _prime_msg(_current_outbound_msg_info, JOIN, 0);
+    _write_to_msg(_current_outbound_msg_info, scratch, strlen(scratch));
+    sprintf(scratch, "/%d", getpid());
+    _write_to_msg(_current_outbound_msg_info,
+		  scratch,
+		  strlen(scratch) + 1);
+    _write_to_msg(_current_outbound_msg_info,
+		  _truncated_build_version,
+		  strlen(_truncated_build_version) + 1);
+    _write_to_msg(_current_outbound_msg_info,
+		  PROTOCOL_VERSION,
+		  strlen(PROTOCOL_VERSION) + 1);
+    _write_to_msg(_current_outbound_msg_info,
+		  Machine->gamedrv->name,
+		  strlen(Machine->gamedrv->name) + 1);
+    /* First attempt to send a message to the address -- possible
+       problems include bad address and/or port */
+    if (! _send_msg_to_peer(_current_outbound_msg_info, &(_master_info))) {
+	_CHATTY_LOG("Unable to send JOIN message to master");
+    } else {
+	/* Until START message receipt, local instance and master
+	   are the only two peers involved */
+	unsigned time_used, time_before_giveup = SYNC_TIMEOUT;
+	_protocol_state = REGISTRATION;
+	_master_info.state = UNSYNCED;
+	_original_player_count = 2;
+	while (peer = _pushy_rcv_msg_from_peer(&_inbound_scratch_msg_info,
+					       REGISTRATION_RETRY_TIMEOUT,
+					       time_before_giveup,
+					       &time_used,
+					       FALSE),
+	       peer != NULL &&
+	       _inbound_scratch_msg_info.msg_type != REFUSE &&
+	       _inbound_scratch_msg_info.msg_type != START)
+	{
+	    /* NVRAM override happens here */
+	    _process_inbound_msg(&_inbound_scratch_msg_info,
+				 &(_master_info),
+				 NULL,
+				 REGISTRATION_RETRY_TIMEOUT);
+	    /* HACK:  Override protocol state set by _process_inbound_msg() */
+	    if (_protocol_state == INPUT_EXCHANGE) {
+		_protocol_state = ACKNOWLEDGEMENT;
+	    }
+	}
+	    
+	if (peer == NULL) {
+	    _CHATTY_LOG("Registration to \"%s\" timed out", _master_info.name);
+	}
+	else if (_inbound_scratch_msg_info.msg_type == REFUSE) {
+	    _CHATTY_LOG("\"%s\" refused registration", _master_info.name);
+	    if (_inbound_scratch_msg_info.data_len > 0) {
+		_CHATTY_LOG("Reason given:  %.50s",
+			    _inbound_scratch_msg_info.data_start);
+	    } else {
+		_CHATTY_LOG("No reason given");
+	    }
+	} else /* _inbound_scratch_msg_info.msg_type == START */ {
+	    /* Process START message */
+	    _player_number = _inbound_scratch_msg_info.data_start[0];
+	    _parallel_sync =
+		(_inbound_scratch_msg_info.data_start[1] & (1 << CONFIG_BITMAP_PARALLELSYNC));
+	    _machine_state_debug = 
+		(_inbound_scratch_msg_info.data_start[1] & (1 << CONFIG_BITMAP_MACHINE_STATE_DEBUG));
+
+	    _current_player_count = 2;
+	    peer_index = 0;
+	    peer_player_number = 1;
+	    /* 1 byte for _player_number + 1 byte for config bitmap == 2 */
+	    msg_read_pointer = _inbound_scratch_msg_info.data_start + 2;
+	    msg_data_left = _inbound_scratch_msg_info.data_len - 2;
+	    while (msg_data_left > 0) {
+		peer_index += 1;
+		peer_player_number += 1;
+
+		if (peer_player_number == _player_number) {
+		    peer_player_number += 1;
+		}
+
+		strncpy(_peer_info[peer_index].name,
+			msg_read_pointer,
+			msg_data_left);
+		msg_data_left -= (strlen(msg_read_pointer) + 1);
+		msg_read_pointer += (strlen(msg_read_pointer) + 1);
+		
+		if (msg_data_left == 0) {
+		    _CHATTY_LOG("Master returned malformed accept message:"
+				" no IP address for player %d",
+				peer_player_number);
+		}
+		else if (! _parse_hostport(msg_read_pointer,
+					   &(_peer_info[peer_index].addr)))
+		{
+		    _CHATTY_LOG("Master returned malformed accept message:"
+				" bogus peer host:port \"%s\" for player %d",
+				msg_read_pointer,
+				peer_player_number);
+		    break;
+		} else {
+		    msg_data_left -= (strlen(msg_read_pointer) + 1);
+		    msg_read_pointer += (strlen(msg_read_pointer) + 1);
+		    
+		    _peer_info[peer_index].player_number = peer_player_number;
+		    _peer_info[peer_index].state = UNSYNCED;
+		    _peer_info[peer_index].early_inbound_msg_info.sequence = 0;
+		    _peer_info[peer_index].outbound_counter = 0;
+		    _peer_info[peer_index].last_inbound_counter = 0;
+		}
+		_current_player_count += 1;
+	    }
+	    if (msg_data_left == 0) {
+		_original_player_count = _current_player_count;
+
+		_prime_msg(&_outbound_scratch_msg_info,
+			   ACK,
+			   _current_sync_sequence);
+		_send_msg_to_peer(&_outbound_scratch_msg_info,
+				  &(_master_info));
+		_protocol_state = ACKNOWLEDGEMENT;
+		_current_sync_sequence += 1;
+		
+		_CHATTY_LOG("START message processed;"
+			    " registration as player %d confirmed",
+			    (unsigned)_player_number);
+		_CHATTY_LOG("Protocol config:"
+			    " parallelsync %s, machine state debug %s",
+			    (_parallel_sync ? "enabled" : "disabled"),
+			    (_machine_state_debug ? "enabled" : "disabled"));
+		result = TRUE;
+	    }
+	}
+    }
+    return result;
+}
+
+
+static int
+_approve_join_msg(struct net_msg_info *msg_info,
+		  struct net_peer_info *source_peer)
+{
+    int result = FALSE;
+    const char * comparison_string[4];
+    const char * comparison_string_name[] = { "build version",
+					      "protocol version",
+					      "game name" };
+    unsigned i = 0;
+
+    unsigned msg_data_left = msg_info->data_len;
+    char *msg_read_pointer = msg_info->data_start;
+    char scratch_msg_data[MAX_MSG_LEN];
+	    
+    /* Compiler pacification */
+    comparison_string[0] = _truncated_build_version;
+    comparison_string[1] = PROTOCOL_VERSION;
+    comparison_string[2] = Machine->gamedrv->name;
+    comparison_string[3] = NULL;
+
+    strncpy(source_peer->name, msg_read_pointer, msg_data_left);
+    msg_data_left -= (strlen(source_peer->name) + 1);
+    msg_read_pointer += (strlen(source_peer->name) + 1);
+
+    while (comparison_string[i] != NULL) {
+	if (strncmp(msg_read_pointer,
+		    comparison_string[i],
+		    msg_data_left) != 0)
+	{
+	    sprintf(scratch_msg_data,
+		    "Wrong %s; need %s not %.10s",
+		    comparison_string_name[i],
+		    comparison_string[i],
+		    msg_read_pointer);
+
+	    _prime_msg(&_outbound_scratch_msg_info, REFUSE, 0);
+	    _write_to_msg(&_outbound_scratch_msg_info,
+			  scratch_msg_data,
+			  strlen(scratch_msg_data));
+	    _send_msg(&_outbound_scratch_msg_info, &(source_peer->addr));
+	    break;
+	}
+	msg_data_left -= (strlen(comparison_string[i]) + 1);
+	msg_read_pointer += strlen(comparison_string[i]) + 1;
+	i += 1;
+    }
+    if (comparison_string[i] == NULL) {
+	result = TRUE;
+    }
+    return result;
+}
+
+static int
+_await_slave_registrations(void)
+{
+    unsigned char slave_index;
+    unsigned i;
+    unsigned expected_ack_count;
+
+    _CHATTY_LOG("Master Mode: Waiting for %d more player%s.",
+		_original_player_count - 1,
+		(_original_player_count - 1 == 1) ? "" : "s");
+
+    _current_player_count = 1; /* Count only master to being with */
+
+    for (slave_index = 0;
+	 slave_index < _original_player_count - 1;
+	 slave_index++)
+    {
+	memset(&(_peer_info[slave_index].addr.sin_addr),
+	       0,
+	       sizeof(&(_peer_info[slave_index].addr.sin_addr)));
+	_peer_info[slave_index].state = INACTIVE;
+    }
+    if (_read_nvram(&_block_info.buffer, &_block_info.size)) {
+	UINT32 scratch;
+
+	_block_info.type = NVRAM_BLOCK;
+	_block_info.total_part_count = _block_info.size / MAX_BLOCK_PART_SIZE;
+	if (_block_info.size % MAX_BLOCK_PART_SIZE > 0) {
+	    _block_info.total_part_count += 1;
+	}
+
+	_current_outbound_msg_info = &(_saved_msg_info[1]);
+	_prime_msg(_current_outbound_msg_info, BLOCK_INIT, 0);
+	scratch = htonl(NVRAM_BLOCK);
+	_write_to_msg(_current_outbound_msg_info,
+		      &scratch,
+		      sizeof(scratch));
+	scratch = htonl(_block_info.size);
+	_write_to_msg(_current_outbound_msg_info,
+		      &scratch,
+		      sizeof(scratch));
+    } else {
+	_block_info.buffer = NULL;
+    }
+
+    _protocol_state = ACKNOWLEDGEMENT;
+    expected_ack_count = 0;
+    while (expected_ack_count > 0 ||
+	   _current_player_count < _original_player_count)
+    {
+	struct net_peer_info *source_peer;
+	source_peer = _rcv_msg_from_peer(&_inbound_scratch_msg_info,
+					 -1,
+					 NULL,
+					 TRUE);
+
+	if (_inbound_scratch_msg_info.msg_type != JOIN &&
+	    source_peer->state != INACTIVE)
+	{
+	    /* BLOCK_INIT for the NVRAM transfer happens here */
+	    _process_inbound_msg(&_inbound_scratch_msg_info,
+				 source_peer,
+				 NULL,
+				 REGISTRATION_RETRY_TIMEOUT);
+	    if (source_peer->state == SYNCED) {
+		expected_ack_count -= 1;
+	    }
+	}
+	else if (_inbound_scratch_msg_info.msg_type == JOIN) {
+	    /* New or re-registration, possibly unknown peer. 
+	       When a known slave re-registers (possibly due to packet loss)
+	       the master must double-check its handshake parameters
+	       (MAME/net version, game name) because it's possible they've
+	       changed -- this happens if it's a new process on the same
+	       host, which the master has no way of detecting */
+
+	    if (_approve_join_msg(&_inbound_scratch_msg_info, source_peer)) {
+		source_peer->outbound_counter = 0;
+		if (source_peer->state == INACTIVE) {
+		    /* New peer */
+		    _current_player_count += 1;
+		    source_peer->state = UNSYNCED;
+		    if (_block_info.buffer != NULL) {
+			_send_msg_to_peer(_current_outbound_msg_info,
+					  source_peer);
+			expected_ack_count += 1;
+		    }
+		} else {
+		    if (_block_info.buffer != NULL) {
+			_handle_duplicate_msg(&_inbound_scratch_msg_info,
+					      source_peer,
+					      _current_outbound_msg_info,
+					      REGISTRATION_RETRY_TIMEOUT);
+		    }
+		}
+		source_peer->last_inbound_counter =
+		    _inbound_scratch_msg_info.counter;
+	    } else {
+		if (source_peer->state != INACTIVE) {
+		    /* Existing peer re-registration failed */
+		    if (_block_info.buffer != NULL &&
+			source_peer->state == UNSYNCED)
+		    {
+			expected_ack_count -= 1;
+		    }
+		    source_peer->state = INACTIVE;
+		    _current_player_count -= 1;
+		}
+	    }
+	} else /* Neither JOIN nor already active peer */ {
+	    _CHATTY_LOG("Error: Unexpected message type (%d)"
+			" from unknown peer while awaiting JOIN requests",
+			_inbound_scratch_msg_info.msg_type);
+	}
+    }
+
+    /* At this point the master has accepted enough registrations to
+       start the game, so it sends out the NVRAM block if necessary */
+    if (_block_info.buffer != NULL) {
+	_current_sync_sequence += 1;
+	_protocol_state = BLOCK_TRANSFER;
+	for (slave_index = 0;
+	     slave_index < _current_player_count - 1;
+	     slave_index++)
+	{
+	    for (i = 0; i < _block_info.total_part_count; i++) {
+		_send_block_part_to_peer(i, &(_peer_info[slave_index]));
+	    }
+	    _peer_info[slave_index].state = UNSYNCED;
+	}
+	_unsynced_peer_count = _current_player_count - 1;
+	_inbound_sync(NULL);
+    }
+
+    /* Finally, the START messages */
+    _protocol_state = REGISTRATION;
+    for (slave_index = 0;
+	 slave_index < _current_player_count - 1;
+	 slave_index++)
+    {
+	_peer_info[slave_index].player_number = slave_index + 2;
+	_build_start_msg_for_peer(&_outbound_scratch_msg_info,
+				  &(_peer_info[slave_index]),
+				  _current_sync_sequence);
+
+	if (! _send_msg_to_peer(&_outbound_scratch_msg_info,
+				&(_peer_info[slave_index])))
+	{
+	    /* At this point it's too late to back out and start accepting
+	       registrations again, so we'll have to forget about this
+	       one.  The other slaves don't know and will have to time
+	       out */
+	    _CHATTY_ERRNO_LOG("Error: socket error sending START message"
+			      " to slave \"%s\" (player %d)",
+			      _peer_info[slave_index].name,
+			      _peer_info[slave_index].player_number);
+	} else {
+	    _CHATTY_LOG("\"%s\" registration accepted as player %d.",
+			_peer_info[slave_index].name,
+			_peer_info[slave_index].player_number);
+	    _peer_info[slave_index].state = UNSYNCED;
+	    _peer_info[slave_index].early_inbound_msg_info.sequence = 0;
+	}
+    }
+
+    /* Await ACKs for START messages */
+    _unsynced_peer_count = _current_player_count - 1;
+    _inbound_sync(NULL);
+
+    _previous_outbound_msg_info = &(_saved_msg_info[0]);
+    _current_outbound_msg_info = &(_saved_msg_info[1]);
+
+    return TRUE;
+}
+
+static int
+_map_input_port(unsigned unmapped_bit_index,
+		struct net_input_bit_id *mapped_bit_id)
+{
+    struct input_map_reference_t {
+	UINT32 playermask;
+	UINT32 start;
+	UINT32 coin;
+    } input_map_reference[] = { { IPF_PLAYER2, IPT_START2, IPT_COIN2 },
+				{ IPF_PLAYER3, IPT_START3, IPT_COIN3 },
+				{ IPF_PLAYER4, IPT_START4, IPT_COIN4 } };
+
+    unsigned candidate_port_index, candidate_bit_index;
+    UINT32 unmapped_type = Machine->gamedrv->input_ports[unmapped_bit_index].type;
+    UINT32 target_type = IPT_UNKNOWN;
+    int result = FALSE;
+
+    if (Machine->gamedrv->input_ports[0].type != IPT_PORT) {
+	_CHATTY_LOG("Unable to build key map:  "
+		    "Port definitions do not begin with IPT_PORT");        
+    }
+    else if (_player_number > 1) {      /* Map player n input bit to player 1,
+					   all others are no-op */
+	if ((unmapped_type & IPF_PLAYERMASK) ==
+	    input_map_reference[_player_number - 2].playermask)
+	{
+	    target_type = ((unmapped_type & ~IPF_PLAYERMASK) | IPF_PLAYER1);
+	}
+	else if (unmapped_type == input_map_reference[_player_number - 2].start)
+	{
+	    target_type = IPT_START1;
+	}
+	else if (unmapped_type == input_map_reference[_player_number - 2].coin)
+	{
+	    target_type = IPT_COIN1;
+	}
+
+	if (target_type != IPT_UNKNOWN) {
+	    UINT32 candidate_type;
+	    candidate_bit_index = 1;
+	    candidate_port_index = 0;
+	    while (candidate_port_index < MAX_INPUT_PORTS &&
+		   (candidate_type = Machine->gamedrv->input_ports[candidate_bit_index].type,
+		    candidate_type != IPT_END) &&
+		   ! result)
+	    {
+		if (candidate_type == IPT_PORT) {
+		    candidate_port_index += 1;
+		}
+		else if (candidate_type == target_type) {
+		    mapped_bit_id->port_index = candidate_port_index;
+		    mapped_bit_id->mask = Machine->gamedrv->input_ports[candidate_bit_index].mask;
+		    result = TRUE;
+		}
+		candidate_bit_index += 1;
+	    }
+	}
+    }
+    return result;
+}
+
+static int
+_build_net_keymap(void)
+{
+    int result = FALSE;
+
+    _input_mapping_count = 0;
+
+    if (Machine->gamedrv->input_ports[0].type != IPT_PORT) {
+	_CHATTY_LOG("Unable to build key map:  "
+		    "Port definitions do not begin with IPT_PORT");        
+    } else {
+	UINT32 current_type;
+	unsigned unmapped_bit_index = 1, unmapped_port_index = 0;
+
+	while (unmapped_port_index < MAX_INPUT_PORTS &&
+	       (current_type = Machine->gamedrv->input_ports[unmapped_bit_index].type,
+		current_type != IPT_END))
+	{
+	    unsigned previous_mapping_index;
+	    int duplicate_found = 0;
+	    if (current_type == IPT_PORT) {
+		unmapped_port_index += 1;
+	    }
+	    /* Check for duplicates (eg, same input port for player 1 button 1
+	       and player 1 start in Gauntlet) */
+	    previous_mapping_index = 0;
+	    while (previous_mapping_index < _input_mapping_count &&
+		   ! duplicate_found)
+	    {
+		unsigned previously_mapped_port_index = 
+		    _input_map[previous_mapping_index].source.port_index;
+		unsigned short previously_mapped_mask =
+		    _input_map[previous_mapping_index].source.mask;
+		if (unmapped_port_index == previously_mapped_port_index &&
+		    Machine->gamedrv->input_ports[unmapped_bit_index].mask == previously_mapped_mask)
+		{
+		    duplicate_found = 1;
+		}
+		previous_mapping_index += 1;
+	    }
+	    if (! duplicate_found &&
+		_map_input_port(unmapped_bit_index, &(_input_map[_input_mapping_count].dest)))
+	    {
+		_input_map[_input_mapping_count].source.port_index = unmapped_port_index;
+		_input_map[_input_mapping_count].source.mask =
+		    Machine->gamedrv->input_ports[unmapped_bit_index].mask;
+		_input_mapping_count += 1;
+	    }
+	    unmapped_bit_index += 1;
+	}
+	result = TRUE;
+    }
+    return result;
+}
+
+static void
+_remap_input_state(unsigned short input_state[MAX_INPUT_PORTS])
+{
+    unsigned mapping_index;
+    for (mapping_index = 0;
+	 mapping_index < _input_mapping_count;
+	 mapping_index++)
+    {
+	unsigned short source_mask = _input_map[mapping_index].source.mask;
+	unsigned short source_bit =
+	    input_state[_input_map[mapping_index].source.port_index] & source_mask;
+	unsigned short dest_mask = _input_map[mapping_index].dest.mask;
+	unsigned short dest_bit = 
+	    input_state[_input_map[mapping_index].dest.port_index] & dest_mask;
+
+	if (source_bit == 0) {
+	    input_state[_input_map[mapping_index].dest.port_index] &= ~dest_mask;
+	} else {
+	    input_state[_input_map[mapping_index].dest.port_index] |= dest_mask;
+	}
+	if (dest_bit == 0) {
+	    input_state[_input_map[mapping_index].source.port_index] &= ~source_mask;
+	} else {
+	    input_state[_input_map[mapping_index].source.port_index] |= source_mask;
+	}
+    }
+}
+
+#if PROTOCOL_DEBUG >= 3
+static void
+_log_port_array(unsigned short *port_values, unsigned port_count)
+{
+    unsigned i;
+    for (i = 0; i < port_count; i++) {
+	fprintf(stderr_file,
+		"%x%s",
+		port_values[i],
+		(i < port_count - 1) ? " " : "\n");
+    }
+}
+#endif
+
+static void
+_build_input_state_msg(struct net_msg_info *msg)
+{
+    unsigned i;
+    
+#if PROTOCOL_DEBUG >= 3
+    fprintf(stderr_file,
+	    "Frame %d outbound/saved deviations: ",
+	    _frame_count);
+    _log_port_array(_outbound_input_state, MAX_INPUT_PORTS);
+#endif
+
+    _prime_msg(msg, INPUT_STATE, _current_sync_sequence);
+    for (i = 0; i < MAX_INPUT_PORTS; i++) {
+	unsigned short scratch = htons(_outbound_input_state[i]);
+	_write_to_msg(msg, &scratch, sizeof(scratch));
+    }
+}
+
+static void
+_build_set_sync_skip_msg(struct net_msg_info *msg)
+{
+    UINT32 scratch = (UINT32)htonl(_new_sync_skip);
+    _prime_msg(msg, SET_SYNC_SKIP, _current_sync_sequence);
+    _write_to_msg(msg, &scratch, sizeof(scratch));
+}
+
+static void
+_outbound_sync(struct net_msg_info *msg)
+{
+    unsigned peer_index;
+
+#if PROTOCOL_DEBUG >= 3
+    _CHATTY_LOG("Sending message type %d sequence %d to peers",
+		msg->msg_type,
+		msg->sequence);
+#endif
+    if (_current_net_role == MASTER || PROTOCOL_DEBUG >= 1) {
+	_record_sync_start();
+    }
+
+    for (peer_index = 0;
+	 peer_index < _original_player_count - 1;
+	 peer_index++)
+    {
+	if (_peer_info[peer_index].state != INACTIVE) {
+	    _send_msg_to_peer(_current_outbound_msg_info,
+			      &(_peer_info[peer_index]));
+	    _peer_info[peer_index].state = UNSYNCED;
+#if PROTOCOL_DEBUG >= 3
+	    _CHATTY_LOG("State of peer \"%s\" is now %d",
+			_peer_info[peer_index].name,
+			_peer_info[peer_index].state);
+#endif
+	}
+    }
+    _unsynced_peer_count = _current_player_count - 1;
+
+    /* Now determine the new protocol state based on the outbound message
+       type (n.b. BLOCK_TRANSFER not handled here) */
+    if (msg->msg_type == INPUT_STATE) {
+	_protocol_state = INPUT_EXCHANGE;
+    } else {
+	_protocol_state = ACKNOWLEDGEMENT;
+    }
+}
+
+static void
+_accumulate_new_input(unsigned short input_port_values[MAX_INPUT_PORTS],
+		      unsigned short input_port_defaults[MAX_INPUT_PORTS])
+{
+    unsigned i;
+    /* The idea here is to accumulate deviations from the
+       *outbound* state (not the default state), in order
+       to try to minimize "lost" keystrokes */
+    for (i = 0; i < MAX_INPUT_PORTS; i++) {
+	_new_input_state[i] |= 
+	    (_outbound_input_state[i] ^ (input_port_values[i] ^ input_port_defaults[i]));
+    }
+    
+}
+
+static unsigned
+_sync_skip_adjustment()
+{
+    unsigned adjusted_skip = _sync_skip;
+
+    if (_frame_count >= _minimum_frame_for_valid_sma) {
+	float ms_per_frame =
+	    (float)1000 / (float)Machine->drv->frames_per_second;
+	float lower_boundary =
+	    (float)_sync_skip * ms_per_frame - (float)SYNC_SKIP_TOLERANCE;
+	float upper_boundary =
+	    (float)(_sync_skip + 1) * ms_per_frame + (float)SYNC_SKIP_TOLERANCE;
+	if (_sync_skip > 0 && _sync_time_sma < lower_boundary) {
+	    adjusted_skip -= 1;
+#if PROTOCOL_DEBUG >= 2
+	    _CHATTY_LOG("Sync time SMA is now %.2f (< %.2f)",
+			_sync_time_sma,
+			lower_boundary);
+#endif
+	}
+	else if (_sync_skip < MAX_SYNC_SKIP && _sync_time_sma > upper_boundary)
+	{
+	    adjusted_skip += 1;
+#if PROTOCOL_DEBUG >= 2
+	    _CHATTY_LOG("Sync time SMA is now %.2f (> %.2f)",
+			_sync_time_sma,
+			upper_boundary);
+#endif
+	}
+    }
+    return adjusted_skip;
+}
+
+void
+osd_net_sync(unsigned short input_port_values[MAX_INPUT_PORTS],
+	     unsigned short input_port_defaults[MAX_INPUT_PORTS])
+{
+    if (_current_net_role != NONE) {
+	unsigned i;
+	int skip_this_frame = (_frame_count % (_sync_skip + 1) != 0);
+
+	if (_input_remap && _player_number != 1) {
+	    _remap_input_state(input_port_values);
+	    _remap_input_state(input_port_defaults);
+	}
+
+	_accumulate_new_input(input_port_values, input_port_defaults);
+
+	if (skip_this_frame) {
+
+	    if (_unsynced_peer_count > 0) {
+		_inbound_presync(_inbound_input_state);
+	    }
+
+	} else {
+
+	    for (i = 0; i < MAX_INPUT_PORTS; i++) {
+		_saved_input_state[i] =
+		    _outbound_input_state[i] | _inbound_input_state[i];
+		_outbound_input_state[i] ^= _new_input_state[i];
+	    }
+	    memset(_new_input_state,
+		   0,
+		   MAX_INPUT_PORTS * sizeof(input_port_values[0]));
+	    memset(_inbound_input_state,
+		   0,
+		   MAX_INPUT_PORTS * sizeof(input_port_values[0]));
+
+	    /* Step 1:  If parallel sync is enabled, _inbound_sync() first */
+	    if (_parallel_sync && _frame_count > 0) {
+		_inbound_sync(_saved_input_state);
+	    }
+
+	    /* Step 2: Sync skip adjustment, if necessary */
+	    if (_new_sync_skip != _sync_skip) {
+		_CHATTY_LOG("Now setting skip to %d (_frame_count == %d)",
+			    _new_sync_skip,
+			    _frame_count);
+		_sync_skip = _new_sync_skip;
+		_minimum_frame_for_valid_sma =
+		    _frame_count + SYNC_TIME_SMA_POINTS;
+	    }
+	    else if (_current_net_role == MASTER &&
+		     (_new_sync_skip = _sync_skip_adjustment(),
+		      _new_sync_skip != _sync_skip))
+	    {
+		_PTR_SWAP(_current_outbound_msg_info,
+			  _previous_outbound_msg_info);
+		_build_set_sync_skip_msg(_current_outbound_msg_info);
+		_outbound_sync(_current_outbound_msg_info);
+		_inbound_sync(_inbound_input_state);
+	    }
+
+	    /* Step 3: _outbound_sync() */
+	    _PTR_SWAP(_current_outbound_msg_info, _previous_outbound_msg_info);
+	    _build_input_state_msg(_current_outbound_msg_info);
+	    _outbound_sync(_current_outbound_msg_info);
+	    /* Convert deviations from the saved input state into
+	       deviations from the default state */
+	    
+	    /* Step 4: If parallel sync is disabled, _inbound_sync() last */
+	    if (! _parallel_sync) {
+		_inbound_sync(_saved_input_state);
+	    }
+	}
+
+	/* Change array from default deviations back into actual values */
+	for (i = 0; i < MAX_INPUT_PORTS; i++) {
+	    input_port_values[i] =
+		_saved_input_state[i] ^ input_port_defaults[i];
+	}
+
+#if PROTOCOL_DEBUG >= 3
+	fprintf(stderr_file,
+		"Frame %d final values: ",
+		_frame_count);
+	_log_port_array(input_port_values, MAX_INPUT_PORTS);
+#endif
+	_frame_count += 1;
+    } /* else this shouldn't even be called */
+}
+    
+/*
+ * Initialise network
+ * - the master opens a socket and waits for slaves
+ * - the slaves register to the master
+ */
+int
+osd_net_init(void)
+{
+    int result = OSD_NOT_OK;
+
+    if (_original_player_count > 0) {
+	if (_current_net_role == SLAVE) {
+	    _CHATTY_LOG("Can't be both Slave and Master");
+	} else {
+	    _current_net_role = MASTER;
+	}
+    }
+	
+    if (_current_net_role == NONE) {
+	result = OSD_OK;
+    } else {
+	/* BRITTLE. The truncated build version is used in
+	   the handshake to match MAME versions -- is it worth it? */
+	char *build_version_end = strchr(build_version, ' ');
+	if (build_version_end == NULL) {
+	    strcpy(_truncated_build_version, build_version);
+	} else {
+	    strncpy(_truncated_build_version,
+		    build_version,
+		    (build_version_end - build_version));
+	}
+
+	if (_init_sockets()) {
+	    if (_current_net_role == MASTER) {
+		if (_await_slave_registrations()) {
+		    unsigned i;
+		    result = OSD_OK;
+		    for (i = 0; i < SYNC_TIME_SMA_POINTS; i++) {
+			_sync_time[i] = 0;
+		    }
+		}
+	    } else {
+		if (_register_to_master()) {
+		    result = OSD_OK;
+		    if (_input_remap)
+			if (! _build_net_keymap()) {
+			    _input_remap = 0;
+		    }
+		}
+	    }
+	    memset(_saved_input_state,
+		   0,
+		   MAX_INPUT_PORTS * sizeof(_saved_input_state[0]));
+	    memset(_inbound_input_state,
+		   0,
+		   MAX_INPUT_PORTS * sizeof(_inbound_input_state[0]));
+	    memset(_outbound_input_state,
+		   0,
+		   MAX_INPUT_PORTS * sizeof(_outbound_input_state[0]));
+	    memset(_new_input_state,
+		   0,
+		   MAX_INPUT_PORTS * sizeof(_new_input_state[0]));
+
+#if PROTOCOL_DEBUG >= 1
+	    gettimeofday(&_start_time, NULL);
+#endif
+	}
+    }
+    return result;
+}
+
+int
+osd_net_active(void)
+{
+    return (_current_net_role != NONE);
+}
+
+static void
+_bid_farewell(void)
+{
+    unsigned peer_index = 0;
+
+    _protocol_state = QUITTING;
+    for (peer_index = 0;
+	 peer_index < _original_player_count - 1;
+	 peer_index++)
+    {
+	if (_peer_info[peer_index].state != INACTIVE) {
+	    _prime_msg(&_outbound_scratch_msg_info,
+		       QUIT,
+		       _current_sync_sequence);
+	    _send_msg_to_peer(&_outbound_scratch_msg_info, 
+			      &(_peer_info[peer_index]));
+	    _peer_info[peer_index].state = UNSYNCED;
+	}
+    }
+    _inbound_sync(NULL);
+}
+
+#define MILLISECONDS_PART(ms) (ms % 1000)
+#define SECONDS_PART(ms) ((ms / 1000) - (ms / (60 * 1000) * 60))
+#define MINUTES_PART(ms) (ms / (60 * 1000))
+/*
+ * Close all opened sockets
+ */
+static void
+_net_shutdown(void)
+{
+#if PROTOCOL_DEBUG >= 1
+    struct timeval end_time;
+    unsigned total_time;
+#endif
+    
+    close(_socket_fd);
+
+#if PROTOCOL_DEBUG >= 1
+    gettimeofday(&end_time, NULL);
+
+    total_time = _tv_subtract(&end_time, &_start_time) / 1000;
+    _CHATTY_LOG("Protocol stats:");
+    _CHATTY_LOG("Current sync sequence:  %d", _current_sync_sequence);
+    _CHATTY_LOG("Duplicate inbound messages:  %d, reminder messages sent: %d",
+		_inbound_duplicate_count,
+		_reminder_count);
+    _CHATTY_LOG("Total sync time:  %02dm%02d.%ds (%02dm%02d.%ds real time elapsed)",
+		MINUTES_PART(_total_sync_time),
+		SECONDS_PART(_total_sync_time),
+		MILLISECONDS_PART(_total_sync_time),
+		MINUTES_PART(total_time),
+		SECONDS_PART(total_time),
+		MILLISECONDS_PART(total_time));
+    _CHATTY_LOG("Average sync time:  %d ms",
+		_total_sync_time / _current_sync_sequence);
+    _CHATTY_LOG("Min sync time:  %d ms", _min_sync_time);
+    _CHATTY_LOG("Max sync time:  %d ms", _max_sync_time);
+#endif
+    _current_net_role = NONE;
+}
+
+void
+osd_net_close(void)
+{
+#if PROTOCOL_DEBUG >= 2
+    _CHATTY_LOG("Bye");
+#endif    
+    if (_current_net_role != NONE) {
+	_bid_farewell(); /* _net_shutdown() will also get called
+			    through _inbound_sync() */
+    }
+    if (_nvram_backup != NULL) {
+	_write_nvram(_nvram_backup, _nvram_backup_len);
+    }
+}
+
+#endif /* XMAME_NET */
diff --git a/src/unix/osd_cpu.h b/src/unix/osd_cpu.h
new file mode 100644
index 0000000..ee51417
--- /dev/null
+++ b/src/unix/osd_cpu.h
@@ -0,0 +1,110 @@
+/*******************************************************************************
+*																			   *
+*	Define size independent data types and operations.						   *
+*																			   *
+*   The following types must be supported by all platforms:					   *
+*																			   *
+*	UINT8  - Unsigned 8-bit Integer		INT8  - Signed 8-bit integer           *
+*	UINT16 - Unsigned 16-bit Integer	INT16 - Signed 16-bit integer          *
+*	UINT32 - Unsigned 32-bit Integer	INT32 - Signed 32-bit integer          *
+*	UINT64 - Unsigned 64-bit Integer	INT64 - Signed 64-bit integer          *
+*																			   *
+*																			   *
+*   The macro names for the artithmatic operations are composed as follows:    *
+*																			   *
+*   XXX_R_A_B, where XXX - 3 letter operation code (ADD, SUB, etc.)			   *
+*					 R   - The type	of the result							   *
+*					 A   - The type of operand 1							   *
+*			         B   - The type of operand 2 (if binary operation)		   *
+*																			   *
+*				     Each type is one of: U8,8,U16,16,U32,32,U64,64			   *
+*																			   *
+*******************************************************************************/
+#ifndef OSD_CPU_H 
+#define OSD_CPU_H
+
+/* fixup some clock() related issues */
+#include <time.h>
+/* this is cut and pasted from sysdep/misc.c ,check sysdep/misc.c for
+   changes if you suspect something is wrong with this */
+/* some platforms don't define CLOCKS_PER_SEC, according to posix it should
+   always be 1000000, so asume that's the case if it is not defined,
+   except for openstep which doesn't define it and has it at 64 */
+#ifndef CLOCKS_PER_SEC
+#ifdef openstep
+#define CLOCKS_PER_SEC 64     /* this is correct for OS4.2 intel */
+#else
+#define CLOCKS_PER_SEC 1000000
+#endif
+#endif
+
+#ifndef __ARCH_solaris
+/* grrr work around some stupid header conflicts */
+#if !defined __XF86_DGA_C && !defined __XOPENGL_C_ && !defined LONG64
+typedef signed   char      INT8;
+typedef signed   short     INT16;
+typedef signed   int       INT32;
+#endif
+
+#else
+#include "X11/Xmd.h"
+#endif
+
+#ifndef LONG64
+typedef signed   long long INT64;
+#endif
+
+typedef unsigned char      UINT8;
+typedef unsigned short     UINT16;
+typedef unsigned int       UINT32;
+typedef unsigned long long UINT64;
+
+/* Combine two 32-bit integers into a 64-bit integer */
+#define COMBINE_64_32_32(A,B)     ((((UINT64)(A))<<32) | (UINT32)(B))
+#define COMBINE_U64_U32_U32(A,B)  COMBINE_64_32_32(A,B)
+
+/* Return upper 32 bits of a 64-bit integer */
+#define HI32_32_64(A)		  (((UINT64)(A)) >> 32)
+#define HI32_U32_U64(A)		  HI32_32_64(A)
+
+/* Return lower 32 bits of a 64-bit integer */
+#define LO32_32_64(A)		  ((A) & 0xffffffff)
+#define LO32_U32_U64(A)		  LO32_32_64(A)
+
+#define DIV_64_64_32(A,B)	  ((A)/(B))
+#define DIV_U64_U64_U32(A,B)  ((A)/(UINT32)(B))
+
+#define MOD_32_64_32(A,B)	  ((A)%(B))
+#define MOD_U32_U64_U32(A,B)  ((A)%(UINT32)(B))
+
+#define MUL_64_32_32(A,B)	  ((A)*(INT64)(B))
+#define MUL_U64_U32_U32(A,B)  ((A)*(UINT64)(UINT32)(B))
+
+/******************************************************************************
+ * Union of UINT8, UINT16 and UINT32 in native endianess of the target
+ * This is used to access bytes and words in a machine independent manner.
+ * The upper bytes h2 and h3 normally contain zero (16 bit CPU cores)
+ * thus PAIR.d can be used to pass arguments to the memory system
+ * which expects 'int' really.
+ ******************************************************************************/
+typedef union {
+#ifdef LSB_FIRST
+	struct { UINT8 l,h,h2,h3; } b;
+	struct { UINT16 l,h; } w;
+#else
+	struct { UINT8 h3,h2,h,l; } b;
+	struct { UINT16 h,l; } w;
+#endif
+	UINT32 d;
+}	PAIR;
+
+/* disable BIG_SWITCH optimalisation in z80.c and m6809.c on buggy gcc
+   versions */
+#if (defined __GNUC__) && \
+   ((__GNUC__ < 2) || ((__GNUC__ == 2) && (__GNUC_MINOR__ < 8)))
+#define BIG_SWITCH          0
+#else
+#define BIG_SWITCH          1
+#endif
+
+#endif	/* defined OSD_CPU_H */
diff --git a/src/unix/osdutils.h b/src/unix/osdutils.h
new file mode 100644
index 0000000..0845bf1
--- /dev/null
+++ b/src/unix/osdutils.h
@@ -0,0 +1,11 @@
+#include <sys/stat.h>
+#include <sys/types.h>
+#include <fcntl.h>
+
+#define strcmpi		strcasecmp
+#define strncmpi	strncasecmp
+
+#define osd_mkdir(dir)	mkdir(dir, 0)
+
+#define PATH_SEPARATOR '/'
+#define EOLN "\n"
diff --git a/src/unix/osinline.h b/src/unix/osinline.h
new file mode 100644
index 0000000..61caddf
--- /dev/null
+++ b/src/unix/osinline.h
@@ -0,0 +1,41 @@
+#ifndef __OSINLINE__
+#define __OSINLINE__
+
+/* for uclock() */
+#include "sysdep/misc.h"
+
+/* #define osd_cycles() uclock() */
+
+#if defined svgalib || defined x11 || defined ggi || defined openstep || defined SDL
+extern unsigned char *dirty_lines;
+extern unsigned char **dirty_blocks;
+
+#define osd_mark_vector_dirty(x,y) \
+{ \
+   dirty_lines[(y)>>3] = 1; \
+   dirty_blocks[(y)>>3][(x)>>3] = 1; \
+}
+
+#else
+#define osd_mark_vector_dirty(x,y)
+#endif
+
+#ifdef X86_ASM
+#define vec_mult _vec_mult
+INLINE int _vec_mult(int x, int y)
+{
+	int result;
+	asm (
+			"movl  %1    , %0    ; "
+			"imull %2            ; "    /* do the multiply */
+			"movl  %%edx , %%eax ; "
+			:  "=&a" (result)           /* the result has to go in eax */
+			:  "mr" (x),                /* x and y can be regs or mem */
+			   "mr" (y)
+			:  "%edx", "%cc"            /* clobbers edx and flags */
+		);
+	return result;
+}
+#endif
+
+#endif /* __OSINLINE__ */
diff --git a/src/unix/parallel.c b/src/unix/parallel.c
new file mode 100644
index 0000000..7c30391
--- /dev/null
+++ b/src/unix/parallel.c
@@ -0,0 +1,10 @@
+/*
+ * This is code that, if properly implemented, can parallelize operations for
+ * SMP.  Right now it's just a placeholder that does nothing.  See 
+ * mess/windows/parallel.c and .h if you want inspiration.  :-)
+ */
+void osd_parallelize(void (*task)(void *param, int task_num, int task_count),
+		void *param, int max_tasks)
+{
+	task(param, 0, 1);
+}
diff --git a/src/unix/snprintf.c b/src/unix/snprintf.c
new file mode 100644
index 0000000..a7f0066
--- /dev/null
+++ b/src/unix/snprintf.c
@@ -0,0 +1,824 @@
+/*
+ * Copyright Patrick Powell 1995
+ * This code is based on code written by Patrick Powell (papowell@astart.com)
+ * It may be used for any purpose as long as this notice remains intact
+ * on all source code distributions
+ */
+
+/**************************************************************
+ * Original:
+ * Patrick Powell Tue Apr 11 09:48:21 PDT 1995
+ * A bombproof version of doprnt (dopr) included.
+ * Sigh.  This sort of thing is always nasty do deal with.  Note that
+ * the version here does not include floating point...
+ *
+ * snprintf() is used instead of sprintf() as it does limit checks
+ * for string length.  This covers a nasty loophole.
+ *
+ * The other functions are there to prevent NULL pointers from
+ * causing nast effects.
+ *
+ * More Recently:
+ *  Brandon Long <blong@fiction.net> 9/15/96 for mutt 0.43
+ *  This was ugly.  It is still ugly.  I opted out of floating point
+ *  numbers, but the formatter understands just about everything
+ *  from the normal C string format, at least as far as I can tell from
+ *  the Solaris 2.5 printf(3S) man page.
+ *
+ *  Brandon Long <blong@fiction.net> 10/22/97 for mutt 0.87.1
+ *    Ok, added some minimal floating point support, which means this
+ *    probably requires libm on most operating systems.  Don't yet
+ *    support the exponent (e,E) and sigfig (g,G).  Also, fmtint()
+ *    was pretty badly broken, it just wasn't being exercised in ways
+ *    which showed it, so that's been fixed.  Also, formated the code
+ *    to mutt conventions, and removed dead code left over from the
+ *    original.  Also, there is now a builtin-test, just compile with:
+ *           gcc -DTEST_SNPRINTF -o snprintf snprintf.c -lm
+ *    and run snprintf for results.
+ * 
+ *  Thomas Roessler <roessler@guug.de> 01/27/98 for mutt 0.89i
+ *    The PGP code was using unsigned hexadecimal formats. 
+ *    Unfortunately, unsigned formats simply didn't work.
+ *
+ *  Michael Elkins <me@cs.hmc.edu> 03/05/98 for mutt 0.90.8
+ *    The original code assumed that both snprintf() and vsnprintf() were
+ *    missing.  Some systems only have snprintf() but not vsnprintf(), so
+ *    the code is now broken down under HAVE_SNPRINTF and HAVE_VSNPRINTF.
+ *
+ *  Andrew Tridgell (tridge@samba.org) Oct 1998
+ *    fixed handling of %.0f
+ *    added test for HAVE_LONG_DOUBLE
+ *
+ *  Chris Kirmse (ckirmse@yahoo.com) May 2003
+ *    fixed handling of leading zeros in the fractional part of a float.
+ *
+ **************************************************************/
+
+/* #include "config.h" */
+#define HAVE_STDARG_H
+
+/* moved above the #ifdef to avoid warning about empty c-files */
+#include <string.h>
+#include <ctype.h>
+#include <sys/types.h>
+
+#if !defined(HAVE_SNPRINTF) || !defined(HAVE_VSNPRINTF)
+
+
+/* Define this as a fall through, HAVE_STDARG_H is probably already set */
+#define HAVE_VARARGS_H
+
+
+/* varargs declarations: */
+
+#if defined(HAVE_STDARG_H)
+# include <stdarg.h>
+# define HAVE_STDARGS    /* let's hope that works everywhere (mj) */
+# define VA_LOCAL_DECL   va_list ap
+# define VA_START(f)     va_start(ap, f)
+# define VA_SHIFT(v,t)  ;   /* no-op for ANSI */
+# define VA_END          va_end(ap)
+#else
+# if defined(HAVE_VARARGS_H)
+#  include <varargs.h>
+#  undef HAVE_STDARGS
+#  define VA_LOCAL_DECL   va_list ap
+#  define VA_START(f)     va_start(ap)      /* f is ignored! */
+#  define VA_SHIFT(v,t) v = va_arg(ap,t)
+#  define VA_END        va_end(ap)
+# else
+/*XX ** NO VARARGS ** XX*/
+# endif
+#endif
+
+#ifdef HAVE_LONG_DOUBLE
+#define LDOUBLE long double
+#else
+#define LDOUBLE double
+#endif
+
+int snprintf (char *str, size_t count, const char *fmt, ...);
+int vsnprintf (char *str, size_t count, const char *fmt, va_list arg);
+
+static void dopr (char *buffer, size_t maxlen, const char *format, 
+		va_list args);
+static void fmtstr (char *buffer, size_t *currlen, size_t maxlen,
+		char *value, int flags, int min, int max);
+static void fmtint (char *buffer, size_t *currlen, size_t maxlen,
+		long value, int base, int min, int max, int flags);
+static void fmtfp (char *buffer, size_t *currlen, size_t maxlen,
+		LDOUBLE fvalue, int min, int max, int flags);
+static void dopr_outch (char *buffer, size_t *currlen, size_t maxlen, char c );
+
+/*
+ * dopr(): poor man's version of doprintf
+ */
+
+/* format read states */
+#define DP_S_DEFAULT 0
+#define DP_S_FLAGS   1
+#define DP_S_MIN     2
+#define DP_S_DOT     3
+#define DP_S_MAX     4
+#define DP_S_MOD     5
+#define DP_S_CONV    6
+#define DP_S_DONE    7
+
+/* format flags - Bits */
+#define DP_F_MINUS 	(1 << 0)
+#define DP_F_PLUS  	(1 << 1)
+#define DP_F_SPACE 	(1 << 2)
+#define DP_F_NUM   	(1 << 3)
+#define DP_F_ZERO  	(1 << 4)
+#define DP_F_UP    	(1 << 5)
+#define DP_F_UNSIGNED 	(1 << 6)
+
+/* Conversion Flags */
+#define DP_C_SHORT   1
+#define DP_C_LONG    2
+#define DP_C_LDOUBLE 3
+
+#define char_to_int(p) (p - '0')
+#define MAX(p,q) ((p >= q) ? p : q)
+
+static void dopr (char *buffer, size_t maxlen, const char *format, va_list args)
+{
+	char ch;
+	long value;
+	LDOUBLE fvalue;
+	char *strvalue;
+	int min;
+	int max;
+	int state;
+	int flags;
+	int cflags;
+	size_t currlen;
+
+	state = DP_S_DEFAULT;
+	currlen = flags = cflags = min = 0;
+	max = -1;
+	ch = *format++;
+
+	while (state != DP_S_DONE)
+	{
+		if ((ch == '\0') || (currlen >= maxlen)) 
+			state = DP_S_DONE;
+
+		switch(state) 
+		{
+			case DP_S_DEFAULT:
+				if (ch == '%') 
+					state = DP_S_FLAGS;
+				else 
+					dopr_outch (buffer, &currlen, maxlen, ch);
+				ch = *format++;
+				break;
+			case DP_S_FLAGS:
+				switch (ch) 
+				{
+					case '-':
+						flags |= DP_F_MINUS;
+						ch = *format++;
+						break;
+					case '+':
+						flags |= DP_F_PLUS;
+						ch = *format++;
+						break;
+					case ' ':
+						flags |= DP_F_SPACE;
+						ch = *format++;
+						break;
+					case '#':
+						flags |= DP_F_NUM;
+						ch = *format++;
+						break;
+					case '0':
+						flags |= DP_F_ZERO;
+						ch = *format++;
+						break;
+					default:
+						state = DP_S_MIN;
+						break;
+				}
+				break;
+			case DP_S_MIN:
+				if (isdigit(ch)) 
+				{
+					min = 10*min + char_to_int (ch);
+					ch = *format++;
+				} 
+				else if (ch == '*') 
+				{
+					min = va_arg (args, int);
+					ch = *format++;
+					state = DP_S_DOT;
+				} 
+				else 
+					state = DP_S_DOT;
+				break;
+			case DP_S_DOT:
+				if (ch == '.') 
+				{
+					state = DP_S_MAX;
+					ch = *format++;
+				} 
+				else 
+					state = DP_S_MOD;
+				break;
+			case DP_S_MAX:
+				if (isdigit(ch)) 
+				{
+					if (max < 0)
+						max = 0;
+					max = 10*max + char_to_int (ch);
+					ch = *format++;
+				} 
+				else if (ch == '*') 
+				{
+					max = va_arg (args, int);
+					ch = *format++;
+					state = DP_S_MOD;
+				} 
+				else 
+					state = DP_S_MOD;
+				break;
+			case DP_S_MOD:
+				/* Currently, we don't support Long Long, bummer */
+				switch (ch) 
+				{
+					case 'h':
+						cflags = DP_C_SHORT;
+						ch = *format++;
+						break;
+					case 'l':
+						cflags = DP_C_LONG;
+						ch = *format++;
+						break;
+					case 'L':
+						cflags = DP_C_LDOUBLE;
+						ch = *format++;
+						break;
+					default:
+						break;
+				}
+				state = DP_S_CONV;
+				break;
+			case DP_S_CONV:
+				switch (ch) 
+				{
+					case 'd':
+					case 'i':
+						if (cflags == DP_C_SHORT) 
+							value = va_arg (args, int);
+						else if (cflags == DP_C_LONG)
+							value = va_arg (args, long int);
+						else
+							value = va_arg (args, int);
+						fmtint (buffer, &currlen, maxlen, value, 10, min, max, flags);
+						break;
+					case 'o':
+						flags |= DP_F_UNSIGNED;
+						if (cflags == DP_C_SHORT)
+							value = va_arg (args, unsigned int);
+						else if (cflags == DP_C_LONG)
+							value = va_arg (args, unsigned long int);
+						else
+							value = va_arg (args, unsigned int);
+						fmtint (buffer, &currlen, maxlen, value, 8, min, max, flags);
+						break;
+					case 'u':
+						flags |= DP_F_UNSIGNED;
+						if (cflags == DP_C_SHORT)
+							value = va_arg (args, unsigned int);
+						else if (cflags == DP_C_LONG)
+							value = va_arg (args, unsigned long int);
+						else
+							value = va_arg (args, unsigned int);
+						fmtint (buffer, &currlen, maxlen, value, 10, min, max, flags);
+						break;
+					case 'X':
+						flags |= DP_F_UP;
+					case 'x':
+						flags |= DP_F_UNSIGNED;
+						if (cflags == DP_C_SHORT)
+							value = va_arg (args, unsigned int);
+						else if (cflags == DP_C_LONG)
+							value = va_arg (args, unsigned long int);
+						else
+							value = va_arg (args, unsigned int);
+						fmtint (buffer, &currlen, maxlen, value, 16, min, max, flags);
+						break;
+					case 'f':
+						if (cflags == DP_C_LDOUBLE)
+							fvalue = va_arg (args, LDOUBLE);
+						else
+							fvalue = va_arg (args, double);
+						/* um, floating point? */
+						fmtfp (buffer, &currlen, maxlen, fvalue, min, max, flags);
+						break;
+					case 'E':
+						flags |= DP_F_UP;
+					case 'e':
+						if (cflags == DP_C_LDOUBLE)
+							fvalue = va_arg (args, LDOUBLE);
+						else
+							fvalue = va_arg (args, double);
+						break;
+					case 'G':
+						flags |= DP_F_UP;
+					case 'g':
+						if (cflags == DP_C_LDOUBLE)
+							fvalue = va_arg (args, LDOUBLE);
+						else
+							fvalue = va_arg (args, double);
+						break;
+					case 'c':
+						dopr_outch (buffer, &currlen, maxlen, va_arg (args, int));
+						break;
+					case 's':
+						strvalue = va_arg (args, char *);
+						if (max < 0) 
+							max = maxlen; /* ie, no max */
+						fmtstr (buffer, &currlen, maxlen, strvalue, flags, min, max);
+						break;
+					case 'p':
+						strvalue = va_arg (args, void *);
+						fmtint (buffer, &currlen, maxlen, (long) strvalue, 16, min, max, flags);
+						break;
+					case 'n':
+						if (cflags == DP_C_SHORT) 
+						{
+							short int *num;
+							num = va_arg (args, short int *);
+							*num = currlen;
+						} 
+						else if (cflags == DP_C_LONG) 
+						{
+							long int *num;
+							num = va_arg (args, long int *);
+							*num = currlen;
+						} 
+						else 
+						{
+							int *num;
+							num = va_arg (args, int *);
+							*num = currlen;
+						}
+						break;
+					case '%':
+						dopr_outch (buffer, &currlen, maxlen, ch);
+						break;
+					case 'w':
+						/* not supported yet, treat as next char */
+						ch = *format++;
+						break;
+					default:
+						/* Unknown, skip */
+						break;
+				}
+				ch = *format++;
+				state = DP_S_DEFAULT;
+				flags = cflags = min = 0;
+				max = -1;
+				break;
+			case DP_S_DONE:
+				break;
+			default:
+				/* hmm? */
+				break; /* some picky compilers need this */
+		}
+	}
+	if (currlen < maxlen - 1) 
+		buffer[currlen] = '\0';
+	else 
+		buffer[maxlen - 1] = '\0';
+}
+
+static void fmtstr (char *buffer, size_t *currlen, size_t maxlen,
+		char *value, int flags, int min, int max)
+{
+	int padlen, strln;     /* amount to pad */
+	int cnt = 0;
+
+	if (value == 0)
+	{
+		value = "<NULL>";
+	}
+
+	for (strln = 0; value[strln]; ++strln); /* strlen */
+	padlen = min - strln;
+	if (padlen < 0) 
+		padlen = 0;
+	if (flags & DP_F_MINUS) 
+		padlen = -padlen; /* Left Justify */
+
+	while ((padlen > 0) && (cnt < max)) 
+	{
+		dopr_outch (buffer, currlen, maxlen, ' ');
+		--padlen;
+		++cnt;
+	}
+	while (*value && (cnt < max)) 
+	{
+		dopr_outch (buffer, currlen, maxlen, *value++);
+		++cnt;
+	}
+	while ((padlen < 0) && (cnt < max)) 
+	{
+		dopr_outch (buffer, currlen, maxlen, ' ');
+		++padlen;
+		++cnt;
+	}
+}
+
+/* Have to handle DP_F_NUM (ie 0x and 0 alternates) */
+
+static void fmtint (char *buffer, size_t *currlen, size_t maxlen,
+		long value, int base, int min, int max, int flags)
+{
+	int signvalue = 0;
+	unsigned long uvalue;
+	char convert[20];
+	int place = 0;
+	int spadlen = 0; /* amount to space pad */
+	int zpadlen = 0; /* amount to zero pad */
+	int caps = 0;
+
+	if (max < 0)
+		max = 0;
+
+	uvalue = value;
+
+	if(!(flags & DP_F_UNSIGNED))
+	{
+		if( value < 0 ) {
+			signvalue = '-';
+			uvalue = -value;
+		}
+		else
+			if (flags & DP_F_PLUS)  /* Do a sign (+/i) */
+				signvalue = '+';
+			else
+				if (flags & DP_F_SPACE)
+					signvalue = ' ';
+	}
+
+	if (flags & DP_F_UP) caps = 1; /* Should characters be upper case? */
+
+	do {
+		convert[place++] =
+			(caps? "0123456789ABCDEF":"0123456789abcdef")
+			[uvalue % (unsigned)base  ];
+		uvalue = (uvalue / (unsigned)base );
+	} while(uvalue && (place < 20));
+	if (place == 20) place--;
+	convert[place] = 0;
+
+	zpadlen = max - place;
+	spadlen = min - MAX (max, place) - (signvalue ? 1 : 0);
+	if (zpadlen < 0) zpadlen = 0;
+	if (spadlen < 0) spadlen = 0;
+	if (flags & DP_F_ZERO)
+	{
+		zpadlen = MAX(zpadlen, spadlen);
+		spadlen = 0;
+	}
+	if (flags & DP_F_MINUS) 
+		spadlen = -spadlen; /* Left Justifty */
+
+#ifdef DEBUG_SNPRINTF
+	dprint (1, (debugfile, "zpad: %d, spad: %d, min: %d, max: %d, place: %d\n",
+				zpadlen, spadlen, min, max, place));
+#endif
+
+	/* Spaces */
+	while (spadlen > 0) 
+	{
+		dopr_outch (buffer, currlen, maxlen, ' ');
+		--spadlen;
+	}
+
+	/* Sign */
+	if (signvalue) 
+		dopr_outch (buffer, currlen, maxlen, signvalue);
+
+	/* Zeros */
+	if (zpadlen > 0) 
+	{
+		while (zpadlen > 0)
+		{
+			dopr_outch (buffer, currlen, maxlen, '0');
+			--zpadlen;
+		}
+	}
+
+	/* Digits */
+	while (place > 0) 
+		dopr_outch (buffer, currlen, maxlen, convert[--place]);
+
+	/* Left Justified spaces */
+	while (spadlen < 0) {
+		dopr_outch (buffer, currlen, maxlen, ' ');
+		++spadlen;
+	}
+}
+
+static LDOUBLE abs_val (LDOUBLE value)
+{
+	LDOUBLE result = value;
+
+	if (value < 0)
+		result = -value;
+
+	return result;
+}
+
+static LDOUBLE pow10 (int exp)
+{
+	LDOUBLE result = 1;
+
+	while (exp)
+	{
+		result *= 10;
+		exp--;
+	}
+
+	return result;
+}
+
+static long round (LDOUBLE value)
+{
+	long intpart;
+
+	intpart = value;
+	value = value - intpart;
+	if (value >= 0.5)
+		intpart++;
+
+	return intpart;
+}
+
+static void fmtfp (char *buffer, size_t *currlen, size_t maxlen,
+		LDOUBLE fvalue, int min, int max, int flags)
+{
+	int signvalue = 0;
+	LDOUBLE ufvalue;
+	char iconvert[20];
+	char fconvert[20];
+	int iplace = 0;
+	int fplace = 0;
+	int padlen = 0; /* amount to pad */
+	int zpadlen = 0; 
+	int caps = 0;
+	long intpart;
+	long fracpart;
+
+	/* 
+	 * AIX manpage says the default is 0, but Solaris says the default
+	 * is 6, and sprintf on AIX defaults to 6
+	 */
+	if (max < 0)
+		max = 6;
+
+	ufvalue = abs_val (fvalue);
+
+	if (fvalue < 0)
+		signvalue = '-';
+	else
+		if (flags & DP_F_PLUS)  /* Do a sign (+/i) */
+			signvalue = '+';
+		else
+			if (flags & DP_F_SPACE)
+				signvalue = ' ';
+
+#if 0
+	if (flags & DP_F_UP) caps = 1; /* Should characters be upper case? */
+#endif
+
+	intpart = ufvalue;
+
+	/* 
+	 * Sorry, we only support 9 digits past the decimal because of our 
+	 * conversion method
+	 */
+	if (max > 9)
+		max = 9;
+
+	/* We "cheat" by converting the fractional part to integer by
+	 * multiplying by a factor of 10
+	 */
+	fracpart = round ((pow10 (max)) * (ufvalue - intpart));
+
+	if (fracpart >= pow10 (max))
+	{
+		intpart++;
+		fracpart -= pow10 (max);
+	}
+
+#ifdef DEBUG_SNPRINTF
+	dprint (1, (debugfile, "fmtfp: %f =? %d.%d\n", fvalue, intpart, fracpart));
+#endif
+
+	/* Convert integer part */
+	do {
+		iconvert[iplace++] =
+			(caps? "0123456789ABCDEF":"0123456789abcdef")[intpart % 10];
+		intpart = (intpart / 10);
+	} while(intpart && (iplace < 20));
+	if (iplace == 20) iplace--;
+	iconvert[iplace] = 0;
+
+	/* Convert fractional part */
+	do {
+		fconvert[fplace++] =
+			(caps? "0123456789ABCDEF":"0123456789abcdef")[fracpart % 10];
+		fracpart = (fracpart / 10);
+	} while(fracpart && (fplace < 20));
+	if (fplace == 20) fplace--;
+	fconvert[fplace] = 0;
+
+	/* -1 for decimal point, another -1 if we are printing a sign */
+	padlen = min - iplace - max - 1 - ((signvalue) ? 1 : 0); 
+	zpadlen = max - fplace;
+	if (zpadlen < 0)
+		zpadlen = 0;
+	if (padlen < 0) 
+		padlen = 0;
+	if (flags & DP_F_MINUS) 
+		padlen = -padlen; /* Left Justifty */
+
+	if ((flags & DP_F_ZERO) && (padlen > 0)) 
+	{
+		if (signvalue) 
+		{
+			dopr_outch (buffer, currlen, maxlen, signvalue);
+			--padlen;
+			signvalue = 0;
+		}
+		while (padlen > 0)
+		{
+			dopr_outch (buffer, currlen, maxlen, '0');
+			--padlen;
+		}
+	}
+	while (padlen > 0)
+	{
+		dopr_outch (buffer, currlen, maxlen, ' ');
+		--padlen;
+	}
+	if (signvalue) 
+		dopr_outch (buffer, currlen, maxlen, signvalue);
+
+	while (iplace > 0) 
+		dopr_outch (buffer, currlen, maxlen, iconvert[--iplace]);
+
+	/*
+	 * Decimal point.  This should probably use locale to find the correct
+	 * char to print out.
+	 */
+	if (max > 0)
+	{
+		int i;
+		dopr_outch (buffer, currlen, maxlen, '.');
+
+		/* print leading zeros of the fractional part */
+		for (i = 0; i < max - fplace; i++)
+		{
+			dopr_outch(buffer, currlen, maxlen, '0');
+			zpadlen--;
+		}
+
+		while (fplace > 0) 
+			dopr_outch (buffer, currlen, maxlen, fconvert[--fplace]);
+	}
+
+	while (zpadlen > 0)
+	{
+		dopr_outch (buffer, currlen, maxlen, '0');
+		--zpadlen;
+	}
+
+	while (padlen < 0) 
+	{
+		dopr_outch (buffer, currlen, maxlen, ' ');
+		++padlen;
+	}
+}
+
+static void dopr_outch (char *buffer, size_t *currlen, size_t maxlen, char c)
+{
+	if (*currlen < maxlen)
+		buffer[(*currlen)++] = c;
+}
+
+#ifndef HAVE_VSNPRINTF
+int vsnprintf (char *str, size_t count, const char *fmt, va_list args)
+{
+	str[0] = 0;
+	dopr(str, count, fmt, args);
+	return(strlen(str));
+}
+#endif /* !HAVE_VSNPRINTF */
+
+#ifndef HAVE_SNPRINTF
+/* VARARGS3 */
+#ifdef HAVE_STDARGS
+int snprintf (char *str,size_t count,const char *fmt,...)
+#else
+int snprintf (va_alist) va_dcl
+#endif
+{
+#ifndef HAVE_STDARGS
+	char *str;
+	size_t count;
+	char *fmt;
+#endif
+	VA_LOCAL_DECL;
+
+	VA_START (fmt);
+	VA_SHIFT (str, char *);
+	VA_SHIFT (count, size_t );
+	VA_SHIFT (fmt, char *);
+	(void) vsnprintf(str, count, fmt, ap);
+	VA_END;
+	return(strlen(str));
+}
+#endif /* !HAVE_SNPRINTF */
+
+#ifdef TEST_SNPRINTF
+#ifndef LONG_STRING
+#define LONG_STRING 1024
+#endif
+int main (void)
+{
+	char buf1[LONG_STRING];
+	char buf2[LONG_STRING];
+	char *fp_fmt[] = {
+		"%-1.5f",
+		"%1.5f",
+		"%123.9f",
+		"%10.5f",
+		"% 10.5f",
+		"%+22.9f",
+		"%+4.9f",
+		"%01.3f",
+		"%4f",
+		"%3.1f",
+		"%3.2f",
+		"%.0f",
+		"%.1f",
+		NULL
+	};
+	double fp_nums[] = { -1.5, 134.21, 91340.2, 341.1234, 0203.9, 0.96, 0.996, 
+		0.9996, 1.996, 4.136, 1.05, 0};
+		char *int_fmt[] = {
+			"%-1.5d",
+			"%1.5d",
+			"%123.9d",
+			"%5.5d",
+			"%10.5d",
+			"% 10.5d",
+			"%+22.33d",
+			"%01.3d",
+			"%4d",
+			NULL
+		};
+		long int_nums[] = { -1, 134, 91340, 341, 0203, 0};
+		int x, y;
+		int fail = 0;
+		int num = 0;
+
+		printf ("Testing snprintf format codes against system sprintf...\n");
+
+		for (x = 0; fp_fmt[x] != NULL ; x++)
+			for (y = 0; fp_nums[y] != 0 ; y++)
+			{
+				snprintf (buf1, sizeof (buf1), fp_fmt[x], fp_nums[y]);
+				sprintf (buf2, fp_fmt[x], fp_nums[y]);
+				if (strcmp (buf1, buf2))
+				{
+					printf("snprintf doesn't match Format: %s\n\tsnprintf = %s\n\tsprintf  = %s\n", 
+							fp_fmt[x], buf1, buf2);
+					fail++;
+				}
+				num++;
+			}
+
+		for (x = 0; int_fmt[x] != NULL ; x++)
+			for (y = 0; int_nums[y] != 0 ; y++)
+			{
+				snprintf (buf1, sizeof (buf1), int_fmt[x], int_nums[y]);
+				sprintf (buf2, int_fmt[x], int_nums[y]);
+				if (strcmp (buf1, buf2))
+				{
+					printf("snprintf doesn't match Format: %s\n\tsnprintf = %s\n\tsprintf  = %s\n", 
+							int_fmt[x], buf1, buf2);
+					fail++;
+				}
+				num++;
+			}
+		printf ("%d tests failed out of %d.\n", fail, num);
+}
+#endif /* SNPRINTF_TEST */
+
+#endif /* !HAVE_SNPRINTF */
diff --git a/src/unix/sound-drivers.old/aix.c b/src/unix/sound-drivers.old/aix.c
new file mode 100644
index 0000000..35f24cc
--- /dev/null
+++ b/src/unix/sound-drivers.old/aix.c
@@ -0,0 +1,136 @@
+/*
+* AIX dependent code
+*
+* Audio support by Chris Sharp <sharp@hursley.ibm.com>
+*
+*/
+
+#include "xmame.h"
+#include "sound.h"
+#include <stdio.h>
+#include <stdlib.h>
+#include <fcntl.h>
+#include <errno.h>
+#include <sys/stropts.h>
+#include <UMS/UMSAudioDevice.h>
+#include <UMS/UMSBAUDDevice.h>
+
+static int channels;
+static UMSAudioDeviceMClass audio_device_class;
+static UMSAudioDevice_ReturnCode rc;
+static UMSBAUDDevice audio_device;
+
+static Environment *ev;
+static UMSAudioTypes_Buffer buffer;
+static long samples_per_sec, bytes_per_sample;
+static long read_cnt, transferred_cnt;
+static long samples_read;
+static long samples_written;
+static long out_rate;
+static long left_gain, right_gain;
+
+static long flags;
+static UMSAudioDeviceMClass_ErrorCode audio_device_class_error;
+static char* error_string;
+static char* audio_formats_alias;
+static char* audio_inputs_alias;
+static char* audio_outputs_alias;
+static char* obyte_order;
+
+int sysdep_audio_init(void)
+{
+	struct itimerval        timer_value;
+	int 			i;
+	sound_8bit   = TRUE;
+	sound_stereo = FALSE;
+	
+	if (play_sound)
+	{
+		int supported=FALSE;
+		channels = 1;
+                fprintf(stderr_file, "AIX sound device initialization...\n");
+                /* try to open audio device */
+        	ev = somGetGlobalEnvironment();
+        	audio_device = UMSBAUDDeviceNew();
+
+        	rc = UMSAudioDevice_open(audio_device,ev,"/dev/paud0","PLAY", UMSAudioDevice_BlockingIO);
+        	if (audio_device == NULL)
+        	{
+        	fprintf(stderr_file,"can't create audio device object\nError: %s\n",error_string);
+        	exit(1);
+        	}
+
+    		rc = UMSAudioDevice_set_sample_rate(audio_device, ev, options.samplerate, &out_rate);
+    		rc = UMSAudioDevice_set_bits_per_sample(audio_device, ev, AUDIO_SAMPLE_BITS);
+    		rc = UMSAudioDevice_set_number_of_channels(audio_device, ev, channels);
+    		rc = UMSAudioDevice_set_audio_format_type(audio_device, ev, "PCM");
+    		rc = UMSAudioDevice_set_number_format(audio_device, ev, "TWOS_COMPLEMENT");
+    		rc = UMSAudioDevice_set_volume(audio_device, ev, 100);
+    		rc = UMSAudioDevice_set_balance(audio_device, ev, 0);
+
+    		rc = UMSAudioDevice_set_time_format(audio_device,ev,UMSAudioTypes_Bytes);
+
+    		if (obyte_order) free(obyte_order);
+    		rc = UMSAudioDevice_set_byte_order(audio_device, ev, "LSB");
+    		left_gain = 100;
+    		right_gain = 100;
+
+    		rc = UMSAudioDevice_enable_output(audio_device, ev, "LINE_OUT", &left_gain, &right_gain);
+    		rc = UMSAudioDevice_initialize(audio_device, ev);
+#ifdef USE_TIMER
+    		buffer._maximum = AUDIO_BUFF_SIZE;
+#else
+		buffer._maximum = sysdep_get_audio_freespace();
+#endif
+    		buffer._buffer  = (char *) malloc(AUDIO_BUFF_SIZE);
+    		buffer._length = 0;
+
+		/*
+    		bytes_per_sample = (AUDIO_SAMPLE_BITS / 8) * channels;
+    		samples_per_sec  = bytes_per_sample * out_rate;
+    		buffer._buffer  = (char *) malloc(samples_per_sec);
+    		buffer._length = 0;
+    		buffer._maximum = samples_per_sec;
+    		bbuf_size = buffer._maximum;
+		*/
+    		rc = UMSAudioDevice_start(audio_device, ev);
+        }
+        return OSD_OK;
+}
+
+void sysdep_audio_close(void) {
+	if (play_sound)
+	{
+          rc = UMSAudioDevice_play_remaining_data(audio_device, ev, TRUE);
+          UMSAudioDevice_stop(audio_device, ev);
+          UMSAudioDevice_close(audio_device, ev);
+          _somFree(audio_device);
+          free(buffer._buffer);
+	}
+}	
+
+int sysdep_audio_play(unsigned char *buf, int bufsize)
+{
+/* 
+ * not sure about if audio buffers in aix are signed or unsigned char.
+ * please, tester needed...
+ */
+	int i;
+        buffer._length = bufsize;
+#if 1
+	memcpy(buffer._buffer,buf,bufsize); /* unsigned buffer */
+#else
+	for (i=0;i<bufsize;i++) buffer._buffer[i] = buf[i]^0x80; /* signed one */
+#endif
+        rc = UMSAudioDevice_write(audio_device, ev, &buffer, bufsize, &samples_written);
+        return rc;
+}
+
+long sysdep_audio_get_freespace() {
+	int i;
+	rc = UMSAudioDevice_write_buff_remain(audio_device,ev,&i);
+	i = i/96; /* ??? */
+	if (i<0) return (0);
+	/* fprintf(stderr_file,"Audio Buffer remains: %d\n blocks",i); */
+	return (long)(i);
+}
diff --git a/src/unix/sound-drivers.old/irix.c b/src/unix/sound-drivers.old/irix.c
new file mode 100644
index 0000000..23b254f
--- /dev/null
+++ b/src/unix/sound-drivers.old/irix.c
@@ -0,0 +1,168 @@
+/*
+ * IRIX sound code
+ * 
+ * Addition of new al stuff by Tristram Scott 23/9/98
+ * 
+ */
+#include "xmame.h"
+#include "sound.h"
+#include <sys/stropts.h>
+#include <dmedia/audio.h>
+#include <errno.h>
+
+static ALport   devAudio;
+static ALconfig devAudioConfig;
+	
+int sysdep_audio_init(void) {
+#ifdef IRIX_HAVE_al
+	ALpv pvs[4];
+	int alIsBusy = 0;
+#else
+	long parambuf[4];
+#endif
+	sound_8bit	= TRUE;
+	sound_stereo	= FALSE;
+	
+	if (play_sound) {
+
+	    fprintf(stderr_file, "IRIX sound system initializing ...");
+
+#ifdef IRIX_HAVE_al
+	    /* first of all, look for anyone using driver */
+	    pvs[0].param = AL_MAX_PORTS;
+	    pvs[1].param = AL_UNUSED_PORTS;
+	    if( alGetParams( AL_SYSTEM,pvs,2) < 0) {
+		fprintf(stderr_file, "alGetParams failed: %s\n", alGetErrorString(oserror()));
+		exit(1);
+	    }
+	    fprintf(stderr_file, "Maximum audio port count is %d, current unused count is %d\n",
+	    	pvs[0].value.i,pvs[1].value.i);
+	    if( pvs[1].value.i < 1) {
+	        fprintf(stderr_file, "No unused audio ports, try using -nosound option\n");
+		exit(1); 
+	    }
+	    if( pvs[1].value.i < pvs[0].value.i) {
+	        fprintf(stderr_file, "Looks like someone else is using the audio device already.\n");
+		pvs[0].param = AL_RATE;
+		if( alGetParams( AL_DEFAULT_OUTPUT,pvs,1) < 0) {
+		    fprintf(stderr_file, "alGetParams failed: %s\n", alGetErrorString(oserror()));
+		    exit(1);
+		}
+		fprintf(stderr_file, "Current sample rate is %d, we will use that.\n", 
+		    pvs[0].value.i);
+		options.samplerate = pvs[0].value.i;
+		alIsBusy = 1;
+	    }
+
+	    /* try to get a configuration descriptor */
+	    if ( ( devAudioConfig=alNewConfig() ) == (ALconfig) NULL ){
+		fprintf(stderr_file, "Cannot get a config Descriptor.Exiting\n");
+		exit(1);
+	    }
+
+	    /* channel-specific parameters */	
+	    alSetChannels(devAudioConfig,AL_MONO); 		/* mono */
+	    alSetQueueSize(devAudioConfig,(int)AUDIO_BUFF_SIZE); /* buffer size */
+	    alSetSampFmt(devAudioConfig,AL_SAMPFMT_TWOSCOMP);	/* linear signed */
+	    alSetWidth(devAudioConfig,AL_SAMPLE_8);   	/* 8 bits */
+
+	    /* global audio-device parameters */
+
+	    pvs[0].param = AL_MASTER_CLOCK;
+	    pvs[0].value.i = AL_CRYSTAL_MCLK_TYPE;
+	    pvs[1].param = AL_RATE;
+	    pvs[1].value.i = options.samplerate; 
+ 
+	    if( !alIsBusy) {
+		if( alSetParams( AL_DEFAULT_OUTPUT,pvs,2) < 0) {
+		    fprintf(stderr_file, "Cannot Configure the sound system.Exiting...\n");
+		    exit(1);
+		}
+	    }
+
+	    /* try to get a Audio channel descriptor with pre-calculated params */
+	    if ( ( devAudio=alOpenPort("audio_fd","w",devAudioConfig) ) == (ALport) NULL ){
+		fprintf(stderr_file, "Cannot get an Audio Channel Descriptor.Exiting\n");
+		exit(1);
+	    }
+#else
+	    /* first of all, look for anyone using driver */
+	    parambuf[0] = AL_INPUT_COUNT;
+	    parambuf[2] = AL_OUTPUT_COUNT;
+	    ALgetparams( AL_DEFAULT_DEVICE,parambuf,4);
+	    if (parambuf[1] || parambuf[3]) {
+		fprintf(stderr_file, "Someone is already using the sound system.Exiting..\n");
+		exit(1);
+	    }
+
+	    /* try to get a configuration descriptor */
+	    if ( ( devAudioConfig=ALnewconfig() ) == (ALconfig) NULL ){
+		fprintf(stderr_file, "Cannot get a config Descriptor.Exiting\n");
+		exit(1);
+	    }
+
+	    /* channel-specific parameters */	
+	    ALsetchannels(devAudioConfig,AL_MONO); 		/* mono */
+	    ALsetqueuesize(devAudioConfig,(long)AUDIO_BUFF_SIZE); /* buffer size */
+	    ALsetsampfmt(devAudioConfig,AL_SAMPFMT_TWOSCOMP);	/* linear signed */
+	    ALsetwidth(devAudioConfig,AL_SAMPLE_8);   	/* 8 bits */
+
+	    /* global audio-device parameters */
+	    parambuf[0]	= AL_OUTPUT_RATE;	parambuf[1] =	options.samplerate;
+	    parambuf[2]	= AL_INPUT_RATE;	parambuf[3] =	options.samplerate;
+	    if( ALsetparams( AL_DEFAULT_DEVICE,parambuf,4) < 0) {
+		fprintf(stderr_file, "Cannot Configure the sound system.Exiting...\n");
+		exit(1);
+	    }
+
+	    /* try to get a Audio channel descriptor with pre-calculated params */
+	    if ( ( devAudio=ALopenport("audio_fd","w",devAudioConfig) ) == (ALport) NULL ){
+		fprintf(stderr_file, "Cannot get an Audio Channel Descriptor.Exiting\n");
+		exit(1);
+	    }
+
+#endif 
+	} /* if (play_sound) */
+	return OSD_OK;
+}
+
+void sysdep_audio_close(void) {
+#ifdef IRIX_HAVE_al
+	if(play_sound){
+		alClosePort(devAudio);
+		alFreeConfig(devAudioConfig);
+	}
+#else
+	if(play_sound){
+		ALcloseport(devAudio);
+		ALfreeconfig(devAudioConfig);
+	}
+#endif
+}	
+
+long sysdep_audio_get_freespace() {
+#ifdef IRIX_HAVE_al
+	return alGetFillable(devAudio);
+#else
+	return ALgetfillable(devAudio);
+#endif
+}
+
+/* routine to dump audio samples into audio device */
+int sysdep_audio_play(unsigned char *buff, int size) {
+#ifdef IRIX_HAVE_al
+	unsigned char *pt=buff;
+	/* try only to send samples that no cause blocking */
+        long maxsize=alGetFillable(devAudio);
+	/* new mixer code works in a unsigned char; driver is signed.... */
+	for (;pt<(buff+size);pt++) *pt ^=0x80;
+	return alWriteFrames(devAudio,(void *)buff,(size<=maxsize)?size:maxsize);	
+#else
+	unsigned char *pt=buff;
+	/* try only to send samples that no cause blocking */
+        long maxsize=ALgetfillable(devAudio);
+	/* new mixer code works in a unsigned char; driver is signed.... */
+	for (;pt<(buff+size);pt++) *pt ^=0x80;
+	return ALwritesamps(devAudio,(void *)buff,(size<=maxsize)?size:maxsize);	
+#endif
+}
diff --git a/src/unix/sound-drivers.old/netbsd.c b/src/unix/sound-drivers.old/netbsd.c
new file mode 100644
index 0000000..4d3703a
--- /dev/null
+++ b/src/unix/sound-drivers.old/netbsd.c
@@ -0,0 +1,235 @@
+/*
+ * NetBSD audio code by entropy@zippy.bernstein.com
+ * Audio code is based on the solaris driver, by jantonio@dit.upm.es
+ *
+ * fixed for 16bit & stereo sound by cpg@aladdin.de, 01-Aug-1999
+ * (tested on NetBSD/alpha and NetBSD/i386)
+ */
+
+#include "xmame.h"
+#include "sound.h"
+#include "devices.h"
+#include <stdio.h>
+#include <stdlib.h>
+#include <fcntl.h>
+#include <sys/ioctl.h>
+#include <sys/types.h>
+#include <sys/audioio.h>
+static int audio_fd;
+static char msg_buf[80];
+static audio_info_t a_info;
+static audio_device_t a_dev;
+static int card_stereo; /* card is a stereo card */
+static int setfragment(int,int *);
+static void setblocksize(int,struct audio_info *);
+
+int sysdep_audio_init(void)
+{
+  int log_2_frag, frag;
+  int corrected_frag_size;
+
+  if (play_sound)
+  {
+    fprintf(stderr_file, "NetBSD sound device initialization...\n");
+    /* try to open audio device */
+    if ((audio_fd = open("/dev/audio", O_WRONLY /* | O_NDELAY*/)) < 0)
+    {
+      perror("Cannot open audio device");
+      play_sound = FALSE;
+    }
+    else
+    {
+      /* empty buffers before change config */
+      ioctl(audio_fd, AUDIO_FLUSH, 0);        /* flush everything */
+      
+      /* identify audio device. */
+      if(ioctl(audio_fd, AUDIO_GETDEV, &a_dev) < 0)
+      {
+	perror("Cannot get sound device type");
+	close(audio_fd);
+	play_sound = FALSE;
+      }
+      else
+      {
+	fprintf(stderr_file, "Sound device is a %s %s version %s\n",
+	       a_dev.config, a_dev.name, a_dev.version);
+	    
+	/* initialize audio parameters. */ 
+	AUDIO_INITINFO(&a_info);
+        if (ioctl(audio_fd, AUDIO_GETINFO, &a_info) < 0) {
+          fprintf(stderr_file,"cannot query audio device parameters: %s\n",strerror(errno));
+        err_ret:
+          close(audio_fd);
+          play_sound = FALSE;
+          return OSD_OK;
+        }
+
+        if (a_info.play.channels == 1) {
+          a_info.play.channels = 2; /* try to set stereo */
+          if (ioctl(audio_fd, AUDIO_SETINFO, &a_info) < 0) {
+            a_info.play.channels = 1;
+          }
+        }
+
+        if (a_info.play.channels == 2) {
+          card_stereo = TRUE;
+        }
+        else {
+          card_stereo = FALSE;
+        }
+
+        if (!sound_8bit) { /* force from command line */
+          AUDIO_INITINFO(&a_info);
+          a_info.play.encoding = AUDIO_ENCODING_SLINEAR_LE;
+          a_info.play.precision = 16;
+          sound_8bit = FALSE;
+          if (ioctl(audio_fd, AUDIO_SETINFO, &a_info) < 0) {
+            sound_8bit = TRUE;
+          }
+        }
+        if (sound_8bit) {
+          a_info.play.encoding = (uint) AUDIO_ENCODING_ULINEAR;
+          a_info.play.precision = (uint) 8;
+        }
+
+	AUDIO_INITINFO(&a_info);
+        if (sound_8bit) {
+          a_info.play.encoding = (uint) AUDIO_ENCODING_ULINEAR;
+          a_info.play.precision = (uint) 8;
+        }
+        else {
+          a_info.play.encoding = (uint) AUDIO_ENCODING_SLINEAR_LE;
+          a_info.play.precision = (uint) 16;
+        }
+        if (sound_stereo && card_stereo) {
+          a_info.play.channels = 2;
+        }
+        else {
+          a_info.play.channels = 1;
+          sound_stereo = FALSE;
+        }
+	a_info.play.sample_rate = (uint) options.samplerate;
+	a_info.blocksize = options.samplerate / AUDIO_TIMER_FREQ;
+	a_info.mode = AUMODE_PLAY | AUMODE_PLAY_ALL;
+
+        if (ioctl(audio_fd, AUDIO_SETINFO, &a_info) < 0) {
+          fprintf(stderr_file,"cannot set audio device parameters: %s\n",strerror(errno));
+          goto err_ret;
+        }
+
+	corrected_frag_size = (options.samplerate * frag_size) / 22050;
+	if (!sound_8bit)  corrected_frag_size *= 2;
+	if (sound_stereo) corrected_frag_size *= 2;
+	for (log_2_frag=0; (1 << log_2_frag) < corrected_frag_size; log_2_frag++) {}
+	frag = log_2_frag + (num_frags << 16);
+
+        snprintf(msg_buf,sizeof(msg_buf)-1,"Setting fragsize to %d, numfrags to %d",
+                 1 << (frag&0x0000FFFF), frag >> 16);
+
+	if (setfragment(audio_fd,&frag) < 0) {
+          fprintf(stderr_file,"%s\nSNDCTL_DSP_SETFRAGMENT: %s\n",msg_buf,strerror(errno));
+          goto err_ret;
+	}
+
+#ifndef USE_TIMER
+        if (ioctl(audio_fd, AUDIO_GETINFO, &a_info) < 0) {
+          perror("AUDIO_GETINFO");
+          goto err_ret;
+        }
+        setblocksize(audio_fd, &a_info);
+        frag_size = a_info.blocksize;
+        num_frags = a_info.play.buffer_size / frag_size;
+
+        /* hmm, tests have shown that num_frags > 6 are no good,
+         * so we force them here into this limit...
+         */
+        if (num_frags > 6) {
+          fprintf(stderr_file,"Warning: frags reduced from %d to 6\n",num_frags);
+          num_frags = 6;
+
+          frag = log_2_frag + (num_frags << 16);
+          snprintf(msg_buf,sizeof(msg_buf)-1,"Setting fragsize to %d, numfrags to %d",
+                   1 << (frag&0x0000FFFF), frag >> 16);
+          setfragment(audio_fd,&frag);
+        }
+        /* fprintf(stderr_file,"Fragsize = %d, Numfrags = %d\n", frag_size, num_frags); */
+#endif
+        fprintf(stderr_file,"%s\n",msg_buf);
+	fprintf(stderr_file,"Audio device %s set to %dbit linear %s %dHz\n",
+                audiodevice,(sound_8bit)? 8:16,
+                (sound_stereo)? "stereo":"mono",
+                options.samplerate);
+      }
+    }
+  }
+  return OSD_OK;
+}
+
+static void setblocksize(int fd, struct audio_info *info) /* from netbsd's ossaudio lib */
+{
+  struct audio_info set;
+  int s;
+
+  if (info->blocksize & (info->blocksize-1)) {
+    for(s = 32; s < info->blocksize; s <<= 1)
+      ;
+    AUDIO_INITINFO(&set);
+    set.blocksize = s;
+    ioctl(fd, AUDIO_SETINFO, &set);
+    ioctl(fd, AUDIO_GETINFO, info);
+  }
+}
+
+
+static int setfragment(int fd,int *frag) /* from netbsd's ossaudio lib */
+{
+  audio_info_t tmpinfo;
+  unsigned int u;
+  int idat;
+  int retval;
+
+  AUDIO_INITINFO(&tmpinfo);
+  idat = *frag;
+  if ((idat & 0xffff) < 4 || (idat & 0xffff) > 17)
+    return (EINVAL);
+  tmpinfo.blocksize = 1 << (idat & 0xffff);
+  tmpinfo.hiwat = (idat >> 16) & 0x7fff;
+  if (tmpinfo.hiwat == 0) /* 0 means set to max */
+    tmpinfo.hiwat = 65536;
+  (void) ioctl(fd, AUDIO_SETINFO, &tmpinfo);
+  retval = ioctl(fd, AUDIO_GETINFO, &tmpinfo);
+  if (retval < 0)
+    return (retval);
+  u = tmpinfo.blocksize;
+  for(idat = 0; u > 1; idat++, u >>= 1)
+                        ;
+  idat |= (tmpinfo.hiwat & 0x7fff) << 16;
+  *frag = idat;
+  return(0);
+}
+
+void sysdep_audio_close(void)
+{
+  if (play_sound) close(audio_fd);
+}
+
+int sysdep_audio_play(unsigned char *buf, int bufsize)
+{
+  return write(audio_fd, buf, bufsize);
+}
+
+long sysdep_audio_get_freespace()
+{
+#ifndef USE_TIMER
+       audio_info_t info;
+       int i;
+       long l;
+        AUDIO_INITINFO(&info);
+        i = ioctl(audio_fd,AUDIO_GETINFO,&info);
+       if (i<0) { perror("AUDIO_GETINFO"); return -1; }
+       l = AUDIO_BUFF_SIZE - info.play.seek;
+       return (l < 0) ? 0 : l;
+#else 
+       return 0;
+#endif   
+}
diff --git a/src/unix/sound-drivers.old/nosound.c b/src/unix/sound-drivers.old/nosound.c
new file mode 100644
index 0000000..7073620
--- /dev/null
+++ b/src/unix/sound-drivers.old/nosound.c
@@ -0,0 +1,22 @@
+#include "xmame.h"
+#include "sound.h"
+
+int sysdep_audio_init(void)
+{
+   play_sound = FALSE;
+   return OSD_OK;
+}
+
+void sysdep_audio_close(void)
+{
+}
+
+int sysdep_audio_play(unsigned char *buf, int bufsize)
+{
+   return 0;
+}
+
+long sysdep_audio_get_freespace(void)
+{
+   return 0;
+}
diff --git a/src/unix/sound-drivers.old/solaris.c b/src/unix/sound-drivers.old/solaris.c
new file mode 100644
index 0000000..362ec84
--- /dev/null
+++ b/src/unix/sound-drivers.old/solaris.c
@@ -0,0 +1,140 @@
+/*
+* Solaris dependent code
+*
+* Preliminary audio support by jantonio@dit.upm.es
+* no control on mono/stereo output channel and so  (yet)
+*
+*Major rewrite by Keith Hargrove condor@sun.com
+*       This is my first pass at this
+*       I use the EOF counter to keep track of how
+*       data has been played
+*
+*       The whole sound system needs to be rewiten as a thread
+*       This would give better performace and perfect sound
+*       This code is more of a band-aid
+*       I did not add support for the old ss1 and ss2 audio
+*       I don't think that a ss1 or ss2 can run MAME
+*       unless somone is using an ss2 with the turbo chip??
+*       if there is a need it can be added
+*
+* 990326 merged in Solaris x86 sound. Mathis Rosenhauer
+*
+*/
+
+#include <sys/stropts.h>
+#include <sys/audioio.h>
+#include "xmame.h"
+#include "sound.h"
+
+static int audioctl_fd;     /* audio control device for solaris     */
+static int audio_fd;        /* audio device for solaris             */
+static int written = 0;     /* number of bytes written              */
+static int sample_size;
+static int buffer_size;
+
+static audio_info_t	a_info;   /* info about audio settings            */
+static audio_device_t a_dev;  /* info about audio hardware            */
+
+int sysdep_audio_init(void)
+{
+	int error;
+
+	if (play_sound)
+	{
+		fprintf(stderr_file, "Solaris sound device initialization...\n");
+		/* try to open audio device */
+		if ( (audio_fd = open("/dev/audio", O_WRONLY | O_NDELAY)) < 0)
+		{
+			fprintf(stderr_file, "couldn't open audio device\n");
+			return OSD_NOT_OK;
+		}
+		/* try to open audioctl device */
+		if ( (audioctl_fd = open("/dev/audioctl", O_RDWR )) < 0)
+		{
+			fprintf(stderr_file, "couldn't open audioctl device\n");
+			close(audio_fd);
+			return OSD_NOT_OK;
+		}
+		sleep(2);
+		
+		/* empty buffers before change config */
+		ioctl(audio_fd, AUDIO_DRAIN, 0);    /* drain everything out */
+		ioctl(audio_fd, I_FLUSH, FLUSHRW);  /* flush everything     */
+		ioctl(audioctl_fd, I_FLUSH, FLUSHRW);   /* flush everything */
+		
+		/* identify audio device. if AMD chipset, bad, luck :-( */
+		if(ioctl(audio_fd, AUDIO_GETDEV, &a_dev) < 0)
+		{
+			fprintf(stderr_file, "Cannot get sound device type\n");
+			close(audio_fd);
+			close(audioctl_fd);
+			return OSD_NOT_OK;
+		}
+
+		fprintf(stderr_file, "Sound device is a %s %s version %s\n",a_dev.config,a_dev.name,a_dev.version);
+		
+		/* get audio parameters. */
+		if (ioctl(audioctl_fd, AUDIO_GETINFO, &a_info) < 0)
+		{
+			fprintf(stderr_file, "AUDIO_GETINFO failed!\nRun with -nosound\n");
+			close(audio_fd);
+			close(audioctl_fd);
+			return OSD_NOT_OK;
+		}
+
+		AUDIO_INITINFO(&a_info);
+		a_info.play.precision   = sound_8bit? 8: 16;
+		a_info.play.channels    = sound_stereo? 2: 1;
+		a_info.play.sample_rate = options.samplerate;
+		a_info.play.encoding    = AUDIO_ENCODING_LINEAR;
+		sample_size = a_info.play.precision / 8;
+		a_info.play.buffer_size = buffer_size = sample_size*frag_size*num_frags;
+
+		if ((error = ioctl(audio_fd,AUDIO_SETINFO,&a_info)) < 0 )
+		{
+			fprintf(stderr_file, "Error %d: audio device parameters not supported\n", error);
+			fprintf(stderr_file, "Enter 'man %s' to see parameters supported by your audio device.\n", (strchr(a_dev.name,','))+1);
+			sleep(2);
+			close(audio_fd);
+			close(audioctl_fd);
+			return OSD_NOT_OK;
+		}
+	}
+	return OSD_OK;
+}
+
+void sysdep_audio_close(void)
+{
+	if (play_sound)
+	{
+		close(audio_fd);
+		close(audioctl_fd);
+	}
+}
+
+int sysdep_audio_play(unsigned char *buf, int bufsize)
+{
+	static unsigned char tmp_buf[512];
+	static int  j = 0;
+    int i;
+
+	for (i = 0; i < bufsize; i++)
+	{
+		tmp_buf[j++] = buf[i];
+		if(j == 512 )
+		{
+			write(audio_fd, tmp_buf, j);
+			written += j;
+			/* write eof */
+			write(audio_fd, tmp_buf, 0);
+			j = 0;
+		}
+	}
+	return bufsize;
+}
+
+long sysdep_audio_get_freespace(void)
+{
+	ioctl (audioctl_fd, AUDIO_GETINFO, &a_info);
+	return ((buffer_size - (written - a_info.play.eof * 512))/sample_size);
+}
diff --git a/src/unix/sound-drivers.old/soundkit.m b/src/unix/sound-drivers.old/soundkit.m
new file mode 100644
index 0000000..911aa3b
--- /dev/null
+++ b/src/unix/sound-drivers.old/soundkit.m
@@ -0,0 +1,227 @@
+/*
+ * SoundKit support for xmame. This code is held here rather than in the
+ * OpenStep display file because it is not strictly OpenStep code and thus
+ * is only really applicable to NeXT/Apple operating systems. Not that I really
+ * expect anyone to try and run it elsewhere, but you should try and do these
+ * things right after all !
+ *
+ * -bat. 11/1/1999
+ */
+
+#import <SoundKit/SoundKit.h>
+#import <libc.h>
+#import "xmame.h"
+#import "sound.h"
+#import "osdepend.h"
+#import "driver.h"
+
+/*
+ * Variables used by the sound code.
+ */
+
+static NXSoundOut *sound = nil;
+static NXPlayStream *stream = nil;
+static NSLock *queue_lock = nil;
+static int queued = 0;
+
+/*
+ * This is the delegate object for the sound kit. It is used to keep
+ * track of the number of queued packets for the sound device by collecting
+ * the "complete" messages. Sometimes these get lost though for some reason.
+ */
+
+@interface Delegate : NSObject
+- soundStream:sender didCompleteBuffer:(int)tag;
+- soundStreamDidAbort:sender deviceReserved:(BOOL)flag;
+@end
+
+@implementation Delegate
+
+/*
+ * Decrement the number of queued buffers
+ */
+
+- soundStream:sender didCompleteBuffer:(int)tag
+{
+	[queue_lock lock];
+	queued--;
+	[queue_lock unlock];
+	return self;
+}
+
+/*
+ * Deal with an aborted sound stream
+ */
+
+- soundStreamDidAbort:sender deviceReserved:(BOOL)flag;
+{
+	fprintf(stderr,"Sound stream aborted: ");
+	if(flag!=YES) 
+		fprintf(stderr,"Device reserved\n");
+	else
+		fprintf(stderr,"%s\n",
+		[[NXSoundDevice textForError:[sender lastError]] cString]);
+	play_sound = FALSE;
+	return self;
+}
+
+@end
+
+/*
+ * Initialise the sound stream if we are playing sounds. We set up
+ * the soundkit objects and the delegate necessary to track what has
+ * been completed. A sound object may be placed on a remote host by the
+ * use of an environment variable.
+ */
+
+int
+sysdep_audio_init(void)
+{
+	NXSoundParameters *params = nil;
+	SNDSoundStruct *sptr = NULL;
+	char *host = getenv("SOUNDHOST");
+
+	if(!play_sound)
+		return OSD_OK;
+
+	/* make the queue lock */
+	queue_lock = [NSLock new];
+
+	/* create sound object (possibly remotely) */
+	if(host) {
+		sound = [[NXSoundOut alloc]
+			initOnHost:[NSString stringWithCString:host]];
+		if(sound==nil) {
+			fprintf(stderr,
+			   "could not initialise sound object on %s\n", host);
+	      		return OSD_NOT_OK;
+	    	} else
+	      		printf("Sending sound output to %s\n",host);
+	} else
+		sound=[[NXSoundOut alloc] init];
+
+	if(!sound) {
+		fprintf(stderr,"could not initialise sound object\n");
+		return OSD_NOT_OK;
+	}
+
+	/* create a parameters object */
+	printf("Sound is %d Hz %s %d bit samples\n", options.samplerate,
+		sound_stereo ? "stereo" : "mono", sound_8bit ? 8 : 16);
+	SNDAlloc(&sptr,0,SND_FORMAT_LINEAR_16,options.samplerate,
+		sound_stereo ? 2 : 1 ,0);
+	params = [[NXSoundParameters alloc] initFromSoundStruct:sptr];
+	if(!params) {
+		fprintf(stderr,"could not create sound parameters\n");
+		return OSD_NOT_OK;
+	}
+
+	/* create the stream object */
+	stream = [[NXPlayStream alloc]
+		initOnDevice:sound withParameters:params];
+	if(!stream) {
+		fprintf(stderr,"could not create play stream\n");
+		return OSD_NOT_OK;
+	}
+
+	/* set the delegate and activate the whole lot */
+	[stream setDelegate:[Delegate new]];
+	[stream activate];
+
+	return OSD_OK;
+}
+
+/*
+ * Wait for all sounds to finish and return.
+ */
+
+void
+sysdep_audio_close(void)
+{
+	int i;
+
+	/* return if we are not playing sounds at all */
+	if(!play_sound)
+		return;
+
+	/*
+	 * Wait for all the sounds to finish - but if
+	 * they aren't all done in 4 seconds then quit anyway.
+	 * (sometimes the delegate stops getting the messages!)
+	 */
+
+	for(i=0;i<4;i++) {
+		int left;
+		[queue_lock lock];
+		left = queued;
+		[queue_lock unlock];
+		if(left==0)
+			break;
+			sleep(1);
+	}
+	[stream release];
+	[sound release];
+	[queue_lock release];
+}
+
+/*
+ * o.k.- this is ugly, the idea of this function was to return the amount of
+ * freespace in the audio output buffer. however, all attempts on my part
+ * to do this "properly"  have either resulted in no sound of a horrible
+ * unlistenable mess. This is not great either, but it does work after
+ * a fashion. What I do is keep a count of the number of queued buffers.
+ * As more are queued I return less free space - thus MAME queues smaller
+ * buffers as the sound queue starts to fill up. Don't ask me for a rational
+ * behind this, and feel free to rip it out and try to do better...
+ */
+
+long
+sysdep_audio_get_freespace(void)
+{
+	int how_many;
+
+	if(!play_sound)	/* in case of abort */
+		return 0;
+
+	[queue_lock lock];
+	how_many = queued;
+	[queue_lock unlock];
+
+	if(how_many<8) return AUDIO_BUFF_SIZE;
+	if(how_many<18) return (AUDIO_BUFF_SIZE>>1);
+	if(how_many<30) return (AUDIO_BUFF_SIZE>>2);
+	return 0;
+}
+
+/*
+ * Here we play a block of audio.
+ */
+
+int
+sysdep_audio_play(unsigned char *buff, int size)
+{
+	short buf16[AUDIO_BUFF_SIZE];
+	short *pt16=buf16;
+	int samples = sound_8bit ? size : size / 2;
+	int bytes = sound_8bit ? size * 2 : size;
+
+	/* make sure we have native 16 bit block */
+	if(sound_8bit) {
+		int i;
+		unsigned char *pt8=buff;
+		for(i=0;i<size;i++)
+			*pt16++ = (*pt8++ - 0x80) * 256;
+		pt16=buf16;
+	} else
+		pt16 = (short*)buff;
+
+	/* Do the byte swapping and play the stream */
+	SNDSwapHostToSound(pt16, pt16, samples,
+		sound_stereo ? 2 : 1, SND_FORMAT_LINEAR_16);
+	[stream playBuffer:pt16 size:bytes tag:(int)1];
+
+	[queue_lock lock];
+	queued++;
+	[queue_lock unlock];
+	return size;
+}
diff --git a/src/unix/sound.c b/src/unix/sound.c
new file mode 100644
index 0000000..4e3c313
--- /dev/null
+++ b/src/unix/sound.c
@@ -0,0 +1,296 @@
+/*
+ * X-Mame sound code
+ */
+
+#include "xmame.h"
+#include "sysdep/sysdep_dsp.h"
+#include "sysdep/sysdep_mixer.h"
+#include "sysdep/sound_stream.h"
+#include "driver.h"
+#ifdef AVICAPTURE
+#include <lame/lame.h>
+#endif
+
+/* #define SOUND_DEBUG */
+
+static int sound_fake = 0;
+static int sound_samplerate = 22050;
+static float sound_bufsize = 3.0;
+static int sound_attenuation = -3;
+static char *sound_dsp_device = NULL;
+static char *sound_mixer_device = NULL;
+static struct sysdep_dsp_struct *sound_dsp = NULL;
+static struct sysdep_mixer_struct *sound_mixer = NULL;
+static int sound_samples_per_frame = 0;
+static int type;
+
+static int sound_set_options(struct rc_option *option, const char *arg,
+   int priority)
+{
+  if(sound_enabled)
+  {
+     options.samplerate = sound_samplerate;
+  }
+  else if(sound_fake)
+  {
+     options.samplerate = 8000;
+  }
+  else
+     options.samplerate = 0;
+  
+  option->priority = priority;
+  
+  return 0;
+}
+
+struct rc_option sound_opts[] = {
+   /* name, shortname, type, dest, deflt, min, max, func, help */
+   { "Sound Related",	NULL,			rc_seperator,	NULL,
+     NULL,		0,			0,		NULL,
+     NULL },
+   { "sound",		"snd",			rc_bool,	&sound_enabled,
+     "1",		0,			0,		sound_set_options,
+     "Enable/disable sound (if available)" },
+   { "samples",		"sam",			rc_bool,	&options.use_samples,
+     "1",		0,			0,		NULL,
+     "Use/don't use samples (if available)" },
+   { "fakesound",	"fsnd",			rc_set_int,	&sound_fake,
+     NULL,		1,			0,		sound_set_options,
+     "Generate sound even when sound is disabled, this is needed for some games which won't run without sound" },
+   { "samplefreq",	"sf",			rc_int,		&sound_samplerate,
+     "22050",		8000,			48000,		sound_set_options,
+     "Set the playback sample-frequency/rate" },
+   { "bufsize", 	"bs",			rc_float,	&sound_bufsize,
+     "3.0",		1.0,			30.0,		NULL,
+     "Number of frames of sound to buffer" },
+   { "volume",		"v",			rc_int,		&sound_attenuation,
+     "-3",		-32,			0,		NULL,
+     "Set volume to <int> db, (-32 (soft) - 0(loud) )" },
+   { "audiodevice",	"ad",			rc_string,	&sound_dsp_device,
+     NULL,		0,			0,		NULL,
+     "Use an alternative audiodevice" },
+   { "mixerdevice",	"md",			rc_string,	&sound_mixer_device,
+     NULL,		0,			0,		NULL,
+     "Use an alternative mixerdevice" },
+   { NULL,		NULL,			rc_end,		NULL,
+     NULL,		0,			0,		NULL,
+     NULL }
+};
+
+/* attenuation in dB */
+void osd_set_mastervolume (int attenuation)
+{
+   float f = attenuation;
+   
+   if(!sound_mixer)
+      return;
+      
+   f += 32.0;
+   f *= 100.0;
+   f /= 32.0;
+   f += 0.50; /* for rounding */
+#ifdef SOUND_DEBUG
+   fprintf(stderr, "sound.c: setting volume to %d (%d)\n",
+      attenuation, (int)f);
+#endif
+   
+   sysdep_mixer_set(sound_mixer, SYSDEP_MIXER_PCM1, f, f);
+}
+
+int osd_get_mastervolume (void)
+{
+   int left, right;
+   float f;
+   
+   if(!sound_mixer)
+      return -32;
+      
+   if(sysdep_mixer_get(sound_mixer, SYSDEP_MIXER_PCM1, &left, &right))
+      return -32;
+      
+   f = left;
+   f *= 32.0;
+   f /= 100.0;
+   f -= 32.5; /* 32 + 0.5 for rounding */
+#ifdef SOUND_DEBUG
+   fprintf(stderr, "sound.c: got volume %d (%d)\n", (int)f, left);
+#endif
+   return f;
+}
+
+void osd_sound_enable (int enable_it)
+{
+   if (sound_stream && enable_it)
+   {
+      sound_enabled = 1;
+      if (!sound_dsp)
+      {
+	 if (!(sound_dsp = sysdep_dsp_create(NULL,
+	    sound_dsp_device,
+	    &options.samplerate,
+	    &type,
+	    sound_bufsize * (1 / Machine->drv->frames_per_second),
+	    SYSDEP_DSP_EMULATE_TYPE | SYSDEP_DSP_O_NONBLOCK)))
+	    sound_enabled = 0;
+	 else
+	 {
+	    sound_stream_destroy(sound_stream);
+	    if (!(sound_stream = sound_stream_create(sound_dsp, type,
+	       sound_samples_per_frame, 3)))
+	    {
+	       osd_stop_audio_stream();
+	       sound_enabled = 0;
+	    }
+	 }
+      }
+   }
+   else
+   {
+      if (sound_dsp)
+      {
+	 sysdep_dsp_destroy(sound_dsp);
+	 sound_dsp = NULL;
+      }
+      sound_enabled = 0;
+   }
+}
+
+int osd_start_audio_stream(int stereo)
+{
+   type = SYSDEP_DSP_16BIT | (stereo? SYSDEP_DSP_STEREO:SYSDEP_DSP_MONO);
+   
+   sound_stream = NULL;
+
+   /* create dsp */
+   if(sound_enabled)
+   {
+      if(!(sound_dsp = sysdep_dsp_create(NULL,
+         sound_dsp_device,
+         &options.samplerate,
+         &type,
+         sound_bufsize * (1 / Machine->drv->frames_per_second),
+         SYSDEP_DSP_EMULATE_TYPE | SYSDEP_DSP_O_NONBLOCK)))
+      {
+         osd_stop_audio_stream();
+         sound_enabled = 0;
+      }
+   }
+   
+   /* create sound_stream */
+   if(sound_enabled)
+   {
+      /* sysdep_dsp_open may have changed the samplerate */
+      Machine->sample_rate = options.samplerate;
+      
+      /* calculate samples_per_frame */
+      sound_samples_per_frame = Machine->sample_rate /
+         Machine->drv->frames_per_second;
+#ifdef SOUND_DEBUG
+      fprintf(stderr, "debug: sound: samples_per_frame = %d\n",
+         sound_samples_per_frame);
+#endif
+      if(!(sound_stream = sound_stream_create(sound_dsp, type,
+         sound_samples_per_frame, 3)))
+      {
+         osd_stop_audio_stream();
+         sound_enabled = 0;
+      }
+   }
+
+   /* if sound is not enabled, set the samplerate of the core to 0 */
+   if(!sound_enabled)
+   {
+      if(sound_fake)
+         Machine->sample_rate = options.samplerate = 8000;
+      else
+         Machine->sample_rate = options.samplerate = 0;
+      
+      /* calculate samples_per_frame */
+      sound_samples_per_frame = Machine->sample_rate /
+         Machine->drv->frames_per_second;
+      
+      return sound_samples_per_frame;
+   }
+   
+   /* create a mixer instance */
+   sound_mixer = sysdep_mixer_create(NULL, sound_mixer_device,
+      SYSDEP_MIXER_RESTORE_SETTINS_ON_EXIT);
+   
+   /* check if the user specified a volume, and ifso set it */
+   if(sound_mixer && rc_get_priority2(sound_opts, "volume"))
+      osd_set_mastervolume(sound_attenuation);
+   
+   return sound_samples_per_frame;
+}
+
+
+#ifdef AVICAPTURE
+static FILE *audio_fp = NULL;
+static lame_global_flags* fl = NULL;
+#endif
+
+int osd_update_audio_stream(INT16 *buffer)
+{
+#ifdef AVICAPTURE
+   static int times=0;
+
+   if (sound_enabled)
+   {
+	   static int opened = 0;
+      unsigned char audio_outbuf[100000];
+	   int bytes;
+
+	   if (!opened)
+      {
+	      opened=1;
+	      fl = lame_init();
+	      lame_set_in_samplerate( fl, Machine->sample_rate );
+	      lame_set_num_channels( fl, (type & SYSDEP_DSP_STEREO) ? 2 : 1 );
+	      lame_set_quality( fl, 5 );
+	      lame_init_params( fl );
+	      audio_fp = fopen("audio.outf","wb");
+      }
+   	
+      if (type & SYSDEP_DSP_STEREO)
+			bytes = lame_encode_buffer_interleaved (
+				fl, buffer, sound_samples_per_frame, 
+				audio_outbuf, sizeof(audio_outbuf));
+		else
+			bytes = lame_encode_buffer (
+				fl, buffer, buffer, sound_samples_per_frame, 
+				audio_outbuf, sizeof(audio_outbuf));
+	   fwrite( audio_outbuf,1, bytes, audio_fp );
+	}
+#endif /* AVICAPTURE */
+ 
+   /* sound enabled ? */
+   if (sound_enabled)
+      sound_stream_write(sound_stream, (unsigned char *)buffer,
+         sound_samples_per_frame);
+   
+   return sound_samples_per_frame;
+}
+
+void osd_stop_audio_stream(void)
+{
+   if(sound_stream)
+      sound_stream_destroy(sound_stream);
+   
+   if(sound_dsp)
+      sysdep_dsp_destroy(sound_dsp);
+   
+   if(sound_mixer)
+      sysdep_mixer_destroy(sound_mixer);
+
+#ifdef AVICAPTURE
+   if (audio_fp )
+   {
+     unsigned char buf[10000];
+     int bytes = lame_encode_flush(fl, buf, sizeof(buf));
+     fwrite( buf,1, bytes, audio_fp );
+     fclose( audio_fp );
+     lame_close(fl);
+   }
+#endif /* AVICAPTURE */
+
+}
diff --git a/src/unix/sysdep/COPYING.LIB b/src/unix/sysdep/COPYING.LIB
new file mode 100644
index 0000000..161a3d1
--- /dev/null
+++ b/src/unix/sysdep/COPYING.LIB
@@ -0,0 +1,482 @@
+		  GNU LIBRARY GENERAL PUBLIC LICENSE
+		       Version 2, June 1991
+
+ Copyright (C) 1991 Free Software Foundation, Inc.
+ 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA
+ Everyone is permitted to copy and distribute verbatim copies
+ of this license document, but changing it is not allowed.
+
+[This is the first released version of the library GPL.  It is
+ numbered 2 because it goes with version 2 of the ordinary GPL.]
+
+			    Preamble
+
+  The licenses for most software are designed to take away your
+freedom to share and change it.  By contrast, the GNU General Public
+Licenses are intended to guarantee your freedom to share and change
+free software--to make sure the software is free for all its users.
+
+  This license, the Library General Public License, applies to some
+specially designated Free Software Foundation software, and to any
+other libraries whose authors decide to use it.  You can use it for
+your libraries, too.
+
+  When we speak of free software, we are referring to freedom, not
+price.  Our General Public Licenses are designed to make sure that you
+have the freedom to distribute copies of free software (and charge for
+this service if you wish), that you receive source code or can get it
+if you want it, that you can change the software or use pieces of it
+in new free programs; and that you know you can do these things.
+
+  To protect your rights, we need to make restrictions that forbid
+anyone to deny you these rights or to ask you to surrender the rights.
+These restrictions translate to certain responsibilities for you if
+you distribute copies of the library, or if you modify it.
+
+  For example, if you distribute copies of the library, whether gratis
+or for a fee, you must give the recipients all the rights that we gave
+you.  You must make sure that they, too, receive or can get the source
+code.  If you link a program with the library, you must provide
+complete object files to the recipients so that they can relink them
+with the library, after making changes to the library and recompiling
+it.  And you must show them these terms so they know their rights.
+
+  Our method of protecting your rights has two steps: (1) copyright
+the library, and (2) offer you this license which gives you legal
+permission to copy, distribute and/or modify the library.
+
+  Also, for each distributor's protection, we want to make certain
+that everyone understands that there is no warranty for this free
+library.  If the library is modified by someone else and passed on, we
+want its recipients to know that what they have is not the original
+version, so that any problems introduced by others will not reflect on
+the original authors' reputations.
+
+  Finally, any free program is threatened constantly by software
+patents.  We wish to avoid the danger that companies distributing free
+software will individually obtain patent licenses, thus in effect
+transforming the program into proprietary software.  To prevent this,
+we have made it clear that any patent must be licensed for everyone's
+free use or not licensed at all.
+
+  Most GNU software, including some libraries, is covered by the ordinary
+GNU General Public License, which was designed for utility programs.  This
+license, the GNU Library General Public License, applies to certain
+designated libraries.  This license is quite different from the ordinary
+one; be sure to read it in full, and don't assume that anything in it is
+the same as in the ordinary license.
+
+  The reason we have a separate public license for some libraries is that
+they blur the distinction we usually make between modifying or adding to a
+program and simply using it.  Linking a program with a library, without
+changing the library, is in some sense simply using the library, and is
+analogous to running a utility program or application program.  However, in
+a textual and legal sense, the linked executable is a combined work, a
+derivative of the original library, and the ordinary General Public License
+treats it as such.
+
+  Because of this blurred distinction, using the ordinary General
+Public License for libraries did not effectively promote software
+sharing, because most developers did not use the libraries.  We
+concluded that weaker conditions might promote sharing better.
+
+  However, unrestricted linking of non-free programs would deprive the
+users of those programs of all benefit from the free status of the
+libraries themselves.  This Library General Public License is intended to
+permit developers of non-free programs to use free libraries, while
+preserving your freedom as a user of such programs to change the free
+libraries that are incorporated in them.  (We have not seen how to achieve
+this as regards changes in header files, but we have achieved it as regards
+changes in the actual functions of the Library.)  The hope is that this
+will lead to faster development of free libraries.
+
+  The precise terms and conditions for copying, distribution and
+modification follow.  Pay close attention to the difference between a
+"work based on the library" and a "work that uses the library".  The
+former contains code derived from the library, while the latter only
+works together with the library.
+
+  Note that it is possible for a library to be covered by the ordinary
+General Public License rather than by this special one.
+
+		  GNU LIBRARY GENERAL PUBLIC LICENSE
+   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
+
+  0. This License Agreement applies to any software library which
+contains a notice placed by the copyright holder or other authorized
+party saying it may be distributed under the terms of this Library
+General Public License (also called "this License").  Each licensee is
+addressed as "you".
+
+  A "library" means a collection of software functions and/or data
+prepared so as to be conveniently linked with application programs
+(which use some of those functions and data) to form executables.
+
+  The "Library", below, refers to any such software library or work
+which has been distributed under these terms.  A "work based on the
+Library" means either the Library or any derivative work under
+copyright law: that is to say, a work containing the Library or a
+portion of it, either verbatim or with modifications and/or translated
+straightforwardly into another language.  (Hereinafter, translation is
+included without limitation in the term "modification".)
+
+  "Source code" for a work means the preferred form of the work for
+making modifications to it.  For a library, complete source code means
+all the source code for all modules it contains, plus any associated
+interface definition files, plus the scripts used to control compilation
+and installation of the library.
+
+  Activities other than copying, distribution and modification are not
+covered by this License; they are outside its scope.  The act of
+running a program using the Library is not restricted, and output from
+such a program is covered only if its contents constitute a work based
+on the Library (independent of the use of the Library in a tool for
+writing it).  Whether that is true depends on what the Library does
+and what the program that uses the Library does.
+  
+  1. You may copy and distribute verbatim copies of the Library's
+complete source code as you receive it, in any medium, provided that
+you conspicuously and appropriately publish on each copy an
+appropriate copyright notice and disclaimer of warranty; keep intact
+all the notices that refer to this License and to the absence of any
+warranty; and distribute a copy of this License along with the
+Library.
+
+  You may charge a fee for the physical act of transferring a copy,
+and you may at your option offer warranty protection in exchange for a
+fee.
+
+  2. You may modify your copy or copies of the Library or any portion
+of it, thus forming a work based on the Library, and copy and
+distribute such modifications or work under the terms of Section 1
+above, provided that you also meet all of these conditions:
+
+    a) The modified work must itself be a software library.
+
+    b) You must cause the files modified to carry prominent notices
+    stating that you changed the files and the date of any change.
+
+    c) You must cause the whole of the work to be licensed at no
+    charge to all third parties under the terms of this License.
+
+    d) If a facility in the modified Library refers to a function or a
+    table of data to be supplied by an application program that uses
+    the facility, other than as an argument passed when the facility
+    is invoked, then you must make a good faith effort to ensure that,
+    in the event an application does not supply such function or
+    table, the facility still operates, and performs whatever part of
+    its purpose remains meaningful.
+
+    (For example, a function in a library to compute square roots has
+    a purpose that is entirely well-defined independent of the
+    application.  Therefore, Subsection 2d requires that any
+    application-supplied function or table used by this function must
+    be optional: if the application does not supply it, the square
+    root function must still compute square roots.)
+
+These requirements apply to the modified work as a whole.  If
+identifiable sections of that work are not derived from the Library,
+and can be reasonably considered independent and separate works in
+themselves, then this License, and its terms, do not apply to those
+sections when you distribute them as separate works.  But when you
+distribute the same sections as part of a whole which is a work based
+on the Library, the distribution of the whole must be on the terms of
+this License, whose permissions for other licensees extend to the
+entire whole, and thus to each and every part regardless of who wrote
+it.
+
+Thus, it is not the intent of this section to claim rights or contest
+your rights to work written entirely by you; rather, the intent is to
+exercise the right to control the distribution of derivative or
+collective works based on the Library.
+
+In addition, mere aggregation of another work not based on the Library
+with the Library (or with a work based on the Library) on a volume of
+a storage or distribution medium does not bring the other work under
+the scope of this License.
+
+  3. You may opt to apply the terms of the ordinary GNU General Public
+License instead of this License to a given copy of the Library.  To do
+this, you must alter all the notices that refer to this License, so
+that they refer to the ordinary GNU General Public License, version 2,
+instead of to this License.  (If a newer version than version 2 of the
+ordinary GNU General Public License has appeared, then you can specify
+that version instead if you wish.)  Do not make any other change in
+these notices.
+
+  Once this change is made in a given copy, it is irreversible for
+that copy, so the ordinary GNU General Public License applies to all
+subsequent copies and derivative works made from that copy.
+
+  This option is useful when you wish to copy part of the code of
+the Library into a program that is not a library.
+
+  4. You may copy and distribute the Library (or a portion or
+derivative of it, under Section 2) in object code or executable form
+under the terms of Sections 1 and 2 above provided that you accompany
+it with the complete corresponding machine-readable source code, which
+must be distributed under the terms of Sections 1 and 2 above on a
+medium customarily used for software interchange.
+
+  If distribution of object code is made by offering access to copy
+from a designated place, then offering equivalent access to copy the
+source code from the same place satisfies the requirement to
+distribute the source code, even though third parties are not
+compelled to copy the source along with the object code.
+
+  5. A program that contains no derivative of any portion of the
+Library, but is designed to work with the Library by being compiled or
+linked with it, is called a "work that uses the Library".  Such a
+work, in isolation, is not a derivative work of the Library, and
+therefore falls outside the scope of this License.
+
+  However, linking a "work that uses the Library" with the Library
+creates an executable that is a derivative of the Library (because it
+contains portions of the Library), rather than a "work that uses the
+library".  The executable is therefore covered by this License.
+Section 6 states terms for distribution of such executables.
+
+  When a "work that uses the Library" uses material from a header file
+that is part of the Library, the object code for the work may be a
+derivative work of the Library even though the source code is not.
+Whether this is true is especially significant if the work can be
+linked without the Library, or if the work is itself a library.  The
+threshold for this to be true is not precisely defined by law.
+
+  If such an object file uses only numerical parameters, data
+structure layouts and accessors, and small macros and small inline
+functions (ten lines or less in length), then the use of the object
+file is unrestricted, regardless of whether it is legally a derivative
+work.  (Executables containing this object code plus portions of the
+Library will still fall under Section 6.)
+
+  Otherwise, if the work is a derivative of the Library, you may
+distribute the object code for the work under the terms of Section 6.
+Any executables containing that work also fall under Section 6,
+whether or not they are linked directly with the Library itself.
+
+  6. As an exception to the Sections above, you may also compile or
+link a "work that uses the Library" with the Library to produce a
+work containing portions of the Library, and distribute that work
+under terms of your choice, provided that the terms permit
+modification of the work for the customer's own use and reverse
+engineering for debugging such modifications.
+
+  You must give prominent notice with each copy of the work that the
+Library is used in it and that the Library and its use are covered by
+this License.  You must supply a copy of this License.  If the work
+during execution displays copyright notices, you must include the
+copyright notice for the Library among them, as well as a reference
+directing the user to the copy of this License.  Also, you must do one
+of these things:
+
+    a) Accompany the work with the complete corresponding
+    machine-readable source code for the Library including whatever
+    changes were used in the work (which must be distributed under
+    Sections 1 and 2 above); and, if the work is an executable linked
+    with the Library, with the complete machine-readable "work that
+    uses the Library", as object code and/or source code, so that the
+    user can modify the Library and then relink to produce a modified
+    executable containing the modified Library.  (It is understood
+    that the user who changes the contents of definitions files in the
+    Library will not necessarily be able to recompile the application
+    to use the modified definitions.)
+
+    b) Accompany the work with a written offer, valid for at
+    least three years, to give the same user the materials
+    specified in Subsection 6a, above, for a charge no more
+    than the cost of performing this distribution.
+
+    c) If distribution of the work is made by offering access to copy
+    from a designated place, offer equivalent access to copy the above
+    specified materials from the same place.
+
+    d) Verify that the user has already received a copy of these
+    materials or that you have already sent this user a copy.
+
+  For an executable, the required form of the "work that uses the
+Library" must include any data and utility programs needed for
+reproducing the executable from it.  However, as a special exception,
+the source code distributed need not include anything that is normally
+distributed (in either source or binary form) with the major
+components (compiler, kernel, and so on) of the operating system on
+which the executable runs, unless that component itself accompanies
+the executable.
+
+  It may happen that this requirement contradicts the license
+restrictions of other proprietary libraries that do not normally
+accompany the operating system.  Such a contradiction means you cannot
+use both them and the Library together in an executable that you
+distribute.
+
+  7. You may place library facilities that are a work based on the
+Library side-by-side in a single library together with other library
+facilities not covered by this License, and distribute such a combined
+library, provided that the separate distribution of the work based on
+the Library and of the other library facilities is otherwise
+permitted, and provided that you do these two things:
+
+    a) Accompany the combined library with a copy of the same work
+    based on the Library, uncombined with any other library
+    facilities.  This must be distributed under the terms of the
+    Sections above.
+
+    b) Give prominent notice with the combined library of the fact
+    that part of it is a work based on the Library, and explaining
+    where to find the accompanying uncombined form of the same work.
+
+  8. You may not copy, modify, sublicense, link with, or distribute
+the Library except as expressly provided under this License.  Any
+attempt otherwise to copy, modify, sublicense, link with, or
+distribute the Library is void, and will automatically terminate your
+rights under this License.  However, parties who have received copies,
+or rights, from you under this License will not have their licenses
+terminated so long as such parties remain in full compliance.
+
+  9. You are not required to accept this License, since you have not
+signed it.  However, nothing else grants you permission to modify or
+distribute the Library or its derivative works.  These actions are
+prohibited by law if you do not accept this License.  Therefore, by
+modifying or distributing the Library (or any work based on the
+Library), you indicate your acceptance of this License to do so, and
+all its terms and conditions for copying, distributing or modifying
+the Library or works based on it.
+
+  10. Each time you redistribute the Library (or any work based on the
+Library), the recipient automatically receives a license from the
+original licensor to copy, distribute, link with or modify the Library
+subject to these terms and conditions.  You may not impose any further
+restrictions on the recipients' exercise of the rights granted herein.
+You are not responsible for enforcing compliance by third parties to
+this License.
+
+  11. If, as a consequence of a court judgment or allegation of patent
+infringement or for any other reason (not limited to patent issues),
+conditions are imposed on you (whether by court order, agreement or
+otherwise) that contradict the conditions of this License, they do not
+excuse you from the conditions of this License.  If you cannot
+distribute so as to satisfy simultaneously your obligations under this
+License and any other pertinent obligations, then as a consequence you
+may not distribute the Library at all.  For example, if a patent
+license would not permit royalty-free redistribution of the Library by
+all those who receive copies directly or indirectly through you, then
+the only way you could satisfy both it and this License would be to
+refrain entirely from distribution of the Library.
+
+If any portion of this section is held invalid or unenforceable under any
+particular circumstance, the balance of the section is intended to apply,
+and the section as a whole is intended to apply in other circumstances.
+
+It is not the purpose of this section to induce you to infringe any
+patents or other property right claims or to contest validity of any
+such claims; this section has the sole purpose of protecting the
+integrity of the free software distribution system which is
+implemented by public license practices.  Many people have made
+generous contributions to the wide range of software distributed
+through that system in reliance on consistent application of that
+system; it is up to the author/donor to decide if he or she is willing
+to distribute software through any other system and a licensee cannot
+impose that choice.
+
+This section is intended to make thoroughly clear what is believed to
+be a consequence of the rest of this License.
+
+  12. If the distribution and/or use of the Library is restricted in
+certain countries either by patents or by copyrighted interfaces, the
+original copyright holder who places the Library under this License may add
+an explicit geographical distribution limitation excluding those countries,
+so that distribution is permitted only in or among countries not thus
+excluded.  In such case, this License incorporates the limitation as if
+written in the body of this License.
+
+  13. The Free Software Foundation may publish revised and/or new
+versions of the Library General Public License from time to time.
+Such new versions will be similar in spirit to the present version,
+but may differ in detail to address new problems or concerns.
+
+Each version is given a distinguishing version number.  If the Library
+specifies a version number of this License which applies to it and
+"any later version", you have the option of following the terms and
+conditions either of that version or of any later version published by
+the Free Software Foundation.  If the Library does not specify a
+license version number, you may choose any version ever published by
+the Free Software Foundation.
+
+  14. If you wish to incorporate parts of the Library into other free
+programs whose distribution conditions are incompatible with these,
+write to the author to ask for permission.  For software which is
+copyrighted by the Free Software Foundation, write to the Free
+Software Foundation; we sometimes make exceptions for this.  Our
+decision will be guided by the two goals of preserving the free status
+of all derivatives of our free software and of promoting the sharing
+and reuse of software generally.
+
+			    NO WARRANTY
+
+  15. BECAUSE THE LIBRARY IS LICENSED FREE OF CHARGE, THERE IS NO
+WARRANTY FOR THE LIBRARY, TO THE EXTENT PERMITTED BY APPLICABLE LAW.
+EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR
+OTHER PARTIES PROVIDE THE LIBRARY "AS IS" WITHOUT WARRANTY OF ANY
+KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE
+LIBRARY IS WITH YOU.  SHOULD THE LIBRARY PROVE DEFECTIVE, YOU ASSUME
+THE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION.
+
+  16. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN
+WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY
+AND/OR REDISTRIBUTE THE LIBRARY AS PERMITTED ABOVE, BE LIABLE TO YOU
+FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR
+CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE
+LIBRARY (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING
+RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A
+FAILURE OF THE LIBRARY TO OPERATE WITH ANY OTHER SOFTWARE), EVEN IF
+SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
+DAMAGES.
+
+		     END OF TERMS AND CONDITIONS
+
+     Appendix: How to Apply These Terms to Your New Libraries
+
+  If you develop a new library, and you want it to be of the greatest
+possible use to the public, we recommend making it free software that
+everyone can redistribute and change.  You can do so by permitting
+redistribution under these terms (or, alternatively, under the terms of the
+ordinary General Public License).
+
+  To apply these terms, attach the following notices to the library.  It is
+safest to attach them to the start of each source file to most effectively
+convey the exclusion of warranty; and each file should have at least the
+"copyright" line and a pointer to where the full notice is found.
+
+    <one line to give the library's name and a brief idea of what it does.>
+    Copyright (C) <year>  <name of author>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License as published by the Free Software Foundation; either
+    version 2 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public
+    License along with this library; if not, write to the Free
+    Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,
+    MA 02111-1307, USA
+
+Also add information on how to contact you by electronic and paper mail.
+
+You should also get your employer (if you work as a programmer) or your
+school, if any, to sign a "copyright disclaimer" for the library, if
+necessary.  Here is a sample; alter the names:
+
+  Yoyodyne, Inc., hereby disclaims all copyright interest in the
+  library `Frob' (a library for tweaking knobs) written by James Random Hacker.
+
+  <signature of Ty Coon>, 1 April 1990
+  Ty Coon, President of Vice
+
+That's all there is to it!
diff --git a/src/unix/sysdep/begin_code.h b/src/unix/sysdep/begin_code.h
new file mode 100644
index 0000000..96c3613
--- /dev/null
+++ b/src/unix/sysdep/begin_code.h
@@ -0,0 +1,31 @@
+/* A few simple include macros
+
+   Copyright 1999,2000 Hans de Goede
+   
+   This file and the acompanying files in this directory are free software;
+   you can redistribute them and/or modify them under the terms of the GNU
+   Library General Public License as published by the Free Software Foundation;
+   either version 2 of the License, or (at your option) any later version.
+
+   These files are distributed in the hope that they will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with these files; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.
+*/
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#ifndef BUF_SIZE
+#define BUF_SIZE 512
+#endif
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
diff --git a/src/unix/sysdep/blit_2.h b/src/unix/sysdep/blit_2.h
new file mode 100644
index 0000000..f0a9a42
--- /dev/null
+++ b/src/unix/sysdep/blit_2.h
@@ -0,0 +1,592 @@
+/* this routine is the generic blit routine used in many cases, trough a number
+   of defines it can be customised for specific cases.
+   Currently recognised defines:
+   DEST		ptr of type DEST_PIXEL to which should be blitted, if this is
+		not defined only PUT_IMAGE is called if defined.
+   DEST_PIXEL	type of the buffer to which is blitted, only needed if
+                DEST is defined.
+   DEST_WIDTH   Width of the destination buffer in pixels! Only needed if
+                DEST is defined.
+   SRC_PIXEL    type of the buffer from which is blitted, currently
+                8 bpp (unsigned char) and 16 bpp (unsigned short) are supported.
+   PUT_IMAGE    This function is called to update the parts of the screen
+		which need updating. This is only called if defined.
+   INDIRECT     This needs to be defined if DEST_PIXEL != unsigned char,
+                this is a ptr to a list of pixels/colormappings for the
+                colordepth conversion.
+   BLIT_16BPP_HACK This one speaks for itself, it's a speedup hack for 8bpp
+                to 16bpp blits.
+   PACK_BITS    Write to packed 24bit pixels, DEST_PIXEL must be 32bits and
+                INDIRECT must be on.
+   DOUBLEBUFFER First copy each line to a buffer called doublebuffer_buffer,
+                then do a memcpy to the real destination. This speeds up
+                scaling when writing directly to framebuffer since it
+                tremendously speeds up the reads done to copy one line to
+                the next.
+   
+   This routines use long copy's so everything should always be long aligned.
+*/
+
+#error unused
+
+#ifdef PACK_BITS
+/* scale destptr delta's by 3/4 since we're using 32 bits ptr's for a 24 bits
+   dest */
+#define DEST_SCALE(X) ((X * 3) / 4)
+#define DEST_PIXEL_SIZE 3
+#else
+#define DEST_SCALE(X) (X)
+#define DEST_PIXEL_SIZE sizeof(DEST_PIXEL)
+#endif
+
+switch (heightscale | (widthscale << 8) | (use_scanlines << 16))
+{
+/* 1x1 */
+
+#ifdef INDIRECT
+
+#ifdef BLIT_16BPP_HACK
+#define COPY_LINE2(SRC, END, DST) \
+   unsigned short *src = (unsigned short *)(SRC); \
+   unsigned short *end = (unsigned short *)(END); \
+   unsigned int   *dst = (unsigned int   *)(DST); \
+   for(;src<end;src+=4,dst+=4) \
+   { \
+      *(dst  ) = INDIRECT[*(src  )]; \
+      *(dst+1) = INDIRECT[*(src+1)]; \
+      *(dst+2) = INDIRECT[*(src+2)]; \
+      *(dst+3) = INDIRECT[*(src+3)]; \
+   }
+#elif defined PACK_BITS
+#define COPY_LINE2(SRC, END, DST) \
+   SRC_PIXEL  *src = SRC; \
+   SRC_PIXEL  *end = END; \
+   DEST_PIXEL *dst = DST; \
+   for(;src<end;dst+=3,src+=4) \
+   { \
+      *(dst  ) = (INDIRECT[*(src  )]    ) | (INDIRECT[*(src+1)]<<24); \
+      *(dst+1) = (INDIRECT[*(src+1)]>> 8) | (INDIRECT[*(src+2)]<<16); \
+      *(dst+2) = (INDIRECT[*(src+2)]>>16) | (INDIRECT[*(src+3)]<< 8); \
+   }
+#else /* normal indirect */
+#define COPY_LINE2(SRC, END, DST) \
+   SRC_PIXEL  *src = SRC; \
+   SRC_PIXEL  *end = END; \
+   DEST_PIXEL *dst = DST; \
+   for(;src<end;src+=8,dst+=8) \
+   { \
+      *(dst  ) = INDIRECT[*(src  )]; \
+      *(dst+1) = INDIRECT[*(src+1)]; \
+      *(dst+2) = INDIRECT[*(src+2)]; \
+      *(dst+3) = INDIRECT[*(src+3)]; \
+      *(dst+4) = INDIRECT[*(src+4)]; \
+      *(dst+5) = INDIRECT[*(src+5)]; \
+      *(dst+6) = INDIRECT[*(src+6)]; \
+      *(dst+7) = INDIRECT[*(src+7)]; \
+   }
+#endif /* dga_16bpp_hack / packed / normal indirect */
+
+#else  /* not indirect */
+#define COPY_LINE2(SRC, END, DST) \
+   memcpy(DST, SRC, ((END)-(SRC))*DEST_PIXEL_SIZE);
+#endif /* indirect */
+
+#define SCALE_X(X) (X)
+#define SCALE_Y(Y) (Y)
+
+/* 1x1 we don't do scanlines with 1x1 */
+case 0x00101:
+case 0x10101:
+#define COPY_LINE(SRC, END, DST) { COPY_LINE2(SRC, END, DST) }
+#include "blit_core.h"
+#undef COPY_LINE
+break;
+
+#undef SCALE_Y
+
+/* 1x2 */
+
+#define SCALE_Y(Y)   ((Y) * 2)
+
+/* 1x2 no scanlines */
+case 0x00102:
+
+#ifdef DOUBLEBUFFER
+
+#ifdef INDIRECT
+#define COPY_LINE(SRC, END, DST) \
+{ \
+   COPY_LINE2(SRC, END, (DEST_PIXEL *)doublebuffer_buffer) \
+   memcpy((DST),                          doublebuffer_buffer, ((END)-(SRC))*DEST_PIXEL_SIZE); \
+   memcpy((DST) + DEST_SCALE(DEST_WIDTH), doublebuffer_buffer, ((END)-(SRC))*DEST_PIXEL_SIZE); \
+}
+#else
+#define COPY_LINE(SRC, END, DST) \
+{ \
+   COPY_LINE2(SRC, END, (DST)); \
+   COPY_LINE2(SRC, END, (DST) + DEST_SCALE(DEST_WIDTH)); \
+}
+#endif
+
+#else
+#define COPY_LINE(SRC, END, DST) \
+{ \
+   COPY_LINE2(SRC, END, DST) \
+   memcpy((DST) + DEST_SCALE(DEST_WIDTH), DST, ((END)-(SRC))*DEST_PIXEL_SIZE); \
+}
+#endif
+
+#include "blit_core.h"
+#undef COPY_LINE
+break;
+
+/* 1x2 scanlines */
+case 0x10102:
+#define COPY_LINE(SRC, END, DST) { COPY_LINE2(SRC, END, DST) }
+#include "blit_core.h"
+#undef COPY_LINE
+break;
+
+#undef COPY_LINE2
+#undef SCALE_X
+#undef SCALE_Y
+
+
+/* 2x2 */
+
+#ifdef INDIRECT
+
+#ifdef PACK_BITS
+#define COPY_LINE2(SRC, END, DST) \
+   SRC_PIXEL  *src = SRC; \
+   SRC_PIXEL  *end = END; \
+   DEST_PIXEL *dst = DST; \
+   for(;src<end; src+=2, dst+=3) \
+   { \
+      *(dst  ) = (INDIRECT[*(src  )]    ) | (INDIRECT[*(src  )]<<24); \
+      *(dst+1) = (INDIRECT[*(src  )]>> 8) | (INDIRECT[*(src+1)]<<16); \
+      *(dst+2) = (INDIRECT[*(src+1)]>>16) | (INDIRECT[*(src+1)]<<8); \
+   }
+#else /* not pack bits */
+#define COPY_LINE2(SRC, END, DST) \
+   SRC_PIXEL  *src = SRC; \
+   SRC_PIXEL  *end = END; \
+   DEST_PIXEL *dst = DST; \
+   for(;src<end; src+=8, dst+=16) \
+   { \
+      *(dst   ) = *(dst+ 1) = INDIRECT[*(src  )]; \
+      *(dst+ 2) = *(dst+ 3) = INDIRECT[*(src+1)]; \
+      *(dst+ 4) = *(dst+ 5) = INDIRECT[*(src+2)]; \
+      *(dst+ 6) = *(dst+ 7) = INDIRECT[*(src+3)]; \
+      *(dst+ 8) = *(dst+ 9) = INDIRECT[*(src+4)]; \
+      *(dst+10) = *(dst+11) = INDIRECT[*(src+5)]; \
+      *(dst+12) = *(dst+13) = INDIRECT[*(src+6)]; \
+      *(dst+14) = *(dst+15) = INDIRECT[*(src+7)]; \
+   }
+#endif /* pack bits */
+
+#else /* not indirect */
+
+#define COPY_LINE2(SRC, END, DST) \
+   SRC_PIXEL  *src = SRC; \
+   SRC_PIXEL  *end = END; \
+   DEST_PIXEL *dst = DST; \
+   for(;src<end; src+=8, dst+=16) \
+   { \
+      *(dst   ) = *(dst+ 1) = *(src  ); \
+      *(dst+ 2) = *(dst+ 3) = *(src+1); \
+      *(dst+ 4) = *(dst+ 5) = *(src+2); \
+      *(dst+ 6) = *(dst+ 7) = *(src+3); \
+      *(dst+ 8) = *(dst+ 9) = *(src+4); \
+      *(dst+10) = *(dst+11) = *(src+5); \
+      *(dst+12) = *(dst+13) = *(src+6); \
+      *(dst+14) = *(dst+15) = *(src+7); \
+   }
+#endif
+
+#define SCALE_X(X)   ((X)<<1)
+#define SCALE_X_8(X) ((X)<<4)
+#define SCALE_Y(Y)   ((Y)<<1)
+#define SCALE_Y_8(Y) ((Y)<<4)
+
+/* 2x2 no scanlines */
+case 0x00202:
+
+#ifdef DOUBLEBUFFER
+#define COPY_LINE(SRC, END, DST) \
+{ \
+   COPY_LINE2(SRC, END, (DEST_PIXEL *)doublebuffer_buffer) \
+   memcpy((DST),                        doublebuffer_buffer, ((END)-(SRC))*DEST_PIXEL_SIZE*2); \
+   memcpy((DST)+(CORRECTED_DEST_WIDTH), doublebuffer_buffer, ((END)-(SRC))*DEST_PIXEL_SIZE*2); \
+}
+#else
+#define COPY_LINE(SRC, END, DST) \
+{ \
+   COPY_LINE2(SRC, END, DST) \
+   memcpy((DST)+(CORRECTED_DEST_WIDTH), DST, ((END)-(SRC))*DEST_PIXEL_SIZE*2); \
+}
+#endif
+
+#include "blit_core.h"
+#undef COPY_LINE
+break;
+
+/* 2x2 scanlines */
+case 0x10202:
+
+#ifdef DOUBLEBUFFER
+#define COPY_LINE(SRC, END, DST) \
+{ \
+   COPY_LINE2(SRC, END, (DEST_PIXEL *)doublebuffer_buffer) \
+   memcpy((DST),                        doublebuffer_buffer, ((END)-(SRC))*DEST_PIXEL_SIZE*2); \
+}
+#else
+#define COPY_LINE(SRC, END, DST) { COPY_LINE2(SRC, END, DST) }
+#endif
+
+#include "blit_core.h"
+#undef COPY_LINE
+break;
+
+#undef COPY_LINE2
+#undef SCALE_X
+#undef SCALE_X_8
+#undef SCALE_Y
+#undef SCALE_Y_8
+
+#ifndef PACK_BITS
+/* 3x3 */
+
+/* this macro is used to copy a line */
+#ifdef INDIRECT
+
+#define COPY_LINE2(SRC, END, DST) \
+   SRC_PIXEL  *src = SRC; \
+   SRC_PIXEL  *end = END; \
+   DEST_PIXEL *dst = DST; \
+   for(;src<end; src+=8, dst+=24) \
+   { \
+      *(dst   ) = *(dst+ 1) = *(dst+ 2) = INDIRECT[*(src  )]; \
+      *(dst+ 3) = *(dst+ 4) = *(dst+ 5) = INDIRECT[*(src+1)]; \
+      *(dst+ 6) = *(dst+ 7) = *(dst+ 8) = INDIRECT[*(src+2)]; \
+      *(dst+ 9) = *(dst+10) = *(dst+11) = INDIRECT[*(src+3)]; \
+      *(dst+12) = *(dst+13) = *(dst+14) = INDIRECT[*(src+4)]; \
+      *(dst+15) = *(dst+16) = *(dst+17) = INDIRECT[*(src+5)]; \
+      *(dst+18) = *(dst+19) = *(dst+20) = INDIRECT[*(src+6)]; \
+      *(dst+21) = *(dst+22) = *(dst+23) = INDIRECT[*(src+7)]; \
+   }
+#else /* not indirect */
+#define COPY_LINE2(SRC, END, DST) \
+   SRC_PIXEL  *src = SRC; \
+   SRC_PIXEL  *end = END; \
+   DEST_PIXEL *dst = DST; \
+   for(;src<end; src+=8, dst+=24) \
+   { \
+      *(dst   ) = *(dst+ 1) = *(dst+ 2) = *(src  ); \
+      *(dst+ 3) = *(dst+ 4) = *(dst+ 5) = *(src+1); \
+      *(dst+ 6) = *(dst+ 7) = *(dst+ 8) = *(src+2); \
+      *(dst+ 9) = *(dst+10) = *(dst+11) = *(src+3); \
+      *(dst+12) = *(dst+13) = *(dst+14) = *(src+4); \
+      *(dst+15) = *(dst+16) = *(dst+17) = *(src+5); \
+      *(dst+18) = *(dst+19) = *(dst+20) = *(src+6); \
+      *(dst+21) = *(dst+22) = *(dst+23) = *(src+7); \
+   }
+#endif
+
+#define SCALE_X(X)   ((X)*3)
+#define SCALE_X_8(X) ((X)*24)
+#define SCALE_Y(Y)   ((Y)*3)
+#define SCALE_Y_8(Y) ((Y)*24)
+
+/* 3x3 no scanlines */
+case 0x00303:
+
+/* should we use doublebuffering ? */
+#ifdef DOUBLEBUFFER
+#define COPY_LINE(SRC, END, DST) \
+{ \
+   COPY_LINE2(SRC, END, (DEST_PIXEL *)doublebuffer_buffer) \
+   memcpy((DST),                          doublebuffer_buffer, ((END)-(SRC))*DEST_PIXEL_SIZE*3); \
+   memcpy((DST)+(CORRECTED_DEST_WIDTH),   doublebuffer_buffer, ((END)-(SRC))*DEST_PIXEL_SIZE*3); \
+   memcpy((DST)+(CORRECTED_DEST_WIDTH)*2, doublebuffer_buffer, ((END)-(SRC))*DEST_PIXEL_SIZE*3); \
+}
+#else
+#define COPY_LINE(SRC, END, DST) \
+{ \
+   COPY_LINE2(SRC, END, DST) \
+   memcpy((DST)+(CORRECTED_DEST_WIDTH),   DST, ((END)-(SRC))*DEST_PIXEL_SIZE*3); \
+   memcpy((DST)+(CORRECTED_DEST_WIDTH)*2, DST, ((END)-(SRC))*DEST_PIXEL_SIZE*3); \
+}
+#endif
+
+#include "blit_core.h"
+#undef COPY_LINE
+break;
+
+/* 3x3 scanlines */
+case 0x10303:
+
+/* should we use doublebuffering ? */
+#ifdef DOUBLEBUFFER
+#define COPY_LINE(SRC, END, DST) \
+{ \
+   COPY_LINE2(SRC, END, (DEST_PIXEL *)doublebuffer_buffer) \
+   memcpy((DST),                          doublebuffer_buffer, ((END)-(SRC))*DEST_PIXEL_SIZE*3); \
+   memcpy((DST)+(CORRECTED_DEST_WIDTH),   doublebuffer_buffer, ((END)-(SRC))*DEST_PIXEL_SIZE*3); \
+}
+#else
+#define COPY_LINE(SRC, END, DST) \
+{ \
+   COPY_LINE2(SRC, END, DST) \
+   memcpy((DST)+(CORRECTED_DEST_WIDTH),   DST, ((END)-(SRC))*DEST_PIXEL_SIZE*3); \
+}
+#endif
+
+#include "blit_core.h"
+#undef COPY_LINE
+break;
+
+#undef COPY_LINE2
+#undef SCALE_X
+#undef SCALE_X_8
+#undef SCALE_Y
+#undef SCALE_Y_8
+
+/* 4x4 */
+
+#ifdef INDIRECT
+
+#define COPY_LINE2(SRC, END, DST) \
+   SRC_PIXEL  *src = SRC; \
+   SRC_PIXEL  *end = END; \
+   DEST_PIXEL *dst = DST; \
+   for(;src<end; src+=8, dst+=32) \
+   { \
+      *(dst   ) = *(dst+ 1) = *(dst+ 2) = *(dst+ 3) = INDIRECT[*(src  )]; \
+      *(dst+ 4) = *(dst+ 5) = *(dst+ 6) = *(dst+ 7) = INDIRECT[*(src+1)]; \
+      *(dst+ 8) = *(dst+ 9) = *(dst+10) = *(dst+11) = INDIRECT[*(src+2)]; \
+      *(dst+12) = *(dst+13) = *(dst+14) = *(dst+15) = INDIRECT[*(src+3)]; \
+      *(dst+16) = *(dst+17) = *(dst+18) = *(dst+19) = INDIRECT[*(src+4)]; \
+      *(dst+20) = *(dst+21) = *(dst+22) = *(dst+23) = INDIRECT[*(src+5)]; \
+      *(dst+24) = *(dst+25) = *(dst+26) = *(dst+27) = INDIRECT[*(src+6)]; \
+      *(dst+28) = *(dst+29) = *(dst+30) = *(dst+31) = INDIRECT[*(src+7)]; \
+   }
+#else /* not indirect */
+#define COPY_LINE2(SRC, END, DST) \
+   SRC_PIXEL  *src = SRC; \
+   SRC_PIXEL  *end = END; \
+   DEST_PIXEL *dst = DST; \
+   for(;src<end; src+=8, dst+=32) \
+   { \
+      *(dst   ) = *(dst+ 1) = *(dst+ 2) = *(dst+ 3) = *(src  ); \
+      *(dst+ 4) = *(dst+ 5) = *(dst+ 6) = *(dst+ 7) = *(src+1); \
+      *(dst+ 8) = *(dst+ 9) = *(dst+10) = *(dst+11) = *(src+2); \
+      *(dst+12) = *(dst+13) = *(dst+14) = *(dst+15) = *(src+3); \
+      *(dst+16) = *(dst+17) = *(dst+18) = *(dst+19) = *(src+4); \
+      *(dst+20) = *(dst+21) = *(dst+22) = *(dst+23) = *(src+5); \
+      *(dst+24) = *(dst+25) = *(dst+26) = *(dst+27) = *(src+6); \
+      *(dst+28) = *(dst+29) = *(dst+30) = *(dst+31) = *(src+7); \
+   }
+#endif
+
+#define SCALE_X(X)   ((X)<<2)
+#define SCALE_X_8(X) ((X)<<5)
+#define SCALE_Y(Y)   ((Y)<<2)
+#define SCALE_Y_8(Y) ((Y)<<5)
+
+/* 4x4 no scanlines */
+case 0x00404:
+
+/* should we use doublebuffering ? */
+#ifdef DOUBLEBUFFER
+#define COPY_LINE(SRC, END, DST) \
+{ \
+   COPY_LINE2(SRC, END, (DEST_PIXEL *)doublebuffer_buffer) \
+   memcpy((DST),                          doublebuffer_buffer, ((END)-(SRC))*DEST_PIXEL_SIZE*4); \
+   memcpy((DST)+(CORRECTED_DEST_WIDTH),   doublebuffer_buffer, ((END)-(SRC))*DEST_PIXEL_SIZE*4); \
+   memcpy((DST)+(CORRECTED_DEST_WIDTH)*2, doublebuffer_buffer, ((END)-(SRC))*DEST_PIXEL_SIZE*4); \
+   memcpy((DST)+(CORRECTED_DEST_WIDTH)*3, doublebuffer_buffer, ((END)-(SRC))*DEST_PIXEL_SIZE*4); \
+}
+#else
+#define COPY_LINE(SRC, END, DST) \
+{ \
+   COPY_LINE2(SRC, END, DST) \
+   memcpy((DST)+(CORRECTED_DEST_WIDTH),   DST, ((END)-(SRC))*DEST_PIXEL_SIZE*4); \
+   memcpy((DST)+(CORRECTED_DEST_WIDTH)*2, DST, ((END)-(SRC))*DEST_PIXEL_SIZE*4); \
+   memcpy((DST)+(CORRECTED_DEST_WIDTH)*3, DST, ((END)-(SRC))*DEST_PIXEL_SIZE*4); \
+}
+#endif
+
+#include "blit_core.h"
+#undef COPY_LINE
+break;
+
+/* 4x4 scanlines */
+case 0x10404:
+
+/* should we use doublebuffering ? */
+#ifdef DOUBLEBUFFER
+#define COPY_LINE(SRC, END, DST) \
+{ \
+   COPY_LINE2(SRC, END, (DEST_PIXEL *)doublebuffer_buffer) \
+   memcpy((DST),                          doublebuffer_buffer, ((END)-(SRC))*DEST_PIXEL_SIZE*4); \
+   memcpy((DST)+(CORRECTED_DEST_WIDTH),   doublebuffer_buffer, ((END)-(SRC))*DEST_PIXEL_SIZE*4); \
+   memcpy((DST)+(CORRECTED_DEST_WIDTH)*2, doublebuffer_buffer, ((END)-(SRC))*DEST_PIXEL_SIZE*4); \
+}
+#else
+#define COPY_LINE(SRC, END, DST) \
+{ \
+   COPY_LINE2(SRC, END, DST) \
+   memcpy((DST)+(CORRECTED_DEST_WIDTH),   DST, ((END)-(SRC))*DEST_PIXEL_SIZE*4); \
+   memcpy((DST)+(CORRECTED_DEST_WIDTH)*2, DST, ((END)-(SRC))*DEST_PIXEL_SIZE*4); \
+}
+#endif
+
+#include "blit_core.h"
+#undef COPY_LINE
+break;
+
+#undef COPY_LINE2
+#undef SCALE_X
+#undef SCALE_X_8
+#undef SCALE_Y
+#undef SCALE_Y_8
+
+#endif /* #ifndef PACK_BITS */
+
+/* Generic scaling code here (arbitrary values) */
+
+/* This is what happens when you give an assembly-language programmer
+   a C compiler.  Thanks to td, of course.                             -JDL */
+
+default:
+
+#ifdef INDIRECT
+
+#ifdef PACK_BITS
+#define COPY_LINE2(SRC, END, DST) \
+   SRC_PIXEL  *src = SRC; \
+   SRC_PIXEL  *end = END; \
+   DEST_PIXEL *dst = DST; \
+   DEST_PIXEL pixel; \
+   int i, step=0; \
+   for(;src<end;src++) \
+   { \
+      pixel = INDIRECT[*src]; \
+      for(i=0; i<widthscale; i++,step=(step+1)%4) \
+      { \
+         switch(step) \
+         { \
+            case 0: \
+               *(dst  )  = pixel; \
+               break; \
+            case 1: \
+               *(dst  ) |= pixel << 24; \
+               *(dst+1)  = pixel >> 8; \
+               break; \
+            case 2: \
+               *(dst+1) |= pixel << 16; \
+               *(dst+2)  = pixel >> 16; \
+               break; \
+            case 3: \
+               *(dst+2) |= pixel << 8; \
+               dst+=3; \
+               break; \
+         } \
+      } \
+   }
+#else
+#define COPY_LINE2(SRC, END, DST) \
+   SRC_PIXEL  *src = SRC; \
+   SRC_PIXEL  *end = END; \
+   DEST_PIXEL *dst = DST; \
+   int i; \
+   for(;src<end;src++) \
+   { \
+      i=(widthscale+7)/8; \
+      dst+=widthscale%8; \
+      switch (widthscale%8) \
+      { \
+         case 0: do{  dst+=8; \
+                      *(dst-8) = INDIRECT[*(src)]; \
+         case 7:      *(dst-7) = INDIRECT[*(src)]; \
+         case 6:      *(dst-6) = INDIRECT[*(src)]; \
+         case 5:      *(dst-5) = INDIRECT[*(src)]; \
+         case 4:      *(dst-4) = INDIRECT[*(src)]; \
+         case 3:      *(dst-3) = INDIRECT[*(src)]; \
+         case 2:      *(dst-2) = INDIRECT[*(src)]; \
+         case 1:      *(dst-1) = INDIRECT[*(src)]; \
+                 } while(--i>0); \
+      } \
+   }
+#endif
+
+#else
+#define COPY_LINE2(SRC, END, DST) \
+   SRC_PIXEL  *src = SRC; \
+   SRC_PIXEL  *end = END; \
+   DEST_PIXEL *dst = DST; \
+   int i; \
+   for(;src<end;src++) \
+   { \
+      i=(widthscale+7)/8; \
+      dst+=widthscale%8; \
+      switch (widthscale%8) \
+      { \
+         case 0: do{  dst+=8; \
+                      *(dst-8) = *(src); \
+         case 7:      *(dst-7) = *(src); \
+         case 6:      *(dst-6) = *(src); \
+         case 5:      *(dst-5) = *(src); \
+         case 4:      *(dst-4) = *(src); \
+         case 3:      *(dst-3) = *(src); \
+         case 2:      *(dst-2) = *(src); \
+         case 1:      *(dst-1) = *(src); \
+                 } while(--i>0); \
+      } \
+   }
+#endif
+
+#define SCALE_X(X)   ((X)*widthscale)
+#define SCALE_X_8(X) ((X)*widthscale*8)
+#define SCALE_Y(Y)   ((Y)*heightscale)
+#define SCALE_Y_8(Y) ((Y)*heightscale*8)
+
+/* should we use doublebuffering ? */
+#ifdef DOUBLEBUFFER
+#define COPY_LINE(SRC, END, DST) \
+{ \
+   int max_i = heightscale-use_scanlines; \
+   COPY_LINE2(SRC, END, (DEST_PIXEL *)doublebuffer_buffer) \
+   dst = (DST); \
+   if (max_i < 1) max_i = 1; \
+   for(i=0; i<max_i; i++, dst+=CORRECTED_DEST_WIDTH) \
+      memcpy(dst, doublebuffer_buffer, ((END)-(SRC))*DEST_PIXEL_SIZE*widthscale); \
+}
+#else
+#define COPY_LINE(SRC, END, DST) \
+{ \
+   COPY_LINE2(SRC, END, DST) \
+   dst = (DST) + (CORRECTED_DEST_WIDTH); \
+   for(i=1; i<(heightscale-use_scanlines); i++, dst+=CORRECTED_DEST_WIDTH) \
+      memcpy(dst, DST, ((END)-(SRC))*DEST_PIXEL_SIZE*widthscale); \
+}
+#endif
+
+#include "blit_core.h"
+#undef COPY_LINE
+
+#undef COPY_LINE2
+#undef SCALE_X
+#undef SCALE_X_8
+#undef SCALE_Y
+#undef SCALE_Y_8
+
+break;      
+}
+
+#ifdef DEST_SCALE
+#undef DEST_SCALE
+#endif
+#undef DEST_PIXEL_SIZE
+#undef CORRECTED_DEST_WIDTH
diff --git a/src/unix/sysdep/blit_3.h b/src/unix/sysdep/blit_3.h
new file mode 100644
index 0000000..5eef343
--- /dev/null
+++ b/src/unix/sysdep/blit_3.h
@@ -0,0 +1,89 @@
+/* this file is used by blit.h don't use it directly ! */
+
+#define DEST_SCALE_X(X)   DEST_SCALE(SCALE_X(X))
+#define DEST_SCALE_X_8(X) DEST_SCALE(SCALE_X(X) * 8)
+#define DEST_SCALE_Y(Y)   DEST_SCALE(SCALE_Y(Y))
+#define DEST_SCALE_Y_8(Y) DEST_SCALE(SCALE_Y(Y) * 8)
+
+switch(use_dirty)
+{
+   case 0: /* non dirty */
+   {
+#ifdef DEST
+      int src_width = (((SRC_PIXEL *)bitmap->line[1]) -
+         ((SRC_PIXEL *)bitmap->line[0]));
+      SRC_PIXEL *line_src = (SRC_PIXEL *)bitmap->line[src_y] + src_x;
+      SRC_PIXEL *line_end = (SRC_PIXEL *)bitmap->line[src_y + src_height] +
+         src_x + src_width;
+      DEST_PIXEL *line_dest = (DEST_PIXEL *)(DEST);
+      
+      for (;line_src < line_end; line_dest+=DEST_SCALE_Y(DEST_WIDTH),
+         line_src+=src_width)
+         COPY_LINE(line_src, line_src+src_width, line_dest)
+#endif
+#ifdef PUT_IMAGE
+      PUT_IMAGE(src_x, src_y, dest_x, dest_y,
+         SCALE_X(src_width), SCALE_Y(src_height))
+#endif      
+      break;
+   }
+   case 1: /* normal dirty */
+      osd_dirty_merge();
+   case 2: /* vector */
+   {
+      int y, max_y = (src_y + src_width) >> 3;
+#ifdef DEST
+      DEST_PIXEL *line_dest = (DEST_PIXEL *)(DEST);
+      for (y = src_y>>3; y < max_y; y++, line_dest += DEST_SCALE_Y_8(DEST_WIDTH))
+#else
+      for (y = src_y>>3; y < max_y; y++)
+#endif      
+      {
+         if (bitmap->dirty_lines[y])
+         {
+            int x, max_x;
+            max_x = (src_x + src_width) >> 3;
+            for(x = src_x>>3; x < max_x; x++)
+            {
+               if (bitmap->dirty_blocks[y][x])
+               {
+                  int min_x;
+#ifdef DEST
+                  int max_x, h, max_h;
+                  DEST_PIXEL *block_dest = line_dest + DEST_SCALE_X_8(x);
+#endif
+                  min_x = x << 3;
+                  do {
+                     bitmap->dirty_blocks[y][x]=0;
+                     x++;
+                  } while (bitmap->dirty_blocks[y][x]);
+#ifdef DEST                  
+                  max_x = x << 3;
+                  h     = y << 3;
+                  max_h = h + 8;
+                  for (; h<max_h; h++, block_dest += DEST_SCALE_Y(DEST_WIDTH))
+                     COPY_LINE((SRC_PIXEL *)bitmap->line[h]+min_x,
+                        (SRC_PIXEL *)bitmap->line[h]+max_x, block_dest)
+#endif
+#ifdef PUT_IMAGE
+                  PUT_IMAGE(
+                     min_x,
+                     y << 3,
+                     dest_x + SCALE_X(min_x - src_x),
+                     dest_y + SCALE_Y((y << 3) - src_y),
+                     SCALE_X((x<<3) - min_x),
+                     SCALE_Y(8))
+#endif
+               }
+            }
+            bitmap->dirty_lines[y] = 0;
+         }
+      }
+      break;
+   }
+}
+
+#undef DEST_SCALE_X
+#undef DEST_SCALE_X_8
+#undef DEST_SCALE_Y
+#undef DEST_SCALE_Y_8
diff --git a/src/unix/sysdep/dsp-drivers/alsa.c b/src/unix/sysdep/dsp-drivers/alsa.c
new file mode 100644
index 0000000..1990565
--- /dev/null
+++ b/src/unix/sysdep/dsp-drivers/alsa.c
@@ -0,0 +1,598 @@
+/*
+ * ALSA Sound Driver for xMAME
+ *
+ *  Copyright 2000 Luc Saillard <luc.saillard@alcove.fr>
+ *  Copyright 2001, 2002, 2003 Shyouzou Sugitani <shy@debian.or.jp>
+ *  
+ *  This file and the acompanying files in this directory are free software;
+ *  you can redistribute them and/or modify them under the terms of the GNU
+ *  Library General Public License as published by the Free Software Foundation;
+ *  either version 2 of the License, or (at your option) any later version.
+ *
+ *  These files are distributed in the hope that they will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Library General Public
+ *  License along with these files; see the file COPYING.LIB.  If not,
+ *  write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ *  Boston, MA 02111-1307, USA.
+ *
+ * Changelog:
+ *   v 0.1 Thu, 10 Aug 2000 08:29:00 +0200
+ *     - initial release
+ *     - TODO: find the best sound card to play sound.
+ *   v 0.2 Wed, 13 Sep 2000    Shyouzou Sugitani <shy@debian.or.jp>
+ *     - change from block to stream mode.
+ *   v 0.3 Sat, 16 Sep 2000    Shyouzou Sugitani <shy@debian.or.jp>
+ *     - one important bug fix, performance improvements and code cleanup.
+ *   v 0.4 Sun, 15 Apr 2001    Shyouzou Sugitani <shy@debian.or.jp>
+ *     - minor cosmetic changes.
+ *     - suppression of bogus warnings about underruns.
+ *     - TODO: add support for ALSA 0.9 API.
+ *   v 0.5 Thu, 17 May 2001    Shyouzou Sugitani <shy@debian.or.jp>
+ *     - added preliminary support for ALSA 0.9 API.
+ *     - split of the 0.5 and 0.9 API stuff into separate files.
+ *   v 0.6 Sat, 19 May 2001    Shyouzou Sugitani <shy@debian.or.jp>
+ *     - update of the 0.9 API stuff.
+ *       added -list-alsa-pcm option.
+ *       improved write error handling.
+ *   v 0.7 Sat, 08 Sep 2001    Shyouzou Sugitani <shy@debian.or.jp>
+ *     - update of the 0.9 API stuff.
+ *       added -alsa-buffer option.
+ *       use SND_PCM_FORMAT_S16 instead of SND_PCM_FORMAT_S16_{LE,BE}.
+ *   v 0.8 Thu, 13 Sep 2001    Shyouzou Sugitani <shy@debian.or.jp>
+ *     - update of the 0.9 API stuff.
+ *       changed the -alsapcm(-pcm) to -alsa-pcm(-apcm).
+ *       changed the default value of the -alsa-pcm.
+ *   V 0.8a                    Stephen Anthony
+ *     - Fixed a problem in the ALSA 0.9 driver with setting the sample rate
+ *       on SB128 soundcards.
+ *   V 0.9 Mon, 13 Jan 2003    Shyouzou Sugitani <shy@debian.or.jp>
+ *     - removed the 0.5 API support.
+ *
+ */
+
+#include "xmame.h"           /* xMAME common header */
+#include "devices.h"         /* xMAME device header */
+
+#ifdef SYSDEP_DSP_ALSA
+
+#include <sys/ioctl.h>       /* System and I/O control */
+#include <alsa/asoundlib.h>  /* ALSA sound library header */
+#include "sysdep/sysdep_dsp.h"
+#include "sysdep/sysdep_dsp_priv.h"
+#include "sysdep/plugin_manager.h"
+
+/* our per instance private data struct */
+struct alsa_dsp_priv_data
+{
+	snd_pcm_t *pcm_handle;
+};
+
+/* public methods prototypes (static but exported through the sysdep_dsp or
+   plugin struct) */
+static int alsa_dsp_init(void);
+static void *alsa_dsp_create(const void *flags);
+static void alsa_dsp_destroy(struct sysdep_dsp_struct *dsp);
+static int alsa_dsp_get_freespace(struct sysdep_dsp_struct *dsp);
+static int alsa_dsp_write(struct sysdep_dsp_struct *dsp, unsigned char *data,
+			  int count);
+static int alsa_device_list(struct rc_option *option, const char *arg,
+			    int priority);
+static int alsa_pcm_list(struct rc_option *option, const char *arg,
+			 int priority);
+static int alsa_dsp_set_params(struct alsa_dsp_priv_data *priv);
+
+/* public variables */
+
+static struct {
+        snd_pcm_format_t format;
+        unsigned int channels;
+        unsigned int rate;
+} pcm_params;
+
+static char *pcm_name = NULL;
+static snd_pcm_stream_t stream = SND_PCM_STREAM_PLAYBACK;
+static size_t bits_per_sample, bits_per_frame;
+static unsigned int buffer_time;
+
+struct rc_option alsa_dsp_opts[] = {
+	/* name, shortname, type, dest, deflt, min, max, func, help */
+	{ "Alsa Sound System", NULL,     rc_seperator, NULL,
+	  NULL,    0,      0,    NULL,
+	  NULL },
+	{ "list-alsa-cards", NULL,	rc_use_function_no_arg, NULL,
+	  NULL,    0,      0,    alsa_device_list,
+	  "List available sound cards" },
+	{ "list-alsa-pcm", NULL,	rc_use_function_no_arg, NULL,
+	  NULL,    0,      0,    alsa_pcm_list,
+	  "List available pcm devices" },
+	{ "alsa-pcm",    "apcm",  rc_string,    &pcm_name,
+	  "default",     0,    0,    NULL,
+	  "Specify the PCM by name" },
+	{ "alsa-buffer", "abuf",  rc_int,       &buffer_time,
+	  "250000",      0,    0,    NULL,
+	  "Set the buffer size [micro sec] (default: 250000)" },
+	{ NULL,    NULL,     rc_end,   NULL,
+	  NULL,    0,      0,    NULL,
+	  NULL }
+};
+
+const struct plugin_struct sysdep_dsp_alsa = {
+	"alsa",
+	"sysdep_dsp",
+	"Alsa Sound System DSP plugin",
+	alsa_dsp_opts,
+	alsa_dsp_init,
+	NULL, /* no exit */
+	alsa_dsp_create,
+	4     /* high priority */
+};
+
+/* private variables */
+static int alsa_dsp_bytes_per_sample[4] = SYSDEP_DSP_BYTES_PER_SAMPLE;
+
+
+/* public methods (static but exported through the sysdep_dsp or plugin
+   struct) */
+
+/*
+ * Function name : alsa_dsp_init
+ *
+ * Description : Detect if a card is present on the machine
+ * Output :
+ *   a boolean
+ */
+static int alsa_dsp_init(void)
+{
+	int card = -1;
+	
+	if (snd_card_next(&card) < 0 || card < 0) {
+		fprintf(stderr, "No cards detected.\n"
+			"ALSA sound disabled.\n");
+		return 1;
+	}
+	return 0;
+}
+
+/*
+ * Function name : alsa_dsp_create
+ *
+ * Description : Create an instance of dsp plugins
+ * Input :
+ *   flags: a ptr to struct sysdep_dsp_create_params
+ * Output :
+ *   a ptr to a struct sysdep_dsp_struct
+ */
+static void *alsa_dsp_create(const void *flags)
+{
+	int err;
+	struct alsa_dsp_priv_data *priv = NULL;
+	struct sysdep_dsp_struct *dsp = NULL;
+	const struct sysdep_dsp_create_params *params = flags;
+	snd_pcm_info_t *info;
+	int open_mode = 0;
+
+	/* allocate the dsp struct */
+	dsp = calloc(1, sizeof(struct sysdep_dsp_struct));
+	if (!dsp) {
+		fprintf(stderr,
+			"error malloc failed for struct sysdep_dsp_struct\n");
+		return NULL;
+	}
+
+	/* alloc private data */
+	priv = calloc(1, sizeof(struct alsa_dsp_priv_data));
+	if(!priv) {
+		fprintf(stderr,
+			"error malloc failed for struct alsa_dsp_priv_data\n");
+		alsa_dsp_destroy(dsp);
+		return NULL;
+	}
+
+	/* fill in the functions and some data */
+	memset(priv,0,sizeof(struct alsa_dsp_priv_data));
+	dsp->_priv = priv;
+	dsp->get_freespace = alsa_dsp_get_freespace;
+	dsp->write = alsa_dsp_write;
+	dsp->destroy = alsa_dsp_destroy;
+	dsp->hw_info.type = params->type;
+	dsp->hw_info.samplerate = params->samplerate;
+	dsp->hw_info.bufsize = 0;
+
+	open_mode |= SND_PCM_NONBLOCK;
+
+	pcm_params.format = (dsp->hw_info.type & SYSDEP_DSP_16BIT) ?
+		SND_PCM_FORMAT_S16 /* Signed 16 bit CPU endian */ :
+		SND_PCM_FORMAT_U8;
+
+	/* rate >= 2000 && rate <= 128000 */
+	pcm_params.rate = dsp->hw_info.samplerate;
+	pcm_params.channels = (dsp->hw_info.type & SYSDEP_DSP_STEREO) ? 2 : 1;
+
+	err = snd_pcm_open(&priv->pcm_handle, pcm_name, stream, open_mode);
+	if (err < 0) {
+		fprintf(stderr_file, "Alsa error: audio open error: %s\n",
+			snd_strerror(err));
+		return NULL;
+	}
+
+	snd_pcm_info_alloca(&info);
+	err = snd_pcm_info(priv->pcm_handle, info);
+	if (err < 0) {
+		fprintf(stderr_file, "Alsa error: info error: %s\n",
+			snd_strerror(err));
+		return NULL;
+	}
+	/* set non-blocking mode if selected */
+	if (params->flags & SYSDEP_DSP_O_NONBLOCK) {
+		err = snd_pcm_nonblock(priv->pcm_handle, 1);
+		if (err < 0) {
+			fprintf(stderr_file,
+				"Alsa error: nonblock setting error: %s\n",
+				snd_strerror(err));
+			return NULL;
+		}
+	}
+
+	fprintf(stderr_file, "info: set to %dbit linear %s %dHz\n",
+		(dsp->hw_info.type & SYSDEP_DSP_16BIT) ? 16 : 8,
+		(dsp->hw_info.type & SYSDEP_DSP_STEREO) ? "stereo" : "mono",
+		dsp->hw_info.samplerate);
+
+	if (alsa_dsp_set_params(priv) == 0)
+		return NULL;
+
+	return dsp;
+}
+
+/*
+ * Function name : alsa_dsp_destroy
+ *
+ * Description :
+ * Input :
+ * Output :
+ */
+static void alsa_dsp_destroy(struct sysdep_dsp_struct *dsp)
+{
+	struct alsa_dsp_priv_data *priv = dsp->_priv;
+
+	if (priv) {
+		if (priv->pcm_handle) {
+			snd_pcm_close(priv->pcm_handle);
+		}
+		free(priv);
+	}
+	free(dsp);
+}
+
+/*
+ * Function name : alsa_dsp_get_freespace
+ *
+ * Description :
+ * Input :
+ * Output :
+ */
+static int alsa_dsp_get_freespace(struct sysdep_dsp_struct *dsp)
+{
+	int err;
+	struct alsa_dsp_priv_data *priv = dsp->_priv;
+	snd_pcm_status_t *status;
+	snd_pcm_uframes_t frames;
+
+	snd_pcm_status_alloca(&status);
+	err = snd_pcm_status(priv->pcm_handle, status);
+	if (err < 0) {
+		fprintf(stderr_file, "Alsa error: status error: %s\n",
+			snd_strerror(err));
+		return -1;
+	}
+	frames = snd_pcm_status_get_avail(status);
+	if (frames < 0)
+		return -1;
+	else
+		return frames * bits_per_frame / 8
+			/ alsa_dsp_bytes_per_sample[dsp->hw_info.type];
+}
+
+/*
+ * Function name : alsa_dsp_write
+ *
+ * Description :
+ * Input :
+ * Output :
+ */
+static int alsa_dsp_write(struct sysdep_dsp_struct *dsp, unsigned char *data,
+			  int count)
+{
+	int data_size, result;
+	struct alsa_dsp_priv_data *priv = dsp->_priv;
+
+	data_size = count * alsa_dsp_bytes_per_sample[dsp->hw_info.type]
+		* 8 / bits_per_frame;
+
+	result = snd_pcm_writei(priv->pcm_handle, data, data_size);
+	if (result == -EAGAIN) {
+		return 0;
+	} else if (result == -EPIPE) {
+		int err;
+		snd_pcm_status_t *status;
+
+		snd_pcm_status_alloca(&status);
+		err = snd_pcm_status(priv->pcm_handle, status);
+		if (err < 0) {
+			fprintf(stderr_file,
+				"Alsa error: status error: %s\n",
+				snd_strerror(err));
+			return -1;
+		}
+		if (snd_pcm_status_get_state(status) == SND_PCM_STATE_XRUN) {
+			err = snd_pcm_prepare(priv->pcm_handle);
+			if (err < 0) {
+				fprintf(stderr_file,
+					"Alsa error: prepare error: %s\n",
+					snd_strerror(err));
+				return -1;
+			}
+			/* ok, data should be accepted again */
+			return 0;
+		}
+		fprintf(stderr_file, "Alsa error: write error: %s\n",
+			snd_strerror(result));
+		return -1;
+	} else if (result < 0) {
+		fprintf(stderr_file, "Alsa error: write error: %s\n",
+			snd_strerror(result));
+		return -1;
+	}
+
+	return result * bits_per_frame / 8
+		/ alsa_dsp_bytes_per_sample[dsp->hw_info.type];
+}
+
+/*
+ * Function name : alsa_device_list
+ *
+ * Description :
+ * Input :
+ * Output :
+ */
+static int alsa_device_list(struct rc_option *option, const char *arg,
+			    int priority)
+{
+	snd_ctl_t *handle;
+	int card, err, dev;
+	snd_ctl_card_info_t *info;
+	snd_pcm_info_t *pcminfo;
+	snd_ctl_card_info_alloca(&info);
+	snd_pcm_info_alloca(&pcminfo);
+
+	card = -1;
+	if (snd_card_next(&card) < 0 || card < 0) {
+		printf("Alsa: no soundcards found...\n");
+		return -1;
+	}
+	fprintf(stdout, "Alsa cards:\n");
+	while (card >= 0) {
+		char name[32];
+		sprintf(name, "hw:%d", card);
+		err = snd_ctl_open(&handle, name, 0);
+		if (err < 0) {
+			fprintf(stderr, "Alsa error: control open (%i): %s\n",
+				card, snd_strerror(err));
+			continue;
+		}
+		err = snd_ctl_card_info(handle, info);
+		if (err < 0) {
+			fprintf(stderr,
+				"Alsa error: control hardware info (%i): %s\n",
+				card, snd_strerror(err));
+			snd_ctl_close(handle);
+			continue;
+		}
+		dev = -1;
+		while (1) {
+			int idx;
+			unsigned int count;
+
+			if (snd_ctl_pcm_next_device(handle, &dev) < 0)
+				;
+			if (dev < 0)
+				break;
+			snd_pcm_info_set_device(pcminfo, dev);
+			snd_pcm_info_set_subdevice(pcminfo, 0);
+			snd_pcm_info_set_stream(pcminfo, stream);
+			err = snd_ctl_pcm_info(handle, pcminfo);
+			if (err < 0) {
+				if (err != -ENOENT)
+					fprintf(stderr,
+						"Alsa error: control digital audio info (%i): %s\n",
+						card, snd_strerror(err));
+				continue;
+			}
+			fprintf(stderr,
+				"card %i: %s [%s], device %i: %s [%s]\n",
+				card,
+				snd_ctl_card_info_get_id(info),
+				snd_ctl_card_info_get_name(info),
+				dev,
+				snd_pcm_info_get_id(pcminfo),
+				snd_pcm_info_get_name(pcminfo));
+			count = snd_pcm_info_get_subdevices_count(pcminfo);
+			fprintf(stderr, "  Subdevices: %i/%i\n",
+				snd_pcm_info_get_subdevices_avail(pcminfo),
+				count);
+			for (idx = 0; idx < count; idx++) {
+				snd_pcm_info_set_subdevice(pcminfo, idx);
+				err = snd_ctl_pcm_info(handle, pcminfo);
+				if (err < 0) {
+					fprintf(stderr,
+						"Alsa error: control digital audio playback info (%i): %s",
+						card, snd_strerror(err));
+				} else {
+					fprintf(stderr,
+						"  Subdevice #%i: %s\n",
+						idx, snd_pcm_info_get_subdevice_name(pcminfo));
+				}
+			}
+		}
+		snd_ctl_close(handle);
+		if (snd_card_next(&card) < 0) {
+			break;
+		}
+	}
+	return -1;
+}
+
+/*
+ * Function name : alsa_pcm_list
+ *
+ * Description :
+ * Input :
+ * Output :
+ */
+static int alsa_pcm_list(struct rc_option *option, const char *arg,
+			 int priority)
+{
+        snd_config_t *conf;
+        snd_output_t *out;
+
+        int err;
+
+	err = snd_config_update();
+        if (err < 0) {
+		fprintf(stderr, "Alsa error: snd_config_update: %s\n",
+			snd_strerror(err));
+                return -1;
+        }
+        snd_output_stdio_attach(&out, stderr, 0);
+        err = snd_config_search(snd_config, "pcm", &conf);
+        if (err < 0)
+                return -1;
+        fprintf(stderr, "ALSA PCM devices:\n");
+        snd_config_save(conf, out);
+        snd_output_close(out);
+
+	return -1;
+}
+
+/*
+ * Function name : alsa_dsp_set_params
+ *
+ * Description :
+ * Input :
+ *   priv: a ptr to struct alsa_dsp_priv_data
+ * Output :
+ *  priv is modified with the current parameters.
+ *  a boolean if the card accept the value.
+ *  
+ */
+static int alsa_dsp_set_params(struct alsa_dsp_priv_data *priv)
+{
+	snd_pcm_hw_params_t *hw_params;
+	snd_pcm_sw_params_t *sw_params;
+
+	size_t buffer_size;
+	int chunk_size;
+	int err;
+
+	snd_pcm_hw_params_alloca(&hw_params);
+	snd_pcm_sw_params_alloca(&sw_params);
+	err = snd_pcm_hw_params_any(priv->pcm_handle, hw_params);
+	if (err < 0) {
+		fprintf(stderr_file,
+			"Alsa error: no configurations available\n");
+		return 0;
+	}
+
+	if (snd_pcm_hw_params_set_access(priv->pcm_handle, hw_params,
+					 SND_PCM_ACCESS_RW_INTERLEAVED) < 0) {
+		fprintf(stderr_file,
+			"Alsa error: interleaved access mode non available\n");
+		return 0;
+	}
+
+	err = snd_pcm_hw_params_set_format(priv->pcm_handle, hw_params, pcm_params.format);
+	if (err < 0) {
+		fprintf(stderr_file,
+			"Alsa error: requested format %s isn't supported with hardware\n",
+			snd_pcm_format_name(pcm_params.format));
+		return 0;
+	}
+
+	err = snd_pcm_hw_params_set_channels(priv->pcm_handle, hw_params, pcm_params.channels);
+	if (err < 0) {
+		fprintf(stderr_file,
+			"Alsa error: channels count non available\n");
+		return 0;
+	}
+
+	if (snd_pcm_hw_params_set_rate_near(priv->pcm_handle, hw_params, pcm_params.rate, 0) < 0) {
+		fprintf(stderr_file,
+			"Alsa error: unsupported rate %iHz (valid range is %iHz-%iHz)\n",
+			pcm_params.rate,
+			snd_pcm_hw_params_get_rate_min(hw_params, 0),
+			snd_pcm_hw_params_get_rate_max(hw_params, 0));
+		return 0;
+	}
+
+	snd_pcm_hw_params_set_buffer_time_near(priv->pcm_handle, hw_params, buffer_time, 0);
+	snd_pcm_hw_params_set_period_size_near(priv->pcm_handle, hw_params, 1, 0);
+
+	err = snd_pcm_hw_params(priv->pcm_handle, hw_params);
+	if (err < 0) {
+		fprintf(stderr_file,
+			"Alsa error: Unable to install hw params\n");
+		return 0;
+	}
+
+	chunk_size = snd_pcm_hw_params_get_period_size(hw_params, 0);
+	buffer_size = snd_pcm_hw_params_get_buffer_size(hw_params);
+	if (chunk_size == buffer_size) {
+		fprintf(stderr_file,
+			"Alsa error: cannot use period equal to buffer size (%u == %lu)\n",
+			chunk_size, (long)buffer_size);
+		return 0;
+	}
+
+	snd_pcm_sw_params_current(priv->pcm_handle, sw_params);
+
+	snd_pcm_sw_params_set_sleep_min(priv->pcm_handle, sw_params, 0);
+	snd_pcm_sw_params_set_xfer_align(priv->pcm_handle, sw_params, 1);
+	snd_pcm_sw_params_set_avail_min(priv->pcm_handle, sw_params, 1);
+
+	snd_pcm_sw_params_set_start_threshold(priv->pcm_handle, sw_params, 1);
+
+	snd_pcm_sw_params_set_stop_threshold(priv->pcm_handle, sw_params, buffer_size);
+
+	if (snd_pcm_sw_params(priv->pcm_handle, sw_params) < 0) {
+		fprintf(stderr_file, "Alsa error: unable to install sw params\n");
+		return 0;
+	}
+
+#if 0 /* DEBUG */
+	{
+		snd_output_t *log;
+		snd_output_stdio_attach(&log, stderr_file, 0);
+		snd_pcm_dump(priv->pcm_handle, log);
+		snd_output_close(log);
+	}
+#endif
+
+	bits_per_sample = snd_pcm_format_physical_width(pcm_params.format);
+	bits_per_frame = bits_per_sample * pcm_params.channels;
+
+	err = snd_pcm_prepare(priv->pcm_handle);
+	if (err < 0) {
+		fprintf(stderr_file,
+			"Alsa error: unable to prepare audio: %s\n",
+			snd_strerror(err));
+		return 0;
+	}
+
+	return 1;
+}
+
+#endif /* SYSDEP_DSP_ALSA */
diff --git a/src/unix/sysdep/dsp-drivers/arts.c b/src/unix/sysdep/dsp-drivers/arts.c
new file mode 100644
index 0000000..b857feb
--- /dev/null
+++ b/src/unix/sysdep/dsp-drivers/arts.c
@@ -0,0 +1,197 @@
+#ifdef SYSDEP_DSP_ARTS_SMOTEK
+
+/* Sysdep aRts sound dsp driver
+ 
+   Copyright 2001 Petr Smotek
+ 
+   This file and the acompanying files in this directory are free software;
+   you can redistribute them and/or modify them under the terms of the GNU
+   Library General Public License as published by the Free Software Foundation;
+   either version 2 of the License, or (at your option) any later version.
+ 
+   These files are distributed in the hope that they will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+ 
+   You should have received a copy of the GNU Library General Public
+   License along with these files; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.
+*/
+/* Changelog
+Version 0.1, May 16 2001
+-initial release, based on the xmame oss and esound drivers done by
+ Hans de Goede (Petr Smotek)
+*/
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+
+#include <artsc.h>
+
+#include "sysdep/sysdep_dsp.h"
+#include "sysdep/sysdep_dsp_priv.h"
+#include "sysdep/plugin_manager.h"
+
+/* #define ARTS_DEBUG */
+
+/* our per instance private data struct */
+struct arts_dsp_priv_data {
+   arts_stream_t stream;
+};
+
+/* public methods prototypes (static but exported through the sysdep_dsp or
+   plugin struct) */
+static void *arts_dsp_create(const void *flags);
+static void arts_dsp_destroy(struct sysdep_dsp_struct *dsp);
+static int arts_dsp_write(struct sysdep_dsp_struct *dsp, unsigned char *data,
+   int count);
+
+/* public variables */
+const struct plugin_struct sysdep_dsp_arts = {
+   "arts",
+   "sysdep_dsp",
+   "aRts DSP plugin",
+   NULL,
+   NULL,
+   NULL,
+   arts_dsp_create,
+   2 
+};
+
+/* private variables */
+static int arts_dsp_bytes_per_sample[4] = SYSDEP_DSP_BYTES_PER_SAMPLE;
+
+/* public methods (static but exported through the sysdep_dsp or plugin
+   struct) */
+static void *arts_dsp_create(const void *flags)
+{
+   int i, j, result, bits, channels, block;
+   struct arts_dsp_priv_data *priv = NULL;
+   struct sysdep_dsp_struct *dsp = NULL;
+   const struct sysdep_dsp_create_params *params = flags;
+   
+   /* allocate the dsp struct */
+   if (!(dsp = calloc(1, sizeof(struct sysdep_dsp_struct))))
+   {
+      fprintf(stderr,
+         "error malloc failed for struct sysdep_dsp_struct\n");
+      return NULL;
+   }
+   
+   /* alloc private data */
+   if(!(priv = calloc(1, sizeof(struct arts_dsp_priv_data))))
+   {
+      fprintf(stderr,
+         "error malloc failed for struct arts_dsp_priv_data\n");
+      arts_dsp_destroy(dsp);
+      return NULL;
+   }
+   
+   /* fill in the functions and some data */
+   priv->stream = NULL;
+   dsp->_priv = priv;
+   dsp->write = arts_dsp_write;
+   dsp->destroy = arts_dsp_destroy;
+   dsp->hw_info.type = params->type;
+   dsp->hw_info.samplerate = params->samplerate;
+
+   result = arts_init();
+   if (result < 0)
+   {
+      fprintf(stderr,
+         "arts_init error: %s\n", arts_error_text(result));
+      arts_dsp_destroy(dsp);
+      return NULL;
+   }
+
+   bits = (dsp->hw_info.type & SYSDEP_DSP_16BIT) ? 16 : 8;
+   channels = (dsp->hw_info.type & SYSDEP_DSP_STEREO) ? 2 : 1;
+   priv->stream = arts_play_stream(dsp->hw_info.samplerate, bits, channels,
+      "xmame arts");
+
+   block = (params->flags & SYSDEP_DSP_O_NONBLOCK) ? 0 : 1;
+   result = arts_stream_set(priv->stream, ARTS_P_BLOCKING, block);
+   if (result < 0)
+   {
+      fprintf(stderr,
+         "arts_stream_set error: %s\n", arts_error_text(result));
+      arts_dsp_destroy(dsp);
+      return NULL;
+   }
+   else 
+   {
+      if (result != block)
+      {
+         fprintf(stderr,
+            "arts_stream_set ARTS_P_BLOCKING to %d failed\n", block);
+         arts_dsp_destroy(dsp);
+         return NULL;
+      }
+   }
+
+   /* calculate fragsize & number of frags */
+   /* fragsize (as power of 2) */
+   i = 7;
+   if (dsp->hw_info.type & SYSDEP_DSP_16BIT) i++;
+   if (dsp->hw_info.type & SYSDEP_DSP_STEREO) i++;
+   i += dsp->hw_info.samplerate / 22050;
+ 
+   /* number of frags */
+   j = ((dsp->hw_info.samplerate * arts_dsp_bytes_per_sample[dsp->hw_info.type] * params->bufsize) / (0x01 << i)) + 1;
+
+   arts_stream_set(priv->stream, ARTS_P_BUFFER_SIZE, (0x01<<i)*j);
+
+#ifdef ARTS_DEBUG
+   /* print some info messages ;) */
+   fprintf(stderr, "info: aRts buffer size    : %d\n", 
+      arts_stream_get(priv->stream, ARTS_P_BUFFER_SIZE));
+   fprintf(stderr, "info: aRts buffer time    : %d\n",
+      arts_stream_get(priv->stream, ARTS_P_BUFFER_TIME));
+   fprintf(stderr, "info: aRts server latency : %d\n",
+      arts_stream_get(priv->stream, ARTS_P_SERVER_LATENCY));
+   fprintf(stderr, "info: aRts total latency  : %d\n",
+      arts_stream_get(priv->stream, ARTS_P_TOTAL_LATENCY));
+   fprintf(stderr, "info: aRts blocking       : %s\n",
+      arts_stream_get(priv->stream, ARTS_P_BLOCKING) ? "yes" : "no");
+#endif /* ifdef ARTS_DEBUG */
+
+   return dsp;
+}
+
+static void arts_dsp_destroy(struct sysdep_dsp_struct *dsp)
+{
+   struct arts_dsp_priv_data *priv = dsp->_priv;
+   
+   if(priv)
+   {
+      if (priv->stream)
+         arts_close_stream(priv->stream);
+      arts_free();
+      free(priv);
+   }
+   free(dsp);
+}
+
+static int arts_dsp_write(struct sysdep_dsp_struct *dsp, unsigned char *data,
+   int count)
+{
+   int result;
+   struct arts_dsp_priv_data *priv = dsp->_priv;
+
+   result = arts_write(priv->stream, data, count *
+      arts_dsp_bytes_per_sample[dsp->hw_info.type]);
+      
+   if (result < 0)
+   {
+      fprintf(stderr,
+         "arts_write error: %s\n", arts_error_text(result));
+      return -1;
+   }
+      
+   return result / arts_dsp_bytes_per_sample[dsp->hw_info.type];
+}
+
+#endif /* ifdef SYSDEP_DSP_ARTS_SMOTEK */
diff --git a/src/unix/sysdep/dsp-drivers/artssound.c b/src/unix/sysdep/dsp-drivers/artssound.c
new file mode 100644
index 0000000..50b0b92
--- /dev/null
+++ b/src/unix/sysdep/dsp-drivers/artssound.c
@@ -0,0 +1,158 @@
+/* Sysdep aRts sound dsp driver
+
+   Copyright 2001 Manuel Teira
+   
+   This file and the acompanying files in this directory are free software;
+   you can redistribute them and/or modify them under the terms of the GNU
+   Library General Public License as published by the Free Software Foundation;
+   either version 2 of the License, or (at your option) any later version.
+
+   These files are distributed in the hope that they will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with these files; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.
+*/
+/* Changelog
+Version 0.1, April 2001
+-initial release, based on the esound mame sound driver
+*/
+
+#ifdef SYSDEP_DSP_ARTS_TEIRA
+#include <stdlib.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <sys/ioctl.h>
+#include <artsc.h>
+#include "sysdep/sysdep_dsp.h"
+#include "sysdep/sysdep_dsp_priv.h"
+#include "sysdep/plugin_manager.h"
+
+
+/* our per instance private data struct */
+struct arts_dsp_priv_data {
+   arts_stream_t stream;
+};
+
+/* public methods prototypes (static but exported through the sysdep_dsp or
+   plugin struct) */
+static void *arts_dsp_create(const void *flags);
+static void arts_dsp_destroy(struct sysdep_dsp_struct *dsp);
+static int arts_dsp_write(struct sysdep_dsp_struct *dsp, unsigned char *data,
+   int count);
+
+static int btime=10;
+
+struct rc_option arts_dsp_opts[] = {
+/* name, shortname, type, dest, */
+/* deflt, min, max, func, help */
+{"artsBufferTime","abt",rc_int, &btime,
+"10",1,1000,NULL,"aRts buffer delay time"},
+{NULL,NULL,rc_end,NULL,NULL,0,0,NULL,NULL}
+};
+
+/* public variables */
+const struct plugin_struct sysdep_dsp_arts = {
+   "arts",
+   "sysdep_dsp",
+   "aRts DSP plugin",
+   arts_dsp_opts, 
+   NULL, /* no init */
+   NULL, /* no exit */
+   arts_dsp_create,
+   3     /* high priority */
+};
+
+/* private variables */
+static int arts_dsp_bytes_per_sample[4] = SYSDEP_DSP_BYTES_PER_SAMPLE;
+
+/* public methods (static but exported through the sysdep_dsp or plugin
+   struct) */
+static void *arts_dsp_create(const void *flags)
+{
+   struct sysdep_dsp_struct *dsp = NULL;
+   struct arts_dsp_priv_data *priv = NULL;
+   const struct sysdep_dsp_create_params *params = flags;
+   
+   
+   /* allocate the dsp struct */
+   if (!(dsp = calloc(1, sizeof(struct sysdep_dsp_struct))))
+   {
+      fprintf(stderr,
+         "error malloc failed for struct sysdep_dsp_struct\n");
+      return NULL;
+   }
+
+   if(!(priv = calloc(1, sizeof(struct arts_dsp_priv_data))))
+   {
+      fprintf(stderr,
+         "error malloc failed for struct arts_dsp_priv_data\n");
+      return NULL;
+   }
+
+   
+   /* fill in the functions and some data */
+   priv->stream=0; 
+   dsp->_priv = priv;
+   dsp->write = arts_dsp_write;
+   dsp->destroy = arts_dsp_destroy;
+   dsp->hw_info.type = params->type;
+   dsp->hw_info.samplerate = params->samplerate;
+   dsp->hw_info.bufsize = 1024;
+   
+   /* open the sound device */
+   arts_init();
+   priv->stream=arts_play_stream(dsp->hw_info.samplerate,
+				 (dsp->hw_info.type&SYSDEP_DSP_16BIT)?16:8,
+				 (dsp->hw_info.type&SYSDEP_DSP_STEREO)?2:1,
+				 "xmame arts");
+   
+   /* Set the buffering time */
+   arts_stream_set(priv->stream,ARTS_P_BUFFER_TIME,btime);
+
+   /* set non-blocking mode if selected */
+   if(params->flags & SYSDEP_DSP_O_NONBLOCK)
+   {
+	   arts_stream_set(priv->stream,ARTS_P_BLOCKING,0);
+   }
+   
+   return dsp;
+}
+
+static void arts_dsp_destroy(struct sysdep_dsp_struct *dsp)
+{
+   struct arts_dsp_priv_data *priv = dsp->_priv;
+   if(priv)
+   {
+	   arts_close_stream(priv->stream);
+	   arts_free();
+	   free(priv);
+   }
+   free(dsp);
+}
+   
+static int arts_dsp_write(struct sysdep_dsp_struct *dsp,
+			  unsigned char *data,
+			  int count)
+{
+   int result;
+   struct arts_dsp_priv_data *priv = dsp->_priv;
+
+   result=arts_write(priv->stream,
+		     data,
+		     count * arts_dsp_bytes_per_sample[dsp->hw_info.type]);
+      
+   if (result<0)
+   {
+      fprintf(stderr, "error: arts_write error: %s\n",
+	      arts_error_text(result));
+      return -1;
+   }
+   return result/arts_dsp_bytes_per_sample[dsp->hw_info.type];
+}
+
+#endif /* ifdef SYSDEP_DSP_ARTS_TEIRA */
diff --git a/src/unix/sysdep/dsp-drivers/coreaudio.c b/src/unix/sysdep/dsp-drivers/coreaudio.c
new file mode 100644
index 0000000..9e7504b
--- /dev/null
+++ b/src/unix/sysdep/dsp-drivers/coreaudio.c
@@ -0,0 +1,460 @@
+/*
+ * Driver for Mac OS X core audio interface, primarily for use
+ * with the OpenStep driver on this system. This driver was written for
+ * the OS X public beta, and emulated lower sample rates and mono sound as
+ * the device did not appear to support anything other than full rate stereo.
+ * Interestingly the released code also does not appear to do this, and thus
+ * this driver has inherited these abilities in order to continue working. If
+ * we discover a way to set the device at some layter date then this code can
+ * be updated then.
+ *
+ * -bat. 12/04/2001 
+ */     
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <pthread.h>
+#include <Carbon/Carbon.h>
+#include <CoreAudio/AudioHardware.h>
+
+#include "sysdep/sysdep_dsp.h"
+#include "sysdep/sysdep_dsp_priv.h"
+#include "sysdep/plugin_manager.h"
+
+#define NAME_LEN 256		/* max length of a device name */
+
+/*
+ * We have to implement a FIFO of blocks of floats, without using up
+ * vast amounts of memory, or being too inefficient. We thus require
+ * the queued blocks to be created by malloc (so we do not have to copy
+ * the data) but free them ourself upon dequeue.
+ */
+
+struct audio_block {
+	float *block_base;		/* base of the memory block */
+	float *current_base;		/* current unread position */
+	int samples_left;		/* number left in block */
+	struct audio_block *next;	/* next block in list */
+};
+
+struct audio_queue {
+	struct audio_block *head;	/* head of queue */
+	struct audio_block *tail;	/* tail of queue */
+	pthread_mutex_t	mutex;		/* queue locking mutex */
+};
+
+/*
+ * Adds a block of audio samples to the end of the given queue. This
+ * function is 'unsafe' and is thus wrapped by a function that handles
+ * the queue mutex lock.
+ */
+
+static void
+unsafe_queue_audio_block(struct audio_queue *queue, float *block, int len)
+{
+	struct audio_block *new = malloc(sizeof(struct audio_block));
+
+	/* if malloc fails we ditch the block */
+	if(!new)
+		return;
+
+	/* fill it out */
+	new->block_base = block;
+	new->current_base = block;
+	new->samples_left = len;
+	new->next = NULL;
+
+	/* add it to the end */
+	if(!queue->head) {
+		queue->head = new;
+		queue->tail = new;
+	} else {
+		queue->tail->next = new;
+		queue->tail = new;
+	}
+}
+
+/*
+ * Wrapper to handle mutex locking on queue
+ */
+
+static void
+queue_audio_block(struct audio_queue *queue, float *block, int len)
+{
+	pthread_mutex_lock(&queue->mutex);
+	unsafe_queue_audio_block(queue, block, len);
+	pthread_mutex_unlock(&queue->mutex);
+}
+
+/*
+ * Dequeue a certain number of audio bytes from the fifo. For blocks
+ * smaller than the remaining number we simply copy them and reduce
+ * the count. For blocks that go over this limit we have to make a
+ * recursive call on the function to fill out the rest. When there
+ * are no blocks left the buffer is zero padded. As with the queueing function
+ * this is unsafe and wrapped by a mutex handling funcion.
+ */
+
+static void
+unsafe_dequeue_audio_block(struct audio_queue *queue, float *block, int len)
+{
+	struct audio_block *head = queue->head;
+
+	/* anything to do ? */
+	if(len < 1)
+		return;
+
+	/* zero padding ? */
+	if(!head) {
+		int i;
+		for(i=0;i<len;i++)
+			*block++ = 0.0;
+		return;
+	}
+
+	/* smaller than current */
+	if(len < head->samples_left) {
+		memcpy(block, head->current_base, len*sizeof(float));
+		head->samples_left -= len;
+		head->current_base += len;
+		return;
+	}
+
+	/* copy all of this block */
+	memcpy(block, head->current_base, head->samples_left*sizeof(float));
+	len -= head->samples_left;
+	block += head->samples_left;
+
+	/* free it up and recuurse */
+	queue->head = head->next;
+	if(!queue->head)
+		queue->tail = NULL;
+	free(head->block_base);
+	free(head);
+	unsafe_dequeue_audio_block(queue, block, len);
+}
+
+/*
+ * Wrapper to handle mutex locking on queue
+ */
+
+static void
+dequeue_audio_block(struct audio_queue *queue, float *block, int len)
+{
+	pthread_mutex_lock(&queue->mutex);
+	unsafe_dequeue_audio_block(queue, block, len);
+	pthread_mutex_unlock(&queue->mutex);
+}
+
+/*
+ * This is the private data structure containing the audio device ID,
+ * the queue and some flags dictating how we adapt the sound samples
+ * to work with the setting on this device.
+ */
+
+struct coreaudio_private {
+	AudioDeviceID device;
+	struct audio_queue queue;
+	int fake_mono;			/* double samples for stereo channel */
+	int rate_mult;			/* rate mutiplier for samples */
+};
+
+/*
+ * This is the callback function which the audio device calls whenever it
+ * wants some new blocks of data to process. For each data block in the
+ * passed buffer list we dequeue the appropriate number of samples, padding
+ * with zeroes in the case of an underrun. According to the headers there
+ * can only ever be one buffer in the list, but we loose nothing by doing
+ * things "properly" after all.
+ */
+
+static OSStatus
+coreaudio_dsp_play (AudioDeviceID device, const AudioTimeStamp *now_time,
+		const AudioBufferList *in_data, const AudioTimeStamp *in_time,
+		AudioBufferList *out_data, const AudioTimeStamp *out_time,
+		void *data)
+{
+	int i;
+	struct coreaudio_private *priv = (struct coreaudio_private*)data;
+	for(i=0;i<out_data->mNumberBuffers;i++)
+		dequeue_audio_block(&(priv->queue),
+				out_data->mBuffers[i].mData,
+				out_data->mBuffers[i].mDataByteSize /
+				 sizeof(float));
+	return noErr;
+}
+
+/*
+ * Destroy function. We stop the sound device from playing and detach
+ * ourselves from it. We do not free up the dsp structure as we dont
+ * entriely trust OS X not to make a final call to the callback.
+ */
+
+static void
+coreaudio_dsp_destroy(struct sysdep_dsp_struct *dsp)
+{
+	struct coreaudio_private *priv = (struct coreaudio_private*)dsp->_priv;
+	OSStatus audio_err;
+
+	/* stop the device */
+        audio_err = AudioDeviceStop(priv->device, coreaudio_dsp_play);
+        if(audio_err != noErr)
+		fprintf(stderr,"error %ld stopping audio device\n",
+				audio_err);
+
+	/* remove the callback function */
+        audio_err = AudioDeviceRemoveIOProc(priv->device, coreaudio_dsp_play);
+        if(audio_err != noErr)
+		fprintf(stderr,"error %ld removing callback function\n",
+				audio_err);
+}
+
+/*
+ * Queue a block of data. The API requires that samples are expressed as
+ * floats between -1.0 and 1.0 for some reason. It makes sense numerically,
+ * but it's hardly fast to convert from signed shorts ! Here is where we
+ * carry our channel faking processes such as the doubling of mono to give
+ * stereo and inserting mutiple copies of samples for when the output channel
+ * rate has to be an integral multiple higher that that generated by xmame.
+ */
+   
+static int
+coreaudio_dsp_write(struct sysdep_dsp_struct *dsp,
+		unsigned char *data, int count)
+{
+	struct coreaudio_private *priv = (struct coreaudio_private*)dsp->_priv;
+	int is_stereo = dsp->hw_info.type & SYSDEP_DSP_STEREO;
+	int fake_mono = priv->fake_mono;
+	int mult = priv->rate_mult;
+	float *data_block, *data_ptr;
+	short *short_ptr;
+	int i;
+
+	/* make the data block - always stereo */
+	data_block = malloc(count * 2 * sizeof(float) * mult);
+	if(!data_block) {
+		fprintf(stderr, "out of memory queueing audio block");
+		return count;
+	}
+
+	/*
+	 * copy in the data, each sample is added twice if we are running
+	 * a half rate emulation. If we are in mono mode then the second sample
+	 * is the same as the first and not taken from the buffer at all
+	 */
+	data_ptr = data_block;
+	short_ptr = (short*)data;
+	for(i=0;i<count;i++) {
+		float left_chan, right_chan;
+		int m;
+
+		/* setup the left and right values */
+		left_chan = *short_ptr++ / 32768.0;
+		if(is_stereo)
+			right_chan = *short_ptr++ / 32768.0;
+		else
+			right_chan = left_chan;
+
+		/* add the sammples */
+		for(m=0;m<mult;m++) {
+			*data_ptr++ = left_chan;
+			if(fake_mono)
+				*data_ptr++ = right_chan;
+		}
+	}
+
+	/* and queue it */
+	queue_audio_block(&(priv->queue), data_block, count * 2 * mult);
+	return count;
+}
+
+/*
+ * Creation function. Attach ourselves to the default audio device if
+ * we can, and set up the various parts of our internal structure. Public
+ * beta did emulations of such things as lower sample rates and mono output.
+ * For the OS X release we try and set these things up properly, but we
+ * revert to the emulations if things do not work out.
+ */
+
+static void*
+coreaudio_dsp_create(const void *flags)
+{
+	const struct sysdep_dsp_create_params *params = flags;
+	struct sysdep_dsp_struct *dsp = NULL;
+	struct coreaudio_private *priv = NULL;
+	OSStatus audio_err;
+	UInt32 audio_count, audio_buff_len;
+	char audio_device[NAME_LEN];
+	AudioStreamBasicDescription default_format, new_format;
+
+	/* allocate the dsp struct */
+	if (!(dsp = calloc(1, sizeof(struct sysdep_dsp_struct))))
+	{
+		perror("malloc failed for struct sysdep_dsp_struct\n");
+		return NULL;
+	}
+
+	/* always 16 bit samples */
+	dsp->hw_info.type |= SYSDEP_DSP_16BIT;
+	fprintf(stderr, "info: requesting %s sound at %d hz\n",
+			(params->type & SYSDEP_DSP_STEREO) ?
+			"stereo" : "mono", params->samplerate);
+
+	/* make the private structure */
+	if (!(priv = calloc(1, sizeof(struct coreaudio_private)))) {
+		perror("malloc failed for struct coreaudio_private\n");
+		return NULL;
+	}
+
+	/* set up with queue, no device, and zero length buffer */
+ 	priv->device = kAudioDeviceUnknown;
+	priv->queue.head = NULL;
+	priv->queue.tail = NULL;
+	if(pthread_mutex_init(&(priv->queue.mutex),NULL)) {
+		perror("failed to create mutex\n");
+		return NULL;
+	}
+
+	/* get the default device */
+	audio_count = sizeof(AudioDeviceID);
+	audio_err = AudioHardwareGetProperty(
+			kAudioHardwarePropertyDefaultOutputDevice,
+			&audio_count, &(priv->device));
+	if(audio_err != noErr) {
+		fprintf(stderr,"error %ld getting default audio device\n",
+				audio_err);
+		return NULL;
+	}
+
+	/* whats it called ? */
+	audio_count = NAME_LEN;
+	audio_err = AudioDeviceGetProperty(priv->device, 0, false,
+			kAudioDevicePropertyDeviceName,
+			&audio_count, audio_device);
+	if(audio_err != noErr) {
+		fprintf(stderr,"error %ld getting default device name\n",
+				audio_err);
+		return NULL;
+	}
+	audio_device[NAME_LEN-1] = '\0';	/* just in case */
+	fprintf(stderr, "info: sound device is %s\n", audio_device);
+
+	/* get the default parameters */
+	audio_count = sizeof(AudioStreamBasicDescription);
+	audio_err = AudioDeviceGetProperty(priv->device, 0, false,
+			kAudioDevicePropertyStreamFormat,
+			&audio_count, &default_format);
+	if(audio_err != noErr) {
+		fprintf(stderr,"error %ld getting basic device parameters\n",
+				audio_err);
+		return NULL;
+	}
+
+	/* try and set the parameters */
+	new_format = default_format;
+	new_format.mChannelsPerFrame = (params->type & SYSDEP_DSP_STEREO)
+			? 2 : 1;
+	/*
+	 * At this point we were supposed to set the device parameters
+	 * to the required rate and number of channels, buut we have not
+	 * so far found a way to do it in the API. Thus we do nothing here.
+	 * The following code re-reads the device parameters and makes do
+	 * with whatever we get, thus it should work if and when we find a call
+	 * to set things up properly !
+	 */
+
+	/* get the new parameters */
+	audio_count = sizeof(AudioStreamBasicDescription);
+	audio_err = AudioDeviceGetProperty(priv->device, 0, false,
+			kAudioDevicePropertyStreamFormat,
+			&audio_count, &new_format);
+	if(audio_err != noErr) {
+		fprintf(stderr,"error %ld getting basic device parameters\n",
+				audio_err);
+		return NULL;
+	}
+
+	/* the device must do linear pcm */
+	if(new_format.mFormatID != kAudioFormatLinearPCM) {
+		fprintf(stderr,"device does not do linear pcm!\n");
+		return NULL;
+	}
+
+	/* possibly emulate mono onto stereo */
+	priv->fake_mono = 0;
+	if(params->type & SYSDEP_DSP_STEREO) {
+		dsp->hw_info.type |= SYSDEP_DSP_STEREO;
+		if(new_format.mChannelsPerFrame != 2) {
+			fprintf(stderr,"device does not do stereo!\n");
+			return NULL;
+		} else
+			fprintf(stderr, "info: sound device native stereo\n");
+	} else  {
+		if(new_format.mChannelsPerFrame != 1) {
+			if(new_format.mChannelsPerFrame != 2) {
+				fprintf(stderr,"device does %ld channels!\n",
+						new_format.mChannelsPerFrame);
+				return NULL;
+			}
+			fprintf(stderr, "info: emulating mono onto stereo\n");
+			priv->fake_mono = 1;
+		} else
+			fprintf(stderr, "info: sound device native mono\n");
+	}
+
+	/* create and check the channel multiplier */
+	priv->rate_mult = ((int)(new_format.mSampleRate+0.5)) /
+			params->samplerate;
+	if(((int)(new_format.mSampleRate+0.5)) !=
+			(params->samplerate*priv->rate_mult)) {
+		fprintf(stderr,"rate %f is not a multiple of %d\n",
+				new_format.mSampleRate, params->samplerate);
+		return NULL;
+	}
+	if(priv->rate_mult != 1)
+		fprintf(stderr, "info: mutiplying %d hz by %d to give %d hz\n",
+				params->samplerate, priv->rate_mult,
+				(int)(new_format.mSampleRate+0.5));
+
+	/* attach the callback function */
+        audio_err = AudioDeviceAddIOProc(priv->device,
+			coreaudio_dsp_play, (void*)priv);
+	if(audio_err != noErr) {
+		fprintf(stderr,"error %ld adding callback function\n",
+				audio_err);
+		return NULL;
+	}
+
+	/* start it playing */
+        audio_err = AudioDeviceStart(priv->device, coreaudio_dsp_play);
+	if(audio_err != noErr) {
+		fprintf(stderr,"error %ld starting audio device\n",
+				audio_err);
+		return NULL;
+	}
+	
+	/* fill in the functions and private data */
+	dsp->_priv = priv;
+	dsp->write = coreaudio_dsp_write;
+	dsp->destroy = coreaudio_dsp_destroy;
+	dsp->hw_info.type = params->type;
+	dsp->hw_info.samplerate = params->samplerate;
+
+	return dsp;
+}
+
+/*
+ * The public variables structure
+ */
+
+const struct plugin_struct sysdep_dsp_coreaudio = {
+	"coreaudio",
+	"sysdep_dsp",
+	"Apple OS X CoreAudio plugin",
+	NULL, 				/* no options */
+	NULL,				/* no init */
+	NULL,				/* no exit */
+	coreaudio_dsp_create,
+	3				/* high priority */
+};
diff --git a/src/unix/sysdep/dsp-drivers/esound.c b/src/unix/sysdep/dsp-drivers/esound.c
new file mode 100644
index 0000000..12bda17
--- /dev/null
+++ b/src/unix/sysdep/dsp-drivers/esound.c
@@ -0,0 +1,185 @@
+/* Sysdep esound sound dsp driver
+
+   Copyright 2000 Hans de Goede
+   
+   This file and the acompanying files in this directory are free software;
+   you can redistribute them and/or modify them under the terms of the GNU
+   Library General Public License as published by the Free Software Foundation;
+   either version 2 of the License, or (at your option) any later version.
+
+   These files are distributed in the hope that they will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with these files; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.
+*/
+/* Changelog
+Version 0.1, January 2000
+-initial release, based on the driver submitted by riq <riq@ciudad.com.ar>,
+ amongst others (Hans de Goede)
+*/
+#ifdef SYSDEP_DSP_ESOUND
+#include <stdlib.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <sys/ioctl.h>
+#include <esd.h>
+#include "sysdep/sysdep_dsp.h"
+#include "sysdep/sysdep_dsp_priv.h"
+#include "sysdep/plugin_manager.h"
+
+/* #define ESOUND_DEBUG */
+
+/* our per instance private data struct */
+struct esound_dsp_priv_data {
+   int fd;
+};
+
+/* public methods prototypes (static but exported through the sysdep_dsp or
+   plugin struct) */
+static void *esound_dsp_create(const void *flags);
+static void esound_dsp_destroy(struct sysdep_dsp_struct *dsp);
+static int esound_dsp_write(struct sysdep_dsp_struct *dsp, unsigned char *data,
+   int count);
+
+/* public variables */
+const struct plugin_struct sysdep_dsp_esound = {
+   "esound",
+   "sysdep_dsp",
+   "Esound DSP plugin",
+   NULL, /* no options */
+   NULL, /* no init */
+   NULL, /* no exit */
+   esound_dsp_create,
+   2     /* lower priority as direct device access */
+};
+
+/* private variables */
+static int esound_dsp_bytes_per_sample[4] = SYSDEP_DSP_BYTES_PER_SAMPLE;
+
+/* public methods (static but exported through the sysdep_dsp or plugin
+   struct) */
+static void *esound_dsp_create(const void *flags)
+{
+#ifdef ESOUND_DEBUG
+   int server_fd;
+   esd_server_info_t *info = NULL;
+#endif
+   struct esound_dsp_priv_data *priv = NULL;
+   struct sysdep_dsp_struct *dsp = NULL;
+   const struct sysdep_dsp_create_params *params = flags;
+   esd_format_t esd_format;
+   
+   /* allocate the dsp struct */
+   if (!(dsp = calloc(1, sizeof(struct sysdep_dsp_struct))))
+   {
+      fprintf(stderr,
+         "error malloc failed for struct sysdep_dsp_struct\n");
+      return NULL;
+   }
+   
+   /* alloc private data */
+   if(!(priv = calloc(1, sizeof(struct esound_dsp_priv_data))))
+   {
+      fprintf(stderr,
+         "error malloc failed for struct esound_dsp_priv_data\n");
+      esound_dsp_destroy(dsp);
+      return NULL;
+   }
+   
+   /* fill in the functions and some data */
+   priv->fd = -1;
+   dsp->_priv = priv;
+   dsp->write = esound_dsp_write;
+   dsp->destroy = esound_dsp_destroy;
+   dsp->hw_info.type = params->type;
+   dsp->hw_info.samplerate = params->samplerate;
+   
+   /* open the sound device */
+   esd_format = ESD_STREAM | ESD_PLAY ;
+   esd_format |= (dsp->hw_info.type & SYSDEP_DSP_16BIT)?
+      ESD_BITS16 : ESD_BITS8;
+   esd_format |= (dsp->hw_info.type & SYSDEP_DSP_STEREO)?
+      ESD_STEREO : ESD_MONO;
+   
+#ifdef ESOUND_DEBUG
+   if((server_fd = esd_open_sound(params->device)) < 0)
+   {
+      fprintf(stderr, "error: esound server open failed\n");
+      esound_dsp_destroy(dsp);
+      return NULL;
+   }
+   
+   if(!(info = esd_get_server_info(server_fd)))
+   {
+      fprintf(stderr, "error: esound get server info failed\n");
+      esd_close(server_fd);
+      esound_dsp_destroy(dsp);
+      return NULL;
+   }
+   
+   esd_print_server_info(info);
+   esd_free_server_info(info);
+   esd_close(server_fd);
+#endif
+   
+   if((priv->fd = esd_play_stream(esd_format, dsp->hw_info.samplerate,
+      params->device, "mame esound")) < 0)
+   {
+      fprintf(stderr, "error: esound open stream failed\n");
+      esound_dsp_destroy(dsp);
+      return NULL;
+   }
+
+   /* set non-blocking mode if selected */
+   if(params->flags & SYSDEP_DSP_O_NONBLOCK)
+   {
+      long flags = fcntl(priv->fd, F_GETFL);
+      if((flags < 0) || (fcntl(priv->fd, F_SETFL, flags|O_NONBLOCK) < 0))
+      {
+         perror("Esound-driver, error: fnctl");
+         esound_dsp_destroy(dsp);
+         return NULL;
+      }
+   }
+   
+   return dsp;
+}
+
+static void esound_dsp_destroy(struct sysdep_dsp_struct *dsp)
+{
+   struct esound_dsp_priv_data *priv = dsp->_priv;
+   
+   if(priv)
+   {
+      if(priv->fd >= 0)
+         close(priv->fd);
+      
+      free(priv);
+   }
+   free(dsp);
+}
+   
+static int esound_dsp_write(struct sysdep_dsp_struct *dsp, unsigned char *data,
+   int count)
+{
+   int result;
+   struct esound_dsp_priv_data *priv = dsp->_priv;
+
+   result = write(priv->fd, data, count *
+      esound_dsp_bytes_per_sample[dsp->hw_info.type]);
+      
+   if (result < 0)
+   {
+      fprintf(stderr, "error: esound write to stream failed\n");
+      return -1;
+   }
+      
+   return result / esound_dsp_bytes_per_sample[dsp->hw_info.type];
+}
+
+#endif /* ifdef SYSDEP_DSP_ESOUND */
diff --git a/src/unix/sysdep/dsp-drivers/io-audio.c b/src/unix/sysdep/dsp-drivers/io-audio.c
new file mode 100644
index 0000000..93c8e13
--- /dev/null
+++ b/src/unix/sysdep/dsp-drivers/io-audio.c
@@ -0,0 +1,331 @@
+/*
+
+	Travis's Note: io-audio isnt out yet, so lets stick
+	with David's old code till it's out.
+	
+	I called this io-audio.c for reasons that I dont
+	even understand. If you can think of a better name
+	for this file lemme know.
+
+*/
+/* Sysdep Alsa 5 driver : 
+	Written by Dave Rempel
+
+	email : drempel@qnx.com
+
+Note...I've only tried this under Neutrino 2.1....
+it should work for Linux too though...
+
+based on the OSS source code...
+
+---------------------------------------------------------------------------
+   Copyright 2000 Hans de Goede
+   
+   This file and the acompanying files in this directory are free software;
+   you can redistribute them and/or modify them under the terms of the GNU
+   Library General Public License as published by the Free Software Foundation;
+   either version 2 of the License, or (at your option) any later version.
+
+   These files are distributed in the hope that they will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with these files; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.
+----------------------------------------------------------------------------
+
+*/
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <sys/ioctl.h>
+#include <alsa/asoundlib.h>
+#include "sysdep/sysdep_dsp.h"
+#include "sysdep/sysdep_dsp_priv.h"
+#include "sysdep/plugin_manager.h"
+//#include "xmame.h"
+//#include "sound.h"
+
+#define TRUE 1
+#define FALSE 0
+
+typedef struct alsa_audio_device 
+{
+	snd_pcm_t			*m_AudioHandle;
+	snd_mixer_t			*m_MixerHandle;
+	int				m_Acard;
+	int				m_Adevice;
+	int				FdAudioDevice;
+	snd_pcm_channel_info_t		m_Achaninfo;
+	snd_mixer_group_t		m_Amixgroup;
+	snd_pcm_channel_params_t	m_Aparams;
+	snd_pcm_channel_setup_t		m_Asetup;
+	snd_pcm_channel_status_t	m_Astatus;
+	int				bMute;
+	pthread_t			*RenderThread;
+	int				m_Aformat;
+	int				m_BytesPerSample;  //one channel
+} AlsaAudioDevice_t;
+
+/* our per instance private data struct */
+struct alsa_dsp_priv_data 
+{
+   AlsaAudioDevice_t audio_dev;
+};
+
+/* public methods prototypes (static but exported through the sysdep_dsp or
+   plugin struct) */
+static void *alsa_dsp_create(const void *flags);
+static void alsa_dsp_destroy(struct sysdep_dsp_struct *dsp);
+static int alsa_dsp_get_freespace(struct sysdep_dsp_struct *dsp);
+static int alsa_dsp_write(struct sysdep_dsp_struct *dsp, unsigned char *data, int count);
+static int preferred_device=FALSE;
+
+struct rc_option alsa_opts[] = {
+	{"QNX Audio related", NULL, rc_seperator, NULL, NULL, 0, 0, NULL, NULL},
+	{"audio-preferred" , "audio-primary", rc_bool, &preferred_device, "1", 0, 0, NULL, "Use the preferred device or use the primary device."},
+	{NULL, NULL, rc_end, NULL, NULL, 0, 0, NULL, NULL }
+};
+
+/* public variables */
+const struct plugin_struct sysdep_dsp_alsa= 
+{
+   "alsa",
+   "sysdep_dsp",
+   "ALSA 5 DSP plugin",
+   alsa_opts, /* options */
+   NULL, /* no init */
+   NULL, /* no exit */
+   alsa_dsp_create,
+   3     /* high priority */
+};
+
+/* private variables */
+static int alsa_dsp_bytes_per_sample[4] = SYSDEP_DSP_BYTES_PER_SAMPLE;
+
+/* public methods (static but exported through the sysdep_dsp or plugin
+   struct) */
+static void *alsa_dsp_create(const void *flags)
+{
+	int i, j;
+//	audio_buf_info info;
+	struct alsa_dsp_priv_data *priv = NULL;
+	struct sysdep_dsp_struct *dsp = NULL;
+	const struct sysdep_dsp_create_params *params = flags;
+	const char *device = params->device;
+	int err;
+	int bytespersample;
+
+	fprintf(stderr,"info: dsp_create called\n");
+   
+	/* allocate the dsp struct */
+	if (!(dsp = calloc(1, sizeof(struct sysdep_dsp_struct))))
+	{
+		fprintf(stderr,
+			"error: malloc failed for struct sysdep_dsp_struct\n");
+		return NULL;
+	}
+   
+	/* alloc private data */
+	if(!(priv = calloc(1, sizeof(struct alsa_dsp_priv_data))))
+	{
+		fprintf(stderr,
+			"error: malloc failed for struct dsp_priv_data\n");
+		alsa_dsp_destroy(dsp);
+		return NULL;
+	}
+   
+	/* fill in the functions and some data */
+	dsp->_priv = priv;
+	dsp->get_freespace = alsa_dsp_get_freespace;
+	dsp->write = alsa_dsp_write;
+	dsp->destroy = alsa_dsp_destroy;
+	dsp->hw_info.type = params->type;
+	dsp->hw_info.samplerate = params->samplerate;
+
+	priv->audio_dev.bMute = 0;
+	priv->audio_dev.m_AudioHandle = NULL;
+	priv->audio_dev.m_MixerHandle = NULL;
+	priv->audio_dev.m_Acard = 0;
+	priv->audio_dev.m_Adevice = 0;
+
+
+	if (preferred_device)
+	{	
+ 		if((err = snd_pcm_open_preferred(&(priv->audio_dev.m_AudioHandle), &priv->audio_dev.m_Acard,
+                                       &priv->audio_dev.m_Adevice, SND_PCM_OPEN_PLAYBACK)) < 0)
+    	{
+			fprintf(stderr,"info: snd_pcm_open_preferred failed: %s \n", snd_strerror(err));
+    	            alsa_dsp_destroy(dsp);
+			return NULL;
+    	}
+	}
+	else
+	{
+		fprintf(stderr,"info: audio is using primary device\n");
+		if((err = snd_pcm_open(&(priv->audio_dev.m_AudioHandle), 0, 0, SND_PCM_OPEN_PLAYBACK)) < 0)
+		{
+			fprintf(stderr,"info: snd_pcm_open failed: %s \n", snd_strerror(err));
+			alsa_dsp_destroy(dsp);
+			return NULL;
+		}
+	}
+	
+	memset (&(priv->audio_dev.m_Achaninfo), 0, sizeof (priv->audio_dev.m_Achaninfo));
+	priv->audio_dev.m_Achaninfo.channel = SND_PCM_CHANNEL_PLAYBACK;
+	if ((err = snd_pcm_plugin_info (priv->audio_dev.m_AudioHandle, &(priv->audio_dev.m_Achaninfo))) < 0)
+	{
+		fprintf (stderr, "info: snd_pcm_plugin_info failed: %s\n", snd_strerror (err));
+		alsa_dsp_destroy(dsp);
+		return NULL;
+	}
+
+	//needed to enable the count status parameter, mmap plugin disables this
+	if((err = snd_plugin_set_disable(priv->audio_dev.m_AudioHandle, PLUGIN_DISABLE_MMAP)) < 0)
+	{
+		fprintf (stderr, "info: snd_plugin_set_disable failed: %s\n", snd_strerror (err));
+		alsa_dsp_destroy(dsp);
+		return NULL;
+	}
+
+	/* calculate and set the fragsize & number of frags */
+	/* fragsize (as power of 2) */
+	i = 8;
+	if (dsp->hw_info.type & SYSDEP_DSP_16BIT) i++;
+	if (dsp->hw_info.type & SYSDEP_DSP_STEREO) i++;
+	i += dsp->hw_info.samplerate / 22000;
+
+	/* number of frags */
+	j = ((dsp->hw_info.samplerate * alsa_dsp_bytes_per_sample[dsp->hw_info.type] *
+		params->bufsize) / (0x01 << i)) + 1;
+
+	bytespersample=1;
+//	dsp->hw_info.type &= ~SYSDEP_DSP_16BIT;
+//	dsp->hw_info.type &= ~SYSDEP_DSP_STEREO;
+	if (dsp->hw_info.type & SYSDEP_DSP_16BIT) bytespersample++;
+	if (dsp->hw_info.type & SYSDEP_DSP_STEREO) bytespersample <<= 1;
+	
+	memset( &(priv->audio_dev.m_Aparams), 0, sizeof(priv->audio_dev.m_Aparams));
+	priv->audio_dev.m_Aparams.mode = SND_PCM_MODE_BLOCK;
+	priv->audio_dev.m_Aparams.channel = SND_PCM_CHANNEL_PLAYBACK;
+	priv->audio_dev.m_Aparams.start_mode = SND_PCM_START_FULL;
+	priv->audio_dev.m_Aparams.stop_mode = SND_PCM_STOP_ROLLOVER;
+#if 0
+	priv->audio_dev.m_Aparams.buf.stream.queue_size = 512 * bytespersample;
+	priv->audio_dev.m_Aparams.buf.stream.fill = SND_PCM_FILL_SILENCE;
+	priv->audio_dev.m_Aparams.buf.stream.max_fill = 512 * bytespersample;
+#endif
+        priv->audio_dev.m_Aparams.format.interleave = 1;
+        priv->audio_dev.m_Aparams.format.rate = dsp->hw_info.samplerate;
+        priv->audio_dev.m_Aparams.format.voices = (dsp->hw_info.type & SYSDEP_DSP_STEREO) ? 2 : 1;
+
+	priv->audio_dev.m_Aparams.buf.block.frag_size = 1000;
+	priv->audio_dev.m_Aparams.buf.block.frags_min = 1;
+	priv->audio_dev.m_Aparams.buf.block.frags_max = 5;
+
+        priv->audio_dev.m_BytesPerSample = bytespersample;
+        priv->audio_dev.m_Aparams.format.format = 
+#ifdef LSB_FIRST
+				(dsp->hw_info.type & SYSDEP_DSP_16BIT) ? SND_PCM_SFMT_S16_LE : SND_PCM_SFMT_U8; 
+#else
+				(dsp->hw_info.type & SYSDEP_DSP_16BIT) ? SND_PCM_SFMT_S16_BE : SND_PCM_SFMT_U8;
+#endif
+
+	if ((err = snd_pcm_plugin_params (priv->audio_dev.m_AudioHandle, &(priv->audio_dev.m_Aparams))) < 0)
+	{
+		fprintf (stderr, "info: snd_pcm_plugin_params failed: %s\n", snd_strerror (err));
+		alsa_dsp_destroy(dsp);
+		return NULL;
+	}
+
+	if ((err = snd_pcm_plugin_prepare (priv->audio_dev.m_AudioHandle, SND_PCM_CHANNEL_PLAYBACK)) < 0)
+	{
+		fprintf (stderr, "warning: snd_pcm_plugin_prepare failed: %s\n", snd_strerror (err));
+	}
+
+	memset (&(priv->audio_dev.m_Asetup), 0, sizeof (priv->audio_dev.m_Asetup));
+	priv->audio_dev.m_Asetup.channel = SND_PCM_CHANNEL_PLAYBACK;
+	if ((err = snd_pcm_plugin_setup (priv->audio_dev.m_AudioHandle, &(priv->audio_dev.m_Asetup))) < 0)
+	{
+		fprintf (stderr, "warning: snd_pcm_plugin_setup failed: %s\n", snd_strerror (err));
+		alsa_dsp_destroy(dsp);
+		return NULL;
+	}
+	
+	memset (&(priv->audio_dev.m_Astatus), 0, sizeof (priv->audio_dev.m_Astatus));
+	priv->audio_dev.m_Astatus.channel = SND_PCM_CHANNEL_PLAYBACK;
+	if ((err = snd_pcm_plugin_status (priv->audio_dev.m_AudioHandle, &(priv->audio_dev.m_Astatus))) < 0)
+	{
+		fprintf (stderr, "warning: snd_pcm_plugin_status failed: %s\n", snd_strerror (err));
+        }
+	dsp->hw_info.bufsize = priv->audio_dev.m_Asetup.buf.stream.queue_size  
+	             		/ alsa_dsp_bytes_per_sample[dsp->hw_info.type];
+#if 0
+	if ((err=snd_pcm_nonblock_mode(priv->audio_dev.m_AudioHandle, 1))<0)
+	{
+		fprintf(stderr, "error: error with non block mode: %s\n", snd_strerror (err));
+	}
+#endif
+	return dsp;
+}
+
+/* BUG: Core dumps if -nosound isn't present when using a soundless setup... */
+static void alsa_dsp_destroy(struct sysdep_dsp_struct *dsp)
+{
+	struct alsa_dsp_priv_data *priv = dsp->_priv;
+	int err;
+	
+	fprintf (stderr,"info: dsp_destroy called\n");
+	
+	if(priv)
+	{
+		if ((err = snd_pcm_plugin_flush(priv->audio_dev.m_AudioHandle,SND_PCM_CHANNEL_PLAYBACK)) < 0)
+			fprintf (stderr, "warning: snd_pcm_plugin_playback_drain failed: %s\n", snd_strerror (err));
+
+	        err =  snd_pcm_close(priv->audio_dev.m_AudioHandle);
+	        if (err != 0)
+			printf("info: snd_pcm_close failed: %s\n",snd_strerror(err));
+
+		priv->audio_dev.m_AudioHandle = NULL;
+		free(priv);
+	}
+	free(dsp);
+	
+}
+   
+static int alsa_dsp_get_freespace(struct sysdep_dsp_struct *dsp)
+{
+	struct alsa_dsp_priv_data *priv = dsp->_priv;
+	snd_pcm_channel_status_t status={0};	
+ 
+ 	snd_pcm_plugin_status(priv->audio_dev.m_AudioHandle, &status);
+ 
+	return status.free / alsa_dsp_bytes_per_sample[dsp->hw_info.type];
+}
+
+static int alsa_dsp_write(struct sysdep_dsp_struct *dsp, unsigned char *data,
+   int count)
+{
+	int BytesWritten, BytesToWrite;
+        unsigned int bytesleft;
+        int err;
+	struct alsa_dsp_priv_data *priv = dsp->_priv;
+        snd_pcm_channel_status_t  status = {0};
+
+	BytesToWrite = count*alsa_dsp_bytes_per_sample[dsp->hw_info.type];
+	BytesWritten = snd_pcm_plugin_write( priv->audio_dev.m_AudioHandle, data, BytesToWrite );
+#if 0	
+	if (BytesWritten == 0)
+        {
+		return count;
+        }
+#endif	
+	return BytesWritten / alsa_dsp_bytes_per_sample[dsp->hw_info.type];
+}
diff --git a/src/unix/sysdep/dsp-drivers/irix.c b/src/unix/sysdep/dsp-drivers/irix.c
new file mode 100644
index 0000000..f3e8b9c
--- /dev/null
+++ b/src/unix/sysdep/dsp-drivers/irix.c
@@ -0,0 +1,256 @@
+/* Sysdep Irix sound dsp driver
+
+   Copyright 2001 by Brandon Corey
+   
+   This file and the acompanying files in this directory are free software;
+   you can redistribute them and/or modify them under the terms of the GNU
+   Library General Public License as published by the Free Software Foundation;
+   either version 2 of the License, or (at your option) any later version.
+
+   These files are distributed in the hope that they will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with these files; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.
+
+   Addendum: This file may also be used under the terms of the MAME license, by
+   permission of Brandon Corey.  (For the text of the license, see 
+   http://www.mame.net/readme.html.)
+*/
+/* Changelog
+Version 0.1, April 15, 2001
+- initial release
+*/
+
+/* Notes/Future
+1) I've only compiled this with MIPSPro, although I assume it works with gcc as well.
+		If someone could test that and email me, I'd appreciate it.
+2) Will add mixer support for the next version
+3) Use IRIX_DEBUG and IRIX_DEBUG_VERBOSE for Extra Info
+4) Use FORCEMONO to force MONO output
+5) Use FORCE8BIT to force 8 Bit output
+
+Email: brandon@blackboxcentral.com
+*/
+
+/* #define IRIX_DEBUG */
+/* #define IRIX_DEBUG_VERBOSE */
+/* #define FORCEMONO */
+/* #define FORCE8BIT */
+/* #define SYSDEP_DSP_IRIX */
+
+#ifdef SYSDEP_DSP_IRIX
+#include <stdlib.h>
+#include <unistd.h>
+#include <sys/ioctl.h>
+#include <dmedia/audio.h>
+#include "sysdep/sysdep_dsp.h"
+#include "sysdep/sysdep_dsp_priv.h"
+#include "sysdep/plugin_manager.h"
+
+/* our per instance private data struct */
+struct irix_dsp_priv_data {
+	ALport devAudio;
+	ALconfig devAudioConfig;	
+	unsigned int buffer_samples;
+	int sampwidth;
+	int sampchan;
+	int port_status;
+};
+
+/* public methods prototypes (static but exported through the sysdep_dsp or
+   plugin struct) */
+static void *irix_dsp_create(const void *flags);
+static void irix_dsp_destroy(struct sysdep_dsp_struct *dsp);
+static int irix_dsp_get_freespace(struct sysdep_dsp_struct *dsp);
+static int irix_dsp_write(struct sysdep_dsp_struct *dsp, unsigned char *data,
+   int count);
+
+/* public variables */
+const struct plugin_struct sysdep_dsp_irix = {
+   "irix",
+   "sysdep_dsp",
+   "Irix DSP plugin",
+   NULL, /* no options */
+   NULL, /* no init */
+   NULL, /* no exit */
+   irix_dsp_create,
+   3     /* high priority as direct device access */
+};
+
+/* private variables */
+static int irix_dsp_bytes_per_sample[4] = SYSDEP_DSP_BYTES_PER_SAMPLE;
+
+/* public methods (static but exported through the sysdep_dsp or plugin
+   struct) */
+static void *irix_dsp_create(const void *flags)
+{
+   long parambuf[4];
+   long tempbits, tempchan;
+   struct irix_dsp_priv_data *priv = NULL;
+   struct sysdep_dsp_struct *dsp = NULL;
+   const struct sysdep_dsp_create_params *params = flags;
+   
+   /* allocate the dsp struct */
+   if (!(dsp = calloc(1, sizeof(struct sysdep_dsp_struct))))
+   {
+      fprintf(stderr, "Error: malloc failed for struct sysdep_dsp_struct.\n");
+      return NULL;
+   }
+   
+   /* alloc private data */
+   if(!(priv = calloc(1, sizeof(struct irix_dsp_priv_data))))
+   {
+      fprintf(stderr, "Error: malloc failed for struct irix_dsp_priv_data.\n");
+      irix_dsp_destroy(dsp);
+      return NULL;
+   }
+   
+   /* fill in the functions and some data */
+   priv->port_status = -1;
+   dsp->_priv = priv;
+   dsp->get_freespace = irix_dsp_get_freespace;
+   dsp->write = irix_dsp_write;
+   dsp->destroy = irix_dsp_destroy;
+   dsp->hw_info.type = params->type;
+   dsp->hw_info.samplerate = params->samplerate;
+
+   /* open the sound device */
+	parambuf[0] = AL_INPUT_COUNT;
+	parambuf[2] = AL_OUTPUT_COUNT;
+	ALgetparams(AL_DEFAULT_DEVICE,parambuf,4);
+	if (parambuf[1] || parambuf[3]) {
+		fprintf(stderr, "ALgetparams failed: %d.\n", oserror());
+		irix_dsp_destroy(dsp);
+		return NULL;
+	}  
+
+	/* create a clean config descriptor */
+	if ( (priv->devAudioConfig = ALnewconfig() ) == (ALconfig) NULL ) {
+		fprintf(stderr, "Cannot create a config Descriptor. Exiting.\n");
+		irix_dsp_destroy(dsp);
+		return NULL;
+	}
+
+#ifdef FORCE8BIT
+	dsp->hw_info.type &= ~SYSDEP_DSP_16BIT;
+#endif
+#ifdef FORCEMONO
+	dsp->hw_info.type &= ~SYSDEP_DSP_STEREO;
+#endif
+
+	priv->buffer_samples = dsp->hw_info.samplerate * params->bufsize;
+
+	tempchan = (dsp->hw_info.type & SYSDEP_DSP_STEREO)? 2:1;
+	tempbits = (dsp->hw_info.type & SYSDEP_DSP_16BIT)? 2:1;
+	
+	priv->buffer_samples = priv->buffer_samples * tempchan;
+
+	priv->sampwidth = tempbits;
+	priv->sampchan = tempchan;
+
+#ifdef IRIX_DEBUG
+	fprintf(stderr, "Sample Rate Requested: %d\n", dsp->hw_info.samplerate);
+	fprintf(stderr, "Buffer Size Requested: %d\n", priv->buffer_samples);
+#endif
+
+	fprintf(stderr, "Setting sound to %dHz, %d bit, %s\n",dsp->hw_info.samplerate,
+		tempbits * 8, (tempchan == 2) ? "stereo" : "mono");
+
+	/* channel specific parameters */
+	ALsetchannels(priv->devAudioConfig, tempchan);						/* channels */
+	ALsetqueuesize(priv->devAudioConfig,(long) priv->buffer_samples);	/* buffer size */
+	ALsetsampfmt(priv->devAudioConfig, AL_SAMPFMT_TWOSCOMP);			/* BTC */
+	ALsetwidth(priv->devAudioConfig, tempbits);							/* bitrate */
+
+	/* global audio parameters */
+	parambuf[0] = AL_OUTPUT_RATE;
+	parambuf[1] = dsp->hw_info.samplerate;
+	parambuf[2] = AL_INPUT_RATE;
+	parambuf[3] = dsp->hw_info.samplerate;
+	if (ALsetparams (AL_DEFAULT_DEVICE, parambuf, 4) < 0) {
+		fprintf(stderr, "Error: Cannot configure the sound system.\n");
+		irix_dsp_destroy(dsp);
+		return NULL;
+	} 
+
+	/* Open the audio port with the parameters we setup */
+	if ( (priv->devAudio=ALopenport("audio_fd","w",priv->devAudioConfig) ) == (ALport) NULL ) {
+		fprintf(stderr, "Error: Cannot get an audio channel descriptor.\n");
+		irix_dsp_destroy(dsp);
+		return NULL;
+	}
+
+   priv->port_status = 0;
+
+   return dsp;
+}
+
+static void irix_dsp_destroy(struct sysdep_dsp_struct *dsp)
+{
+   struct irix_dsp_priv_data *priv = dsp->_priv;
+ 
+#ifdef IRIX_DEBUG 
+	fprintf(stderr, "Destroying sound channel.\n");
+#endif
+ 
+   if(priv)
+   {
+	  if(priv->port_status >= 0) ALcloseport(priv->devAudio);
+	  ALfreeconfig(priv->devAudioConfig);
+      
+      free(priv);
+   }
+   free(dsp);
+}
+
+
+static int irix_dsp_get_freespace(struct sysdep_dsp_struct *dsp)
+{
+	struct irix_dsp_priv_data *priv = dsp->_priv;
+
+	return (int) ALgetfillable(priv->devAudio);
+}
+
+   
+static int irix_dsp_write(struct sysdep_dsp_struct *dsp, unsigned char *data,
+   int count)
+{
+   unsigned char *pt=data;
+   int result;
+   struct irix_dsp_priv_data *priv = dsp->_priv;
+   int playcnt;
+   long maxsize;
+
+	maxsize = ALgetfillable(priv->devAudio);
+
+	count = count * priv->sampchan;
+
+	if (count <= maxsize) playcnt = count;
+		else playcnt = (int) maxsize;
+
+	pt += (priv->sampwidth - 1);	
+
+	for (;pt<(data+count);pt+=priv->sampwidth) *pt ^=0x80;
+
+	result = ALwritesamps(priv->devAudio, (void *)data, playcnt);
+
+	if (result < 0) {
+		fprintf(stderr, "Error %d: failure writing to dmedia stream\n",oserror());
+		return -1;
+	}
+
+
+#ifdef IRIX_DEBUG_VERBOSE
+	fprintf(stderr, "Wrote %d samples OK.\n",playcnt);
+#endif
+
+	return playcnt / priv->sampchan;
+}
+
+#endif /* ifdef SYSDEP_DSP_IRIX */
+
diff --git a/src/unix/sysdep/dsp-drivers/irix_al.c b/src/unix/sysdep/dsp-drivers/irix_al.c
new file mode 100644
index 0000000..316d373
--- /dev/null
+++ b/src/unix/sysdep/dsp-drivers/irix_al.c
@@ -0,0 +1,295 @@
+/* Sysdep Irix_al sound dsp driver
+
+   Copyright 2001 by Brandon Corey
+   
+   This file and the acompanying files in this directory are free software;
+   you can redistribute them and/or modify them under the terms of the GNU
+   Library General Public License as published by the Free Software Foundation;
+   either version 2 of the License, or (at your option) any later version.
+
+   These files are distributed in the hope that they will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with these files; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.
+
+   Addendum: This file may also be used under the terms of the MAME license, by
+   permission of Brandon Corey.  (For the text of the license, see 
+   http://www.mame.net/readme.html.)
+*/
+/* Changelog
+Version 0.1, April 15, 2001
+- initial release
+Version 0.2, April 15, 2001
+- added sample frequency code so that a sample frequency other than the
+	system default is usable
+*/
+
+/* Notes/Future
+1) I've only compiled this with MIPSPro, although it should work with gcc.
+	If someone could test that and email me, I'd appreciate it.
+2) Will add mixer support for the next version
+3) Use IRIX_DEBUG and IRIX_DEBUG_VERBOSE for Extra Info
+4) Use FORCEMONO to force MONO output
+5) Use FORCE8BIT to force 8 Bit output
+
+Email: brandon@blackboxcentral.com
+*/
+
+/* #define IRIX_DEBUG */
+/* #define IRIX_DEBUG_VERBOSE */
+/* #define FORCEMONO */
+/* #define FORCE8BIT */
+/* #define SYSDEP_DSP_IRIX */
+
+#ifdef SYSDEP_DSP_IRIX
+#include <stdlib.h>
+#include <unistd.h>
+#include <sys/ioctl.h>
+#include <dmedia/audio.h>
+#include "sysdep/sysdep_dsp.h"
+#include "sysdep/sysdep_dsp_priv.h"
+#include "sysdep/plugin_manager.h"
+
+/* our per instance private data struct */
+struct irix_dsp_priv_data {
+	ALport devAudio;
+	ALconfig devAudioConfig;	
+	unsigned int buffer_samples;
+	int sampwidth;
+	int sampchan;
+	int port_status;
+};
+
+/* public methods prototypes (static but exported through the sysdep_dsp or
+   plugin struct) */
+static void *irix_dsp_create(const void *flags);
+static void irix_dsp_destroy(struct sysdep_dsp_struct *dsp);
+static int irix_dsp_get_freespace(struct sysdep_dsp_struct *dsp);
+static int irix_dsp_write(struct sysdep_dsp_struct *dsp, unsigned char *data,
+   int count);
+
+/* public variables */
+const struct plugin_struct sysdep_dsp_irix = {
+   "irix_al",
+   "sysdep_dsp",
+   "IrixAL DSP plugin",
+   NULL, /* no options */
+   NULL, /* no init */
+   NULL, /* no exit */
+   irix_dsp_create,
+   3     /* high priority as direct device access */
+};
+
+
+/* public methods (static but exported through the sysdep_dsp or plugin
+   struct) */
+static void *irix_dsp_create(const void *flags)
+{
+	ALpv pvs[4];
+	long tempbits, tempchan;
+	long oldrate;
+	long ratechange = 0;
+	struct irix_dsp_priv_data *priv = NULL;
+	struct sysdep_dsp_struct *dsp = NULL;
+	const struct sysdep_dsp_create_params *params = flags;
+   
+   /* allocate the dsp struct */
+   if (!(dsp = calloc(1, sizeof(struct sysdep_dsp_struct))))
+   {
+      fprintf(stderr, "Error: malloc failed for struct sysdep_dsp_struct.\n"); 
+      return NULL;
+   }
+   
+   /* alloc private data */
+   if(!(priv = calloc(1, sizeof(struct irix_dsp_priv_data))))
+   {
+      fprintf(stderr, "Error: malloc failed for struct irix_dsp_priv_data.\n");
+      irix_dsp_destroy(dsp);
+      return NULL;
+   }
+   
+	/* fill in the functions and some data */
+	priv->port_status = -1;
+   	dsp->_priv = priv;
+	dsp->get_freespace = irix_dsp_get_freespace;
+   	dsp->write = irix_dsp_write;
+   	dsp->destroy = irix_dsp_destroy;
+   	dsp->hw_info.type = params->type;
+   	dsp->hw_info.samplerate = params->samplerate;
+
+   	/* open the sound device */
+	pvs[0].param = AL_MAX_PORTS;
+	pvs[1].param = AL_UNUSED_PORTS;
+	if (alGetParams(AL_SYSTEM,pvs,2) < 0) {
+		fprintf(stderr, "alGetParams failed: %s\n", alGetErrorString(oserror()));
+		irix_dsp_destroy(dsp);
+		return NULL;
+	}  
+
+	if (pvs[1].value.i < 1) {
+		fprintf(stderr, "No available audio ports.\n");
+		irix_dsp_destroy(dsp);
+		return NULL;
+	}
+
+	pvs[0].param = AL_RATE;
+	if (alGetParams(AL_DEFAULT_OUTPUT,pvs,1) < 0) {
+		fprintf(stderr, "alGetParams failed: %s\n", alGetErrorString(oserror()));
+		irix_dsp_destroy(dsp);
+		return NULL;
+	}
+
+    /* If samplerate is different than systems, override */
+	oldrate = pvs[0].value.i;
+	if (pvs[0].value.i != dsp->hw_info.samplerate)
+	{
+		ratechange = 1;
+		fprintf(stderr, "System sample rate was %dHz, forcing %dHz instead.\n",
+			pvs[0].value.i, dsp->hw_info.samplerate);
+	}
+
+	/* create a clean config descriptor */
+	if ( (priv->devAudioConfig = alNewConfig() ) == (ALconfig) NULL ) {
+		fprintf(stderr, "Cannot get a Descriptor. Exiting..\n");
+		irix_dsp_destroy(dsp);
+		return NULL;
+	}
+
+#ifdef FORCE8BIT
+	dsp->hw_info.type &= ~SYSDEP_DSP_16BIT;
+#endif
+#ifdef FORCEMONO
+	dsp->hw_info.type &= ~SYSDEP_DSP_STEREO;
+#endif
+
+	priv->buffer_samples = dsp->hw_info.samplerate * params->bufsize;
+
+	tempchan = (dsp->hw_info.type & SYSDEP_DSP_STEREO)? 2:1;
+	tempbits = (dsp->hw_info.type & SYSDEP_DSP_16BIT)? 2:1;
+	
+	priv->buffer_samples = priv->buffer_samples * tempchan;
+
+	priv->sampwidth = tempbits;
+	priv->sampchan = tempchan;
+
+#ifdef IRIX_DEBUG
+	fprintf(stderr, "Sample Rate Requested: %d\n", dsp->hw_info.samplerate);
+	fprintf(stderr, "Buffer Size Requested: %d\n", priv->buffer_samples);
+#endif
+
+	fprintf(stderr, "Setting sound to %dHz, %d bit, %s\n",dsp->hw_info.samplerate,
+		tempbits * 8, (tempchan == 2) ? "stereo" : "mono");
+
+	/* channel specific audio parameters */
+	alSetChannels(priv->devAudioConfig, tempchan);						/* channels */
+	alSetQueueSize(priv->devAudioConfig,(long) priv->buffer_samples);	/* buffer size */
+	alSetSampFmt(priv->devAudioConfig, AL_SAMPFMT_TWOSCOMP);			/* BTC */
+	alSetWidth(priv->devAudioConfig, tempbits);							/* bitrate */
+
+	/* global audio parameters */
+	pvs[0].param = AL_MASTER_CLOCK;
+	pvs[0].value.i = AL_CRYSTAL_MCLK_TYPE;
+	pvs[1].param = AL_RATE;
+	pvs[1].value.i = dsp->hw_info.samplerate;
+	if (alSetParams(AL_DEFAULT_OUTPUT,pvs,2) < 0) {
+		fprintf(stderr, "Error: Cannot configure the sound system.\n");
+		irix_dsp_destroy(dsp);
+		return(NULL);
+	}
+
+	/* Get new sample rate */
+	pvs[0].param = AL_RATE;
+	if (alGetParams(AL_DEFAULT_OUTPUT,pvs,1) < 0) {
+		fprintf(stderr, "failed\n");
+		irix_dsp_destroy(dsp);
+		return NULL;
+	}
+
+    /* Verify rate was changed */
+	if ((ratechange == 1) && (oldrate == pvs[0].value.i)) 
+	  fprintf(stderr, "Error changing sample rate, using default of: %dHz.\n",
+		pvs[0].value.i);
+
+	/* Open the audio port with the parameters we setup */
+	if ( (priv->devAudio=alOpenPort("audio_fd","w",priv->devAudioConfig) ) == (ALport) NULL ) {
+		fprintf(stderr, "Error: Cannot get an audio channel descriptor.\n");
+		irix_dsp_destroy(dsp);
+		return NULL;
+	}
+
+	/* since we don't have FD's with DMEDIA, we use this to inform us of success */
+	priv->port_status = 0;
+
+   return dsp;
+}
+
+static void irix_dsp_destroy(struct sysdep_dsp_struct *dsp)
+{
+   struct irix_dsp_priv_data *priv = dsp->_priv;
+ 
+#ifdef IRIX_DEBUG 
+	fprintf(stderr, "Destroying sound channel.\n");
+#endif
+ 
+   if(priv)
+   {
+	  if(priv->port_status >= 0) alClosePort(priv->devAudio);
+	  alFreeConfig(priv->devAudioConfig);
+      
+      free(priv);
+   }
+   free(dsp);
+}
+
+
+static int irix_dsp_get_freespace(struct sysdep_dsp_struct *dsp)
+{
+	struct irix_dsp_priv_data *priv = dsp->_priv;
+
+	return alGetFillable(priv->devAudio);
+}
+
+   
+static int irix_dsp_write(struct sysdep_dsp_struct *dsp, unsigned char *data,
+   int count)
+{
+	unsigned char *outbuf=data;
+   int result;
+   struct irix_dsp_priv_data *priv = dsp->_priv;
+	int playcnt;
+	int maxsize;
+
+	maxsize = alGetFillable(priv->devAudio);
+
+/*	count = count * priv->sampchan; */
+
+	if (count <= maxsize) playcnt = count;
+		else playcnt = maxsize;
+
+	outbuf += (priv->sampwidth - 1);	
+
+	for (;outbuf<(data+count);outbuf+=priv->sampwidth) *outbuf ^= 0x80;
+
+	result = alWriteFrames(priv->devAudio, (void *)data, playcnt);
+
+	if (result < 0) {
+		fprintf(stderr, "Error %d: failure writing to irix stream\n",oserror());
+		return -1;
+	}
+
+
+#ifdef IRIX_DEBUG_VERBOSE
+	fprintf(stderr, "Wrote %d samples OK.\n",playcnt);
+#endif
+
+/*	return playcnt / priv->sampchan; */
+	return playcnt;
+}
+
+#endif /* ifdef SYSDEP_DSP_IRIX */
+
diff --git a/src/unix/sysdep/dsp-drivers/netbsd.c b/src/unix/sysdep/dsp-drivers/netbsd.c
new file mode 100644
index 0000000..9069f9f
--- /dev/null
+++ b/src/unix/sysdep/dsp-drivers/netbsd.c
@@ -0,0 +1,284 @@
+/* Sysdep NetBSD sound dsp driver
+
+   Copyright 2000 Hans de Goede, Krister Walfridsson
+   
+   This file and the acompanying files in this directory are free software;
+   you can redistribute them and/or modify them under the terms of the GNU
+   Library General Public License as published by the Free Software Foundation;
+   either version 2 of the License, or (at your option) any later version.
+
+   These files are distributed in the hope that they will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with these files; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.
+*/
+/* Changelog
+Version 0.1, February 2000
+-initial release, based on the xmame OSS dsp driver version 0.1, and using
+ some inspiration from the old xmame NetBSD driver. (Krister Walfridsson)
+*/
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <sys/ioctl.h>
+#include <sys/audioio.h>
+#include "sysdep/sysdep_dsp.h"
+#include "sysdep/sysdep_dsp_priv.h"
+#include "sysdep/plugin_manager.h"
+
+/* Our per instance private data struct. */
+struct netbsd_dsp_priv_data {
+  int fd;
+};
+
+/* Public methods prototypes (static but exported through the sysdep_dsp or
+   plugin struct.) */
+static void *netbsd_dsp_create(const void *flags);
+static void netbsd_dsp_destroy(struct sysdep_dsp_struct *dsp);
+static int netbsd_dsp_get_freespace(struct sysdep_dsp_struct *dsp);
+static int netbsd_dsp_write(struct sysdep_dsp_struct *dsp, unsigned char *data,
+			    int count);
+
+/* Public variables. */
+const struct plugin_struct sysdep_dsp_netbsd = {
+  "netbsd",
+  "sysdep_dsp",
+  "NetBSD DSP plugin",
+  NULL, /* no options */
+  NULL, /* no init */
+  NULL, /* no exit */
+  netbsd_dsp_create,
+  3     /* high priority */
+};
+
+/* Private variables.  */
+static int netbsd_dsp_bytes_per_sample[4] = SYSDEP_DSP_BYTES_PER_SAMPLE;
+
+/* Public methods (static but exported through the sysdep_dsp or plugin
+   struct.) */
+static void *netbsd_dsp_create(const void *flags)
+{
+  int block_size, blocks;
+  audio_info_t a_info;
+  int desired_encoding, desired_precision;
+  struct netbsd_dsp_priv_data *priv = NULL;
+  struct sysdep_dsp_struct *dsp = NULL;
+  const struct sysdep_dsp_create_params *params = flags;
+  const char *device = params->device;
+
+  /* Allocate the dsp struct. */
+  if (!(dsp = calloc(1, sizeof(struct sysdep_dsp_struct))))
+    {
+      fprintf(stderr,
+	      "error malloc failed for struct sysdep_dsp_struct\n");
+      return NULL;
+    }
+
+  /* Alloc private data. */
+  if (!(priv = calloc(1, sizeof(struct netbsd_dsp_priv_data))))
+    {
+      fprintf(stderr,
+	      "error malloc failed for struct netbsd_dsp_priv_data\n");
+      netbsd_dsp_destroy(dsp);
+      return NULL;
+    }
+
+  /* Fill in the functions and some data. */
+  priv->fd = -1;
+  dsp->_priv = priv;
+  dsp->get_freespace = netbsd_dsp_get_freespace;
+  dsp->write = netbsd_dsp_write;
+  dsp->destroy = netbsd_dsp_destroy;
+  dsp->hw_info.type = params->type;
+  dsp->hw_info.samplerate = params->samplerate;
+
+  /* Open the sound device. */
+  if (!device)
+    device = "/dev/audio";
+
+  if((priv->fd = open(device, O_WRONLY, 0)) < 0)
+    {
+      perror("error: /dev/audio");
+      netbsd_dsp_destroy(dsp);
+      return NULL;
+    }
+
+  /* Empty buffers before change config. */
+  ioctl(priv->fd, AUDIO_FLUSH, 0);
+
+  /* Set the number of bits. */
+  AUDIO_INITINFO(&a_info);
+  if (dsp->hw_info.type & SYSDEP_DSP_16BIT)
+    {
+      desired_encoding = AUDIO_ENCODING_SLINEAR;
+      desired_precision = 16;
+    }
+  else
+    {
+      desired_encoding = AUDIO_ENCODING_ULINEAR;
+      desired_precision = 8;
+    }
+  a_info.play.encoding = desired_encoding;
+  a_info.play.precision = desired_precision;
+  if (ioctl(priv->fd, AUDIO_SETINFO, &a_info) < 0)
+    {
+      perror("error: AUDIO_SETINFO");
+      netbsd_dsp_destroy(dsp);
+      return NULL;
+    }
+  if (a_info.play.encoding != desired_encoding
+      || a_info.play.precision != desired_precision)
+    {
+      if (desired_precision == 8)
+	{
+	  fprintf(stderr, "error: couldn't set sound to 8 bits,\n");
+	  netbsd_dsp_destroy(dsp);
+	  return NULL;
+	}
+
+      fprintf(stderr,
+	      "warning: couldn't set sound to 16 bits,\n"
+	      "   trying again with 8 bits: ");
+
+      AUDIO_INITINFO(&a_info);
+      a_info.play.encoding = AUDIO_ENCODING_ULINEAR;
+      a_info.play.precision = 8;
+      if (ioctl(priv->fd, AUDIO_SETINFO, &a_info) < 0)
+	{
+	  perror("error: AUDIO_SETINFO");
+	  netbsd_dsp_destroy(dsp);
+	  return NULL;
+	}
+
+      if (a_info.play.encoding != AUDIO_ENCODING_ULINEAR
+	  || a_info.play.precision != 8)
+	{
+	  fprintf(stderr, "failed\n");
+	  netbsd_dsp_destroy(dsp);
+	  return NULL;
+	}
+      fprintf(stderr, "success\n");
+
+      dsp->hw_info.type &= ~SYSDEP_DSP_16BIT;
+    }
+
+  /* Set the number of channels.  */
+  AUDIO_INITINFO(&a_info);
+  a_info.play.channels = (dsp->hw_info.type & SYSDEP_DSP_STEREO)? 2 : 1;
+  if (ioctl(priv->fd, AUDIO_SETINFO, &a_info) < 0)
+    {
+      perror("error: AUDIO_SETINFO");
+      netbsd_dsp_destroy(dsp);
+      return NULL;
+    }
+  if (a_info.play.channels == 1)
+    dsp->hw_info.type &= ~SYSDEP_DSP_STEREO;
+  else
+    dsp->hw_info.type |= SYSDEP_DSP_STEREO;
+
+  /* Set the sample rate.  */
+  AUDIO_INITINFO(&a_info);
+  a_info.play.sample_rate = dsp->hw_info.samplerate;
+  a_info.mode = AUMODE_PLAY | AUMODE_PLAY_ALL;
+  if (ioctl(priv->fd, AUDIO_SETINFO, &a_info) < 0)
+    {
+      perror("error: AUDIO_SETINFO");
+      netbsd_dsp_destroy(dsp);
+      return NULL;
+    }
+  dsp->hw_info.samplerate = a_info.play.sample_rate;
+   
+  /* Calculate and set the block size and number of blocks.
+     This is basically the same thing as frags in OSS, so the
+     calculations are taken from the OSS driver. The a_info.play.seek
+     used in the freespace calculation doesn't seem to be updated
+     as often as we should like, so the buffer need to consist of
+     at least 4 blocks. */
+  block_size = 1<<9;
+  if (dsp->hw_info.type & SYSDEP_DSP_16BIT) block_size<<=1;
+  if (dsp->hw_info.type & SYSDEP_DSP_STEREO) block_size<<=1;
+
+  blocks = ((dsp->hw_info.samplerate
+	     * netbsd_dsp_bytes_per_sample[dsp->hw_info.type] *
+	     params->bufsize) / block_size) + 1;
+  blocks = (blocks < 4) ? 4 : blocks;
+
+  AUDIO_INITINFO(&a_info);
+  a_info.blocksize = block_size;
+  a_info.play.buffer_size = block_size * blocks;
+  if (ioctl(priv->fd, AUDIO_SETINFO, &a_info) < 0)
+    {
+      perror("error: AUDIO_SETINFO");
+      netbsd_dsp_destroy(dsp);
+      return NULL;
+    }
+  fprintf(stderr, "info: setting blocksize to %d, buffer_size to %d\n",
+	  a_info.blocksize, a_info.play.buffer_size);
+
+  dsp->hw_info.bufsize =
+    block_size * blocks / netbsd_dsp_bytes_per_sample[dsp->hw_info.type];
+
+  fprintf(stderr,
+	  "info: audiodevice %s set to %dbit linear %s %dHz\n",
+	  device,
+	  (dsp->hw_info.type & SYSDEP_DSP_16BIT) ? 16 : 8,
+	  (dsp->hw_info.type & SYSDEP_DSP_STEREO) ? "stereo" : "mono",
+	  dsp->hw_info.samplerate);
+
+  return dsp;
+}
+
+static void netbsd_dsp_destroy(struct sysdep_dsp_struct *dsp)
+{
+  struct netbsd_dsp_priv_data *priv = dsp->_priv;
+
+  if (priv)
+    {
+      if (priv->fd >= 0)
+	close(priv->fd);
+
+      free(priv);
+    }
+  free(dsp);
+}
+
+static int netbsd_dsp_get_freespace(struct sysdep_dsp_struct *dsp)
+{
+  audio_info_t a_info;
+  struct netbsd_dsp_priv_data *priv = dsp->_priv;
+
+  AUDIO_INITINFO(&a_info);
+  if (ioctl(priv->fd, AUDIO_GETINFO, &a_info) < 0)
+    {
+      perror("error: AUDIO_GETINFO");
+      return -1;
+    }
+
+  return  dsp->hw_info.bufsize
+    - a_info.play.seek/netbsd_dsp_bytes_per_sample[dsp->hw_info.type];
+}
+
+static int netbsd_dsp_write(struct sysdep_dsp_struct *dsp, unsigned char *data,
+			    int count)
+{
+  int result;
+  int bytes_per_sample;
+  struct netbsd_dsp_priv_data *priv = dsp->_priv;
+
+  bytes_per_sample = netbsd_dsp_bytes_per_sample[dsp->hw_info.type];
+
+  result = write(priv->fd, data, count * bytes_per_sample);
+
+  if (result < 0)
+    return -1;
+      
+  return result / bytes_per_sample;
+}
diff --git a/src/unix/sysdep/dsp-drivers/oss.c b/src/unix/sysdep/dsp-drivers/oss.c
new file mode 100644
index 0000000..a4371c0
--- /dev/null
+++ b/src/unix/sysdep/dsp-drivers/oss.c
@@ -0,0 +1,305 @@
+/* Sysdep Open Sound System sound dsp driver
+
+   Copyright 2000 Hans de Goede
+   
+   This file and the acompanying files in this directory are free software;
+   you can redistribute them and/or modify them under the terms of the GNU
+   Library General Public License as published by the Free Software Foundation;
+   either version 2 of the License, or (at your option) any later version.
+
+   These files are distributed in the hope that they will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with these files; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.
+*/
+/* Changelog
+Version 0.1, January 2000
+-initial release, based on the xmame driver done by Mike Oliphant
+ (oliphant@ling.ed.ac.uk), amongst others (Hans de Goede)
+*/
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <sys/ioctl.h>
+#if defined (__ARCH_openbsd)
+#include <soundcard.h>
+#else
+#include <sys/soundcard.h>
+#endif
+#include "sysdep/sysdep_dsp.h"
+#include "sysdep/sysdep_dsp_priv.h"
+#include "sysdep/plugin_manager.h"
+
+#ifdef __ARCH_openbsd
+#define AUDIO_DEVICE   "/dev/audio"
+#else
+#define AUDIO_DEVICE   "/dev/dsp"
+#endif
+
+/* our per instance private data struct */
+struct oss_dsp_priv_data {
+   int fd;
+};
+
+/* public methods prototypes (static but exported through the sysdep_dsp or
+   plugin struct) */
+static void *oss_dsp_create(const void *flags);
+static void oss_dsp_destroy(struct sysdep_dsp_struct *dsp);
+static int oss_dsp_get_freespace(struct sysdep_dsp_struct *dsp);
+static int oss_dsp_write(struct sysdep_dsp_struct *dsp, unsigned char *data,
+   int count);
+
+/* public variables */
+const struct plugin_struct sysdep_dsp_oss = {
+   "oss",
+   "sysdep_dsp",
+   "Open Sound System DSP plugin",
+   NULL, /* no options */
+   NULL, /* no init */
+   NULL, /* no exit */
+   oss_dsp_create,
+   3     /* high priority */
+};
+
+/* private variables */
+static int oss_dsp_bytes_per_sample[4] = SYSDEP_DSP_BYTES_PER_SAMPLE;
+
+/* public methods (static but exported through the sysdep_dsp or plugin
+   struct) */
+static void *oss_dsp_create(const void *flags)
+{
+   int i, j;
+   audio_buf_info info;
+   struct oss_dsp_priv_data *priv = NULL;
+   struct sysdep_dsp_struct *dsp = NULL;
+   const struct sysdep_dsp_create_params *params = flags;
+   const char *device = params->device;
+   
+   /* allocate the dsp struct */
+   if (!(dsp = calloc(1, sizeof(struct sysdep_dsp_struct))))
+   {
+      fprintf(stderr,
+         "error malloc failed for struct sysdep_dsp_struct\n");
+      return NULL;
+   }
+   
+   /* alloc private data */
+   if (!(priv = calloc(1, sizeof(struct oss_dsp_priv_data))))
+   {
+      fprintf(stderr,
+         "error malloc failed for struct oss_dsp_priv_data\n");
+      oss_dsp_destroy(dsp);
+      return NULL;
+   }
+   
+   /* fill in the functions and some data */
+   priv->fd = -1;
+   dsp->_priv = priv;
+   dsp->get_freespace = oss_dsp_get_freespace;
+   dsp->write = oss_dsp_write;
+   dsp->destroy = oss_dsp_destroy;
+   dsp->hw_info.type = params->type;
+   dsp->hw_info.samplerate = params->samplerate;
+   
+   /* open the sound device */
+   if (!device)
+      device = AUDIO_DEVICE;
+   
+   /* always open in non-blocking mode, otherwise the open itself may
+      block, hanging the entire application */
+   if ((priv->fd = open(device, O_WRONLY|O_NONBLOCK, 0)) < 0) {
+      perror("error: " AUDIO_DEVICE);
+      oss_dsp_destroy(dsp);
+      return NULL;
+   }
+   
+   /* set back to blocking mode, unless non-blocking mode was selected */
+   if (!(params->flags & SYSDEP_DSP_O_NONBLOCK))
+   {
+      if (fcntl(priv->fd, F_SETFL, O_WRONLY) < 0)
+      {
+         perror("OSS-driver, error: fnctl");
+         oss_dsp_destroy(dsp);
+         return NULL;
+      }
+   }
+   
+   /* set the number of bits */
+#ifdef LSB_FIRST
+   i = j = (dsp->hw_info.type & SYSDEP_DSP_16BIT) ? AFMT_S16_LE : AFMT_U8;
+#else
+   i = j = (dsp->hw_info.type & SYSDEP_DSP_16BIT) ? AFMT_S16_BE : AFMT_U8;
+#endif
+
+   if (ioctl(priv->fd, SNDCTL_DSP_SETFMT, &i) < 0)
+   {
+      perror("error: SNDCTL_DSP_SETFMT");
+      oss_dsp_destroy(dsp);
+      return NULL;
+   }
+
+   if (i != j)
+   {
+      if (dsp->hw_info.type & SYSDEP_DSP_16BIT)
+      {
+         fprintf(stderr, "warning: couldn't set sound to 16 bits,\n"
+            "   trying again with 8 bits: ");
+      }
+      else
+      {
+         fprintf(stderr, "error: couldn't set sound to 8 bits,\n");
+         oss_dsp_destroy(dsp);
+         return NULL;
+      }
+
+      dsp->hw_info.type &= ~SYSDEP_DSP_16BIT;
+      i = AFMT_U8;
+      if (ioctl(priv->fd, SNDCTL_DSP_SETFMT, &i) < 0)
+      {
+         perror("error: SNDCTL_DSP_SETFMT");
+         oss_dsp_destroy(dsp);
+         return NULL;
+      }
+
+      if (i != AFMT_U8)
+      {
+         fprintf(stderr, "failed\n");
+         oss_dsp_destroy(dsp);
+         return NULL;
+      }
+      fprintf(stderr, "success\n");
+   }
+   
+   /* set the number of channels */
+   i = (dsp->hw_info.type & SYSDEP_DSP_STEREO) ? 1 : 0;
+   if (ioctl(priv->fd, SNDCTL_DSP_STEREO, &i) < 0)
+   {
+      perror("error: SNDCTL_DSP_STEREO");
+      oss_dsp_destroy(dsp);
+      return NULL;
+   }
+
+   if (i)
+      dsp->hw_info.type |= SYSDEP_DSP_STEREO;
+   else
+      dsp->hw_info.type &= ~SYSDEP_DSP_STEREO;
+   
+   /* set the samplerate */
+   if (ioctl(priv->fd, SNDCTL_DSP_SPEED, &dsp->hw_info.samplerate) < 0)
+   {
+      perror("error: SNDCTL_DSP_SPEED");
+      oss_dsp_destroy(dsp);
+      return NULL;
+   }
+   
+   /* calculate and set the fragsize & number of frags */
+   /* fragsize (as power of 2) */
+   i = 7;
+   if (dsp->hw_info.type & SYSDEP_DSP_16BIT) i++;
+   if (dsp->hw_info.type & SYSDEP_DSP_STEREO) i++;
+   i += dsp->hw_info.samplerate / 22000;
+   
+   /* number of frags */
+   j = ((dsp->hw_info.samplerate * oss_dsp_bytes_per_sample[dsp->hw_info.type] *
+      params->bufsize) / (0x01 << i)) + 1;
+      
+   /* set the fraginfo */
+   i = j = i | (j << 16);
+   fprintf(stderr, "info: setting fragsize to %d, numfrags to %d\n",
+   	1 << (i & 0x0000FFFF), i >> 16);
+   if (ioctl(priv->fd, SNDCTL_DSP_SETFRAGMENT, &i) < 0)
+   {
+      perror("error: SNDCTL_DSP_SETFRAGMENT");
+      oss_dsp_destroy(dsp);
+      return NULL;
+   }
+
+   if (ioctl(priv->fd, SNDCTL_DSP_GETOSPACE, &info) < 0)
+   {
+      perror("warning: SNDCTL_DSP_GETOSPACE");
+      fprintf(stderr, "   falling back to timer based-audio\n");
+      dsp->get_freespace = NULL;
+   }
+   else
+   {
+      fprintf(stderr, "info: fragsize = %d, numfrags = %d\n", info.fragsize,
+         info.fragstotal);
+      /* i = requested fragsize, j = requested numfrags */
+      i = 1 << (j & 0x0000FFFF);
+      j = j >> 16;
+      if ((info.fragsize < (i / 2)) || (info.fragsize > (i * 2)) ||
+         (info.fragstotal < (j - 2)) || (info.fragstotal > (j + 2)))
+      {
+         fprintf(stderr, "warning: obtained fragsize/numfrags differs too much from requested\n"
+            "   you may wish to adjust the bufsize setting in your xmamerc file, or try\n"
+	    "   timer-based audio by adding -timer to your command line\n");
+      }
+      else if (info.bytes > (info.fragsize * info.fragstotal))
+      {
+         fprintf(stderr, "warning: freespace > (fragsize * numfrags) assuming buggy FreeBSD PCM driver,\n"
+            "   falling back to timer based-audio\n");
+         dsp->get_freespace = NULL;
+      }
+      else
+         /* info.fragstotal + 1 to work around yet more OSS bugs ;( */
+         dsp->hw_info.bufsize = (info.fragsize * (info.fragstotal + 1)) /
+            oss_dsp_bytes_per_sample[dsp->hw_info.type];
+   }
+
+   fprintf(stderr, "info: audiodevice %s set to %dbit linear %s %dHz\n",
+      device, (dsp->hw_info.type & SYSDEP_DSP_16BIT)? 16:8,
+      (dsp->hw_info.type & SYSDEP_DSP_STEREO)? "stereo":"mono",
+      dsp->hw_info.samplerate);
+      
+   return dsp;
+}
+
+static void oss_dsp_destroy(struct sysdep_dsp_struct *dsp)
+{
+   struct oss_dsp_priv_data *priv = dsp->_priv;
+   
+   if (priv)
+   {
+      if (priv->fd >= 0)
+         close(priv->fd);
+      
+      free(priv);
+   }
+   free(dsp);
+}
+   
+static int oss_dsp_get_freespace(struct sysdep_dsp_struct *dsp)
+{
+   audio_buf_info info;
+   struct oss_dsp_priv_data *priv = dsp->_priv;
+   
+   if (ioctl(priv->fd, SNDCTL_DSP_GETOSPACE, &info) < 0)
+   {
+      perror("error: SNDCTL_DSP_GETOSPACE");
+      return -1;
+   }
+   return info.bytes / oss_dsp_bytes_per_sample[dsp->hw_info.type];
+}
+
+static int oss_dsp_write(struct sysdep_dsp_struct *dsp, unsigned char *data,
+   int count)
+{
+   int result;
+   struct oss_dsp_priv_data *priv = dsp->_priv;
+
+   result = write(priv->fd, data, count *
+      oss_dsp_bytes_per_sample[dsp->hw_info.type]);
+      
+   if (result < 0)
+      return -1;
+      
+   return result / oss_dsp_bytes_per_sample[dsp->hw_info.type];
+}
diff --git a/src/unix/sysdep/dsp-drivers/sdl.c b/src/unix/sysdep/dsp-drivers/sdl.c
new file mode 100644
index 0000000..b9dd358
--- /dev/null
+++ b/src/unix/sysdep/dsp-drivers/sdl.c
@@ -0,0 +1,244 @@
+#ifdef SYSDEP_DSP_SDL
+
+/* Sysdep SDL sound dsp driver
+
+   Copyright 2001 Jack Burton aka Stefano Ceccherini
+   <burton666@freemail.it>
+   
+   This file and the acompanying files in this directory are free software;
+   you can redistribute them and/or modify them under the terms of the GNU
+   Library General Public License as published by the Free Software Foundation;
+   either version 2 of the License, or (at your option) any later version.
+
+   These files are distributed in the hope that they will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with these files; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.
+*/
+
+/* Thank goes to Caz Jones <turok2@currantbun.com>, who fixed this plugin 
+   and made it finally sound good.
+*/
+/* Changelog
+Version 0.1, January 2002
+-initial release, based on various xmame dsp plugins and Yoshi's code
+
+
+*/
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <strings.h>
+#include "SDL.h"
+#include "sysdep/sysdep_dsp.h"
+#include "sysdep/sysdep_dsp_priv.h"
+#include "sysdep/plugin_manager.h"
+
+#ifdef __BEOS__
+#define BUFFERSIZE 1470 * 4 /* in my experience, BeOS likes buffers to be 4x */
+#else
+#define BUFFERSIZE 1024
+#endif
+
+/* private variables */
+static struct {
+	Uint8 *data;
+    int amountRemain;
+    int amountWrite;
+    int amountRead;
+    int tmp;
+    Uint32 soundlen;
+    int sound_n_pos;
+    int sound_w_pos;
+    int sound_r_pos;
+} sample; 
+
+/* callback function prototype */
+static void sdl_fill_sound(void *unused, Uint8 *stream, int len);
+
+/* public methods prototypes */
+static void *sdl_dsp_create(const void *flags);
+static void sdl_dsp_destroy(struct sysdep_dsp_struct *dsp);
+static int sdl_dsp_write(struct sysdep_dsp_struct *dsp, unsigned char *data,
+   int count);
+
+
+/* public variables */
+const struct plugin_struct sysdep_dsp_sdl = {
+   "sdl",
+   "sysdep_dsp",
+   "Simple Direct Library DSP plugin",
+   NULL, /* no options */
+   NULL, /* no init */
+   NULL, /* no exit */
+   sdl_dsp_create,
+   3     /* high priority */
+};
+
+/* public methods (static but exported through the sysdep_dsp or plugin
+   struct) */
+static void *sdl_dsp_create(const void *flags)
+{
+   struct sdl_dsp_priv_data *priv = NULL;
+   struct sysdep_dsp_struct *dsp = NULL;
+   const struct sysdep_dsp_create_params *params = flags;
+   const char *device = params->device;
+   SDL_AudioSpec *audiospec;
+   
+   /* allocate the dsp struct */
+   if (!(dsp = calloc(1, sizeof(struct sysdep_dsp_struct))))
+   {
+      fprintf(stderr,
+         "error malloc failed for struct sysdep_dsp_struct\n");
+      return NULL;
+   }
+   
+   
+   if (!(audiospec = calloc(1, sizeof(SDL_AudioSpec))))
+   {
+   		fprintf(stderr, "error malloc failed for SDL_AudioSpec\n");
+   		sdl_dsp_destroy(dsp);
+   		return NULL;
+   }
+
+   
+   if (!(sample.data = calloc(BUFFERSIZE, sizeof(Uint8))))
+   {
+   		fprintf(stderr, "error malloc failed for data\n");
+   		sdl_dsp_destroy(dsp);
+   		return NULL;
+   }
+   
+   /* fill in the functions and some data */
+   dsp->_priv = priv;
+   dsp->write = sdl_dsp_write;
+   dsp->destroy = sdl_dsp_destroy;
+   dsp->hw_info.type = params->type;
+   dsp->hw_info.samplerate = params->samplerate;
+    
+    
+   /* set the number of bits */
+   audiospec->format = (dsp->hw_info.type & SYSDEP_DSP_16BIT)?
+   							AUDIO_S16SYS : AUDIO_S8;
+   
+   /* set the number of channels */
+   audiospec->channels = (dsp->hw_info.type & SYSDEP_DSP_STEREO)? 2:1;
+         
+   /* set the samplerate */
+   audiospec->freq = dsp->hw_info.samplerate;
+   
+   /* set samples size */
+   audiospec->samples = BUFFERSIZE;
+   
+   /* set callback funcion */
+   audiospec->callback = sdl_fill_sound;
+   
+   audiospec->userdata = NULL;
+   
+   /* Open audio device */
+   if(SDL_WasInit(SDL_INIT_VIDEO)!=0)   /* If sdl video system is already */
+      SDL_InitSubSystem(SDL_INIT_AUDIO);/* initialized, we just initialize */
+   else									/* the audio subsystem */
+   	  SDL_Init(SDL_INIT_AUDIO);   		/* else we MUST use "SDL_Init" */
+   										/* (untested) */
+   if (SDL_OpenAudio(audiospec, NULL) != 0) { 
+   		fprintf(stderr, "failed opening audio device\n");
+   		return NULL;
+   }
+   SDL_PauseAudio(0);
+   
+   fprintf(stderr, "info: audiodevice %s set to %dbit linear %s %dHz\n",
+      device, (dsp->hw_info.type & SYSDEP_DSP_16BIT)? 16:8,
+      (dsp->hw_info.type & SYSDEP_DSP_STEREO)? "stereo":"mono",
+      dsp->hw_info.samplerate);
+      
+   return dsp;
+}
+
+static void sdl_dsp_destroy(struct sysdep_dsp_struct *dsp)
+{ 
+   SDL_CloseAudio();
+    
+   free(dsp);
+}
+   
+
+static int sdl_dsp_write(struct sysdep_dsp_struct *dsp, unsigned char *data,
+   int count)
+{
+	/* sound_n_pos = normal position
+	   sound_r_pos = read position
+	   and so on.					*/
+	int result = 0;
+	Uint8 *src;
+	SDL_LockAudio();
+	
+	sample.amountRemain = BUFFERSIZE - sample.sound_n_pos;
+	sample.amountWrite = (dsp->hw_info.type & SYSDEP_DSP_STEREO)? count * 4 : count * 2;
+	
+	if(sample.amountRemain <= 0) {
+		SDL_UnlockAudio();
+		return(result);
+	}
+	
+	if(sample.amountRemain < sample.amountWrite) sample.amountWrite = sample.amountRemain;
+		result = (int)sample.amountWrite;
+		sample.sound_n_pos += sample.amountWrite;
+		
+		src = (Uint8 *)data;
+		sample.tmp = BUFFERSIZE - sample.sound_w_pos;
+		
+		if(sample.tmp < sample.amountWrite){
+			memcpy(sample.data + sample.sound_w_pos, src, sample.tmp);
+			sample.amountWrite -= sample.tmp;
+			src += sample.tmp;
+			memcpy(sample.data, src, sample.amountWrite);			
+			sample.sound_w_pos = sample.amountWrite;
+		}
+		else{
+			memcpy( sample.data + sample.sound_w_pos, src, sample.amountWrite);
+			sample.sound_w_pos += sample.amountWrite;
+		}
+		SDL_UnlockAudio();
+		
+	return	count;
+}
+
+/* Private method */
+static void sdl_fill_sound(void *unused, Uint8 *stream, int len) 
+{
+	int result;
+	Uint8 *dst;
+	SDL_LockAudio();
+	sample.amountRead = len;
+	if(sample.sound_n_pos <= 0)
+		SDL_UnlockAudio();
+		
+		if(sample.sound_n_pos<sample.amountRead) sample.amountRead = sample.sound_n_pos;
+		result = (int)sample.amountRead;
+		sample.sound_n_pos -= sample.amountRead;
+		
+		dst = (Uint8*)stream;
+		
+		sample.tmp = BUFFERSIZE - sample.sound_r_pos;
+		if(sample.tmp<sample.amountRead){
+			memcpy( dst, sample.data + sample.sound_r_pos, sample.tmp);
+			sample.amountRead -= sample.tmp;
+			dst += sample.tmp;
+			memcpy( dst, sample.data, sample.amountRead);	
+			sample.sound_r_pos = sample.amountRead;
+		}
+		else{
+			memcpy( dst, sample.data + sample.sound_r_pos, sample.amountRead);
+			sample.sound_r_pos += sample.amountRead;
+		}
+	SDL_UnlockAudio();
+
+}
+
+#endif /* ifdef SYSDEP_DSP_SDL */
diff --git a/src/unix/sysdep/dsp-drivers/solaris.c b/src/unix/sysdep/dsp-drivers/solaris.c
new file mode 100644
index 0000000..4db814d
--- /dev/null
+++ b/src/unix/sysdep/dsp-drivers/solaris.c
@@ -0,0 +1,264 @@
+/* Sysdep Solaris sound dsp driver
+
+   Copyright 2000 Hans de Goede, Mathis Rosenhauer
+   
+   This file and the acompanying files in this directory are free software;
+   you can redistribute them and/or modify them under the terms of the GNU
+   Library General Public License as published by the Free Software Foundation;
+   either version 2 of the License, or (at your option) any later version.
+
+   These files are distributed in the hope that they will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with these files; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.
+*/
+/* Changelog
+Version 0.1, February 2000
+-initial release, based on oss.c and on the old xmame sound driver done by 
+ Juan Antonio Martinez, Keith Hargrove, Mathis Rosenhauer and others.
+ (Mathis Rosenhauer)
+*/
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <sys/types.h>
+#include <sys/conf.h>
+#include <sys/stat.h>
+#include <sys/ioctl.h>
+#include <sys/stropts.h>
+#include <sys/audioio.h>
+#include "sysdep/sysdep_dsp.h"
+#include "sysdep/sysdep_dsp_priv.h"
+#include "sysdep/plugin_manager.h"
+
+/* our per instance private data struct */
+struct sol_dsp_priv_data {
+	int fd;
+	unsigned int samples_written;
+	unsigned int buffer_samples;
+};
+
+/* public methods prototypes (static but exported through the sysdep_dsp or
+   plugin struct) */
+static void *sol_dsp_create(const void *flags);
+static void sol_dsp_destroy(struct sysdep_dsp_struct *dsp);
+static int sol_dsp_get_freespace(struct sysdep_dsp_struct *dsp);
+static int sol_dsp_write(struct sysdep_dsp_struct *dsp, unsigned char *data,
+						 int count);
+
+/* public variables */
+const struct plugin_struct sysdep_dsp_solaris = {
+	"solaris",
+	"sysdep_dsp",
+	"Solaris DSP plugin",
+	NULL, /* no options */
+	NULL, /* no init */
+	NULL, /* no exit */
+	sol_dsp_create,
+	3	  /* high priority */
+};
+
+/* private variables */
+static int sol_dsp_bytes_per_sample[4] = SYSDEP_DSP_BYTES_PER_SAMPLE;
+
+/* public methods (static but exported through the sysdep_dsp or plugin
+   struct) */
+static void *sol_dsp_create(const void *flags)
+{
+	int i,j;
+	audio_info_t info;   /* info about audio settings */
+	audio_device_t dev;  /* info about audio hardware */
+	struct sol_dsp_priv_data *priv = NULL;
+	struct sysdep_dsp_struct *dsp = NULL;
+	const struct sysdep_dsp_create_params *params = flags;
+	const char *device = params->device;
+	
+	/* allocate the dsp struct */
+	if (!(dsp = calloc(1, sizeof(struct sysdep_dsp_struct))))
+	{
+		perror("error malloc failed for struct sysdep_dsp_struct\n");
+		return NULL;
+	}
+   
+	/* alloc private data */
+	if(!(priv = calloc(1, sizeof(struct sol_dsp_priv_data))))
+	{
+		perror("error malloc failed for struct sol_dsp_priv_data\n");
+		sol_dsp_destroy(dsp);
+		return NULL;
+	}
+   
+	/* fill in the functions and some data */
+	priv->fd = -1;
+	priv->samples_written = 0;
+	dsp->_priv = priv;
+	dsp->get_freespace = sol_dsp_get_freespace;
+	dsp->write = sol_dsp_write;
+	dsp->destroy = sol_dsp_destroy;
+	dsp->hw_info.type = params->type;
+	dsp->hw_info.samplerate = params->samplerate;
+   
+	/* open the sound device */
+	if (!device)
+		device = getenv("AUDIODEV");
+	if (!device)
+		device = "/dev/audio";
+   
+	if((priv->fd = open(device, O_WRONLY)) < 0)
+	{
+		fprintf(stderr, "error: opening %s\n", device);
+		sol_dsp_destroy(dsp);
+		return NULL;
+	}
+   
+	/* empty buffers before change config */
+	ioctl(priv->fd, AUDIO_DRAIN, 0);	/* drain everything out */
+	ioctl(priv->fd, I_FLUSH, FLUSHRW);	/* flush everything		*/
+		
+	/* identify audio device. */
+	if(ioctl(priv->fd, AUDIO_GETDEV, &dev) < 0)
+	{
+		perror("error: cannot get sound device type\n");
+		sol_dsp_destroy(dsp);
+		return NULL;
+	}
+
+	fprintf(stderr, "info: sound device is a %s %s version %s\n",dev.config,dev.name,dev.version);
+		
+	/* get audio parameters. */
+	if (ioctl(priv->fd, AUDIO_GETINFO, &info) < 0)
+	{
+		perror("AUDIO_GETINFO failed!\nRun with -nosound\n");
+		sol_dsp_destroy(dsp);
+		return NULL;
+	}
+
+	/* set the number of bits */
+	AUDIO_INITINFO(&info);
+
+	if (dsp->hw_info.type & SYSDEP_DSP_16BIT)
+	{
+		info.play.encoding = i = AUDIO_ENCODING_LINEAR;
+		info.play.precision = j = 16;
+	}
+	else
+	{
+		info.play.encoding = i = AUDIO_ENCODING_LINEAR8;
+		info.play.precision = j = 8;
+	}
+
+	if (ioctl(priv->fd, AUDIO_SETINFO, &info) < 0)
+	{
+		perror("error: AUDIO_SETINFO\n");
+		sol_dsp_destroy(dsp);
+		return NULL;
+	}
+	if ((info.play.encoding != i) || (info.play.precision != j))
+	{
+		if(dsp->hw_info.type & SYSDEP_DSP_16BIT)
+		{
+			fprintf(stderr, "warning: couldn't set sound to 16 bits,\ntrying again with 8 bits: ");
+		}
+		else
+		{
+			fprintf(stderr, "error: couldn't set sound to 8 bits,\n");
+			sol_dsp_destroy(dsp);
+			return NULL;
+		}
+		dsp->hw_info.type &= ~SYSDEP_DSP_16BIT;
+		info.play.precision = 8;
+		info.play.encoding = AUDIO_ENCODING_LINEAR8;
+		if (ioctl(priv->fd, AUDIO_SETINFO, &info) < 0)
+		{
+			perror("error: AUDIO_SETINFO\n");
+			sol_dsp_destroy(dsp);
+			return NULL;
+		}
+		if (info.play.precision != 8 || info.play.encoding != AUDIO_ENCODING_LINEAR8)
+		{
+			fprintf(stderr, "failed\n");
+			sol_dsp_destroy(dsp);
+			return NULL;
+		}
+		fprintf(stderr, "success\n");
+	}
+   
+   /* set the number of channels */
+    info.play.channels = (dsp->hw_info.type & SYSDEP_DSP_STEREO)? 2:1;
+	if (ioctl(priv->fd, AUDIO_SETINFO, &info) < 0)
+	{
+		perror("error: AUDIO_SETINFO\n");
+		sol_dsp_destroy(dsp);
+		return NULL;
+	}
+	if(info.play.channels == 2)
+		dsp->hw_info.type |= SYSDEP_DSP_STEREO;
+	else
+		dsp->hw_info.type &= ~SYSDEP_DSP_STEREO;
+   
+	/* set the samplerate and buffer size*/
+	info.play.sample_rate = dsp->hw_info.samplerate;
+	priv->buffer_samples = dsp->hw_info.samplerate * params->bufsize;
+	info.play.buffer_size = dsp->hw_info.bufsize = priv->buffer_samples * sol_dsp_bytes_per_sample[dsp->hw_info.type]; /* this seems to have no effect */
+	if (ioctl(priv->fd, AUDIO_SETINFO, &info) < 0)
+	{
+		perror("error: AUDIO_SETINFO\n");
+		sol_dsp_destroy(dsp);
+		return NULL;
+	}
+
+	dsp->hw_info.samplerate = info.play.sample_rate;
+	fprintf(stderr, "info: audiodevice %s set to %dbit linear %s %dHz\n",
+			dev.name, info.play.precision,
+			(info.play.channels & 2)? "stereo":"mono",
+			info.play.sample_rate);
+	
+	return dsp;
+}
+
+static void sol_dsp_destroy(struct sysdep_dsp_struct *dsp)
+{
+	struct sol_dsp_priv_data *priv = dsp->_priv;
+   
+	if(priv)
+	{
+		if(priv->fd >= 0)
+			close(priv->fd);
+		free(priv);
+	}
+	free(dsp);
+}
+   
+static int sol_dsp_get_freespace(struct sysdep_dsp_struct *dsp)
+{
+	audio_info_t info;
+	struct sol_dsp_priv_data *priv = dsp->_priv;
+   
+	if (ioctl(priv->fd, AUDIO_GETINFO, &info) < 0)
+	{
+		perror("error: AUDIO_GETINFO\n");
+		return -1;
+	}
+	return priv->buffer_samples - (priv->samples_written - info.play.samples);
+}
+
+static int sol_dsp_write(struct sysdep_dsp_struct *dsp, unsigned char *data, int count)
+{
+	int result;
+	struct sol_dsp_priv_data *priv = dsp->_priv;
+	result = write(priv->fd, data, count * sol_dsp_bytes_per_sample[dsp->hw_info.type]);
+
+	if (result < 0)
+		return -1;
+	
+	result /= sol_dsp_bytes_per_sample[dsp->hw_info.type];
+	priv->samples_written += result;
+	return result;
+}
diff --git a/src/unix/sysdep/dsp-drivers/soundkit.m b/src/unix/sysdep/dsp-drivers/soundkit.m
new file mode 100644
index 0000000..29081cc
--- /dev/null
+++ b/src/unix/sysdep/dsp-drivers/soundkit.m
@@ -0,0 +1,169 @@
+/*
+ * Driver for the NeXT / Apple soundkit objects for use on OpenStep
+ * systems. Based on the older sound drivers, converted into the new
+ * style framework by taking a long hard look at esound.c.
+ *
+ * -bat. 06/09/2000
+ */
+
+#import <stdio.h>
+#import <stdlib.h>
+#import <unistd.h>
+#import <SoundKit/SoundKit.h>
+
+#import "sysdep/sysdep_dsp.h"
+#import "sysdep/sysdep_dsp_priv.h"
+#import "sysdep/plugin_manager.h"
+
+/*
+ * Destroy function - we release the playStream and free up
+ * the dsp structure.
+ */
+
+static void
+soundkit_dsp_destroy(struct sysdep_dsp_struct *dsp)
+{
+	NXPlayStream *playStream = (NXPlayStream*)dsp->_priv;
+
+	[playStream release];
+
+	free(dsp);
+}
+
+/*
+ * Write a block of data to the sound object. We take pains to make sure it
+ * in the correct format by copying it around the place quite a lot - this
+ * makes 8 bit sound rather slow as we cannot write it to the device
+ * directly due to an intel bug.
+ */
+   
+static int
+soundkit_dsp_write(struct sysdep_dsp_struct *dsp,
+		unsigned char *data, int count)
+{
+	static int theTag = 1;
+	static long buff_size = 0;
+	static unsigned char *out_buff = NULL;
+
+	BOOL isStereo = (dsp->hw_info.type & SYSDEP_DSP_STEREO) ? YES : NO;
+	NXPlayStream *playStream = (NXPlayStream*)dsp->_priv;
+	long bytes = sizeof(short) * count * (isStereo ? 2 : 1);
+
+	/* do a malloc if necessary */
+	if(bytes > buff_size) {
+		if(out_buff)
+			free(out_buff);
+		out_buff = malloc(bytes);
+		if(!out_buff)
+			return 0;
+		buff_size = bytes;
+	}
+
+	/* do the byte swap and write the block */
+	SNDSwapHostToSound(out_buff, data, count,
+			isStereo ? 2: 1, SND_FORMAT_LINEAR_16);
+	[playStream playBuffer:out_buff size:bytes tag:theTag++];
+
+	return count;
+}
+
+/*
+ * Creation function.
+ */
+
+static void*
+soundkit_dsp_create(const void *flags)
+{
+	NXPlayStream *playStream = nil;
+	NXSoundOut *soundOut = nil;
+	NXSoundParameters *soundParams = nil;
+	SNDSoundStruct *soundStruct = NULL;
+	char *soundHost = getenv("SOUNDHOST");
+	id priv = nil;
+	struct sysdep_dsp_struct *dsp = NULL;
+	const struct sysdep_dsp_create_params *params = flags;
+
+	/* allocate the dsp struct */
+	if (!(dsp = calloc(1, sizeof(struct sysdep_dsp_struct))))
+	{
+		perror("error malloc failed for struct sysdep_dsp_struct\n");
+		return NULL;
+	}
+
+	/* create sound object (possibly remotely) */
+	if(soundHost) {
+		soundOut = [[NXSoundOut alloc]
+			initOnHost:[NSString stringWithCString:soundHost]];
+		if(!soundOut) {
+			fprintf(stderr,
+				"could not initialise sound object on %s\n",
+				soundHost);
+	      		return NULL;
+	    	} else
+			fprintf(stderr, "info: soundkit: send sound to %s\n",
+					soundHost);
+	} else
+		soundOut = [NXSoundOut new];
+
+	if(!soundOut) {
+		fprintf(stderr,"could not initialise sound object\n");
+		return NULL;
+	}
+
+	/* create a parameters object - always 16 bit please ! */
+	dsp->hw_info.type |= SYSDEP_DSP_16BIT;
+	if(params->type & SYSDEP_DSP_STEREO) {
+		SNDAlloc(&soundStruct, 0, SND_FORMAT_LINEAR_16,
+				params->samplerate, 2, 0);
+		dsp->hw_info.type |= SYSDEP_DSP_STEREO;
+	} else {
+		SNDAlloc(&soundStruct, 0, SND_FORMAT_LINEAR_16,
+				params->samplerate, 1, 0);
+	}
+	soundParams = [[NXSoundParameters alloc]
+			initFromSoundStruct:soundStruct];
+	if(!soundParams) {
+		fprintf(stderr,"could not create sound parameters\n");
+		return NULL;
+	}
+
+	/* print the info */
+	fprintf(stderr, "info: soundkit: %s sound at %d hz\n",
+			(dsp->hw_info.type & SYSDEP_DSP_STEREO) ?
+			"stereo" : "mono", params->samplerate);
+
+	/* create the stream object */
+	playStream = [[NXPlayStream alloc]
+		initOnDevice:soundOut withParameters:soundParams];
+	if(!playStream) {
+		fprintf(stderr,"could not create play stream\n");
+		return NULL;
+	}
+
+	/* fill in the functions and some data */
+	dsp->_priv = playStream;
+	dsp->write = soundkit_dsp_write;
+	dsp->destroy = soundkit_dsp_destroy;
+	dsp->hw_info.type = params->type;
+	dsp->hw_info.samplerate = params->samplerate;
+
+	/* activate and return */
+   
+	[playStream activate];
+	return dsp;
+}
+
+/*
+ * The public variables structure
+ */
+
+const struct plugin_struct sysdep_dsp_soundkit = {
+	"soundkit",
+	"sysdep_dsp",
+	"NeXT SoundKit plugin",
+	NULL, 				/* no options */
+	NULL,				/* no init */
+	NULL,				/* no exit */
+	soundkit_dsp_create,
+	3				/* high priority */
+};
diff --git a/src/unix/sysdep/dsp-drivers/waveout.c b/src/unix/sysdep/dsp-drivers/waveout.c
new file mode 100644
index 0000000..ed8ef9c
--- /dev/null
+++ b/src/unix/sysdep/dsp-drivers/waveout.c
@@ -0,0 +1,216 @@
+/* Sysdep Wave File Output sound dsp driver
+
+   Written by Donald King.
+   This file is placed in the Public Domain.
+*/
+
+/* Changelog
+   Version 0.1, September 2002
+   - Initial release
+*/
+
+#ifdef SYSDEP_DSP_WAVEOUT
+
+#include <errno.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include "sysdep/sysdep_dsp.h"
+#include "sysdep/sysdep_dsp_priv.h"
+#include "sysdep/plugin_manager.h"
+
+struct waveout_dsp_priv_data {
+   const char *name;
+   FILE *file;
+};
+
+static void *waveout_dsp_create(const void *flags);
+static void waveout_dsp_destroy(struct sysdep_dsp_struct *dsp);
+static int waveout_dsp_write(struct sysdep_dsp_struct *dsp, unsigned char *data, int count);
+
+const struct plugin_struct sysdep_dsp_waveout = {
+   "waveout",
+   "sysdep_dsp",
+   "Wave File Output DSP plugin",
+   NULL,				/* no options */
+   NULL,				/* no init */
+   NULL,				/* no exit */
+   waveout_dsp_create,
+   0					/* very low priority */
+};
+
+static int waveout_dsp_bytes_per_sample[4] = SYSDEP_DSP_BYTES_PER_SAMPLE;
+
+static const unsigned char wave_template[44] = {
+  'R', 'I', 'F', 'F',	/*  0: 'RIFF' magic */
+    0,   0,   0,   0,	/*  4: 'RIFF' length */
+  'W', 'A', 'V', 'E',	/*  8: 'RIFF' type */
+  'f', 'm', 't', ' ',	/* 12: 'fmt ' chunk-type */
+   16,   0,   0,   0,	/* 16: 'fmt ' chunk-length */
+    1,   0,		/* 20: WAVE_FORMAT_PCM */
+    1,   0,		/* 22: Channels */
+    0,   0,   0,   0,	/* 24: Samples per second */
+    0,   0,   0,   0,	/* 28: Bytes per second */
+    1,   0,		/* 32: Aligned bytes per sample group */
+    8,   0,		/* 34: Bits per sample */
+  'd', 'a', 't', 'a',	/* 36: 'data' chunk-type */
+    0,   0,   0,   0,	/* 40: 'data' chunk-length */
+};
+
+static void *waveout_dsp_create(const void *flags)
+{
+  const struct sysdep_dsp_create_params *params;
+  struct sysdep_dsp_struct *dsp;
+  struct waveout_dsp_priv_data *priv;
+  unsigned char *header;
+  unsigned long tmp;
+
+  params = flags;
+
+  /* Allocate DSP structure */
+  if (!(dsp = calloc(1, sizeof(struct sysdep_dsp_struct))))
+  {
+    fprintf(stderr, "error: failed to malloc struct sysdep_dsp_struct\n");
+    return NULL;
+  }
+
+  /* Allocate private storage */
+  if (!(priv = calloc(1, sizeof(struct waveout_dsp_priv_data))))
+  {
+    fprintf(stderr, "error: failed to malloc struct waveout_dsp_priv_data\n");
+    free(dsp);
+    return NULL;
+  }
+
+  /* Allocate temporary storage for RIFF WAVE header */
+  if (!(header = malloc(44)))
+  {
+    fprintf(stderr, "error: failed to malloc WAVE header storage\n");
+    free(priv);
+    free(dsp);
+    return NULL;
+  }
+
+  /* Fill in DSP structure */
+  dsp->hw_info.type = params->type;
+  dsp->hw_info.samplerate = params->samplerate;
+  dsp->write = waveout_dsp_write;
+  dsp->destroy = waveout_dsp_destroy;
+  dsp->_priv = priv;
+
+  /* Fill in private storage */
+  priv->name = params->device;
+  if (!priv->name)
+    priv->name = "xmameout.wav";
+
+  /* Compute RIFF WAVE header */
+  memcpy(header, wave_template, 44);
+  tmp = dsp->hw_info.samplerate;
+  if (dsp->hw_info.type & SYSDEP_DSP_STEREO)
+    header[22] = 2;
+  header[24] = (unsigned char)tmp;
+  header[25] = (unsigned char)(tmp >>  8);
+  header[26] = (unsigned char)(tmp >> 16);
+  header[27] = (unsigned char)(tmp >> 24);
+  tmp *= waveout_dsp_bytes_per_sample[dsp->hw_info.type];
+  header[28] = (unsigned char)tmp;
+  header[29] = (unsigned char)(tmp >>  8);
+  header[30] = (unsigned char)(tmp >> 16);
+  header[31] = (unsigned char)(tmp >> 24);
+  header[32] = waveout_dsp_bytes_per_sample[dsp->hw_info.type];
+  if (dsp->hw_info.type & SYSDEP_DSP_16BIT)
+    header[34] = 16;
+
+  /* Open output file */
+  if (!(priv->file = fopen(priv->name, "wb")))
+  {
+    fprintf(stderr, "error: failed to open \"%s\" for writing: %s\n", priv->name, strerror(errno));
+    free(header);
+    free(priv);
+    free(dsp);
+    return NULL;
+  }
+
+  /* Write computed header to disk */
+  if (fwrite(header, 1, 44, priv->file) != 44)
+  {
+    fprintf(stderr, "error: failed to write WAVE header to \"%s\": %s\n", priv->name, strerror(errno));
+    fclose(priv->file);
+    free(header);
+    free(priv);
+    free(dsp);
+  }
+
+  /* Free the header */
+  free(header);
+
+  fprintf(stderr, "info: Writing sound output to file \"%s\" in %dHz/%d/%c PCM format\n",
+  	priv->name,
+  	dsp->hw_info.samplerate,
+  	(dsp->hw_info.type & SYSDEP_DSP_16BIT) ? 16 : 8,
+  	(dsp->hw_info.type & SYSDEP_DSP_STEREO) ? 'S' : 'M'
+  );
+
+  return dsp;
+}
+
+static void waveout_dsp_destroy(struct sysdep_dsp_struct *dsp)
+{
+  struct waveout_dsp_priv_data *priv = dsp->_priv;
+
+  if (priv)
+  {
+    if (priv->file)
+    {
+      unsigned char tmp[4];
+      long pos;
+
+      /* Find out where we are in the file */
+      pos = ftell(priv->file);
+
+      /* Update the RIFF file length */
+      pos -= 8L;
+      tmp[0] = (unsigned char)pos;
+      tmp[1] = (unsigned char)(pos >>  8);
+      tmp[2] = (unsigned char)(pos >> 16);
+      tmp[3] = (unsigned char)(pos >> 24);
+      fseek(priv->file, 4L, SEEK_SET);
+      fwrite(tmp, 4, 1, priv->file);
+
+      /* Update the data chunk length */
+      pos -= 36L;
+      tmp[0] = (unsigned char)pos;
+      tmp[1] = (unsigned char)(pos >>  8);
+      tmp[2] = (unsigned char)(pos >> 16);
+      tmp[3] = (unsigned char)(pos >> 24);
+      fseek(priv->file, 40L, SEEK_SET);
+      fwrite(tmp, 4, 1, priv->file);
+
+      /* All done, so close the file */
+      fclose(priv->file);
+    }
+    free(priv);
+  }
+  free(dsp);
+}
+
+static int waveout_dsp_write(struct sysdep_dsp_struct *dsp, unsigned char *data, int count)
+{
+  if(count > 0)
+  {
+    struct waveout_dsp_priv_data *priv;
+    size_t result;
+
+    priv = dsp->_priv;
+
+    /* FIXME: This produces invalid PCM WAVE files on big-endian systems */
+    result = fwrite(data, waveout_dsp_bytes_per_sample[dsp->hw_info.type], count, priv->file);
+
+    if (result != count)
+      fprintf(stderr, "error: failed to write %d samples to \"%s\": %s\n", count, priv->name, strerror(errno));
+    return result;
+  }
+  return -1;
+}
+
+#endif /* SYSDEP_DSP_WAVEOUT */
diff --git a/src/unix/sysdep/end_code.h b/src/unix/sysdep/end_code.h
new file mode 100644
index 0000000..e28c8e7
--- /dev/null
+++ b/src/unix/sysdep/end_code.h
@@ -0,0 +1,22 @@
+/* A few simple include macros
+
+   Copyright 1999,2000 Hans de Goede
+   
+   This file and the acompanying files in this directory are free software;
+   you can redistribute them and/or modify them under the terms of the GNU
+   Library General Public License as published by the Free Software Foundation;
+   either version 2 of the License, or (at your option) any later version.
+
+   These files are distributed in the hope that they will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with these files; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.
+*/
+#ifdef __cplusplus
+}
+#endif
diff --git a/src/unix/sysdep/fifo.h b/src/unix/sysdep/fifo.h
new file mode 100644
index 0000000..1d13209
--- /dev/null
+++ b/src/unix/sysdep/fifo.h
@@ -0,0 +1,160 @@
+/* Generic fifo implemented through defines
+
+   Copyright 2000 Hans de Goede
+   
+   This file and the acompanying files in this directory are free software;
+   you can redistribute them and/or modify them under the terms of the GNU
+   Library General Public License as published by the Free Software Foundation;
+   either version 2 of the License, or (at your option) any later version.
+
+   These files are distributed in the hope that they will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with these files; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.
+*/
+/* Changelog
+Version 0.1, March 2000
+-initial release (Hans de Goede)
+*/
+#ifndef __FIFO_H
+#define __FIFO_H
+
+#define FIFO(PREFIX,NAME,TYPE)						\
+   FIFO_PROTOTYPES(PREFIX,NAME,TYPE)					\
+   FIFO_STRUCT(PREFIX,NAME,TYPE)					\
+   FIFO_CREATE(PREFIX,NAME,TYPE)					\
+   FIFO_DESTROY(PREFIX,NAME,TYPE)					\
+   FIFO_PUT(PREFIX,NAME,TYPE)						\
+   FIFO_GET(PREFIX,NAME,TYPE)						\
+   FIFO_PEEK(PREFIX,NAME,TYPE)						\
+   FIFO_EMPTY(PREFIX,NAME,TYPE)						\
+   FIFO_GET_FREESPACE(PREFIX,NAME,TYPE)					\
+   FIFO_IN_USE(PREFIX,NAME,TYPE)
+
+#define FIFO_PROTOTYPES(PREFIX,NAME,TYPE)				\
+   struct NAME ## _fifo_struct;						\
+   PREFIX struct NAME ## _fifo_struct * NAME ## _fifo_create(int size);	\
+   PREFIX void NAME ## _fifo_destroy(struct NAME ## _fifo_struct	\
+      *fifo);								\
+   PREFIX int NAME ## _fifo_put(struct NAME ## _fifo_struct *fifo,	\
+      TYPE data);							\
+   PREFIX int NAME ## _fifo_get(struct NAME ## _fifo_struct *fifo,	\
+      TYPE *data);							\
+   PREFIX int NAME ## _fifo_peek(struct NAME ## _fifo_struct *fifo,	\
+      TYPE *data);							\
+   PREFIX void NAME ## _fifo_empty(struct NAME ## _fifo_struct *fifo);	\
+   PREFIX int NAME ## _fifo_in_use(struct NAME ## _fifo_struct *fifo);	\
+   PREFIX int NAME ## _fifo_get_freespace(struct NAME ## _fifo_struct 	\
+      *fifo);
+
+#define FIFO_STRUCT(PREFIX,NAME,TYPE)					\
+   struct NAME ## _fifo_struct {					\
+      int size;								\
+      int head;								\
+      int in_use;							\
+      TYPE *buffer;							\
+   };
+
+#define FIFO_CREATE(PREFIX,NAME,TYPE)					\
+   PREFIX struct NAME ## _fifo_struct * NAME ## _fifo_create(int size)	\
+   {									\
+      struct NAME ## _fifo_struct *fifo = NULL;				\
+      									\
+      /* allocate the fifo struct */					\
+      if(!(fifo = calloc(1, sizeof(struct NAME ## _fifo_struct))))	\
+      {									\
+         fprintf(stderr,						\
+            "error malloc failed for struct xxx_fifo_struct\n");	\
+         return NULL;							\
+      }									\
+      									\
+      /* allocate the buffer */						\
+      if(!(fifo->buffer = calloc(size, sizeof(TYPE))))			\
+      {									\
+         fprintf(stderr,						\
+            "error malloc failed for xxx_fifo buffer\n");		\
+         NAME ## _fifo_destroy(fifo);					\
+         return NULL;							\
+      }									\
+     									\
+      fifo->size = size;						\
+     									\
+      return fifo;							\
+   }
+
+#define FIFO_DESTROY(PREFIX,NAME,TYPE)					\
+   PREFIX void NAME ## _fifo_destroy(struct NAME ## _fifo_struct *fifo)	\
+   {									\
+      if(fifo->buffer)							\
+         free(fifo->buffer);						\
+      									\
+      free(fifo);							\
+   }
+   
+#define FIFO_PUT(PREFIX,NAME,TYPE)					\
+   PREFIX int NAME ## _fifo_put(struct NAME ## _fifo_struct *fifo,	\
+      TYPE data)							\
+   {									\
+      int tail;								\
+      									\
+      if(fifo->in_use == fifo->size)					\
+         return -1;							\
+      									\
+      tail = (fifo->head + fifo->in_use) % fifo->size;			\
+      fifo->buffer[tail] = data;					\
+      fifo->in_use++;							\
+      									\
+      return 0;								\
+   }
+
+#define FIFO_GET(PREFIX,NAME,TYPE)					\
+   PREFIX int NAME ## _fifo_get(struct NAME ## _fifo_struct *fifo,	\
+      TYPE *data)							\
+   {									\
+      if(!fifo->in_use)							\
+         return -1;							\
+      									\
+      *data = fifo->buffer[fifo->head];					\
+      fifo->head = (fifo->head + 1) % fifo->size;			\
+      fifo->in_use--;							\
+      									\
+      return 0;								\
+   }
+
+#define FIFO_PEEK(PREFIX,NAME,TYPE)					\
+   PREFIX int NAME ## _fifo_peek(struct NAME ## _fifo_struct *fifo,	\
+      TYPE *data)							\
+   {									\
+      if(!fifo->in_use)							\
+         return -1;							\
+      									\
+      *data = fifo->buffer[fifo->head];					\
+      									\
+      return 0;								\
+   }
+
+#define FIFO_EMPTY(PREFIX,NAME,TYPE)					\
+   PREFIX void NAME ## _fifo_empty(struct NAME ## _fifo_struct *fifo)	\
+   {									\
+      fifo->head = fifo->in_use = 0;					\
+   }
+
+#define FIFO_IN_USE(PREFIX,NAME,TYPE)					\
+   PREFIX int NAME ## _fifo_in_use(struct NAME ## _fifo_struct *fifo)	\
+   {									\
+      return fifo->in_use;						\
+   }
+
+#define FIFO_GET_FREESPACE(PREFIX,NAME,TYPE)				\
+   PREFIX int NAME ## _fifo_get_freespace(struct NAME ## _fifo_struct	\
+      *fifo)								\
+   {									\
+      return fifo->size - fifo->in_use;					\
+   }
+
+#endif /* ifndef __FIFO_H */
diff --git a/src/unix/sysdep/misc.c b/src/unix/sysdep/misc.c
new file mode 100644
index 0000000..213cfd8
--- /dev/null
+++ b/src/unix/sysdep/misc.c
@@ -0,0 +1,143 @@
+/* Miscelancelous utility functions
+
+   Copyright 2000 Hans de Goede
+   
+   This file and the acompanying files in this directory are free software;
+   you can redistribute them and/or modify them under the terms of the GNU
+   Library General Public License as published by the Free Software Foundation;
+   either version 2 of the License, or (at your option) any later version.
+
+   These files are distributed in the hope that they will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with these files; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.
+*/
+/* Changelog
+Version 0.1, February 2000
+-initial release (Hans de Goede)
+Version 0.2, May 2000
+-moved time system headers from .h to .c to avoid header conflicts (Hans de Goede)
+-made uclock a funtion on systems without gettimeofday too (Hans de Goede) 
+-UCLOCKS_PER_SECOND is now always 1000000, instead of making it depent on
+ the system headers. (Hans de Goede)
+*/
+/* Todo ?
+-rename uclock to sysdep_clock (Hans de Goede)
+*/
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <time.h>
+#include <sys/time.h>
+#include "misc.h"
+
+
+#ifdef HAVE_GETTIMEOFDAY
+/* Standard UNIX clock() is based on CPU time, not real time.
+   Here is a real-time drop in replacement for UNIX systems that have the
+   gettimeofday() routine.  This results in much more accurate timing.
+*/
+uclock_t uclock(void)
+{
+  static uclock_t init_sec = 0;
+  struct timeval tv;
+  
+  gettimeofday(&tv, 0);
+  if (init_sec == 0) init_sec = tv.tv_sec;
+  
+  return (tv.tv_sec - init_sec) * 1000000 + tv.tv_usec;
+}
+#else
+
+/* some platforms don't define CLOCKS_PER_SEC, according to posix it should
+   always be 1000000, so asume that's the case if it is not defined,
+   except for openstep which doesn't define it and has it at 64 */
+#ifndef CLOCKS_PER_SEC
+#ifdef openstep
+#define CLOCKS_PER_SEC 64     /* this is correct for OS4.2 intel */
+#else
+#define CLOCKS_PER_SEC 1000000
+#endif
+#endif
+
+uclock_t uclock(void)
+{
+   return (clock() * (1000000 / CLOCKS_PER_SEC));
+}
+
+#endif
+
+void print_columns(const char *text1, const char *text2)
+{
+   fprint_columns(stdout, text1, text2);
+}
+
+void fprint_columns(FILE *f, const char *text1, const char *text2)
+{
+   const char *text[2];
+   int i, j, cols, width[2], done = 0;
+   char *e_cols = getenv("COLUMNS");
+
+   cols = e_cols? atoi(e_cols):80;
+   if ( cols < 6 ) cols = 6;  /* minimum must be 6 */
+   cols--;
+
+   /* initialize our arrays */
+   text[0] = text1;
+   text[1] = text2;
+   width[0] = cols * 0.4;
+   width[1] = cols - width[0];
+   
+   while(!done)
+   {
+      done = 1;
+      for(i = 0; i < 2; i++)
+      {
+         int to_print = width[i]-1; /* always leave one space open */
+         
+         /* we don't want to print more then we have */
+         j = strlen(text[i]);
+         if (to_print > j)
+           to_print = j;
+            
+         /* if they have preffered breaks, try to give them to them */
+         for(j=0; j<to_print; j++)
+            if(text[i][j] == '\n')
+            {
+               to_print = j;
+               break;
+            }
+         
+         /* if we don't have enough space, break at the first ' ' or '\n' */
+         if(to_print < strlen(text[i]))
+         {
+           while(to_print && (text[i][to_print] != ' ') &&
+              (text[i][to_print] != '\n'))
+              to_print--;
+           
+           /* if it didn't work, just print the columnwidth */
+           if(!to_print)
+              to_print = width[i]-1;
+         }
+         fprintf(f, "%-*.*s", width[i], to_print, text[i]);
+         
+         /* adjust ptr */
+         text[i] += to_print;
+         
+         /* skip ' ' and '\n' */
+         while((text[i][0] == ' ') || (text[i][0] == '\n'))
+            text[i]++;
+         
+         /* do we still have text to print */
+         if(text[i][0])
+            done = 0;
+      }
+      fprintf(f, "\n");
+   }
+}
diff --git a/src/unix/sysdep/misc.h b/src/unix/sysdep/misc.h
new file mode 100644
index 0000000..118c362
--- /dev/null
+++ b/src/unix/sysdep/misc.h
@@ -0,0 +1,42 @@
+/* Miscellaneous utility functions
+
+   Copyright 2000 Hans de Goede
+   
+   This file and the accompanying files in this directory are free software;
+   you can redistribute them and/or modify them under the terms of the GNU
+   Library General Public License as published by the Free Software Foundation;
+   either version 2 of the License, or (at your option) any later version.
+
+   These files are distributed in the hope that they will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with these files; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.
+*/
+#ifndef __MISC_H
+#define __MISC_H
+#include <stdio.h>
+#include "begin_code.h"
+
+#ifdef __BEOS__
+#include <OS.h>
+/* BeOS doesn't have the "usleep()" function. It has the "snooze()"
+   one which sleeps in microseconds, not milliseconds. */
+#define usleep(x) snooze((x)/1000)
+#endif
+
+/* clock stuff */
+typedef long uclock_t;
+uclock_t uclock(void);
+#define UCLOCKS_PER_SEC 1000000
+
+/* print colum stuff */
+void print_columns(const char *text1, const char *text2);
+void fprint_columns(FILE *f, const char *text1, const char *text2);
+
+#include "end_code.h"
+#endif /* ifndef __MISC_H */
diff --git a/src/unix/sysdep/mixer-drivers/oss.c b/src/unix/sysdep/mixer-drivers/oss.c
new file mode 100644
index 0000000..0b27cdb
--- /dev/null
+++ b/src/unix/sysdep/mixer-drivers/oss.c
@@ -0,0 +1,183 @@
+/* Sysdep Open Sound System sound mixer driver
+
+   Copyright 2000 Hans de Goede
+   
+   This file and the acompanying files in this directory are free software;
+   you can redistribute them and/or modify them under the terms of the GNU
+   Library General Public License as published by the Free Software Foundation;
+   either version 2 of the License, or (at your option) any later version.
+
+   These files are distributed in the hope that they will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with these files; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.
+*/
+/* Changelog
+Version 0.1, January 2000
+-initial release (Hans de Goede)
+*/
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <sys/ioctl.h>
+#if defined (__ARCH_openbsd)
+#include <soundcard.h>
+#else
+#include <sys/soundcard.h>
+#endif
+#include "sysdep/sysdep_mixer.h"
+#include "sysdep/sysdep_mixer_priv.h"
+#include "sysdep/plugin_manager.h"
+
+/* our per instance private data struct */
+struct oss_mixer_priv_data {
+   int fd;
+};
+
+/* public methods prototypes (static but exported through the sysdep_mixer or
+   plugin struct) */
+static void *oss_mixer_create(const void *flags);
+static void oss_mixer_destroy(struct sysdep_mixer_struct *mixer);
+static int oss_mixer_set(struct sysdep_mixer_struct *mixer,
+   int channel, int left, int right);
+static int oss_mixer_get(struct sysdep_mixer_struct *mixer,
+   int channel, int *left, int *right);
+   
+/* private variables */
+const int oss_mixer_sysdep_to_oss[] = {
+   SOUND_MIXER_VOLUME, /* SYSDEP_MIXER_VOLUME */
+   SOUND_MIXER_PCM,    /* SYSDEP_MIXER_PCM1 */
+   SOUND_MIXER_ALTPCM, /* SYSDEP_MIXER_PCM2 */
+   SOUND_MIXER_SYNTH,  /* SYSDEP_MIXER_SYNTH */
+   SOUND_MIXER_CD,     /* SYSDEP_MIXER_CD */
+   SOUND_MIXER_LINE,   /* SYSDEP_MIXER_LINE1 */
+   SOUND_MIXER_LINE1,  /* SYSDEP_MIXER_LINE2 */
+   SOUND_MIXER_LINE2,  /* SYSDEP_MIXER_LINE3 */
+   SOUND_MIXER_BASS,   /* SYSDEP_MIXER_BASS */
+   SOUND_MIXER_TREBLE, /* SYSDEP_MIXER_TREBLE */
+};
+
+/* public variables */
+const struct plugin_struct sysdep_mixer_oss = {
+   "oss",
+   "sysdep_mixer",
+   "Open Sound System mixer plugin",
+   NULL, /* no options */
+   NULL, /* no init */
+   NULL, /* no exit */
+   oss_mixer_create,
+   3     /* high priority */
+};
+
+/* public methods (static but exported through the sysdep_mixer or plugin
+   struct) */
+static void *oss_mixer_create(const void *flags)
+{
+   int i, j;
+   struct oss_mixer_priv_data *priv = NULL;
+   struct sysdep_mixer_struct *mixer = NULL;
+   const struct sysdep_mixer_create_params *params = flags;
+   const char *device = params->device;
+   
+   /* allocate the mixer struct */
+   if (!(mixer = calloc(1, sizeof(struct sysdep_mixer_struct))))
+   {
+      fprintf(stderr,
+         "error malloc failed for struct sysdep_mixer_struct\n");
+      return NULL;
+   }
+   
+   /* alloc private data */
+   if(!(priv = calloc(1, sizeof(struct oss_mixer_priv_data))))
+   {
+      fprintf(stderr,
+         "error malloc failed for struct oss_mixer_priv_data\n");
+      oss_mixer_destroy(mixer);
+      return NULL;
+   }
+   
+   /* fill in the functions and some data */
+   priv->fd = -1;
+   mixer->_priv = priv;
+   mixer->set = oss_mixer_set;
+   mixer->get = oss_mixer_get;
+   mixer->destroy = oss_mixer_destroy;
+   
+   /* open the mixer device */
+   if (!device)
+      device = "/dev/mixer";
+   
+   if((priv->fd = open(device, O_WRONLY, 0)) < 0) {
+      perror("error: /dev/mixer");
+      oss_mixer_destroy(mixer);
+      return NULL;
+   }
+   
+   /* and check which channels are available */
+   if (ioctl(priv->fd, SOUND_MIXER_READ_DEVMASK, &i))
+   {
+      perror("error: SOUND_MIXER_READ_DEVMASK");
+      oss_mixer_destroy(mixer);
+      return NULL;
+   }
+   for(j=0; j < SYSDEP_MIXER_CHANNELS; j++)
+      if(i & (0x01 << oss_mixer_sysdep_to_oss[j]))
+         mixer->channel_available[j] = 1;
+   
+   return mixer;
+}
+
+static void oss_mixer_destroy(struct sysdep_mixer_struct *mixer)
+{
+   struct oss_mixer_priv_data *priv = mixer->_priv;
+   
+   if(priv)
+   {
+      if(priv->fd >= 0)
+         close(priv->fd);
+      
+      free(priv);
+   }
+   free(mixer);
+}
+   
+static int oss_mixer_set(struct sysdep_mixer_struct *mixer,
+   int channel, int left, int right)
+{
+   int i = left | right << 8;
+   struct oss_mixer_priv_data *priv = mixer->_priv;
+   
+   if(ioctl(priv->fd, MIXER_WRITE(oss_mixer_sysdep_to_oss[channel]), &i))
+   {
+      perror("error: SOUND_MIXER_WRITE");
+      return -1;
+   }
+   return 0;
+}
+
+static int oss_mixer_get(struct sysdep_mixer_struct *mixer,
+   int channel, int *left, int *right)
+{
+   int value;
+   struct oss_mixer_priv_data *priv = mixer->_priv;
+   
+   if(ioctl(priv->fd, MIXER_READ(oss_mixer_sysdep_to_oss[channel]),
+      &value))
+   {
+      perror("error: SOUND_MIXER_READ");
+      return -1;
+   }
+      
+   *left = value & 0xFF;
+   *right = (value >> 8) & 0xFF;
+
+   return 0;
+}
diff --git a/src/unix/sysdep/mixer-drivers/solaris.c b/src/unix/sysdep/mixer-drivers/solaris.c
new file mode 100644
index 0000000..8daf3b4
--- /dev/null
+++ b/src/unix/sysdep/mixer-drivers/solaris.c
@@ -0,0 +1,172 @@
+/* Sysdep Open Sound System sound mixer driver
+
+   Copyright 2000 Hans de Goede, Mathis Rosenhauer
+   
+   This file and the acompanying files in this directory are free software;
+   you can redistribute them and/or modify them under the terms of the GNU
+   Library General Public License as published by the Free Software Foundation;
+   either version 2 of the License, or (at your option) any later version.
+
+   These files are distributed in the hope that they will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with these files; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.
+*/
+/* Changelog
+Version 0.1, February 2000
+-initial release based on oss.c by Hans de Goede (Mathis Rosenhauer)
+*/
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <sys/ioctl.h>
+#include <sys/stropts.h>
+#include <sys/audioio.h>
+#include "sysdep/sysdep_mixer.h"
+#include "sysdep/sysdep_mixer_priv.h"
+#include "sysdep/plugin_manager.h"
+
+/* our per instance private data struct */
+struct sol_mixer_priv_data {
+	int fd;
+};
+
+/* public methods prototypes (static but exported through the sysdep_mixer or
+   plugin struct) */
+static void *sol_mixer_create(const void *flags);
+static void sol_mixer_destroy(struct sysdep_mixer_struct *mixer);
+static int sol_mixer_set(struct sysdep_mixer_struct *mixer,
+						 int channel, int left, int right);
+static int sol_mixer_get(struct sysdep_mixer_struct *mixer,
+						 int channel, int *left, int *right);
+   
+/* public variables */
+const struct plugin_struct sysdep_mixer_solaris = {
+	"solaris",
+	"sysdep_mixer",
+	"Solaris mixer plugin",
+	NULL, /* no options */
+	NULL, /* no init */
+	NULL, /* no exit */
+	sol_mixer_create,
+	3	  /* high priority */
+};
+
+/* public methods (static but exported through the sysdep_mixer or plugin
+   struct) */
+static void *sol_mixer_create(const void *flags)
+{
+	struct sol_mixer_priv_data *priv = NULL;
+	struct sysdep_mixer_struct *mixer = NULL;
+	const struct sysdep_mixer_create_params *params = flags;
+	const char *device = params->device;
+   
+	/* allocate the mixer struct */
+	if (!(mixer = calloc(1, sizeof(struct sysdep_mixer_struct))))
+	{
+		perror("error malloc failed for struct sysdep_mixer_struct\n");
+		return NULL;
+	}
+   
+	/* alloc private data */
+	if(!(priv = calloc(1, sizeof(struct sol_mixer_priv_data))))
+	{
+		perror("error malloc failed for struct sol_mixer_priv_data\n");
+		sol_mixer_destroy(mixer);
+		return NULL;
+	}
+   
+	/* fill in the functions and some data */
+	priv->fd = -1;
+	mixer->_priv = priv;
+	mixer->set = sol_mixer_set;
+	mixer->get = sol_mixer_get;
+	mixer->destroy = sol_mixer_destroy;
+   
+	/* open the mixer device */
+	if (!device)
+		device = getenv("AUDIODEV");
+	if (!device)
+		device = "/dev/audioctl";
+   
+	if((priv->fd = open(device, O_RDWR)) < 0) {
+		fprintf(stderr, "error: opening %s\n", device);
+		sol_mixer_destroy(mixer);
+		return NULL;
+	}
+   
+	/* are there more channels on other hardware as dbri? */
+	mixer->channel_available[SYSDEP_MIXER_PCM1] = 1;
+	return mixer;
+}
+
+static void sol_mixer_destroy(struct sysdep_mixer_struct *mixer)
+{
+	struct sol_mixer_priv_data *priv = mixer->_priv;
+   
+	if(priv)
+	{
+		if(priv->fd >= 0)
+			close(priv->fd);
+	  
+		free(priv);
+	}
+	free(mixer);
+}
+   
+static int sol_mixer_set(struct sysdep_mixer_struct *mixer, int channel, int left, int right)
+{
+	audio_info_t info;
+	struct sol_mixer_priv_data *priv = mixer->_priv;
+	int maxvol = (left > right)? left: right;
+
+	AUDIO_INITINFO(&info);
+
+	info.play.gain = (maxvol * (AUDIO_MAX_GAIN - AUDIO_MIN_GAIN)) / 100 + AUDIO_MIN_GAIN;
+	if (maxvol)
+	{
+		info.play.balance = (right - left) * (AUDIO_RIGHT_BALANCE - AUDIO_LEFT_BALANCE);
+		info.play.balance /= 2 * maxvol;
+		info.play.balance += AUDIO_MID_BALANCE;
+	}
+
+	if (ioctl(priv->fd, AUDIO_SETINFO, &info) < 0)
+	{
+		perror("error: AUDIO_SETINFO\n");
+		return -1;
+	}
+	return 0;
+}
+
+static int sol_mixer_get(struct sysdep_mixer_struct *mixer, int channel, int *left, int *right)
+{
+	audio_info_t info;
+	struct sol_mixer_priv_data *priv = mixer->_priv;
+
+	if (ioctl(priv->fd, AUDIO_GETINFO, &info) < 0)
+	{
+		perror("error: AUDIO_GETINFO\n");
+		return -1;
+	}
+	
+	if (info.play.balance > AUDIO_MID_BALANCE)
+	{
+		*right = ((info.play.gain - AUDIO_MIN_GAIN) * 100) / (AUDIO_MAX_GAIN - AUDIO_MIN_GAIN);
+		*left = *right * ((AUDIO_RIGHT_BALANCE - (float)info.play.balance) / AUDIO_MID_BALANCE);
+	}
+	else
+	{
+		*left = ((info.play.gain - AUDIO_MIN_GAIN) * 100) / (AUDIO_MAX_GAIN - AUDIO_MIN_GAIN);
+		*right = *left * ((float)info.play.balance / AUDIO_MID_BALANCE);
+	}
+	return 0;
+}
+
diff --git a/src/unix/sysdep/plugin_manager.c b/src/unix/sysdep/plugin_manager.c
new file mode 100644
index 0000000..da34e37
--- /dev/null
+++ b/src/unix/sysdep/plugin_manager.c
@@ -0,0 +1,247 @@
+/* A simple plugin manager
+
+   Copyright 2000 Hans de Goede
+   
+   This file and the acompanying files in this directory are free software;
+   you can redistribute them and/or modify them under the terms of the GNU
+   Library General Public License as published by the Free Software Foundation;
+   either version 2 of the License, or (at your option) any later version.
+
+   These files are distributed in the hope that they will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with these files; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.
+*/
+/* Changelog
+Version 0.1, January 2000
+-initial release (Hans de Goede)
+*/
+#include <stdlib.h>
+#include <string.h>
+#include "plugin_manager.h"
+#include "plugin_manager_priv.h"
+#include "misc.h"
+
+/* private methods */
+static int plugin_manager_add(struct plugin_manager_struct *manager,
+   struct plugin_manager_data *data)
+{
+   int i;
+   
+   /* does the plugin have the correct type? */
+   if(strcmp(data->plugin->type, manager->type))
+   {
+      fprintf(stderr,
+         "error: trying to add \"%s\" type plugin, to \"%s\" type plugin manager\n",
+         data->plugin->type, manager->type);
+      return -1;
+   }
+   
+   for(i=0; i < manager->data_size; i++)
+      if(!manager->data[i].plugin)
+         break;
+         
+   if(i == manager->data_size)
+   {
+      struct plugin_manager_data *tmp;
+      
+      if(!(tmp=realloc(manager->data, (manager->data_size+BUF_SIZE) *
+         sizeof(struct plugin_manager_data))))
+      {
+         fprintf(stderr, "error reallocating plugin data\n");
+         return -1;
+      }
+      manager->data = tmp;
+      memset(manager->data + manager->data_size, 0,
+         sizeof(struct plugin_manager_data) * BUF_SIZE);
+      manager->data_size += BUF_SIZE;
+   }
+   
+   if (manager->rc && data->plugin->opts &&
+      rc_register(manager->rc, data->plugin->opts))
+      return -1;
+   
+   if (data->plugin->priority > manager->highest_priority)
+      manager->highest_priority = data->plugin->priority;
+   
+   manager->data[i] = *data;
+
+   return 0;
+}
+
+static void plugin_manager_remove(struct plugin_manager_struct *manager,
+   int id)
+{
+   if(manager->rc && manager->data[id].plugin->opts)
+      rc_unregister(manager->rc, manager->data[id].plugin->opts);
+      
+   if(manager->data[id].initialised && manager->data[id].plugin->exit)
+      manager->data[id].plugin->exit();
+   
+   if(manager->data[id].plugin_handle)
+   {
+      /* TODO implement dlclose */
+   }
+   memset(manager->data + id, 0, sizeof(struct plugin_manager_data));
+}
+
+/* public methods (in plugin_manager.h) */
+struct plugin_manager_struct *plugin_manager_create(const char *type,
+   struct rc_struct *rc)
+{
+   struct plugin_manager_struct *manager = NULL;
+   
+   /* allocate the plugin_manager struct */
+   if (!(manager = calloc(1, sizeof(struct plugin_manager_struct))))
+   {
+      fprintf(stderr,
+         "error malloc failed for struct plugin_manager_struct\n");
+      return NULL;
+   }
+   manager->type = type;
+   manager->rc   = rc;
+   return manager;
+}
+
+void plugin_manager_destroy(struct plugin_manager_struct *manager)
+{
+   plugin_manager_unload(manager, NULL);
+   free(manager);
+}
+
+int plugin_manager_register(struct plugin_manager_struct *manager,
+   const struct plugin_struct *plugin[])
+{
+   int i;
+   struct plugin_manager_data data = { NULL, NULL, 0 };
+   
+   for(i=0; plugin[i]; i++)
+   {
+      data.plugin = plugin[i];
+      if(plugin_manager_add(manager, &data))
+         return -1;
+   }
+   return 0;
+}
+
+void plugin_manager_unregister(struct plugin_manager_struct *manager,
+   const struct plugin_struct *plugin[])
+{
+   int i, j;
+   
+   /* remove all */
+   if (!plugin)
+   {
+      plugin_manager_unload(manager, NULL);
+      return;
+   }
+      
+   for(i=0; plugin[i]; i++)
+   {
+      for(j=0; j < manager->data_size; j++)
+      {
+         if(manager->data[j].plugin == plugin[i])
+         {
+            plugin_manager_remove(manager, j);
+            break;
+         }
+      }
+   }
+}
+
+int plugin_manager_load(struct plugin_manager_struct *manager,
+   const char *path, const char *name)
+{
+   /* TODO: implement me */
+   return 0;
+}
+
+void plugin_manager_unload(struct plugin_manager_struct *manager,
+   const char *name)
+{
+   int i;
+   
+   for(i=0; i < manager->data_size; i++)
+   {
+      if(manager->data[i].plugin &&
+         (!name || !strcmp(name, manager->data[i].plugin->name)))
+      {
+         plugin_manager_remove(manager, i);
+      }
+   }
+}
+
+static void *plugin_manager_init_and_or_create(
+   struct plugin_manager_struct *manager, const char *name, int load,
+   void *flags)
+{
+   int i, priority;
+   void *result = NULL;
+
+   for(priority=manager->highest_priority; priority>=0; priority--)
+   {
+      for(i=0; i<manager->data_size; i++)
+      {
+         if(manager->data[i].plugin &&
+            (manager->data[i].plugin->priority == priority) &&
+            (!name || !strcmp(name, manager->data[i].plugin->name)) )
+         {
+            if(!manager->data[i].initialised &&
+               manager->data[i].plugin->init &&
+               manager->data[i].plugin->init())
+            {  /* init failed */
+               plugin_manager_remove(manager, i);
+               continue;
+            }
+            /* no init needed, or init successfull */
+            manager->data[i].initialised = 1;
+            if (load)
+            {
+               if((result = manager->data[i].plugin->create(flags)))
+               {
+                  /* if no name was given tell them which plugin we're
+                     using */
+                  if(!name)
+                     fprintf(stderr, "info: %s: using %s plugin\n",
+                        manager->type, manager->data[i].plugin->name);
+                  return result;
+               }
+            }
+            else
+               result = (void *)-1;
+         }
+      }
+   }
+   return result;
+}
+
+int plugin_manager_init_plugin(struct plugin_manager_struct *manager,
+   const char *name)
+{
+   if(!plugin_manager_init_and_or_create(manager, name, 0, NULL))
+      return -1;
+
+   return 0;
+}
+
+void *plugin_manager_create_instance(struct plugin_manager_struct *manager,
+   const char *name, void *flags)
+{
+   return plugin_manager_init_and_or_create(manager, name, 1, flags);
+}
+
+void plugin_manager_list_plugins(struct plugin_manager_struct *manager,
+   FILE *f)
+{
+   int i;
+   
+   for(i=0; i < manager->data_size; i++)
+      if(manager->data[i].plugin)
+         fprint_columns(f, manager->data[i].plugin->name,
+            manager->data[i].plugin->description);
+}
diff --git a/src/unix/sysdep/plugin_manager.h b/src/unix/sysdep/plugin_manager.h
new file mode 100644
index 0000000..2c47e97
--- /dev/null
+++ b/src/unix/sysdep/plugin_manager.h
@@ -0,0 +1,103 @@
+/* A simple plugin manager
+
+   Copyright 2000 Hans de Goede
+   
+   This file and the acompanying files in this directory are free software;
+   you can redistribute them and/or modify them under the terms of the GNU
+   Library General Public License as published by the Free Software Foundation;
+   either version 2 of the License, or (at your option) any later version.
+
+   These files are distributed in the hope that they will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with these files; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.
+*/
+#ifndef __PLUGIN_MANAGER_H
+#define __PLUGIN_MANAGER_H
+#include <stdio.h>
+#include "rc.h"
+#include "begin_code.h"
+
+struct plugin_struct
+{
+   const char *name;             /* name of plugin */
+   const char *type;             /* type of plugin */
+   const char *description;      /* description of plugin */
+   struct rc_option *opts;       /* options for this plugin */
+   int (*init)(void);            /* f-ptr which inits the plugin if nescesarry
+                                    */
+   void (*exit)(void);           /* cleans up before unloading */
+   void *(*create)(const void *flags);
+                                 /* creates an instance of the object
+                                    associated with the type of pluging we're
+                                    managing.
+                                    The plugin system has no knowledge of this
+                                    object, but the object which uses the
+                                    plugin system should have knowledge about
+                                    it. */
+   int priority;                 /* higher priority plugins are checked first
+                                    when checking multiple plugins. (for
+                                    auto plugin selection for example) */
+};
+
+struct plugin_manager_struct;
+
+/* Creates a plugin manager struct, doesn't do much else */
+struct plugin_manager_struct *plugin_manager_create(const char *type,
+   struct rc_struct *rc);
+
+/* Free all data, unload all plugins etc */
+void plugin_manager_destroy(struct plugin_manager_struct *manager);
+
+/* Register the NULL ptr terminated list of plugins, mainly usefull,
+   to register static plugins. */
+int plugin_manager_register(struct plugin_manager_struct *manager,
+   const struct plugin_struct *plugin[]);
+
+/* Unregister (and if not static unloads) the NULL ptr terminated list of
+   plugins, if plugin == NULL, all plugins are unregistered */
+void plugin_manager_unregister(struct plugin_manager_struct *manager,
+   const struct plugin_struct *plugin[]);
+
+/* Loads plugin(s) from:
+   <path>/<name>.so
+   If name == NULL all plugins in <path> are loaded.
+   
+   Returns:
+   0 if one or more plugins we're successfully loaded -1 otherwise */
+int plugin_manager_load(struct plugin_manager_struct *manager,
+   const char *path, const char *name);
+   
+/* Unloads (if not static) and unregisters plugins matching name, if
+   name == NULL, all plugins are unloaded.
+   If one or more plugins where unloaded successfully 0 is returned,
+   otherwise -1 is returned */
+void plugin_manager_unload(struct plugin_manager_struct *manager,
+   const char *name);
+
+/* Initialises the plugin(s) matching name. If name == NULL all plugins are
+   initialised starting with the ones with the highest priority.
+   If one or more plugins where initialised successfully 0 is returned,
+   otherwise -1 is returned */
+int plugin_manager_init_plugin(struct plugin_manager_struct *manager,
+   const char *name);
+
+/* Creates an instance of the object associated with the type of plugin which
+   is being managed. The instance is created using the plugin matching name,
+   which will first be initialised if nescesarry. If name == NULL all plugins
+   are tried untill the instance has been created, starting with the ones with
+   the highest priority.
+   On success 0 is returned, on failure -1 is returned */
+void *plugin_manager_create_instance(struct plugin_manager_struct *manager,
+   const char *name, void *flags);
+   
+void plugin_manager_list_plugins(struct plugin_manager_struct *manager,
+   FILE *f);
+
+#include "end_code.h"
+#endif /* #ifndef __PLUGIN_MANAGER_H */
diff --git a/src/unix/sysdep/plugin_manager_priv.h b/src/unix/sysdep/plugin_manager_priv.h
new file mode 100644
index 0000000..bbbdd6b
--- /dev/null
+++ b/src/unix/sysdep/plugin_manager_priv.h
@@ -0,0 +1,52 @@
+/* A simple plugin manager
+
+   Copyright 2000 Hans de Goede
+   
+   This file and the acompanying files in this directory are free software;
+   you can redistribute them and/or modify them under the terms of the GNU
+   Library General Public License as published by the Free Software Foundation;
+   either version 2 of the License, or (at your option) any later version.
+
+   These files are distributed in the hope that they will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with these files; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.
+*/
+#ifndef __PLUGIN_MANAGER_PRIV_H
+#define __PLUGIN_MANAGER_PRIV_H
+
+#include "begin_code.h"
+
+struct plugin_manager_data {
+   const struct plugin_struct *plugin; 
+                                 /* the plugin_plugin struct describing
+                                    the plugin, or NULL for a removed plugin */
+   void *plugin_handle;          /* void * for the dynamic linker handles,
+                                    or NULL for static / unloaded plugins */
+   int initialised;              /* is the plugin checked? (plugins
+                                    which fail there check are removed from
+                                    the list */
+};
+
+struct plugin_manager_struct
+{
+   const char *type;             /* type of the plugins which are
+                                    managed by this instance of the plugin
+                                    manager */
+   struct rc_struct *rc;         /* rc object where the options for
+                                    added plugins should be registered */
+   struct plugin_manager_data *data;
+                                 /* array of data for the loaded plugins */
+   int data_size;                /* size of this array, to know when it
+                                    should be reallocated */
+   int highest_priority;         /* keeps count of the highest priority plugin
+                                    added */
+};
+
+#include "end_code.h"
+#endif /* #ifndef __PLUGIN_MANAGER_PRIV_H */
diff --git a/src/unix/sysdep/rc.c b/src/unix/sysdep/rc.c
new file mode 100644
index 0000000..469e2b2
--- /dev/null
+++ b/src/unix/sysdep/rc.c
@@ -0,0 +1,883 @@
+/* A simple rcfile and commandline parsing mechanism
+
+   Copyright 1999,2000 Hans de Goede
+   
+   This file and the acompanying files in this directory are free software;
+   you can redistribute them and/or modify them under the terms of the GNU
+   Library General Public License as published by the Free Software Foundation;
+   either version 2 of the License, or (at your option) any later version.
+
+   These files are distributed in the hope that they will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with these files; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.
+*/
+/* Changelog
+Version 0.1, December 1999
+-Initial release (Hans de Goede)
+Version 0.2, January 2000
+-Fixed priority parsing for booleans (Hans de Goede)
+-Fixed error messages for: "error optionx requires an argument". (Hans de
+ Goede)
+-Fixed --boolean option parsing. (Hans de Goede)
+Version 0.3, Februari 2000
+-Reworked and cleaned up the interface, broke backward compatibility (Hans
+ de Goede)
+*/
+#include <stdlib.h>
+#include <string.h>
+#include <pwd.h>
+#include <unistd.h>
+#include <errno.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include "rc.h"
+#include "rc_priv.h"
+#include "misc.h"
+
+/* private variables */
+static int rc_requires_arg[] = {0, 1, 1, 1, 1, 0, 0, 1, 1, 0, 0 };
+
+/* private methods */
+static int rc_verify(struct rc_option *option, float value)
+{
+   if(option->min == option->max)
+      return 0;
+      
+   if( (value < option->min) || (value > option->max) )
+      return -1;
+
+   return 0;
+}
+
+static int rc_set_defaults(struct rc_option *option)
+{
+   int i;
+
+   /* set the defaults */
+   for(i=0; option[i].type; i++)
+   {
+      if (option[i].type == rc_link)
+      {
+         if(rc_set_defaults(option[i].dest))
+            return -1;
+      }
+      else if (option[i].deflt && rc_set_option3(option+i, option[i].deflt,
+         option[i].priority))
+         return -1;
+   }
+   
+   return 0;
+}
+
+static void rc_free_stuff(struct rc_option *option)
+{
+   int i;
+   
+   for(i=0; option[i].type; i++)
+   {
+      switch (option[i].type)
+      {
+         case rc_link:
+            rc_free_stuff(option[i].dest);
+            break;
+         case rc_string:
+            if(*(char **)option[i].dest)
+               free(*(char **)option[i].dest);
+            break;
+         case rc_file:
+            if(*(FILE **)option[i].dest)
+               fclose(*(FILE **)option[i].dest);
+            break;
+      }
+   }
+}
+
+/* public methods (in rc.h) */
+struct rc_struct *rc_create(void)
+{
+   struct rc_struct *rc = NULL;
+   
+   if(!(rc = calloc(1, sizeof(struct rc_struct))))
+   {
+      fprintf(stderr, "error: malloc failed for: struct rc_struct\n");
+      return NULL;
+   }
+   
+   return rc;
+}
+
+void rc_destroy(struct rc_struct *rc)
+{
+   if(rc->option)
+   {
+      rc_free_stuff(rc->option);
+      free (rc->option);
+   }
+   if(rc->arg)
+      free(rc->arg);
+   free(rc);
+}
+
+int rc_register(struct rc_struct *rc, struct rc_option *option)
+{
+   int i;
+   
+   /* try to find a free entry in our option list */
+   for(i = 0; i < rc->option_size; i++)
+      if(rc->option[i].type <= 0)
+         break;
+
+   /* do we have space to register this option list ? */
+   if(i >= (rc->option_size-1))
+   {
+      struct rc_option *tmp = realloc(rc->option,
+         (rc->option_size + BUF_SIZE) * sizeof(struct rc_option));
+      if (!tmp)
+      {
+         fprintf(stderr, "error: malloc failed in rc_register_option\n");
+         return -1;
+      }
+      rc->option = tmp;
+      memset(rc->option + rc->option_size, 0, BUF_SIZE * 
+         sizeof(struct rc_option));
+      rc->option_size += BUF_SIZE;
+   }
+   
+   /* set the defaults */
+   if(rc_set_defaults(option))
+      return -1;
+   
+   /* register the option */
+   rc->option[i].type = rc_link;
+   rc->option[i].dest = option;
+   
+   return 0;
+}
+
+int rc_unregister(struct rc_struct *rc, struct rc_option *option)
+{
+   int i;
+   
+   /* try to find the entry in our option list, unregister later registered
+      duplicates first */
+   for(i = rc->option_size - 1; i >= 0; i--)
+   {
+      if(rc->option[i].dest == option)
+      {
+         memset(rc->option + i, 0, sizeof(struct rc_option));
+         rc->option[i].type = rc_ignore;
+         return 0;
+      }
+   }
+   
+   return -1;
+}
+
+int rc_load(struct rc_struct *rc, const char *name,
+   int priority, int continue_on_errors)
+{
+   FILE *f;
+   
+   fprintf(stderr, "info: trying to parse: %s\n", name);
+   
+   if (!(f = fopen(name, "r")))
+      return 0;
+      
+   return rc_read(rc, f, name, priority, continue_on_errors);
+}
+   
+int rc_save(struct rc_struct *rc, const char *name, int append)
+{
+   FILE *f;
+   
+   if (!(f = fopen(name, append? "a":"w")))
+      return -1;
+      
+   return rc_write(rc, f, name);
+}
+
+int osd_rc_read(struct rc_struct *rc, mame_file *f, const char *description,
+   int priority, int continue_on_errors)
+{
+   char buf[BUF_SIZE];
+   int line = 0;
+
+   while(mame_fgets(buf, BUF_SIZE, f))
+   {
+      struct rc_option *option;
+      char *name, *tmp, *arg = NULL;
+
+      line ++;
+
+      /* get option name */
+      if(!(name = strtok(buf, " \t\r\n")))
+         continue;
+      if(name[0] == '#')
+         continue;
+
+      /* get complete rest of line */
+      arg = strtok(NULL, "\r\n");
+
+      if (arg)
+      {
+      /* ignore white space */
+      for (; (*arg == '\t' || *arg == ' '); arg++) {}
+
+      /* deal with quotations */
+      if (arg[0] == '"')
+         arg = strtok (arg, "\"");
+      else if (arg[0] == '\'')
+         arg = strtok (arg, "'");
+      else
+         arg = strtok (arg, " \t\r\n");
+      }
+
+      if(!(option = rc_get_option2(rc->option, name)))
+      {
+         fprintf(stderr, "error: unknown option %s, on line %d of file: %s\n",
+            name, line, description);
+      }
+      else if (rc_requires_arg[option->type] && !arg)
+      {
+         fprintf(stderr,
+            "error: %s requires an argument, on line %d of file: %s\n",
+            name, line, description);
+      }
+      else if ( (tmp = strtok(NULL, " \t\r\n")) && (tmp[0] != '#') )
+      {
+         fprintf(stderr,
+            "error: trailing garbage: \"%s\" on line: %d of file: %s\n",
+            tmp, line, description);
+      }
+      else if (!rc_set_option3(option, arg, priority))
+         continue;
+
+      if (continue_on_errors)
+         fprintf(stderr, "   ignoring line\n");
+      else
+         return -1;
+   }
+   return 0;
+}
+
+int rc_read(struct rc_struct *rc, FILE *f, const char *description,
+   int priority, int continue_on_errors)
+{
+   char buf[BUF_SIZE];
+   int line = 0;
+   
+   while(fgets(buf, BUF_SIZE, f))
+   {
+      struct rc_option *option;
+      char *name, *tmp, *arg = NULL;
+      int errin3 = 0;
+      
+      line ++;
+      
+      if(!(name = strtok(buf, " \t\r\n")))
+         continue;
+      if(name[0] == '#')
+         continue;
+         
+      if(!(option = rc_get_option2(rc->option, name)))
+      {
+         fprintf(stderr, "error: %s(%d): unknown option %s",
+            description, line, name);
+      }
+      else if (rc_requires_arg[option->type] &&
+         !(arg = strtok(NULL, " \t\r\n")))
+      {
+         fprintf(stderr,
+            "error: %s(%d): %s requires an argument",
+            description, line, name);
+      }
+      else if ( (tmp = strtok(NULL, " \t\r\n")) && (tmp[0] != '#') )
+      {
+         fprintf(stderr,
+            "error: %s(%d): trailing garbage: \"%s\"",
+            description, line, tmp);
+      }
+      else if (rc_set_option3(option, arg, priority))
+         errin3 = 1;
+      else
+         continue;
+      
+      if (continue_on_errors)
+      {
+         if (errin3)
+            fprintf(stderr, "   ignoring line\n");
+         else
+            fprintf(stderr, ", ignoring line\n");
+      }
+      else
+      {
+         fputc('\n', stderr);
+         return -1;
+      }
+   }
+   return 0;
+}
+
+/* needed to walk the tree */
+static int rc_real_write(struct rc_option *option, FILE *f,
+   const char *description)
+{
+   int i;
+   
+   if (description)
+      fprintf(f, "### %s ###\n", description);   
+   
+   for(i=0; option[i].type; i++)
+   {
+      switch (option[i].type)
+      {
+         case rc_seperator:
+            fprintf(f, "\n### %s ###\n", option[i].name);
+            break;
+         case rc_link:
+            if(rc_real_write(option[i].dest, f, NULL))
+               return -1;
+            break;
+         case rc_string:
+            if(!*(char **)option[i].dest)
+            {
+               fprintf(f, "# %-19s   <NULL> (not set)\n", option[i].name);
+               break;
+            }
+         case rc_bool:
+         case rc_int:
+         case rc_float:
+            fprintf(f, "%-21s   ", option[i].name);
+            switch(option[i].type)
+            {
+               case rc_bool:
+               case rc_int:
+                  fprintf(f, "%d\n", *(int *)option[i].dest);
+                  break;
+               case rc_float:
+                  fprintf(f, "%f\n", *(float *)option[i].dest);
+                  break;
+               case rc_string:
+                  fprintf(f, "%s\n", *(char **)option[i].dest);
+                  break;
+            }
+            break;
+      }
+   }
+   if (description)
+      fprintf(f, "\n");   
+   return 0;
+}
+
+static int real_rc_write(struct rc_option *option, mame_file *f,
+		const char *description)
+{
+	int i;
+
+	if (description)
+		mame_fprintf(f, "### %s ###\n", description);
+
+	for(i=0; option[i].type; i++)
+	{
+		switch (option[i].type)
+		{
+			case rc_seperator:
+				mame_fprintf(f, "\n### %s ###\n", option[i].name);
+				break;
+
+			case rc_link:
+				if (real_rc_write(option[i].dest, f, NULL))
+					return -1;
+				break;
+
+			case rc_string:
+				if(!*(char **)option[i].dest)
+				{
+					mame_fprintf(f, "# %-19s   <NULL> (not set)\n", option[i].name);
+					break;
+				}
+				/* fall through */
+
+			case rc_bool:
+			case rc_int:
+			case rc_float:
+				mame_fprintf(f, "%-21s   ", option[i].name);
+				switch(option[i].type)
+				{
+					case rc_bool:
+					case rc_int:
+						mame_fprintf(f, "%d\n", *(int *)option[i].dest);
+						break;
+					case rc_float:
+						mame_fprintf(f, "%f\n", *(float *)option[i].dest);
+						break;
+					case rc_string:
+						mame_fprintf(f, "%s\n", *(char **)option[i].dest);
+						break;
+				}
+				break;
+		}
+	}
+	if (description)
+		mame_fprintf(f, "\n");
+	return 0;
+}
+
+int osd_rc_write(struct rc_struct *rc, mame_file *f, const char *description)
+{
+	return real_rc_write(rc->option, f, description);
+}
+
+int rc_write(struct rc_struct *rc, FILE *f, const char *description)
+{
+   return rc_real_write(rc->option, f, description);
+}
+
+int rc_parse_commandline(struct rc_struct *rc, int argc, char *argv[],
+   int priority, int (*arg_callback)(char *arg))
+{
+   int i;
+   
+   for(i=1; i<argc; i++)
+   {
+      if(argv[i][0] == '-')
+      {
+         int start = 1;
+         struct rc_option *option;
+         char *arg = NULL;
+         
+         if(argv[i][1] == '-')
+            start = 2;
+         
+         if((option = rc_get_option2(rc->option, argv[i] + start)))
+         {
+            if (option->type == rc_bool)
+            {
+               /* handle special bool set case */
+               arg = "1";
+            }
+            else
+            {
+               /* normal option */
+               if (rc_requires_arg[option->type])
+               {
+                  i++;
+                  if (i >= argc)
+                  {
+                     fprintf(stderr, "error: %s requires an argument\n", argv[i-1]);
+                     return -1;
+                  }
+                  arg = argv[i];
+               }
+            }
+         }
+         else if(!strncmp(argv[i] + start, "no", 2) &&
+            (option = rc_get_option2(rc->option, argv[i] + start + 2)) &&
+            (option->type == rc_bool))
+         {
+            /* handle special bool clear case */
+            arg = "0";
+         }
+         else
+         {
+            fprintf(stderr, "error: unknown option %s\n", argv[i]);
+            return -1;
+         }
+         
+         if(rc_set_option3(option, arg, priority))
+            return -1;
+      }
+      else
+      {
+         /* do we have space to register the non-option arg */
+         if(rc->args_registered >= (rc->arg_size))
+         {
+            char **tmp = realloc(rc->arg, (rc->arg_size + BUF_SIZE) *
+               sizeof(char *));
+            if (!tmp)
+            {
+               fprintf(stderr,
+                  "error: malloc failed in rc_parse_commadline\n");
+               return -1;
+            }
+            rc->arg = tmp;
+            memset(rc->arg + rc->arg_size, 0, BUF_SIZE * sizeof(char *));
+            rc->arg_size += BUF_SIZE;
+         }
+         
+         /* register the non-option arg */
+         rc->arg[rc->args_registered] = argv[i];
+         rc->args_registered++;
+         
+         /* call the callback if defined */
+         if(arg_callback && (*arg_callback)(argv[i]))
+            return -1;
+      }
+   }
+   return 0;
+}
+
+int rc_get_non_option_args(struct rc_struct *rc, int *argc, char **argv[])
+{
+   *argv = rc->arg;
+   *argc = rc->args_registered;
+   return 0;
+}
+
+/* needed to walk the tree */
+static void rc_real_print_help(struct rc_option *option, FILE *f)
+{
+   int i;
+   char buf[BUF_SIZE];
+   static const char *type_name[] = {"", "", " <string>", " <int>", " <float>",
+      "", "", " <filename>", " <arg>", "", "" };
+   
+   for(i=0; option[i].type; i++)
+   {
+      switch (option[i].type)
+      {
+         case rc_ignore:
+            break;
+         case rc_seperator:
+            fprintf(f, "\n*** %s ***\n", option[i].name);
+            break;
+         case rc_link:
+            rc_real_print_help(option[i].dest, f);
+            break;
+         default:
+            snprintf(buf, BUF_SIZE, "-%s%s%s%s%s%s",
+               (option[i].type == rc_bool)? "[no]":"",
+               option[i].name,
+               (option[i].shortname)? " / -":"",
+               (option[i].shortname && (option[i].type == rc_bool))? "[no]":"",
+               (option[i].shortname)? option[i].shortname:"",
+               type_name[option[i].type]);
+            fprint_columns(f, buf,
+               (option[i].help)? option[i].help:"no help available");
+      }
+   }
+}
+
+void rc_print_help(struct rc_struct *rc, FILE *f)
+{
+   rc_real_print_help(rc->option, f);
+}
+
+/* needed to walk the tree */
+static void rc_real_print_man_options(struct rc_option *option, FILE *f)
+{
+   int i;
+   static const char *type_name[] = {"", "", " Ar string", " Ar int",
+      " Ar float", "", "", " Ar filename", " Ar arg", "", "" };
+   
+   for(i=0; option[i].type; i++)
+   {
+      switch (option[i].type)
+      {
+         case rc_ignore:
+            break;
+         case rc_seperator:
+            fprintf(f, ".It \\fB*** %s ***\\fR\n", option[i].name);
+            break;
+         case rc_link:
+            rc_real_print_man_options(option[i].dest, f);
+            break;
+         default:
+            fprintf(f, ".It Fl %s%s%s%s%s%s\n%s\n",
+               (option[i].type == rc_bool)? "[no]":"",
+               option[i].name,
+               (option[i].shortname)? " , ":"",
+               (option[i].shortname && (option[i].type == rc_bool))? "[no]":"",
+               (option[i].shortname)? option[i].shortname:"",
+               type_name[option[i].type],
+               (option[i].help)? option[i].help:"no help available");
+      }
+   }
+}
+
+void rc_print_man_options(struct rc_struct *rc, FILE *f)
+{
+   rc_real_print_man_options(rc->option, f);
+}
+
+int rc_verify_power_of_2(struct rc_option *option, const char *arg,
+   int priority)
+{
+   int i, value;
+   
+   value = *(int *)option->dest;
+   
+   for(i=0; i<(sizeof(int)*8); i++)
+      if(((int)0x01 << i) == value)
+         break;
+   if(i == (sizeof(int)*8))
+   {
+      fprintf(stderr, "error invalid value for %s: %s\n", option->name, arg);
+      return -1;
+   }
+   
+   option->priority = priority;
+   
+   return 0;
+}
+
+int rc_option_requires_arg(struct rc_struct *rc, const char *name)
+{
+   return rc_option_requires_arg2(rc->option, name);
+}
+
+int rc_option_requires_arg2(struct rc_option *option, const char *name)
+{
+   struct rc_option *my_option;
+   
+   if(!(my_option = rc_get_option2(option, name)))
+   {
+      fprintf(stderr, "error: unknown option %s\n", name);
+      return -1;
+   }
+   return rc_requires_arg[my_option->type];
+}
+
+int rc_option_requires_arg3(struct rc_option *option)
+{
+   return rc_requires_arg[option->type];
+}
+
+int rc_get_priority(struct rc_struct *rc, const char *name)
+{
+   return rc_get_priority2(rc->option, name);
+}
+
+int rc_get_priority2(struct rc_option *option, const char *name)
+{
+   struct rc_option *my_option;
+   
+   if(!(my_option = rc_get_option2(option, name)))
+   {
+      fprintf(stderr, "error: unknown option %s\n", name);
+      return -1;
+   }
+   return my_option->priority;
+}
+
+int rc_get_priority3(struct rc_option *option)
+{
+   return option->priority;
+}
+
+int rc_set_option(struct rc_struct *rc, const char *name, const char *arg,
+   int priority)
+{
+   return rc_set_option2(rc->option, name, arg, priority);
+}
+
+int rc_set_option2(struct rc_option *option, const char *name,
+   const char *arg, int priority)
+{
+   struct rc_option *my_option;
+   
+   if(!(my_option = rc_get_option2(option, name)))
+   {
+      fprintf(stderr, "error: unknown option %s\n", name);
+      return -1;
+   }
+   return rc_set_option3(my_option, arg, priority);
+}
+
+int rc_set_option3(struct rc_option *option, const char *arg, int priority)
+{
+   char *end;
+   
+   /* check priority */
+   if(priority < option->priority)
+      return 0;
+   
+   switch(option->type)
+   {
+      case rc_string:
+         {
+            char *str;
+            if ( !( str = malloc(strlen(arg)+1) ) )
+            {
+               fprintf(stderr, "error: malloc failed for %s\n", option->name);
+               return -1;
+            }
+            strcpy(str, arg);
+            if(*(char **)option->dest)
+               free(*(char **)option->dest);
+            *(char **)option->dest = str;
+         }
+         break;
+      case rc_int:
+      case rc_bool:
+         {
+            int x;
+            x = strtol(arg, &end, 0);
+            if (*end || rc_verify(option, x))
+            {
+               fprintf(stderr, "error: invalid value for %s: %s\n", option->name, arg);
+               return -1;
+            }
+            *(int *)option->dest = x;
+         }
+         break;
+      case rc_float:
+         {
+            float x;
+            x = strtod(arg, &end);
+            if (*end || rc_verify(option, x))
+            {
+               fprintf(stderr, "error: invalid value for %s: %s\n", option->name, arg);
+               return -1;
+            }
+            *(float *)option->dest = x;
+         }
+         break;
+      case rc_set_int:
+         *(int*)option->dest = option->min;
+         break;
+      case rc_file:
+         {
+            FILE *f = fopen(arg, (option->min)? "w":"r");
+            if(!f)
+            {
+               fprintf(stderr, "error: couldn't open file: %s\n", arg);
+               return -1;
+            }
+            if (*(FILE **)option->dest)
+               fclose(*(FILE **)option->dest);
+            *(FILE **)option->dest = f;
+         }
+         break;
+      case rc_use_function:
+      case rc_use_function_no_arg:
+         break;
+      default:
+         fprintf(stderr,
+            "error: unknown option type: %d, this should not happen!\n",
+            option->type);
+         return -1;
+   }
+   /* functions should do there own priority handling, so that they can
+      ignore priority handling if they wish */
+   if(option->func)
+      return (*option->func)(option, arg, priority);
+   
+   option->priority = priority;
+   
+   return 0;
+}
+
+struct rc_option *rc_get_option(struct rc_struct *rc, const char *name)
+{
+   return rc_get_option2(rc->option, name);
+}
+
+struct rc_option *rc_get_option2(struct rc_option *option, const char *name)
+{
+   int i;
+   struct rc_option *result;
+   
+   for(i=0; option[i].type; i++)
+   {
+      switch(option[i].type)
+      {
+         case rc_ignore:
+         case rc_seperator:
+            break;
+         case rc_link:
+            if((result = rc_get_option2(option[i].dest, name)))
+               return result;
+            break;
+         default:
+            if(!strcmp(name, option[i].name) ||
+               (option[i].shortname &&
+                  !strcmp(name, option[i].shortname)))
+               return &option[i];
+      }
+   }
+   return NULL;
+}
+
+/* gimmi the entire tree, I want todo all the parsing myself */
+struct rc_option *rc_get_options(struct rc_struct *rc)
+{
+   return rc->option;
+}
+
+/* various utility methods which don't really belong to the rc object,
+   but seem to fit here well */
+
+/* locate user's home directory */
+char *rc_get_home_dir(void)
+{
+   struct passwd *pw;
+   char *s;
+   
+   if (!(pw=getpwuid(getuid())))
+   { 
+      fprintf(stderr, "Who are you? Not found in passwd database!!\n");
+      return NULL;
+   }
+   if (!(s=malloc(strlen(pw->pw_dir)+1)))
+   {
+      fprintf(stderr, "error: malloc faild for homedir string\n");
+      return NULL;
+   }
+   strcpy(s, pw->pw_dir);
+   return s;
+}
+
+/* 
+ * check and if nescesarry create dir
+ */
+int rc_check_and_create_dir(const char *name)
+{
+   struct stat stat_buffer;
+
+   if (stat(name, &stat_buffer))
+   {
+      /* error check if it doesn't exist or something else is wrong */
+      if (errno == ENOENT)
+      {
+         /* doesn't exist letts create it ;) */
+#ifdef BSD43
+	 if (mkdir(name, 0775))
+#else
+         if (mkdir(name, S_IRWXU|S_IRWXG|S_IROTH|S_IXOTH))
+#endif
+         {
+            fprintf(stderr, "Error creating dir %s", name);
+            perror(" ");
+            return -1;
+         }
+      }
+      else
+      {
+         /* something else went wrong yell about it */
+         fprintf(stderr, "Error opening %s", name);
+         perror(" ");
+         return -1;
+      }
+   }
+   else
+   {
+      /* file exists check it's a dir otherwise yell about it */
+#ifdef BSD43
+      if(!(S_IFDIR & stat_buffer.st_mode))
+#else
+      if(!S_ISDIR(stat_buffer.st_mode))
+#endif
+      {
+         fprintf(stderr,"Error %s exists but isn't a dir\n", name);
+         return -1;
+      }
+   }
+   return 0;
+}
diff --git a/src/unix/sysdep/rc.h b/src/unix/sysdep/rc.h
new file mode 100644
index 0000000..166e287
--- /dev/null
+++ b/src/unix/sysdep/rc.h
@@ -0,0 +1,129 @@
+/* A simple rcfile and commandline parsing mechanism
+
+   Copyright 1999,2000 Hans de Goede
+   
+   This file and the acompanying files in this directory are free software;
+   you can redistribute them and/or modify them under the terms of the GNU
+   Library General Public License as published by the Free Software Foundation;
+   either version 2 of the License, or (at your option) any later version.
+
+   These files are distributed in the hope that they will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with these files; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.
+*/
+#ifndef __RC_H
+#define __RC_H
+
+#include <stdio.h>
+#include "begin_code.h"
+#include "fileio.h"
+
+struct rc_struct;
+struct rc_option;
+
+enum { rc_ignore = -1, rc_end, rc_bool, rc_string, rc_int, rc_float,
+   rc_set_int, rc_seperator, rc_file, rc_use_function,
+   rc_use_function_no_arg, rc_link };
+
+typedef int(*rc_func)(struct rc_option *option, const char *arg,
+   int priority);
+
+struct rc_option
+{
+   const char *name;  /* name of the option */
+   const char *shortname;  /* shortcut name of the option, or clear for bool */
+   int type;          /* type of the option */
+   void *dest;        /* ptr to where the value of the option should be stored */
+   const char *deflt; /* default value of the option in a c-string */
+   float min;         /* used to verify rc_int or rc_float, this check is not */
+   float max;         /* done if min == max. min is also used as value for
+                         set_int, and as write flag for rc_file. */
+   rc_func func;      /* function which is called for additional verification
+                         of the value, or which is called to parse the value if
+                         type == use_function, or NULL. Should return 0 on
+                         success, -1 on failure */
+   const char *help;  /* help text for this option */
+   int priority;      /* priority of the current value, the current value
+                         is only changed when the priority of the source
+                         is higher as this, and then the priority is set to
+                         the priority of the source */
+};
+
+/* open / close */
+struct rc_struct *rc_create(void);
+void rc_destroy(struct rc_struct *rc);
+
+/* register / unregister */
+int rc_register(struct rc_struct *rc, struct rc_option *option);
+int rc_unregister(struct rc_struct *rc, struct rc_option *option);
+
+/* load/save (read/write) a configfile */
+int rc_load(struct rc_struct *rc, const char *name, int priority,
+   int continue_on_errors);
+int rc_save(struct rc_struct *rc, const char *name, int append);
+int osd_rc_read(struct rc_struct *rc, mame_file *f, const char *description,
+   int priority, int continue_on_errors);
+int osd_rc_write(struct rc_struct *rc, mame_file *f, const char *description);
+int rc_read(struct rc_struct *rc, FILE *f, const char *description,
+   int priority, int continue_on_errors);
+int rc_write(struct rc_struct *rc, FILE *f, const char *description);
+
+/* commandline handling */
+int rc_parse_commandline(struct rc_struct *rc, int argc, char *argv[],
+   int priority, int(*arg_callback)(char *arg));
+int rc_get_non_option_args(struct rc_struct *rc, int *argc, char **argv[]);
+
+/* print help */
+void rc_print_help(struct rc_struct *rc, FILE *f);
+
+/* print commandline options in manpage style */
+void rc_print_man_options(struct rc_struct *rc, FILE *f);
+
+/* some default verify functions */
+int rc_verify_power_of_2(struct rc_option *option, const char *arg,
+   int priority);
+
+/* functions which can be used in option functions or to build your own
+   parser. */
+/* 3 ways to query if an option needs arguments, to query it's priority and
+   to set it:
+   -by name, searching the options in a rc instance
+   -by name, searching an array of options, as given to rc_register
+   -using the option given (which could for example have been returned
+    by rc_get_option) */
+int rc_option_requires_arg(struct rc_struct *rc, const char *name);
+int rc_option_requires_arg2(struct rc_option *option, const char *name);
+int rc_option_requires_arg3(struct rc_option *option);
+
+int rc_get_priority(struct rc_struct *rc, const char *name);
+int rc_get_priority2(struct rc_option *option, const char *name);
+int rc_get_priority3(struct rc_option *option);
+
+int rc_set_option(struct rc_struct *rc, const char *name, const char *arg,
+   int priority);
+int rc_set_option2(struct rc_option *option, const char *name,
+   const char *arg, int priority);
+int rc_set_option3(struct rc_option *option, const char *arg, int priority);
+   
+/* 2 ways to get the option_struct belonging to a certain option:
+   -by name, searching the options in a rc instance
+   -by name, searching an array of options, as given to rc_register */
+struct rc_option *rc_get_option(struct rc_struct *rc, const char *name);
+struct rc_option *rc_get_option2(struct rc_option *option, const char *name);
+
+/* gimmi the entire tree, I want todo all the parsing myself */
+struct rc_option *rc_get_options(struct rc_struct *rc);
+
+/* various utility functions which don't really belong to the rc object,
+   but seem to fit here well */
+int rc_check_and_create_dir(const char *name);
+char *rc_get_home_dir(void);
+
+#include "end_code.h"
+#endif /* ifndef __RC_H */
diff --git a/src/unix/sysdep/rc_priv.h b/src/unix/sysdep/rc_priv.h
new file mode 100644
index 0000000..25c8dc6
--- /dev/null
+++ b/src/unix/sysdep/rc_priv.h
@@ -0,0 +1,36 @@
+/* A simple rcfile and commandline parsing mechanism
+
+   Copyright 1999,2000 Hans de Goede
+   
+   This file and the acompanying files in this directory are free software;
+   you can redistribute them and/or modify them under the terms of the GNU
+   Library General Public License as published by the Free Software Foundation;
+   either version 2 of the License, or (at your option) any later version.
+
+   These files are distributed in the hope that they will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with these files; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.
+*/
+#ifndef __RC_PRIV_H
+#define __RC_PRIV_H
+
+#include "rc.h"
+#include "begin_code.h"
+
+struct rc_struct
+{
+   struct rc_option *option;
+   int option_size;
+   char **arg;
+   int arg_size;
+   int args_registered;
+};
+
+#include "end_code.h"
+#endif /* ifndef __RC_PRIV_H */
diff --git a/src/unix/sysdep/sound_stream.c b/src/unix/sysdep/sound_stream.c
new file mode 100644
index 0000000..9391e4d
--- /dev/null
+++ b/src/unix/sysdep/sound_stream.c
@@ -0,0 +1,248 @@
+/* Sound stream object
+
+   Copyright 2000 Hans de Goede
+   
+   This file and the acompanying files in this directory are free software;
+   you can redistribute them and/or modify them under the terms of the GNU
+   Library General Public License as published by the Free Software Foundation;
+   either version 2 of the License, or (at your option) any later version.
+
+   These files are distributed in the hope that they will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with these files; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.
+*/
+/* Changelog
+Version 0.1, March 2000
+-initial release (Hans de Goede)
+*/
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include "sound_stream.h"
+#include "sound_stream_priv.h"
+#include "fifo.h"
+
+/* #define SOUND_STREAM_DEBUG */
+/* #define SOUND_STREAM_WARNING */
+
+/* private methods */
+FIFO(INLINE, sample_buf, struct sound_stream_sample_buf *)
+
+/* public methods (in sound_stream.h) */
+struct sound_stream_struct *sound_stream_create(struct sysdep_dsp_struct* dsp,
+   int type, int buf_size, int buf_count)
+{
+   int i, bytes_per_sample[] = SYSDEP_DSP_BYTES_PER_SAMPLE;
+   struct sound_stream_struct *stream = NULL;
+   
+   /* allocate the sound_stream struct */
+   if(!(stream = calloc(1, sizeof(struct sound_stream_struct))))
+   {
+      fprintf(stderr,
+         "error malloc failed for struct sound_stream_struct\n");
+      return NULL;
+   }
+   
+   /* fill in some value's */
+   stream->dsp = dsp;
+   stream->bytes_per_sample = bytes_per_sample[type];
+   stream->sample_buf_size = buf_size;
+   stream->sample_buf_count = buf_count;
+   
+   /* allocate the output buffer */
+   stream->output_buf_size = sysdep_dsp_get_max_freespace(stream->dsp);
+   if(!(stream->output_buf = calloc(stream->output_buf_size,
+      stream->bytes_per_sample)))
+   {
+      fprintf(stderr,
+         "error malloc failed for sound_stream output buffer\n");
+      sound_stream_destroy(stream);
+      return NULL;
+   }
+   
+   /* create the fifo's */
+   if(!(stream->sample_buf_fifo = sample_buf_fifo_create(
+      stream->sample_buf_count)))
+   {
+      sound_stream_destroy(stream);
+      return NULL;
+   }
+   if(!(stream->empty_sample_buf_fifo = sample_buf_fifo_create(
+      stream->sample_buf_count)))
+   {
+      sound_stream_destroy(stream);
+      return NULL;
+   }
+   
+   /* create sample_buf_count sample_buf structs */
+   if(!(stream->sample_buf = calloc(stream->sample_buf_count,
+      sizeof(struct sound_stream_sample_buf))))
+   {
+      fprintf(stderr,
+         "error malloc failed for struct sound_stream_sample_buf\n");
+      sound_stream_destroy(stream);
+      return NULL;
+   }
+   
+   /* allocate the sample_buf-buffers and fill the empty_sample_buf_fifo */
+   for(i = 0; i < stream->sample_buf_count; i++)
+   {
+      if(!(stream->sample_buf[i].data =
+         calloc(stream->sample_buf_size, stream->bytes_per_sample)))
+      {
+         fprintf(stderr,
+            "error malloc failed for sample_buf data\n");
+         sound_stream_destroy(stream);
+         return NULL;
+      }
+      sample_buf_fifo_put(stream->empty_sample_buf_fifo,
+         &stream->sample_buf[i]);
+   }
+   
+   return stream;
+}
+
+void sound_stream_destroy(struct sound_stream_struct *stream)
+{
+   int i;
+   
+   if(stream->output_buf)
+      free(stream->output_buf);
+      
+   if(stream->sample_buf_fifo)
+      sample_buf_fifo_destroy(stream->sample_buf_fifo);
+   
+   if(stream->empty_sample_buf_fifo)
+      sample_buf_fifo_destroy(stream->empty_sample_buf_fifo);
+      
+   if(stream->sample_buf)
+   {
+      for(i = 0; i < stream->sample_buf_count; i++)
+         if(stream->sample_buf[i].data)
+            free(stream->sample_buf[i].data);
+      
+      free(stream->sample_buf);
+   }
+   
+   free(stream);
+}
+
+void sound_stream_write(struct sound_stream_struct *stream,
+   unsigned char *data, int samples)
+{
+   struct sound_stream_sample_buf *sample_buf;
+   
+   /* add the samples to our sample_buf_fifo */
+   while(samples)
+   {
+      if(sample_buf_fifo_get(stream->empty_sample_buf_fifo, &sample_buf) == 0)
+      {
+         int samples_this_loop = samples;
+         
+         if(samples_this_loop > stream->sample_buf_size)
+            samples_this_loop = stream->sample_buf_size;
+         
+         sample_buf->length = samples_this_loop;
+         sample_buf->pos = 0;
+         memcpy(sample_buf->data, data, samples_this_loop *
+            stream->bytes_per_sample);
+         sample_buf_fifo_put(stream->sample_buf_fifo, sample_buf);
+         
+         samples -= samples_this_loop;
+         data += samples_this_loop * stream->bytes_per_sample;
+      }
+      else
+      {
+#ifdef SOUND_STREAM_WARNING
+         fprintf(stderr, "warning: sound_stream: fifo full, dropping sample\n");
+#endif
+         samples = 0;
+      }
+   }
+}
+
+void sound_stream_update(struct sound_stream_struct *stream)
+{
+   int freespace;
+   struct sound_stream_sample_buf *sample_buf;
+
+   /* get freespace */   
+   freespace = sysdep_dsp_get_freespace(stream->dsp);
+#ifdef SOUND_STREAM_DEBUG
+   fprintf(stderr, "debug: sound_stream: freespace = %d\n", freespace);
+#endif
+
+   while(freespace > 0)
+   {
+      int result, samples_this_loop;
+      
+      /* we peek a sample_buf since we might not completly use it, once we're
+         done we get it to disgard it. If there haven't been any writes to the
+         fifo yet it can be empty, in this case there is nothing we can do. */
+      if(sample_buf_fifo_peek(stream->sample_buf_fifo, &sample_buf))
+         return;
+      
+#ifdef SOUND_STREAM_DEBUG      
+      fprintf(stderr, "sample_buf->length = %d, sample_buf->pos = %d\n",
+         sample_buf->length, sample_buf->pos);
+#endif
+      
+      samples_this_loop = sample_buf->length - sample_buf->pos;
+      if (samples_this_loop > freespace)
+         samples_this_loop = freespace;
+      
+      result = sysdep_dsp_write(stream->dsp,
+         sample_buf->data + (sample_buf->pos * stream->bytes_per_sample),
+         samples_this_loop);
+      
+      /* woops something went wrong (EAGAIN ?!), try again next update */
+      if (result < 0)
+      {
+#ifdef SOUND_STREAM_WARNING
+         fprintf(stderr, "warning: sound_stream: sysdep_dsp_write returned -1\n");
+#endif
+         return;
+      }
+      
+      sample_buf->pos += result;
+      
+      /* was there enough space in the sound device to write the entire sample?
+         otherwise try again next update */
+      if (result < samples_this_loop)
+      {
+#ifdef SOUND_STREAM_WARNING
+         fprintf(stderr,
+            "warning: sound_stream: sysdep_dsp_write returned %d, expected %d\n",
+            result, samples_this_loop);
+#endif
+         return;
+      }
+         
+      /* is this sample_buf finished ? */
+      if(sample_buf->pos == sample_buf->length)
+      {
+         /* if we have more then one sample_buf queued, queue the next,
+            otherwise loop this one */
+         if(sample_buf_fifo_in_use(stream->sample_buf_fifo) > 1)
+         {
+            sample_buf_fifo_get(stream->sample_buf_fifo, &sample_buf);
+            sample_buf_fifo_put(stream->empty_sample_buf_fifo, sample_buf);
+         }
+         else
+         {
+#ifdef SOUND_STREAM_WARNING
+            fprintf(stderr, "warning: sound_stream: fifo empty, looping sample\n");
+#endif
+            sample_buf->pos = 0;
+         }
+      }
+      
+      freespace -= result;
+   }
+}
diff --git a/src/unix/sysdep/sound_stream.h b/src/unix/sysdep/sound_stream.h
new file mode 100644
index 0000000..e2a59bb
--- /dev/null
+++ b/src/unix/sysdep/sound_stream.h
@@ -0,0 +1,38 @@
+/* Sound stream object
+
+   Copyright 2000 Hans de Goede
+   
+   This file and the acompanying files in this directory are free software;
+   you can redistribute them and/or modify them under the terms of the GNU
+   Library General Public License as published by the Free Software Foundation;
+   either version 2 of the License, or (at your option) any later version.
+
+   These files are distributed in the hope that they will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with these files; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.
+*/
+#ifndef __SOUND_STREAM_H
+#define __SOUND_STREAM_H
+
+#include "sysdep_dsp.h"
+#include "begin_code.h"
+
+struct sound_stream_struct;
+
+struct sound_stream_struct *sound_stream_create(struct sysdep_dsp_struct* dsp,
+   int type, int buf_size, int buf_count);
+void sound_stream_destroy(struct sound_stream_struct *stream);
+
+void sound_stream_write(struct sound_stream_struct *stream,
+   unsigned char *data, int samples);
+
+void sound_stream_update(struct sound_stream_struct *stream);
+
+#include "end_code.h"
+#endif /* ifndef __SOUND_STREAM_H */
diff --git a/src/unix/sysdep/sound_stream_priv.h b/src/unix/sysdep/sound_stream_priv.h
new file mode 100644
index 0000000..d0b8068
--- /dev/null
+++ b/src/unix/sysdep/sound_stream_priv.h
@@ -0,0 +1,46 @@
+/* Sound stream object
+
+   Copyright 2000 Hans de Goede
+   
+   This file and the acompanying files in this directory are free software;
+   you can redistribute them and/or modify them under the terms of the GNU
+   Library General Public License as published by the Free Software Foundation;
+   either version 2 of the License, or (at your option) any later version.
+
+   These files are distributed in the hope that they will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with these files; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.
+*/
+#ifndef __SOUND_STREAM_PRIV_H
+#define __SOUND_STREAM_PRIV_H
+#include "sysdep_dsp.h"
+#include "begin_code.h"
+
+struct sample_buf_fifo_struct;
+
+struct sound_stream_sample_buf {
+   int length;
+   int pos;
+   unsigned char *data;
+};
+
+struct sound_stream_struct {
+   struct sysdep_dsp_struct *dsp;
+   int bytes_per_sample;
+   int sample_buf_size;
+   int sample_buf_count;
+   int output_buf_size;
+   unsigned char *output_buf;
+   struct sound_stream_sample_buf *sample_buf;
+   struct sample_buf_fifo_struct *sample_buf_fifo;
+   struct sample_buf_fifo_struct *empty_sample_buf_fifo;
+};
+
+#include "end_code.h"
+#endif /* ifndef __SOUND_STREAM_PRIV_H */
diff --git a/src/unix/sysdep/sysdep_display.c b/src/unix/sysdep/sysdep_display.c
new file mode 100644
index 0000000..e74c1e5
--- /dev/null
+++ b/src/unix/sysdep/sysdep_display.c
@@ -0,0 +1,440 @@
+/* Sysdep display object
+
+   Copyright 2000 Hans de Goede
+   
+   This file and the acompanying files in this directory are free software;
+   you can redistribute them and/or modify them under the terms of the GNU
+   Library General Public License as published by the Free Software Foundation;
+   either version 2 of the License, or (at your option) any later version.
+
+   These files are distributed in the hope that they will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with these files; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.
+*/
+/* Changelog
+Version 0.1, March 2000
+-initial release (Hans de Goede)
+*/
+#include <stdio.h>
+#include <stdlib.h>
+#include "sysdep_display.h"
+#include "sysdep_display_priv.h"
+#include "sysdep_display_plugins.h"
+#include "plugin_manager.h"
+
+/* private func prototypes */
+static int sysdep_display_list_plugins(struct rc_option *option,
+   const char *arg, int priority);
+
+/* private variables */
+static int sysdep_display_widthscale = 1;
+static int sysdep_display_heightscale = 1;
+static int sysdep_display_scanlines = 0;
+static float sysdep_display_hw_aspect_ratio = 1.33;
+static int sysdep_display_keep_aspect = 1;
+static char *sysdep_display_plugin = NULL;
+static struct rc_struct *sysdep_display_rc = NULL;
+static struct plugin_manager_struct *sysdep_display_plugin_manager = NULL;
+static struct rc_option sysdep_display_opts[] = {
+   /* name, shortname, type, dest, deflt, min, max, func, help */
+   { "Display related", NULL,			rc_seperator,	NULL,
+     NULL,		0,			0,		NULL,
+     NULL },
+   { "display-plugin", 	"dp",			rc_string,	&sysdep_display_plugin,
+     NULL,		0,			0,		NULL,
+     "Select which plugin to use for the display" },
+   { "list-display-plugins",  "ldisp",		rc_use_function_no_arg, NULL,
+     NULL,		0,			0,		sysdep_display_list_plugins,
+     "List available display plugins" },
+   { "widthscale",	"ws",			rc_int,		&sysdep_display_widthscale,
+     "1",		1,			10,		NULL,
+     "Select the X scale factor" },
+   { "heightscale",	"hs",			rc_int,		&sysdep_display_heightscale,
+     "1",		1,			10,		NULL,
+     "Select the Y scale factor" },
+   { "scanlines",       "sl",			rc_bool,	&sysdep_display_scanlines,
+     "0",		0,			0,		NULL,
+     "Emulate / don't emulates scanlines when scaling allong the Y axis" },
+   { "display-aspect-ratio", "dar",		rc_float,	&sysdep_display_hw_aspect_ratio,
+     "1.33",		0.5,			2.0,		NULL,
+     "Set the aspect ratio of your monitor, this is used for mode selection "
+     "calculations. Usually this is 4/3 (1.33) in some cases this is 3/4 "
+     "(0.75) or even 16/9 (1.77)" },
+   { "keep-aspect",     "ka",			rc_bool,	&sysdep_display_keep_aspect,
+     "1",		0,			0,		NULL,
+     "Try / don't try to keep the correct aspect ratio when selecting the best mode" },
+   { NULL,		NULL,			rc_end,		NULL,
+     NULL,		0,			0,		NULL,
+     NULL }
+};
+static const struct plugin_struct *sysdep_display_plugins[] = {
+#ifdef SYSDEP_DISPLAY_X11
+   &sysdep_display_x11,
+#endif
+#ifdef SYSDEP_DISPLAY_DGA
+   &sysdep_display_dga,
+#endif
+#ifdef SYSDEP_DISPLAY_SVGALIB
+   &sysdep_display_svgalib,
+#endif
+   NULL
+};
+
+/* private methods */
+static int sysdep_display_list_plugins(struct rc_option *option,
+   const char *arg, int priority)
+{
+   fprintf(stdout, "Display plugins:\n\n");
+   plugin_manager_list_plugins(sysdep_display_plugin_manager, stdout);
+   
+   return -1;
+}
+
+static int sysdep_display_match_mode(struct sysdep_display_struct
+         *display, int mode)
+{
+   int ideal_width  = display->emu_mode.width  * display->widthscale;
+   int ideal_height = display->emu_mode.height * display->heightscale;
+   
+   /* does it fit at all ? */
+   if((display->modes[mode].width  < ideal_width) ||
+      (display->modes[mode].height < ideal_height) ||
+      (display->modes[mode].depth  < display->emu_mode.depth))
+      return 0;
+   
+   if(sysdep_display_keep_aspect)
+   {
+      float aspect_ratio_ratio = (display->aspect_ratio *
+         display->modes[mode].aspect_ratio) / display->emu_mode.aspect_ratio;
+
+      /* keep height? */
+      if(aspect_ratio_ratio >= 1.0)
+         ideal_width  *= aspect_ratio_ratio;
+      else
+         ideal_height /= aspect_ratio_ratio;
+   }
+
+   return ( 100 *
+      ((float)ideal_width  /
+         (abs(display->modes[mode].width  - ideal_width ) + ideal_width )) *
+      ((float)ideal_height /
+         (abs(display->modes[mode].height - ideal_height) + ideal_height)) *
+      ((float)display->emu_mode.depth / display->modes[mode].depth));
+}
+
+/* public methods (in sysdep_display.h) */
+int sysdep_display_init(struct rc_struct *rc, const char *plugin_path)
+{
+   if(!sysdep_display_rc)
+   {
+      if(rc && rc_register(rc, sysdep_display_opts))
+         return -1;
+      sysdep_display_rc = rc;
+   }
+   
+   if(!sysdep_display_plugin_mananger)
+   {
+      if(!(sysdep_display_plugin_manager =
+         plugin_manager_create("sysdep_display", rc)))
+      {
+         sysdep_display_exit();
+         return -1;
+      }
+      /* no need to fail here, if we don't have any plugins,
+         sysdep_display_create will always fail, but that doesn't have to be
+         fatal, failing here usually is! */
+      plugin_manager_register(sysdep_display_plugin_manager,
+         sysdep_display_plugins);
+      plugin_manager_load(sysdep_display_plugin_manager, plugin_path, NULL);
+      if (plugin_manager_init_plugin(sysdep_display_plugin_manager, NULL))
+      {
+         fprintf(stderr, "warning: no display plugins available\n");
+      }
+   }
+
+   return 0;
+}
+
+void sysdep_display_exit(void)
+{
+   if(sysdep_display_plugin_manager)
+   {
+      plugin_manager_destroy(sysdep_display_plugin_manager);
+      sysdep_display_plugin_manager = NULL;
+   }
+   if(sysdep_display_rc)
+   {
+      rc_unregister(sysdep_display_rc, sysdep_display_opts);
+      sysdep_display_rc = NULL;
+   }
+}
+
+
+struct sysdep_display_struct *sysdep_display_create(const char *plugin)
+{
+   struct sysdep_display_struct *display = NULL;
+   
+   /* create the instance */
+   if (!(display = plugin_manager_create_instance(sysdep_display_plugin_manager,
+      plugin? plugin:sysdep_display_plugin, NULL)))
+   {
+      return NULL;
+   }
+   
+   /* if the plugin couldn't give us an aspect ratio then use the user
+      defined aspect ratio */
+   if(!display->aspect_ratio)
+      display->aspect_ratio = sysdep_display_aspect_ratio;
+      
+   /* set the mode to -1 */
+   display->mode = -1;
+   
+   return display;
+}
+
+void sysdep_display_destroy(struct sysdep_display_struct *display)
+{
+   if(display->opened)
+      display->close(display);
+   
+   display->destroy(display);
+}
+
+
+int sysdep_display_open(struct sysdep_display_struct *display, int width,
+   int height, int depth, struct sysdep_display_open_params *params,
+   int params_present)
+{
+   /* are we already open ? */
+   if(display->opened)
+      return -1;
+   
+   /* get all the params */
+   display->emu_mode.width = width;
+   display->emu_mode.height = height;
+   display->emu_mode.depth = depth;
+   
+   if(params_present & SYSDEP_DISPLAY_ASPECT_RATIO)
+      display->emu_mode.aspect_ratio = params->aspect_ratio;
+   else
+      display->emu_mode.aspect_ratio = display->aspect_ratio;
+      
+   if(params_present & SYSDEP_DISPLAY_WIDTHSCALE)
+      display->widthscale = params->widthscale;
+   else
+      display->widthscale = sysdep_display_widthscale;
+   
+   if(params_present & SYSDEP_DISPLAY_HEIGHTSCALE)
+      display->heightscale = params->heightscale;
+   else
+      display->heightscale = sysdep_display_heightscale;
+      
+   if(params_present & SYSDEP_DISPLAY_SCANLINES)
+      display->scanlines = params->scanlines;
+   else
+      display->scanlines = sysdep_display_scanlines;
+      
+   /* if this plugin uses modes, then select the best mode */
+   if(display->modes)
+   {
+      int best_score = 0;
+      
+      display->mode = 0;
+      best_score = sysdep_display_match_mode(display, 0);
+      
+      for(i = 1; modes[i].width; i++)
+      {
+         int score = sysdep_display_match_mode(display, i);
+         if(score >= best_score)
+         {
+            best_score = score;
+            display->mode = i;
+         }
+      }
+      display->hw_mode = display->modes[display->mode];
+      display->startx = ((display->emu_mode.width  * display->widthscale) -
+         display->hw_mode.width ) / 2;
+      display->starty = ((display->emu_mode.heigth * display->heightscale) -
+         display->hw_mode.height) / 2;
+   }
+   else
+      display->hw_mode = display->emu_mode;
+   
+   if(display->open(display))
+   {
+      sysdep_display_close(display);
+      return -1;
+   }
+      
+   display->opened = 1;
+   
+   return 0;
+}
+
+void sysdep_display_close(struct sysdep_display_struct *display)
+{
+  /* Save these 3 so that they can be restored after clearing the
+     display struct. */
+  struct sysdep_display_mode *modes = display->modes;
+  float aspect_ratio = display->aspect_ratio;
+  void *_priv = display->_priv;
+  
+  /* close the display */
+  if(display->opened)
+     display->close(display);
+  
+  /* clear the display struct */
+  memset(display, 0, sizeof(struct sysdep_display_struct));
+  
+  /* and restore the vital data */
+  display->modes = modes;
+  display->aspect_ratio = aspect_ratio;
+  display->_priv = _priv;
+  display->mode = -1;
+}
+
+
+/* map / unmap (set graphics mode / text mode) */
+int sysdep_display_map(struct sysdep_display_struct *display)
+{
+}
+
+int sysdep_display_unmap(struct sysdep_display_struct *display)
+{
+}
+
+
+/* mode handling */
+float sysdep_display_get_aspect_ratio(struct sysdep_display_struct *display)
+{
+   return display->aspect_ratio;
+}
+
+const struct sysdep_display_mode *sysdep_display_get_modes(
+   struct sysdep_display_struct *display)
+{
+   static const struct sysdep_display_mode no_modes[2] = {
+      { -1, -1, -1, 0, 0 },
+         0,  0,  0, 0, 0 }
+      };
+      
+   /* does this plugin use modes? */
+   if (display->modes)
+      return display->modes;
+   else
+      return no_modes;
+}
+
+
+/* palette handling */
+int sysdep_display_16bpp_capable(struct sysdep_display_struct *display)
+{
+   return display->is_16bpp_capable;
+}
+
+const struct sysdep_palette_info *sysdep_display_get_palette_info(
+   struct sysdep_display_struct *display)
+{
+   return &(display->palette_info);
+}
+
+int sysdep_display_alloc_palette(struct sysdep_display_struct *display,
+   int writable_colors)
+{
+   if(display->alloc_palette)
+      return display->alloc_palette(display, writable_colors);
+      
+   return 0;
+}
+
+int sysdep_display_set_pen(struct sysdep_display_struct *display, int pen,
+   unsigned char red, unsigned char green, unsigned char blue)
+{
+   if(display->set_pen)
+      return display->set_pen(display, pen, red, green, blue);
+   
+   return -1;
+}
+
+   
+int sysdep_display_blit(struct sysdep_display_struct *display,
+   struct sysdep_bitmap *bitmap, int src_x, int src_y, int dest_x, int dest_y,
+   int src_width, int src_height, int scale_x, int scale_y, int use_dirty)
+{
+   /* adjust scale_xx and dest_xx for display scaling and panning */
+   scale_x *= display->widthscale;
+   scale_y *= display->heightscale;
+   dest_x  *= display->widthscale;
+   dest_y  *= display->heightscale;
+   dest_x  += display->startx;
+   dest_y  += display->starty;
+   
+   /* 4 different scenarios:
+      -The display plugin has it's own blit function, and we use that.
+      -The display plugin has it's own blit function, but the display
+       types (the display palette_info structs) don't match, or scaling is
+       requested, so we first blit to a dummy framebuffer, and then call the
+       system's blit function to update the real framebuffer.
+      -the display plugin gives us direct access to its framebuffer, so
+       we use our own blit code to blit to this.
+      -the display plugin gives us direct access to its framebuffer, so
+       we blit to it, and wants us to call a function afterwards to notify it
+       about the updating of his framebuffer.
+   */
+   
+   questions:
+   -do we solve this by writing seperate code 4 the 4 blit scenarios, or do
+    we introduce's if statements for this in the blit code.
+   -how about special cases like doublebuffering no double buffering etc.
+}
+
+
+struct sysdep_input_struct *sysdep_display_open_input(
+   struct sysdep_display_struct *display)
+{
+}
+
+
+int sysdep_display_set_widthscale(struct sysdep_display_struct **display,
+   int widthscale)
+{
+}
+int sysdep_display_get_widthscale(struct sysdep_display_struct *display)
+{
+}
+
+int sysdep_display_set_heightscale(struct sysdep_display_struct **display,
+   int heightscale)
+{
+}
+int sysdep_display_get_widthscale(struct sysdep_display_struct *display)
+{
+}
+   
+int sysdep_display_set_scanlines(struct sysdep_display_struct *display,
+   int scanlines)
+{
+}
+int sysdep_display_get_widthscale(struct sysdep_display_struct *display)
+{
+}
+   
+int sysdep_display_set_plugin(struct sysdep_display_struct **display,
+   const char *plugin)
+{
+}
+const char *sysdep_display_get_plugin(struct sysdep_display_struct *display)
+{
+}
+
+int sysdep_display_handle_hotkeys(struct sysdep_display_struct **display,
+   struct sysdep_input_struct *input)
+{
+}
+
diff --git a/src/unix/sysdep/sysdep_display.h b/src/unix/sysdep/sysdep_display.h
new file mode 100644
index 0000000..a81b9a5
--- /dev/null
+++ b/src/unix/sysdep/sysdep_display.h
@@ -0,0 +1,114 @@
+/* Sysdep display object
+
+   Copyright 2000 Hans de Goede
+   
+   This file and the acompanying files in this directory are free software;
+   you can redistribute them and/or modify them under the terms of the GNU
+   Library General Public License as published by the Free Software Foundation;
+   either version 2 of the License, or (at your option) any later version.
+
+   These files are distributed in the hope that they will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with these files; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.
+*/
+#ifndef __SYSDEP_DISPLAY_H
+#define __SYSDEP_DISPLAY_H
+
+#include "begin_code.h"
+
+/* sysdep_display_open params_present defines */
+#define SYSDEP_DISPLAY_WIDTHSCALE	0x01
+#define SYSDEP_DISPLAY_HEIGHTSCALE	0x02
+#define SYSDEP_DISPLAY_SCANLINES	0x04
+#define SYSDEP_DISPLAY_ASPECT_RATIO	0x08
+
+struct sysdep_display_struct;
+struct sysdep_palette_struct;
+struct sysdep_palette_info;
+struct sysdep_input_struct;
+
+struct sysdep_display_open_params {
+   int widthscale;
+   int heightscale;
+   int scanlines;
+   float aspect_ratio;
+};
+
+struct sysdep_display_mode {
+   int width;
+   int height;
+   int depth;
+   float aspect_ratio;
+   int _priv;
+};
+
+/* init / exit */
+int sysdep_display_init(struct rc_struct *rc, const char *plugin_path);
+void sysdep_display_exit(void);
+
+/* create / destroy */
+struct sysdep_display_struct *sysdep_display_create(const char *plugin);
+void sysdep_display_destroy(struct sysdep_display_struct *display);
+
+/* open / close */
+int sysdep_display_open(struct sysdep_display_struct *display, int width,
+   int height, int depth, struct sysdep_display_open_params *params,
+   int params_present);
+void sysdep_display_close(struct sysdep_display_struct *display);
+
+/* map / unmap (set graphics mode / text mode) */
+int sysdep_display_map(struct sysdep_display_struct *display);
+int sysdep_display_unmap(struct sysdep_display_struct *display);
+
+/* mode handling */
+float sysdep_display_get_aspect_ratio(struct sysdep_display_struct *display);
+struct sysdep_display_mode *sysdep_display_get_modes(
+   struct sysdep_display_struct *display);
+
+/* palette handling */
+int sysdep_display_16bpp_capable(struct sysdep_display_struct *display);
+const struct sysdep_palette_info *sysdep_display_get_palette_info(
+   struct sysdep_display_struct *display);
+int sysdep_display_alloc_palette(struct sysdep_display_struct *display,
+   int writable_colors);
+int sysdep_display_set_pen(struct sysdep_display_struct *display, int pen,
+   unsigned char red, unsigned char green, unsigned char blue);
+
+/* blit */   
+int sysdep_display_blit(struct sysdep_display_struct *display,
+   struct sysdep_palette_struct *palette,
+   struct sysdep_bitmap *bitmap, int src_x, int src_y, int dest_x, int dest_y,
+   int src_width, int src_height, int scale_x, int scale_y, int use_dirty);
+
+/* input */ 
+struct sysdep_input_struct *sysdep_display_open_input(
+   struct sysdep_display_struct *display);
+
+/* option handling / changing */
+int sysdep_display_set_widthscale(struct sysdep_display_struct *display,
+   int widthscale);
+int sysdep_display_get_widthscale(struct sysdep_display_struct *display);
+
+int sysdep_display_set_heightscale(struct sysdep_display_struct *display,
+   int heightscale);
+int sysdep_display_get_widthscale(struct sysdep_display_struct *display);
+   
+int sysdep_display_set_scanlines(struct sysdep_display_struct *display,
+   int scanlines);
+int sysdep_display_get_widthscale(struct sysdep_display_struct *display);
+   
+int sysdep_display_set_plugin(struct sysdep_display_struct **display,
+   const char *plugin);
+const char *sysdep_display_get_plugin(struct sysdep_display_struct *display);
+
+int sysdep_display_handle_hotkeys(struct sysdep_display_struct **display,
+   struct sysdep_input_struct *input);
+
+#include "end_code.h"
+#endif /* ifndef __SYSDEP_DISPLAY_H */
diff --git a/src/unix/sysdep/sysdep_display_priv.h b/src/unix/sysdep/sysdep_display_priv.h
new file mode 100644
index 0000000..282edf9
--- /dev/null
+++ b/src/unix/sysdep/sysdep_display_priv.h
@@ -0,0 +1,48 @@
+/* Sysdep display object
+
+   Copyright 2000 Hans de Goede
+   
+   This file and the acompanying files in this directory are free software;
+   you can redistribute them and/or modify them under the terms of the GNU
+   Library General Public License as published by the Free Software Foundation;
+   either version 2 of the License, or (at your option) any later version.
+
+   These files are distributed in the hope that they will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with these files; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.
+*/
+#ifndef __SYSDEP_DISPLAY_PRIV_H
+#define __SYSDEP_DISPLAY_PRIV_H
+
+#include "sysdep_display.h"
+#include "sysdep_palette.h"
+#include "begin_code.h"
+
+struct sysdep_display_struct {
+   struct sysdep_display_mode emu_mode;
+   struct sysdep_display_mode hw_mode;
+   struct sysdep_display_mode *modes;
+   struct sysdep_palette_info palette_info;
+   float aspect_ratio;
+   int is_16bpp_capable;
+   int widthscale;
+   int heightscale;
+   int scanlines;
+   int mode;
+   int opened;
+   int mapped;
+   int startx;
+   int starty;
+   int framebuffer_pitch;
+   unsigned char *framebuffer;
+   void *_priv;
+};
+
+#include "end_code.h"
+#endif /* ifndef __SYSDEP_DISPLAY_PRIV_H */
diff --git a/src/unix/sysdep/sysdep_dsp.c b/src/unix/sysdep/sysdep_dsp.c
new file mode 100644
index 0000000..893a710
--- /dev/null
+++ b/src/unix/sysdep/sysdep_dsp.c
@@ -0,0 +1,364 @@
+/* Sysdep sound dsp object
+
+   Copyright 2000 Hans de Goede
+   
+   This file and the acompanying files in this directory are free software;
+   you can redistribute them and/or modify them under the terms of the GNU
+   Library General Public License as published by the Free Software Foundation;
+   either version 2 of the License, or (at your option) any later version.
+
+   These files are distributed in the hope that they will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with these files; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.
+*/
+/* Changelog
+Version 0.1, January 2000
+-initial release (Hans de Goede)
+Version 0.2, March 2000
+-added a plugin parameter to create, to override the global plugin
+ configuration (Hans de Goede)
+-made bufsize a parameter to create, removed the global bufsize configuration,
+ the code using us should have a much better idea of what bufsize should be
+ then we do. (Hans de Goede)
+-protected sysdep_dsp_init against being called twice (Hans de Goede)
+*/
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include "sysdep_dsp.h"
+#include "sysdep_dsp_priv.h"
+#include "sysdep_dsp_plugins.h"
+#include "plugin_manager.h"
+
+/* private func prototypes */
+static int sysdep_dsp_list_plugins(struct rc_option *option, const char *arg,
+   int priority);
+
+/* private variables */
+static char *sysdep_dsp_plugin = NULL;
+static int sysdep_dsp_use_timer = 0;
+static int sysdep_dsp_bytes_per_sample[] = SYSDEP_DSP_BYTES_PER_SAMPLE;
+static struct rc_struct *sysdep_dsp_rc = NULL;
+static struct plugin_manager_struct *sysdep_dsp_plugin_manager = NULL;
+static struct rc_option sysdep_dsp_opts[] = {
+   /* name, shortname, type, dest, deflt, min, max, func, help */
+   { "Digital sound related", NULL,		rc_seperator,	NULL,
+     NULL,		0,			0,		NULL,
+     NULL },
+   { "dsp-plugin", 	"dp",			rc_string,	&sysdep_dsp_plugin,
+     NULL,		0,			0,		NULL,
+     "Select which plugin to use for digital sound" },
+   { "list-dsp-plugins", "ldp",			rc_use_function_no_arg, NULL,
+     NULL,		0,			0,		sysdep_dsp_list_plugins,
+     "List available sound-dsp plugins" },
+   { "timer",		"ti",			rc_bool,	&sysdep_dsp_use_timer,
+     "0",		0,			0,		NULL,
+     "Use / don't use timer based audio (normally it will be used automagically when nescesarry)" },
+   { NULL,		NULL,			rc_end,		NULL,
+     NULL,		0,			0,		NULL,
+     NULL }
+};
+static const struct plugin_struct *sysdep_dsp_plugins[] = {
+#ifdef SYSDEP_DSP_OSS
+   &sysdep_dsp_oss,
+#endif
+#ifdef SYSDEP_DSP_NETBSD
+   &sysdep_dsp_netbsd,
+#endif
+#ifdef SYSDEP_DSP_SOLARIS
+   &sysdep_dsp_solaris,
+#endif
+#ifdef SYSDEP_DSP_SOUNDKIT
+   &sysdep_dsp_soundkit,
+#endif
+#ifdef SYSDEP_DSP_COREAUDIO
+   &sysdep_dsp_coreaudio,
+#endif
+#ifdef SYSDEP_DSP_IRIX
+   &sysdep_dsp_irix,
+#endif
+#ifdef SYSDEP_DSP_AIX
+   &sysdep_dsp_aix,
+#endif
+#ifdef SYSDEP_DSP_ESOUND
+   &sysdep_dsp_esound,
+#endif
+#ifdef SYSDEP_DSP_ALSA
+   &sysdep_dsp_alsa,
+#endif
+#ifdef SYSDEP_DSP_ARTS_TEIRA
+   &sysdep_dsp_arts,
+#endif
+#ifdef SYSDEP_DSP_ARTS_SMOTEK
+   &sysdep_dsp_arts,
+#endif
+#ifdef SYSDEP_DSP_SDL
+   &sysdep_dsp_sdl,
+#endif
+#ifdef SYSDEP_DSP_WAVEOUT
+   &sysdep_dsp_waveout,
+#endif
+   NULL
+};
+
+/* private methods */
+static int sysdep_dsp_list_plugins(struct rc_option *option, const char *arg,
+   int priority)
+{
+   fprintf(stdout, "Digital sound plugins:\n\n");
+   plugin_manager_list_plugins(sysdep_dsp_plugin_manager, stdout);
+   
+   return -1;
+}
+
+/* public methods (in sysdep_dsp.h) */
+int sysdep_dsp_init(struct rc_struct *rc, const char *plugin_path)
+{
+   if(!sysdep_dsp_rc)
+   {
+      if(rc && rc_register(rc, sysdep_dsp_opts))
+         return -1;
+      sysdep_dsp_rc = rc;
+   }
+   
+   if(!sysdep_dsp_plugin_manager)
+   {
+      if(!(sysdep_dsp_plugin_manager =
+         plugin_manager_create("sysdep_dsp", rc)))
+      {
+         sysdep_dsp_exit();
+         return -1;
+      }
+      /* no need to fail here, if we don't have any plugins, sysdep_dsp_create
+         will always fail, but that doesn't have to be fatal, failing here
+         usually is! */
+      plugin_manager_register(sysdep_dsp_plugin_manager, sysdep_dsp_plugins);
+      plugin_manager_load(sysdep_dsp_plugin_manager, plugin_path, NULL);
+      if(plugin_manager_init_plugin(sysdep_dsp_plugin_manager, NULL))
+      {
+         fprintf(stderr, "warning: no dsp plugins available\n");
+      }
+   }
+
+   return 0;
+}
+
+void sysdep_dsp_exit(void)
+{
+   if(sysdep_dsp_plugin_manager)
+   {
+      plugin_manager_destroy(sysdep_dsp_plugin_manager);
+      sysdep_dsp_plugin_manager = NULL;
+   }
+   if(sysdep_dsp_rc)
+   {
+      rc_unregister(sysdep_dsp_rc, sysdep_dsp_opts);
+      sysdep_dsp_rc = NULL;
+   }
+}
+
+struct sysdep_dsp_struct *sysdep_dsp_create(const char *plugin,
+   const char *device, int *samplerate, int *type, float bufsize,
+   int flags)
+{
+   struct sysdep_dsp_struct *dsp = NULL;
+   struct sysdep_dsp_create_params params;
+   
+   /* fill the params struct */
+   params.bufsize = bufsize;
+   params.device = device;
+   params.samplerate = *samplerate;
+   params.type = *type;
+   params.flags = flags;
+   
+   /* create the instance */
+   if (!(dsp = plugin_manager_create_instance(sysdep_dsp_plugin_manager,
+      plugin? plugin:sysdep_dsp_plugin, &params)))
+   {
+      return NULL;
+   }
+   
+   /* calculate buf_size if not done by the plugin */
+   if(!dsp->hw_info.bufsize)
+      dsp->hw_info.bufsize = bufsize * dsp->hw_info.samplerate;
+
+   /* fill in the emu info struct */
+   if(flags & SYSDEP_DSP_EMULATE_TYPE)
+      dsp->emu_info.type = *type;
+   else
+      dsp->emu_info.type = dsp->hw_info.type;
+   dsp->emu_info.samplerate = dsp->hw_info.samplerate;
+   dsp->emu_info.bufsize = dsp->hw_info.bufsize;
+   
+   /* allocate convert buffer if nescesarry */
+   if(memcmp(&dsp->emu_info, &dsp->hw_info, sizeof(struct sysdep_dsp_info)))
+   {
+      if(!(dsp->convert_buf =
+         malloc(dsp->hw_info.bufsize *
+            sysdep_dsp_bytes_per_sample[dsp->hw_info.type])))
+      {
+         fprintf(stderr,
+            "error malloc failed for dsp convert buffer\n");
+         sysdep_dsp_destroy(dsp);
+         return NULL;
+      }
+   }
+   
+   if(sysdep_dsp_use_timer || !dsp->get_freespace)
+      fprintf(stderr, "info: dsp: using timer-based audio\n");
+   
+   /* return actual type and samplerate */
+   *type = dsp->emu_info.type;
+   *samplerate = dsp->emu_info.samplerate;
+   
+   return dsp;
+}
+
+void sysdep_dsp_destroy(struct sysdep_dsp_struct *dsp)
+{
+   if(dsp->convert_buf)
+      free(dsp->convert_buf);
+   dsp->destroy(dsp);
+}
+
+int sysdep_dsp_get_freespace(struct sysdep_dsp_struct *dsp)
+{
+   uclock_t t;
+   int result;
+   
+   if(!sysdep_dsp_use_timer && dsp->get_freespace)
+      return dsp->get_freespace(dsp);
+      
+   /* fall back using uclock (which uses gettimeofday where available) */
+   t = uclock();
+   
+   if (dsp->last_update == 0)
+      result = 0;
+   else
+      result = ((t - dsp->last_update) * dsp->emu_info.samplerate) /
+         UCLOCKS_PER_SEC;
+   
+   dsp->last_update = t;
+   
+   /* sanity check */
+   if ((result < 0) || (result > dsp->emu_info.bufsize))
+      result = 0;
+   
+   return result;
+}
+
+int sysdep_dsp_write(struct sysdep_dsp_struct *dsp,
+   unsigned char *data, int count)
+{
+   if(!count)
+      return 0;
+
+   /* do we need to emulate? */
+   if(memcmp(&dsp->emu_info, &dsp->hw_info, sizeof(struct sysdep_dsp_info)))
+   {
+      unsigned char *convert_buf = dsp->convert_buf;
+      short *convert_buf_large = (short *)dsp->convert_buf;
+      short *data_large = (short *)data;
+      int i;
+      
+      if (count > dsp->emu_info.bufsize)
+         count = dsp->emu_info.bufsize;
+      
+      switch((dsp->emu_info.type << 4) | dsp->hw_info.type)
+      {
+         /* 8bit mono -> */
+         case 0x01: /* 16bit mono */
+            for(i = 0; i < count; i++)
+               convert_buf_large[i] = ((int)data[i] << 8) - 32768;
+            break;
+         case 0x02: /* 8bit stereo */
+            for(i = 0; i < count; i++)
+            {
+               convert_buf[i * 2]     = data[i];
+               convert_buf[i * 2 + 1] = data[i];
+            }
+            break;
+         case 0x03: /* 16bit stereo */
+            for(i = 0; i < count; i++)
+            {
+               convert_buf_large[i * 2]     = ((int)data[i] << 8) - 32768;
+               convert_buf_large[i * 2 + 1] = convert_buf[i * 2];
+            }
+            break;
+            
+         /* 16bit mono -> */
+         case 0x10: /* 8 bit mono */
+            for(i = 0; i < count; i++)
+               convert_buf[i] = (data_large[i] >> 8) + 128;
+            break;
+         case 0x12: /* 8bit stereo */
+            for(i = 0; i < count; i++)
+            {
+               convert_buf[i * 2]     = (data_large[i] >> 8) + 128;
+               convert_buf[i * 2 + 1] = convert_buf[i * 2];
+            }
+            break;
+         case 0x13: /* 16bit stereo */
+            for(i = 0; i < count; i++)
+            {
+               convert_buf_large[i * 2]     = data_large[i];
+               convert_buf_large[i * 2 + 1] = data_large[i];
+            }
+            break;
+            
+         /* 8bit stereo -> */
+         case 0x20: /* 8 bit mono */
+            for(i = 0; i < count; i++)
+               convert_buf[i] = (((int)data[i * 2] + (int)data[i * 2 + 1])
+                  >> 1);
+            break;
+         case 0x21: /* 16bit mono */
+            for(i = 0; i < count; i++)
+               convert_buf_large[i] = (((int)data[i * 2] + 
+                  (int)data[i * 2 + 1]) << 7) - 32768;
+            break;
+         case 0x23: /* 16bit stereo */
+            for (i = 0; i < count; i++)
+            {
+               convert_buf_large[i * 2    ] = ((int)data[i * 2    ] << 8)
+                  - 32768;
+               convert_buf_large[i * 2 + 1] = ((int)data[i * 2 + 1] << 8)
+                  - 32768;
+            }
+            break;
+            
+         /* 16bit stereo -> */
+         case 0x30: /* 8 bit mono */
+            for(i = 0; i < count; i++)
+               convert_buf[i] = (((int)data_large[i * 2] +
+                  (int)data_large[i * 2 + 1]) >> 9) + 128;
+            break;
+         case 0x31: /* 16bit mono */
+            for(i = 0; i < count; i++)
+               convert_buf_large[i] = (((int)data_large[i * 2] +
+                  (int)data_large[i * 2 + 1]) >> 1);
+            break;
+         case 0x32: /* 8bit stereo */
+            for (i = 0; i < count; i++)
+            {
+               convert_buf[i * 2    ] = (data_large[i * 2    ] >> 8) + 128;
+               convert_buf[i * 2 + 1] = (data_large[i * 2 + 1] >> 8) + 128;
+            }
+            break;
+      }
+      data = dsp->convert_buf;
+   }
+
+   return dsp->write(dsp, data, count);
+}
+
+int sysdep_dsp_get_max_freespace(struct sysdep_dsp_struct *dsp)
+{
+   return dsp->emu_info.bufsize;
+}
diff --git a/src/unix/sysdep/sysdep_dsp.h b/src/unix/sysdep/sysdep_dsp.h
new file mode 100644
index 0000000..e4eb39d
--- /dev/null
+++ b/src/unix/sysdep/sysdep_dsp.h
@@ -0,0 +1,55 @@
+/* Sysdep sound dsp object
+
+   Copyright 2000 Hans de Goede
+   
+   This file and the acompanying files in this directory are free software;
+   you can redistribute them and/or modify them under the terms of the GNU
+   Library General Public License as published by the Free Software Foundation;
+   either version 2 of the License, or (at your option) any later version.
+
+   These files are distributed in the hope that they will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with these files; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.
+*/
+#ifndef __SYSDEP_DSP_H
+#define __SYSDEP_DSP_H
+
+#include "rc.h"
+#include "begin_code.h"
+
+#define SYSDEP_DSP_BYTES_PER_SAMPLE { 1, 2, 2, 4 }
+
+/* valid flags for type */
+#define SYSDEP_DSP_8BIT   0x00
+#define SYSDEP_DSP_16BIT  0x01
+#define SYSDEP_DSP_MONO   0x00
+#define SYSDEP_DSP_STEREO 0x02
+
+/* valid flags for sysdep_dsp_create */
+#define SYSDEP_DSP_EMULATE_TYPE 0x01
+/* TODO: implement SYSDEP_DSP_EMULATE_SAMPLERATE */
+/* #define SYSDEP_DSP_EMULATE_SAMPLERATE 0x02 */
+#define SYSDEP_DSP_O_NONBLOCK 0x04
+
+struct sysdep_dsp_struct;
+
+int sysdep_dsp_init(struct rc_struct *rc, const char *plugin_path);
+void sysdep_dsp_exit(void);
+
+struct sysdep_dsp_struct *sysdep_dsp_create(const char *plugin,
+   const char *device, int *samplerate, int *type, float bufsize, int flags);
+void sysdep_dsp_destroy(struct sysdep_dsp_struct *dsp);
+
+int sysdep_dsp_get_freespace(struct sysdep_dsp_struct *dsp);
+int sysdep_dsp_write(struct sysdep_dsp_struct *dsp, unsigned char *data,
+   int count);
+int sysdep_dsp_get_max_freespace(struct sysdep_dsp_struct *dsp);
+
+#include "end_code.h"
+#endif /* ifndef __SYSDEP_DSP_H */
diff --git a/src/unix/sysdep/sysdep_dsp_plugins.h b/src/unix/sysdep/sysdep_dsp_plugins.h
new file mode 100644
index 0000000..e25403a
--- /dev/null
+++ b/src/unix/sysdep/sysdep_dsp_plugins.h
@@ -0,0 +1,65 @@
+/* Sysdep sound dsp plugins listing
+   Copyright 2000 Hans de Goede
+   
+   This file and the acompanying files in this directory are free software;
+   you can redistribute them and/or modify them under the terms of the GNU
+   Library General Public License as published by the Free Software Foundation;
+   either version 2 of the License, or (at your option) any later version.
+
+   These files are distributed in the hope that they will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with these files; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.
+*/
+#ifndef __SYSDEP_DSP_PLUGINS_H
+#define __SYSDEP_DSP_PLUGINS_H
+#include "plugin_manager.h"
+#include "begin_code.h"
+
+#ifdef SYSDEP_DSP_OSS
+extern struct plugin_struct sysdep_dsp_oss;
+#endif
+#ifdef SYSDEP_DSP_NETBSD
+extern struct plugin_struct sysdep_dsp_netbsd;
+#endif
+#ifdef SYSDEP_DSP_SOLARIS
+extern struct plugin_struct sysdep_dsp_solaris;
+#endif
+#ifdef SYSDEP_DSP_SOUNDKIT
+extern struct plugin_struct sysdep_dsp_soundkit;
+#endif
+#ifdef SYSDEP_DSP_COREAUDIO
+extern struct plugin_struct sysdep_dsp_coreaudio;
+#endif
+#ifdef SYSDEP_DSP_IRIX
+extern struct plugin_struct sysdep_dsp_irix;
+#endif
+#ifdef SYSDEP_DSP_AIX
+extern struct plugin_struct sysdep_dsp_aix;
+#endif
+#ifdef SYSDEP_DSP_ESOUND
+extern struct plugin_struct sysdep_dsp_esound;
+#endif
+#ifdef SYSDEP_DSP_ALSA
+extern struct plugin_struct sysdep_dsp_alsa;
+#endif
+#ifdef SYSDEP_DSP_ARTS_TEIRA
+extern struct plugin_struct sysdep_dsp_arts;
+#endif
+#ifdef SYSDEP_DSP_ARTS_SMOTEK
+extern struct plugin_struct sysdep_dsp_arts;
+#endif
+#ifdef SYSDEP_DSP_SDL
+extern struct plugin_struct sysdep_dsp_sdl;
+#endif
+#ifdef SYSDEP_DSP_WAVEOUT
+extern struct plugin_struct sysdep_dsp_waveout;
+#endif
+
+#include "end_code.h"
+#endif /* ifndef __SYSDEP_DSP_PLUGINS_H */
diff --git a/src/unix/sysdep/sysdep_dsp_priv.h b/src/unix/sysdep/sysdep_dsp_priv.h
new file mode 100644
index 0000000..afbefd2
--- /dev/null
+++ b/src/unix/sysdep/sysdep_dsp_priv.h
@@ -0,0 +1,53 @@
+/* Sysdep sound dsp object
+
+   Copyright 2000 Hans de Goede
+   
+   This file and the acompanying files in this directory are free software;
+   you can redistribute them and/or modify them under the terms of the GNU
+   Library General Public License as published by the Free Software Foundation;
+   either version 2 of the License, or (at your option) any later version.
+
+   These files are distributed in the hope that they will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with these files; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.
+*/
+#ifndef __SYSDEP_DSP_PRIV_H
+#define __SYSDEP_DSP_PRIV_H
+
+#include "misc.h"
+#include "begin_code.h"
+
+struct sysdep_dsp_info {
+   int samplerate;
+   int type;
+   int bufsize;
+};
+
+struct sysdep_dsp_struct {
+   struct sysdep_dsp_info hw_info;
+   struct sysdep_dsp_info emu_info;
+   unsigned char *convert_buf;
+   uclock_t last_update;
+   void *_priv;
+   int (*get_freespace)(struct sysdep_dsp_struct *dsp);
+   int (*write)(struct sysdep_dsp_struct *dsp, unsigned char *data,
+      int count);
+   void (*destroy)(struct sysdep_dsp_struct *dsp);
+};
+
+struct sysdep_dsp_create_params {
+   float bufsize;
+   const char *device;
+   int samplerate;
+   int type;
+   int flags;
+};
+
+#include "end_code.h"
+#endif /* ifndef __SYSDEP_DSP_PRIV_H */
diff --git a/src/unix/sysdep/sysdep_mixer.c b/src/unix/sysdep/sysdep_mixer.c
new file mode 100644
index 0000000..a923113
--- /dev/null
+++ b/src/unix/sysdep/sysdep_mixer.c
@@ -0,0 +1,263 @@
+/* Sysdep sound mixer object
+
+   Copyright 2000 Hans de Goede
+   
+   This file and the acompanying files in this directory are free software;
+   you can redistribute them and/or modify them under the terms of the GNU
+   Library General Public License as published by the Free Software Foundation;
+   either version 2 of the License, or (at your option) any later version.
+
+   These files are distributed in the hope that they will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with these files; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.
+*/
+/* Changelog
+Version 0.1, February 2000
+-initial release (Hans de Goede)
+Version 0.2, March 2000
+-added a plugin parameter to create, to override the global plugin
+ configuration (Hans de Goede)
+-protected sysdep_mixer_init against being called twice (Hans de Goede)
+*/
+#include "sysdep_mixer.h"
+#include "sysdep_mixer_priv.h"
+#include "sysdep_mixer_plugins.h"
+
+/* #define SYSDEP_MIXER_DEBUG */
+
+/* private func prototypes */
+static int sysdep_mixer_list_plugins(struct rc_option *option,
+   const char *arg, int priority);
+
+/* private variables */
+static char *sysdep_mixer_plugin = NULL;
+static struct rc_struct *sysdep_mixer_rc = NULL;
+static struct plugin_manager_struct *sysdep_mixer_plugin_manager = NULL;
+static struct rc_option sysdep_mixer_opts[] = {
+   /* name, shortname, type, dest, deflt, min, max, func, help */
+   { "Sound mixer related", NULL,		rc_seperator,	NULL,
+     NULL,		0,			0,		NULL,
+     NULL },
+   { "sound-mixer-plugin", "smp",		rc_string,	&sysdep_mixer_plugin,
+     NULL,		0,			0,		NULL,
+     "Select which plugin to use for the sound mixer" },
+   { "list-mixer-plugins", "lmp",		rc_use_function_no_arg, NULL,
+     NULL,		0,			0,		sysdep_mixer_list_plugins,
+     "List available sound-mixer plugins" },
+   { NULL,		NULL,			rc_end,		NULL,
+     NULL,		0,			0,		NULL,
+     NULL }
+};
+static const struct plugin_struct *sysdep_mixer_plugins[] = {
+#ifdef SYSDEP_MIXER_OSS
+   &sysdep_mixer_oss,
+#endif
+#ifdef SYSDEP_MIXER_NETBSD
+   &sysdep_mixer_netbsd,
+#endif
+#ifdef SYSDEP_MIXER_SOLARIS
+   &sysdep_mixer_solaris,
+#endif
+#ifdef SYSDEP_MIXER_NEXT
+   &sysdep_mixer_next,
+#endif
+#ifdef DSYSDEP_MIXER_IRIX
+   &sysdep_mixer_irix,
+#endif
+#ifdef DSYSDEP_MIXER_AIX
+   &sysdep_mixer_aix,
+#endif
+   NULL
+};
+#ifdef SYSDEP_MIXER_DEBUG
+const char *sysdep_mixer_names[] = SYSDEP_MIXER_NAMES;
+#endif
+
+/* private methods */
+static int sysdep_mixer_list_plugins(struct rc_option *option,
+   const char *arg, int priority)
+{
+   fprintf(stdout, "Sound mixer plugins:\n\n");
+   plugin_manager_list_plugins(sysdep_mixer_plugin_manager, stdout);
+   
+   return -1;
+}
+
+/* public methods */
+int sysdep_mixer_init(struct rc_struct *rc, const char *plugin_path)
+{
+   if(!sysdep_mixer_rc)
+   {
+      if(rc && rc_register(rc, sysdep_mixer_opts))
+         return -1;
+      sysdep_mixer_rc = rc;
+   }
+   
+   if(!sysdep_mixer_plugin_manager)
+   {
+      if(!(sysdep_mixer_plugin_manager = plugin_manager_create("sysdep_mixer",
+         rc)))
+      {
+         sysdep_mixer_exit();
+         return -1;
+      }
+      /* no need to fail here, if we don't have any plugins,
+         sysdep_mixer_create will always fail, but that doesn't have to be
+         fatal, failing here usually is! */
+      plugin_manager_register(sysdep_mixer_plugin_manager,
+         sysdep_mixer_plugins);
+      plugin_manager_load(sysdep_mixer_plugin_manager, plugin_path, NULL);
+      if(plugin_manager_init_plugin(sysdep_mixer_plugin_manager, NULL))
+      {
+         fprintf(stderr, "warning: no mixer plugins available\n");
+      }
+   }
+
+   return 0;
+}
+
+void sysdep_mixer_exit(void)
+{
+   if(sysdep_mixer_plugin_manager)
+   {
+      plugin_manager_destroy(sysdep_mixer_plugin_manager);
+      sysdep_mixer_plugin_manager = NULL;
+   }
+   if(sysdep_mixer_rc)
+   {
+      rc_unregister(sysdep_mixer_rc, sysdep_mixer_opts);
+      sysdep_mixer_rc = NULL;
+   }
+}
+
+struct sysdep_mixer_struct *sysdep_mixer_create(const char *plugin,
+   const char *device, int flags)
+{
+   int i;
+   struct sysdep_mixer_struct *mixer = NULL;
+   struct sysdep_mixer_create_params params;
+   
+   /* fill the params struct */
+   params.device = device;
+   
+   /* create the instance */
+   if(!(mixer = plugin_manager_create_instance(sysdep_mixer_plugin_manager,
+      plugin? plugin:sysdep_mixer_plugin, &params)))
+      return NULL;
+   
+   /* fill the mixer cache and save the original settings */
+   for(i = 0; i < SYSDEP_MIXER_CHANNELS; i++)
+   {
+      if(mixer->channel_available[i])
+      {
+#ifdef SYSDEP_MIXER_DEBUG
+	 fprintf(stderr, "debug: mixer got channel %s\n",
+	    sysdep_mixer_names[i]);
+#endif
+         if(mixer->get(mixer, i, &mixer->cache_left[i],
+            &mixer->cache_right[i]))
+         {
+            sysdep_mixer_destroy(mixer);
+            return NULL;
+         }
+         mixer->orig_left[i]  = mixer->cache_left[i];
+         mixer->orig_right[i] = mixer->cache_right[i];
+      }
+   }
+   
+   /* save our flags */
+   mixer->flags = flags;
+   
+   return mixer;
+}
+
+void sysdep_mixer_destroy(struct sysdep_mixer_struct *mixer)
+{
+   int i, left, right;
+   
+   /* restore orig settings if requested */
+   for(i = 0; i < SYSDEP_MIXER_CHANNELS; i++)
+   {
+      /* check that the channel wasn't modified under our ass */
+      sysdep_mixer_get(mixer, i, &left, &right);
+      if(mixer->restore_channel[i])
+      {
+#ifdef SYSDEP_MIXER_DEBUG
+         fprintf(stderr, "debug: sysdep_mixer: restoring channel %s\n",
+	    sysdep_mixer_names[i]);
+#endif
+         sysdep_mixer_set(mixer, i, mixer->orig_left[i],
+            mixer->orig_right[i]);
+      }
+   }
+   mixer->destroy(mixer);
+}
+
+int sysdep_mixer_channel_available(struct sysdep_mixer_struct *mixer,
+   int channel)
+{
+   return mixer->channel_available[channel];
+}
+
+int sysdep_mixer_set(struct sysdep_mixer_struct *mixer, int channel,
+   int left, int right)
+{
+   if(!mixer->channel_available[channel])
+      return -1;
+
+   if(mixer->set(mixer, channel, left, right))
+      return -1;
+   
+   mixer->cache_left[channel]  = left;
+   mixer->cache_right[channel] = right;
+   if(mixer->flags & SYSDEP_MIXER_RESTORE_SETTINS_ON_EXIT)
+      mixer->restore_channel[channel] = 1;
+   
+   return 0;
+}
+
+int sysdep_mixer_get(struct sysdep_mixer_struct *mixer, int channel,
+   int *left, int *right)
+{
+   if(!mixer->channel_available[channel])
+      return -1;
+
+   if(mixer->get(mixer, channel, left, right))
+      return -1;
+   
+   /* if we're close to the cached values use the cache, to avoid repeated
+      calls to get->set, causing the volume to slide */
+   if((*left >= (mixer->cache_left[channel] - 5)) &&
+      (*left <= (mixer->cache_left[channel] + 5)) &&
+      (*right >= (mixer->cache_right[channel] - 5)) &&
+      (*right <= (mixer->cache_right[channel] + 5)))
+   {
+#ifdef SYSDEP_MIXER_DEBUG
+      fprintf(stderr, "debug: sysdep_mixer: cached\n");
+#endif
+      *left = mixer->cache_left[channel];
+      *right = mixer->cache_right[channel];
+   }
+   else 
+   {
+#ifdef SYSDEP_MIXER_DEBUG
+      fprintf(stderr, "debug: sysdep_mixer: modified under our ass\n");
+#endif
+      /* The channel was modified under our ass, no need to restore it anymore.
+         Save the new values as original values, so that if we change it
+         later on we restore the new values */
+      mixer->restore_channel[channel] = 0;
+      mixer->cache_left[channel]  = *left;
+      mixer->cache_right[channel] = *right;
+      mixer->orig_left[channel]  = *left;
+      mixer->orig_right[channel] = *right;
+   }
+      
+   return 0;
+}
diff --git a/src/unix/sysdep/sysdep_mixer.h b/src/unix/sysdep/sysdep_mixer.h
new file mode 100644
index 0000000..947a349
--- /dev/null
+++ b/src/unix/sysdep/sysdep_mixer.h
@@ -0,0 +1,62 @@
+/* Sysdep sound mixer object
+
+   Copyright 2000 Hans de Goede
+   
+   This file and the acompanying files in this directory are free software;
+   you can redistribute them and/or modify them under the terms of the GNU
+   Library General Public License as published by the Free Software Foundation;
+   either version 2 of the License, or (at your option) any later version.
+
+   These files are distributed in the hope that they will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with these files; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.
+*/
+#ifndef __SYSDEP_MIXER_H
+#define __SYSDEP_MIXER_H
+
+#include "rc.h"
+#include "begin_code.h"
+
+/* channel defines */
+#define SYSDEP_MIXER_VOLUME	0
+#define SYSDEP_MIXER_PCM1	1
+#define SYSDEP_MIXER_PCM2	2
+#define SYSDEP_MIXER_SYNTH	3
+#define SYSDEP_MIXER_CD		4
+#define SYSDEP_MIXER_LINE1	5
+#define SYSDEP_MIXER_LINE2	6
+#define SYSDEP_MIXER_LINE3	7
+#define SYSDEP_MIXER_BASS	8
+#define SYSDEP_MIXER_TREBLE	9
+#define SYSDEP_MIXER_CHANNELS	10
+#define SYSDEP_MIXER_NAMES { "Volume", "PCM 1", "PCM 2", "Synth", \
+   "CD", "Line 1", "Line 2", "Line 3", "Bass", "Treble" }
+
+/* flags for sysdep_mixer_create */
+#define SYSDEP_MIXER_RESTORE_SETTINS_ON_EXIT 0x01
+
+struct sysdep_mixer_struct;
+
+int sysdep_mixer_init(struct rc_struct *rc, const char *plugin_path);
+void sysdep_mixer_exit(void);
+
+struct sysdep_mixer_struct *sysdep_mixer_create(const char *plugin,
+   const char *device, int flags);
+void sysdep_mixer_destroy(struct sysdep_mixer_struct *dsp);
+
+int sysdep_mixer_channel_available(struct sysdep_mixer_struct *mixer,
+   int channel);
+
+int sysdep_mixer_set(struct sysdep_mixer_struct *mixer, int channel,
+   int left, int right);
+int sysdep_mixer_get(struct sysdep_mixer_struct *mixer, int channel,
+   int *left, int *right);
+
+#include "end_code.h"
+#endif /* ifndef __SYSDEP_MIXER_H */
diff --git a/src/unix/sysdep/sysdep_mixer_plugins.h b/src/unix/sysdep/sysdep_mixer_plugins.h
new file mode 100644
index 0000000..47736a5
--- /dev/null
+++ b/src/unix/sysdep/sysdep_mixer_plugins.h
@@ -0,0 +1,44 @@
+/* Sysdep sound mixer plugins listing
+   Copyright 2000 Hans de Goede
+   
+   This file and the acompanying files in this directory are free software;
+   you can redistribute them and/or modify them under the terms of the GNU
+   Library General Public License as published by the Free Software Foundation;
+   either version 2 of the License, or (at your option) any later version.
+
+   These files are distributed in the hope that they will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with these files; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.
+*/
+#ifndef __SYSDEP_MIXER_PLUGINS_H
+#define __SYSDEP_MIXER_PLUGINS_H
+#include "plugin_manager.h"
+#include "begin_code.h"
+
+#ifdef SYSDEP_MIXER_OSS
+extern struct plugin_struct sysdep_mixer_oss;
+#endif
+#ifdef SYSDEP_MIXER_NETBSD
+extern struct plugin_struct sysdep_mixer_netbsd;
+#endif
+#ifdef SYSDEP_MIXER_SOLARIS
+extern struct plugin_struct sysdep_mixer_solaris;
+#endif
+#ifdef SYSDEP_MIXER_NEXT
+extern struct plugin_struct sysdep_mixer_next;
+#endif
+#ifdef SYSDEP_MIXER_IRIX
+extern struct plugin_struct sysdep_mixer_irix;
+#endif
+#ifdef SYSDEP_MIXER_AIX
+extern struct plugin_struct sysdep_mixer_aix;
+#endif
+
+#include "end_code.h"
+#endif /* ifndef __SYSDEP_MIXER_PLUGINS_H */
diff --git a/src/unix/sysdep/sysdep_mixer_priv.h b/src/unix/sysdep/sysdep_mixer_priv.h
new file mode 100644
index 0000000..c406de7
--- /dev/null
+++ b/src/unix/sysdep/sysdep_mixer_priv.h
@@ -0,0 +1,46 @@
+/* Sysdep sound mixer object
+
+   Copyright 2000 Hans de Goede
+   
+   This file and the acompanying files in this directory are free software;
+   you can redistribute them and/or modify them under the terms of the GNU
+   Library General Public License as published by the Free Software Foundation;
+   either version 2 of the License, or (at your option) any later version.
+
+   These files are distributed in the hope that they will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with these files; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.
+*/
+#ifndef __SYSDEP_MIXER_PRIV_H
+#define __SYSDEP_MIXER_PRIV_H
+#include "sysdep_mixer.h"
+#include "begin_code.h"
+
+struct sysdep_mixer_struct {
+   int flags;
+   char channel_available[SYSDEP_MIXER_CHANNELS];
+   char restore_channel[SYSDEP_MIXER_CHANNELS];
+   int cache_left[SYSDEP_MIXER_CHANNELS];
+   int cache_right[SYSDEP_MIXER_CHANNELS];
+   int orig_left[SYSDEP_MIXER_CHANNELS];
+   int orig_right[SYSDEP_MIXER_CHANNELS];
+   void *_priv;
+   int (*set)(struct sysdep_mixer_struct *mixer, int channel, int left,
+      int right);
+   int (*get)(struct sysdep_mixer_struct *mixer, int channel, int *left,
+      int *right);
+   void (*destroy)(struct sysdep_mixer_struct *mixer);
+};
+
+struct sysdep_mixer_create_params {
+   const char *device;
+};
+
+#include "end_code.h"
+#endif /* ifndef __SYSDEP_MIXER_PRIV_H */
diff --git a/src/unix/sysdep/sysdep_palette.c b/src/unix/sysdep/sysdep_palette.c
new file mode 100644
index 0000000..f2667e6
--- /dev/null
+++ b/src/unix/sysdep/sysdep_palette.c
@@ -0,0 +1,210 @@
+/* Sysdep palette abstraction and emulation object
+
+   Copyright 1999,2000 Hans de Goede
+   
+   This file and the acompanying files in this directory are free software;
+   you can redistribute them and/or modify them under the terms of the GNU
+   Library General Public License as published by the Free Software Foundation;
+   either version 2 of the License, or (at your option) any later version.
+
+   These files are distributed in the hope that they will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with these files; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.
+*/
+/* Changelog
+Version 0.1, November 1999
+-initial release (Hans de Goede)
+*/
+#include <stdio.h>
+#include <stdlib.h>
+#include <driver.h>
+#include <math.h>
+#include "sysdep_palette.h"
+
+/* from xmame.h, since in the future we want this to be entirely mame
+   independent */
+extern struct sysdep_palette_info display_palette_info;
+int  sysdep_display_alloc_palette(int writable_colors);
+int  sysdep_display_set_pen(int pen, unsigned char red, unsigned char green, unsigned char blue);
+extern int widthscale, heightscale;
+
+/* private methods */
+static int sysdep_palette_make_pen_from_info(struct sysdep_palette_info
+   *info, unsigned char red, unsigned char green, unsigned char blue)
+{
+   int pen = 0;
+   
+   /* are the shifts initialised ? */
+   if(!info->red_shift)
+   {
+      for(pen = 1 << (8 * sizeof(pen) - 1); pen && (!(pen & info->red_mask));
+         pen >>= 1, info->red_shift++);
+
+      for(pen = 1 << (8 * sizeof(pen) - 1); pen && (!(pen & info->green_mask));
+         pen >>= 1, info->green_shift++);
+
+      for(pen = 1 << (8 * sizeof(pen) - 1); pen && (!(pen & info->blue_mask));
+         pen >>= 1, info->blue_shift++);
+   }
+   
+   pen  = ((red   << 24) >> info->red_shift)   & info->red_mask;
+   pen |= ((green << 24) >> info->green_shift) & info->green_mask;
+   pen |= ((blue  << 24) >> info->blue_shift)  & info->blue_mask;
+   
+   return pen;
+}
+
+
+/* public methods */
+struct sysdep_palette_struct *sysdep_palette_create(int depth,
+   int writable_colors)
+{
+   int r,g,b;
+   struct sysdep_palette_struct *palette = NULL;
+   int lookup_size = 0;
+   
+   /* verify if the display can handle the requested depth */
+   if ( display_palette_info.depth < depth )
+   {
+      fprintf(stderr,
+         "error in sysdep_palette_create: %d bpp requested on a %d bpp display\n",
+         depth, display_palette_info.depth);
+      return NULL;
+   }
+   
+/* If the display gets recreated this must be done again, but the
+   palette can be kept, so now the creator of the display is responsible
+   for calling this. Also because there can be 2 palette's for one
+   display (the normal and debugger one in xmame for example) */
+#if 0
+   /* if the display is 8 bpp allocate the necessary pens for displays
+      with a shared palette like X */
+   if (display_palette_info.depth == 8)
+      if (sysdep_display_alloc_palette(writable_colors))
+         return NULL;
+#endif
+   
+   /* allocate the palette struct */
+   if (!(palette = calloc(1, sizeof(struct sysdep_palette_struct))))
+   {
+      fprintf(stderr,
+         "error malloc failed for struct sysdep_palette_struct\n");
+      return NULL;
+   }
+   
+   lookup_size = writable_colors;
+   if (!(palette->lookup = calloc(lookup_size, sizeof(int))))
+   {
+      fprintf(stderr, "error malloc failed for color lookup table\n");
+      sysdep_palette_destroy(palette);
+      return NULL;
+   }
+      
+   /* do we need to fill the lookup table? */
+
+   for(r=0; r<32; r++)
+      for(g=0; g<32; g++)
+         for(b=0; b<32; b++)
+            palette->lookup[r*1024 + g*32 + b] =
+               sysdep_palette_make_pen_from_info(&display_palette_info,
+                  r*8, g*8, b*8);
+   
+   /* build the emulated palette info */
+   palette->emulated.writable_colors = writable_colors;
+   palette->emulated.depth           = depth;
+   /* fill in the masks and shifts if necessary */
+
+   /* if we're emulating a truecolor palette and we use a lookup
+      table, we always emulate 555 rgb */
+   palette->emulated.red_mask    = 0x7C00;
+   palette->emulated.green_mask  = 0x03E0;
+   palette->emulated.blue_mask   = 0x001F;
+   
+   return palette;
+}
+
+/* destructor */
+void sysdep_palette_destroy(struct sysdep_palette_struct *palette)
+{
+   free(palette->lookup);
+   free(palette);
+}
+
+/* for pseudo color modes */
+int sysdep_palette_set_pen(struct sysdep_palette_struct *palette, int pen,
+   unsigned char red, unsigned char green, unsigned char blue)
+{
+   palette->lookup[pen] = sysdep_palette_make_pen_from_info(
+                             &display_palette_info, red, green, blue);
+
+   return 0;
+}
+
+
+/* for true color modes */
+int sysdep_palette_make_pen(struct sysdep_palette_struct *palette,
+   unsigned char red, unsigned char green, unsigned char blue)
+{
+   return sysdep_palette_make_pen_from_info(&palette->emulated, red, green,
+      blue);
+}
+
+
+/* This is broken, and for now is no longer used, instead
+   sysdep_palette_marked dirty should be used,
+   and display_alloc_palette palette must be called every time a dispay is
+   created. So also on recreation! */
+int sysdep_palette_change_display(struct sysdep_palette_struct **palette)
+{
+   struct sysdep_palette_struct *new_palette = NULL;
+   
+   if(!(new_palette=sysdep_palette_create((*palette)->emulated.depth,
+      (*palette)->emulated.writable_colors)))
+      return -1;
+   
+   /* check that the color masks of the new palette are the same as the old
+      colormasks, otherwise barf for now, we could emulate them later on
+      as follows:
+      - close new_palette
+      - recreate new_palette writable
+      - set all the pens of new_palette so that they match
+        the old masks.
+      - modify new_palette->emulated so that it becomes non-wrtiable,
+        with the masks of the old palette.
+      However if we're going this way, we might just as well
+      add the possibility to sysdep_palette_create to force specific 
+      colormasks, which we might want in the future anyway
+   */
+   if ( ((*palette)->emulated.red_mask   != new_palette->emulated.red_mask) ||
+        ((*palette)->emulated.green_mask != new_palette->emulated.green_mask) ||
+        ((*palette)->emulated.blue_mask  != new_palette->emulated.blue_mask))
+   {
+      fprintf(stderr, "error recreating palette, colormasks don't match!\n");
+      sysdep_palette_destroy(new_palette);
+      return -1;
+   }
+   
+   sysdep_palette_destroy(*palette);
+   *palette = new_palette;
+
+   return 0;
+}
+
+/* Added by AMR for the Xv Patch, which needs to be informed
+   when the palette lookup table has changed, so it can create
+   a matching YUV table */
+void sysdep_palette_mark_dirty(struct sysdep_palette_struct *palette)
+{
+   palette->dirty = 1;
+}
+
+void sysdep_palette_clear_dirty(struct sysdep_palette_struct *palette)
+{
+   palette->dirty = 0;
+}
diff --git a/src/unix/sysdep/sysdep_palette.h b/src/unix/sysdep/sysdep_palette.h
new file mode 100644
index 0000000..ea41de5
--- /dev/null
+++ b/src/unix/sysdep/sysdep_palette.h
@@ -0,0 +1,103 @@
+/* Sysdep palette abstraction and emulation object
+
+   Copyright 1999,2000 Hans de Goede
+   
+   This file and the acompanying files in this directory are free software;
+   you can redistribute them and/or modify them under the terms of the GNU
+   Library General Public License as published by the Free Software Foundation;
+   either version 2 of the License, or (at your option) any later version.
+
+   These files are distributed in the hope that they will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with these files; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.
+*/
+#ifndef __SYSDEP_PALETTE_H
+#define __SYSDEP_PALETTE_H
+
+#include "begin_code.h"
+
+/* This struct is used to describe both the emulated palette and the
+   display's palette.
+   
+   The following modes are considered valid for the display's palette
+   (depth, writable_colors) :
+   8,  256
+   16, 0
+   24, 0
+   32, 0
+   
+   The following modes can be emulated:
+   8,  1-256
+   16, 0
+   16, 1-65536
+   
+   Using this code with a display with any other palette, or requesting
+   any other palette to be emulated is unsupported, and may result
+   in undefined behaviour.
+*/
+struct sysdep_palette_info
+{
+   int writable_colors; /* 0 for truecolor, the number of writable colors
+                           for psuedo color */
+   int depth;           /* pixel size (not colordepth!) in bpp (8,16,24,32) */
+   int red_shift;       /* shifts and masks to calculate true_color palette */
+   int green_shift;     /* entries */
+   int blue_shift;
+   int red_mask;
+   int green_mask;
+   int blue_mask;
+};
+
+struct sysdep_palette_struct
+{
+   struct sysdep_palette_info emulated;
+   int dirty;             /* Used by the Xv patch for updating YUV lookup */
+   int *lookup;           /* lookup table to be used for blitters to convert
+                             the emulated palette to the physical palette */
+};
+
+/* This function creates a sysdep palette object for the current
+   display, which can be used with the display update functios.
+
+   Parameters:
+   depth           Color depth of the palette to be emulated valid values:
+                   8 or 16.
+   writable_colors The number of writable colors you want or 0 if you want
+                   true color. Valid values for depth == 8: 1-256, for
+                   depth == 16: 0-65536.
+                   
+   Return value:
+   A pointer to the sysdep palette object, or NULL on failure.
+   Upon failure an error message wil be printed to stderr.
+*/
+struct sysdep_palette_struct *sysdep_palette_create(int depth,
+   int writable_colors);
+   
+/* destructor */
+void sysdep_palette_destroy(struct sysdep_palette_struct *palette);
+
+/* for pseudo color modes */   
+int sysdep_palette_set_pen(struct sysdep_palette_struct *palette, int pen,
+   unsigned char red, unsigned char green, unsigned char blue);
+   
+/* for true color modes */   
+int sysdep_palette_make_pen(struct sysdep_palette_struct *palette,
+   unsigned char red, unsigned char green, unsigned char blue);
+
+/* This function has to be called if the display is changed, it recreates
+   the palette object with the settings from the new display */
+int sysdep_palette_change_display(struct sysdep_palette_struct **palette);
+
+/* Added by AMR for Xv patch - used for updating YUV palette */
+void sysdep_palette_mark_dirty(struct sysdep_palette_struct *palette);
+
+void sysdep_palette_clear_dirty(struct sysdep_palette_struct *palette);
+
+#include "end_code.h"
+#endif /* ifndef __SYSDEP_PALETTE_H */
diff --git a/src/unix/sysdep/unused/parser.c b/src/unix/sysdep/unused/parser.c
new file mode 100644
index 0000000..88b1de2
--- /dev/null
+++ b/src/unix/sysdep/unused/parser.c
@@ -0,0 +1,159 @@
+/* A simple text parser
+
+   Copyright 1999,2000 Hans de Goede
+   
+   This file and the acompanying files in this directory are free software;
+   you can redistribute them and/or modify them under the terms of the GNU
+   Library General Public License as published by the Free Software Foundation;
+   either version 2 of the License, or (at your option) any later version.
+
+   These files are distributed in the hope that they will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with these files; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.
+*/
+/* TODO:
+- allow unlimited number of arguments
+- check for comments ('#'), to allow parsing files
+- check for to much arguments
+- allow registering / removing parser elements
+- make a copy of the string before parsing it, make string a const * ?
+- put parser_struct in parser_priv.h
+*/
+/* Changelog
+Version 0.1, November 1999
+-initial release (Hans de Goede)
+Version 0.2, December 1999
+-changed parser_parse_tokens to take the command as a seperate argument
+ instead of using token[0], this allows the caller to remove the - for
+ a commandline option for example. (Hans de Goede)
+*/
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include "parser.h"
+
+struct parser_struct *parser_create(const struct parser_element *element[])
+{
+   int i,j;
+   struct parser_struct *parser = NULL;
+   
+   if (!element)
+      return NULL;
+      
+   for(i=0; element[i]; i++)
+   {
+      for(j=0; element[i][j].name; j++)
+      {
+         if(element[i][j].arg_count > BUF_SIZE)
+         {
+            fprintf(stderr,
+               "error parser doesn't support commands with more then %d arguments",
+               BUF_SIZE);
+            return NULL;
+         }
+      }
+   }
+   
+   if (!(parser = calloc(1, sizeof(struct parser_struct))))
+   {
+      fprintf(stderr, "error malloc failed for struct parser_struct");
+      return NULL;
+   }
+   parser->element = element;
+   return parser;
+}
+
+void parser_destroy(struct parser_struct *parser)
+{
+   if (parser)
+      free(parser);
+}
+
+static const struct parser_element *parser_find_element(
+   struct parser_struct *parser, const char *command)
+{
+   int i,j;
+   
+   for(i=0; parser->element[i]; i++)
+   {
+      for(j=0; parser->element[i][j].name; j++)
+      {
+         if(!strcmp(command, parser->element[i][j].name) ||
+            (parser->element[i][j].shortname &&
+               !strcmp(command, parser->element[i][j].shortname)))
+         {
+            return &parser->element[i][j];
+         }
+      }
+   }
+   fprintf(stderr, "error unknown command: %s", command);
+   return NULL;
+}
+
+int parser_parse_string(struct parser_struct *parser, char *string)
+{
+   int i;
+   const char *command;
+   const char *arg[BUF_SIZE];
+   const struct parser_element *element = NULL;
+  
+   if(!(command = strtok(string, " \t\r\n")))
+      return 0;
+ 
+   if(!(element = parser_find_element(parser, command)))
+      return -1;
+
+   for(i=0; i < element->arg_count; i++)
+   {
+      arg[i] = strtok(NULL, " \t\r\n");
+      if (!arg[i])
+      {
+         fprintf(stderr, "error %s requires %d arguments",
+            element->name, element->arg_count);
+         return -1;
+      }
+   }
+   
+   return (*element->function)(arg, element->flags);
+}
+
+int parser_parse_tokens(struct parser_struct *parser, const char *command,
+   int tokenc, const char *tokenv[], int *tokens_used)
+{
+   const struct parser_element *element = NULL;
+   
+   *tokens_used = 0;
+      
+   if(!(element = parser_find_element(parser, command)))
+      return -1;
+
+   if (tokenc < element->arg_count)
+   {
+      fprintf(stderr, "error %s requires %d arguments",
+         element->name, element->arg_count);
+      return -1;
+   }
+   *tokens_used = element->arg_count;
+   return (*element->function)(tokenv, element->flags);
+}
+
+int parser_get_arg_count(struct parser_struct *parser, const char *command,
+   int *arg_count)
+{
+   const struct parser_element *element = NULL;
+   
+   *arg_count = 0;
+      
+   if(!(element = parser_find_element(parser, command)))
+      return -1;
+   
+   *arg_count = element->arg_count;
+   return 0;
+}
+
diff --git a/src/unix/sysdep/unused/parser.h b/src/unix/sysdep/unused/parser.h
new file mode 100644
index 0000000..6621dfa
--- /dev/null
+++ b/src/unix/sysdep/unused/parser.h
@@ -0,0 +1,52 @@
+/* A simple text parser
+
+   Copyright 1999,2000 Hans de Goede
+   
+   This file and the acompanying files in this directory are free software;
+   you can redistribute them and/or modify them under the terms of the GNU
+   Library General Public License as published by the Free Software Foundation;
+   either version 2 of the License, or (at your option) any later version.
+
+   These files are distributed in the hope that they will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with these files; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.
+*/
+#ifndef __PARSER_H
+#define __PARSER_H
+
+#include "begin_code.h"
+
+struct parser_element
+{
+   const char *name;
+   const char *shortname;
+   int (*function)(const char *arg[], void *flags);
+   int arg_count;
+   void *flags;
+};
+
+struct parser_struct
+{
+   const struct parser_element **element;
+};
+
+struct parser_struct *parser_create(const struct parser_element *element[]);
+
+void parser_destroy(struct parser_struct *parser);
+
+int parser_parse_string(struct parser_struct *parser, char *string);
+
+int parser_parse_tokens(struct parser_struct *parser, const char *command,
+   int tokenc, const char *tokenv[], int *tokens_used);
+   
+int parser_get_arg_count(struct parser_struct *parser, const char *command,
+   int *arg_count);
+
+#include "end_code.h"
+#endif /* ifndef __PARSER_H */
diff --git a/src/unix/ticker.c b/src/unix/ticker.c
new file mode 100644
index 0000000..188b497
--- /dev/null
+++ b/src/unix/ticker.c
@@ -0,0 +1,34 @@
+/* MAME headers */
+#include "osdepend.h"
+#include "sysdep/misc.h"
+
+/*============================================================ */
+/*	osd_cycles */
+/*============================================================ */
+
+cycles_t osd_cycles(void)
+{
+	return uclock();
+}
+
+
+
+/*============================================================ */
+/*	osd_cycles_per_second */
+/*============================================================ */
+
+cycles_t osd_cycles_per_second(void)
+{
+	return UCLOCKS_PER_SEC;
+}
+
+
+
+/*============================================================ */
+/*	osd_profiling_ticks */
+/*============================================================ */
+
+cycles_t osd_profiling_ticks(void)
+{
+	return 0;
+}
diff --git a/src/unix/ticker.h b/src/unix/ticker.h
new file mode 100644
index 0000000..e69de29
diff --git a/src/unix/unix.mak b/src/unix/unix.mak
new file mode 100644
index 0000000..e4888de
--- /dev/null
+++ b/src/unix/unix.mak
@@ -0,0 +1,469 @@
+##############################################################################
+# None user configurable settings
+##############################################################################
+
+# *** Comment this line to get verbose make output, for debugging build
+# problems
+# QUIET = 1
+
+
+##############################################################################
+# **** CPU dependent settings.
+##############################################################################
+#note : -D__CPU_$(MY_CPU) is added automaticly later on.
+CFLAGS.i386       = -DLSB_FIRST -DX86_ASM
+CFLAGS.i386_noasm = -DLSB_FIRST
+CFLAGS.ia64       = -DLSB_FIRST -DALIGN_INTS -DALIGN_SHORTS -D__LP64__
+CFLAGS.alpha      = -DLSB_FIRST -DALIGN_INTS -DALIGN_SHORTS -D__LP64__
+CFLAGS.m68k       = 
+CFLAGS.risc       = -DALIGN_INTS -DALIGN_SHORTS 
+CFLAGS.risc_lsb   = -DALIGN_INTS -DALIGN_SHORTS -DLSB_FIRST
+CFLAGS.mips       = -DALIGN_INTS -DALIGN_SHORTS -DSGI_FIX_MWA_NOP
+
+##############################################################################
+# **** Architecture dependent settings.
+##############################################################################
+LIBS.solaris       = -lnsl -lsocket
+LIBS.irix          = -laudio
+LIBS.irix_al       = -laudio
+LIBS.aix           = -lUMSobj
+LIBS.next	   = -framework SoundKit
+LIBS.macosx	   = -framework CoreAudio
+#LIBS.openbsd       = -lossaudio
+LIBS.nto	   = -lsocket -lasound
+LIBS.beos          = `$(SDL_CONFIG) --libs`
+
+##############################################################################
+# **** Display dependent settings.
+##############################################################################
+#first calculate the X11 Joystick driver settings, this is done here since
+#they are only valid for X11 based display methods
+ifdef JOY_X11
+JOY_X11_CFLAGS = -DX11_JOYSTICK "-DX11_JOYNAME='$(X11_JOYNAME)'" -DUSE_X11_JOYEVENTS
+JOY_X11_LIBS   = -lXi
+endif
+
+ifdef XINPUT_DEVICES
+XINPUT_DEVICES_CFLAGS = -DUSE_XINPUT_DEVICES
+XINPUT_DEVICES_LIBS = -lXi
+endif
+
+# svga and ggi also use $(X11LIB) since that's where zlib often is
+LIBS.x11        = $(X11LIB) $(JOY_X11_LIBS) $(XINPUT_DEVICES_LIBS) -lX11 -lXext
+LIBS.svgalib    = $(X11LIB) -lvga -lvgagl
+LIBS.ggi        = $(X11LIB) -lggi
+LIBS.xgl        = $(X11LIB) $(JOY_X11_LIBS) -lX11 -lXext $(GLLIBS) -ljpeg
+LIBS.xfx        = $(X11LIB) $(JOY_X11_LIBS) -lX11 -lXext -lglide2x
+LIBS.svgafx     = $(X11LIB) -lvga -lvgagl -lglide2x
+LIBS.openstep	= -framework AppKit
+LIBS.SDL	= $(X11LIB) `$(SDL_CONFIG) --libs`
+LIBS.photon2	= -L/usr/lib -lph -lphrender
+
+CFLAGS.x11      = $(X11INC) $(JOY_X11_CFLAGS) $(XINPUT_DEVICES_CFLAGS)
+CFLAGS.xgl      = $(X11INC) $(JOY_X11_CFLAGS) $(GLCFLAGS)
+CFLAGS.xfx      = $(X11INC) $(JOY_X11_CFLAGS) -I/usr/include/glide
+CFLAGS.svgafx   = -I/usr/include/glide
+CFLAGS.SDL      = $(X11INC) `$(SDL_CONFIG) --cflags` -D_REENTRANT
+CFLAGS.photon2	=
+
+ifdef X11_DGA
+INST.x11        = doinstallsuid
+else
+INST.x11	= doinstall
+endif
+INST.ggi        = doinstall
+INST.svgalib    = doinstallsuid
+INST.xgl        = doinstallsuid copycab
+INST.xfx        = doinstallsuid
+INST.svgafx     = doinstallsuid
+INST.SDL	= doinstall
+INST.photon2	= doinstall
+
+# handle X11 display method additonal settings
+ifdef X11_MITSHM
+CFLAGS.x11 += -DUSE_MITSHM
+endif
+ifdef X11_XV
+CFLAGS.x11 += -DUSE_XV -DUSE_HWSCALE
+LIBS.x11   += -lXv
+endif
+ifdef X11_DGA
+CFLAGS.x11 += -DUSE_DGA
+LIBS.x11   += -lXxf86dga -lXxf86vm
+endif
+ifdef TDFX_DGA_WORKAROUND
+CFLAGS.x11 +=  -DTDFX_DGA_WORKAROUND 
+endif
+ifdef X11_XIL
+CFLAGS.x11 += -DUSE_XIL
+LIBS.x11   += -lxil -lpthread
+endif
+
+
+##############################################################################
+# Quiet the compiler output if requested
+##############################################################################
+
+ifdef QUIET
+CC_COMMENT = 
+CC_COMPILE = @
+AR_OPTS = rc
+else
+CC_COMMENT = \#
+CC_COMPILE = 
+AR_OPTS = rcv
+endif
+
+
+##############################################################################
+# these are the object subdirectories that need to be created.
+##############################################################################
+OBJ     = $(NAME).obj
+
+CORE_OBJDIRS = $(OBJ) \
+	$(OBJ)/drivers $(OBJ)/machine $(OBJ)/vidhrdw $(OBJ)/sndhrdw \
+	$(OBJ)/cpu $(OBJ)/sound \
+	$(OBJ)/mess $(OBJ)/mess/cpu $(OBJ)/mess/formats $(OBJ)/mess/systems \
+	$(OBJ)/mess/machine $(OBJ)/mess/vidhrdw $(OBJ)/mess/sndhrdw \
+	$(OBJ)/mess/sound $(OBJ)/mess/devices $(OBJ)/mess/tools \
+	$(OBJ)/mess/tools/dat2html $(OBJ)/mess/tools/mkhdimg \
+	$(OBJ)/mess/tools/messroms $(OBJ)/mess/tools/imgtool \
+	$(OBJ)/mess/tools/mkimage $(OBJ)/mess/tools/makedep \
+	$(OBJ)/mess/tools/cgafont
+
+IMGTOOL_LIBS = -lz
+
+ifeq ($(TARGET), mess)
+INCLUDE_PATH = -I. -Imess -Isrc -Isrc/includes -Isrc/unix -I$(OBJ)/cpu/m68000 -Isrc/cpu/m68000
+else
+INCLUDE_PATH = -I. -Isrc -Isrc/includes -Isrc/unix -I$(OBJ)/cpu/m68000 -Isrc/cpu/m68000
+endif
+
+##############################################################################
+# "Calculate" the final CFLAGS, unix CONFIG, LIBS and OBJS
+##############################################################################
+ifdef ZLIB
+ZLIB    = src/unix/contrib/cutzlib-1.1.4/libz.a
+endif
+
+all: $(ZLIB) objdirs osdepend $(NAME).$(DISPLAY_METHOD)
+
+# CPU core include paths
+VPATH=src $(wildcard src/cpu/*)
+
+# Platform-dependent objects for imgtool
+PLATFORM_IMGTOOL_OBJS = $(OBJ)/unix.$(DISPLAY_METHOD)/dirio.o \
+			$(OBJ)/unix.$(DISPLAY_METHOD)/fileio.o \
+			$(OBJ)/unix.$(DISPLAY_METHOD)/sysdep/rc.o \
+			$(OBJ)/unix.$(DISPLAY_METHOD)/sysdep/misc.o
+
+include src/core.mak
+
+ifeq ($(TARGET), mess)
+include mess/mess.mak
+else
+include src/$(TARGET).mak
+endif
+
+include src/rules.mak
+
+ifeq ($(TARGET), mess)
+include mess/rules_ms.mak
+endif
+
+ifdef DEBUG
+DBGDEFS = -DMAME_DEBUG
+else
+DBGDEFS =
+DBGOBJS =
+endif
+
+# Perhaps one day original mame/mess sources will use POSIX strcasecmp and
+# M_PI instead MS-DOS counterparts... ( a long and sad history ...)
+# bcd - added DEFS to the list
+MY_CFLAGS = $(CFLAGS) $(IL) $(CFLAGS.$(MY_CPU)) \
+	-D__ARCH_$(ARCH) -D__CPU_$(MY_CPU) -D$(DISPLAY_METHOD) \
+	-Dstricmp=strcasecmp -Dstrnicmp=strncasecmp \
+	-DPI=M_PI -DXMAME -DUNIX -DSIGNED_SAMPLES -DCLIB_DECL= \
+	$(COREDEFS) $(SOUNDDEFS) $(CPUDEFS) $(ASMDEFS) $(DEFS)\
+	$(INCLUDES) $(INCLUDE_PATH)
+
+MY_LIBS = $(LIBS) $(LIBS.$(ARCH)) $(LIBS.$(DISPLAY_METHOD)) -lz
+
+ifdef SEPARATE_LIBM
+MY_LIBS += -lm
+endif
+
+ifdef ZLIB
+MY_CFLAGS += -Isrc/unix/contrib/cutzlib-1.1.4 -I../../contrib/cutzlib-1.1.4
+LDFLAGS   += -Lsrc/unix/contrib/cutzlib-1.1.4
+endif
+
+ifdef DEBUG
+MY_CFLAGS += -DMAME_DEBUG
+MY_LIBS   += -lcurses
+endif
+
+ifdef XMAME_NET
+MY_CFLAGS += -DXMAME_NET
+endif
+
+ifdef AVICAPTURE
+MY_CFLAGS += -DAVICAPTURE
+MY_LIBS += -lavcodec -lmp3lame
+OBJS += $(OBJ)/unix.x11/video-drivers/x11-avi.o
+endif
+   
+# CONFIG are the cflags used to build the unix tree, this is where most defines
+# go
+CONFIG = $(MY_CFLAGS) $(CFLAGS.$(DISPLAY_METHOD)) -DNAME='\"x$(TARGET)\"' \
+	-DDISPLAY_METHOD='\"$(DISPLAY_METHOD)\"' -DXMAMEROOT='\"$(XMAMEROOT)\"'
+
+ifdef HAVE_GETTIMEOFDAY
+CONFIG += -DHAVE_GETTIMEOFDAY
+endif
+
+# Sound drivers config
+ifdef SOUND_ESOUND
+CONFIG  += -DSYSDEP_DSP_ESOUND `esd-config --cflags`
+MY_LIBS += `esd-config --libs`
+endif
+
+ifdef SOUND_ALSA
+CONFIG  += -DSYSDEP_DSP_ALSA 
+MY_LIBS += -lasound
+endif
+
+ifdef SOUND_ARTS_TEIRA
+CONFIG  += -DSYSDEP_DSP_ARTS_TEIRA `artsc-config --cflags`
+MY_LIBS += `artsc-config --libs`
+endif
+
+ifdef SOUND_ARTS_SMOTEK
+CONFIG  += -DSYSDEP_DSP_ARTS_SMOTEK `artsc-config --cflags`
+MY_LIBS += `artsc-config --libs`
+endif
+
+ifdef SOUND_SDL
+CONFIG  += -DSYSDEP_DSP_SDL `$(SDL_CONFIG) --cflags`
+MY_LIBS += `$(SDL_CONFIG) --libs`
+endif
+
+ifdef SOUND_WAVEOUT
+CONFIG  += -DSYSDEP_DSP_WAVEOUT
+endif
+
+# Joystick drivers config
+ifdef JOY_I386
+CONFIG += -DI386_JOYSTICK
+endif
+ifdef JOY_PAD
+CONFIG += -DLIN_FM_TOWNS
+endif
+ifdef JOY_PS2
+CONFIG += -DPS2_JOYSTICK
+endif
+
+ifdef JOY_USB
+CONFIG += -DUSB_JOYSTICK
+ifeq ($(shell test -f /usr/include/usbhid.h && echo have_usbhid), have_usbhid)
+CONFIG += -DHAVE_USBHID_H
+MY_LIBS += -lusbhid
+else
+ifeq ($(shell test -f /usr/include/libusbhid.h && echo have_libusbhid), have_libusbhid)
+CONFIG += -DHAVE_LIBUSBHID_H
+MY_LIBS += -lusbhid
+else
+MY_LIBS += -lusb
+endif
+endif
+endif
+
+# Happ UGCI config
+ifdef UGCICOIN
+CONFIG += -DUGCICOIN
+MY_LIBS += -lugci
+endif
+
+ifdef EFENCE
+MY_LIBS += -lefence
+endif
+
+#we remove $(OBJ)/vidhrdw/vector.o from $(COREOBJS) since we have our own
+#build rules for this object because it is display dependent.
+OBJS  += $(subst $(OBJ)/vidhrdw/vector.o, ,$(COREOBJS)) $(DRVLIBS) \
+ $(OBJ)/unix.$(DISPLAY_METHOD)/osdepend.a $(OBJ)/unix.$(DISPLAY_METHOD)/vector.o
+
+MY_OBJDIRS = $(CORE_OBJDIRS) $(sort $(OBJDIRS))
+
+
+##############################################################################
+# Begin of the real makefile.
+##############################################################################
+$(NAME).$(DISPLAY_METHOD): $(OBJS)
+	$(CC_COMMENT) @echo 'Linking $@ ...'
+	$(CC_COMPILE) $(LD) $(LDFLAGS) -o $@ $(OBJS) $(MY_LIBS)
+
+tools: $(ZLIB) $(OBJDIRS) $(TOOLS)
+
+objdirs: $(MY_OBJDIRS)
+
+$(MY_OBJDIRS):
+	-mkdir $@
+
+xlistdev: src/unix/contrib/tools/xlistdev.c
+	$(CC_COMMENT) @echo 'Compiling $< ...'
+	$(CC_COMPILE) $(CC) $(X11INC) src/unix/contrib/tools/xlistdev.c -o xlistdev $(JSLIB) $(LIBS.$(ARCH)) $(LIBS.$(DISPLAY_METHOD)) -lXi -lm
+
+romcmp: $(OBJ)/romcmp.o $(OBJ)/unzip.o
+	$(CC_COMMENT) @echo Linking $@...
+	$(CC_COMPILE) $(LD) $(LDFLAGS) -o $@ $^ -lz
+
+hdcomp: $(OBJ)/hdcomp.o $(OBJ)/harddisk.o $(OBJ)/md5.o
+	$(CC_COMMENT) @echo Linking $@...
+	$(CC_COMMENT) $(LD) $(LDFLAGS) -o $@ $^ -lz
+
+osdepend:
+	$(CC_COMMENT) @echo 'Compiling in the unix directory...'
+	$(CC_COMPILE) \
+	 ( \
+	 cd src/unix; \
+	  $(MAKE) CC="$(CC)" RANLIB="$(RANLIB)" ARCH="$(ARCH)" \
+	  DISPLAY_METHOD="$(DISPLAY_METHOD)" CFLAGS="$(CONFIG)" \
+	  CC_COMMENT="$(CC_COMMENT)" CC_COMPILE="$(CC_COMPILE)" \
+	  AR_OPTS="$(AR_OPTS)" OBJ="$(OBJ)" \
+	 )
+
+src/unix/contrib/cutzlib-1.1.4/libz.a:
+	( \
+	cd src/unix/contrib/cutzlib-1.1.4; \
+	./configure; \
+	$(MAKE) libz.a \
+	)
+
+ifdef MESS
+$(OBJ)/mess/%.o: mess/%.c
+	$(CC_COMMENT) @echo '[MESS] Compiling $< ...'
+	$(CC_COMPILE) $(CC) $(MY_CFLAGS) -o $@ -c $<
+endif
+
+$(OBJ)/%.o: src/%.c
+	$(CC_COMMENT) @echo 'Compiling $< ...'
+	$(CC_COMPILE) $(CC) $(MY_CFLAGS) -o $@ -c $<
+
+$(OBJ)/%.a:
+	$(CC_COMMENT) @echo 'Archiving $@ ...'
+	$(CC_COMPILE) ar $(AR_OPTS) $@ $^
+	$(CC_COMPILE) $(RANLIB) $@
+
+# special cases for the 68000 core
+#
+# compile generated C files for the 68000 emulator
+$(M68000_GENERATED_OBJS): $(OBJ)/cpu/m68000/m68kmake
+	$(CC_COMMENT) @echo Compiling $(subst .o,.c,$@)...
+	$(CC_COMPILE) $(CC) $(MY_CFLAGS) -c $*.c -o $@
+
+# additional rule, because m68kcpu.c includes the generated m68kops.h :-/
+$(OBJ)/cpu/m68000/m68kcpu.o: $(OBJ)/cpu/m68000/m68kmake
+
+# generate C source files for the 68000 emulator
+$(OBJ)/cpu/m68000/m68kmake: src/cpu/m68000/m68kmake.c
+	$(CC_COMMENT) @echo M68K make $<...
+	$(CC_COMPILE) $(CC) $(MY_CFLAGS) -DDOS -o $(OBJ)/cpu/m68000/m68kmake $<
+	$(CC_COMMENT) @echo Generating M68K source files...
+	$(CC_COMPILE) $(OBJ)/cpu/m68000/m68kmake $(OBJ)/cpu/m68000 src/cpu/m68000/m68k_in.c
+
+# generate asm source files for the 68000/68020 emulators
+$(OBJ)/cpu/m68000/68000.asm:  src/cpu/m68000/make68k.c
+	$(CC_COMMENT) @echo Compiling $<...
+	$(CC_COMPILE) $(CC) $(MY_CFLAGS) -O0 -DDOS -o $(OBJ)/cpu/m68000/make68k $<
+	$(CC_COMMENT) @echo Generating $@...
+	$(CC_COMPILE) $(OBJ)/cpu/m68000/make68k $@ $(OBJ)/cpu/m68000/68000tab.asm 00
+
+$(OBJ)/cpu/m68000/68020.asm:  src/cpu/m68000/make68k.c
+	$(CC_COMMENT) @echo Compiling $<...
+	$(CC_COMPILE) $(CC) $(MY_CFLAGS) -O0 -DDOS -o $(OBJ)/cpu/m68000/make68k $<
+	$(CC_COMMENT) @echo Generating $@...
+	$(CC_COMPILE) $(OBJ)/cpu/m68000/make68k $@ $(OBJ)/cpu/m68000/68020tab.asm 20
+
+# generated asm files for the 68000 emulator
+$(OBJ)/cpu/m68000/68000.o:  $(OBJ)/cpu/m68000/68000.asm
+	$(CC_COMMENT) @echo Assembling $<...
+	$(CC_COMPILE) $(ASM_STRIP) $<
+	$(CC_COMPILE) nasm $(NASM_FMT) -o $@ $(subst -D,-d,$(ASMDEFS)) $<
+
+$(OBJ)/cpu/m68000/68020.o:  $(OBJ)/cpu/m68000/68020.asm
+	$(CC_COMMENT) @echo Assembling $<...
+	$(CC_COMPILE) $(ASM_STRIP) $<
+	$(CC_COMPILE) nasm $(NASM_FMT) -o $@ $(subst -D,-d,$(ASMDEFS)) $<
+
+#some tricks, since vector.o these days is display method-dependent:
+$(OBJ)/unix.$(DISPLAY_METHOD)/vector.o: src/vidhrdw/vector.c
+	$(CC_COMMENT) @echo 'Compiling $< ...'
+	$(CC_COMPILE) $(CC) $(MY_CFLAGS) -o $@ -c $<
+
+$(OBJ)/unix.$(DISPLAY_METHOD)/video-drivers/x11-avi.o: src/unix/video-drivers/x11-avi.c
+	$(CC_COMMENT) @echo 'Compiling $< ...'
+	$(CC_COMPILE) $(CC) $(MY_CFLAGS) -o $@ -c $<
+
+#make sure this isn't accidently in makefile.$(OBJ):
+$(OBJ)/vidhrdw/vector.o: bla
+
+doc: doc/xmame-doc.txt doc/x$(TARGET)rc.dist doc/gamelist.$(TARGET) doc/x$(TARGET).6
+
+doc/xmame-doc.txt: doc/xmame-doc.sgml
+	cd doc; \
+	sgml2txt   -l en -p a4 -f          xmame-doc.sgml; \
+	sgml2html  -l en -p a4             xmame-doc.sgml; \
+	sgml2latex -l en -p a4 --output=ps xmame-doc.sgml; \
+	rm -f xmame-doc.lyx~
+	
+doc/x$(TARGET)rc.dist: all src/unix/xmamerc-keybinding-notes.txt
+	./x$(TARGET).$(DISPLAY_METHOD) -noloadconfig -showconfig | \
+	 grep -v loadconfig | tr "\033" \# > doc/x$(TARGET)rc.dist
+	cat src/unix/xmamerc-keybinding-notes.txt >> doc/x$(TARGET)rc.dist
+	
+doc/gamelist.$(TARGET): all
+	./x$(TARGET).$(DISPLAY_METHOD) -listgamelistheader > doc/gamelist.$(TARGET)
+	./x$(TARGET).$(DISPLAY_METHOD) -listgamelist >> doc/gamelist.$(TARGET)
+
+doc/x$(TARGET).6: all src/unix/xmame.6-1 src/unix/xmame.6-3
+	cat src/unix/xmame.6-1 > doc/x$(TARGET).6
+	./x$(TARGET).$(DISPLAY_METHOD) -noloadconfig -manhelp | \
+	 tr "\033" \# >> doc/x$(TARGET).6
+	cat src/unix/xmame.6-3 >> doc/x$(TARGET).6
+
+install: $(INST.$(DISPLAY_METHOD)) install-man
+	@echo $(NAME) for $(ARCH)-$(MY_CPU) installation completed
+
+install-man:
+	@echo installing manual pages under $(MANDIR) ...
+	-$(INSTALL_MAN_DIR) $(MANDIR)
+	$(INSTALL_MAN) doc/x$(TARGET).6 $(MANDIR)/x$(TARGET).6
+
+doinstall:
+	@echo installing binaries under $(BINDIR)...
+	-$(INSTALL_PROGRAM_DIR) $(BINDIR)
+	$(INSTALL_PROGRAM) $(NAME).$(DISPLAY_METHOD) $(BINDIR)
+
+doinstallsuid:
+	@echo installing binaries under $(BINDIR)...
+	-$(INSTALL_PROGRAM_DIR) $(BINDIR)
+	$(INSTALL_PROGRAM_SUID) $(NAME).$(DISPLAY_METHOD) $(BINDIR)
+
+copycab:
+	@echo installing cabinet files under $(XMAMEROOT)...
+	@for i in cab/*; do \
+	if test ! -d $(XMAMEROOT)/$$i; then \
+	$(INSTALL_DATA_DIR) $(XMAMEROOT)/$$i; fi; \
+	for j in $$i/*; do $(INSTALL_DATA) $$j $(XMAMEROOT)/$$i; done; done
+
+clean: 
+	rm -fr $(OBJ) $(NAME).* xlistdev src/unix/contrib/cutzlib-1.1.4/libz.a src/unix/contrib/cutzlib-1.1.4/*.o $(TOOLS)
+#	cd makedep; make clean
+
+clean68k:
+	@echo Deleting 68k files...
+	rm -f $(OBJ)/cpuintrf.o
+	rm -f $(OBJ)/drivers/cps2.o
+	rm -rf $(OBJ)/cpu/m68000
diff --git a/src/unix/video-drivers/SDL-keytable.h b/src/unix/video-drivers/SDL-keytable.h
new file mode 100644
index 0000000..5ce3f07
--- /dev/null
+++ b/src/unix/video-drivers/SDL-keytable.h
@@ -0,0 +1,514 @@
+unsigned char klookup[] = {
+	KEY_NONE            ,   /* SDLK_FIRST           = 0 */
+	KEY_NONE            ,   /* SDLK_NONE            = 1 */
+	KEY_NONE            ,   /* SDLK_NONE            = 2 */
+	KEY_NONE            ,   /* SDLK_NONE            = 3 */
+	KEY_NONE            ,   /* SDLK_NONE            = 4 */
+	KEY_NONE            ,   /* SDLK_NONE            = 5 */
+	KEY_NONE            ,   /* SDLK_NONE            = 6 */
+	KEY_NONE            ,   /* SDLK_NONE            = 7 */
+	KEY_BACKSPACE       ,   /* SDLK_BACKSPACE       = 8 */
+	KEY_TAB             ,   /* SDLK_TAB             = 9 */
+	KEY_NONE            ,   /* SDLK_NONE            = 10 */
+	KEY_NONE            ,   /* SDLK_NONE            = 11 */
+	KEY_NONE            ,   /* SDLK_CLEAR           = 12 */
+	KEY_ENTER           ,   /* SDLK_RETURN          = 13 */
+	KEY_NONE            ,   /* SDLK_NONE            = 14 */
+	KEY_NONE            ,   /* SDLK_NONE            = 15 */
+	KEY_NONE            ,   /* SDLK_NONE            = 16 */
+	KEY_NONE            ,   /* SDLK_NONE            = 17 */
+	KEY_NONE            ,   /* SDLK_NONE            = 18 */
+	KEY_PAUSE           ,   /* SDLK_PAUSE           = 19 */
+	KEY_NONE            ,   /* SDLK_NONE            = 20 */
+	KEY_NONE            ,   /* SDLK_NONE            = 21 */
+	KEY_NONE            ,   /* SDLK_NONE            = 22 */
+	KEY_NONE            ,   /* SDLK_NONE            = 23 */
+	KEY_NONE            ,   /* SDLK_NONE            = 24 */
+	KEY_NONE            ,   /* SDLK_NONE            = 25 */
+	KEY_NONE            ,   /* SDLK_NONE            = 26 */
+	KEY_ESC             ,   /* SDLK_ESCAPE          = 27 */
+	KEY_NONE            ,   /* SDLK_NONE            = 28 */
+	KEY_NONE            ,   /* SDLK_NONE            = 29 */
+	KEY_NONE            ,   /* SDLK_NONE            = 30 */
+	KEY_NONE            ,   /* SDLK_NONE            = 31 */
+	KEY_SPACE           ,   /* SDLK_SPACE           = 32 */
+	KEY_NONE            ,   /* SDLK_EXCLAIM         = 33 */
+	KEY_QUOTE           ,   /* SDLK_QUOTEDBL        = 34 */
+	KEY_NONE            ,   /* SDLK_HASH            = 35 */
+	KEY_NONE            ,   /* SDLK_DOLLAR          = 36 */
+	KEY_NONE            ,   /* SDLK_NONE            = 37 */
+	KEY_NONE            ,   /* SDLK_AMPERSAND       = 38 */
+	KEY_QUOTE           ,   /* SDLK_QUOTE           = 39 */
+	KEY_OPENBRACE       ,   /* SDLK_LEFTPAREN       = 40 NS */
+	KEY_CLOSEBRACE      ,   /* SDLK_RIGHTPAREN      = 41 NS */
+	KEY_ASTERISK        ,   /* SDLK_ASTERISK        = 42 */
+	KEY_NONE            ,   /* SDLK_PLUS            = 43 */
+	KEY_COMMA           ,   /* SDLK_COMMA           = 44 */
+	KEY_MINUS           ,   /* SDLK_MINUS           = 45 */
+	KEY_STOP            ,   /* SDLK_PERIOD          = 46 */
+	KEY_SLASH           ,   /* SDLK_SLASH           = 47 */
+	KEY_0               ,   /* SDLK_0               = 48 */
+	KEY_1               ,   /* SDLK_1               = 49 */
+	KEY_2               ,   /* SDLK_2               = 50 */
+	KEY_3               ,   /* SDLK_3               = 51 */
+	KEY_4               ,   /* SDLK_4               = 52 */
+	KEY_5               ,   /* SDLK_5               = 53 */
+	KEY_6               ,   /* SDLK_6               = 54 */
+	KEY_7               ,   /* SDLK_7               = 55 */
+	KEY_8               ,   /* SDLK_8               = 56 */
+	KEY_9               ,   /* SDLK_9               = 57 */
+	KEY_QUOTE           ,   /* SDLK_COLON           = 58 */
+	KEY_COLON           ,   /* SDLK_SEMICOLON       = 59 */
+	KEY_BACKSLASH2      ,   /* SDLK_LESS            = 60 */
+	KEY_EQUALS          ,   /* SDLK_EQUALS          = 61 */
+	KEY_NONE            ,   /* SDLK_GREATER         = 62 */
+	KEY_NONE            ,   /* SDLK_QUESTION        = 63 */
+	KEY_NONE            ,   /* SDLK_AT              = 64 */
+	KEY_NONE            ,   /* SDLK_NONE            = 65 */
+	KEY_NONE            ,   /* SDLK_NONE            = 66 */
+	KEY_NONE            ,   /* SDLK_NONE            = 67 */
+	KEY_NONE            ,   /* SDLK_NONE            = 68 */
+	KEY_NONE            ,   /* SDLK_NONE            = 69 */
+	KEY_NONE            ,   /* SDLK_NONE            = 70 */
+	KEY_NONE            ,   /* SDLK_NONE            = 71 */
+	KEY_NONE            ,   /* SDLK_NONE            = 72 */
+	KEY_NONE            ,   /* SDLK_NONE            = 73 */
+	KEY_NONE            ,   /* SDLK_NONE            = 74 */
+	KEY_NONE            ,   /* SDLK_NONE            = 75 */
+	KEY_NONE            ,   /* SDLK_NONE            = 76 */
+	KEY_NONE            ,   /* SDLK_NONE            = 77 */
+	KEY_NONE            ,   /* SDLK_NONE            = 78 */
+	KEY_NONE            ,   /* SDLK_NONE            = 79 */
+	KEY_NONE            ,   /* SDLK_NONE            = 80 */
+	KEY_NONE            ,   /* SDLK_NONE            = 81 */
+	KEY_NONE            ,   /* SDLK_NONE            = 82 */
+	KEY_NONE            ,   /* SDLK_NONE            = 83 */
+	KEY_NONE            ,   /* SDLK_NONE            = 84 */
+	KEY_NONE            ,   /* SDLK_NONE            = 85 */
+	KEY_NONE            ,   /* SDLK_NONE            = 86 */
+	KEY_NONE            ,   /* SDLK_NONE            = 87 */
+	KEY_NONE            ,   /* SDLK_NONE            = 88 */
+	KEY_NONE            ,   /* SDLK_NONE            = 89 */
+	KEY_NONE            ,   /* SDLK_NONE            = 90 */
+	KEY_OPENBRACE       ,   /* SDLK_LEFTBRACKET     = 91 */
+	KEY_BACKSLASH       ,   /* SDLK_BACKSLASH       = 92 */
+	KEY_CLOSEBRACE      ,   /* SDLK_RIGHTBRACKET    = 93 */
+	KEY_NONE            ,   /* SDLK_CARET           = 94 */
+	KEY_NONE            ,   /* SDLK_UNDERSCORE      = 95 */
+	KEY_TILDE           ,   /* SDLK_BACKQUOTE       = 96 */
+	KEY_A               ,   /* SDLK_a               = 97 */
+	KEY_B               ,   /* SDLK_b               = 98 */
+	KEY_C               ,   /* SDLK_c               = 99 */
+	KEY_D               ,   /* SDLK_d               = 100 */
+	KEY_E               ,   /* SDLK_e               = 101 */
+	KEY_F               ,   /* SDLK_f               = 102 */
+	KEY_G               ,   /* SDLK_g               = 103 */
+	KEY_H               ,   /* SDLK_h               = 104 */
+	KEY_I               ,   /* SDLK_i               = 105 */
+	KEY_J               ,   /* SDLK_j               = 106 */
+	KEY_K               ,   /* SDLK_k               = 107 */
+	KEY_L               ,   /* SDLK_l               = 108 */
+	KEY_M               ,   /* SDLK_m               = 109 */
+	KEY_N               ,   /* SDLK_n               = 110 */
+	KEY_O               ,   /* SDLK_o               = 111 */
+	KEY_P               ,   /* SDLK_p               = 112 */
+	KEY_Q               ,   /* SDLK_q               = 113 */
+	KEY_R               ,   /* SDLK_r               = 114 */
+	KEY_S               ,   /* SDLK_s               = 115 */
+	KEY_T               ,   /* SDLK_t               = 116 */
+	KEY_U               ,   /* SDLK_u               = 117 */
+	KEY_V               ,   /* SDLK_v               = 118 */
+	KEY_W               ,   /* SDLK_w               = 119 */
+	KEY_X               ,   /* SDLK_x               = 120 */
+	KEY_Y               ,   /* SDLK_y               = 121 */
+	KEY_Z               ,   /* SDLK_z               = 122 */
+	KEY_NONE            ,   /* SDLK_NONE            = 123 */
+	KEY_NONE            ,   /* SDLK_NONE            = 124 */
+	KEY_NONE            ,   /* SDLK_NONE            = 125 */
+	KEY_NONE            ,   /* SDLK_NONE            = 126 */
+	KEY_DEL             ,   /* SDLK_DELETE          = 127 */
+	KEY_NONE            ,   /* SDLK_NONE            = 128 */
+	KEY_NONE            ,   /* SDLK_NONE            = 129 */
+	KEY_NONE            ,   /* SDLK_NONE            = 130 */
+	KEY_NONE            ,   /* SDLK_NONE            = 131 */
+	KEY_NONE            ,   /* SDLK_NONE            = 132 */
+	KEY_NONE            ,   /* SDLK_NONE            = 133 */
+	KEY_NONE            ,   /* SDLK_NONE            = 134 */
+	KEY_NONE            ,   /* SDLK_NONE            = 135 */
+	KEY_NONE            ,   /* SDLK_NONE            = 136 */
+	KEY_NONE            ,   /* SDLK_NONE            = 137 */
+	KEY_NONE            ,   /* SDLK_NONE            = 138 */
+	KEY_NONE            ,   /* SDLK_NONE            = 139 */
+	KEY_NONE            ,   /* SDLK_NONE            = 140 */
+	KEY_NONE            ,   /* SDLK_NONE            = 141 */
+	KEY_NONE            ,   /* SDLK_NONE            = 142 */
+	KEY_NONE            ,   /* SDLK_NONE            = 143 */
+	KEY_NONE            ,   /* SDLK_NONE            = 144 */
+	KEY_NONE            ,   /* SDLK_NONE            = 145 */
+	KEY_NONE            ,   /* SDLK_NONE            = 146 */
+	KEY_NONE            ,   /* SDLK_NONE            = 147 */
+	KEY_NONE            ,   /* SDLK_NONE            = 148 */
+	KEY_NONE            ,   /* SDLK_NONE            = 149 */
+	KEY_NONE            ,   /* SDLK_NONE            = 150 */
+	KEY_NONE            ,   /* SDLK_NONE            = 151 */
+	KEY_NONE            ,   /* SDLK_NONE            = 152 */
+	KEY_NONE            ,   /* SDLK_NONE            = 153 */
+	KEY_NONE            ,   /* SDLK_NONE            = 154 */
+	KEY_NONE            ,   /* SDLK_NONE            = 155 */
+	KEY_NONE            ,   /* SDLK_NONE            = 156 */
+	KEY_NONE            ,   /* SDLK_NONE            = 157 */
+	KEY_NONE            ,   /* SDLK_NONE            = 158 */
+	KEY_NONE            ,   /* SDLK_NONE            = 159 */
+	KEY_NONE            ,   /* SDLK_WORLD_0         = 160 */
+	KEY_NONE            ,   /* SDLK_WORLD_1         = 161 */
+	KEY_NONE            ,   /* SDLK_WORLD_2         = 162 */
+	KEY_NONE            ,   /* SDLK_WORLD_3         = 163 */
+	KEY_NONE            ,   /* SDLK_WORLD_4         = 164 */
+	KEY_NONE            ,   /* SDLK_WORLD_5         = 165 */
+	KEY_NONE            ,   /* SDLK_WORLD_6         = 166 */
+	KEY_NONE            ,   /* SDLK_WORLD_7         = 167 */
+	KEY_NONE            ,   /* SDLK_WORLD_8         = 168 */
+	KEY_NONE            ,   /* SDLK_WORLD_9         = 169 */
+	KEY_NONE            ,   /* SDLK_WORLD_10        = 170 */
+	KEY_NONE            ,   /* SDLK_WORLD_11        = 171 */
+	KEY_NONE            ,   /* SDLK_WORLD_12        = 172 */
+	KEY_NONE            ,   /* SDLK_WORLD_13        = 173 */
+	KEY_NONE            ,   /* SDLK_WORLD_14        = 174 */
+	KEY_NONE            ,   /* SDLK_WORLD_15        = 175 */
+	KEY_NONE            ,   /* SDLK_WORLD_16        = 176 */
+	KEY_NONE            ,   /* SDLK_WORLD_17        = 177 */
+	KEY_NONE            ,   /* SDLK_WORLD_18        = 178 */
+	KEY_NONE            ,   /* SDLK_WORLD_19        = 179 */
+	KEY_NONE            ,   /* SDLK_WORLD_20        = 180 */
+	KEY_NONE            ,   /* SDLK_WORLD_21        = 181 */
+	KEY_NONE            ,   /* SDLK_WORLD_22        = 182 */
+	KEY_NONE            ,   /* SDLK_WORLD_23        = 183 */
+	KEY_NONE            ,   /* SDLK_WORLD_24        = 184 */
+	KEY_NONE            ,   /* SDLK_WORLD_25        = 185 */
+	KEY_NONE            ,   /* SDLK_WORLD_26        = 186 */
+	KEY_NONE            ,   /* SDLK_WORLD_27        = 187 */
+	KEY_NONE            ,   /* SDLK_WORLD_28        = 188 */
+	KEY_NONE            ,   /* SDLK_WORLD_29        = 189 */
+	KEY_NONE            ,   /* SDLK_WORLD_30        = 190 */
+	KEY_NONE            ,   /* SDLK_WORLD_31        = 191 */
+	KEY_NONE            ,   /* SDLK_WORLD_32        = 192 */
+	KEY_NONE            ,   /* SDLK_WORLD_33        = 193 */
+	KEY_NONE            ,   /* SDLK_WORLD_34        = 194 */
+	KEY_NONE            ,   /* SDLK_WORLD_35        = 195 */
+	KEY_NONE            ,   /* SDLK_WORLD_36        = 196 */
+	KEY_NONE            ,   /* SDLK_WORLD_37        = 197 */
+	KEY_NONE            ,   /* SDLK_WORLD_38        = 198 */
+	KEY_NONE            ,   /* SDLK_WORLD_39        = 199 */
+	KEY_NONE            ,   /* SDLK_WORLD_40        = 200 */
+	KEY_NONE            ,   /* SDLK_WORLD_41        = 201 */
+	KEY_NONE            ,   /* SDLK_WORLD_42        = 202 */
+	KEY_NONE            ,   /* SDLK_WORLD_43        = 203 */
+	KEY_NONE            ,   /* SDLK_WORLD_44        = 204 */
+	KEY_NONE            ,   /* SDLK_WORLD_45        = 205 */
+	KEY_NONE            ,   /* SDLK_WORLD_46        = 206 */
+	KEY_NONE            ,   /* SDLK_WORLD_47        = 207 */
+	KEY_NONE            ,   /* SDLK_WORLD_48        = 208 */
+	KEY_NONE            ,   /* SDLK_WORLD_49        = 209 */
+	KEY_NONE            ,   /* SDLK_WORLD_50        = 210 */
+	KEY_NONE            ,   /* SDLK_WORLD_51        = 211 */
+	KEY_NONE            ,   /* SDLK_WORLD_52        = 212 */
+	KEY_NONE            ,   /* SDLK_WORLD_53        = 213 */
+	KEY_NONE            ,   /* SDLK_WORLD_54        = 214 */
+	KEY_NONE            ,   /* SDLK_WORLD_55        = 215 */
+	KEY_NONE            ,   /* SDLK_WORLD_56        = 216 */
+	KEY_NONE            ,   /* SDLK_WORLD_57        = 217 */
+	KEY_NONE            ,   /* SDLK_WORLD_58        = 218 */
+	KEY_NONE            ,   /* SDLK_WORLD_59        = 219 */
+	KEY_NONE            ,   /* SDLK_WORLD_60        = 220 */
+	KEY_NONE            ,   /* SDLK_WORLD_61        = 221 */
+	KEY_NONE            ,   /* SDLK_WORLD_62        = 222 */
+	KEY_NONE            ,   /* SDLK_WORLD_63        = 223 */
+	KEY_NONE            ,   /* SDLK_WORLD_64        = 224 */
+	KEY_NONE            ,   /* SDLK_WORLD_65        = 225 */
+	KEY_NONE            ,   /* SDLK_WORLD_66        = 226 */
+	KEY_NONE            ,   /* SDLK_WORLD_67        = 227 */
+	KEY_NONE            ,   /* SDLK_WORLD_68        = 228 */
+	KEY_NONE            ,   /* SDLK_WORLD_69        = 229 */
+	KEY_NONE            ,   /* SDLK_WORLD_70        = 230 */
+	KEY_NONE            ,   /* SDLK_WORLD_71        = 231 */
+	KEY_NONE            ,   /* SDLK_WORLD_72        = 232 */
+	KEY_NONE            ,   /* SDLK_WORLD_73        = 233 */
+	KEY_NONE            ,   /* SDLK_WORLD_74        = 234 */
+	KEY_NONE            ,   /* SDLK_WORLD_75        = 235 */
+	KEY_NONE            ,   /* SDLK_WORLD_76        = 236 */
+	KEY_NONE            ,   /* SDLK_WORLD_77        = 237 */
+	KEY_NONE            ,   /* SDLK_WORLD_78        = 238 */
+	KEY_NONE            ,   /* SDLK_WORLD_79        = 239 */
+	KEY_NONE            ,   /* SDLK_WORLD_80        = 240 */
+	KEY_NONE            ,   /* SDLK_WORLD_81        = 241 */
+	KEY_NONE            ,   /* SDLK_WORLD_82        = 242 */
+	KEY_NONE            ,   /* SDLK_WORLD_83        = 243 */
+	KEY_NONE            ,   /* SDLK_WORLD_84        = 244 */
+	KEY_NONE            ,   /* SDLK_WORLD_85        = 245 */
+	KEY_NONE            ,   /* SDLK_WORLD_86        = 246 */
+	KEY_NONE            ,   /* SDLK_WORLD_87        = 247 */
+	KEY_NONE            ,   /* SDLK_WORLD_88        = 248 */
+	KEY_NONE            ,   /* SDLK_WORLD_89        = 249 */
+	KEY_NONE            ,   /* SDLK_WORLD_90        = 250 */
+	KEY_NONE            ,   /* SDLK_WORLD_91        = 251 */
+	KEY_NONE            ,   /* SDLK_WORLD_92        = 252 */
+	KEY_NONE            ,   /* SDLK_WORLD_93        = 253 */
+	KEY_NONE            ,   /* SDLK_WORLD_94        = 254 */
+	KEY_NONE            ,   /* SDLK_WORLD_95        = 255 */
+	KEY_0_PAD           ,   /* SDLK_KP0             = 256 */
+	KEY_1_PAD           ,   /* SDLK_KP1             = 257 */
+	KEY_2_PAD           ,   /* SDLK_KP2             = 258 */
+	KEY_3_PAD           ,   /* SDLK_KP3             = 259 */
+	KEY_4_PAD           ,   /* SDLK_KP4             = 260 */
+	KEY_5_PAD           ,   /* SDLK_KP5             = 261 */
+	KEY_6_PAD           ,   /* SDLK_KP6             = 262 */
+	KEY_7_PAD           ,   /* SDLK_KP7             = 263 */
+	KEY_8_PAD           ,   /* SDLK_KP8             = 264 */
+	KEY_9_PAD           ,   /* SDLK_KP9             = 265 */
+	KEY_DEL_PAD         ,   /* SDLK_KP_PERIOD       = 266 */
+	KEY_SLASH_PAD       ,   /* SDLK_KP_DIVIDE       = 267 NS */
+	KEY_ASTERISK        ,   /* SDLK_KP_MULTIPLY     = 268 */
+	KEY_MINUS_PAD       ,   /* SDLK_KP_MINUS        = 269 */
+	KEY_PLUS_PAD        ,   /* SDLK_KP_PLUS         = 270 */
+	KEY_ENTER_PAD       ,   /* SDLK_KP_ENTER        = 271 */
+	KEY_EQUALS          ,   /* SDLK_KP_EQUALS       = 272 */
+	KEY_UP              ,   /* SDLK_UP              = 273 */
+	KEY_DOWN            ,   /* SDLK_DOWN            = 274 */
+	KEY_RIGHT           ,   /* SDLK_RIGHT           = 275 */
+	KEY_LEFT            ,   /* SDLK_LEFT            = 276 */
+	KEY_INSERT          ,   /* SDLK_INSERT          = 277 */
+	KEY_HOME            ,   /* SDLK_HOME            = 278 */
+	KEY_END             ,   /* SDLK_END             = 279 */
+	KEY_PGUP            ,   /* SDLK_PAGEUP          = 280 */
+	KEY_PGDN            ,   /* SDLK_PAGEDOWN        = 281 */
+	KEY_F1              ,   /* SDLK_F1              = 282 */
+	KEY_F2              ,   /* SDLK_F2              = 283 */
+	KEY_F3              ,   /* SDLK_F3              = 284 */
+	KEY_F4              ,   /* SDLK_F4              = 285 */
+	KEY_F5              ,   /* SDLK_F5              = 286 */
+	KEY_F6              ,   /* SDLK_F6              = 287 */
+	KEY_F7              ,   /* SDLK_F7              = 288 */
+	KEY_F8              ,   /* SDLK_F8              = 289 */
+	KEY_F9              ,   /* SDLK_F9              = 290 */
+	KEY_F10             ,   /* SDLK_F10             = 291 */
+	KEY_F11             ,   /* SDLK_F11             = 292 */
+	KEY_F12             ,   /* SDLK_F12             = 293 */
+	KEY_NONE            ,   /* SDLK_F13             = 294 */
+	KEY_NONE            ,   /* SDLK_F14             = 295 */
+	KEY_NONE            ,   /* SDLK_F15             = 296 */
+	KEY_NONE            ,   /* SDLK_NONE            = 297 */
+	KEY_NONE            ,   /* SDLK_NONE            = 298 */
+	KEY_NONE            ,   /* SDLK_NONE            = 299 */
+	KEY_NUMLOCK         ,   /* SDLK_NUMLOCK         = 300 */
+	KEY_CAPSLOCK        ,   /* SDLK_CAPSLOCK        = 301 */
+	KEY_SCRLOCK         ,   /* SDLK_SCROLLOCK       = 302 */
+	KEY_RSHIFT          ,   /* SDLK_RSHIFT          = 303 */
+	KEY_LSHIFT          ,   /* SDLK_LSHIFT          = 304 */
+	KEY_RCONTROL        ,   /* SDLK_RCTRL           = 305 */
+	KEY_LCONTROL        ,   /* SDLK_LCTRL           = 306 */
+	KEY_ALTGR           ,   /* SDLK_RALT            = 307 NS */
+	KEY_ALT             ,   /* SDLK_LALT            = 308 NS */
+	KEY_ALTGR           ,   /* SDLK_RMETA           = 309 NS */
+	KEY_ALT             ,   /* SDLK_LMETA           = 310 NS */
+	KEY_NONE            ,   /* SDLK_LSUPER          = 311 */
+	KEY_NONE            ,   /* SDLK_RSUPER          = 312 */
+	KEY_NONE            ,   /* SDLK_MODE            = 313 */
+	KEY_NONE            ,   /* SDLK_NONE            = 314 */
+	KEY_NONE            ,   /* SDLK_HELP            = 315 */
+	KEY_PRTSCR          ,   /* SDLK_PRINT           = 316 NS */
+	KEY_NONE            ,   /* SDLK_SYSREQ          = 317 */
+	KEY_NONE            ,   /* SDLK_BREAK           = 318 */
+	KEY_MENU            ,   /* SDLK_MENU            = 319 */
+	KEY_NONE            ,   /* SDLK_POWER           = 320 */
+	KEY_NONE            ,   /* SDLK_EURO            = 321 */
+	KEY_NONE            ,   /* SDLK_NONE            = 322 */
+	KEY_NONE            ,   /* SDLK_NONE            = 323 */
+	KEY_NONE            ,   /* SDLK_NONE            = 324 */
+	KEY_NONE            ,   /* SDLK_NONE            = 325 */
+	KEY_NONE            ,   /* SDLK_NONE            = 326 */
+	KEY_NONE            ,   /* SDLK_NONE            = 327 */
+	KEY_NONE            ,   /* SDLK_NONE            = 328 */
+	KEY_NONE            ,   /* SDLK_NONE            = 329 */
+	KEY_NONE            ,   /* SDLK_NONE            = 330 */
+	KEY_NONE            ,   /* SDLK_NONE            = 331 */
+	KEY_NONE            ,   /* SDLK_NONE            = 332 */
+	KEY_NONE            ,   /* SDLK_NONE            = 333 */
+	KEY_NONE            ,   /* SDLK_NONE            = 334 */
+	KEY_NONE            ,   /* SDLK_NONE            = 335 */
+	KEY_NONE            ,   /* SDLK_NONE            = 336 */
+	KEY_NONE            ,   /* SDLK_NONE            = 337 */
+	KEY_NONE            ,   /* SDLK_NONE            = 338 */
+	KEY_NONE            ,   /* SDLK_NONE            = 339 */
+	KEY_NONE            ,   /* SDLK_NONE            = 340 */
+	KEY_NONE            ,   /* SDLK_NONE            = 341 */
+	KEY_NONE            ,   /* SDLK_NONE            = 342 */
+	KEY_NONE            ,   /* SDLK_NONE            = 343 */
+	KEY_NONE            ,   /* SDLK_NONE            = 344 */
+	KEY_NONE            ,   /* SDLK_NONE            = 345 */
+	KEY_NONE            ,   /* SDLK_NONE            = 346 */
+	KEY_NONE            ,   /* SDLK_NONE            = 347 */
+	KEY_NONE            ,   /* SDLK_NONE            = 348 */
+	KEY_NONE            ,   /* SDLK_NONE            = 349 */
+	KEY_NONE            ,   /* SDLK_NONE            = 350 */
+	KEY_NONE            ,   /* SDLK_NONE            = 351 */
+	KEY_NONE            ,   /* SDLK_NONE            = 352 */
+	KEY_NONE            ,   /* SDLK_NONE            = 353 */
+	KEY_NONE            ,   /* SDLK_NONE            = 354 */
+	KEY_NONE            ,   /* SDLK_NONE            = 355 */
+	KEY_NONE            ,   /* SDLK_NONE            = 356 */
+	KEY_NONE            ,   /* SDLK_NONE            = 357 */
+	KEY_NONE            ,   /* SDLK_NONE            = 358 */
+	KEY_NONE            ,   /* SDLK_NONE            = 359 */
+	KEY_NONE            ,   /* SDLK_NONE            = 360 */
+	KEY_NONE            ,   /* SDLK_NONE            = 361 */
+	KEY_NONE            ,   /* SDLK_NONE            = 362 */
+	KEY_NONE            ,   /* SDLK_NONE            = 363 */
+	KEY_NONE            ,   /* SDLK_NONE            = 364 */
+	KEY_NONE            ,   /* SDLK_NONE            = 365 */
+	KEY_NONE            ,   /* SDLK_NONE            = 366 */
+	KEY_NONE            ,   /* SDLK_NONE            = 367 */
+	KEY_NONE            ,   /* SDLK_NONE            = 368 */
+	KEY_NONE            ,   /* SDLK_NONE            = 369 */
+	KEY_NONE            ,   /* SDLK_NONE            = 370 */
+	KEY_NONE            ,   /* SDLK_NONE            = 371 */
+	KEY_NONE            ,   /* SDLK_NONE            = 372 */
+	KEY_NONE            ,   /* SDLK_NONE            = 373 */
+	KEY_NONE            ,   /* SDLK_NONE            = 374 */
+	KEY_NONE            ,   /* SDLK_NONE            = 375 */
+	KEY_NONE            ,   /* SDLK_NONE            = 376 */
+	KEY_NONE            ,   /* SDLK_NONE            = 377 */
+	KEY_NONE            ,   /* SDLK_NONE            = 378 */
+	KEY_NONE            ,   /* SDLK_NONE            = 379 */
+	KEY_NONE            ,   /* SDLK_NONE            = 380 */
+	KEY_NONE            ,   /* SDLK_NONE            = 381 */
+	KEY_NONE            ,   /* SDLK_NONE            = 382 */
+	KEY_NONE            ,   /* SDLK_NONE            = 383 */
+	KEY_NONE            ,   /* SDLK_NONE            = 384 */
+	KEY_NONE            ,   /* SDLK_NONE            = 385 */
+	KEY_NONE            ,   /* SDLK_NONE            = 386 */
+	KEY_NONE            ,   /* SDLK_NONE            = 387 */
+	KEY_NONE            ,   /* SDLK_NONE            = 388 */
+	KEY_NONE            ,   /* SDLK_NONE            = 389 */
+	KEY_NONE            ,   /* SDLK_NONE            = 390 */
+	KEY_NONE            ,   /* SDLK_NONE            = 391 */
+	KEY_NONE            ,   /* SDLK_NONE            = 392 */
+	KEY_NONE            ,   /* SDLK_NONE            = 393 */
+	KEY_NONE            ,   /* SDLK_NONE            = 394 */
+	KEY_NONE            ,   /* SDLK_NONE            = 395 */
+	KEY_NONE            ,   /* SDLK_NONE            = 396 */
+	KEY_NONE            ,   /* SDLK_NONE            = 397 */
+	KEY_NONE            ,   /* SDLK_NONE            = 398 */
+	KEY_NONE            ,   /* SDLK_NONE            = 399 */
+	KEY_NONE            ,   /* SDLK_NONE            = 400 */
+	KEY_NONE            ,   /* SDLK_NONE            = 401 */
+	KEY_NONE            ,   /* SDLK_NONE            = 402 */
+	KEY_NONE            ,   /* SDLK_NONE            = 403 */
+	KEY_NONE            ,   /* SDLK_NONE            = 404 */
+	KEY_NONE            ,   /* SDLK_NONE            = 405 */
+	KEY_NONE            ,   /* SDLK_NONE            = 406 */
+	KEY_NONE            ,   /* SDLK_NONE            = 407 */
+	KEY_NONE            ,   /* SDLK_NONE            = 408 */
+	KEY_NONE            ,   /* SDLK_NONE            = 409 */
+	KEY_NONE            ,   /* SDLK_NONE            = 410 */
+	KEY_NONE            ,   /* SDLK_NONE            = 411 */
+	KEY_NONE            ,   /* SDLK_NONE            = 412 */
+	KEY_NONE            ,   /* SDLK_NONE            = 413 */
+	KEY_NONE            ,   /* SDLK_NONE            = 414 */
+	KEY_NONE            ,   /* SDLK_NONE            = 415 */
+	KEY_NONE            ,   /* SDLK_NONE            = 416 */
+	KEY_NONE            ,   /* SDLK_NONE            = 417 */
+	KEY_NONE            ,   /* SDLK_NONE            = 418 */
+	KEY_NONE            ,   /* SDLK_NONE            = 419 */
+	KEY_NONE            ,   /* SDLK_NONE            = 420 */
+	KEY_NONE            ,   /* SDLK_NONE            = 421 */
+	KEY_NONE            ,   /* SDLK_NONE            = 422 */
+	KEY_NONE            ,   /* SDLK_NONE            = 423 */
+	KEY_NONE            ,   /* SDLK_NONE            = 424 */
+	KEY_NONE            ,   /* SDLK_NONE            = 425 */
+	KEY_NONE            ,   /* SDLK_NONE            = 426 */
+	KEY_NONE            ,   /* SDLK_NONE            = 427 */
+	KEY_NONE            ,   /* SDLK_NONE            = 428 */
+	KEY_NONE            ,   /* SDLK_NONE            = 429 */
+	KEY_NONE            ,   /* SDLK_NONE            = 430 */
+	KEY_NONE            ,   /* SDLK_NONE            = 431 */
+	KEY_NONE            ,   /* SDLK_NONE            = 432 */
+	KEY_NONE            ,   /* SDLK_NONE            = 433 */
+	KEY_NONE            ,   /* SDLK_NONE            = 434 */
+	KEY_NONE            ,   /* SDLK_NONE            = 435 */
+	KEY_NONE            ,   /* SDLK_NONE            = 436 */
+	KEY_NONE            ,   /* SDLK_NONE            = 437 */
+	KEY_NONE            ,   /* SDLK_NONE            = 438 */
+	KEY_NONE            ,   /* SDLK_NONE            = 439 */
+	KEY_NONE            ,   /* SDLK_NONE            = 440 */
+	KEY_NONE            ,   /* SDLK_NONE            = 441 */
+	KEY_NONE            ,   /* SDLK_NONE            = 442 */
+	KEY_NONE            ,   /* SDLK_NONE            = 443 */
+	KEY_NONE            ,   /* SDLK_NONE            = 444 */
+	KEY_NONE            ,   /* SDLK_NONE            = 445 */
+	KEY_NONE            ,   /* SDLK_NONE            = 446 */
+	KEY_NONE            ,   /* SDLK_NONE            = 447 */
+	KEY_NONE            ,   /* SDLK_NONE            = 448 */
+	KEY_NONE            ,   /* SDLK_NONE            = 449 */
+	KEY_NONE            ,   /* SDLK_NONE            = 450 */
+	KEY_NONE            ,   /* SDLK_NONE            = 451 */
+	KEY_NONE            ,   /* SDLK_NONE            = 452 */
+	KEY_NONE            ,   /* SDLK_NONE            = 453 */
+	KEY_NONE            ,   /* SDLK_NONE            = 454 */
+	KEY_NONE            ,   /* SDLK_NONE            = 455 */
+	KEY_NONE            ,   /* SDLK_NONE            = 456 */
+	KEY_NONE            ,   /* SDLK_NONE            = 457 */
+	KEY_NONE            ,   /* SDLK_NONE            = 458 */
+	KEY_NONE            ,   /* SDLK_NONE            = 459 */
+	KEY_NONE            ,   /* SDLK_NONE            = 460 */
+	KEY_NONE            ,   /* SDLK_NONE            = 461 */
+	KEY_NONE            ,   /* SDLK_NONE            = 462 */
+	KEY_NONE            ,   /* SDLK_NONE            = 463 */
+	KEY_NONE            ,   /* SDLK_NONE            = 464 */
+	KEY_NONE            ,   /* SDLK_NONE            = 465 */
+	KEY_NONE            ,   /* SDLK_NONE            = 466 */
+	KEY_NONE            ,   /* SDLK_NONE            = 467 */
+	KEY_NONE            ,   /* SDLK_NONE            = 468 */
+	KEY_NONE            ,   /* SDLK_NONE            = 469 */
+	KEY_NONE            ,   /* SDLK_NONE            = 470 */
+	KEY_NONE            ,   /* SDLK_NONE            = 471 */
+	KEY_NONE            ,   /* SDLK_NONE            = 472 */
+	KEY_NONE            ,   /* SDLK_NONE            = 473 */
+	KEY_NONE            ,   /* SDLK_NONE            = 474 */
+	KEY_NONE            ,   /* SDLK_NONE            = 475 */
+	KEY_NONE            ,   /* SDLK_NONE            = 476 */
+	KEY_NONE            ,   /* SDLK_NONE            = 477 */
+	KEY_NONE            ,   /* SDLK_NONE            = 478 */
+	KEY_NONE            ,   /* SDLK_NONE            = 479 */
+	KEY_NONE            ,   /* SDLK_NONE            = 480 */
+	KEY_NONE            ,   /* SDLK_NONE            = 481 */
+	KEY_NONE            ,   /* SDLK_NONE            = 482 */
+	KEY_NONE            ,   /* SDLK_NONE            = 483 */
+	KEY_NONE            ,   /* SDLK_NONE            = 484 */
+	KEY_NONE            ,   /* SDLK_NONE            = 485 */
+	KEY_NONE            ,   /* SDLK_NONE            = 486 */
+	KEY_NONE            ,   /* SDLK_NONE            = 487 */
+	KEY_NONE            ,   /* SDLK_NONE            = 488 */
+	KEY_NONE            ,   /* SDLK_NONE            = 489 */
+	KEY_NONE            ,   /* SDLK_NONE            = 490 */
+	KEY_NONE            ,   /* SDLK_NONE            = 491 */
+	KEY_NONE            ,   /* SDLK_NONE            = 492 */
+	KEY_NONE            ,   /* SDLK_NONE            = 493 */
+	KEY_NONE            ,   /* SDLK_NONE            = 494 */
+	KEY_NONE            ,   /* SDLK_NONE            = 495 */
+	KEY_NONE            ,   /* SDLK_NONE            = 496 */
+	KEY_NONE            ,   /* SDLK_NONE            = 497 */
+	KEY_NONE            ,   /* SDLK_NONE            = 498 */
+	KEY_NONE            ,   /* SDLK_NONE            = 499 */
+	KEY_NONE            ,   /* SDLK_NONE            = 500 */
+	KEY_NONE            ,   /* SDLK_NONE            = 501 */
+	KEY_NONE            ,   /* SDLK_NONE            = 502 */
+	KEY_NONE            ,   /* SDLK_NONE            = 503 */
+	KEY_NONE            ,   /* SDLK_NONE            = 504 */
+	KEY_NONE            ,   /* SDLK_NONE            = 505 */
+	KEY_NONE            ,   /* SDLK_NONE            = 506 */
+	KEY_NONE            ,   /* SDLK_NONE            = 507 */
+	KEY_NONE            ,   /* SDLK_NONE            = 508 */
+	KEY_NONE            ,   /* SDLK_NONE            = 509 */
+	KEY_NONE            ,   /* SDLK_NONE            = 510 */
+	KEY_NONE                /* SDLK_NONE            = 511 */
+};
diff --git a/src/unix/video-drivers/SDL.c b/src/unix/video-drivers/SDL.c
new file mode 100644
index 0000000..6294d88
--- /dev/null
+++ b/src/unix/video-drivers/SDL.c
@@ -0,0 +1,802 @@
+/***************************************************************************
+                                          
+ This is the SDL XMAME display driver.
+ FIrst incarnation by Tadeusz Szczyrba <trevor@pik-nel.pl>,
+ based on the Linux SVGALib adaptation by Phillip Ezolt.
+
+ updated and patched by Ricardo Calixto Quesada (riq@core-sdi.com)
+
+ patched by Patrice Mandin (pmandin@caramail.com)
+  modified support for fullscreen modes using SDL and XFree 4
+  added toggle fullscreen/windowed mode (Alt + Return)
+  added title for the window
+  hide mouse cursor in fullscreen mode
+  added command line switch to start fullscreen or windowed
+  modified the search for the best screen size (SDL modes are sorted by
+    Y size)
+
+ patched by Dan Scholnik (scholnik@ieee.org)
+  added support for 32bpp XFree86 modes
+  new update routines: 8->32bpp & 16->32bpp
+
+ TODO: Test the HERMES code.
+       Test the 16bpp->24bpp update routine
+       Test the 16bpp->32bpp update routine
+       Improve performance.
+       Test mouse buttons (which games use them?)
+
+***************************************************************************/
+/* #define PARANOIC */
+#define __SDL_C
+
+#undef SDL_DEBUG
+/* #define DIRECT_HERMES */
+
+#include <signal.h>
+#include <sys/ioctl.h>
+#include <sys/types.h>
+#include <SDL.h>
+#include "xmame.h"
+#include "devices.h"
+#include "keyboard.h"
+#include "driver.h"
+#include "SDL-keytable.h"
+#ifdef DIRECT_HERMES 
+#include <Hermes/Hermes.h>
+#endif /* DIRECT_HERMES */
+#include "effect.h"
+
+static int Vid_width;
+static int Vid_height;
+static int Vid_depth = 8;
+static SDL_Surface* Surface;
+static SDL_Surface* Offscreen_surface;
+static int hardware=1;
+static int mode_number=-1;
+static int start_fullscreen=0;
+SDL_Color *Colors=NULL;
+static int cursor_state; /* previous mouse cursor state */
+
+#ifdef DIRECT_HERMES
+HermesHandle   H_PaletteHandle;
+HermesHandle H_ConverterHandle;
+int32_t* H_Palette;
+static int H_Palette_modified = 0;
+#endif
+
+typedef void (*update_func_t)(struct mame_bitmap *bitmap);
+
+update_func_t update_function;
+
+static int sdl_mapkey(struct rc_option *option, const char *arg, int priority);
+
+static int list_sdl_modes(struct rc_option *option, const char *arg, int priority);
+
+struct rc_option display_opts[] = {
+    /* name, shortname, type, dest, deflt, min, max, func, help */
+   { "SDL Related",  NULL,    rc_seperator,  NULL,
+       NULL,         0,       0,             NULL,
+       NULL },
+   { "fullscreen",   NULL,    rc_bool,       &start_fullscreen,
+      "0",           0,       0,             NULL,
+      "Start fullscreen" },
+   { "listmodes",    NULL,    rc_use_function_no_arg,       NULL,
+      NULL,           0,       0,             list_sdl_modes,
+      "List all posible fullscreen modes" },
+   { "modenumber",   NULL,    rc_int,        &mode_number,
+      "-1",          0,       0,             NULL,
+      "Try to use the fullscreen mode numbered 'n' (see the output of -listmodes)" },
+   { "sdlmapkey",	"sdlmk",	rc_use_function,	NULL,
+     NULL,		0,			0,		sdl_mapkey,
+     "Set a specific key mapping, see xmamerc.dist" },
+   { NULL,           NULL,    rc_end,        NULL,
+      NULL,          0,       0,             NULL,
+      NULL }
+};
+
+void sdl_update_16_to_16bpp(struct mame_bitmap *bitmap);
+void sdl_update_16_to_24bpp(struct mame_bitmap *bitmap);
+void sdl_update_16_to_32bpp(struct mame_bitmap *bitmap);
+void sdl_update_rgb_direct_32bpp(struct mame_bitmap *bitmap);
+
+int sysdep_init(void)
+{
+   if (SDL_Init(SDL_INIT_VIDEO) < 0) {
+      fprintf (stderr, "SDL: Error: %s\n",SDL_GetError());
+      return OSD_NOT_OK;
+   } 
+#ifdef DIRECT_HERMES
+   Hermes_Init(0);
+#endif /* DIRECT_HERMES */
+   fprintf (stderr, "SDL: Info: SDL initialized\n");
+   atexit (SDL_Quit);
+   return OSD_OK;
+}
+
+void sysdep_close(void)
+{
+   SDL_Quit();
+}
+
+int sysdep_create_display(int depth)
+{
+   SDL_Rect** vid_modes;
+   const SDL_VideoInfo* video_info;
+   int vid_modes_i;
+#ifdef DIRECT_HERMES 
+   HermesFormat* H_src_format;
+   HermesFormat* H_dst_format;
+#endif /* DIRECT_HERMES */
+   int vid_mode_flag; /* Flag to set the video mode */
+
+   video_info = SDL_GetVideoInfo();
+
+#ifdef SDL_DEBUG
+   fprintf (stderr,"SDL: create_display(%d): \n",depth);
+   fprintf (stderr,"SDL: Info: HW blits %d\n"
+      "SDL: Info: SW blits %d\n"
+      "SDL: Info: Vid mem %d\n"
+      "SDL: Info: Best supported depth %d\n",
+      video_info->blit_hw,
+      video_info->blit_sw,
+      video_info->video_mem,
+      video_info->vfmt->BitsPerPixel);
+#endif
+
+   Vid_depth = video_info->vfmt->BitsPerPixel;
+
+   vid_modes = SDL_ListModes(NULL,SDL_FULLSCREEN);
+   vid_modes_i = 0;
+
+   hardware = video_info->hw_available;
+
+   if ( (! vid_modes) || ((long)vid_modes == -1)) {
+#ifdef SDL_DEBUG
+      fprintf (stderr, "SDL: Info: Possible all video modes available\n");
+#endif
+      Vid_height = visual_height*heightscale;
+      Vid_width = visual_width*widthscale;
+   } else {
+      int best_vid_mode; /* Best video mode found */
+      int best_width,best_height;
+      int i;
+
+#ifdef SDL_DEBUG
+      fprintf (stderr, "SDL: visual w:%d visual h:%d\n", visual_width, visual_height);
+#endif
+      best_vid_mode = 0;
+      best_width = vid_modes[best_vid_mode]->w;
+      best_height = vid_modes[best_vid_mode]->h;
+      for (i=0;vid_modes[i];++i)
+      {
+         int cur_width, cur_height;
+
+         cur_width = vid_modes[i]->w;
+         cur_height = vid_modes[i]->h;
+
+#ifdef SDL_DEBUG
+         fprintf (stderr, "SDL: Info: Found mode %d x %d\n", cur_width, cur_height);
+#endif /* SDL_DEBUG */
+
+         /* If width and height too small, skip to next mode */
+         if ((cur_width < visual_width*widthscale) || (cur_height < visual_height*heightscale)) {
+            continue;
+         }
+
+         /* If width or height smaller than current best, keep it */
+         if ((cur_width < best_width) || (cur_height < best_height)) {
+            best_vid_mode = i;
+            best_width = cur_width;
+            best_height = cur_height;
+         }
+      }
+
+#ifdef SDL_DEBUG
+      fprintf (stderr, "SDL: Info: Best mode found : %d x %d\n",
+         vid_modes[best_vid_mode]->w,
+         vid_modes[best_vid_mode]->h);
+#endif /* SDL_DEBUG */
+
+      vid_modes_i = best_vid_mode;
+
+      /* mode_number is a command line option */
+      if( mode_number != -1) {
+         if( mode_number >vid_modes_i)
+            fprintf(stderr, "SDL: The mode number is invalid... ignoring\n");
+         else
+            vid_modes_i = mode_number;
+      }
+      if( vid_modes_i<0 ) {
+         fprintf(stderr, "SDL: None of the modes match :-(\n");
+         Vid_height = visual_height*heightscale;
+         Vid_width = visual_width*widthscale;
+      } else {
+         if(*(vid_modes+vid_modes_i)==NULL) 
+            vid_modes_i--;
+
+         Vid_width = (*(vid_modes + vid_modes_i))->w;
+         Vid_height = (*(vid_modes + vid_modes_i))->h;
+      }
+   }
+
+   if( depth == 16 )
+   {
+      switch( Vid_depth ) {
+      case 32:
+         update_function = &sdl_update_16_to_32bpp;
+         break;
+      case 24:
+         update_function = &sdl_update_16_to_24bpp;
+         break;
+      case 16:
+         update_function = &sdl_update_16_to_16bpp;
+         break;
+      default:
+         fprintf (stderr, "SDL: Unsupported Vid_depth=%d in depth=%d\n", Vid_depth,depth);
+         SDL_Quit();
+         exit (OSD_NOT_OK);
+         break;
+      }
+   }
+   else if (depth == 32)
+   {
+      if (Vid_depth == 32)
+      {
+         update_function = &sdl_update_rgb_direct_32bpp; 
+      }
+      else
+      {
+         fprintf (stderr, "SDL: Unsupported Vid_depth=%d in depth=%d\n",
+            Vid_depth, depth);
+         SDL_Quit();
+         exit (OSD_NOT_OK);
+      }
+   }
+   else
+   {
+      fprintf (stderr, "SDL: Unsupported depth=%d\n", depth);
+      SDL_Quit();
+      exit (OSD_NOT_OK);
+   }
+
+
+   /* Set video mode according to flags */
+   vid_mode_flag = SDL_HWSURFACE;
+   if (start_fullscreen) {
+      vid_mode_flag |= SDL_FULLSCREEN;
+   }
+
+   if(! (Surface = SDL_SetVideoMode(Vid_width, Vid_height,Vid_depth, vid_mode_flag))) {
+      fprintf (stderr, "SDL: Error: Setting video mode failed\n");
+      SDL_Quit();
+      exit (OSD_NOT_OK);
+   } else {
+      fprintf (stderr, "SDL: Info: Video mode set as %d x %d, depth %d\n", Vid_width, Vid_height, Vid_depth);
+   }
+
+#ifndef DIRECT_HERMES
+   Offscreen_surface = SDL_CreateRGBSurface(SDL_SWSURFACE,Vid_width,Vid_height,Vid_depth,0,0,0,0); 
+   if(Offscreen_surface==NULL) {
+      SDL_Quit();
+      exit (OSD_NOT_OK);
+   }
+#else /* DIRECT_HERMES */
+   /* No offscreen surface when using hermes directly */
+   H_ConverterHandle = Hermes_ConverterInstance(0);
+   H_src_format = Hermes_FormatNew (8,0,0,0,0,HERMES_INDEXED);
+   /* TODO: More general destination choosing - uptil
+       now only 16 bit */
+   H_dst_format = Hermes_FormatNew (16,Surface->format->Rmask,Surface->format->Gmask,Surface->format->Bmask,0,0);
+   /*  H_dst_format = Hermes_FormatNew (16,5,5,5,0,0); */
+   if ( ! (Hermes_ConverterRequest(H_ConverterHandle,H_src_format , H_dst_format)) ) {
+      fprintf (stderr_file, "Hermes: Info: Converter request failed\n");
+      exit (OSD_NOT_OK);
+   }
+#endif /* DIRECT_HERMES */
+
+
+   /* Creating event mask */
+   SDL_EventState(SDL_KEYUP, SDL_ENABLE);
+   SDL_EventState(SDL_KEYDOWN, SDL_ENABLE);
+   SDL_EnableUNICODE(1);
+   
+    /* fill the display_palette_info struct */
+    memset(&display_palette_info, 0, sizeof(struct sysdep_palette_info));
+    display_palette_info.depth = Vid_depth;
+    if (Vid_depth == 8)
+         display_palette_info.writable_colors = 256;
+    else if (Vid_depth == 16) {
+      display_palette_info.red_mask = 0xF800;
+      display_palette_info.green_mask = 0x07E0;
+      display_palette_info.blue_mask   = 0x001F;
+    }
+    else {
+      display_palette_info.red_mask   = 0x00FF0000;
+      display_palette_info.green_mask = 0x0000FF00;
+      display_palette_info.blue_mask  = 0x000000FF;
+    };
+
+   /* Hide mouse cursor and save its previous status */
+   cursor_state = SDL_ShowCursor(0);
+
+   /* Set window title */
+   SDL_WM_SetCaption(title, NULL);
+
+   effect_init2(depth, Vid_depth, Vid_width);
+
+   return OSD_OK;
+}
+
+/*
+ *  keyboard remapping routine
+ *  invoiced in startup code
+ *  returns 0-> success 1-> invalid from or to
+ */
+static int sdl_mapkey(struct rc_option *option, const char *arg, int priority)
+{
+   unsigned int from, to;
+   /* ultrix sscanf() requires explicit leading of 0x for hex numbers */
+   if (sscanf(arg, "0x%x,0x%x", &from, &to) == 2)
+   {
+      /* perform tests */
+      /* fprintf(stderr,"trying to map %x to %x\n", from, to); */
+      if (from >= SDLK_FIRST && from < SDLK_LAST && to >= 0 && to <= 127)
+      {
+         klookup[from] = to;
+	 return OSD_OK;
+      }
+      /* stderr_file isn't defined yet when we're called. */
+      fprintf(stderr,"Invalid keymapping %s. Ignoring...\n", arg);
+   }
+   return OSD_NOT_OK;
+}
+
+/* Update routines */
+void sdl_update_16_to_16bpp (struct mame_bitmap *bitmap)
+{
+#define SRC_PIXEL  unsigned short
+#define DEST_PIXEL unsigned short
+#define DEST Offscreen_surface->pixels
+#define DEST_WIDTH Vid_width
+   if(current_palette->lookup)
+   {
+#define INDIRECT current_palette->lookup
+#include "blit.h"
+#undef INDIRECT
+   }
+   else
+   {
+#include "blit.h"
+   }
+#undef DEST
+#undef DEST_WIDTH
+#undef SRC_PIXEL
+#undef DEST_PIXEL
+}
+
+void sdl_update_16_to_24bpp (struct mame_bitmap *bitmap)
+{
+#define SRC_PIXEL  unsigned short
+#define DEST_PIXEL unsigned int
+#define PACK_BITS
+#define DEST Offscreen_surface->pixels
+#define DEST_WIDTH Vid_width
+   if(current_palette->lookup)
+   {
+#define INDIRECT current_palette->lookup
+#include "blit.h"
+#undef INDIRECT
+   }
+   else
+   {
+#include "blit.h"
+   }
+#undef DEST_WIDTH
+#undef DEST
+#undef PACK_BITS
+#undef DEST_PIXEL
+#undef SRC_PIXEL
+}
+
+void sdl_update_16_to_32bpp (struct mame_bitmap *bitmap)
+{
+#define INDIRECT current_palette->lookup
+#define SRC_PIXEL unsigned short
+#define DEST_PIXEL unsigned int
+#define DEST Offscreen_surface->pixels
+#define DEST_WIDTH Vid_width
+#include "blit.h"
+#undef DEST_WIDTH
+#undef DEST
+#undef DEST_PIXEL
+#undef SRC_PIXEL
+#undef INDIRECT
+}
+
+void sdl_update_rgb_direct_32bpp(struct mame_bitmap *bitmap)
+{
+#define SRC_PIXEL unsigned int
+#define DEST_PIXEL unsigned int
+#define DEST Offscreen_surface->pixels
+#define DEST_WIDTH Vid_width
+#include "blit.h"
+#undef DEST_WIDTH
+#undef DEST
+#undef DEST_PIXEL
+#undef SRC_PIXEL
+}
+
+#ifndef DIRECT_HERMES
+void sysdep_update_display(struct mame_bitmap *bitmap)
+{
+   SDL_Rect srect = { 0,0,0,0 };
+   SDL_Rect drect = { 0,0,0,0 };
+   srect.w = Vid_width;
+   srect.h = Vid_height;
+
+   /* Center the display */
+   drect.x = (Vid_width - visual_width*widthscale ) >> 1;
+   drect.y = (Vid_height - visual_height*heightscale ) >> 1;
+
+   drect.w = Vid_width;
+   drect.h = Vid_height;
+
+   (*update_function)(bitmap);
+
+   
+   if(SDL_BlitSurface (Offscreen_surface, &srect, Surface, &drect)<0) 
+      fprintf (stderr,"SDL: Warn: Unsuccessful blitting\n");
+
+   if(hardware==0)
+      SDL_UpdateRects(Surface,1, &drect);
+}
+#else /* DIRECT_HERMES */
+void sysdep_update_display(struct mame_bitmap *bitmap)
+{
+   int i,j,x,y,w,h;
+   int locked =0 ;
+   static int first_run = 1;
+   int line_amount;
+
+#ifdef SDL_DEBUG
+   static int update_count = 0;
+   static char* bak_bitmap;
+   int corrected = 0;
+   int debug = 0;
+#endif /* SDL_DEBUG */
+
+   if (H_Palette_modified) {
+      Hermes_PaletteInvalidateCache(H_PaletteHandle);
+      Hermes_ConverterPalette(H_ConverterHandle,H_PaletteHandle,0);
+      H_Palette_modified = 0;
+   }
+   
+#ifdef PANANOIC 
+      memset(Offscreen_surface->pixels,'\0' ,Vid_height * Vid_width);
+#endif 
+
+   switch   (use_dirty) {
+      long line_min;
+      long line_max;
+      long col_min;
+      long col_amount;
+
+      
+#ifdef SDL_DEBUG
+      int my_off;
+#endif       
+   case 0:
+      /* Not using dirty */
+      if (SDL_MUSTLOCK(Surface))
+         SDL_LockSurface(Surface);
+      
+      Hermes_ConverterCopy (H_ConverterHandle, 
+               bitmap->line[0] ,
+               0, 0 , 
+               Vid_width,Vid_height, bitmap->line[1] - bitmap->line[0],
+               Surface->pixels, 
+               0,0,
+               Vid_width, Vid_height, Vid_width <<1 );
+      
+      SDL_UnlockSurface(Surface);
+      SDL_UpdateRect(Surface,0,0,Vid_width,Vid_height);
+      break;
+
+   case 1:
+      /* Algorithm:
+          search through dirty & find max maximal polygon, which 
+          we can get to clipping (don't know if 8x8 is enought)
+      */
+      /*osd_dirty_merge();*/
+      
+   case 2:
+      h = (bitmap->height+7) >> 3; /* Divide by 8, up rounding */
+      w = (bitmap->width +7) >> 3; /* Divide by 8, up rounding */
+      
+#ifdef PARANOIC
+      /* Rechecking dirty correctness ...*/
+      if ( (! first_run) && debug) {
+         for (y=0;y<h;y++ ) {
+            for (i=0;i<8;i++) {
+               int line_off = ((y<<3) + i);
+               for (x=0;x<w;x++) {
+                  for (j=0;j<8;j++) {
+                     int col_off = ((x<<3) + j);
+                     if ( *(bak_bitmap + (line_off * (bitmap->line[1]- bitmap->line[0])) + col_off ) != *(*(bitmap->line + line_off) + col_off)) {
+                        if (! dirty_blocks[y][x] ) {
+                           printf ("Warn!!! Block should be dirty %d, %d, %d - correcting \n",y,x,i);
+                           dirty_blocks[y][x] = 1;
+                           dirty_lines[y]=1;
+                           corrected = 1;
+                        }
+                     } 
+                  }
+               }
+            }
+         }
+      } else {
+         bak_bitmap = (void*)malloc(w<<3 * h<<3);
+      }
+      
+      if (! corrected) {
+         printf ("dirty ok\n");
+      }
+      
+      first_run = 0;
+      for (i = 0;i< bitmap->height;i++)
+         memcpy(bak_bitmap + (bitmap->line[1] - bitmap->line[0])*i,*(bitmap->line+i),w<<3);
+      
+#endif /* PARANOIC */
+
+      /* #define dirty_lines old_dirty_lines     */
+      /* #define dirty_blocks old_dirty_blocks */
+      
+      for (y=0;y<h;y++) {
+         if (dirty_lines[y]) {
+            line_min = y<<3;
+            line_max = line_min + 8;
+            /* old_dirty_lines[y]=1; */
+            for (x=0;x<w;x++) {
+               if (dirty_blocks[y][x]) {
+                  col_min = x<<3;
+                  col_amount = 0;
+                  do { 
+                     col_amount++; 
+                     dirty_blocks[y][x] = 0;
+                     x++; 
+                  } while (dirty_blocks[y][x]); 
+
+                  dirty_blocks[y][x] = 0;
+                  col_amount <<= 3;
+
+                  line_amount = line_max - line_min;
+                  /* Trying to use direct hermes library for fast blitting */
+                  if (SDL_MUSTLOCK(Surface))
+                     SDL_LockSurface(Surface);
+               
+                  Hermes_ConverterCopy (H_ConverterHandle, 
+                     bitmap->line[0] ,
+                     col_min, line_min , 
+                     col_amount,line_amount, bitmap->line[1] - bitmap->line[0],
+                     Surface->pixels, 
+                     col_min, line_min, 
+                     col_amount ,line_amount, Vid_width <<1 );
+               
+                  SDL_UnlockSurface(Surface);
+                  SDL_UpdateRect(Surface,col_min,line_min,col_amount,line_amount);
+               }
+            }
+            dirty_lines[y] = 0;
+         }
+      }
+      
+      /* Vector game .... */
+      break;
+      return ;
+   }
+   
+   /* TODO - It's the real evil - better to use would be original 
+       hermes routines */
+
+#ifdef SDL_DEBUG
+   update_count++;
+#endif
+}
+#endif /* DIRECT_HERMES */
+
+/* shut up the display */
+void sysdep_display_close(void)
+{
+   SDL_FreeSurface(Offscreen_surface);
+
+   /* Restore cursor state */
+   SDL_ShowCursor(cursor_state);
+}
+
+/*
+ * In 8 bpp we should alloc pallete - some ancient people  
+ * are still using 8bpp displays
+ */
+int sysdep_display_alloc_palette(int totalcolors)
+{
+   int ncolors;
+   int i;
+   ncolors = totalcolors;
+
+   fprintf (stderr, "SDL: sysdep_display_alloc_palette(%d);\n",totalcolors);
+   if (Vid_depth != 8)
+      return 0;
+
+#ifndef DIRECT_HERMES
+   Colors = (SDL_Color*) malloc (totalcolors * sizeof(SDL_Color));
+   if( !Colors )
+      return 1;
+   for (i=0;i<totalcolors;i++) {
+      (Colors + i)->r = 0xFF;
+      (Colors + i)->g = 0x00;
+      (Colors + i)->b = 0x00;
+   }
+   SDL_SetColors (Offscreen_surface,Colors,0,totalcolors-1);
+#else /* DIRECT_HERMES */
+   H_PaletteHandle = Hermes_PaletteInstance();
+   if ( !(H_Palette = Hermes_PaletteGet(H_PaletteHandle)) ) {
+      fprintf (stderr_file, "Hermes: Info: PaletteHandle invalid");
+      exit(OSD_NOT_OK);
+   }
+#endif /* DIRECT_HERMES */
+
+   fprintf (stderr, "SDL: Info: Palette with %d colors allocated\n", totalcolors);
+   return 0;
+}
+
+int sysdep_display_set_pen(int pen,unsigned char red, unsigned char green, unsigned char blue)
+{
+   static int warned = 0;
+#ifdef SDL_DEBUG
+   fprintf(stderr,"sysdep_display_set_pen(%d,%d,%d,%d)\n",pen,red,green,blue);
+#endif
+
+#ifndef DIRECT_HERMES
+   if( Colors ) {
+      (Colors + pen)->r = red;
+      (Colors + pen)->g = green;
+      (Colors + pen)->b = blue;
+      if ( (! SDL_SetColors(Offscreen_surface, Colors + pen, pen,1)) && (! warned)) {
+         printf ("Color allocation failed, or > 8 bit display\n");
+         warned = 0;
+      }
+   }
+#else /* DIRECT_HERMES */
+   *(H_Palette + pen) = (red<<16) | ((green) <<8) | (blue );
+   H_Palette_modified = 1; 
+#endif 
+
+#ifdef SDL_DEBUG
+   fprintf(stderr, "STD: Debug: Pen %d modification: r %d, g %d, b, %d\n", pen, red,green,blue);
+#endif /* SDL_DEBUG */
+   return 0;
+}
+
+void sysdep_mouse_poll (void)
+{
+   int i;
+   int x,y;
+   Uint8 buttons;
+
+   buttons = SDL_GetRelativeMouseState( &x, &y);
+   mouse_data[0].deltas[0] = x;
+   mouse_data[0].deltas[1] = y;
+   for(i=0;i<MOUSE_BUTTONS;i++) {
+      mouse_data[0].buttons[i] = buttons & (0x01 << i);
+   }
+}
+
+/* Keyboard procs */
+/* Lighting keyboard leds */
+void sysdep_set_leds(int leds) 
+{
+}
+
+void sysdep_update_keyboard() 
+{
+   struct xmame_keyboard_event kevent;
+   SDL_Event event;
+
+   if (Surface) {
+      while(SDL_PollEvent(&event)) {
+         kevent.press = 0;
+         
+         switch (event.type)
+         {
+            case SDL_KEYDOWN:
+               kevent.press = 1;
+
+               /* ALT-Enter: toggle fullscreen */
+               if ( event.key.keysym.sym == SDLK_RETURN )
+               {
+                  if(event.key.keysym.mod & KMOD_ALT)
+                     SDL_WM_ToggleFullScreen(SDL_GetVideoSurface());
+               }
+
+            case SDL_KEYUP:
+               kevent.scancode = klookup[event.key.keysym.sym];
+               kevent.unicode = event.key.keysym.unicode;
+               xmame_keyboard_register_event(&kevent);
+               if(!kevent.scancode)
+                  fprintf (stderr, "Unknown symbol 0x%x\n",
+                     event.key.keysym.sym);
+#ifdef SDL_DEBUG
+               fprintf (stderr, "Key %s %ssed\n",
+                  SDL_GetKeyName(event.key.keysym.sym),
+                  kevent.press? "pres":"relea");
+#endif
+               break;
+            case SDL_QUIT:
+               /* Shoult leave this to application */
+               exit(OSD_OK);
+               break;
+
+    	    case SDL_JOYAXISMOTION:   
+               if (event.jaxis.which < JOY_AXIS)
+                  joy_data[event.jaxis.which].axis[event.jaxis.axis].val = event.jaxis.value;
+#ifdef SDL_DEBUG
+               fprintf (stderr,"Axis=%d,value=%d\n",event.jaxis.axis ,event.jaxis.value);
+#endif
+		break;
+	    case SDL_JOYBUTTONDOWN:
+
+	    case SDL_JOYBUTTONUP:
+               if (event.jbutton.which < JOY_BUTTONS)
+                  joy_data[event.jbutton.which].buttons[event.jbutton.button] = event.jbutton.state;
+#ifdef SDL_DEBUG
+               fprintf (stderr, "Button=%d,value=%d\n",event.jbutton.button ,event.jbutton.state);
+#endif
+		break;
+
+
+            default:
+#ifdef SDL_DEBUG
+               fprintf(stderr, "SDL: Debug: Other event\n");
+#endif /* SDL_DEBUG */
+               break;
+         }
+    joy_evaluate_moves ();
+      }
+   }
+}
+
+/* added funcions */
+int sysdep_display_16bpp_capable(void)
+{
+   const SDL_VideoInfo* video_info;
+   video_info = SDL_GetVideoInfo();
+   return ( video_info->vfmt->BitsPerPixel >=16);
+}
+
+int list_sdl_modes(struct rc_option *option, const char *arg, int priority)
+{
+   SDL_Rect** vid_modes;
+   int vid_modes_i;
+
+   vid_modes = SDL_ListModes(NULL,SDL_FULLSCREEN);
+   vid_modes_i = 0;
+
+   if ( (! vid_modes) || ((long)vid_modes == -1)) {
+      printf("This option only works in a full-screen mode (eg: linux's framebuffer)\n");
+      return - 1;
+   }
+
+   printf("Modes available:\n");
+
+   while( *(vid_modes+vid_modes_i) ) {
+      printf("\t%d) Mode %d x %d\n",
+         vid_modes_i,
+         (*(vid_modes+vid_modes_i))->w,
+         (*(vid_modes+vid_modes_i))->h
+         );
+   
+      vid_modes_i++;
+   }
+
+   return -1;
+}
diff --git a/src/unix/video-drivers/blit.h b/src/unix/video-drivers/blit.h
new file mode 100644
index 0000000..b009450
--- /dev/null
+++ b/src/unix/video-drivers/blit.h
@@ -0,0 +1,1093 @@
+/* this routine is the generic blit routine used in many cases, through a number
+   of defines it can be customised for specific cases.
+   Currently recognised defines:
+   DEST		ptr of type DEST_PIXEL to which should be blitted, if this is
+		not defined only PUT_IMAGE is called if defined.
+   DEST_PIXEL	type of the buffer to which is blitted, only needed if
+                DEST is defined.
+   DEST_WIDTH   Width of the destination buffer in pixels! Only needed if
+                DEST is defined.
+   SRC_PIXEL    type of the buffer from which is blitted, currently
+                8 bpp (unsigned char) and 16 bpp (unsigned short) are supported.
+   PUT_IMAGE    This function is called to update the parts of the screen
+		which need updating. This is only called if defined.
+   INDIRECT     This needs to be defined if DEST_PIXEL != unsigned char,
+                this is a ptr to a list of pixels/colormappings for the
+                colordepth conversion.
+   BLIT_16BPP_HACK This one speaks for itself, it's a speedup hack for 8bpp
+                to 16bpp blits.
+   PACK_BITS    Write to packed 24bit pixels, DEST_PIXEL must be 32bits and
+                INDIRECT must be on.
+   DOUBLEBUFFER First copy each line to a buffer called doublebuffer_buffer,
+                then do a memcpy to the real destination. This speeds up
+                scaling when writing directly to framebuffer since it
+                tremendously speeds up the reads done to copy one line to
+                the next.
+
+   These routines use long copies so everything should always be long aligned.
+*/
+
+#ifdef PACK_BITS
+/* scale destptr delta's by 3/4 since we're using 32 bits ptr's for a 24 bits
+   dest */
+#define DEST_SCALE 3/4
+#define DEST_PIXEL_SIZE 3
+#define CORRECTED_DEST_WIDTH ((DEST_WIDTH*3)/4)
+#else
+#define DEST_PIXEL_SIZE sizeof(DEST_PIXEL)
+#define CORRECTED_DEST_WIDTH DEST_WIDTH
+#endif
+
+if (yarbsize) /* using arbitrary Y-scaling (Adam D. Moss <adam@gimp.org>) */
+{
+  switch(widthscale)
+    {
+#ifdef INDIRECT
+
+#ifdef BLIT_16BPP_HACK
+#define COPY_LINE2(SRC, END, DST) \
+      {\
+   unsigned short *src = (unsigned short *)(SRC); \
+   unsigned short *end = (unsigned short *)(END); \
+   unsigned int   *dst = (unsigned int   *)(DST); \
+   for(;src<end;src+=4,dst+=4) \
+   { \
+      *(dst  ) = INDIRECT[*(src  )]; \
+      *(dst+1) = INDIRECT[*(src+1)]; \
+      *(dst+2) = INDIRECT[*(src+2)]; \
+      *(dst+3) = INDIRECT[*(src+3)]; \
+   }\
+      }
+#elif defined PACK_BITS
+#define COPY_LINE2(SRC, END, DST) \
+      {\
+   SRC_PIXEL  *src = SRC; \
+   SRC_PIXEL  *end = END; \
+   DEST_PIXEL *dst = DST; \
+   for(;src<end;dst+=3,src+=4) \
+   { \
+      *(dst  ) = (INDIRECT[*(src  )]    ) | (INDIRECT[*(src+1)]<<24); \
+      *(dst+1) = (INDIRECT[*(src+1)]>> 8) | (INDIRECT[*(src+2)]<<16); \
+      *(dst+2) = (INDIRECT[*(src+2)]>>16) | (INDIRECT[*(src+3)]<< 8); \
+   }\
+      }
+#elif defined BLIT_HWSCALE_YUY2
+#define COPY_LINE2(SRC, END, DST) \
+   {\
+      SRC_PIXEL  *src = SRC; \
+      SRC_PIXEL  *end = END; \
+      unsigned long *dst = (unsigned long *)DST; \
+      unsigned int r,y,y2,u,v; \
+      for(;src<end;) \
+      { \
+         r=INDIRECT[*src++]; \
+         y=r&255; \
+         u=(r>>8)&255; \
+         v=(r>>24); \
+         r=INDIRECT[*src++]; \
+         u=(u+((r>>8)&255))/2; \
+         v=(v+(r>>24))/2; \
+         y2=r&255; \
+         *dst++=(y&255)|((u&255)<<8)|((y2&255)<<16)|((v&255)<<24); \
+      } \
+   }
+#else /* normal indirect */
+#define COPY_LINE2(SRC, END, DST) \
+      {\
+   SRC_PIXEL  *src = SRC; \
+   SRC_PIXEL  *end = END; \
+   DEST_PIXEL *dst = DST; \
+   for(;src<end;src+=8,dst+=8) \
+   { \
+      *(dst  ) = INDIRECT[*(src  )]; \
+      *(dst+1) = INDIRECT[*(src+1)]; \
+      *(dst+2) = INDIRECT[*(src+2)]; \
+      *(dst+3) = INDIRECT[*(src+3)]; \
+      *(dst+4) = INDIRECT[*(src+4)]; \
+      *(dst+5) = INDIRECT[*(src+5)]; \
+      *(dst+6) = INDIRECT[*(src+6)]; \
+      *(dst+7) = INDIRECT[*(src+7)]; \
+   }\
+      }
+#endif /* dga_16bpp_hack / packed / normal indirect */
+
+#else  /* not indirect */
+#define COPY_LINE2(SRC, END, DST) \
+   memcpy(DST, SRC, ((END)-(SRC))*DEST_PIXEL_SIZE);
+#endif /* indirect */
+
+#define SCALE_Y(Y) (((Y)*yarbsize)/visual_height)
+#define REPS_FOR_Y(N,YV,YMAX) ((N)* ( (((YV)+1)*yarbsize)/(YMAX) - ((YV)*yarbsize)/(YMAX)))
+
+    case 1:
+#define SCALE_X(X) (X)
+#ifdef DOUBLEBUFFER
+
+#ifdef INDIRECT
+#define COPY_LINE_FOR_Y(YV, YMAX, SRC, END, DST) \
+{ \
+   int reps = REPS_FOR_Y(1, YV, YMAX); \
+   if (reps >0) COPY_LINE2(SRC, END, (DEST_PIXEL *)doublebuffer_buffer); \
+   while (reps-- >0) { memcpy((DST)+(reps*(CORRECTED_DEST_WIDTH)), doublebuffer_buffer, ((END)-(SRC))*DEST_PIXEL_SIZE*SCALE_X(1)); } \
+}
+#else
+#define COPY_LINE_FOR_Y(YV, YMAX, SRC, END, DST) \
+{ \
+   int reps = REPS_FOR_Y(1, YV, YMAX); \
+   while (reps-- >0) COPY_LINE2(SRC, END, (DST)+(reps*(CORRECTED_DEST_WIDTH)));\
+}
+#endif
+
+#else
+#define COPY_LINE_FOR_Y(YV, YMAX, SRC, END, DST) \
+{ \
+   int reps = REPS_FOR_Y(1, YV, YMAX); \
+   if (reps >0) COPY_LINE2(SRC, END, DST); \
+   while (reps-- >1) memcpy((DST)+(reps*(CORRECTED_DEST_WIDTH)), DST, ((END)-(SRC))*DEST_PIXEL_SIZE*SCALE_X(1)); \
+}
+#endif
+/*#define COPY_LINE(SRC, END, DST) { COPY_LINE2(SRC, END, DST) }*/
+#include "blit_core.h"
+break;
+
+#undef SCALE_X
+#undef COPY_LINE2
+
+
+
+
+case 2:
+#define SCALE_X(X) ((X)*2)
+#ifdef INDIRECT
+
+#ifdef PACK_BITS
+#define COPY_LINE2(SRC, END, DST) \
+{ \
+   SRC_PIXEL  *src = SRC; \
+   SRC_PIXEL  *end = END; \
+   DEST_PIXEL *dst = DST; \
+   for(;src<end; src+=2, dst+=3) \
+   { \
+      *(dst  ) = (INDIRECT[*(src  )]    ) | (INDIRECT[*(src  )]<<24); \
+      *(dst+1) = (INDIRECT[*(src  )]>> 8) | (INDIRECT[*(src+1)]<<16); \
+      *(dst+2) = (INDIRECT[*(src+1)]>>16) | (INDIRECT[*(src+1)]<<8); \
+   } \
+}
+#else /* not pack bits */
+#define COPY_LINE2(SRC, END, DST) \
+{ \
+   SRC_PIXEL  *src = SRC; \
+   SRC_PIXEL  *end = END; \
+   DEST_PIXEL *dst = DST; \
+   for(;src<end; src+=8, dst+=16) \
+   { \
+      *(dst   ) = *(dst+ 1) = INDIRECT[*(src  )]; \
+      *(dst+ 2) = *(dst+ 3) = INDIRECT[*(src+1)]; \
+      *(dst+ 4) = *(dst+ 5) = INDIRECT[*(src+2)]; \
+      *(dst+ 6) = *(dst+ 7) = INDIRECT[*(src+3)]; \
+      *(dst+ 8) = *(dst+ 9) = INDIRECT[*(src+4)]; \
+      *(dst+10) = *(dst+11) = INDIRECT[*(src+5)]; \
+      *(dst+12) = *(dst+13) = INDIRECT[*(src+6)]; \
+      *(dst+14) = *(dst+15) = INDIRECT[*(src+7)]; \
+   } \
+}
+#endif /* pack bits */
+
+#else /* not indirect */
+
+#define COPY_LINE2(SRC, END, DST) \
+{ \
+   SRC_PIXEL  *src = SRC; \
+   SRC_PIXEL  *end = END; \
+   DEST_PIXEL *dst = DST; \
+   for(;src<end; src+=8, dst+=16) \
+   { \
+      *(dst   ) = *(dst+ 1) = *(src  ); \
+      *(dst+ 2) = *(dst+ 3) = *(src+1); \
+      *(dst+ 4) = *(dst+ 5) = *(src+2); \
+      *(dst+ 6) = *(dst+ 7) = *(src+3); \
+      *(dst+ 8) = *(dst+ 9) = *(src+4); \
+      *(dst+10) = *(dst+11) = *(src+5); \
+      *(dst+12) = *(dst+13) = *(src+6); \
+      *(dst+14) = *(dst+15) = *(src+7); \
+   } \
+}
+#endif
+#include "blit_core.h"
+break;
+
+#undef SCALE_X
+#undef COPY_LINE2
+
+
+
+
+case 3:
+#define SCALE_X(X)   ((X)*3)
+#ifdef INDIRECT
+
+#define COPY_LINE2(SRC, END, DST) \
+{ \
+   SRC_PIXEL  *src = SRC; \
+   SRC_PIXEL  *end = END; \
+   DEST_PIXEL *dst = DST; \
+   for(;src<end; src+=8, dst+=24) \
+   { \
+      *(dst   ) = *(dst+ 1) = *(dst+ 2) = INDIRECT[*(src  )]; \
+      *(dst+ 3) = *(dst+ 4) = *(dst+ 5) = INDIRECT[*(src+1)]; \
+      *(dst+ 6) = *(dst+ 7) = *(dst+ 8) = INDIRECT[*(src+2)]; \
+      *(dst+ 9) = *(dst+10) = *(dst+11) = INDIRECT[*(src+3)]; \
+      *(dst+12) = *(dst+13) = *(dst+14) = INDIRECT[*(src+4)]; \
+      *(dst+15) = *(dst+16) = *(dst+17) = INDIRECT[*(src+5)]; \
+      *(dst+18) = *(dst+19) = *(dst+20) = INDIRECT[*(src+6)]; \
+      *(dst+21) = *(dst+22) = *(dst+23) = INDIRECT[*(src+7)]; \
+   } \
+}
+#else /* not indirect */
+#define COPY_LINE2(SRC, END, DST) \
+{ \
+   SRC_PIXEL  *src = SRC; \
+   SRC_PIXEL  *end = END; \
+   DEST_PIXEL *dst = DST; \
+   for(;src<end; src+=8, dst+=24) \
+   { \
+      *(dst   ) = *(dst+ 1) = *(dst+ 2) = *(src  ); \
+      *(dst+ 3) = *(dst+ 4) = *(dst+ 5) = *(src+1); \
+      *(dst+ 6) = *(dst+ 7) = *(dst+ 8) = *(src+2); \
+      *(dst+ 9) = *(dst+10) = *(dst+11) = *(src+3); \
+      *(dst+12) = *(dst+13) = *(dst+14) = *(src+4); \
+      *(dst+15) = *(dst+16) = *(dst+17) = *(src+5); \
+      *(dst+18) = *(dst+19) = *(dst+20) = *(src+6); \
+      *(dst+21) = *(dst+22) = *(dst+23) = *(src+7); \
+   } \
+}
+#endif
+#include "blit_core.h"
+break;
+
+#undef SCALE_X
+#undef COPY_LINE2
+
+
+
+
+default:
+#define SCALE_X(X)   ((X)*widthscale)
+
+#ifdef INDIRECT
+
+#ifdef PACK_BITS
+#define COPY_LINE2(SRC, END, DST) \
+{ \
+   SRC_PIXEL  *src = SRC; \
+   SRC_PIXEL  *end = END; \
+   DEST_PIXEL *dst = DST; \
+   DEST_PIXEL pixel; \
+   int i, step=0; \
+   for(;src<end;src++) \
+   { \
+      pixel = INDIRECT[*src]; \
+      for(i=0; i<widthscale; i++,step=(step+1)&3) \
+      { \
+         switch(step) \
+         { \
+            case 0: \
+               *(dst  )  = pixel; \
+               break; \
+            case 1: \
+               *(dst  ) |= pixel << 24; \
+               *(dst+1)  = pixel >> 8; \
+               break; \
+            case 2: \
+               *(dst+1) |= pixel << 16; \
+               *(dst+2)  = pixel >> 16; \
+               break; \
+            case 3: \
+               *(dst+2) |= pixel << 8; \
+               dst+=3; \
+               break; \
+         } \
+      } \
+   } \
+}
+#else
+#define COPY_LINE2(SRC, END, DST) \
+{ \
+   SRC_PIXEL  *src = SRC; \
+   SRC_PIXEL  *end = END; \
+   DEST_PIXEL *dst = DST; \
+   int i; \
+   for(;src<end;src++) \
+   { \
+      const DEST_PIXEL v = INDIRECT[*(src)]; \
+      i=(widthscale+7)/8; \
+      dst+=widthscale&7; \
+      switch (widthscale&7) \
+      { \
+         case 0: do{  dst+=8; \
+                      *(dst-8) = v; \
+         case 7:      *(dst-7) = v; \
+         case 6:      *(dst-6) = v; \
+         case 5:      *(dst-5) = v; \
+         case 4:      *(dst-4) = v; \
+         case 3:      *(dst-3) = v; \
+         case 2:      *(dst-2) = v; \
+         case 1:      *(dst-1) = v; \
+                 } while(--i>0); \
+      } \
+   } \
+}
+#endif
+
+#else
+#define COPY_LINE2(SRC, END, DST) \
+{ \
+   SRC_PIXEL  *src = SRC; \
+   SRC_PIXEL  *end = END; \
+   DEST_PIXEL *dst = DST; \
+   int i; \
+   for(;src<end;src++) \
+   { \
+      const DEST_PIXEL v = *(src); \
+      i=(widthscale+7)/8; \
+      dst+=widthscale&7; \
+      switch (widthscale&7) \
+      { \
+         case 0: do{  dst+=8; \
+                      *(dst-8) = v; \
+         case 7:      *(dst-7) = v; \
+         case 6:      *(dst-6) = v; \
+         case 5:      *(dst-5) = v; \
+         case 4:      *(dst-4) = v; \
+         case 3:      *(dst-3) = v; \
+         case 2:      *(dst-2) = v; \
+         case 1:      *(dst-1) = v; \
+                 } while(--i>0); \
+      } \
+   } \
+}
+#endif
+#include "blit_core.h"
+break;
+
+#undef SCALE_X
+#undef COPY_LINE2
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+#undef COPY_LINE
+
+#undef SCALE_Y
+#undef REPS_FOR_Y
+#undef COPY_LINE_FOR_Y
+
+#define COPY_LINE_FOR_Y(YV,YMAX, SRC,END,DST) COPY_LINE(SRC,END,DST)
+#define REPS_FOR_Y(N,YV,YMAX) SCALE_Y(N)
+    }
+}
+else
+switch (heightscale | (widthscale << 8) | (use_scanlines << 16))
+{
+/* 1x1 */
+
+#ifdef INDIRECT
+
+#ifdef BLIT_16BPP_HACK
+#define COPY_LINE2(SRC, END, DST) \
+   unsigned short *src = (unsigned short *)(SRC); \
+   unsigned short *end = (unsigned short *)(END); \
+   unsigned int   *dst = (unsigned int   *)(DST); \
+   for(;src<end;src+=4,dst+=4) \
+   { \
+      *(dst  ) = INDIRECT[*(src  )]; \
+      *(dst+1) = INDIRECT[*(src+1)]; \
+      *(dst+2) = INDIRECT[*(src+2)]; \
+      *(dst+3) = INDIRECT[*(src+3)]; \
+   }
+#elif defined PACK_BITS
+#define COPY_LINE2(SRC, END, DST) \
+   SRC_PIXEL  *src = SRC; \
+   SRC_PIXEL  *end = END; \
+   DEST_PIXEL *dst = DST; \
+   for(;src<end;dst+=3,src+=4) \
+   { \
+      *(dst  ) = (INDIRECT[*(src  )]    ) | (INDIRECT[*(src+1)]<<24); \
+      *(dst+1) = (INDIRECT[*(src+1)]>> 8) | (INDIRECT[*(src+2)]<<16); \
+      *(dst+2) = (INDIRECT[*(src+2)]>>16) | (INDIRECT[*(src+3)]<< 8); \
+   }
+#elif defined BLIT_HWSCALE_YUY2
+#define COPY_LINE2(SRC, END, DST) \
+   {\
+      SRC_PIXEL  *src = SRC; \
+      SRC_PIXEL  *end = END; \
+      unsigned long *dst = (unsigned long *)DST; \
+      unsigned int r,r2,y,y2,uv1,uv2; \
+      for(;src<end;) \
+      { \
+         r=INDIRECT[*src++]; \
+         r2=INDIRECT[*src++]; \
+         y=r&0xff; \
+         y2=r2&0xff0000; \
+         uv1=(r&0xff00ff00)>>1; \
+         uv2=(r2&0xff00ff00)>>1; \
+         uv1=(uv1+uv2)&0xff00ff00; \
+         *dst++=y|y2|uv1; \
+      } \
+   }
+#else /* normal indirect */
+#define COPY_LINE2(SRC, END, DST) \
+   SRC_PIXEL  *src = SRC; \
+   SRC_PIXEL  *end = END; \
+   DEST_PIXEL *dst = DST; \
+   for(;src<end;src+=8,dst+=8) \
+   { \
+      *(dst  ) = INDIRECT[*(src  )]; \
+      *(dst+1) = INDIRECT[*(src+1)]; \
+      *(dst+2) = INDIRECT[*(src+2)]; \
+      *(dst+3) = INDIRECT[*(src+3)]; \
+      *(dst+4) = INDIRECT[*(src+4)]; \
+      *(dst+5) = INDIRECT[*(src+5)]; \
+      *(dst+6) = INDIRECT[*(src+6)]; \
+      *(dst+7) = INDIRECT[*(src+7)]; \
+   }
+#endif /* dga_16bpp_hack / packed / normal indirect */
+
+#else  /* not indirect */
+#ifdef BLIT_HWSCALE_YUY2
+#define COPY_LINE2(SRC, END, DST) \
+   {\
+      SRC_PIXEL  *src = SRC; \
+      SRC_PIXEL  *end = END; \
+      unsigned char *dst = (unsigned char *)DST; \
+      int r,g,b,r2,g2,b2,y,y2,u,v; \
+      for(;src<end;) \
+      { \
+         r=g=b=*src++; \
+         r&=RMASK;  r>>=16; \
+         g&=GMASK;  g>>=8; \
+         b&=BMASK;  b>>=0; \
+         r2=g2=b2=*src++; \
+         r2&=RMASK;  r2>>=16; \
+         g2&=GMASK;  g2>>=8; \
+         b2&=BMASK;  b2>>=0; \
+         y = (( 9897*r + 19235*g + 3736*b ) >> 15); \
+         y2 = (( 9897*r2 + 19235*g2 + 3736*b2 ) >> 15); \
+         r+=r2; g+=g2; b+=b2; \
+         *dst++=y; \
+         u = (( -(5537/2)*r - (10878/2)*g + (16384/2)*b ) >> 15) + 128; \
+         *dst++=u; \
+         v = (( (16384/2)*r - (13730/2)*g -(2664/2)*b ) >> 15 ) + 128; \
+         *dst++=y2; \
+         *dst++=v; \
+      }\
+   }
+#else
+#define COPY_LINE2(SRC, END, DST) \
+   memcpy(DST, SRC, ((END)-(SRC))*DEST_PIXEL_SIZE);
+#endif
+#endif /* indirect */
+
+#define SCALE_X(X) (X)
+#define SCALE_Y(Y) (Y)
+
+/* 1x1 we don't do scanlines with 1x1 */
+case 0x00101:
+case 0x10101:
+#define COPY_LINE(SRC, END, DST) { COPY_LINE2(SRC, END, DST) }
+#include "blit_core.h"
+#undef COPY_LINE
+break;
+
+#undef SCALE_Y
+
+/* 1x2 */
+
+#define SCALE_Y(Y)   ((Y)<<1)
+
+/* 1x2 no scanlines */
+case 0x00102:
+
+#ifdef DOUBLEBUFFER
+
+#ifdef INDIRECT
+#define COPY_LINE(SRC, END, DST) \
+{ \
+   COPY_LINE2(SRC, END, (DEST_PIXEL *)doublebuffer_buffer) \
+   memcpy((DST),                        doublebuffer_buffer, ((END)-(SRC))*DEST_PIXEL_SIZE); \
+   memcpy((DST)+(CORRECTED_DEST_WIDTH), doublebuffer_buffer, ((END)-(SRC))*DEST_PIXEL_SIZE); \
+}
+#else
+#define COPY_LINE(SRC, END, DST) \
+{ \
+   COPY_LINE2(SRC, END, (DST)); \
+   COPY_LINE2(SRC, END, (DST)+(CORRECTED_DEST_WIDTH)); \
+}
+#endif
+
+#else
+#define COPY_LINE(SRC, END, DST) \
+{ \
+   COPY_LINE2(SRC, END, DST) \
+   memcpy((DST)+(CORRECTED_DEST_WIDTH), DST, ((END)-(SRC))*DEST_PIXEL_SIZE); \
+}
+#endif
+
+#include "blit_core.h"
+#undef COPY_LINE
+break;
+
+/* 1x2 scanlines */
+case 0x10102:
+#define COPY_LINE(SRC, END, DST) { COPY_LINE2(SRC, END, DST) }
+#include "blit_core.h"
+#undef COPY_LINE
+break;
+
+#undef COPY_LINE2
+#undef SCALE_X
+#undef SCALE_Y
+
+
+/* 2x2 */
+
+#ifdef INDIRECT
+
+#ifdef PACK_BITS
+#define COPY_LINE2(SRC, END, DST) \
+   SRC_PIXEL  *src = SRC; \
+   SRC_PIXEL  *end = END; \
+   DEST_PIXEL *dst = DST; \
+   for(;src<end; src+=2, dst+=3) \
+   { \
+      *(dst  ) = (INDIRECT[*(src  )]    ) | (INDIRECT[*(src  )]<<24); \
+      *(dst+1) = (INDIRECT[*(src  )]>> 8) | (INDIRECT[*(src+1)]<<16); \
+      *(dst+2) = (INDIRECT[*(src+1)]>>16) | (INDIRECT[*(src+1)]<<8); \
+   }
+#elif defined BLIT_HWSCALE_YUY2
+#define COPY_LINE2(SRC, END, DST) \
+   {\
+      SRC_PIXEL  *src = SRC; \
+      SRC_PIXEL  *end = END; \
+      unsigned int *dst = (unsigned int *)DST; \
+      int r; \
+      for(;src<end;) \
+      { \
+          r=INDIRECT[*src++]; \
+          *dst++=r; \
+          r=INDIRECT[*src++]; \
+          *dst++=r; \
+          r=INDIRECT[*src++]; \
+          *dst++=r; \
+          r=INDIRECT[*src++]; \
+          *dst++=r; \
+          r=INDIRECT[*src++]; \
+          *dst++=r; \
+          r=INDIRECT[*src++]; \
+          *dst++=r; \
+          r=INDIRECT[*src++]; \
+          *dst++=r; \
+          r=INDIRECT[*src++]; \
+          *dst++=r; \
+      } \
+   }
+#else /* not pack bits */
+#define COPY_LINE2(SRC, END, DST) \
+   SRC_PIXEL  *src = SRC; \
+   SRC_PIXEL  *end = END; \
+   DEST_PIXEL *dst = DST; \
+   for(;src<end; src+=8, dst+=16) \
+   { \
+      *(dst   ) = *(dst+ 1) = INDIRECT[*(src  )]; \
+      *(dst+ 2) = *(dst+ 3) = INDIRECT[*(src+1)]; \
+      *(dst+ 4) = *(dst+ 5) = INDIRECT[*(src+2)]; \
+      *(dst+ 6) = *(dst+ 7) = INDIRECT[*(src+3)]; \
+      *(dst+ 8) = *(dst+ 9) = INDIRECT[*(src+4)]; \
+      *(dst+10) = *(dst+11) = INDIRECT[*(src+5)]; \
+      *(dst+12) = *(dst+13) = INDIRECT[*(src+6)]; \
+      *(dst+14) = *(dst+15) = INDIRECT[*(src+7)]; \
+   }
+#endif /* pack bits */
+
+#else /* not indirect */
+
+#ifdef BLIT_HWSCALE_YUY2
+#define COPY_LINE2(SRC, END, DST) \
+   {\
+      SRC_PIXEL  *src = SRC; \
+      SRC_PIXEL  *end = END; \
+      unsigned char *dst = (unsigned char *)DST; \
+      int r,g,b,y,u,v; \
+      for(;src<end;) \
+      { \
+         r=g=b=*src++; \
+         r&=RMASK;  r>>=16; \
+         g&=GMASK;  g>>=8; \
+         b&=BMASK;  b>>=0; \
+         y = (( 9897*r + 19235*g + 3736*b ) >> 15); \
+         *dst++=y; \
+         u = (( -(5537)*r - (10878)*g + (16384)*b ) >> 15) + 128; \
+         *dst++=u; \
+         v = (( (16384)*r - (13730)*g -(2664)*b ) >> 15 ) + 128; \
+         *dst++=y; \
+         *dst++=v; \
+      }\
+   }
+#else
+#define COPY_LINE2(SRC, END, DST) \
+   SRC_PIXEL  *src = SRC; \
+   SRC_PIXEL  *end = END; \
+   DEST_PIXEL *dst = DST; \
+   for(;src<end; src+=8, dst+=16) \
+   { \
+      *(dst   ) = *(dst+ 1) = *(src  ); \
+      *(dst+ 2) = *(dst+ 3) = *(src+1); \
+      *(dst+ 4) = *(dst+ 5) = *(src+2); \
+      *(dst+ 6) = *(dst+ 7) = *(src+3); \
+      *(dst+ 8) = *(dst+ 9) = *(src+4); \
+      *(dst+10) = *(dst+11) = *(src+5); \
+      *(dst+12) = *(dst+13) = *(src+6); \
+      *(dst+14) = *(dst+15) = *(src+7); \
+   }
+#endif
+#endif
+
+#define SCALE_X(X)   ((X)<<1)
+#define SCALE_Y(Y)   ((Y))
+
+/* 2x1 no scanlines */
+case 0x00201:
+
+#ifdef DOUBLEBUFFER
+#define COPY_LINE(SRC, END, DST) \
+{ \
+   COPY_LINE2(SRC, END, (DEST_PIXEL *)doublebuffer_buffer) \
+   memcpy((DST), doublebuffer_buffer, ((END)-(SRC))*DEST_PIXEL_SIZE*2); \
+}
+#else
+#define COPY_LINE(SRC, END, DST) \
+{ \
+   COPY_LINE2(SRC, END, DST) \
+}
+#endif
+
+#include "blit_core.h"
+#undef COPY_LINE
+break;
+
+#undef SCALE_X
+#undef SCALE_Y
+
+#define SCALE_X(X)   ((X)<<1)
+#define SCALE_Y(Y)   ((Y)<<1)
+
+/* 2x2 no scanlines */
+case 0x00202:
+
+#ifdef DOUBLEBUFFER
+#define COPY_LINE(SRC, END, DST) \
+{ \
+   COPY_LINE2(SRC, END, (DEST_PIXEL *)doublebuffer_buffer) \
+   memcpy((DST),                        doublebuffer_buffer, ((END)-(SRC))*DEST_PIXEL_SIZE*2); \
+   memcpy((DST)+(CORRECTED_DEST_WIDTH), doublebuffer_buffer, ((END)-(SRC))*DEST_PIXEL_SIZE*2); \
+}
+#else
+#define COPY_LINE(SRC, END, DST) \
+{ \
+   COPY_LINE2(SRC, END, DST) \
+   memcpy((DST)+(CORRECTED_DEST_WIDTH), DST, ((END)-(SRC))*DEST_PIXEL_SIZE*2); \
+}
+#endif
+
+#include "blit_core.h"
+#undef COPY_LINE
+break;
+
+/* 2x2 scanlines */
+case 0x10202:
+
+#ifdef DOUBLEBUFFER
+#define COPY_LINE(SRC, END, DST) \
+{ \
+   COPY_LINE2(SRC, END, (DEST_PIXEL *)doublebuffer_buffer) \
+   memcpy((DST),                        doublebuffer_buffer, ((END)-(SRC))*DEST_PIXEL_SIZE*2); \
+}
+#else
+#define COPY_LINE(SRC, END, DST) { COPY_LINE2(SRC, END, DST) }
+#endif
+
+#include "blit_core.h"
+#undef COPY_LINE
+break;
+
+#undef COPY_LINE2
+#undef SCALE_X
+#undef SCALE_Y
+
+#ifndef PACK_BITS
+/* 3x3 */
+
+/* this macro is used to copy a line */
+#ifdef INDIRECT
+
+#define COPY_LINE2(SRC, END, DST) \
+   SRC_PIXEL  *src = SRC; \
+   SRC_PIXEL  *end = END; \
+   DEST_PIXEL *dst = DST; \
+   for(;src<end; src+=8, dst+=24) \
+   { \
+      *(dst   ) = *(dst+ 1) = *(dst+ 2) = INDIRECT[*(src  )]; \
+      *(dst+ 3) = *(dst+ 4) = *(dst+ 5) = INDIRECT[*(src+1)]; \
+      *(dst+ 6) = *(dst+ 7) = *(dst+ 8) = INDIRECT[*(src+2)]; \
+      *(dst+ 9) = *(dst+10) = *(dst+11) = INDIRECT[*(src+3)]; \
+      *(dst+12) = *(dst+13) = *(dst+14) = INDIRECT[*(src+4)]; \
+      *(dst+15) = *(dst+16) = *(dst+17) = INDIRECT[*(src+5)]; \
+      *(dst+18) = *(dst+19) = *(dst+20) = INDIRECT[*(src+6)]; \
+      *(dst+21) = *(dst+22) = *(dst+23) = INDIRECT[*(src+7)]; \
+   }
+#else /* not indirect */
+#define COPY_LINE2(SRC, END, DST) \
+   SRC_PIXEL  *src = SRC; \
+   SRC_PIXEL  *end = END; \
+   DEST_PIXEL *dst = DST; \
+   for(;src<end; src+=8, dst+=24) \
+   { \
+      *(dst   ) = *(dst+ 1) = *(dst+ 2) = *(src  ); \
+      *(dst+ 3) = *(dst+ 4) = *(dst+ 5) = *(src+1); \
+      *(dst+ 6) = *(dst+ 7) = *(dst+ 8) = *(src+2); \
+      *(dst+ 9) = *(dst+10) = *(dst+11) = *(src+3); \
+      *(dst+12) = *(dst+13) = *(dst+14) = *(src+4); \
+      *(dst+15) = *(dst+16) = *(dst+17) = *(src+5); \
+      *(dst+18) = *(dst+19) = *(dst+20) = *(src+6); \
+      *(dst+21) = *(dst+22) = *(dst+23) = *(src+7); \
+   }
+#endif
+
+#define SCALE_X(X)   ((X)*3)
+#define SCALE_Y(Y)   ((Y))
+
+/* 3x1 no scanlines */
+case 0x00301:
+
+#ifdef DOUBLEBUFFER
+#define COPY_LINE(SRC, END, DST) \
+{ \
+   COPY_LINE2(SRC, END, (DEST_PIXEL *)doublebuffer_buffer) \
+   memcpy((DST), doublebuffer_buffer, ((END)-(SRC))*DEST_PIXEL_SIZE*3); \
+}
+#else
+#define COPY_LINE(SRC, END, DST) \
+{ \
+   COPY_LINE2(SRC, END, DST) \
+}
+#endif
+
+#include "blit_core.h"
+#undef COPY_LINE
+break;
+
+#undef SCALE_X
+#undef SCALE_Y
+
+#define SCALE_X(X)   ((X)*3)
+#define SCALE_Y(Y)   ((Y)*3)
+
+/* 3x3 no scanlines */
+case 0x00303:
+
+/* should we use doublebuffering ? */
+#ifdef DOUBLEBUFFER
+#define COPY_LINE(SRC, END, DST) \
+{ \
+   COPY_LINE2(SRC, END, (DEST_PIXEL *)doublebuffer_buffer) \
+   memcpy((DST),                          doublebuffer_buffer, ((END)-(SRC))*DEST_PIXEL_SIZE*3); \
+   memcpy((DST)+(CORRECTED_DEST_WIDTH),   doublebuffer_buffer, ((END)-(SRC))*DEST_PIXEL_SIZE*3); \
+   memcpy((DST)+(CORRECTED_DEST_WIDTH)*2, doublebuffer_buffer, ((END)-(SRC))*DEST_PIXEL_SIZE*3); \
+}
+#else
+#define COPY_LINE(SRC, END, DST) \
+{ \
+   COPY_LINE2(SRC, END, DST) \
+   memcpy((DST)+(CORRECTED_DEST_WIDTH),   DST, ((END)-(SRC))*DEST_PIXEL_SIZE*3); \
+   memcpy((DST)+(CORRECTED_DEST_WIDTH)*2, DST, ((END)-(SRC))*DEST_PIXEL_SIZE*3); \
+}
+#endif
+
+#include "blit_core.h"
+#undef COPY_LINE
+break;
+
+/* 3x3 scanlines */
+case 0x10303:
+
+/* should we use doublebuffering ? */
+#ifdef DOUBLEBUFFER
+#define COPY_LINE(SRC, END, DST) \
+{ \
+   COPY_LINE2(SRC, END, (DEST_PIXEL *)doublebuffer_buffer) \
+   memcpy((DST),                          doublebuffer_buffer, ((END)-(SRC))*DEST_PIXEL_SIZE*3); \
+   memcpy((DST)+(CORRECTED_DEST_WIDTH),   doublebuffer_buffer, ((END)-(SRC))*DEST_PIXEL_SIZE*3); \
+}
+#else
+#define COPY_LINE(SRC, END, DST) \
+{ \
+   COPY_LINE2(SRC, END, DST) \
+   memcpy((DST)+(CORRECTED_DEST_WIDTH),   DST, ((END)-(SRC))*DEST_PIXEL_SIZE*3); \
+}
+#endif
+
+#include "blit_core.h"
+#undef COPY_LINE
+break;
+
+#undef COPY_LINE2
+#undef SCALE_X
+#undef SCALE_Y
+
+/* 4x4 */
+
+#ifdef INDIRECT
+
+#define COPY_LINE2(SRC, END, DST) \
+   SRC_PIXEL  *src = SRC; \
+   SRC_PIXEL  *end = END; \
+   DEST_PIXEL *dst = DST; \
+   for(;src<end; src+=8, dst+=32) \
+   { \
+      *(dst   ) = *(dst+ 1) = *(dst+ 2) = *(dst+ 3) = INDIRECT[*(src  )]; \
+      *(dst+ 4) = *(dst+ 5) = *(dst+ 6) = *(dst+ 7) = INDIRECT[*(src+1)]; \
+      *(dst+ 8) = *(dst+ 9) = *(dst+10) = *(dst+11) = INDIRECT[*(src+2)]; \
+      *(dst+12) = *(dst+13) = *(dst+14) = *(dst+15) = INDIRECT[*(src+3)]; \
+      *(dst+16) = *(dst+17) = *(dst+18) = *(dst+19) = INDIRECT[*(src+4)]; \
+      *(dst+20) = *(dst+21) = *(dst+22) = *(dst+23) = INDIRECT[*(src+5)]; \
+      *(dst+24) = *(dst+25) = *(dst+26) = *(dst+27) = INDIRECT[*(src+6)]; \
+      *(dst+28) = *(dst+29) = *(dst+30) = *(dst+31) = INDIRECT[*(src+7)]; \
+   }
+#else /* not indirect */
+#define COPY_LINE2(SRC, END, DST) \
+   SRC_PIXEL  *src = SRC; \
+   SRC_PIXEL  *end = END; \
+   DEST_PIXEL *dst = DST; \
+   for(;src<end; src+=8, dst+=32) \
+   { \
+      *(dst   ) = *(dst+ 1) = *(dst+ 2) = *(dst+ 3) = *(src  ); \
+      *(dst+ 4) = *(dst+ 5) = *(dst+ 6) = *(dst+ 7) = *(src+1); \
+      *(dst+ 8) = *(dst+ 9) = *(dst+10) = *(dst+11) = *(src+2); \
+      *(dst+12) = *(dst+13) = *(dst+14) = *(dst+15) = *(src+3); \
+      *(dst+16) = *(dst+17) = *(dst+18) = *(dst+19) = *(src+4); \
+      *(dst+20) = *(dst+21) = *(dst+22) = *(dst+23) = *(src+5); \
+      *(dst+24) = *(dst+25) = *(dst+26) = *(dst+27) = *(src+6); \
+      *(dst+28) = *(dst+29) = *(dst+30) = *(dst+31) = *(src+7); \
+   }
+#endif
+
+#define SCALE_X(X)   ((X)<<2)
+#define SCALE_Y(Y)   ((Y)<<2)
+
+/* 4x4 no scanlines */
+case 0x00404:
+
+/* should we use doublebuffering ? */
+#ifdef DOUBLEBUFFER
+#define COPY_LINE(SRC, END, DST) \
+{ \
+   COPY_LINE2(SRC, END, (DEST_PIXEL *)doublebuffer_buffer) \
+   memcpy((DST),                          doublebuffer_buffer, ((END)-(SRC))*DEST_PIXEL_SIZE*4); \
+   memcpy((DST)+(CORRECTED_DEST_WIDTH),   doublebuffer_buffer, ((END)-(SRC))*DEST_PIXEL_SIZE*4); \
+   memcpy((DST)+(CORRECTED_DEST_WIDTH)*2, doublebuffer_buffer, ((END)-(SRC))*DEST_PIXEL_SIZE*4); \
+   memcpy((DST)+(CORRECTED_DEST_WIDTH)*3, doublebuffer_buffer, ((END)-(SRC))*DEST_PIXEL_SIZE*4); \
+}
+#else
+#define COPY_LINE(SRC, END, DST) \
+{ \
+   COPY_LINE2(SRC, END, DST) \
+   memcpy((DST)+(CORRECTED_DEST_WIDTH),   DST, ((END)-(SRC))*DEST_PIXEL_SIZE*4); \
+   memcpy((DST)+(CORRECTED_DEST_WIDTH)*2, DST, ((END)-(SRC))*DEST_PIXEL_SIZE*4); \
+   memcpy((DST)+(CORRECTED_DEST_WIDTH)*3, DST, ((END)-(SRC))*DEST_PIXEL_SIZE*4); \
+}
+#endif
+
+#include "blit_core.h"
+#undef COPY_LINE
+break;
+
+/* 4x4 scanlines */
+case 0x10404:
+
+/* should we use doublebuffering ? */
+#ifdef DOUBLEBUFFER
+#define COPY_LINE(SRC, END, DST) \
+{ \
+   COPY_LINE2(SRC, END, (DEST_PIXEL *)doublebuffer_buffer) \
+   memcpy((DST),                          doublebuffer_buffer, ((END)-(SRC))*DEST_PIXEL_SIZE*4); \
+   memcpy((DST)+(CORRECTED_DEST_WIDTH),   doublebuffer_buffer, ((END)-(SRC))*DEST_PIXEL_SIZE*4); \
+   memcpy((DST)+(CORRECTED_DEST_WIDTH)*2, doublebuffer_buffer, ((END)-(SRC))*DEST_PIXEL_SIZE*4); \
+}
+#else
+#define COPY_LINE(SRC, END, DST) \
+{ \
+   COPY_LINE2(SRC, END, DST) \
+   memcpy((DST)+(CORRECTED_DEST_WIDTH),   DST, ((END)-(SRC))*DEST_PIXEL_SIZE*4); \
+   memcpy((DST)+(CORRECTED_DEST_WIDTH)*2, DST, ((END)-(SRC))*DEST_PIXEL_SIZE*4); \
+}
+#endif
+
+#include "blit_core.h"
+#undef COPY_LINE
+break;
+
+#undef COPY_LINE2
+#undef SCALE_X
+#undef SCALE_Y
+
+#endif /* #ifndef PACK_BITS */
+
+/* Generic scaling code here (arbitrary values) */
+
+/* This is what happens when you give an assembly-language programmer
+   a C compiler.  Thanks to td, of course.                             -JDL */
+
+default:
+
+#ifdef INDIRECT
+
+#ifdef PACK_BITS
+#define COPY_LINE2(SRC, END, DST) \
+   SRC_PIXEL  *src = SRC; \
+   SRC_PIXEL  *end = END; \
+   DEST_PIXEL *dst = DST; \
+   DEST_PIXEL pixel; \
+   int i, step=0; \
+   for(;src<end;src++) \
+   { \
+      pixel = INDIRECT[*src]; \
+      for(i=0; i<widthscale; i++,step=(step+1)&3) \
+      { \
+         switch(step) \
+         { \
+            case 0: \
+               *(dst  )  = pixel; \
+               break; \
+            case 1: \
+               *(dst  ) |= pixel << 24; \
+               *(dst+1)  = pixel >> 8; \
+               break; \
+            case 2: \
+               *(dst+1) |= pixel << 16; \
+               *(dst+2)  = pixel >> 16; \
+               break; \
+            case 3: \
+               *(dst+2) |= pixel << 8; \
+               dst+=3; \
+               break; \
+         } \
+      } \
+   }
+#else
+#define COPY_LINE2(SRC, END, DST) \
+   SRC_PIXEL  *src = SRC; \
+   SRC_PIXEL  *end = END; \
+   DEST_PIXEL *dst = DST; \
+   int i; \
+   for(;src<end;src++) \
+   { \
+      const DEST_PIXEL v = INDIRECT[*(src)]; \
+      i=(widthscale+7)/8; \
+      dst+=widthscale&7; \
+      switch (widthscale&7) \
+      { \
+         case 0: do{  dst+=8; \
+                      *(dst-8) = v; \
+         case 7:      *(dst-7) = v; \
+         case 6:      *(dst-6) = v; \
+         case 5:      *(dst-5) = v; \
+         case 4:      *(dst-4) = v; \
+         case 3:      *(dst-3) = v; \
+         case 2:      *(dst-2) = v; \
+         case 1:      *(dst-1) = v; \
+                 } while(--i>0); \
+      } \
+   }
+#endif
+
+#else
+#define COPY_LINE2(SRC, END, DST) \
+   SRC_PIXEL  *src = SRC; \
+   SRC_PIXEL  *end = END; \
+   DEST_PIXEL *dst = DST; \
+   int i; \
+   for(;src<end;src++) \
+   { \
+      const DEST_PIXEL v = *(src); \
+      i=(widthscale+7)/8; \
+      dst+=widthscale&7; \
+      switch (widthscale&7) \
+      { \
+         case 0: do{  dst+=8; \
+                      *(dst-8) = v; \
+         case 7:      *(dst-7) = v; \
+         case 6:      *(dst-6) = v; \
+         case 5:      *(dst-5) = v; \
+         case 4:      *(dst-4) = v; \
+         case 3:      *(dst-3) = v; \
+         case 2:      *(dst-2) = v; \
+         case 1:      *(dst-1) = v; \
+                 } while(--i>0); \
+      } \
+   }
+#endif
+
+#define SCALE_X(X)   ((X)*widthscale)
+#define SCALE_Y(Y)   ((Y)*heightscale)
+
+/* should we use doublebuffering ? */
+#ifdef DOUBLEBUFFER
+#define COPY_LINE(SRC, END, DST) \
+{ \
+   int max_i = heightscale-use_scanlines; \
+   COPY_LINE2(SRC, END, (DEST_PIXEL *)doublebuffer_buffer) \
+   dst = (DST); \
+   if (max_i < 1) max_i = 1; \
+   for(i=0; i<max_i; i++, dst+=CORRECTED_DEST_WIDTH) \
+      memcpy(dst, doublebuffer_buffer, ((END)-(SRC))*DEST_PIXEL_SIZE*widthscale); \
+}
+#else
+#define COPY_LINE(SRC, END, DST) \
+{ \
+   COPY_LINE2(SRC, END, DST) \
+   dst = (DST) + (CORRECTED_DEST_WIDTH); \
+   for(i=1; i<(heightscale-use_scanlines); i++, dst+=CORRECTED_DEST_WIDTH) \
+      memcpy(dst, DST, ((END)-(SRC))*DEST_PIXEL_SIZE*widthscale); \
+}
+#endif
+
+#include "blit_core.h"
+#undef COPY_LINE
+
+#undef COPY_LINE2
+#undef SCALE_X
+#undef SCALE_Y
+
+break;      
+}
+
+#ifdef DEST_SCALE
+#undef DEST_SCALE
+#endif
+#undef DEST_PIXEL_SIZE
+#undef CORRECTED_DEST_WIDTH
+
+
+#undef REPS_FOR_Y
+#undef COPY_LINE_FOR_Y
diff --git a/src/unix/video-drivers/blit_core.h b/src/unix/video-drivers/blit_core.h
new file mode 100644
index 0000000..3a89fb1
--- /dev/null
+++ b/src/unix/video-drivers/blit_core.h
@@ -0,0 +1,348 @@
+/* this file is used by blit.h -- don't use it directly ! */
+
+#ifdef DEST_SCALE
+#define DEST_SCALE_X(X)   (SCALE_X(X) * DEST_SCALE)
+#define DEST_SCALE_Y(Y)   (SCALE_Y(Y) * DEST_SCALE)
+#else
+#define DEST_SCALE_X(X)   SCALE_X(X)
+#define DEST_SCALE_Y(Y)   SCALE_Y(Y)
+#endif
+
+if (effect) {
+  switch(effect) {
+
+  default:
+  case EFFECT_SCALE2X:
+    {
+#  ifdef DEST
+     if (!blit_hardware_rotation && (blit_flipx || blit_flipy || blit_swapxy)) {
+       int y;
+       SRC_PIXEL *line_src;
+       DEST_PIXEL *line_dest = (DEST_PIXEL *)(DEST);
+       for (y = visual.min_y; y <= visual.max_y; line_dest+=DEST_SCALE_Y(DEST_WIDTH), y++) {
+	       rotate_func(rotate_dbbuf0, bitmap, y-1);
+	       rotate_func(rotate_dbbuf1, bitmap, y);
+	       rotate_func(rotate_dbbuf2, bitmap, y+1);
+	       line_src = (SRC_PIXEL *)rotate_dbbuf;
+
+#	ifdef INDIRECT
+#		ifdef DOUBLEBUFFER
+		  effect_scale2x_func(effect_dbbuf, effect_dbbuf+DEST_WIDTH*DEST_PIXEL_SIZE, rotate_dbbuf0, rotate_dbbuf1, rotate_dbbuf2, visual_width, INDIRECT);
+		  memcpy(line_dest, effect_dbbuf, DEST_WIDTH*DEST_PIXEL_SIZE*2);
+#		else
+		  effect_scale2x_func(line_dest, line_dest+DEST_WIDTH, rotate_dbbuf0, rotate_dbbuf1, rotate_dbbuf2, visual_width, INDIRECT);
+#		endif
+#	else
+#		ifdef DOUBLEBUFFER
+		  effect_scale2x_direct_func(effect_dbbuf, effect_dbbuf+DEST_WIDTH*DEST_PIXEL_SIZE, rotate_dbbuf0, rotate_dbbuf1, rotate_dbbuf2, visual_width);
+		  memcpy(line_dest, effect_dbbuf, DEST_WIDTH*DEST_PIXEL_SIZE*2);
+#		else
+		  effect_scale2x_direct_func(line_dest, line_dest+DEST_WIDTH, rotate_dbbuf0, rotate_dbbuf1, rotate_dbbuf2, visual_width);
+#		endif
+#	endif
+       }
+     } else {
+	int src_width = (((SRC_PIXEL *)bitmap->line[1]) - ((SRC_PIXEL *)bitmap->line[0]));
+	SRC_PIXEL *line_src = (SRC_PIXEL *)bitmap->line[visual.min_y]   + visual.min_x;
+	SRC_PIXEL *line_end = (SRC_PIXEL *)bitmap->line[visual.max_y+1] + visual.min_x;
+	DEST_PIXEL *line_dest = (DEST_PIXEL *)(DEST);
+
+	for (;line_src < line_end; line_dest+=DEST_SCALE_Y(DEST_WIDTH), line_src+=src_width) {
+
+#	ifdef INDIRECT
+#		ifdef DOUBLEBUFFER
+		  effect_scale2x_func(effect_dbbuf, effect_dbbuf+DEST_WIDTH*DEST_PIXEL_SIZE, line_src-src_width, line_src, line_src+src_width, visual_width, INDIRECT);
+		  memcpy(line_dest, effect_dbbuf, DEST_WIDTH*DEST_PIXEL_SIZE*2);
+#		else
+		  effect_scale2x_func(line_dest, line_dest+DEST_WIDTH, line_src-src_width, line_src, line_src+src_width, visual_width, INDIRECT);
+#		endif
+#	else
+#		ifdef DOUBLEBUFFER
+		  effect_scale2x_direct_func(effect_dbbuf, effect_dbbuf+DEST_WIDTH*DEST_PIXEL_SIZE, line_src-src_width, line_src, line_src+src_width, visual_width);
+		  memcpy(line_dest, effect_dbbuf, DEST_WIDTH*DEST_PIXEL_SIZE*2);
+#		else
+		  effect_scale2x_direct_func(line_dest, line_dest+DEST_WIDTH, line_src-src_width, line_src, line_src+src_width, visual_width);
+#		endif
+#	endif
+	}
+     }
+#  endif
+#  ifdef PUT_IMAGE
+      PUT_IMAGE(0, 0, SCALE_X(visual_width), SCALE_Y(visual_height))
+#  endif      
+  }
+  break;
+
+    case EFFECT_SCAN2:
+      {
+#  ifdef DEST
+     if (!blit_hardware_rotation && (blit_flipx || blit_flipy || blit_swapxy)) {
+       int y;
+       SRC_PIXEL *line_src;
+       DEST_PIXEL *line_dest = (DEST_PIXEL *)(DEST);
+       for (y = visual.min_y; y <= visual.max_y; line_dest+=DEST_SCALE_Y(DEST_WIDTH), y++) {
+	       rotate_func(rotate_dbbuf, bitmap, y);
+	       line_src = (SRC_PIXEL *)rotate_dbbuf;
+
+#	ifdef INDIRECT
+#		ifdef DOUBLEBUFFER
+		  effect_scan2_func(effect_dbbuf, effect_dbbuf+DEST_WIDTH*DEST_PIXEL_SIZE, line_src, visual_width, INDIRECT);
+		  memcpy(line_dest, effect_dbbuf, DEST_WIDTH*DEST_PIXEL_SIZE*2);
+#		else
+		  effect_scan2_func(line_dest, line_dest+DEST_WIDTH, line_src, visual_width, INDIRECT);
+#		endif
+#	else
+#		ifdef DOUBLEBUFFER
+		  effect_scan2_direct_func(effect_dbbuf, effect_dbbuf+DEST_WIDTH*DEST_PIXEL_SIZE, line_src, visual_width);
+		  memcpy(line_dest, effect_dbbuf, DEST_WIDTH*DEST_PIXEL_SIZE*2);
+#		else
+		  effect_scan2_direct_func(line_dest, line_dest+DEST_WIDTH, line_src, visual_width);
+#		endif
+#	endif
+       }
+     } else {
+	int src_width = (((SRC_PIXEL *)bitmap->line[1]) - ((SRC_PIXEL *)bitmap->line[0]));
+	SRC_PIXEL *line_src = (SRC_PIXEL *)bitmap->line[visual.min_y]   + visual.min_x;
+	SRC_PIXEL *line_end = (SRC_PIXEL *)bitmap->line[visual.max_y+1] + visual.min_x;
+	DEST_PIXEL *line_dest = (DEST_PIXEL *)(DEST);
+
+	for (;line_src < line_end; line_dest+=DEST_SCALE_Y(DEST_WIDTH), line_src+=src_width) {
+
+#	ifdef INDIRECT
+#		ifdef DOUBLEBUFFER
+		  effect_scan2_func(effect_dbbuf, effect_dbbuf+DEST_WIDTH*DEST_PIXEL_SIZE, line_src, visual_width, INDIRECT);
+		  memcpy(line_dest, effect_dbbuf, DEST_WIDTH*DEST_PIXEL_SIZE*2);
+#		else
+		  effect_scan2_func(line_dest, line_dest+DEST_WIDTH, line_src, visual_width, INDIRECT);
+#		endif
+#	else
+#		ifdef DOUBLEBUFFER
+		  effect_scan2_direct_func(effect_dbbuf, effect_dbbuf+DEST_WIDTH*DEST_PIXEL_SIZE, line_src, visual_width);
+		  memcpy(line_dest, effect_dbbuf, DEST_WIDTH*DEST_PIXEL_SIZE*2);
+#		else
+		  effect_scan2_direct_func(line_dest, line_dest+DEST_WIDTH, line_src, visual_width);
+#		endif
+#	endif
+	}
+     }
+#  endif
+#  ifdef PUT_IMAGE
+      PUT_IMAGE(0, 0, SCALE_X(visual_width), SCALE_Y(visual_height))
+#  endif      
+  }
+  break;
+
+    case EFFECT_RGBSTRIPE:
+      {
+#  ifdef DEST
+     if (!blit_hardware_rotation && (blit_flipx || blit_flipy || blit_swapxy)) {
+       int y;
+       SRC_PIXEL *line_src;
+       DEST_PIXEL *line_dest = (DEST_PIXEL *)(DEST);
+       for (y = visual.min_y; y <= visual.max_y; line_dest+=DEST_SCALE_Y(DEST_WIDTH), y++) {
+	       rotate_func(rotate_dbbuf, bitmap, y);
+	       line_src = (SRC_PIXEL *)rotate_dbbuf;
+
+#	ifdef INDIRECT
+#		ifdef DOUBLEBUFFER
+		  effect_rgbstripe_func(effect_dbbuf, effect_dbbuf+DEST_WIDTH*DEST_PIXEL_SIZE, line_src, visual_width, INDIRECT);
+		  memcpy(line_dest, effect_dbbuf, DEST_WIDTH*DEST_PIXEL_SIZE*2);
+#		else
+		  effect_rgbstripe_func(line_dest, line_dest+DEST_WIDTH, line_src, visual_width, INDIRECT);
+#		endif
+#	else
+#		ifdef DOUBLEBUFFER
+		  effect_rgbstripe_direct_func(effect_dbbuf, effect_dbbuf+DEST_WIDTH*DEST_PIXEL_SIZE, line_src, visual_width);
+		  memcpy(line_dest, effect_dbbuf, DEST_WIDTH*DEST_PIXEL_SIZE*2);
+#		else
+		  effect_rgbstripe_direct_func(line_dest, line_dest+DEST_WIDTH, line_src, visual_width);
+#		endif
+#	endif
+       }
+     } else {
+	int src_width = (((SRC_PIXEL *)bitmap->line[1]) - ((SRC_PIXEL *)bitmap->line[0]));
+	SRC_PIXEL *line_src = (SRC_PIXEL *)bitmap->line[visual.min_y]   + visual.min_x;
+	SRC_PIXEL *line_end = (SRC_PIXEL *)bitmap->line[visual.max_y+1] + visual.min_x;
+	DEST_PIXEL *line_dest = (DEST_PIXEL *)(DEST);
+
+	for (;line_src < line_end; line_dest+=DEST_SCALE_Y(DEST_WIDTH), line_src+=src_width) {
+
+#	ifdef INDIRECT
+#		ifdef DOUBLEBUFFER
+		  effect_rgbstripe_func(effect_dbbuf, effect_dbbuf+DEST_WIDTH*DEST_PIXEL_SIZE, line_src, visual_width, INDIRECT);
+		  memcpy(line_dest, effect_dbbuf, DEST_WIDTH*DEST_PIXEL_SIZE*2);
+#		else
+		  effect_rgbstripe_func(line_dest, line_dest+DEST_WIDTH, line_src, visual_width, INDIRECT);
+#		endif
+#	else
+#		ifdef DOUBLEBUFFER
+		  effect_rgbstripe_direct_func(effect_dbbuf, effect_dbbuf+DEST_WIDTH*DEST_PIXEL_SIZE, line_src, visual_width);
+		  memcpy(line_dest, effect_dbbuf, DEST_WIDTH*DEST_PIXEL_SIZE*2);
+#		else
+		  effect_rgbstripe_direct_func(line_dest, line_dest+DEST_WIDTH, line_src, visual_width);
+#		endif
+#	endif
+	}
+     }
+#  endif
+#  ifdef PUT_IMAGE
+      PUT_IMAGE(0, 0, SCALE_X(visual_width), SCALE_Y(visual_height))
+#  endif      
+  }
+  break;
+
+    case EFFECT_RGBSCAN:
+      {
+#  ifdef DEST
+     if (!blit_hardware_rotation && (blit_flipx || blit_flipy || blit_swapxy)) {
+       int y;
+       SRC_PIXEL *line_src;
+       DEST_PIXEL *line_dest = (DEST_PIXEL *)(DEST);
+       for (y = visual.min_y; y <= visual.max_y; line_dest+=DEST_SCALE_Y(DEST_WIDTH), y++) {
+	       rotate_func(rotate_dbbuf, bitmap, y);
+	       line_src = (SRC_PIXEL *)rotate_dbbuf;
+
+#	ifdef INDIRECT
+#		ifdef DOUBLEBUFFER
+		  effect_rgbscan_func(effect_dbbuf, effect_dbbuf+DEST_WIDTH*DEST_PIXEL_SIZE, effect_dbbuf+DEST_WIDTH*DEST_PIXEL_SIZE*2, line_src, visual_width, INDIRECT);
+		  memcpy(line_dest, effect_dbbuf, DEST_WIDTH*DEST_PIXEL_SIZE*3);
+#		else
+		  effect_rgbscan_func(line_dest, line_dest+DEST_WIDTH, line_dest+DEST_WIDTH*2, line_src, visual_width, INDIRECT);
+#		endif
+#	else
+#		ifdef DOUBLEBUFFER
+		  effect_rgbscan_direct_func(effect_dbbuf, effect_dbbuf+DEST_WIDTH*DEST_PIXEL_SIZE, effect_dbbuf+DEST_WIDTH*DEST_PIXEL_SIZE*2, line_src, visual_width);
+		  memcpy(line_dest, effect_dbbuf, DEST_WIDTH*DEST_PIXEL_SIZE*3);
+#		else
+		  effect_rgbscan_direct_func(line_dest, line_dest+DEST_WIDTH, line_dest+DEST_WIDTH*2, line_src, visual_width);
+#		endif
+#	endif
+       }
+     } else {
+	int src_width = (((SRC_PIXEL *)bitmap->line[1]) - ((SRC_PIXEL *)bitmap->line[0]));
+	SRC_PIXEL *line_src = (SRC_PIXEL *)bitmap->line[visual.min_y]   + visual.min_x;
+	SRC_PIXEL *line_end = (SRC_PIXEL *)bitmap->line[visual.max_y+1] + visual.min_x;
+	DEST_PIXEL *line_dest = (DEST_PIXEL *)(DEST);
+
+	for (;line_src < line_end; line_dest+=DEST_SCALE_Y(DEST_WIDTH), line_src+=src_width) {
+
+#	ifdef INDIRECT
+#		ifdef DOUBLEBUFFER
+		  effect_rgbscan_func(effect_dbbuf, effect_dbbuf+DEST_WIDTH*DEST_PIXEL_SIZE, effect_dbbuf+DEST_WIDTH*DEST_PIXEL_SIZE*2, line_src, visual_width, INDIRECT);
+		  memcpy(line_dest, effect_dbbuf, DEST_WIDTH*DEST_PIXEL_SIZE*3);
+#		else
+		  effect_rgbscan_func(line_dest, line_dest+DEST_WIDTH, line_dest+DEST_WIDTH*2, line_src, visual_width, INDIRECT);
+#		endif
+#	else
+#		ifdef DOUBLEBUFFER
+		  effect_rgbscan_direct_func(effect_dbbuf, effect_dbbuf+DEST_WIDTH*DEST_PIXEL_SIZE, effect_dbbuf+DEST_WIDTH*DEST_PIXEL_SIZE*2, line_src, visual_width);
+		  memcpy(line_dest, effect_dbbuf, DEST_WIDTH*DEST_PIXEL_SIZE*3);
+#		else
+		  effect_rgbscan_direct_func(line_dest, line_dest+DEST_WIDTH, line_dest+DEST_WIDTH*2, line_src, visual_width);
+#		endif
+#	endif
+	}
+     }
+#  endif
+#  ifdef PUT_IMAGE
+      PUT_IMAGE(0, 0, SCALE_X(visual_width), SCALE_Y(visual_height))
+#  endif      
+  }
+  break;
+
+ case EFFECT_SCAN3:
+  {
+#  ifdef DEST
+     if (!blit_hardware_rotation && (blit_flipx || blit_flipy || blit_swapxy)) {
+       int y;
+       SRC_PIXEL *line_src;
+       DEST_PIXEL *line_dest = (DEST_PIXEL *)(DEST);
+       for (y = visual.min_y; y <= visual.max_y; line_dest+=DEST_SCALE_Y(DEST_WIDTH), y++) {
+	       rotate_func(rotate_dbbuf, bitmap, y);
+	       line_src = (SRC_PIXEL *)rotate_dbbuf;
+
+#	ifdef INDIRECT
+#		ifdef DOUBLEBUFFER
+		  effect_scan3_func(effect_dbbuf, effect_dbbuf+DEST_WIDTH*DEST_PIXEL_SIZE, effect_dbbuf+DEST_WIDTH*DEST_PIXEL_SIZE*2, line_src, visual_width, INDIRECT);
+		  memcpy(line_dest, effect_dbbuf, DEST_WIDTH*DEST_PIXEL_SIZE*3);
+#		else
+		  effect_scan3_func(line_dest, line_dest+DEST_WIDTH, line_dest+DEST_WIDTH*2, line_src, visual_width, INDIRECT);
+#		endif
+#	else
+#		ifdef DOUBLEBUFFER
+		  effect_scan3_direct_func(effect_dbbuf, effect_dbbuf+DEST_WIDTH*DEST_PIXEL_SIZE, effect_dbbuf+DEST_WIDTH*DEST_PIXEL_SIZE*2, line_src, visual_width);
+		  memcpy(line_dest, effect_dbbuf, DEST_WIDTH*DEST_PIXEL_SIZE*3);
+#		else
+		  effect_scan3_direct_func(line_dest, line_dest+DEST_WIDTH, line_dest+DEST_WIDTH*2, line_src, visual_width);
+#		endif
+#	endif
+       }
+     } else {
+	int src_width = (((SRC_PIXEL *)bitmap->line[1]) - ((SRC_PIXEL *)bitmap->line[0]));
+	SRC_PIXEL *line_src = (SRC_PIXEL *)bitmap->line[visual.min_y]   + visual.min_x;
+	SRC_PIXEL *line_end = (SRC_PIXEL *)bitmap->line[visual.max_y+1] + visual.min_x;
+	DEST_PIXEL *line_dest = (DEST_PIXEL *)(DEST);
+
+	for (;line_src < line_end; line_dest+=DEST_SCALE_Y(DEST_WIDTH), line_src+=src_width) {
+
+#	ifdef INDIRECT
+#		ifdef DOUBLEBUFFER
+		  effect_scan3_func(effect_dbbuf, effect_dbbuf+DEST_WIDTH*DEST_PIXEL_SIZE, effect_dbbuf+DEST_WIDTH*DEST_PIXEL_SIZE*2, line_src, visual_width, INDIRECT);
+		  memcpy(line_dest, effect_dbbuf, DEST_WIDTH*DEST_PIXEL_SIZE*3);
+#		else
+		  effect_scan3_func(line_dest, line_dest+DEST_WIDTH, line_dest+DEST_WIDTH*2, line_src, visual_width, INDIRECT);
+#		endif
+#	else
+#		ifdef DOUBLEBUFFER
+		  effect_scan3_direct_func(effect_dbbuf, effect_dbbuf+DEST_WIDTH*DEST_PIXEL_SIZE, effect_dbbuf+DEST_WIDTH*DEST_PIXEL_SIZE*2, line_src, visual_width);
+		  memcpy(line_dest, effect_dbbuf, DEST_WIDTH*DEST_PIXEL_SIZE*3);
+#		else
+		  effect_scan3_direct_func(line_dest, line_dest+DEST_WIDTH, line_dest+DEST_WIDTH*2, line_src, visual_width);
+#		endif
+#	endif
+	}
+     }
+#  endif
+#  ifdef PUT_IMAGE
+      PUT_IMAGE(0, 0, SCALE_X(visual_width), SCALE_Y(visual_height))
+#  endif      
+	}
+      break;
+    }
+  }
+else /* no effect */
+{
+#ifdef DEST
+     if (!blit_hardware_rotation && (blit_flipx || blit_flipy || blit_swapxy)) {
+       int y;
+       SRC_PIXEL *line_src;
+       SRC_PIXEL *line_end;
+       DEST_PIXEL *line_dest = (DEST_PIXEL *)(DEST);
+       for (y = visual.min_y; y <= visual.max_y; line_dest+=REPS_FOR_Y(DEST_WIDTH,y,visual_height), y++) {
+	       rotate_func(rotate_dbbuf, bitmap, y);
+	       line_src = (SRC_PIXEL *)rotate_dbbuf;
+	       line_end = (SRC_PIXEL *)rotate_dbbuf + visual_width;
+	       COPY_LINE_FOR_Y(y, visual_height, line_src, line_end, line_dest);
+       }
+     } else {
+       int y = visual.min_y;
+       int src_width = (((SRC_PIXEL *)bitmap->line[1]) -
+			((SRC_PIXEL *)bitmap->line[0]));
+       SRC_PIXEL *line_src = (SRC_PIXEL *)bitmap->line[visual.min_y]   + visual.min_x;
+       SRC_PIXEL *line_end = (SRC_PIXEL *)bitmap->line[visual.max_y+1] + visual.min_x;
+       DEST_PIXEL *line_dest = (DEST_PIXEL *)(DEST);
+     
+       for (;line_src < line_end;
+	    line_dest+=REPS_FOR_Y(DEST_WIDTH,y,visual_height),
+		    line_src+=src_width, y++)
+	       COPY_LINE_FOR_Y(y,visual_height,
+			       line_src, line_src+visual_width, line_dest);
+     }
+#endif
+#ifdef PUT_IMAGE
+     PUT_IMAGE(0, 0, SCALE_X(visual_width), SCALE_Y(visual_height))
+#endif
+  }
+
+#undef DEST_SCALE_X
+#undef DEST_SCALE_Y
diff --git a/src/unix/video-drivers/fxgen.c b/src/unix/video-drivers/fxgen.c
new file mode 100644
index 0000000..e4d6524
--- /dev/null
+++ b/src/unix/video-drivers/fxgen.c
@@ -0,0 +1,604 @@
+/*****************************************************************
+
+  Generic glide routines
+
+  Copyright 1998 by Mike Oliphant - oliphant@ling.ed.ac.uk
+
+    http://www.ling.ed.ac.uk/~oliphant/glmame
+
+  This code may be used and distributed under the terms of the
+  Mame license
+
+*****************************************************************/
+
+#if defined xfx || defined svgafx
+#include <stdio.h>
+#include <math.h>
+#include <glide.h>
+#include "xmame.h"
+#include "driver.h"
+
+#define _32TO16(p) (UINT16)((((p) & 0x00F80000) >> 9) | \
+                            (((p) & 0x0000F800) >> 6) | \
+                            (((p) & 0x000000F8) >> 3))
+
+#define PIXELCOLOR(x) fxdepth == 15 ? \
+						(UINT16)(x) : \
+                        (fxdepth == 16 ? \
+                        	color_values[(UINT16)(x)] : \
+                            (fxdepth == 24 || fxdepth == 32 ? \
+                            _32TO16((UINT32)(x)) : 0))
+
+#define PAUSEDCOLOR(p) (UINT16) ((((p) >> 11) << 10) | ((((p) &0x03E0) >> 6)<< 5) | (((p) & 0x001F) >> 1))
+
+void CalcPoint(GrVertex *vert,int x,int y);
+void InitTextures(void);
+int  InitVScreen(void);
+void CloseVScreen(void);
+void UpdateTexture(struct mame_bitmap *bitmap);
+void DrawFlatBitmap(void);
+void UpdateFlatDisplay(void);
+void UpdateFXDisplay(struct mame_bitmap *bitmap);
+static int SetResolution(struct rc_option *option, const char *arg,
+   int priority);
+
+extern int pointnum;
+extern UINT32 direct_rgb_components[3];
+extern UINT16 *color_values;
+extern int emulation_paused;
+
+int fxwidth = 640;
+int fxheight = 480;
+static int fxdepth;
+static int black;
+static int white;
+
+GuTexPalette texpal;
+
+static int Gr_format = GR_TEXFMT_ARGB_1555;
+static GrScreenResolution_t Gr_resolution = GR_RESOLUTION_640x480;
+static GrHwConfiguration hwconfig;
+static char version[80];
+static GrTexInfo texinfo;
+static int bilinear=1; /* Do binlinear filtering? */
+static const int texsize=256;
+
+/* The squares that are tiled to make up the game screen polygon */
+
+struct TexSquare
+{
+  UINT16 *texture;
+  unsigned int texobj;
+  long texadd;
+  float x1,y1,z1,x2,y2,z2,x3,y3,z3,x4,y4,z4;
+  GrVertex vtxA, vtxB, vtxC, vtxD;
+  float xcov,ycov;
+};
+
+static struct TexSquare *texgrid=NULL;
+static int texnumx;
+static int texnumy;
+static float texpercx;
+static float texpercy;
+static float vscrntlx;
+static float vscrntly;
+static float vscrnwidth;
+static float vscrnheight;
+static float xinc,yinc;
+
+float cscrx1,cscry1,cscrz1,cscrx2,cscry2,cscrz2,
+  cscrx3,cscry3,cscrz3,cscrx4,cscry4,cscrz4;
+float cscrwdx,cscrwdy,cscrwdz;
+float cscrhdx,cscrhdy,cscrhdz;
+
+struct rc_option fx_opts[] = {
+   /* name, shortname, type, dest, deflt, min, max, func, help */
+   { "FX (Glide) Related", NULL,		rc_seperator,	NULL,
+     NULL,		0,			0,		NULL,
+     NULL },
+   { "resolution",	"res",			rc_use_function, NULL,
+     "640x480",		0,			0,		SetResolution,
+     "Specify the resolution/ windowsize to use in the form of XRESxYRES" },
+   { "keepaspect",	NULL,			rc_bool,	&normal_use_aspect_ratio,
+     "1",		0,			0,		NULL,
+     "Try / don't try to keep the aspect ratio of a game" },
+   { NULL,		NULL,			rc_end,		NULL,
+     NULL,		0,			0,		NULL,
+     NULL }
+};
+
+int sysdep_display_16bpp_capable(void)
+{
+   return 1;
+}
+
+/* Allocate a palette */
+int sysdep_display_alloc_palette(int writable_colors)
+{
+  InitTextures();
+  return 0;
+}
+
+/* Change the color of a pen */
+int sysdep_display_set_pen(int pen, unsigned char red,unsigned char green,
+					unsigned char blue) 
+{
+  return 0;
+}
+
+void CalcPoint(GrVertex *vert,int x,int y)
+{
+  vert->x=vscrntlx+(float)x*texpercx*vscrnwidth;
+  if(vert->x>vscrntlx+vscrnwidth) vert->x=vscrntlx+vscrnwidth;
+
+  vert->y=vscrntly+vscrnheight-(float)y*texpercy*vscrnheight;
+  if(vert->y<vscrntly) vert->y=vscrntly;
+}
+
+int InitGlide(void)
+{
+  int fd = open("/dev/3dfx", O_RDWR);
+  if ((fd < 0) && geteuid())
+  {
+     fprintf(stderr, "Glide error: couldn't open /dev/3dfx and not running as root\n");
+     return OSD_NOT_OK;
+  }
+  if (fd >= 0)
+     close(fd);
+  putenv("FX_GLIDE_NO_SPLASH=");
+  grGlideInit();
+  if (!grSstQueryHardware(&hwconfig))
+  {
+     grGlideShutdown();
+     fprintf(stderr, "Glide error: no boards found\n");
+     return OSD_NOT_OK;
+  }
+  return OSD_OK;
+}
+
+void InitTextures(void)
+{
+  int x,y;
+  struct TexSquare *tsq;
+  long texmem,memaddr;
+
+  texinfo.smallLod=texinfo.largeLod=GR_LOD_256;
+  texinfo.aspectRatio=GR_ASPECT_1x1;
+  texinfo.format=Gr_format;
+
+  texmem=grTexTextureMemRequired(GR_MIPMAPLEVELMASK_BOTH,&texinfo);
+
+  grColorCombine(GR_COMBINE_FUNCTION_SCALE_OTHER,
+				   GR_COMBINE_FACTOR_ONE,
+				   GR_COMBINE_LOCAL_NONE,
+				   GR_COMBINE_OTHER_TEXTURE,
+				   FXFALSE);
+
+  grTexCombine(GR_TMU0,
+			   GR_COMBINE_FUNCTION_LOCAL,GR_COMBINE_FACTOR_NONE,
+			   GR_COMBINE_FUNCTION_NONE,GR_COMBINE_FACTOR_NONE,
+			   FXFALSE, FXFALSE);
+
+  grTexMipMapMode(GR_TMU0,
+				  GR_MIPMAP_DISABLE,
+				  FXFALSE);
+
+  grTexClampMode(GR_TMU0,
+				 GR_TEXTURECLAMP_CLAMP,
+				 GR_TEXTURECLAMP_CLAMP);
+
+  if(bilinear)
+	grTexFilterMode(GR_TMU0,
+					GR_TEXTUREFILTER_BILINEAR,
+					GR_TEXTUREFILTER_BILINEAR);
+  else
+	grTexFilterMode(GR_TMU0,
+					GR_TEXTUREFILTER_POINT_SAMPLED,
+					GR_TEXTUREFILTER_POINT_SAMPLED);
+
+  /* Allocate the texture memory */
+  
+  texnumx=visual_width/texsize;
+  if(texnumx*texsize!=visual_width) texnumx++;
+  texnumy=visual_height/texsize;
+  if(texnumy*texsize!=visual_height) texnumy++;
+  
+  xinc=vscrnwidth*((float)texsize/(float)visual_width);
+  yinc=vscrnheight*((float)texsize/(float)visual_height);
+  
+  texpercx=(float)texsize/(float)visual_width;
+  if(texpercx>1.0) texpercx=1.0;
+  
+  texpercy=(float)texsize/(float)visual_height;
+  if(texpercy>1.0) texpercy=1.0;
+  
+  texgrid=(struct TexSquare *)
+	malloc(texnumx*texnumy*sizeof(struct TexSquare));
+  memaddr=grTexMinAddress(GR_TMU0);
+  
+  for(y=0;y<texnumy;y++) {
+	for(x=0;x<texnumx;x++) {
+	  tsq=texgrid+y*texnumx+x;
+
+	  tsq->texadd=memaddr;
+	  memaddr+=texmem;
+
+	  if(x==(texnumx-1) && visual_width%texsize)
+		tsq->xcov=(float)((visual_width)%texsize)/(float)texsize;
+	  else tsq->xcov=1.0;
+	  
+	  if(y==(texnumy-1) && visual_height%texsize)
+		tsq->ycov=(float)((visual_height)%texsize)/(float)texsize;
+	  else tsq->ycov=1.0;
+
+	  tsq->vtxA.oow=1.0;
+	  tsq->vtxB=tsq->vtxC=tsq->vtxD=tsq->vtxA;
+	
+	  CalcPoint(&(tsq->vtxA),x,y);
+	  CalcPoint(&(tsq->vtxB),x+1,y);
+	  CalcPoint(&(tsq->vtxC),x+1,y+1);
+	  CalcPoint(&(tsq->vtxD),x,y+1);
+ 	
+	  tsq->vtxA.tmuvtx[0].sow=0.0;
+	  tsq->vtxA.tmuvtx[0].tow=0.0;
+
+	  tsq->vtxB.tmuvtx[0].sow=256.0*tsq->xcov;
+	  tsq->vtxB.tmuvtx[0].tow=0.0;
+
+	  tsq->vtxC.tmuvtx[0].sow=256.0*tsq->xcov;
+	  tsq->vtxC.tmuvtx[0].tow=256.0*tsq->ycov;
+
+	  tsq->vtxD.tmuvtx[0].sow=0.0;
+	  tsq->vtxD.tmuvtx[0].tow=256.0*tsq->ycov;
+	  
+
+	  /* Initialize the texture memory */
+	  tsq->texture=calloc(texsize*texsize, sizeof *(tsq->texture));
+	}
+  }
+}
+
+typedef struct {
+    int         res;
+    int       width;
+    int       height;
+} ResToRes;
+		
+static ResToRes resTable[] = {
+    { GR_RESOLUTION_320x200,   320,  200 },  /* 0x0 */
+    { GR_RESOLUTION_320x240,   320,  240 },  /* 0x1 */
+    { GR_RESOLUTION_400x256,   400,  256 },  /* 0x2 */
+    { GR_RESOLUTION_512x384,   512,  384 },  /* 0x3 */
+    { GR_RESOLUTION_640x200,   640,  200 },  /* 0x4 */
+    { GR_RESOLUTION_640x350,   640,  350 },  /* 0x5 */
+    { GR_RESOLUTION_640x400,   640,  400 },  /* 0x6 */
+    { GR_RESOLUTION_640x480,   640,  480 },  /* 0x7 */
+    { GR_RESOLUTION_800x600,   800,  600 },  /* 0x8 */
+    { GR_RESOLUTION_960x720,   960,  720 },  /* 0x9 */
+    { GR_RESOLUTION_856x480,   856,  480 },  /* 0xA */
+    { GR_RESOLUTION_512x256,   512,  256 },  /* 0xB */
+    { GR_RESOLUTION_1024x768,  1024, 768 },  /* 0xC */
+    { GR_RESOLUTION_1280x1024, 1280, 1024 }, /* 0xD */
+    { GR_RESOLUTION_1600x1200, 1600, 1200 }, /* 0xE */
+    { GR_RESOLUTION_400x300,   400,  300 }   /* 0xF */
+};
+			
+static long resTableSize = sizeof( resTable ) / sizeof( ResToRes );
+
+/* Get screen resolution */
+static int SetResolution(struct rc_option *option, const char *arg,
+   int priority)
+{
+  int width, height, match;
+  if (sscanf(arg, "%dx%d", &width, &height) == 2)
+  {
+     for( match = 0; match < resTableSize; match++ )
+        if( width==resTable[match].width && height==resTable[match].height)
+        {
+           Gr_resolution = resTable[match].res;
+           fxwidth = width;
+           fxheight = height;
+           option->priority = priority;
+           return 0;
+        }
+  }
+  fprintf(stderr,
+      "error: invalid resolution or unknown resolution: \"%s\".\n"
+      "   Valid resolutions are:\n", arg);
+  for( match = 0; match < resTableSize; match++ )
+  {
+     fprintf(stderr_file, "   \"%dx%d\"", resTable[match].width,
+        resTable[match].height);
+     if (match && (match % 5) == 0)
+        fprintf(stderr_file, "\n");
+  }
+  return -1;
+}
+
+
+/* Set up the virtual screen */
+
+int InitVScreen(void)
+{
+  float scrnaspect,vscrnaspect;
+
+  grGlideGetVersion(version);
+
+  fxdepth = Machine->color_depth;
+
+  fprintf(stderr_file, "info: using Glide version %s\n", version);
+  
+  grSstSelect(0);
+
+  if(!grSstWinOpen(0,Gr_resolution,GR_REFRESH_60Hz,GR_COLORFORMAT_ABGR,
+     GR_ORIGIN_LOWER_LEFT,2,1))
+  {
+     fprintf(stderr_file, "error opening Glide window, do you have enough memory on your 3dfx for the selected mode?\n");
+     return OSD_NOT_OK;
+  }
+  fprintf(stderr_file,
+     "info: screen resolution set to %dx%d\n", fxwidth, fxheight);
+
+  /* clear the buffer */
+
+  grBufferClear(0,0,GR_ZDEPTHVALUE_FARTHEST);
+
+
+  if (use_aspect_ratio)
+  {
+     scrnaspect=(float)visual_width/(float)visual_height;
+     vscrnaspect=(float)fxwidth/(float)fxheight;
+
+     if(scrnaspect<vscrnaspect) {
+   	vscrnheight=(float)fxheight;
+   	vscrnwidth=vscrnheight*scrnaspect;
+   	vscrntlx=((float)fxwidth-vscrnwidth)/2.0;
+   	vscrntly=0.0;
+     }
+     else {
+   	vscrnwidth=(float)fxwidth;
+   	vscrnheight=vscrnwidth/scrnaspect;
+   	vscrntlx=0.0;
+   	vscrntly=((float)fxheight-vscrnheight)/2.0;
+     }
+  }
+  else
+  {
+     vscrnwidth=(float)fxwidth;
+     vscrnheight=(float)fxheight;
+     vscrntlx=0.0;
+     vscrntly=0.0;
+  }
+  
+  /* fill the display_palette_info struct */
+  memset(&display_palette_info, 0, sizeof(struct sysdep_palette_info));
+  switch(fxdepth) {
+    case 15:
+    case 16:
+      display_palette_info.depth = 16;
+      display_palette_info.red_mask   = 0x7C00;
+      display_palette_info.green_mask = 0x03E0;
+      display_palette_info.blue_mask  = 0x001F;
+      break;
+    case 24:
+    case 32:
+      display_palette_info.depth = 32;
+      display_palette_info.red_mask   = 0xFF0000;
+      display_palette_info.green_mask = 0x00FF00;
+      display_palette_info.blue_mask  = 0x0000FF;
+      break;
+  }
+   
+  black = video_colors_used -2;
+  white = video_colors_used -1;
+
+  return OSD_OK;
+}
+
+/* Close down the virtual screen */
+
+void CloseVScreen(void)
+{
+  int x,y;
+
+  /* Free Texture stuff */
+
+  if(texgrid) {
+	for(y=0;y<texnumy;y++) {
+	  for(x=0;x<texnumx;x++) {
+		free(texgrid[y*texnumx+x].texture);
+	  }
+	}
+	
+	free(texgrid);
+	texgrid = NULL;
+  }
+
+  grGlideShutdown();
+}
+
+/* Not needed under GL */
+
+void sysdep_clear_screen(void)
+{
+}
+
+
+/* Update the texture with the contents of the game screen */
+
+void UpdateTexture(struct mame_bitmap *bitmap)
+{
+	int y,rline,texline,xsquare,ysquare,ofs,width, i;
+	struct TexSquare *square;
+
+	if(visual_width<=texsize) width=visual_width;
+	else width=texsize;
+
+	switch (fxdepth) {
+
+
+	case 15:
+		for(y=visual.min_y;y<=visual.max_y;y++) {
+			rline=y-visual.min_y;
+			ysquare=rline/texsize;
+			texline=rline%texsize;
+			
+			for(xsquare=0;xsquare<texnumx;xsquare++) {
+				ofs=xsquare*texsize;
+				
+				if(xsquare<(texnumx-1) || !(visual_width%texsize))
+					width=texsize;
+				else width=visual_width%texsize;
+				
+				square=texgrid+(ysquare*texnumx)+xsquare;
+
+				if (emulation_paused) {	
+					for(i = 0;i < width;i++) {	
+						square->texture[texline*texsize+i] = ((UINT16*)(bitmap->line[y]))[visual.min_x+ofs+i];
+					}
+				} else {
+                                       	for(i = 0;i < width;i++) {
+                                               	square->texture[texline*texsize+i] = PAUSEDCOLOR((((UINT16*)(bitmap->line[y]))[visual.min_x+ofs+i]));
+                                       	}
+				}
+			}
+		} 
+		break;
+
+	case 16:
+		
+		for(y=visual.min_y;y<=visual.max_y;y++) {
+			rline=y-visual.min_y;
+			ysquare=rline/texsize;
+			texline=rline%texsize;
+			
+			for(xsquare=0;xsquare<texnumx;xsquare++) {
+				ofs=xsquare*texsize;
+				
+				if(xsquare<(texnumx-1) || !(visual_width%texsize))
+					width=texsize;
+				else width=visual_width%texsize;
+				
+				square=texgrid+(ysquare*texnumx)+xsquare;
+				if (emulation_paused) {
+					for(i = 0;i < width;i++) {
+						square->texture[texline*texsize+i] = 
+							color_values[(((UINT16*)(bitmap->line[y]))[visual.min_x+ofs+i])];
+					}
+				} else {
+					for(i = 0;i < width;i++) {
+						square->texture[texline*texsize+i] =
+							PAUSEDCOLOR(color_values[(((UINT16*)(bitmap->line[y]))[visual.min_x+ofs+i])]);
+					}
+				}
+			}
+		}
+		break;
+
+	case 24:
+	case 32:
+		for(y=visual.min_y;y<=visual.max_y;y++) {
+			rline=y-visual.min_y;
+			ysquare=rline/texsize;
+			texline=rline%texsize;
+			
+			for(xsquare=0;xsquare<texnumx;xsquare++) {
+				ofs=xsquare*texsize;
+				
+				if(xsquare<(texnumx-1) || !(visual_width%texsize))
+					width=texsize;
+				else width=visual_width%texsize;
+				
+				square=texgrid+(ysquare*texnumx)+xsquare;
+					
+				if (emulation_paused) {
+					for(i = 0;i < width;i++) {
+						square->texture[texline*texsize+i] = 
+							PIXELCOLOR((((UINT32*)(bitmap->line[y]))[visual.min_x+ofs+i]));
+					}
+				} else {
+					for(i = 0;i < width;i++) {
+						square->texture[texline*texsize+i] =
+							PAUSEDCOLOR(PIXELCOLOR((((UINT32*)(bitmap->line[y]))[visual.min_x+ofs+i])));
+					}
+				}
+			}
+		}
+		break;
+	}
+}
+
+void DrawFlatBitmap(void)
+{
+  struct TexSquare *square;
+  int x,y;
+
+  for(y=0;y<texnumy;y++) {
+	for(x=0;x<texnumx;x++) {
+	  square=texgrid+y*texnumx+x;
+
+	  texinfo.data=(void *)square->texture;
+
+	  grTexDownloadMipMapLevel(GR_TMU0,square->texadd,
+							   GR_LOD_256,GR_LOD_256,GR_ASPECT_1x1,
+							   Gr_format,
+							   GR_MIPMAPLEVELMASK_BOTH,texinfo.data);
+
+	  grTexSource(GR_TMU0,square->texadd,
+				  GR_MIPMAPLEVELMASK_BOTH,&texinfo);
+
+	  grDrawTriangle(&(square->vtxA),&(square->vtxD),&(square->vtxC));
+	  grDrawTriangle(&(square->vtxA),&(square->vtxB),&(square->vtxC));
+	}
+  }
+}
+
+void UpdateFlatDisplay(void)
+{
+  grBufferClear(0,0,GR_ZDEPTHVALUE_FARTHEST);
+  DrawFlatBitmap();
+  grBufferSwap(1);
+}
+
+void UpdateFXDisplay(struct mame_bitmap *bitmap)
+{
+  if(bitmap) 
+    UpdateTexture(bitmap);
+
+  UpdateFlatDisplay();
+}
+
+/* used when expose events received */
+
+void osd_refresh_screen(void)
+{
+  /* Just re-draw the whole screen */
+
+  UpdateFXDisplay(NULL);
+}
+
+
+/* invoked by main tree code to update bitmap into screen */
+
+void sysdep_update_display(struct mame_bitmap *bitmap)
+{
+  if(keyboard_pressed(KEYCODE_RCONTROL)) {
+	if(keyboard_pressed_memory(KEYCODE_B)) {
+	  bilinear=1-bilinear;
+
+	  if(bilinear)
+		grTexFilterMode(GR_TMU0,
+						GR_TEXTUREFILTER_BILINEAR,
+						GR_TEXTUREFILTER_BILINEAR);
+	  else
+		grTexFilterMode(GR_TMU0,
+						GR_TEXTUREFILTER_POINT_SAMPLED,
+						GR_TEXTUREFILTER_POINT_SAMPLED);
+
+	}
+  }
+
+  UpdateFXDisplay(bitmap);
+}
+
+#endif /* if defined xfx || defined svgafx */
diff --git a/src/unix/video-drivers/fxvec.c b/src/unix/video-drivers/fxvec.c
new file mode 100644
index 0000000..697a086
--- /dev/null
+++ b/src/unix/video-drivers/fxvec.c
@@ -0,0 +1,190 @@
+/*****************************************************************
+
+  Glide vector routines
+
+  Copyright 1998 by Mike Oliphant - oliphant@ling.ed.ac.uk
+
+    http://www.ling.ed.ac.uk/~oliphant/glmame
+
+  This code may be used and distributed under the terms of the
+  Mame license
+
+*****************************************************************/
+
+#if defined xfx || defined svgafx
+
+#include <glide.h>
+#include "xmame.h"
+#include "driver.h"
+#include "artwork.h"
+
+extern int fxwidth,fxheight;
+extern GuTexPalette texpal;
+
+unsigned char *vectorram;
+int vectorram_size;
+
+int antialias;                            /* flag for anti-aliasing */
+int beam;                                 /* size of vector beam    */
+int translucency;
+
+int pointnum;
+GrVertex vec_vert[10000];
+
+static int vecshift;
+static float vecwidth,vecheight;
+
+static int vector_orientation;
+
+static float flicker_correction = 0.0;
+
+/*
+ * Initializes vector game video emulation
+ */
+
+int vector_vh_start (void)
+{
+  vecwidth=(float)(Machine->drv->default_visible_area.max_x-
+	Machine->drv->default_visible_area.min_x);
+
+  vecheight=(float)(Machine->drv->default_visible_area.max_y-
+	Machine->drv->default_visible_area.min_y);
+
+  pointnum=0;
+
+  return 0;
+}
+
+/*
+ * Stop the vector video hardware emulation. Free memory.
+ */
+
+void vector_vh_stop (void)
+{
+}
+
+/*
+ * Setup scaling. Currently the Sega games are stuck at VECSHIFT 15
+ * and the the AVG games at VECSHIFT 16
+ */
+
+void vector_set_shift (int shift)
+{
+  vecshift=shift;
+}
+
+/* Convert an xy point to xyz in the 3D scene */
+
+void PointConvert(int x,int y,float *sx,float *sy)
+{
+  float dx,dy,tmp;
+
+  dx=(float)(x>>vecshift)/vecwidth;
+  dy=(float)(y>>vecshift)/vecheight;
+
+  if(Machine->orientation&ORIENTATION_SWAP_XY) {
+    tmp=dx;
+    dx=dy;
+    dy=tmp;
+  }
+
+  if(Machine->orientation&ORIENTATION_FLIP_X)
+    dx=1.0-dx;
+
+  if(Machine->orientation&ORIENTATION_FLIP_Y)
+    dy=1.0-dy;
+
+  *sx=dx*(float)fxwidth;
+  *sy=(float)fxheight-dy*(float)fxheight;
+}
+
+/*
+ * Adds a line end point to the vertices list. The vector processor emulation
+ * needs to call this.
+ */
+
+void vector_add_point(int x, int y, int color, int intensity)
+{
+  GrVertex *vert;
+  FxU32 pen;
+
+  if(pointnum==10000)
+	printf("Vector buffer overflow\n");
+  else {
+	vert=vec_vert+pointnum;
+
+	vert->oow=1.0;
+
+	pen=texpal.data[Machine->pens[color]];
+
+	vert->r=(float)((pen>>16)&0x000000ff);
+	vert->g=(float)((pen>>8)&0x000000ff);
+	vert->b=(float)(pen&0x000000ff);
+
+	vert->a=(float)intensity; /* /1.7; */
+
+	PointConvert(x,y,&(vert->x),&(vert->y));
+  }
+
+  pointnum++;
+}
+
+/*
+ * Add new clipping info to the list
+ */
+
+void vector_add_clip (int x1, int yy1, int x2, int y2)
+{
+}
+
+/*
+ * The vector CPU creates a new display list.
+ */
+
+void vector_clear_list(void)
+{
+  pointnum=0;
+}
+
+/* Called when the frame is complete */
+
+void vector_vh_update(struct mame_bitmap *bitmap,int full_refresh)
+{
+}
+
+void vector_set_flip_x (int flip)
+{
+	if (flip)
+		vector_orientation |= ORIENTATION_FLIP_X;
+	else
+		vector_orientation &= ~ORIENTATION_FLIP_X;
+}
+
+void vector_set_flip_y (int flip)
+{
+	if (flip)
+		vector_orientation |= ORIENTATION_FLIP_Y;
+	else
+		vector_orientation &= ~ORIENTATION_FLIP_Y;
+}
+
+void vector_set_swap_xy (int swap)
+{
+	if (swap)
+		vector_orientation |= ORIENTATION_SWAP_XY;
+	else
+		vector_orientation &= ~ORIENTATION_SWAP_XY;
+}
+
+void vector_set_flicker(float _flicker)
+{
+	flicker_correction = _flicker;
+	/* flicker = (int)(flicker_correction * 2.55); */
+}
+
+float vector_get_flicker(void)
+{
+	return flicker_correction;
+}
+
+#endif /* if defined xfx || defined svgafx */
diff --git a/src/unix/video-drivers/ggi.c b/src/unix/video-drivers/ggi.c
new file mode 100644
index 0000000..61e6fbb
--- /dev/null
+++ b/src/unix/video-drivers/ggi.c
@@ -0,0 +1,1043 @@
+/***************************************************************************
+
+ Linux libGGI driver by Gabriele Boccone - clayton@dist.unige.it
+
+  Something is recycled (and/or tweaked) from svgalib.c. This is only
+  a "Quick and Dirty Hack"(TM) to make things interesting.
+
+  Please if you test GGI-mame send me a mail, saying: "It works on my system"
+  or "It does not work on my system", and what kind of computer you tested
+  GGI-mame on. If you also want to send me sugar, coffee, chocolate, etc,
+  feel free to send it by e-mail.
+
+  Adapted for xmame-0.31 by Christian Groessler - cpg@aladdin.de
+
+  * tested with GGI 2.0 Beta2 *
+***************************************************************************/
+#ifdef ggi
+#define __GGI_C
+
+#include <ggi/ggi.h>
+#include <signal.h>
+#include <math.h>
+
+/*#define KEY_DEBUG*/
+/*#define GGI_DEBUG*/
+/*#define CATCH_SIGNALS*/
+
+#include "xmame.h"
+#include "driver.h"
+#include "devices.h"
+#include "keyboard.h"
+#include "effect.h"
+
+static int video_width,video_height;
+static int scaled_visual_width,scaled_visual_height;
+static ggi_visual_t vis = NULL;
+static int screen_startx,screen_starty;
+static int lastmouse[MOUSE_AXIS]={0,0,0,0,0,0,0,0};
+static unsigned char *video_mem;
+static unsigned char *doublebuffer_buffer = NULL; /* also used for scaling */
+static ggi_mode mode;
+static int use_linear = 0;
+static int force_x,force_y;
+
+struct rc_option display_opts[] = {
+   /* name, shortname, type, dest, deflt, min, max, func, help */
+   { "GGI Related",	NULL,			rc_seperator,	NULL,
+     NULL,		0,			0,		NULL,
+     NULL },
+   { "linear",		NULL,			rc_bool,	&use_linear,
+     "0",		0,			0,		NULL,
+     "Enable/disable use of linear framebuffer (fast)" },
+   { "xres",            NULL,                   rc_int,         &force_x,
+     "0",               0,                      0,              NULL,
+     "Force the X resolution" },
+   { "yres",            NULL,                   rc_int,         &force_y,
+     "0",               0,                      0,              NULL,
+     "Force the Y resolution" },
+   { NULL,		NULL,			rc_link,	mode_opts,
+     NULL,		0,			0,		NULL,
+     NULL },
+   { NULL,		NULL,			rc_end,		NULL,
+     NULL,		0,			0,		NULL,
+     NULL }
+};
+
+struct mode_list {
+    int width;
+    int height;
+};
+
+/* table of modes to try */
+static struct mode_list ggimodes[] = {
+    {  320,  200 },
+    {  320,  240 },
+    {  360,  240 },
+    {  360,  400 },
+    {  360,  480 },
+    {  320,  400 },
+    {  320,  480 },
+    {  400,  300 },
+    {  600,  400 },
+    {  640,  200 },
+    {  640,  400 },
+    {  640,  480 },
+    {  800,  600 },
+    { 1024,  768 },
+    { 1280, 1024 },
+    { 2048, 1536 }
+};
+#define ML_ANZ (sizeof(ggimodes) / sizeof(struct mode_list))   /* # of entries in table */
+
+static int first_call=TRUE;
+/* do we need this? It makes debugging crashes sorta hard without a core file */
+#ifdef CATCH_SIGNALS
+static void (*oldsigsegvh)(int) = NULL;
+static void (*oldsigbush)(int) = NULL;
+static void (*oldsigquith)(int) = NULL;
+#endif
+
+static void ggi_cleanup(void);
+static void (*update_function)(struct mame_bitmap *bitmap);
+static void ggi_update_16_to_16bpp(struct mame_bitmap *bitmap);
+static void ggi_update_16_to_16bpp_scaled(struct mame_bitmap *bitmap);
+static void ggi_update_16_to_24bpp(struct mame_bitmap *bitmap);
+static void ggi_update_16_to_32bpp(struct mame_bitmap *bitmap);
+static void ggi_update_linear_16_to_16bpp(struct mame_bitmap *bitmap);
+static void ggi_update_linear_16_to_24bpp(struct mame_bitmap *bitmap);
+static void ggi_update_linear_16_to_32bpp(struct mame_bitmap *bitmap);
+
+
+/* do we need this? It makes debugging crashes sorta hard without a core file */
+#ifdef CATCH_SIGNALS
+/* emergency signal handler: try to restore things */
+
+static void myhandler(int signum)
+{
+    char *signam;
+    char tmpbuf[32];
+    void (*orgh)(int) = NULL;
+    switch(signum) {
+        case SIGSEGV:
+            signam="SIGSEGV";
+            orgh=oldsigsegvh;
+            break;
+        case SIGBUS:
+            signam="SIGBUS";
+            orgh=oldsigbush;
+            break;
+        case SIGQUIT:
+            signam="SIGQUIT";
+            orgh=oldsigquith;
+            break;
+        default:
+            sprintf(tmpbuf,"unknown(%d)",signum);
+            signam=tmpbuf;
+    }
+    fprintf(stderr_file,"%s: aborting...\n",signam);
+    if (first_call) {
+        first_call=FALSE;
+        ggi_cleanup(); /* try again once */
+    }
+    if (orgh) orgh(signum);
+    exit(255);
+}
+#endif
+
+int sysdep_init(void)
+{
+#ifdef GGI_DEBUG
+   if (stderr_file)
+      fprintf(stderr_file,"sysdep_init called\n");
+#endif
+
+   if (ggiInit())
+   {
+      fprintf(stderr, "Unable to initialize GGI subsystem!\n"); /* sounds good, doesn't it? */
+      return OSD_NOT_OK;
+   }
+
+   return OSD_OK;
+}
+
+void sysdep_close(void)
+{
+#ifdef GGI_DEBUG
+    fprintf(stderr_file,"sysdep_close called\n");
+#endif
+    ggiExit();
+}
+
+
+int sysdep_display_16bpp_capable(void)
+{
+   /* ehm ? */
+   return 1;
+}
+
+/*
+ * check whether a given mode exists
+ * try 8bit and >8bit color depths as needed
+ * 15-Oct-1999, chris
+ */
+static int ggi_check_mode(ggi_visual_t vis, int w, int h, int depth,
+   ggi_graphtype *type)
+{
+    ggi_mode mode;
+
+#ifdef GGI_DEBUG
+    fprintf(stderr_file,"ggi_check_mode called (%dx%d)\n",w,h);
+#endif
+    memset(&mode,0xff,sizeof(mode));
+    /* try 8bit color depth */
+    if ((depth == 8) &&
+        (! ggiCheckSimpleMode(vis, w, h, GGI_AUTO, GT_8BIT, &mode)))
+    {
+       *type = GT_8BIT;
+       return(TRUE);
+    }
+    /* try 16bit color depth */
+    if (! ggiCheckSimpleMode(vis, w, h, GGI_AUTO, GT_16BIT, &mode))
+    {
+       *type = GT_16BIT;
+       return(TRUE);
+    }
+    /* try 15bit color depth */
+    if (! ggiCheckSimpleMode(vis, w, h, GGI_AUTO, GT_15BIT, &mode))
+    {
+       *type = GT_15BIT;
+       return(TRUE);
+    }
+    /* try 24bit color depth */
+    if (! ggiCheckSimpleMode(vis, w, h, GGI_AUTO, GT_24BIT, &mode))
+    {
+       *type = GT_24BIT;
+       return(TRUE);
+    }
+    /* try 32bit color depth */
+    if (! ggiCheckSimpleMode(vis, w, h, GGI_AUTO, GT_32BIT, &mode))
+    {
+       *type = GT_32BIT;
+       return(TRUE);
+    }
+    return(FALSE);
+}
+
+/*
+ * determine video mode to set:
+ * must have >= colors as game (bitmap->depth == 16)
+ * must be >= resolution than game (visual_width/visual_height)
+ * 03-Nov-1999, chris
+ * 14-Mar-2000, chris, force_x + force_y
+ */
+static int set_video_mode(int depth)
+{
+    int i, best_score = 0;
+    ggi_graphtype type, best_type;
+    const ggi_directbuffer *direct_buf;
+    typedef void(*updater_t)(struct mame_bitmap *bitmap);
+    updater_t updaters[] = {
+        /* linear updaters */
+        NULL,
+        NULL,
+        NULL,
+        NULL,
+        NULL,
+        ggi_update_linear_16_to_16bpp,
+        ggi_update_linear_16_to_24bpp,
+        ggi_update_linear_16_to_32bpp,
+        /* non-linear updaters */
+        NULL,
+        NULL,
+        NULL,
+        NULL,
+        NULL,
+        ggi_update_16_to_16bpp,
+        ggi_update_16_to_24bpp,
+        ggi_update_16_to_32bpp,
+        /* scaled non-linear updaters */
+        NULL,
+        NULL,
+        NULL,
+        NULL,
+        NULL,
+        ggi_update_16_to_16bpp_scaled,
+        ggi_update_16_to_24bpp,
+        ggi_update_16_to_32bpp
+    };
+    int updater = 0;
+
+#ifdef GGI_DEBUG
+    fprintf(stderr_file,"set_video_mode called\n");
+#endif
+    scaled_visual_width = visual_width  * widthscale;
+    scaled_visual_height = visual_height * heightscale;
+
+    if (force_x == 0)
+        video_width = scaled_visual_width;
+    else
+        video_width = force_x;
+
+    if (force_y == 0)
+        video_height = scaled_visual_height;
+    else
+        video_height = force_y;
+
+    if (video_height < scaled_visual_height || video_width < scaled_visual_width) {
+        fprintf(stderr_file,"Forced resolution %dx%d < needed resolution %dx%d -- aborting...\n",
+                video_width,video_height,scaled_visual_width,scaled_visual_height);
+        return(FALSE);
+    }
+
+    if (force_x || force_y)
+        fprintf(stderr_file,"Command line override: setting mode %dx%d\n",video_width,video_height);
+
+    /* some GGI stuff */
+    vis = ggiOpen(NULL);
+    ggiSetFlags(vis, GGIFLAG_ASYNC);
+    ggiSetEventMask(vis, emKey | emPointer);
+
+    /* first try exact game resolution... */
+    if (! ggi_check_mode(vis, video_width, video_height, depth, &best_type) &&
+        (!force_x && !force_y))
+    {
+        int w, h, score;
+        /* now try from my [just hacked] list of modes */
+        /* (grrr -- isn't there a way to get all supported modes from GGI?) */
+        for (i=0; i<ML_ANZ; i++)
+        {
+            w = ggimodes[i].width;
+            h = ggimodes[i].height;
+            if (ggi_check_mode(vis, w, h, depth, &type)) {
+                score = mode_match(w,h);
+                if (score && score >= best_score) {
+                    best_score = score;
+                    best_type  = type;
+                    video_width = w; video_height = h;
+                }
+            }
+        }
+        if (! best_score) {
+            fprintf(stderr_file, "GGI: Couldn't find a suitable mode for a resolution of %dx%d\n"
+                    "Trying to get any mode....\n",
+                    scaled_visual_width,scaled_visual_height);
+            /* trying to get any mode from GGI */
+            if (ggiSetSimpleMode(vis,GGI_AUTO,GGI_AUTO,GGI_AUTO,GT_AUTO) != 0) {
+                fprintf(stderr_file, "GGI: Couldn't find a suitable mode for a resolution of %dx%d\n",
+                        scaled_visual_width,scaled_visual_height);
+                return(FALSE);
+            }
+            goto mode_set;
+        }
+    }
+
+    if (ggiCheckSimpleMode(vis, video_width, video_height, GGI_AUTO,
+                           best_type, &mode) != 0)
+       return(FALSE);
+
+    if (ggiSetMode(vis, &mode) != 0)
+       return(FALSE);
+
+ mode_set:
+
+    ggiGetMode(vis, &mode); /* Maybe we did not get what we asked for */
+    if ((mode.visible.x < scaled_visual_width)||
+	(mode.visible.y < scaled_visual_height)) {
+	fprintf(stderr_file,
+		"Fatal: cannot get big enough mode %dx%d\n",
+		scaled_visual_width,scaled_visual_height);
+        return(FALSE);
+    }
+    if ((mode.visible.x != scaled_visual_width)||
+	(mode.visible.y != scaled_visual_height)) {
+	fprintf(stderr_file,
+		"Notice: cannot get ideal mode %dx%d, setting to %dx%d\n",
+		scaled_visual_width,scaled_visual_height,mode.visible.x,mode.visible.y);
+    }
+    video_width   = mode.visible.x;
+    video_height  = mode.visible.y;
+    screen_startx = ((video_width - scaled_visual_width) / 2) & ~7;
+    screen_starty = (video_height - scaled_visual_height) / 2;
+    
+    /* choose the correct updater for this graphtype */
+    updater += (GT_SIZE(mode.graphtype) / 8) - 1;
+    
+    /* can we do linear ? */
+    if (use_linear && (direct_buf = ggiDBGetBuffer(vis,0)) &&
+        (direct_buf->type & GGI_DB_SIMPLE_PLB) )
+    {
+        if ((widthscale > 1 || heightscale > 2))
+        {
+           doublebuffer_buffer = malloc(scaled_visual_width * 
+              GT_SIZE(mode.graphtype) / 8);
+           if (!doublebuffer_buffer)
+           {
+              fprintf(stderr_file, "GGI: Error: Couldn't allocate doublebuffer buffer\n");
+              return FALSE;
+           }
+        }
+        video_mem = direct_buf->write;
+        video_mem += screen_startx * GT_SIZE(mode.graphtype) / 8;
+        video_mem += screen_starty * video_width *
+           GT_SIZE(mode.graphtype) / 8;
+#ifdef GGI_DEBUG
+        fprintf(stderr_file,
+           "ggi.c: set_video_mode: using %d bit linear update\n",
+           GT_SIZE(mode.graphtype));
+#endif
+    }
+    else
+    {
+        if((widthscale == 1) && (heightscale == 1))
+           updater += 8;
+        else
+           updater += 16;
+        /* we need the doublebuffer_buffer in the following scenarios:
+           -scale != 1x1
+           -16bpp modes, since it could be paletised
+           -if the depths don't match */
+        if( (widthscale > 1) || (heightscale > 1) || (depth == 16) ||
+            (depth != GT_SIZE(mode.graphtype)) )
+        {
+           doublebuffer_buffer = malloc(scaled_visual_width*scaled_visual_height*
+              GT_SIZE(mode.graphtype) / 8);
+           if (!doublebuffer_buffer)
+           {
+              fprintf(stderr_file, "GGI: Error: Couldn't allocate doublebuffer buffer\n");
+              return FALSE;
+           }
+        }
+    }
+    
+    if (depth == 16)
+       updater+=4;
+       
+    update_function = updaters[updater];
+    
+    /* fill the display_palette_info */
+    memset(&display_palette_info, 0, sizeof(struct sysdep_palette_info));
+    display_palette_info.depth = GT_SIZE(mode.graphtype);
+    switch (GT_SIZE(mode.graphtype))
+    {
+       case 8:
+          display_palette_info.writable_colors = 256;
+          break;
+       case 15:
+          display_palette_info.red_mask   = 0x001F;
+          display_palette_info.green_mask = 0x03E0;
+          display_palette_info.blue_mask  = 0xEC00;
+          break;
+       case 16:
+          display_palette_info.red_mask   = 0xF800;
+          display_palette_info.green_mask = 0x07E0;
+          display_palette_info.blue_mask  = 0x001F;
+          break;
+       case 24:
+       case 32:
+          display_palette_info.red_mask   = 0xFF0000;
+          display_palette_info.green_mask = 0x00FF00;
+          display_palette_info.blue_mask  = 0x0000FF;
+          break;
+    }
+    
+    return TRUE;
+}
+
+
+/*
+ * parts from svgalib.c version
+ */
+int sysdep_create_display(int depth)
+{
+#ifdef GGI_DEBUG
+    fprintf(stderr_file,"sysdep_create_display called\n");
+#endif
+/* do we need this? It makes debugging crashes sorta hard without a core file */
+#ifdef CATCH_SIGNALS
+    oldsigsegvh=signal(SIGSEGV,myhandler);
+    oldsigbush=signal(SIGBUS,myhandler);
+    oldsigquith=signal(SIGQUIT,myhandler);
+    if (oldsigsegvh == SIG_ERR || oldsigbush == SIG_ERR || oldsigquith == SIG_ERR) {
+	fprintf (stderr_file, "Cannot install signal handler. Exiting\n");
+	return OSD_NOT_OK;
+    }
+#endif
+    if (! set_video_mode(depth)) {
+        fprintf(stderr_file,"cannot find a mode to use :-(\n");
+        return OSD_NOT_OK;
+    }
+
+    fprintf(stderr_file,"GGI: using mode %dx%d\n",video_width,video_height);
+#ifdef GGI_DEBUG
+    fprintf(stderr_file,"16bit game: %s\n",(bitmap->depth == 16) ? "yes" : "no");
+#endif
+
+   effect_init2(depth, display_palette_info.depth, video_width);
+
+    return OSD_OK;
+}
+
+
+/*
+ * close down the display
+ */
+void sysdep_display_close(void)
+{
+#ifdef GGI_DEBUG
+    fprintf(stderr_file,"sysdep_display_close called\n");
+#endif
+/* do we need this? It makes debugging crashes sorta hard without a core file */
+#ifdef CATCH_SIGNALS
+    if (oldsigsegvh) signal(SIGSEGV,oldsigsegvh);
+    if (oldsigbush) signal(SIGBUS,oldsigbush);
+    if (oldsigquith) signal(SIGBUS,oldsigquith);
+#endif
+    ggi_cleanup();
+#ifdef GGI_DEBUG
+    fprintf(stderr_file,"sysdep_display_close finished\n");
+#endif
+}
+
+
+static void ggi_cleanup(void)
+{
+#ifdef GGI_DEBUG
+    fprintf(stderr_file,"ggi_cleanup called\n");
+#endif
+    if (vis) {
+      ggiClose(vis);
+      vis=NULL;
+    }
+    if (doublebuffer_buffer) free(doublebuffer_buffer);
+}
+
+
+int sysdep_display_alloc_palette(int writable_colors)
+{
+#ifdef GGI_DEBUG
+    fprintf(stderr_file,"sysdep_alloc_palette called\n");
+#endif
+
+    return 0;
+}
+
+
+int sysdep_display_set_pen(int pen,unsigned char red, unsigned char green,
+   unsigned char blue)
+{
+    ggi_color gpen;
+
+#if 0 && defined(GGI_DEBUG)
+    fprintf(stderr_file,"sysdep_modify_pen called\n");
+#endif
+    if (!vis) return -1; /* visual not initialized yet -- do nothing */
+
+    gpen.r = red << 8;
+    gpen.g = green << 8;
+    gpen.b = blue << 8;
+    ggiSetPalette(vis, pen, 1, &gpen);
+    
+    return 0;
+}
+
+
+/*
+ * low-level update routines
+ * for different color depths
+ * (04-Nov-99, they are working, but could
+ *  be improved: move calculations of
+ *  e.g. "X+screen_startx" out of the loops...)
+ */
+
+static void ggi_update_16_to_16bpp(struct mame_bitmap *bitmap)
+{
+   if (current_palette->lookup)
+   {
+      /* since we need todo the lookups we need to go through an extra buffer,
+         just like ggi_update_16_to_16bpp_scaled() does */
+      ggi_update_16_to_16bpp_scaled(bitmap);
+   }
+   else
+   {
+#define PUT_IMAGE(X, Y, WIDTH, HEIGHT) \
+    { \
+        int _i; \
+        for (_i=0; _i<HEIGHT; _i++) { \
+            ggiPutHLine(vis,screen_startx+(X),screen_starty+(Y)+_i, \
+                        WIDTH,bitmap->line[(Y)+visual.min_y+_i]+(visual.min_x+(X))*2); \
+        } \
+    }
+#include "blit.h"
+#undef PUT_IMAGE
+   }
+}
+
+/*---------*/
+
+void ggi_update_16_to_16bpp_scaled(struct mame_bitmap *bitmap)
+{
+#define SRC_PIXEL unsigned short
+#define DEST_PIXEL unsigned short
+#define DEST doublebuffer_buffer
+#define DEST_WIDTH scaled_visual_width
+#define PUT_IMAGE(X, Y, WIDTH, HEIGHT) \
+    { \
+        int _i; \
+        for (_i=0; _i<HEIGHT; _i++) { \
+            ggiPutHLine(vis,screen_startx+(X),screen_starty+(Y)+_i, \
+                        WIDTH,DEST + (X) * sizeof(DEST_PIXEL) + DEST_WIDTH * sizeof(DEST_PIXEL) * (_i + (Y)) ); \
+        } \
+    }
+    
+    if (current_palette->lookup)
+    {
+#define INDIRECT current_palette->lookup
+#include "blit.h"
+#undef INDIRECT
+    }
+    else
+    {
+#include "blit.h"
+    }
+#undef DEST_WIDTH
+#undef DEST
+#undef DEST_PIXEL
+#undef SRC_PIXEL
+#undef PUT_IMAGE
+}
+
+/*---------*/
+
+static void ggi_update_16_to_24bpp(struct mame_bitmap *bitmap)
+{
+#define INDIRECT current_palette->lookup
+#define SRC_PIXEL unsigned short
+#define DEST_PIXEL unsigned int
+#define DEST doublebuffer_buffer
+#define DEST_WIDTH scaled_visual_width
+#define PACK_BITS
+#define PUT_IMAGE(X, Y, WIDTH, HEIGHT) \
+    do { \
+        int _i; \
+        for (_i=0; _i<HEIGHT; _i++) { \
+            ggiPutHLine(vis,screen_startx+(X),screen_starty+(Y)+_i, \
+                        WIDTH,DEST + (X) * 3 + DEST_WIDTH * 3 * (_i + (Y)) ); \
+        } \
+    } while(0);
+#include "blit.h"
+#undef DEST_WIDTH
+#undef DEST
+#undef DEST_PIXEL
+#undef SRC_PIXEL
+#undef PUT_IMAGE
+#undef PACK_BITS
+#undef INDIRECT
+}
+
+/*---------*/
+
+static void ggi_update_16_to_32bpp(struct mame_bitmap *bitmap)
+{
+#define INDIRECT current_palette->lookup
+#define SRC_PIXEL unsigned short
+#define DEST_PIXEL unsigned int
+#define DEST doublebuffer_buffer
+#define DEST_WIDTH scaled_visual_width
+#define PUT_IMAGE(X, Y, WIDTH, HEIGHT) \
+    do { \
+        int _i; \
+        for (_i=0; _i<HEIGHT; _i++) { \
+            ggiPutHLine(vis,screen_startx+(X),screen_starty+(Y)+_i, \
+                        WIDTH,DEST + (X) * sizeof(DEST_PIXEL) + DEST_WIDTH * sizeof(DEST_PIXEL) * (_i + (Y)) ); \
+        } \
+    } while(0);
+#include "blit.h"
+#undef DEST_WIDTH
+#undef DEST
+#undef DEST_PIXEL
+#undef SRC_PIXEL
+#undef PUT_IMAGE
+#undef INDIRECT
+}
+
+/*---------*/
+
+static void ggi_update_linear_16_to_16bpp(struct mame_bitmap *bitmap)
+{
+#define DEST_PIXEL unsigned short
+#define SRC_PIXEL unsigned short
+#define DEST video_mem
+#define DEST_WIDTH mode.virt.x
+#define DOUBLEBUFFER
+    if (current_palette->lookup)
+    {
+#define INDIRECT current_palette->lookup
+#include "blit.h"
+#undef INDIRECT
+    }
+    else
+    {
+#include "blit.h"
+    }
+#undef DEST
+#undef DEST_WIDTH
+#undef DOUBLEBUFFER
+#undef SRC_PIXEL
+#undef DEST_PIXEL
+}
+
+/*---------*/
+
+static void ggi_update_linear_16_to_24bpp(struct mame_bitmap *bitmap)
+{
+#define INDIRECT current_palette->lookup
+#define DEST_PIXEL unsigned int
+#define SRC_PIXEL unsigned short
+#define PACK_BITS
+#define DEST video_mem
+#define DEST_WIDTH mode.virt.x
+#define DOUBLEBUFFER
+#include "blit.h"
+#undef DEST
+#undef DEST_WIDTH
+#undef DOUBLEBUFFER
+#undef PACK_BITS
+#undef SRC_PIXEL
+#undef DEST_PIXEL
+#undef INDIRECT
+}
+
+/*---------*/
+
+static void ggi_update_linear_16_to_32bpp(struct mame_bitmap *bitmap)
+{
+#define INDIRECT current_palette->lookup
+#define DEST_PIXEL unsigned int
+#define SRC_PIXEL unsigned short
+#define DEST video_mem
+#define DEST_WIDTH mode.virt.x
+#define DOUBLEBUFFER
+#include "blit.h"
+#undef PACK_BITS
+#undef DEST_WIDTH
+#undef DOUBLEBUFFER
+#undef SRC_PIXEL
+#undef DEST_PIXEL
+#undef INDIRECT
+}
+
+
+/*
+ * Update the display.
+ */
+void sysdep_update_display(struct mame_bitmap *bitmap) {
+
+    update_function(bitmap);
+    ggiFlush(vis);
+}
+
+int ggi_key(ggi_event *ev)
+{
+    unsigned int keycode=KEY_NONE;
+    int label = ev->key.label;
+
+#ifdef KEY_DEBUG
+    fprintf(stderr_file,
+        "Keyevent detected: sym = 0x%02x, code = 0x%02x, label = 0x%02x\n",
+        ev->key.sym, ev->key.button, label);
+#endif
+
+    switch (label >> 8)
+    {
+       case GII_KT_LATIN1:
+          switch (label) { /* for now, the simple way */
+              case GIIUC_BackSpace:  keycode = KEY_BACKSPACE;  break;
+              case GIIUC_Tab:        keycode = KEY_TAB;        break;
+              case GIIUC_Linefeed:   keycode = KEY_ENTER;      break;
+              case GIIUC_Return:     keycode = KEY_ENTER;      break;
+              case GIIUC_Escape:     keycode = KEY_ESC;        break;
+              case GIIUC_Delete:     keycode = KEY_DEL;        break;
+              case GIIUC_Space:      keycode = KEY_SPACE;      break;
+              case GIIUC_Exclam:     keycode = KEY_1;          break;
+              case GIIUC_QuoteDbl:   keycode = KEY_QUOTE;      break;
+              case GIIUC_Hash:       keycode = KEY_3;          break;
+              case GIIUC_Dollar:     keycode = KEY_4;          break;
+              case GIIUC_Percent:    keycode = KEY_5;          break;
+              case GIIUC_Ampersand:  keycode = KEY_7;          break;
+              case GIIUC_Apostrophe: keycode = KEY_QUOTE;      break;
+              case GIIUC_ParenLeft:  keycode = KEY_9;          break;
+              case GIIUC_ParenRight: keycode = KEY_0;          break;
+              case GIIUC_Asterisk:   keycode = KEY_ASTERISK;   break;
+              case GIIUC_Plus:       keycode = KEY_EQUALS;     break;
+              case GIIUC_Comma:      keycode = KEY_COMMA;      break;
+              case GIIUC_Minus:      keycode = KEY_MINUS;      break;
+              case GIIUC_Period:     keycode = KEY_STOP;       break;
+              case GIIUC_Slash:      keycode = KEY_SLASH;      break;
+              case GIIUC_0:          keycode = KEY_0;          break;
+              case GIIUC_1:          keycode = KEY_1;          break;
+              case GIIUC_2:          keycode = KEY_2;          break;
+              case GIIUC_3:          keycode = KEY_3;          break;
+              case GIIUC_4:          keycode = KEY_4;          break;
+              case GIIUC_5:          keycode = KEY_5;          break;
+              case GIIUC_6:          keycode = KEY_6;          break;
+              case GIIUC_7:          keycode = KEY_7;          break;
+              case GIIUC_8:          keycode = KEY_8;          break;
+              case GIIUC_9:          keycode = KEY_9;          break;
+              case GIIUC_Colon:      keycode = KEY_COLON;      break;
+              case GIIUC_Semicolon:  keycode = KEY_COLON;      break;
+              case GIIUC_Less:       keycode = KEY_COMMA;      break;
+              case GIIUC_Equal:      keycode = KEY_EQUALS;     break;
+              case GIIUC_Greater:    keycode = KEY_STOP;       break;
+              case GIIUC_Question:   keycode = KEY_SLASH;      break;
+              case GIIUC_At:         keycode = KEY_2;          break;
+              case GIIUC_A:          keycode = KEY_A;          break;
+              case GIIUC_B:          keycode = KEY_B;          break;
+              case GIIUC_C:          keycode = KEY_C;          break;
+              case GIIUC_D:          keycode = KEY_D;          break;
+              case GIIUC_E:          keycode = KEY_E;          break;
+              case GIIUC_F:          keycode = KEY_F;          break;
+              case GIIUC_G:          keycode = KEY_G;          break;
+              case GIIUC_H:          keycode = KEY_H;          break;
+              case GIIUC_I:          keycode = KEY_I;          break;
+              case GIIUC_J:          keycode = KEY_J;          break;
+              case GIIUC_K:          keycode = KEY_K;          break;
+              case GIIUC_L:          keycode = KEY_L;          break;
+              case GIIUC_M:          keycode = KEY_M;          break;
+              case GIIUC_N:          keycode = KEY_N;          break;
+              case GIIUC_O:          keycode = KEY_O;          break;
+              case GIIUC_P:          keycode = KEY_P;          break;
+              case GIIUC_Q:          keycode = KEY_Q;          break;
+              case GIIUC_R:          keycode = KEY_R;          break;
+              case GIIUC_S:          keycode = KEY_S;          break;
+              case GIIUC_T:          keycode = KEY_T;          break;
+              case GIIUC_U:          keycode = KEY_U;          break;
+              case GIIUC_V:          keycode = KEY_V;          break;
+              case GIIUC_W:          keycode = KEY_W;          break;
+              case GIIUC_X:          keycode = KEY_X;          break;
+              case GIIUC_Y:          keycode = KEY_Y;          break;
+              case GIIUC_Z:          keycode = KEY_Z;          break;
+              case GIIUC_BracketLeft:  keycode = KEY_OPENBRACE;  break;
+              case GIIUC_BackSlash:    keycode = KEY_BACKSLASH;  break;
+              case GIIUC_BracketRight: keycode = KEY_CLOSEBRACE; break;
+              case GIIUC_Circumflex:   keycode = KEY_6;          break;
+              case GIIUC_Underscore:   keycode = KEY_MINUS;      break;
+              case GIIUC_Grave:        keycode = KEY_TILDE;      break;
+              case GIIUC_a:          keycode = KEY_A;          break;
+              case GIIUC_b:          keycode = KEY_B;          break;
+              case GIIUC_c:          keycode = KEY_C;          break;
+              case GIIUC_d:          keycode = KEY_D;          break;
+              case GIIUC_e:          keycode = KEY_E;          break;
+              case GIIUC_f:          keycode = KEY_F;          break;
+              case GIIUC_g:          keycode = KEY_G;          break;
+              case GIIUC_h:          keycode = KEY_H;          break;
+              case GIIUC_i:          keycode = KEY_I;          break;
+              case GIIUC_j:          keycode = KEY_J;          break;
+              case GIIUC_k:          keycode = KEY_K;          break;
+              case GIIUC_l:          keycode = KEY_L;          break;
+              case GIIUC_m:          keycode = KEY_M;          break;
+              case GIIUC_n:          keycode = KEY_N;          break;
+              case GIIUC_o:          keycode = KEY_O;          break;
+              case GIIUC_p:          keycode = KEY_P;          break;
+              case GIIUC_q:          keycode = KEY_Q;          break;
+              case GIIUC_r:          keycode = KEY_R;          break;
+              case GIIUC_s:          keycode = KEY_S;          break;
+              case GIIUC_t:          keycode = KEY_T;          break;
+              case GIIUC_u:          keycode = KEY_U;          break;
+              case GIIUC_v:          keycode = KEY_V;          break;
+              case GIIUC_w:          keycode = KEY_W;          break;
+              case GIIUC_x:          keycode = KEY_X;          break;
+              case GIIUC_y:          keycode = KEY_Y;          break;
+              case GIIUC_z:          keycode = KEY_Z;          break;
+              case GIIUC_BraceLeft:  keycode = KEY_OPENBRACE;  break;
+              case GIIUC_Pipe:       keycode = KEY_BACKSLASH;  break;
+              case GIIUC_BraceRight: keycode = KEY_CLOSEBRACE; break;
+              case GIIUC_Tilde:      keycode = KEY_TILDE;      break;
+          }
+          break;
+       case GII_KT_SPEC:
+          switch (label) { /* for now, the simple way */
+              case GIIK_Break:       keycode = KEY_PAUSE;      break;
+              case GIIK_ScrollForw:  keycode = KEY_PGUP;       break;
+              case GIIK_ScrollBack:  keycode = KEY_PGDN;       break;
+              case GIIK_Menu:        keycode = KEY_MENU;       break;
+              case GIIK_Cancel:      keycode = KEY_ESC;        break;
+              case GIIK_PrintScreen: keycode = KEY_PRTSCR;     break;
+              case GIIK_Execute:     keycode = KEY_ENTER;      break;
+              case GIIK_Begin:       keycode = KEY_HOME;       break;
+              case GIIK_Clear:       keycode = KEY_DEL;        break;
+              case GIIK_Insert:      keycode = KEY_INSERT;     break;
+              case GIIK_Select:      keycode = KEY_ENTER_PAD;  break;
+              case GIIK_Pause:       keycode = KEY_PAUSE;      break;
+              case GIIK_SysRq:       keycode = KEY_PRTSCR;     break;
+              case GIIK_ModeSwitch:  keycode = KEY_ALTGR;      break;
+              case GIIK_Up:          keycode = KEY_UP;         break;
+              case GIIK_Down:        keycode = KEY_DOWN;       break;
+              case GIIK_Left:        keycode = KEY_LEFT;       break;
+              case GIIK_Right:       keycode = KEY_RIGHT;      break;
+              case GIIK_PageUp:      keycode = KEY_PGUP;       break;
+              case GIIK_PageDown:    keycode = KEY_PGDN;       break;
+              case GIIK_Home:        keycode = KEY_HOME;       break;
+              case GIIK_End:         keycode = KEY_END;        break;
+          }
+          break;
+       case GII_KT_FN:
+          switch (label) { /* for now, the simple way */
+              case GIIK_F1:      keycode = KEY_F1;     break;
+              case GIIK_F2:      keycode = KEY_F2;     break;
+              case GIIK_F3:      keycode = KEY_F3;     break;
+              case GIIK_F4:      keycode = KEY_F4;     break;
+              case GIIK_F5:      keycode = KEY_F5;     break;
+              case GIIK_F6:      keycode = KEY_F6;     break;
+              case GIIK_F7:      keycode = KEY_F7;     break;
+              case GIIK_F8:      keycode = KEY_F8;     break;
+              case GIIK_F9:      keycode = KEY_F9;     break;
+              case GIIK_F10:     keycode = KEY_F10;    break;
+              case GIIK_F11:     keycode = KEY_F11;    break;
+              case GIIK_F12:     keycode = KEY_F12;    break;
+          }
+          break;
+       case GII_KT_PAD:
+          switch (label) { /* for now, the simple way */
+              case GIIK_P0:          keycode = KEY_0_PAD;      break;
+              case GIIK_P1:          keycode = KEY_1_PAD;      break;
+              case GIIK_P2:          keycode = KEY_2_PAD;      break;
+              case GIIK_P3:          keycode = KEY_3_PAD;      break;
+              case GIIK_P4:          keycode = KEY_4_PAD;      break;
+              case GIIK_P5:          keycode = KEY_5_PAD;      break;
+              case GIIK_P6:          keycode = KEY_6_PAD;      break;
+              case GIIK_P7:          keycode = KEY_7_PAD;      break;
+              case GIIK_P8:          keycode = KEY_8_PAD;      break;
+              case GIIK_P9:          keycode = KEY_9_PAD;      break;
+              case GIIK_PA:          keycode = KEY_A;          break;
+              case GIIK_PB:          keycode = KEY_B;          break;
+              case GIIK_PC:          keycode = KEY_C;          break;
+              case GIIK_PD:          keycode = KEY_D;          break;
+              case GIIK_PE:          keycode = KEY_E;          break;
+              case GIIK_PF:          keycode = KEY_F;          break;
+              case GIIK_PPlus:       keycode = KEY_PLUS_PAD;   break;
+              case GIIK_PMinus:      keycode = KEY_MINUS_PAD;  break;
+              case GIIK_PSlash:      keycode = KEY_SLASH_PAD;  break;
+              case GIIK_PAsterisk:   keycode = KEY_ASTERISK;   break;
+              case GIIK_PEqual:       keycode = KEY_ENTER_PAD;  break;
+              case GIIK_PSeparator:  keycode = KEY_DEL_PAD;    break;
+              case GIIK_PDecimal:    keycode = KEY_DEL_PAD;    break;
+              case GIIK_PParenLeft:  keycode = KEY_9_PAD;      break;
+              case GIIK_PParenRight: keycode = KEY_0_PAD;      break;
+              case GIIK_PSpace:      keycode = KEY_SPACE;      break;
+              case GIIK_PEnter:      keycode = KEY_ENTER_PAD;  break;
+              case GIIK_PTab:        keycode = KEY_TAB;        break;
+              case GIIK_PBegin:      keycode = KEY_HOME;       break;
+              case GIIK_PF1:         keycode = KEY_F1;         break;
+              case GIIK_PF2:         keycode = KEY_F2;         break;
+              case GIIK_PF3:         keycode = KEY_F3;         break;
+              case GIIK_PF4:         keycode = KEY_F4;         break;
+              case GIIK_PF5:         keycode = KEY_F5;         break;
+              case GIIK_PF6:         keycode = KEY_F6;         break;
+              case GIIK_PF7:         keycode = KEY_F7;         break;
+              case GIIK_PF8:         keycode = KEY_F8;         break;
+              case GIIK_PF9:         keycode = KEY_F9;         break;
+          }
+          break;
+       case GII_KT_MOD:
+          switch (label) { /* for now, the simple way */
+              case GIIK_ShiftL:      keycode = KEY_LSHIFT;     break;
+              case GIIK_ShiftR:      keycode = KEY_RSHIFT;     break;
+              case GIIK_CtrlL:       keycode = KEY_LCONTROL;   break;
+              case GIIK_CtrlR:       keycode = KEY_RCONTROL;   break;
+              case GIIK_AltL:        keycode = KEY_ALT;        break;
+              case GIIK_AltR:        keycode = KEY_ALTGR;      break;
+              case GIIK_MetaL:       keycode = KEY_LWIN;       break;
+              case GIIK_MetaR:       keycode = KEY_RWIN;       break;
+              case GIIK_ShiftLock:   keycode = KEY_CAPSLOCK;   break;
+              case GIIK_CapsLock:    keycode = KEY_CAPSLOCK;   break;
+              case GIIK_NumLock:     keycode = KEY_NUMLOCK;    break;
+              case GIIK_ScrollLock:  keycode = KEY_SCRLOCK;    break;
+          }
+          break;
+       case GII_KT_DEAD:
+          switch (label) { /* for now, the simple way */
+          }
+          break;
+    }
+#ifdef KEY_DEBUG
+    fprintf(stderr_file,"returning keycode = %d\n",keycode);
+#endif
+    return(keycode);
+}
+
+void sysdep_update_keyboard(void)
+{
+    ggi_event_mask em = emAll; /*emKeyPress | emKeyRelease;*/
+    ggi_event ev;
+    struct timeval to = { 0 , 0 };
+    struct xmame_keyboard_event event;
+
+    if (vis) {
+        while(ggiEventPoll(vis,em,&to)) {
+            event.press = 0;
+            
+            ggiEventRead(vis,&ev,em);
+
+            switch(ev.any.type) {
+              case evKeyPress:
+                  event.press = 1;
+              case evKeyRelease:
+                  event.scancode = ggi_key(&ev);
+                  event.unicode = ev.key.sym;
+                  xmame_keyboard_register_event(&event);
+                  break;
+            }
+
+            to.tv_sec=to.tv_usec=0;
+        }
+    }
+    return;
+}
+
+
+/*
+ * mouse not really tested
+ */
+void sysdep_mouse_poll(void)
+{
+    ggi_event_mask em = emPtrButtonPress | emPtrButtonRelease | emPtrMove;
+    ggi_event ev;
+    struct timeval to = { 0 , 0 };
+    int bi;
+
+    if (vis) {
+        while(ggiEventPoll(vis,em,&to)) {
+            ggiEventRead(vis,&ev,em);
+            bi = 0;
+
+            switch(ev.any.type) {
+
+              case evPtrButtonPress:
+                  bi = 1;
+              case evPtrButtonRelease:
+                  if (ev.pbutton.button < MOUSE_BUTTONS)
+                     mouse_data[0].buttons[ev.pbutton.button] = bi;
+                  break;
+              case evPtrAbsolute:
+                  mouse_data[0].deltas[0] = lastmouse[0] - ev.pmove.x;
+                  mouse_data[0].deltas[1] = lastmouse[1] - ev.pmove.y;
+                  lastmouse[0] = ev.pmove.x;
+                  lastmouse[1] = ev.pmove.y;
+                  break;
+              case evPtrRelative:
+                  mouse_data[0].deltas[0] = ev.pmove.x;
+                  mouse_data[0].deltas[1] = ev.pmove.y;
+                  lastmouse[0] += ev.pmove.x;
+                  lastmouse[1] += ev.pmove.y;
+                  break;
+            }
+            to.tv_sec=to.tv_usec=0;
+        }
+    }
+}
+
+void sysdep_set_leds(int leds)
+{
+}
+#endif /* ifdef ggi */
diff --git a/src/unix/video-drivers/gl-disp-fetch.hc b/src/unix/video-drivers/gl-disp-fetch.hc
new file mode 100644
index 0000000..8caeb97
--- /dev/null
+++ b/src/unix/video-drivers/gl-disp-fetch.hc
@@ -0,0 +1,1328 @@
+/* WARNING ! WARNING *** THIS FILE IS GENERATED BY C2J !!!
+
+   DO NOT MAKE ANY CHANGES *** MAKE CHANGES IN THE SKELETON FILES !!!
+*/
+
+
+	disp__glGetString = (const GLubyte *(CALLBACK *)( GLenum))
+		GET_GL_PROCADDRESS ("glGetString");
+
+/**
+ * C2J Parser Version 2.0
+ * Jausoft - Sven Goethel Software Development
+ * Reading from file: gl-proto-auto.orig.h . . .
+ * Destination-Class: gl4java_GLUFuncJauJNI ! 
+ */
+
+	disp__glClearIndex = (void (CALLBACK *)(GLfloat))
+	  GET_GL_PROCADDRESS ("glClearIndex");
+
+	disp__glClearColor = (void (CALLBACK *)(GLclampf, GLclampf, GLclampf, GLclampf))
+	  GET_GL_PROCADDRESS ("glClearColor");
+
+	disp__glClear = (void (CALLBACK *)(GLbitfield))
+	  GET_GL_PROCADDRESS ("glClear");
+
+	disp__glIndexMask = (void (CALLBACK *)(GLuint))
+	  GET_GL_PROCADDRESS ("glIndexMask");
+
+	disp__glColorMask = (void (CALLBACK *)(GLboolean, GLboolean, GLboolean, GLboolean))
+	  GET_GL_PROCADDRESS ("glColorMask");
+
+	disp__glAlphaFunc = (void (CALLBACK *)(GLenum, GLclampf))
+	  GET_GL_PROCADDRESS ("glAlphaFunc");
+
+	disp__glBlendFunc = (void (CALLBACK *)(GLenum, GLenum))
+	  GET_GL_PROCADDRESS ("glBlendFunc");
+
+	disp__glLogicOp = (void (CALLBACK *)(GLenum))
+	  GET_GL_PROCADDRESS ("glLogicOp");
+
+	disp__glCullFace = (void (CALLBACK *)(GLenum))
+	  GET_GL_PROCADDRESS ("glCullFace");
+
+	disp__glFrontFace = (void (CALLBACK *)(GLenum))
+	  GET_GL_PROCADDRESS ("glFrontFace");
+
+	disp__glPointSize = (void (CALLBACK *)(GLfloat))
+	  GET_GL_PROCADDRESS ("glPointSize");
+
+	disp__glLineWidth = (void (CALLBACK *)(GLfloat))
+	  GET_GL_PROCADDRESS ("glLineWidth");
+
+	disp__glLineStipple = (void (CALLBACK *)(GLint, GLushort))
+	  GET_GL_PROCADDRESS ("glLineStipple");
+
+	disp__glPolygonMode = (void (CALLBACK *)(GLenum, GLenum))
+	  GET_GL_PROCADDRESS ("glPolygonMode");
+
+	disp__glPolygonOffset = (void (CALLBACK *)(GLfloat, GLfloat))
+	  GET_GL_PROCADDRESS ("glPolygonOffset");
+
+	disp__glPolygonStipple = (void (CALLBACK *)(const GLubyte *))
+	  GET_GL_PROCADDRESS ("glPolygonStipple");
+
+	disp__glGetPolygonStipple = (void (CALLBACK *)(GLubyte *))
+	  GET_GL_PROCADDRESS ("glGetPolygonStipple");
+
+	disp__glEdgeFlag = (void (CALLBACK *)(GLboolean))
+	  GET_GL_PROCADDRESS ("glEdgeFlag");
+
+	disp__glEdgeFlagv = (void (CALLBACK *)(const GLboolean *))
+	  GET_GL_PROCADDRESS ("glEdgeFlagv");
+
+	disp__glScissor = (void (CALLBACK *)(GLint, GLint, GLsizei, GLsizei))
+	  GET_GL_PROCADDRESS ("glScissor");
+
+	disp__glClipPlane = (void (CALLBACK *)(GLenum, const GLdouble *))
+	  GET_GL_PROCADDRESS ("glClipPlane");
+
+	disp__glGetClipPlane = (void (CALLBACK *)(GLenum, GLdouble *))
+	  GET_GL_PROCADDRESS ("glGetClipPlane");
+
+	disp__glDrawBuffer = (void (CALLBACK *)(GLenum))
+	  GET_GL_PROCADDRESS ("glDrawBuffer");
+
+	disp__glReadBuffer = (void (CALLBACK *)(GLenum))
+	  GET_GL_PROCADDRESS ("glReadBuffer");
+
+	disp__glEnable = (void (CALLBACK *)(GLenum))
+	  GET_GL_PROCADDRESS ("glEnable");
+
+	disp__glDisable = (void (CALLBACK *)(GLenum))
+	  GET_GL_PROCADDRESS ("glDisable");
+
+	disp__glIsEnabled = (GLboolean (CALLBACK *)(GLenum))
+	  GET_GL_PROCADDRESS ("glIsEnabled");
+
+	disp__glEnableClientState = (void (CALLBACK *)(GLenum))
+	  GET_GL_PROCADDRESS ("glEnableClientState");
+
+	disp__glDisableClientState = (void (CALLBACK *)(GLenum))
+	  GET_GL_PROCADDRESS ("glDisableClientState");
+
+	disp__glGetBooleanv = (void (CALLBACK *)(GLenum, GLboolean *))
+	  GET_GL_PROCADDRESS ("glGetBooleanv");
+
+	disp__glGetDoublev = (void (CALLBACK *)(GLenum, GLdouble *))
+	  GET_GL_PROCADDRESS ("glGetDoublev");
+
+	disp__glGetFloatv = (void (CALLBACK *)(GLenum, GLfloat *))
+	  GET_GL_PROCADDRESS ("glGetFloatv");
+
+	disp__glGetIntegerv = (void (CALLBACK *)(GLenum, GLint *))
+	  GET_GL_PROCADDRESS ("glGetIntegerv");
+
+	disp__glPushAttrib = (void (CALLBACK *)(GLbitfield))
+	  GET_GL_PROCADDRESS ("glPushAttrib");
+
+	disp__glPopAttrib = (void (CALLBACK *)(void))
+	  GET_GL_PROCADDRESS ("glPopAttrib");
+
+	disp__glPushClientAttrib = (void (CALLBACK *)(GLbitfield))
+	  GET_GL_PROCADDRESS ("glPushClientAttrib");
+
+	disp__glPopClientAttrib = (void (CALLBACK *)(void))
+	  GET_GL_PROCADDRESS ("glPopClientAttrib");
+
+	disp__glRenderMode = (GLint (CALLBACK *)(GLenum))
+	  GET_GL_PROCADDRESS ("glRenderMode");
+
+	disp__glGetError = (GLenum (CALLBACK *)(void))
+	  GET_GL_PROCADDRESS ("glGetError");
+
+	disp__glFinish = (void (CALLBACK *)(void))
+	  GET_GL_PROCADDRESS ("glFinish");
+
+	disp__glFlush = (void (CALLBACK *)(void))
+	  GET_GL_PROCADDRESS ("glFlush");
+
+	disp__glHint = (void (CALLBACK *)(GLenum, GLenum))
+	  GET_GL_PROCADDRESS ("glHint");
+
+	disp__glClearDepth = (void (CALLBACK *)(GLclampd))
+	  GET_GL_PROCADDRESS ("glClearDepth");
+
+	disp__glDepthFunc = (void (CALLBACK *)(GLenum))
+	  GET_GL_PROCADDRESS ("glDepthFunc");
+
+	disp__glDepthMask = (void (CALLBACK *)(GLboolean))
+	  GET_GL_PROCADDRESS ("glDepthMask");
+
+	disp__glDepthRange = (void (CALLBACK *)(GLclampd, GLclampd))
+	  GET_GL_PROCADDRESS ("glDepthRange");
+
+	disp__glClearAccum = (void (CALLBACK *)(GLfloat, GLfloat, GLfloat, GLfloat))
+	  GET_GL_PROCADDRESS ("glClearAccum");
+
+	disp__glAccum = (void (CALLBACK *)(GLenum, GLfloat))
+	  GET_GL_PROCADDRESS ("glAccum");
+
+	disp__glMatrixMode = (void (CALLBACK *)(GLenum))
+	  GET_GL_PROCADDRESS ("glMatrixMode");
+
+	disp__glOrtho = (void (CALLBACK *)(GLdouble, GLdouble, GLdouble, GLdouble, GLdouble, GLdouble))
+	  GET_GL_PROCADDRESS ("glOrtho");
+
+	disp__glFrustum = (void (CALLBACK *)(GLdouble, GLdouble, GLdouble, GLdouble, GLdouble, GLdouble))
+	  GET_GL_PROCADDRESS ("glFrustum");
+
+	disp__glViewport = (void (CALLBACK *)(GLint, GLint, GLsizei, GLsizei))
+	  GET_GL_PROCADDRESS ("glViewport");
+
+	disp__glPushMatrix = (void (CALLBACK *)(void))
+	  GET_GL_PROCADDRESS ("glPushMatrix");
+
+	disp__glPopMatrix = (void (CALLBACK *)(void))
+	  GET_GL_PROCADDRESS ("glPopMatrix");
+
+	disp__glLoadIdentity = (void (CALLBACK *)(void))
+	  GET_GL_PROCADDRESS ("glLoadIdentity");
+
+	disp__glLoadMatrixd = (void (CALLBACK *)(const GLdouble *))
+	  GET_GL_PROCADDRESS ("glLoadMatrixd");
+
+	disp__glLoadMatrixf = (void (CALLBACK *)(const GLfloat *))
+	  GET_GL_PROCADDRESS ("glLoadMatrixf");
+
+	disp__glMultMatrixd = (void (CALLBACK *)(const GLdouble *))
+	  GET_GL_PROCADDRESS ("glMultMatrixd");
+
+	disp__glMultMatrixf = (void (CALLBACK *)(const GLfloat *))
+	  GET_GL_PROCADDRESS ("glMultMatrixf");
+
+	disp__glRotated = (void (CALLBACK *)(GLdouble, GLdouble, GLdouble, GLdouble))
+	  GET_GL_PROCADDRESS ("glRotated");
+
+	disp__glRotatef = (void (CALLBACK *)(GLfloat, GLfloat, GLfloat, GLfloat))
+	  GET_GL_PROCADDRESS ("glRotatef");
+
+	disp__glScaled = (void (CALLBACK *)(GLdouble, GLdouble, GLdouble))
+	  GET_GL_PROCADDRESS ("glScaled");
+
+	disp__glScalef = (void (CALLBACK *)(GLfloat, GLfloat, GLfloat))
+	  GET_GL_PROCADDRESS ("glScalef");
+
+	disp__glTranslated = (void (CALLBACK *)(GLdouble, GLdouble, GLdouble))
+	  GET_GL_PROCADDRESS ("glTranslated");
+
+	disp__glTranslatef = (void (CALLBACK *)(GLfloat, GLfloat, GLfloat))
+	  GET_GL_PROCADDRESS ("glTranslatef");
+
+	disp__glIsList = (GLboolean (CALLBACK *)(GLuint))
+	  GET_GL_PROCADDRESS ("glIsList");
+
+	disp__glDeleteLists = (void (CALLBACK *)(GLuint, GLsizei))
+	  GET_GL_PROCADDRESS ("glDeleteLists");
+
+	disp__glGenLists = (GLuint (CALLBACK *)(GLsizei))
+	  GET_GL_PROCADDRESS ("glGenLists");
+
+	disp__glNewList = (void (CALLBACK *)(GLuint, GLenum))
+	  GET_GL_PROCADDRESS ("glNewList");
+
+	disp__glEndList = (void (CALLBACK *)(void))
+	  GET_GL_PROCADDRESS ("glEndList");
+
+	disp__glCallList = (void (CALLBACK *)(GLuint))
+	  GET_GL_PROCADDRESS ("glCallList");
+
+	disp__glCallLists = (void (CALLBACK *)(GLsizei, GLenum, const GLvoid *))
+	  GET_GL_PROCADDRESS ("glCallLists");
+
+	disp__glListBase = (void (CALLBACK *)(GLuint))
+	  GET_GL_PROCADDRESS ("glListBase");
+
+	disp__glBegin = (void (CALLBACK *)(GLenum))
+	  GET_GL_PROCADDRESS ("glBegin");
+
+	disp__glEnd = (void (CALLBACK *)(void))
+	  GET_GL_PROCADDRESS ("glEnd");
+
+	disp__glVertex2d = (void (CALLBACK *)(GLdouble, GLdouble))
+	  GET_GL_PROCADDRESS ("glVertex2d");
+
+	disp__glVertex2f = (void (CALLBACK *)(GLfloat, GLfloat))
+	  GET_GL_PROCADDRESS ("glVertex2f");
+
+	disp__glVertex2i = (void (CALLBACK *)(GLint, GLint))
+	  GET_GL_PROCADDRESS ("glVertex2i");
+
+	disp__glVertex2s = (void (CALLBACK *)(GLshort, GLshort))
+	  GET_GL_PROCADDRESS ("glVertex2s");
+
+	disp__glVertex3d = (void (CALLBACK *)(GLdouble, GLdouble, GLdouble))
+	  GET_GL_PROCADDRESS ("glVertex3d");
+
+	disp__glVertex3f = (void (CALLBACK *)(GLfloat, GLfloat, GLfloat))
+	  GET_GL_PROCADDRESS ("glVertex3f");
+
+	disp__glVertex3i = (void (CALLBACK *)(GLint, GLint, GLint))
+	  GET_GL_PROCADDRESS ("glVertex3i");
+
+	disp__glVertex3s = (void (CALLBACK *)(GLshort, GLshort, GLshort))
+	  GET_GL_PROCADDRESS ("glVertex3s");
+
+	disp__glVertex4d = (void (CALLBACK *)(GLdouble, GLdouble, GLdouble, GLdouble))
+	  GET_GL_PROCADDRESS ("glVertex4d");
+
+	disp__glVertex4f = (void (CALLBACK *)(GLfloat, GLfloat, GLfloat, GLfloat))
+	  GET_GL_PROCADDRESS ("glVertex4f");
+
+	disp__glVertex4i = (void (CALLBACK *)(GLint, GLint, GLint, GLint))
+	  GET_GL_PROCADDRESS ("glVertex4i");
+
+	disp__glVertex4s = (void (CALLBACK *)(GLshort, GLshort, GLshort, GLshort))
+	  GET_GL_PROCADDRESS ("glVertex4s");
+
+	disp__glVertex2dv = (void (CALLBACK *)(const GLdouble *))
+	  GET_GL_PROCADDRESS ("glVertex2dv");
+
+	disp__glVertex2fv = (void (CALLBACK *)(const GLfloat *))
+	  GET_GL_PROCADDRESS ("glVertex2fv");
+
+	disp__glVertex2iv = (void (CALLBACK *)(const GLint *))
+	  GET_GL_PROCADDRESS ("glVertex2iv");
+
+	disp__glVertex2sv = (void (CALLBACK *)(const GLshort *))
+	  GET_GL_PROCADDRESS ("glVertex2sv");
+
+	disp__glVertex3dv = (void (CALLBACK *)(const GLdouble *))
+	  GET_GL_PROCADDRESS ("glVertex3dv");
+
+	disp__glVertex3fv = (void (CALLBACK *)(const GLfloat *))
+	  GET_GL_PROCADDRESS ("glVertex3fv");
+
+	disp__glVertex3iv = (void (CALLBACK *)(const GLint *))
+	  GET_GL_PROCADDRESS ("glVertex3iv");
+
+	disp__glVertex3sv = (void (CALLBACK *)(const GLshort *))
+	  GET_GL_PROCADDRESS ("glVertex3sv");
+
+	disp__glVertex4dv = (void (CALLBACK *)(const GLdouble *))
+	  GET_GL_PROCADDRESS ("glVertex4dv");
+
+	disp__glVertex4fv = (void (CALLBACK *)(const GLfloat *))
+	  GET_GL_PROCADDRESS ("glVertex4fv");
+
+	disp__glVertex4iv = (void (CALLBACK *)(const GLint *))
+	  GET_GL_PROCADDRESS ("glVertex4iv");
+
+	disp__glVertex4sv = (void (CALLBACK *)(const GLshort *))
+	  GET_GL_PROCADDRESS ("glVertex4sv");
+
+	disp__glNormal3b = (void (CALLBACK *)(GLbyte, GLbyte, GLbyte))
+	  GET_GL_PROCADDRESS ("glNormal3b");
+
+	disp__glNormal3d = (void (CALLBACK *)(GLdouble, GLdouble, GLdouble))
+	  GET_GL_PROCADDRESS ("glNormal3d");
+
+	disp__glNormal3f = (void (CALLBACK *)(GLfloat, GLfloat, GLfloat))
+	  GET_GL_PROCADDRESS ("glNormal3f");
+
+	disp__glNormal3i = (void (CALLBACK *)(GLint, GLint, GLint))
+	  GET_GL_PROCADDRESS ("glNormal3i");
+
+	disp__glNormal3s = (void (CALLBACK *)(GLshort, GLshort, GLshort))
+	  GET_GL_PROCADDRESS ("glNormal3s");
+
+	disp__glNormal3bv = (void (CALLBACK *)(const GLbyte *))
+	  GET_GL_PROCADDRESS ("glNormal3bv");
+
+	disp__glNormal3dv = (void (CALLBACK *)(const GLdouble *))
+	  GET_GL_PROCADDRESS ("glNormal3dv");
+
+	disp__glNormal3fv = (void (CALLBACK *)(const GLfloat *))
+	  GET_GL_PROCADDRESS ("glNormal3fv");
+
+	disp__glNormal3iv = (void (CALLBACK *)(const GLint *))
+	  GET_GL_PROCADDRESS ("glNormal3iv");
+
+	disp__glNormal3sv = (void (CALLBACK *)(const GLshort *))
+	  GET_GL_PROCADDRESS ("glNormal3sv");
+
+	disp__glIndexd = (void (CALLBACK *)(GLdouble))
+	  GET_GL_PROCADDRESS ("glIndexd");
+
+	disp__glIndexf = (void (CALLBACK *)(GLfloat))
+	  GET_GL_PROCADDRESS ("glIndexf");
+
+	disp__glIndexi = (void (CALLBACK *)(GLint))
+	  GET_GL_PROCADDRESS ("glIndexi");
+
+	disp__glIndexs = (void (CALLBACK *)(GLshort))
+	  GET_GL_PROCADDRESS ("glIndexs");
+
+	disp__glIndexub = (void (CALLBACK *)(GLubyte))
+	  GET_GL_PROCADDRESS ("glIndexub");
+
+	disp__glIndexdv = (void (CALLBACK *)(const GLdouble *))
+	  GET_GL_PROCADDRESS ("glIndexdv");
+
+	disp__glIndexfv = (void (CALLBACK *)(const GLfloat *))
+	  GET_GL_PROCADDRESS ("glIndexfv");
+
+	disp__glIndexiv = (void (CALLBACK *)(const GLint *))
+	  GET_GL_PROCADDRESS ("glIndexiv");
+
+	disp__glIndexsv = (void (CALLBACK *)(const GLshort *))
+	  GET_GL_PROCADDRESS ("glIndexsv");
+
+	disp__glIndexubv = (void (CALLBACK *)(const GLubyte *))
+	  GET_GL_PROCADDRESS ("glIndexubv");
+
+	disp__glColor3b = (void (CALLBACK *)(GLbyte, GLbyte, GLbyte))
+	  GET_GL_PROCADDRESS ("glColor3b");
+
+	disp__glColor3d = (void (CALLBACK *)(GLdouble, GLdouble, GLdouble))
+	  GET_GL_PROCADDRESS ("glColor3d");
+
+	disp__glColor3f = (void (CALLBACK *)(GLfloat, GLfloat, GLfloat))
+	  GET_GL_PROCADDRESS ("glColor3f");
+
+	disp__glColor3i = (void (CALLBACK *)(GLint, GLint, GLint))
+	  GET_GL_PROCADDRESS ("glColor3i");
+
+	disp__glColor3s = (void (CALLBACK *)(GLshort, GLshort, GLshort))
+	  GET_GL_PROCADDRESS ("glColor3s");
+
+	disp__glColor3ub = (void (CALLBACK *)(GLubyte, GLubyte, GLubyte))
+	  GET_GL_PROCADDRESS ("glColor3ub");
+
+	disp__glColor3ui = (void (CALLBACK *)(GLuint, GLuint, GLuint))
+	  GET_GL_PROCADDRESS ("glColor3ui");
+
+	disp__glColor3us = (void (CALLBACK *)(GLushort, GLushort, GLushort))
+	  GET_GL_PROCADDRESS ("glColor3us");
+
+	disp__glColor4b = (void (CALLBACK *)(GLbyte, GLbyte, GLbyte, GLbyte))
+	  GET_GL_PROCADDRESS ("glColor4b");
+
+	disp__glColor4d = (void (CALLBACK *)(GLdouble, GLdouble, GLdouble, GLdouble))
+	  GET_GL_PROCADDRESS ("glColor4d");
+
+	disp__glColor4f = (void (CALLBACK *)(GLfloat, GLfloat, GLfloat, GLfloat))
+	  GET_GL_PROCADDRESS ("glColor4f");
+
+	disp__glColor4i = (void (CALLBACK *)(GLint, GLint, GLint, GLint))
+	  GET_GL_PROCADDRESS ("glColor4i");
+
+	disp__glColor4s = (void (CALLBACK *)(GLshort, GLshort, GLshort, GLshort))
+	  GET_GL_PROCADDRESS ("glColor4s");
+
+	disp__glColor4ub = (void (CALLBACK *)(GLubyte, GLubyte, GLubyte, GLubyte))
+	  GET_GL_PROCADDRESS ("glColor4ub");
+
+	disp__glColor4ui = (void (CALLBACK *)(GLuint, GLuint, GLuint, GLuint))
+	  GET_GL_PROCADDRESS ("glColor4ui");
+
+	disp__glColor4us = (void (CALLBACK *)(GLushort, GLushort, GLushort, GLushort))
+	  GET_GL_PROCADDRESS ("glColor4us");
+
+	disp__glColor3bv = (void (CALLBACK *)(const GLbyte *))
+	  GET_GL_PROCADDRESS ("glColor3bv");
+
+	disp__glColor3dv = (void (CALLBACK *)(const GLdouble *))
+	  GET_GL_PROCADDRESS ("glColor3dv");
+
+	disp__glColor3fv = (void (CALLBACK *)(const GLfloat *))
+	  GET_GL_PROCADDRESS ("glColor3fv");
+
+	disp__glColor3iv = (void (CALLBACK *)(const GLint *))
+	  GET_GL_PROCADDRESS ("glColor3iv");
+
+	disp__glColor3sv = (void (CALLBACK *)(const GLshort *))
+	  GET_GL_PROCADDRESS ("glColor3sv");
+
+	disp__glColor3ubv = (void (CALLBACK *)(const GLubyte *))
+	  GET_GL_PROCADDRESS ("glColor3ubv");
+
+	disp__glColor3uiv = (void (CALLBACK *)(const GLuint *))
+	  GET_GL_PROCADDRESS ("glColor3uiv");
+
+	disp__glColor3usv = (void (CALLBACK *)(const GLushort *))
+	  GET_GL_PROCADDRESS ("glColor3usv");
+
+	disp__glColor4bv = (void (CALLBACK *)(const GLbyte *))
+	  GET_GL_PROCADDRESS ("glColor4bv");
+
+	disp__glColor4dv = (void (CALLBACK *)(const GLdouble *))
+	  GET_GL_PROCADDRESS ("glColor4dv");
+
+	disp__glColor4fv = (void (CALLBACK *)(const GLfloat *))
+	  GET_GL_PROCADDRESS ("glColor4fv");
+
+	disp__glColor4iv = (void (CALLBACK *)(const GLint *))
+	  GET_GL_PROCADDRESS ("glColor4iv");
+
+	disp__glColor4sv = (void (CALLBACK *)(const GLshort *))
+	  GET_GL_PROCADDRESS ("glColor4sv");
+
+	disp__glColor4ubv = (void (CALLBACK *)(const GLubyte *))
+	  GET_GL_PROCADDRESS ("glColor4ubv");
+
+	disp__glColor4uiv = (void (CALLBACK *)(const GLuint *))
+	  GET_GL_PROCADDRESS ("glColor4uiv");
+
+	disp__glColor4usv = (void (CALLBACK *)(const GLushort *))
+	  GET_GL_PROCADDRESS ("glColor4usv");
+
+	disp__glTexCoord1d = (void (CALLBACK *)(GLdouble))
+	  GET_GL_PROCADDRESS ("glTexCoord1d");
+
+	disp__glTexCoord1f = (void (CALLBACK *)(GLfloat))
+	  GET_GL_PROCADDRESS ("glTexCoord1f");
+
+	disp__glTexCoord1i = (void (CALLBACK *)(GLint))
+	  GET_GL_PROCADDRESS ("glTexCoord1i");
+
+	disp__glTexCoord1s = (void (CALLBACK *)(GLshort))
+	  GET_GL_PROCADDRESS ("glTexCoord1s");
+
+	disp__glTexCoord2d = (void (CALLBACK *)(GLdouble, GLdouble))
+	  GET_GL_PROCADDRESS ("glTexCoord2d");
+
+	disp__glTexCoord2f = (void (CALLBACK *)(GLfloat, GLfloat))
+	  GET_GL_PROCADDRESS ("glTexCoord2f");
+
+	disp__glTexCoord2i = (void (CALLBACK *)(GLint, GLint))
+	  GET_GL_PROCADDRESS ("glTexCoord2i");
+
+	disp__glTexCoord2s = (void (CALLBACK *)(GLshort, GLshort))
+	  GET_GL_PROCADDRESS ("glTexCoord2s");
+
+	disp__glTexCoord3d = (void (CALLBACK *)(GLdouble, GLdouble, GLdouble))
+	  GET_GL_PROCADDRESS ("glTexCoord3d");
+
+	disp__glTexCoord3f = (void (CALLBACK *)(GLfloat, GLfloat, GLfloat))
+	  GET_GL_PROCADDRESS ("glTexCoord3f");
+
+	disp__glTexCoord3i = (void (CALLBACK *)(GLint, GLint, GLint))
+	  GET_GL_PROCADDRESS ("glTexCoord3i");
+
+	disp__glTexCoord3s = (void (CALLBACK *)(GLshort, GLshort, GLshort))
+	  GET_GL_PROCADDRESS ("glTexCoord3s");
+
+	disp__glTexCoord4d = (void (CALLBACK *)(GLdouble, GLdouble, GLdouble, GLdouble))
+	  GET_GL_PROCADDRESS ("glTexCoord4d");
+
+	disp__glTexCoord4f = (void (CALLBACK *)(GLfloat, GLfloat, GLfloat, GLfloat))
+	  GET_GL_PROCADDRESS ("glTexCoord4f");
+
+	disp__glTexCoord4i = (void (CALLBACK *)(GLint, GLint, GLint, GLint))
+	  GET_GL_PROCADDRESS ("glTexCoord4i");
+
+	disp__glTexCoord4s = (void (CALLBACK *)(GLshort, GLshort, GLshort, GLshort))
+	  GET_GL_PROCADDRESS ("glTexCoord4s");
+
+	disp__glTexCoord1dv = (void (CALLBACK *)(const GLdouble *))
+	  GET_GL_PROCADDRESS ("glTexCoord1dv");
+
+	disp__glTexCoord1fv = (void (CALLBACK *)(const GLfloat *))
+	  GET_GL_PROCADDRESS ("glTexCoord1fv");
+
+	disp__glTexCoord1iv = (void (CALLBACK *)(const GLint *))
+	  GET_GL_PROCADDRESS ("glTexCoord1iv");
+
+	disp__glTexCoord1sv = (void (CALLBACK *)(const GLshort *))
+	  GET_GL_PROCADDRESS ("glTexCoord1sv");
+
+	disp__glTexCoord2dv = (void (CALLBACK *)(const GLdouble *))
+	  GET_GL_PROCADDRESS ("glTexCoord2dv");
+
+	disp__glTexCoord2fv = (void (CALLBACK *)(const GLfloat *))
+	  GET_GL_PROCADDRESS ("glTexCoord2fv");
+
+	disp__glTexCoord2iv = (void (CALLBACK *)(const GLint *))
+	  GET_GL_PROCADDRESS ("glTexCoord2iv");
+
+	disp__glTexCoord2sv = (void (CALLBACK *)(const GLshort *))
+	  GET_GL_PROCADDRESS ("glTexCoord2sv");
+
+	disp__glTexCoord3dv = (void (CALLBACK *)(const GLdouble *))
+	  GET_GL_PROCADDRESS ("glTexCoord3dv");
+
+	disp__glTexCoord3fv = (void (CALLBACK *)(const GLfloat *))
+	  GET_GL_PROCADDRESS ("glTexCoord3fv");
+
+	disp__glTexCoord3iv = (void (CALLBACK *)(const GLint *))
+	  GET_GL_PROCADDRESS ("glTexCoord3iv");
+
+	disp__glTexCoord3sv = (void (CALLBACK *)(const GLshort *))
+	  GET_GL_PROCADDRESS ("glTexCoord3sv");
+
+	disp__glTexCoord4dv = (void (CALLBACK *)(const GLdouble *))
+	  GET_GL_PROCADDRESS ("glTexCoord4dv");
+
+	disp__glTexCoord4fv = (void (CALLBACK *)(const GLfloat *))
+	  GET_GL_PROCADDRESS ("glTexCoord4fv");
+
+	disp__glTexCoord4iv = (void (CALLBACK *)(const GLint *))
+	  GET_GL_PROCADDRESS ("glTexCoord4iv");
+
+	disp__glTexCoord4sv = (void (CALLBACK *)(const GLshort *))
+	  GET_GL_PROCADDRESS ("glTexCoord4sv");
+
+	disp__glRasterPos2d = (void (CALLBACK *)(GLdouble, GLdouble))
+	  GET_GL_PROCADDRESS ("glRasterPos2d");
+
+	disp__glRasterPos2f = (void (CALLBACK *)(GLfloat, GLfloat))
+	  GET_GL_PROCADDRESS ("glRasterPos2f");
+
+	disp__glRasterPos2i = (void (CALLBACK *)(GLint, GLint))
+	  GET_GL_PROCADDRESS ("glRasterPos2i");
+
+	disp__glRasterPos2s = (void (CALLBACK *)(GLshort, GLshort))
+	  GET_GL_PROCADDRESS ("glRasterPos2s");
+
+	disp__glRasterPos3d = (void (CALLBACK *)(GLdouble, GLdouble, GLdouble))
+	  GET_GL_PROCADDRESS ("glRasterPos3d");
+
+	disp__glRasterPos3f = (void (CALLBACK *)(GLfloat, GLfloat, GLfloat))
+	  GET_GL_PROCADDRESS ("glRasterPos3f");
+
+	disp__glRasterPos3i = (void (CALLBACK *)(GLint, GLint, GLint))
+	  GET_GL_PROCADDRESS ("glRasterPos3i");
+
+	disp__glRasterPos3s = (void (CALLBACK *)(GLshort, GLshort, GLshort))
+	  GET_GL_PROCADDRESS ("glRasterPos3s");
+
+	disp__glRasterPos4d = (void (CALLBACK *)(GLdouble, GLdouble, GLdouble, GLdouble))
+	  GET_GL_PROCADDRESS ("glRasterPos4d");
+
+	disp__glRasterPos4f = (void (CALLBACK *)(GLfloat, GLfloat, GLfloat, GLfloat))
+	  GET_GL_PROCADDRESS ("glRasterPos4f");
+
+	disp__glRasterPos4i = (void (CALLBACK *)(GLint, GLint, GLint, GLint))
+	  GET_GL_PROCADDRESS ("glRasterPos4i");
+
+	disp__glRasterPos4s = (void (CALLBACK *)(GLshort, GLshort, GLshort, GLshort))
+	  GET_GL_PROCADDRESS ("glRasterPos4s");
+
+	disp__glRasterPos2dv = (void (CALLBACK *)(const GLdouble *))
+	  GET_GL_PROCADDRESS ("glRasterPos2dv");
+
+	disp__glRasterPos2fv = (void (CALLBACK *)(const GLfloat *))
+	  GET_GL_PROCADDRESS ("glRasterPos2fv");
+
+	disp__glRasterPos2iv = (void (CALLBACK *)(const GLint *))
+	  GET_GL_PROCADDRESS ("glRasterPos2iv");
+
+	disp__glRasterPos2sv = (void (CALLBACK *)(const GLshort *))
+	  GET_GL_PROCADDRESS ("glRasterPos2sv");
+
+	disp__glRasterPos3dv = (void (CALLBACK *)(const GLdouble *))
+	  GET_GL_PROCADDRESS ("glRasterPos3dv");
+
+	disp__glRasterPos3fv = (void (CALLBACK *)(const GLfloat *))
+	  GET_GL_PROCADDRESS ("glRasterPos3fv");
+
+	disp__glRasterPos3iv = (void (CALLBACK *)(const GLint *))
+	  GET_GL_PROCADDRESS ("glRasterPos3iv");
+
+	disp__glRasterPos3sv = (void (CALLBACK *)(const GLshort *))
+	  GET_GL_PROCADDRESS ("glRasterPos3sv");
+
+	disp__glRasterPos4dv = (void (CALLBACK *)(const GLdouble *))
+	  GET_GL_PROCADDRESS ("glRasterPos4dv");
+
+	disp__glRasterPos4fv = (void (CALLBACK *)(const GLfloat *))
+	  GET_GL_PROCADDRESS ("glRasterPos4fv");
+
+	disp__glRasterPos4iv = (void (CALLBACK *)(const GLint *))
+	  GET_GL_PROCADDRESS ("glRasterPos4iv");
+
+	disp__glRasterPos4sv = (void (CALLBACK *)(const GLshort *))
+	  GET_GL_PROCADDRESS ("glRasterPos4sv");
+
+	disp__glRectd = (void (CALLBACK *)(GLdouble, GLdouble, GLdouble, GLdouble))
+	  GET_GL_PROCADDRESS ("glRectd");
+
+	disp__glRectf = (void (CALLBACK *)(GLfloat, GLfloat, GLfloat, GLfloat))
+	  GET_GL_PROCADDRESS ("glRectf");
+
+	disp__glRecti = (void (CALLBACK *)(GLint, GLint, GLint, GLint))
+	  GET_GL_PROCADDRESS ("glRecti");
+
+	disp__glRects = (void (CALLBACK *)(GLshort, GLshort, GLshort, GLshort))
+	  GET_GL_PROCADDRESS ("glRects");
+
+	disp__glRectdv = (void (CALLBACK *)(const GLdouble *, const GLdouble *))
+	  GET_GL_PROCADDRESS ("glRectdv");
+
+	disp__glRectfv = (void (CALLBACK *)(const GLfloat *, const GLfloat *))
+	  GET_GL_PROCADDRESS ("glRectfv");
+
+	disp__glRectiv = (void (CALLBACK *)(const GLint *, const GLint *))
+	  GET_GL_PROCADDRESS ("glRectiv");
+
+	disp__glRectsv = (void (CALLBACK *)(const GLshort *, const GLshort *))
+	  GET_GL_PROCADDRESS ("glRectsv");
+
+	disp__glVertexPointer = (void (CALLBACK *)(GLint, GLenum, GLsizei, const GLvoid *))
+	  GET_GL_PROCADDRESS ("glVertexPointer");
+
+	disp__glNormalPointer = (void (CALLBACK *)(GLenum, GLsizei, const GLvoid *))
+	  GET_GL_PROCADDRESS ("glNormalPointer");
+
+	disp__glColorPointer = (void (CALLBACK *)(GLint, GLenum, GLsizei, const GLvoid *))
+	  GET_GL_PROCADDRESS ("glColorPointer");
+
+	disp__glIndexPointer = (void (CALLBACK *)(GLenum, GLsizei, const GLvoid *))
+	  GET_GL_PROCADDRESS ("glIndexPointer");
+
+	disp__glTexCoordPointer = (void (CALLBACK *)(GLint, GLenum, GLsizei, const GLvoid *))
+	  GET_GL_PROCADDRESS ("glTexCoordPointer");
+
+	disp__glEdgeFlagPointer = (void (CALLBACK *)(GLsizei, const GLvoid *))
+	  GET_GL_PROCADDRESS ("glEdgeFlagPointer");
+
+	disp__glGetPointerv = (void (CALLBACK *)(GLenum, void **))
+	  GET_GL_PROCADDRESS ("glGetPointerv");
+
+	disp__glArrayElement = (void (CALLBACK *)(GLint))
+	  GET_GL_PROCADDRESS ("glArrayElement");
+
+	disp__glDrawArrays = (void (CALLBACK *)(GLenum, GLint, GLsizei))
+	  GET_GL_PROCADDRESS ("glDrawArrays");
+
+	disp__glDrawElements = (void (CALLBACK *)(GLenum, GLsizei, GLenum, const GLvoid *))
+	  GET_GL_PROCADDRESS ("glDrawElements");
+
+	disp__glInterleavedArrays = (void (CALLBACK *)(GLenum, GLsizei, const GLvoid *))
+	  GET_GL_PROCADDRESS ("glInterleavedArrays");
+
+	disp__glShadeModel = (void (CALLBACK *)(GLenum))
+	  GET_GL_PROCADDRESS ("glShadeModel");
+
+	disp__glLightf = (void (CALLBACK *)(GLenum, GLenum, GLfloat))
+	  GET_GL_PROCADDRESS ("glLightf");
+
+	disp__glLighti = (void (CALLBACK *)(GLenum, GLenum, GLint))
+	  GET_GL_PROCADDRESS ("glLighti");
+
+	disp__glLightfv = (void (CALLBACK *)(GLenum, GLenum, const GLfloat *))
+	  GET_GL_PROCADDRESS ("glLightfv");
+
+	disp__glLightiv = (void (CALLBACK *)(GLenum, GLenum, const GLint *))
+	  GET_GL_PROCADDRESS ("glLightiv");
+
+	disp__glGetLightfv = (void (CALLBACK *)(GLenum, GLenum, GLfloat *))
+	  GET_GL_PROCADDRESS ("glGetLightfv");
+
+	disp__glGetLightiv = (void (CALLBACK *)(GLenum, GLenum, GLint *))
+	  GET_GL_PROCADDRESS ("glGetLightiv");
+
+	disp__glLightModelf = (void (CALLBACK *)(GLenum, GLfloat))
+	  GET_GL_PROCADDRESS ("glLightModelf");
+
+	disp__glLightModeli = (void (CALLBACK *)(GLenum, GLint))
+	  GET_GL_PROCADDRESS ("glLightModeli");
+
+	disp__glLightModelfv = (void (CALLBACK *)(GLenum, const GLfloat *))
+	  GET_GL_PROCADDRESS ("glLightModelfv");
+
+	disp__glLightModeliv = (void (CALLBACK *)(GLenum, const GLint *))
+	  GET_GL_PROCADDRESS ("glLightModeliv");
+
+	disp__glMaterialf = (void (CALLBACK *)(GLenum, GLenum, GLfloat))
+	  GET_GL_PROCADDRESS ("glMaterialf");
+
+	disp__glMateriali = (void (CALLBACK *)(GLenum, GLenum, GLint))
+	  GET_GL_PROCADDRESS ("glMateriali");
+
+	disp__glMaterialfv = (void (CALLBACK *)(GLenum, GLenum, const GLfloat *))
+	  GET_GL_PROCADDRESS ("glMaterialfv");
+
+	disp__glMaterialiv = (void (CALLBACK *)(GLenum, GLenum, const GLint *))
+	  GET_GL_PROCADDRESS ("glMaterialiv");
+
+	disp__glGetMaterialfv = (void (CALLBACK *)(GLenum, GLenum, GLfloat *))
+	  GET_GL_PROCADDRESS ("glGetMaterialfv");
+
+	disp__glGetMaterialiv = (void (CALLBACK *)(GLenum, GLenum, GLint *))
+	  GET_GL_PROCADDRESS ("glGetMaterialiv");
+
+	disp__glColorMaterial = (void (CALLBACK *)(GLenum, GLenum))
+	  GET_GL_PROCADDRESS ("glColorMaterial");
+
+	disp__glPixelZoom = (void (CALLBACK *)(GLfloat, GLfloat))
+	  GET_GL_PROCADDRESS ("glPixelZoom");
+
+	disp__glPixelStoref = (void (CALLBACK *)(GLenum, GLfloat))
+	  GET_GL_PROCADDRESS ("glPixelStoref");
+
+	disp__glPixelStorei = (void (CALLBACK *)(GLenum, GLint))
+	  GET_GL_PROCADDRESS ("glPixelStorei");
+
+	disp__glPixelTransferf = (void (CALLBACK *)(GLenum, GLfloat))
+	  GET_GL_PROCADDRESS ("glPixelTransferf");
+
+	disp__glPixelTransferi = (void (CALLBACK *)(GLenum, GLint))
+	  GET_GL_PROCADDRESS ("glPixelTransferi");
+
+	disp__glPixelMapfv = (void (CALLBACK *)(GLenum, GLint, const GLfloat *))
+	  GET_GL_PROCADDRESS ("glPixelMapfv");
+
+	disp__glPixelMapuiv = (void (CALLBACK *)(GLenum, GLint, const GLuint *))
+	  GET_GL_PROCADDRESS ("glPixelMapuiv");
+
+	disp__glPixelMapusv = (void (CALLBACK *)(GLenum, GLint, const GLushort *))
+	  GET_GL_PROCADDRESS ("glPixelMapusv");
+
+	disp__glGetPixelMapfv = (void (CALLBACK *)(GLenum, GLfloat *))
+	  GET_GL_PROCADDRESS ("glGetPixelMapfv");
+
+	disp__glGetPixelMapuiv = (void (CALLBACK *)(GLenum, GLuint *))
+	  GET_GL_PROCADDRESS ("glGetPixelMapuiv");
+
+	disp__glGetPixelMapusv = (void (CALLBACK *)(GLenum, GLushort *))
+	  GET_GL_PROCADDRESS ("glGetPixelMapusv");
+
+	disp__glBitmap = (void (CALLBACK *)(GLsizei, GLsizei, GLfloat, GLfloat, GLfloat, GLfloat, const GLubyte *))
+	  GET_GL_PROCADDRESS ("glBitmap");
+
+	disp__glReadPixels = (void (CALLBACK *)(GLint, GLint, GLsizei, GLsizei, GLenum, GLenum, GLvoid *))
+	  GET_GL_PROCADDRESS ("glReadPixels");
+
+	disp__glDrawPixels = (void (CALLBACK *)(GLsizei, GLsizei, GLenum, GLenum, const GLvoid *))
+	  GET_GL_PROCADDRESS ("glDrawPixels");
+
+	disp__glCopyPixels = (void (CALLBACK *)(GLint, GLint, GLsizei, GLsizei, GLenum))
+	  GET_GL_PROCADDRESS ("glCopyPixels");
+
+	disp__glStencilFunc = (void (CALLBACK *)(GLenum, GLint, GLuint))
+	  GET_GL_PROCADDRESS ("glStencilFunc");
+
+	disp__glStencilMask = (void (CALLBACK *)(GLuint))
+	  GET_GL_PROCADDRESS ("glStencilMask");
+
+	disp__glStencilOp = (void (CALLBACK *)(GLenum, GLenum, GLenum))
+	  GET_GL_PROCADDRESS ("glStencilOp");
+
+	disp__glClearStencil = (void (CALLBACK *)(GLint))
+	  GET_GL_PROCADDRESS ("glClearStencil");
+
+	disp__glTexGend = (void (CALLBACK *)(GLenum, GLenum, GLdouble))
+	  GET_GL_PROCADDRESS ("glTexGend");
+
+	disp__glTexGenf = (void (CALLBACK *)(GLenum, GLenum, GLfloat))
+	  GET_GL_PROCADDRESS ("glTexGenf");
+
+	disp__glTexGeni = (void (CALLBACK *)(GLenum, GLenum, GLint))
+	  GET_GL_PROCADDRESS ("glTexGeni");
+
+	disp__glTexGendv = (void (CALLBACK *)(GLenum, GLenum, const GLdouble *))
+	  GET_GL_PROCADDRESS ("glTexGendv");
+
+	disp__glTexGenfv = (void (CALLBACK *)(GLenum, GLenum, const GLfloat *))
+	  GET_GL_PROCADDRESS ("glTexGenfv");
+
+	disp__glTexGeniv = (void (CALLBACK *)(GLenum, GLenum, const GLint *))
+	  GET_GL_PROCADDRESS ("glTexGeniv");
+
+	disp__glGetTexGendv = (void (CALLBACK *)(GLenum, GLenum, GLdouble *))
+	  GET_GL_PROCADDRESS ("glGetTexGendv");
+
+	disp__glGetTexGenfv = (void (CALLBACK *)(GLenum, GLenum, GLfloat *))
+	  GET_GL_PROCADDRESS ("glGetTexGenfv");
+
+	disp__glGetTexGeniv = (void (CALLBACK *)(GLenum, GLenum, GLint *))
+	  GET_GL_PROCADDRESS ("glGetTexGeniv");
+
+	disp__glTexEnvf = (void (CALLBACK *)(GLenum, GLenum, GLfloat))
+	  GET_GL_PROCADDRESS ("glTexEnvf");
+
+	disp__glTexEnvi = (void (CALLBACK *)(GLenum, GLenum, GLint))
+	  GET_GL_PROCADDRESS ("glTexEnvi");
+
+	disp__glTexEnvfv = (void (CALLBACK *)(GLenum, GLenum, const GLfloat *))
+	  GET_GL_PROCADDRESS ("glTexEnvfv");
+
+	disp__glTexEnviv = (void (CALLBACK *)(GLenum, GLenum, const GLint *))
+	  GET_GL_PROCADDRESS ("glTexEnviv");
+
+	disp__glGetTexEnvfv = (void (CALLBACK *)(GLenum, GLenum, GLfloat *))
+	  GET_GL_PROCADDRESS ("glGetTexEnvfv");
+
+	disp__glGetTexEnviv = (void (CALLBACK *)(GLenum, GLenum, GLint *))
+	  GET_GL_PROCADDRESS ("glGetTexEnviv");
+
+	disp__glTexParameterf = (void (CALLBACK *)(GLenum, GLenum, GLfloat))
+	  GET_GL_PROCADDRESS ("glTexParameterf");
+
+	disp__glTexParameteri = (void (CALLBACK *)(GLenum, GLenum, GLint))
+	  GET_GL_PROCADDRESS ("glTexParameteri");
+
+	disp__glTexParameterfv = (void (CALLBACK *)(GLenum, GLenum, const GLfloat *))
+	  GET_GL_PROCADDRESS ("glTexParameterfv");
+
+	disp__glTexParameteriv = (void (CALLBACK *)(GLenum, GLenum, const GLint *))
+	  GET_GL_PROCADDRESS ("glTexParameteriv");
+
+	disp__glGetTexParameterfv = (void (CALLBACK *)(GLenum, GLenum, GLfloat *))
+	  GET_GL_PROCADDRESS ("glGetTexParameterfv");
+
+	disp__glGetTexParameteriv = (void (CALLBACK *)(GLenum, GLenum, GLint *))
+	  GET_GL_PROCADDRESS ("glGetTexParameteriv");
+
+	disp__glGetTexLevelParameterfv = (void (CALLBACK *)(GLenum, GLint, GLenum, GLfloat *))
+	  GET_GL_PROCADDRESS ("glGetTexLevelParameterfv");
+
+	disp__glGetTexLevelParameteriv = (void (CALLBACK *)(GLenum, GLint, GLenum, GLint *))
+	  GET_GL_PROCADDRESS ("glGetTexLevelParameteriv");
+
+	disp__glTexImage1D = (void (CALLBACK *)(GLenum, GLint, GLint, GLsizei, GLint, GLenum, GLenum, const GLvoid *))
+	  GET_GL_PROCADDRESS ("glTexImage1D");
+
+	disp__glTexImage2D = (void (CALLBACK *)(GLenum, GLint, GLint, GLsizei, GLsizei, GLint, GLenum, GLenum, const GLvoid *))
+	  GET_GL_PROCADDRESS ("glTexImage2D");
+
+	disp__glGetTexImage = (void (CALLBACK *)(GLenum, GLint, GLenum, GLenum, GLvoid *))
+	  GET_GL_PROCADDRESS ("glGetTexImage");
+
+	disp__glGenTextures = (void (CALLBACK *)(GLsizei, GLuint *))
+	  GET_GL_PROCADDRESS ("glGenTextures");
+
+	disp__glDeleteTextures = (void (CALLBACK *)(GLsizei, const GLuint *))
+	  GET_GL_PROCADDRESS ("glDeleteTextures");
+
+	disp__glBindTexture = (void (CALLBACK *)(GLenum, GLuint))
+	  GET_GL_PROCADDRESS ("glBindTexture");
+
+	disp__glPrioritizeTextures = (void (CALLBACK *)(GLsizei, const GLuint *, const GLclampf *))
+	  GET_GL_PROCADDRESS ("glPrioritizeTextures");
+
+	disp__glAreTexturesResident = (GLboolean (CALLBACK *)(GLsizei, const GLuint *, GLboolean *))
+	  GET_GL_PROCADDRESS ("glAreTexturesResident");
+
+	disp__glIsTexture = (GLboolean (CALLBACK *)(GLuint))
+	  GET_GL_PROCADDRESS ("glIsTexture");
+
+	disp__glTexSubImage1D = (void (CALLBACK *)(GLenum, GLint, GLint, GLsizei, GLenum, GLenum, const GLvoid *))
+	  GET_GL_PROCADDRESS ("glTexSubImage1D");
+
+	disp__glTexSubImage2D = (void (CALLBACK *)(GLenum, GLint, GLint, GLint, GLsizei, GLsizei, GLenum, GLenum, const GLvoid *))
+	  GET_GL_PROCADDRESS ("glTexSubImage2D");
+
+	disp__glCopyTexImage1D = (void (CALLBACK *)(GLenum, GLint, GLenum, GLint, GLint, GLsizei, GLint))
+	  GET_GL_PROCADDRESS ("glCopyTexImage1D");
+
+	disp__glCopyTexImage2D = (void (CALLBACK *)(GLenum, GLint, GLenum, GLint, GLint, GLsizei, GLsizei, GLint))
+	  GET_GL_PROCADDRESS ("glCopyTexImage2D");
+
+	disp__glCopyTexSubImage1D = (void (CALLBACK *)(GLenum, GLint, GLint, GLint, GLint, GLsizei))
+	  GET_GL_PROCADDRESS ("glCopyTexSubImage1D");
+
+	disp__glCopyTexSubImage2D = (void (CALLBACK *)(GLenum, GLint, GLint, GLint, GLint, GLint, GLsizei, GLsizei))
+	  GET_GL_PROCADDRESS ("glCopyTexSubImage2D");
+
+	disp__glMap1d = (void (CALLBACK *)(GLenum, GLdouble, GLdouble, GLint, GLint, const GLdouble *))
+	  GET_GL_PROCADDRESS ("glMap1d");
+
+	disp__glMap1f = (void (CALLBACK *)(GLenum, GLfloat, GLfloat, GLint, GLint, const GLfloat *))
+	  GET_GL_PROCADDRESS ("glMap1f");
+
+	disp__glMap2d = (void (CALLBACK *)(GLenum, GLdouble, GLdouble, GLint, GLint, GLdouble, GLdouble, GLint, GLint, const GLdouble *))
+	  GET_GL_PROCADDRESS ("glMap2d");
+
+	disp__glMap2f = (void (CALLBACK *)(GLenum, GLfloat, GLfloat, GLint, GLint, GLfloat, GLfloat, GLint, GLint, const GLfloat *))
+	  GET_GL_PROCADDRESS ("glMap2f");
+
+	disp__glGetMapdv = (void (CALLBACK *)(GLenum, GLenum, GLdouble *))
+	  GET_GL_PROCADDRESS ("glGetMapdv");
+
+	disp__glGetMapfv = (void (CALLBACK *)(GLenum, GLenum, GLfloat *))
+	  GET_GL_PROCADDRESS ("glGetMapfv");
+
+	disp__glGetMapiv = (void (CALLBACK *)(GLenum, GLenum, GLint *))
+	  GET_GL_PROCADDRESS ("glGetMapiv");
+
+	disp__glEvalCoord1d = (void (CALLBACK *)(GLdouble))
+	  GET_GL_PROCADDRESS ("glEvalCoord1d");
+
+	disp__glEvalCoord1f = (void (CALLBACK *)(GLfloat))
+	  GET_GL_PROCADDRESS ("glEvalCoord1f");
+
+	disp__glEvalCoord1dv = (void (CALLBACK *)(const GLdouble *))
+	  GET_GL_PROCADDRESS ("glEvalCoord1dv");
+
+	disp__glEvalCoord1fv = (void (CALLBACK *)(const GLfloat *))
+	  GET_GL_PROCADDRESS ("glEvalCoord1fv");
+
+	disp__glEvalCoord2d = (void (CALLBACK *)(GLdouble, GLdouble))
+	  GET_GL_PROCADDRESS ("glEvalCoord2d");
+
+	disp__glEvalCoord2f = (void (CALLBACK *)(GLfloat, GLfloat))
+	  GET_GL_PROCADDRESS ("glEvalCoord2f");
+
+	disp__glEvalCoord2dv = (void (CALLBACK *)(const GLdouble *))
+	  GET_GL_PROCADDRESS ("glEvalCoord2dv");
+
+	disp__glEvalCoord2fv = (void (CALLBACK *)(const GLfloat *))
+	  GET_GL_PROCADDRESS ("glEvalCoord2fv");
+
+	disp__glMapGrid1d = (void (CALLBACK *)(GLint, GLdouble, GLdouble))
+	  GET_GL_PROCADDRESS ("glMapGrid1d");
+
+	disp__glMapGrid1f = (void (CALLBACK *)(GLint, GLfloat, GLfloat))
+	  GET_GL_PROCADDRESS ("glMapGrid1f");
+
+	disp__glMapGrid2d = (void (CALLBACK *)(GLint, GLdouble, GLdouble, GLint, GLdouble, GLdouble))
+	  GET_GL_PROCADDRESS ("glMapGrid2d");
+
+	disp__glMapGrid2f = (void (CALLBACK *)(GLint, GLfloat, GLfloat, GLint, GLfloat, GLfloat))
+	  GET_GL_PROCADDRESS ("glMapGrid2f");
+
+	disp__glEvalPoint1 = (void (CALLBACK *)(GLint))
+	  GET_GL_PROCADDRESS ("glEvalPoint1");
+
+	disp__glEvalPoint2 = (void (CALLBACK *)(GLint, GLint))
+	  GET_GL_PROCADDRESS ("glEvalPoint2");
+
+	disp__glEvalMesh1 = (void (CALLBACK *)(GLenum, GLint, GLint))
+	  GET_GL_PROCADDRESS ("glEvalMesh1");
+
+	disp__glEvalMesh2 = (void (CALLBACK *)(GLenum, GLint, GLint, GLint, GLint))
+	  GET_GL_PROCADDRESS ("glEvalMesh2");
+
+	disp__glFogf = (void (CALLBACK *)(GLenum, GLfloat))
+	  GET_GL_PROCADDRESS ("glFogf");
+
+	disp__glFogi = (void (CALLBACK *)(GLenum, GLint))
+	  GET_GL_PROCADDRESS ("glFogi");
+
+	disp__glFogfv = (void (CALLBACK *)(GLenum, const GLfloat *))
+	  GET_GL_PROCADDRESS ("glFogfv");
+
+	disp__glFogiv = (void (CALLBACK *)(GLenum, const GLint *))
+	  GET_GL_PROCADDRESS ("glFogiv");
+
+	disp__glFeedbackBuffer = (void (CALLBACK *)(GLsizei, GLenum, GLfloat *))
+	  GET_GL_PROCADDRESS ("glFeedbackBuffer");
+
+	disp__glPassThrough = (void (CALLBACK *)(GLfloat))
+	  GET_GL_PROCADDRESS ("glPassThrough");
+
+	disp__glSelectBuffer = (void (CALLBACK *)(GLsizei, GLuint *))
+	  GET_GL_PROCADDRESS ("glSelectBuffer");
+
+	disp__glInitNames = (void (CALLBACK *)(void))
+	  GET_GL_PROCADDRESS ("glInitNames");
+
+	disp__glLoadName = (void (CALLBACK *)(GLuint))
+	  GET_GL_PROCADDRESS ("glLoadName");
+
+	disp__glPushName = (void (CALLBACK *)(GLuint))
+	  GET_GL_PROCADDRESS ("glPushName");
+
+	disp__glPopName = (void (CALLBACK *)(void))
+	  GET_GL_PROCADDRESS ("glPopName");
+
+	disp__glDrawRangeElements = (void (CALLBACK *)(GLenum, GLuint, GLuint, GLsizei, GLenum, const GLvoid *))
+	  GET_GL_PROCADDRESS ("glDrawRangeElements");
+
+	disp__glTexImage3D = (void (CALLBACK *)(GLenum, GLint, GLint, GLsizei, GLsizei, GLsizei, GLint, GLenum, GLenum, const GLvoid *))
+	  GET_GL_PROCADDRESS ("glTexImage3D");
+
+	disp__glTexSubImage3D = (void (CALLBACK *)(GLenum, GLint, GLint, GLint, GLint, GLsizei, GLsizei, GLsizei, GLenum, GLenum, const GLvoid *))
+	  GET_GL_PROCADDRESS ("glTexSubImage3D");
+
+	disp__glCopyTexSubImage3D = (void (CALLBACK *)(GLenum, GLint, GLint, GLint, GLint, GLint, GLint, GLsizei, GLsizei))
+	  GET_GL_PROCADDRESS ("glCopyTexSubImage3D");
+
+	disp__glColorTable = (void (CALLBACK *)(GLenum, GLenum, GLsizei, GLenum, GLenum, const GLvoid *))
+	  GET_GL_PROCADDRESS ("glColorTable");
+
+	disp__glColorSubTable = (void (CALLBACK *)(GLenum, GLsizei, GLsizei, GLenum, GLenum, const GLvoid *))
+	  GET_GL_PROCADDRESS ("glColorSubTable");
+
+	disp__glColorTableParameteriv = (void (CALLBACK *)(GLenum, GLenum, const GLint *))
+	  GET_GL_PROCADDRESS ("glColorTableParameteriv");
+
+	disp__glColorTableParameterfv = (void (CALLBACK *)(GLenum, GLenum, const GLfloat *))
+	  GET_GL_PROCADDRESS ("glColorTableParameterfv");
+
+	disp__glCopyColorSubTable = (void (CALLBACK *)(GLenum, GLsizei, GLint, GLint, GLsizei))
+	  GET_GL_PROCADDRESS ("glCopyColorSubTable");
+
+	disp__glCopyColorTable = (void (CALLBACK *)(GLenum, GLenum, GLint, GLint, GLsizei))
+	  GET_GL_PROCADDRESS ("glCopyColorTable");
+
+	disp__glGetColorTable = (void (CALLBACK *)(GLenum, GLenum, GLenum, GLvoid *))
+	  GET_GL_PROCADDRESS ("glGetColorTable");
+
+	disp__glGetColorTableParameterfv = (void (CALLBACK *)(GLenum, GLenum, GLfloat *))
+	  GET_GL_PROCADDRESS ("glGetColorTableParameterfv");
+
+	disp__glGetColorTableParameteriv = (void (CALLBACK *)(GLenum, GLenum, GLint *))
+	  GET_GL_PROCADDRESS ("glGetColorTableParameteriv");
+
+	disp__glBlendEquation = (void (CALLBACK *)(GLenum))
+	  GET_GL_PROCADDRESS ("glBlendEquation");
+
+	disp__glBlendColor = (void (CALLBACK *)(GLclampf, GLclampf, GLclampf, GLclampf))
+	  GET_GL_PROCADDRESS ("glBlendColor");
+
+	disp__glHistogram = (void (CALLBACK *)(GLenum, GLsizei, GLenum, GLboolean))
+	  GET_GL_PROCADDRESS ("glHistogram");
+
+	disp__glResetHistogram = (void (CALLBACK *)(GLenum))
+	  GET_GL_PROCADDRESS ("glResetHistogram");
+
+	disp__glGetHistogram = (void (CALLBACK *)(GLenum, GLboolean, GLenum, GLenum, GLvoid *))
+	  GET_GL_PROCADDRESS ("glGetHistogram");
+
+	disp__glGetHistogramParameterfv = (void (CALLBACK *)(GLenum, GLenum, GLfloat *))
+	  GET_GL_PROCADDRESS ("glGetHistogramParameterfv");
+
+	disp__glGetHistogramParameteriv = (void (CALLBACK *)(GLenum, GLenum, GLint *))
+	  GET_GL_PROCADDRESS ("glGetHistogramParameteriv");
+
+	disp__glMinmax = (void (CALLBACK *)(GLenum, GLenum, GLboolean))
+	  GET_GL_PROCADDRESS ("glMinmax");
+
+	disp__glResetMinmax = (void (CALLBACK *)(GLenum))
+	  GET_GL_PROCADDRESS ("glResetMinmax");
+
+	disp__glGetMinmax = (void (CALLBACK *)(GLenum, GLboolean, GLenum, GLenum, GLvoid *))
+	  GET_GL_PROCADDRESS ("glGetMinmax");
+
+	disp__glGetMinmaxParameterfv = (void (CALLBACK *)(GLenum, GLenum, GLfloat *))
+	  GET_GL_PROCADDRESS ("glGetMinmaxParameterfv");
+
+	disp__glGetMinmaxParameteriv = (void (CALLBACK *)(GLenum, GLenum, GLint *))
+	  GET_GL_PROCADDRESS ("glGetMinmaxParameteriv");
+
+	disp__glConvolutionFilter1D = (void (CALLBACK *)(GLenum, GLenum, GLsizei, GLenum, GLenum, const GLvoid *))
+	  GET_GL_PROCADDRESS ("glConvolutionFilter1D");
+
+	disp__glConvolutionFilter2D = (void (CALLBACK *)(GLenum, GLenum, GLsizei, GLsizei, GLenum, GLenum, const GLvoid *))
+	  GET_GL_PROCADDRESS ("glConvolutionFilter2D");
+
+	disp__glConvolutionParameterf = (void (CALLBACK *)(GLenum, GLenum, GLfloat))
+	  GET_GL_PROCADDRESS ("glConvolutionParameterf");
+
+	disp__glConvolutionParameterfv = (void (CALLBACK *)(GLenum, GLenum, const GLfloat *))
+	  GET_GL_PROCADDRESS ("glConvolutionParameterfv");
+
+	disp__glConvolutionParameteri = (void (CALLBACK *)(GLenum, GLenum, GLint))
+	  GET_GL_PROCADDRESS ("glConvolutionParameteri");
+
+	disp__glConvolutionParameteriv = (void (CALLBACK *)(GLenum, GLenum, const GLint *))
+	  GET_GL_PROCADDRESS ("glConvolutionParameteriv");
+
+	disp__glCopyConvolutionFilter1D = (void (CALLBACK *)(GLenum, GLenum, GLint, GLint, GLsizei))
+	  GET_GL_PROCADDRESS ("glCopyConvolutionFilter1D");
+
+	disp__glCopyConvolutionFilter2D = (void (CALLBACK *)(GLenum, GLenum, GLint, GLint, GLsizei, GLsizei))
+	  GET_GL_PROCADDRESS ("glCopyConvolutionFilter2D");
+
+	disp__glGetConvolutionFilter = (void (CALLBACK *)(GLenum, GLenum, GLenum, GLvoid *))
+	  GET_GL_PROCADDRESS ("glGetConvolutionFilter");
+
+	disp__glGetConvolutionParameterfv = (void (CALLBACK *)(GLenum, GLenum, GLfloat *))
+	  GET_GL_PROCADDRESS ("glGetConvolutionParameterfv");
+
+	disp__glGetConvolutionParameteriv = (void (CALLBACK *)(GLenum, GLenum, GLint *))
+	  GET_GL_PROCADDRESS ("glGetConvolutionParameteriv");
+
+	disp__glSeparableFilter2D = (void (CALLBACK *)(GLenum, GLenum, GLsizei, GLsizei, GLenum, GLenum, const GLvoid *, const GLvoid *))
+	  GET_GL_PROCADDRESS ("glSeparableFilter2D");
+
+	disp__glGetSeparableFilter = (void (CALLBACK *)(GLenum, GLenum, GLenum, GLvoid *, GLvoid *, GLvoid *))
+	  GET_GL_PROCADDRESS ("glGetSeparableFilter");
+
+	disp__glBlendColorEXT = (void (CALLBACK *)(GLclampf, GLclampf, GLclampf, GLclampf))
+	  GET_GL_PROCADDRESS ("glBlendColorEXT");
+
+	disp__glPolygonOffsetEXT = (void (CALLBACK *)(GLfloat, GLfloat))
+	  GET_GL_PROCADDRESS ("glPolygonOffsetEXT");
+
+	disp__glTexImage3DEXT = (void (CALLBACK *)(GLenum, GLint, GLenum, GLsizei, GLsizei, GLsizei, GLint, GLenum, GLenum, const GLvoid *))
+	  GET_GL_PROCADDRESS ("glTexImage3DEXT");
+
+	disp__glTexSubImage3DEXT = (void (CALLBACK *)(GLenum, GLint, GLint, GLint, GLint, GLsizei, GLsizei, GLsizei, GLenum, GLenum, const GLvoid *))
+	  GET_GL_PROCADDRESS ("glTexSubImage3DEXT");
+
+	disp__glCopyTexSubImage3DEXT = (void (CALLBACK *)(GLenum, GLint, GLint, GLint, GLint, GLint, GLint, GLsizei, GLsizei))
+	  GET_GL_PROCADDRESS ("glCopyTexSubImage3DEXT");
+
+	disp__glGenTexturesEXT = (void (CALLBACK *)(GLsizei, GLuint *))
+	  GET_GL_PROCADDRESS ("glGenTexturesEXT");
+
+	disp__glDeleteTexturesEXT = (void (CALLBACK *)(GLsizei, const GLuint *))
+	  GET_GL_PROCADDRESS ("glDeleteTexturesEXT");
+
+	disp__glBindTextureEXT = (void (CALLBACK *)(GLenum, GLuint))
+	  GET_GL_PROCADDRESS ("glBindTextureEXT");
+
+	disp__glPrioritizeTexturesEXT = (void (CALLBACK *)(GLsizei, const GLuint *, const GLclampf *))
+	  GET_GL_PROCADDRESS ("glPrioritizeTexturesEXT");
+
+	disp__glAreTexturesResidentEXT = (GLboolean (CALLBACK *)(GLsizei, const GLuint *, GLboolean *))
+	  GET_GL_PROCADDRESS ("glAreTexturesResidentEXT");
+
+	disp__glIsTextureEXT = (GLboolean (CALLBACK *)(GLuint))
+	  GET_GL_PROCADDRESS ("glIsTextureEXT");
+
+	disp__glVertexPointerEXT = (void (CALLBACK *)(GLint, GLenum, GLsizei, GLsizei, const GLvoid *))
+	  GET_GL_PROCADDRESS ("glVertexPointerEXT");
+
+	disp__glNormalPointerEXT = (void (CALLBACK *)(GLenum, GLsizei, GLsizei, const GLvoid *))
+	  GET_GL_PROCADDRESS ("glNormalPointerEXT");
+
+	disp__glColorPointerEXT = (void (CALLBACK *)(GLint, GLenum, GLsizei, GLsizei, const GLvoid *))
+	  GET_GL_PROCADDRESS ("glColorPointerEXT");
+
+	disp__glIndexPointerEXT = (void (CALLBACK *)(GLenum, GLsizei, GLsizei, const GLvoid *))
+	  GET_GL_PROCADDRESS ("glIndexPointerEXT");
+
+	disp__glTexCoordPointerEXT = (void (CALLBACK *)(GLint, GLenum, GLsizei, GLsizei, const GLvoid *))
+	  GET_GL_PROCADDRESS ("glTexCoordPointerEXT");
+
+	disp__glEdgeFlagPointerEXT = (void (CALLBACK *)(GLsizei, GLsizei, const GLboolean *))
+	  GET_GL_PROCADDRESS ("glEdgeFlagPointerEXT");
+
+	disp__glGetPointervEXT = (void (CALLBACK *)(GLenum, void **))
+	  GET_GL_PROCADDRESS ("glGetPointervEXT");
+
+	disp__glArrayElementEXT = (void (CALLBACK *)(GLint))
+	  GET_GL_PROCADDRESS ("glArrayElementEXT");
+
+	disp__glDrawArraysEXT = (void (CALLBACK *)(GLenum, GLint, GLsizei))
+	  GET_GL_PROCADDRESS ("glDrawArraysEXT");
+
+	disp__glBlendEquationEXT = (void (CALLBACK *)(GLenum))
+	  GET_GL_PROCADDRESS ("glBlendEquationEXT");
+
+	disp__glPointParameterfEXT = (void (CALLBACK *)(GLenum, GLfloat))
+	  GET_GL_PROCADDRESS ("glPointParameterfEXT");
+
+	disp__glPointParameterfvEXT = (void (CALLBACK *)(GLenum, const GLfloat *))
+	  GET_GL_PROCADDRESS ("glPointParameterfvEXT");
+
+	disp__glColorTableEXT = (void (CALLBACK *)(GLenum, GLenum, GLsizei, GLenum, GLenum, const GLvoid *))
+	  GET_GL_PROCADDRESS ("glColorTableEXT");
+
+	disp__glColorSubTableEXT = (void (CALLBACK *)(GLenum, GLsizei, GLsizei, GLenum, GLenum, const GLvoid *))
+	  GET_GL_PROCADDRESS ("glColorSubTableEXT");
+
+	disp__glGetColorTableEXT = (void (CALLBACK *)(GLenum, GLenum, GLenum, GLvoid *))
+	  GET_GL_PROCADDRESS ("glGetColorTableEXT");
+
+	disp__glGetColorTableParameterfvEXT = (void (CALLBACK *)(GLenum, GLenum, GLfloat *))
+	  GET_GL_PROCADDRESS ("glGetColorTableParameterfvEXT");
+
+	disp__glGetColorTableParameterivEXT = (void (CALLBACK *)(GLenum, GLenum, GLint *))
+	  GET_GL_PROCADDRESS ("glGetColorTableParameterivEXT");
+
+	disp__glLockArraysEXT = (void (CALLBACK *)(GLint, GLsizei))
+	  GET_GL_PROCADDRESS ("glLockArraysEXT");
+
+	disp__glUnlockArraysEXT = (void (CALLBACK *)(void))
+	  GET_GL_PROCADDRESS ("glUnlockArraysEXT");
+
+	disp__glActiveTextureARB = (void (CALLBACK *)(GLenum))
+	  GET_GL_PROCADDRESS ("glActiveTextureARB");
+
+	disp__glClientActiveTextureARB = (void (CALLBACK *)(GLenum))
+	  GET_GL_PROCADDRESS ("glClientActiveTextureARB");
+
+	disp__glMultiTexCoord1dARB = (void (CALLBACK *)(GLenum, GLdouble))
+	  GET_GL_PROCADDRESS ("glMultiTexCoord1dARB");
+
+	disp__glMultiTexCoord1dvARB = (void (CALLBACK *)(GLenum, const GLdouble *))
+	  GET_GL_PROCADDRESS ("glMultiTexCoord1dvARB");
+
+	disp__glMultiTexCoord1fARB = (void (CALLBACK *)(GLenum, GLfloat))
+	  GET_GL_PROCADDRESS ("glMultiTexCoord1fARB");
+
+	disp__glMultiTexCoord1fvARB = (void (CALLBACK *)(GLenum, const GLfloat *))
+	  GET_GL_PROCADDRESS ("glMultiTexCoord1fvARB");
+
+	disp__glMultiTexCoord1iARB = (void (CALLBACK *)(GLenum, GLint))
+	  GET_GL_PROCADDRESS ("glMultiTexCoord1iARB");
+
+	disp__glMultiTexCoord1ivARB = (void (CALLBACK *)(GLenum, const GLint *))
+	  GET_GL_PROCADDRESS ("glMultiTexCoord1ivARB");
+
+	disp__glMultiTexCoord1sARB = (void (CALLBACK *)(GLenum, GLshort))
+	  GET_GL_PROCADDRESS ("glMultiTexCoord1sARB");
+
+	disp__glMultiTexCoord1svARB = (void (CALLBACK *)(GLenum, const GLshort *))
+	  GET_GL_PROCADDRESS ("glMultiTexCoord1svARB");
+
+	disp__glMultiTexCoord2dARB = (void (CALLBACK *)(GLenum, GLdouble, GLdouble))
+	  GET_GL_PROCADDRESS ("glMultiTexCoord2dARB");
+
+	disp__glMultiTexCoord2dvARB = (void (CALLBACK *)(GLenum, const GLdouble *))
+	  GET_GL_PROCADDRESS ("glMultiTexCoord2dvARB");
+
+	disp__glMultiTexCoord2fARB = (void (CALLBACK *)(GLenum, GLfloat, GLfloat))
+	  GET_GL_PROCADDRESS ("glMultiTexCoord2fARB");
+
+	disp__glMultiTexCoord2fvARB = (void (CALLBACK *)(GLenum, const GLfloat *))
+	  GET_GL_PROCADDRESS ("glMultiTexCoord2fvARB");
+
+	disp__glMultiTexCoord2iARB = (void (CALLBACK *)(GLenum, GLint, GLint))
+	  GET_GL_PROCADDRESS ("glMultiTexCoord2iARB");
+
+	disp__glMultiTexCoord2ivARB = (void (CALLBACK *)(GLenum, const GLint *))
+	  GET_GL_PROCADDRESS ("glMultiTexCoord2ivARB");
+
+	disp__glMultiTexCoord2sARB = (void (CALLBACK *)(GLenum, GLshort, GLshort))
+	  GET_GL_PROCADDRESS ("glMultiTexCoord2sARB");
+
+	disp__glMultiTexCoord2svARB = (void (CALLBACK *)(GLenum, const GLshort *))
+	  GET_GL_PROCADDRESS ("glMultiTexCoord2svARB");
+
+	disp__glMultiTexCoord3dARB = (void (CALLBACK *)(GLenum, GLdouble, GLdouble, GLdouble))
+	  GET_GL_PROCADDRESS ("glMultiTexCoord3dARB");
+
+	disp__glMultiTexCoord3dvARB = (void (CALLBACK *)(GLenum, const GLdouble *))
+	  GET_GL_PROCADDRESS ("glMultiTexCoord3dvARB");
+
+	disp__glMultiTexCoord3fARB = (void (CALLBACK *)(GLenum, GLfloat, GLfloat, GLfloat))
+	  GET_GL_PROCADDRESS ("glMultiTexCoord3fARB");
+
+	disp__glMultiTexCoord3fvARB = (void (CALLBACK *)(GLenum, const GLfloat *))
+	  GET_GL_PROCADDRESS ("glMultiTexCoord3fvARB");
+
+	disp__glMultiTexCoord3iARB = (void (CALLBACK *)(GLenum, GLint, GLint, GLint))
+	  GET_GL_PROCADDRESS ("glMultiTexCoord3iARB");
+
+	disp__glMultiTexCoord3ivARB = (void (CALLBACK *)(GLenum, const GLint *))
+	  GET_GL_PROCADDRESS ("glMultiTexCoord3ivARB");
+
+	disp__glMultiTexCoord3sARB = (void (CALLBACK *)(GLenum, GLshort, GLshort, GLshort))
+	  GET_GL_PROCADDRESS ("glMultiTexCoord3sARB");
+
+	disp__glMultiTexCoord3svARB = (void (CALLBACK *)(GLenum, const GLshort *))
+	  GET_GL_PROCADDRESS ("glMultiTexCoord3svARB");
+
+	disp__glMultiTexCoord4dARB = (void (CALLBACK *)(GLenum, GLdouble, GLdouble, GLdouble, GLdouble))
+	  GET_GL_PROCADDRESS ("glMultiTexCoord4dARB");
+
+	disp__glMultiTexCoord4dvARB = (void (CALLBACK *)(GLenum, const GLdouble *))
+	  GET_GL_PROCADDRESS ("glMultiTexCoord4dvARB");
+
+	disp__glMultiTexCoord4fARB = (void (CALLBACK *)(GLenum, GLfloat, GLfloat, GLfloat, GLfloat))
+	  GET_GL_PROCADDRESS ("glMultiTexCoord4fARB");
+
+	disp__glMultiTexCoord4fvARB = (void (CALLBACK *)(GLenum, const GLfloat *))
+	  GET_GL_PROCADDRESS ("glMultiTexCoord4fvARB");
+
+	disp__glMultiTexCoord4iARB = (void (CALLBACK *)(GLenum, GLint, GLint, GLint, GLint))
+	  GET_GL_PROCADDRESS ("glMultiTexCoord4iARB");
+
+	disp__glMultiTexCoord4ivARB = (void (CALLBACK *)(GLenum, const GLint *))
+	  GET_GL_PROCADDRESS ("glMultiTexCoord4ivARB");
+
+	disp__glMultiTexCoord4sARB = (void (CALLBACK *)(GLenum, GLshort, GLshort, GLshort, GLshort))
+	  GET_GL_PROCADDRESS ("glMultiTexCoord4sARB");
+
+	disp__glMultiTexCoord4svARB = (void (CALLBACK *)(GLenum, const GLshort *))
+	  GET_GL_PROCADDRESS ("glMultiTexCoord4svARB");
+
+/* C2J Parser Version 2.0:  Java program parsed successfully. */ 
diff --git a/src/unix/video-drivers/gl-disp-var.h b/src/unix/video-drivers/gl-disp-var.h
new file mode 100644
index 0000000..8ed3a45
--- /dev/null
+++ b/src/unix/video-drivers/gl-disp-var.h
@@ -0,0 +1,3511 @@
+/* WARNING ! WARNING *** THIS FILE IS GENERATED BY C2J !!!
+
+   DO NOT MAKE ANY CHANGES *** MAKE CHANGES IN THE SKELETON FILES !!!
+*/
+
+
+	LIBAPI const GLubyte *(CALLBACK * disp__glGetString )( GLenum name );
+/**
+ * C2J Parser Version 2.0
+ * Jausoft - Sven Goethel Software Development
+ * Reading from file: gl-proto-auto.orig.h . . .
+ * Destination-Class: gl4java_GLUFuncJauJNI ! 
+ */
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glClearIndex ( GLfloat c ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glClearIndex )(GLfloat);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glClearColor ( GLclampf red , GLclampf green , GLclampf blue , GLclampf alpha ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glClearColor )(GLclampf, GLclampf, GLclampf, GLclampf);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glClear ( GLbitfield mask ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glClear )(GLbitfield);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glIndexMask ( GLuint mask ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glIndexMask )(GLuint);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glColorMask ( GLboolean red , GLboolean green , GLboolean blue , GLboolean alpha ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glColorMask )(GLboolean, GLboolean, GLboolean, GLboolean);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glAlphaFunc ( GLenum func , GLclampf ref ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glAlphaFunc )(GLenum, GLclampf);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glBlendFunc ( GLenum sfactor , GLenum dfactor ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glBlendFunc )(GLenum, GLenum);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glLogicOp ( GLenum opcode ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glLogicOp )(GLenum);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glCullFace ( GLenum mode ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glCullFace )(GLenum);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glFrontFace ( GLenum mode ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glFrontFace )(GLenum);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glPointSize ( GLfloat size ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glPointSize )(GLfloat);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glLineWidth ( GLfloat width ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glLineWidth )(GLfloat);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glLineStipple ( GLint factor , GLushort pattern ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glLineStipple )(GLint, GLushort);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glPolygonMode ( GLenum face , GLenum mode ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glPolygonMode )(GLenum, GLenum);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glPolygonOffset ( GLfloat factor , GLfloat units ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glPolygonOffset )(GLfloat, GLfloat);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glPolygonStipple ( const GLubyte * mask ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glPolygonStipple )(const GLubyte *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glGetPolygonStipple ( GLubyte * mask ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glGetPolygonStipple )(GLubyte *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glEdgeFlag ( GLboolean flag ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glEdgeFlag )(GLboolean);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glEdgeFlagv ( const GLboolean * flag ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glEdgeFlagv )(const GLboolean *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glScissor ( GLint x , GLint y , GLsizei width , GLsizei height ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glScissor )(GLint, GLint, GLsizei, GLsizei);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glClipPlane ( GLenum plane , const GLdouble * equation ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glClipPlane )(GLenum, const GLdouble *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glGetClipPlane ( GLenum plane , GLdouble * equation ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glGetClipPlane )(GLenum, GLdouble *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glDrawBuffer ( GLenum mode ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glDrawBuffer )(GLenum);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glReadBuffer ( GLenum mode ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glReadBuffer )(GLenum);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glEnable ( GLenum cap ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glEnable )(GLenum);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glDisable ( GLenum cap ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glDisable )(GLenum);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern GLboolean glIsEnabled ( GLenum cap ) ;
+ * </pre> 
+ */
+	LIBAPI GLboolean (CALLBACK * disp__glIsEnabled )(GLenum);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glEnableClientState ( GLenum cap ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glEnableClientState )(GLenum);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glDisableClientState ( GLenum cap ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glDisableClientState )(GLenum);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glGetBooleanv ( GLenum pname , GLboolean * params ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glGetBooleanv )(GLenum, GLboolean *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glGetDoublev ( GLenum pname , GLdouble * params ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glGetDoublev )(GLenum, GLdouble *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glGetFloatv ( GLenum pname , GLfloat * params ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glGetFloatv )(GLenum, GLfloat *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glGetIntegerv ( GLenum pname , GLint * params ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glGetIntegerv )(GLenum, GLint *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glPushAttrib ( GLbitfield mask ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glPushAttrib )(GLbitfield);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glPopAttrib ( void ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glPopAttrib )(void);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glPushClientAttrib ( GLbitfield mask ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glPushClientAttrib )(GLbitfield);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glPopClientAttrib ( void ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glPopClientAttrib )(void);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern GLint glRenderMode ( GLenum mode ) ;
+ * </pre> 
+ */
+	LIBAPI GLint (CALLBACK * disp__glRenderMode )(GLenum);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern GLenum glGetError ( void ) ;
+ * </pre> 
+ */
+	LIBAPI GLenum (CALLBACK * disp__glGetError )(void);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glFinish ( void ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glFinish )(void);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glFlush ( void ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glFlush )(void);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glHint ( GLenum target , GLenum mode ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glHint )(GLenum, GLenum);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glClearDepth ( GLclampd depth ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glClearDepth )(GLclampd);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glDepthFunc ( GLenum func ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glDepthFunc )(GLenum);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glDepthMask ( GLboolean flag ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glDepthMask )(GLboolean);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glDepthRange ( GLclampd near_val , GLclampd far_val ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glDepthRange )(GLclampd, GLclampd);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glClearAccum ( GLfloat red , GLfloat green , GLfloat blue , GLfloat alpha ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glClearAccum )(GLfloat, GLfloat, GLfloat, GLfloat);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glAccum ( GLenum op , GLfloat value ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glAccum )(GLenum, GLfloat);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glMatrixMode ( GLenum mode ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glMatrixMode )(GLenum);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glOrtho ( GLdouble left , GLdouble right , GLdouble bottom , GLdouble top , GLdouble near_val , GLdouble far_val ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glOrtho )(GLdouble, GLdouble, GLdouble, GLdouble, GLdouble, GLdouble);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glFrustum ( GLdouble left , GLdouble right , GLdouble bottom , GLdouble top , GLdouble near_val , GLdouble far_val ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glFrustum )(GLdouble, GLdouble, GLdouble, GLdouble, GLdouble, GLdouble);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glViewport ( GLint x , GLint y , GLsizei width , GLsizei height ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glViewport )(GLint, GLint, GLsizei, GLsizei);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glPushMatrix ( void ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glPushMatrix )(void);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glPopMatrix ( void ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glPopMatrix )(void);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glLoadIdentity ( void ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glLoadIdentity )(void);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glLoadMatrixd ( const GLdouble * m ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glLoadMatrixd )(const GLdouble *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glLoadMatrixf ( const GLfloat * m ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glLoadMatrixf )(const GLfloat *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glMultMatrixd ( const GLdouble * m ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glMultMatrixd )(const GLdouble *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glMultMatrixf ( const GLfloat * m ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glMultMatrixf )(const GLfloat *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glRotated ( GLdouble angle , GLdouble x , GLdouble y , GLdouble z ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glRotated )(GLdouble, GLdouble, GLdouble, GLdouble);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glRotatef ( GLfloat angle , GLfloat x , GLfloat y , GLfloat z ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glRotatef )(GLfloat, GLfloat, GLfloat, GLfloat);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glScaled ( GLdouble x , GLdouble y , GLdouble z ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glScaled )(GLdouble, GLdouble, GLdouble);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glScalef ( GLfloat x , GLfloat y , GLfloat z ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glScalef )(GLfloat, GLfloat, GLfloat);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glTranslated ( GLdouble x , GLdouble y , GLdouble z ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glTranslated )(GLdouble, GLdouble, GLdouble);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glTranslatef ( GLfloat x , GLfloat y , GLfloat z ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glTranslatef )(GLfloat, GLfloat, GLfloat);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern GLboolean glIsList ( GLuint list ) ;
+ * </pre> 
+ */
+	LIBAPI GLboolean (CALLBACK * disp__glIsList )(GLuint);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glDeleteLists ( GLuint list , GLsizei range ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glDeleteLists )(GLuint, GLsizei);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern GLuint glGenLists ( GLsizei range ) ;
+ * </pre> 
+ */
+	LIBAPI GLuint (CALLBACK * disp__glGenLists )(GLsizei);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glNewList ( GLuint list , GLenum mode ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glNewList )(GLuint, GLenum);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glEndList ( void ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glEndList )(void);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glCallList ( GLuint list ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glCallList )(GLuint);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glCallLists ( GLsizei n , GLenum type , const GLvoid * lists ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glCallLists )(GLsizei, GLenum, const GLvoid *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glListBase ( GLuint base ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glListBase )(GLuint);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glBegin ( GLenum mode ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glBegin )(GLenum);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glEnd ( void ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glEnd )(void);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glVertex2d ( GLdouble x , GLdouble y ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glVertex2d )(GLdouble, GLdouble);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glVertex2f ( GLfloat x , GLfloat y ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glVertex2f )(GLfloat, GLfloat);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glVertex2i ( GLint x , GLint y ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glVertex2i )(GLint, GLint);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glVertex2s ( GLshort x , GLshort y ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glVertex2s )(GLshort, GLshort);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glVertex3d ( GLdouble x , GLdouble y , GLdouble z ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glVertex3d )(GLdouble, GLdouble, GLdouble);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glVertex3f ( GLfloat x , GLfloat y , GLfloat z ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glVertex3f )(GLfloat, GLfloat, GLfloat);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glVertex3i ( GLint x , GLint y , GLint z ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glVertex3i )(GLint, GLint, GLint);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glVertex3s ( GLshort x , GLshort y , GLshort z ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glVertex3s )(GLshort, GLshort, GLshort);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glVertex4d ( GLdouble x , GLdouble y , GLdouble z , GLdouble w ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glVertex4d )(GLdouble, GLdouble, GLdouble, GLdouble);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glVertex4f ( GLfloat x , GLfloat y , GLfloat z , GLfloat w ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glVertex4f )(GLfloat, GLfloat, GLfloat, GLfloat);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glVertex4i ( GLint x , GLint y , GLint z , GLint w ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glVertex4i )(GLint, GLint, GLint, GLint);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glVertex4s ( GLshort x , GLshort y , GLshort z , GLshort w ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glVertex4s )(GLshort, GLshort, GLshort, GLshort);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glVertex2dv ( const GLdouble * v ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glVertex2dv )(const GLdouble *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glVertex2fv ( const GLfloat * v ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glVertex2fv )(const GLfloat *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glVertex2iv ( const GLint * v ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glVertex2iv )(const GLint *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glVertex2sv ( const GLshort * v ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glVertex2sv )(const GLshort *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glVertex3dv ( const GLdouble * v ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glVertex3dv )(const GLdouble *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glVertex3fv ( const GLfloat * v ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glVertex3fv )(const GLfloat *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glVertex3iv ( const GLint * v ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glVertex3iv )(const GLint *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glVertex3sv ( const GLshort * v ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glVertex3sv )(const GLshort *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glVertex4dv ( const GLdouble * v ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glVertex4dv )(const GLdouble *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glVertex4fv ( const GLfloat * v ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glVertex4fv )(const GLfloat *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glVertex4iv ( const GLint * v ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glVertex4iv )(const GLint *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glVertex4sv ( const GLshort * v ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glVertex4sv )(const GLshort *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glNormal3b ( GLbyte nx , GLbyte ny , GLbyte nz ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glNormal3b )(GLbyte, GLbyte, GLbyte);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glNormal3d ( GLdouble nx , GLdouble ny , GLdouble nz ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glNormal3d )(GLdouble, GLdouble, GLdouble);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glNormal3f ( GLfloat nx , GLfloat ny , GLfloat nz ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glNormal3f )(GLfloat, GLfloat, GLfloat);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glNormal3i ( GLint nx , GLint ny , GLint nz ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glNormal3i )(GLint, GLint, GLint);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glNormal3s ( GLshort nx , GLshort ny , GLshort nz ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glNormal3s )(GLshort, GLshort, GLshort);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glNormal3bv ( const GLbyte * v ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glNormal3bv )(const GLbyte *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glNormal3dv ( const GLdouble * v ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glNormal3dv )(const GLdouble *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glNormal3fv ( const GLfloat * v ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glNormal3fv )(const GLfloat *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glNormal3iv ( const GLint * v ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glNormal3iv )(const GLint *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glNormal3sv ( const GLshort * v ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glNormal3sv )(const GLshort *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glIndexd ( GLdouble c ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glIndexd )(GLdouble);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glIndexf ( GLfloat c ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glIndexf )(GLfloat);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glIndexi ( GLint c ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glIndexi )(GLint);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glIndexs ( GLshort c ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glIndexs )(GLshort);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glIndexub ( GLubyte c ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glIndexub )(GLubyte);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glIndexdv ( const GLdouble * c ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glIndexdv )(const GLdouble *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glIndexfv ( const GLfloat * c ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glIndexfv )(const GLfloat *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glIndexiv ( const GLint * c ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glIndexiv )(const GLint *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glIndexsv ( const GLshort * c ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glIndexsv )(const GLshort *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glIndexubv ( const GLubyte * c ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glIndexubv )(const GLubyte *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glColor3b ( GLbyte red , GLbyte green , GLbyte blue ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glColor3b )(GLbyte, GLbyte, GLbyte);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glColor3d ( GLdouble red , GLdouble green , GLdouble blue ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glColor3d )(GLdouble, GLdouble, GLdouble);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glColor3f ( GLfloat red , GLfloat green , GLfloat blue ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glColor3f )(GLfloat, GLfloat, GLfloat);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glColor3i ( GLint red , GLint green , GLint blue ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glColor3i )(GLint, GLint, GLint);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glColor3s ( GLshort red , GLshort green , GLshort blue ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glColor3s )(GLshort, GLshort, GLshort);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glColor3ub ( GLubyte red , GLubyte green , GLubyte blue ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glColor3ub )(GLubyte, GLubyte, GLubyte);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glColor3ui ( GLuint red , GLuint green , GLuint blue ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glColor3ui )(GLuint, GLuint, GLuint);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glColor3us ( GLushort red , GLushort green , GLushort blue ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glColor3us )(GLushort, GLushort, GLushort);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glColor4b ( GLbyte red , GLbyte green , GLbyte blue , GLbyte alpha ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glColor4b )(GLbyte, GLbyte, GLbyte, GLbyte);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glColor4d ( GLdouble red , GLdouble green , GLdouble blue , GLdouble alpha ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glColor4d )(GLdouble, GLdouble, GLdouble, GLdouble);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glColor4f ( GLfloat red , GLfloat green , GLfloat blue , GLfloat alpha ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glColor4f )(GLfloat, GLfloat, GLfloat, GLfloat);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glColor4i ( GLint red , GLint green , GLint blue , GLint alpha ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glColor4i )(GLint, GLint, GLint, GLint);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glColor4s ( GLshort red , GLshort green , GLshort blue , GLshort alpha ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glColor4s )(GLshort, GLshort, GLshort, GLshort);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glColor4ub ( GLubyte red , GLubyte green , GLubyte blue , GLubyte alpha ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glColor4ub )(GLubyte, GLubyte, GLubyte, GLubyte);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glColor4ui ( GLuint red , GLuint green , GLuint blue , GLuint alpha ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glColor4ui )(GLuint, GLuint, GLuint, GLuint);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glColor4us ( GLushort red , GLushort green , GLushort blue , GLushort alpha ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glColor4us )(GLushort, GLushort, GLushort, GLushort);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glColor3bv ( const GLbyte * v ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glColor3bv )(const GLbyte *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glColor3dv ( const GLdouble * v ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glColor3dv )(const GLdouble *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glColor3fv ( const GLfloat * v ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glColor3fv )(const GLfloat *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glColor3iv ( const GLint * v ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glColor3iv )(const GLint *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glColor3sv ( const GLshort * v ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glColor3sv )(const GLshort *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glColor3ubv ( const GLubyte * v ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glColor3ubv )(const GLubyte *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glColor3uiv ( const GLuint * v ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glColor3uiv )(const GLuint *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glColor3usv ( const GLushort * v ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glColor3usv )(const GLushort *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glColor4bv ( const GLbyte * v ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glColor4bv )(const GLbyte *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glColor4dv ( const GLdouble * v ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glColor4dv )(const GLdouble *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glColor4fv ( const GLfloat * v ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glColor4fv )(const GLfloat *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glColor4iv ( const GLint * v ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glColor4iv )(const GLint *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glColor4sv ( const GLshort * v ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glColor4sv )(const GLshort *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glColor4ubv ( const GLubyte * v ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glColor4ubv )(const GLubyte *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glColor4uiv ( const GLuint * v ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glColor4uiv )(const GLuint *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glColor4usv ( const GLushort * v ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glColor4usv )(const GLushort *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glTexCoord1d ( GLdouble s ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glTexCoord1d )(GLdouble);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glTexCoord1f ( GLfloat s ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glTexCoord1f )(GLfloat);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glTexCoord1i ( GLint s ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glTexCoord1i )(GLint);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glTexCoord1s ( GLshort s ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glTexCoord1s )(GLshort);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glTexCoord2d ( GLdouble s , GLdouble t ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glTexCoord2d )(GLdouble, GLdouble);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glTexCoord2f ( GLfloat s , GLfloat t ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glTexCoord2f )(GLfloat, GLfloat);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glTexCoord2i ( GLint s , GLint t ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glTexCoord2i )(GLint, GLint);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glTexCoord2s ( GLshort s , GLshort t ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glTexCoord2s )(GLshort, GLshort);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glTexCoord3d ( GLdouble s , GLdouble t , GLdouble r ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glTexCoord3d )(GLdouble, GLdouble, GLdouble);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glTexCoord3f ( GLfloat s , GLfloat t , GLfloat r ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glTexCoord3f )(GLfloat, GLfloat, GLfloat);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glTexCoord3i ( GLint s , GLint t , GLint r ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glTexCoord3i )(GLint, GLint, GLint);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glTexCoord3s ( GLshort s , GLshort t , GLshort r ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glTexCoord3s )(GLshort, GLshort, GLshort);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glTexCoord4d ( GLdouble s , GLdouble t , GLdouble r , GLdouble q ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glTexCoord4d )(GLdouble, GLdouble, GLdouble, GLdouble);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glTexCoord4f ( GLfloat s , GLfloat t , GLfloat r , GLfloat q ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glTexCoord4f )(GLfloat, GLfloat, GLfloat, GLfloat);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glTexCoord4i ( GLint s , GLint t , GLint r , GLint q ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glTexCoord4i )(GLint, GLint, GLint, GLint);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glTexCoord4s ( GLshort s , GLshort t , GLshort r , GLshort q ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glTexCoord4s )(GLshort, GLshort, GLshort, GLshort);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glTexCoord1dv ( const GLdouble * v ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glTexCoord1dv )(const GLdouble *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glTexCoord1fv ( const GLfloat * v ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glTexCoord1fv )(const GLfloat *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glTexCoord1iv ( const GLint * v ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glTexCoord1iv )(const GLint *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glTexCoord1sv ( const GLshort * v ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glTexCoord1sv )(const GLshort *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glTexCoord2dv ( const GLdouble * v ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glTexCoord2dv )(const GLdouble *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glTexCoord2fv ( const GLfloat * v ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glTexCoord2fv )(const GLfloat *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glTexCoord2iv ( const GLint * v ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glTexCoord2iv )(const GLint *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glTexCoord2sv ( const GLshort * v ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glTexCoord2sv )(const GLshort *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glTexCoord3dv ( const GLdouble * v ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glTexCoord3dv )(const GLdouble *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glTexCoord3fv ( const GLfloat * v ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glTexCoord3fv )(const GLfloat *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glTexCoord3iv ( const GLint * v ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glTexCoord3iv )(const GLint *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glTexCoord3sv ( const GLshort * v ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glTexCoord3sv )(const GLshort *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glTexCoord4dv ( const GLdouble * v ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glTexCoord4dv )(const GLdouble *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glTexCoord4fv ( const GLfloat * v ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glTexCoord4fv )(const GLfloat *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glTexCoord4iv ( const GLint * v ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glTexCoord4iv )(const GLint *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glTexCoord4sv ( const GLshort * v ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glTexCoord4sv )(const GLshort *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glRasterPos2d ( GLdouble x , GLdouble y ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glRasterPos2d )(GLdouble, GLdouble);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glRasterPos2f ( GLfloat x , GLfloat y ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glRasterPos2f )(GLfloat, GLfloat);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glRasterPos2i ( GLint x , GLint y ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glRasterPos2i )(GLint, GLint);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glRasterPos2s ( GLshort x , GLshort y ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glRasterPos2s )(GLshort, GLshort);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glRasterPos3d ( GLdouble x , GLdouble y , GLdouble z ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glRasterPos3d )(GLdouble, GLdouble, GLdouble);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glRasterPos3f ( GLfloat x , GLfloat y , GLfloat z ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glRasterPos3f )(GLfloat, GLfloat, GLfloat);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glRasterPos3i ( GLint x , GLint y , GLint z ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glRasterPos3i )(GLint, GLint, GLint);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glRasterPos3s ( GLshort x , GLshort y , GLshort z ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glRasterPos3s )(GLshort, GLshort, GLshort);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glRasterPos4d ( GLdouble x , GLdouble y , GLdouble z , GLdouble w ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glRasterPos4d )(GLdouble, GLdouble, GLdouble, GLdouble);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glRasterPos4f ( GLfloat x , GLfloat y , GLfloat z , GLfloat w ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glRasterPos4f )(GLfloat, GLfloat, GLfloat, GLfloat);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glRasterPos4i ( GLint x , GLint y , GLint z , GLint w ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glRasterPos4i )(GLint, GLint, GLint, GLint);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glRasterPos4s ( GLshort x , GLshort y , GLshort z , GLshort w ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glRasterPos4s )(GLshort, GLshort, GLshort, GLshort);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glRasterPos2dv ( const GLdouble * v ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glRasterPos2dv )(const GLdouble *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glRasterPos2fv ( const GLfloat * v ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glRasterPos2fv )(const GLfloat *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glRasterPos2iv ( const GLint * v ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glRasterPos2iv )(const GLint *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glRasterPos2sv ( const GLshort * v ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glRasterPos2sv )(const GLshort *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glRasterPos3dv ( const GLdouble * v ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glRasterPos3dv )(const GLdouble *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glRasterPos3fv ( const GLfloat * v ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glRasterPos3fv )(const GLfloat *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glRasterPos3iv ( const GLint * v ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glRasterPos3iv )(const GLint *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glRasterPos3sv ( const GLshort * v ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glRasterPos3sv )(const GLshort *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glRasterPos4dv ( const GLdouble * v ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glRasterPos4dv )(const GLdouble *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glRasterPos4fv ( const GLfloat * v ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glRasterPos4fv )(const GLfloat *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glRasterPos4iv ( const GLint * v ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glRasterPos4iv )(const GLint *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glRasterPos4sv ( const GLshort * v ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glRasterPos4sv )(const GLshort *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glRectd ( GLdouble x1 , GLdouble y1 , GLdouble x2 , GLdouble y2 ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glRectd )(GLdouble, GLdouble, GLdouble, GLdouble);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glRectf ( GLfloat x1 , GLfloat y1 , GLfloat x2 , GLfloat y2 ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glRectf )(GLfloat, GLfloat, GLfloat, GLfloat);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glRecti ( GLint x1 , GLint y1 , GLint x2 , GLint y2 ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glRecti )(GLint, GLint, GLint, GLint);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glRects ( GLshort x1 , GLshort y1 , GLshort x2 , GLshort y2 ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glRects )(GLshort, GLshort, GLshort, GLshort);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glRectdv ( const GLdouble * v1 , const GLdouble * v2 ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glRectdv )(const GLdouble *, const GLdouble *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glRectfv ( const GLfloat * v1 , const GLfloat * v2 ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glRectfv )(const GLfloat *, const GLfloat *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glRectiv ( const GLint * v1 , const GLint * v2 ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glRectiv )(const GLint *, const GLint *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glRectsv ( const GLshort * v1 , const GLshort * v2 ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glRectsv )(const GLshort *, const GLshort *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glVertexPointer ( GLint size , GLenum type , GLsizei stride , const GLvoid * ptr ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glVertexPointer )(GLint, GLenum, GLsizei, const GLvoid *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glNormalPointer ( GLenum type , GLsizei stride , const GLvoid * ptr ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glNormalPointer )(GLenum, GLsizei, const GLvoid *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glColorPointer ( GLint size , GLenum type , GLsizei stride , const GLvoid * ptr ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glColorPointer )(GLint, GLenum, GLsizei, const GLvoid *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glIndexPointer ( GLenum type , GLsizei stride , const GLvoid * ptr ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glIndexPointer )(GLenum, GLsizei, const GLvoid *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glTexCoordPointer ( GLint size , GLenum type , GLsizei stride , const GLvoid * ptr ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glTexCoordPointer )(GLint, GLenum, GLsizei, const GLvoid *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glEdgeFlagPointer ( GLsizei stride , const GLvoid * ptr ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glEdgeFlagPointer )(GLsizei, const GLvoid *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glGetPointerv ( GLenum pname , void * * params ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glGetPointerv )(GLenum, void **);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glArrayElement ( GLint i ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glArrayElement )(GLint);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glDrawArrays ( GLenum mode , GLint first , GLsizei count ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glDrawArrays )(GLenum, GLint, GLsizei);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glDrawElements ( GLenum mode , GLsizei count , GLenum type , const GLvoid * indices ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glDrawElements )(GLenum, GLsizei, GLenum, const GLvoid *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glInterleavedArrays ( GLenum format , GLsizei stride , const GLvoid * pointer ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glInterleavedArrays )(GLenum, GLsizei, const GLvoid *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glShadeModel ( GLenum mode ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glShadeModel )(GLenum);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glLightf ( GLenum light , GLenum pname , GLfloat param ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glLightf )(GLenum, GLenum, GLfloat);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glLighti ( GLenum light , GLenum pname , GLint param ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glLighti )(GLenum, GLenum, GLint);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glLightfv ( GLenum light , GLenum pname , const GLfloat * params ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glLightfv )(GLenum, GLenum, const GLfloat *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glLightiv ( GLenum light , GLenum pname , const GLint * params ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glLightiv )(GLenum, GLenum, const GLint *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glGetLightfv ( GLenum light , GLenum pname , GLfloat * params ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glGetLightfv )(GLenum, GLenum, GLfloat *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glGetLightiv ( GLenum light , GLenum pname , GLint * params ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glGetLightiv )(GLenum, GLenum, GLint *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glLightModelf ( GLenum pname , GLfloat param ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glLightModelf )(GLenum, GLfloat);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glLightModeli ( GLenum pname , GLint param ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glLightModeli )(GLenum, GLint);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glLightModelfv ( GLenum pname , const GLfloat * params ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glLightModelfv )(GLenum, const GLfloat *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glLightModeliv ( GLenum pname , const GLint * params ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glLightModeliv )(GLenum, const GLint *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glMaterialf ( GLenum face , GLenum pname , GLfloat param ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glMaterialf )(GLenum, GLenum, GLfloat);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glMateriali ( GLenum face , GLenum pname , GLint param ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glMateriali )(GLenum, GLenum, GLint);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glMaterialfv ( GLenum face , GLenum pname , const GLfloat * params ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glMaterialfv )(GLenum, GLenum, const GLfloat *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glMaterialiv ( GLenum face , GLenum pname , const GLint * params ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glMaterialiv )(GLenum, GLenum, const GLint *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glGetMaterialfv ( GLenum face , GLenum pname , GLfloat * params ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glGetMaterialfv )(GLenum, GLenum, GLfloat *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glGetMaterialiv ( GLenum face , GLenum pname , GLint * params ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glGetMaterialiv )(GLenum, GLenum, GLint *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glColorMaterial ( GLenum face , GLenum mode ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glColorMaterial )(GLenum, GLenum);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glPixelZoom ( GLfloat xfactor , GLfloat yfactor ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glPixelZoom )(GLfloat, GLfloat);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glPixelStoref ( GLenum pname , GLfloat param ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glPixelStoref )(GLenum, GLfloat);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glPixelStorei ( GLenum pname , GLint param ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glPixelStorei )(GLenum, GLint);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glPixelTransferf ( GLenum pname , GLfloat param ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glPixelTransferf )(GLenum, GLfloat);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glPixelTransferi ( GLenum pname , GLint param ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glPixelTransferi )(GLenum, GLint);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glPixelMapfv ( GLenum map , GLint mapsize , const GLfloat * values ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glPixelMapfv )(GLenum, GLint, const GLfloat *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glPixelMapuiv ( GLenum map , GLint mapsize , const GLuint * values ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glPixelMapuiv )(GLenum, GLint, const GLuint *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glPixelMapusv ( GLenum map , GLint mapsize , const GLushort * values ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glPixelMapusv )(GLenum, GLint, const GLushort *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glGetPixelMapfv ( GLenum map , GLfloat * values ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glGetPixelMapfv )(GLenum, GLfloat *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glGetPixelMapuiv ( GLenum map , GLuint * values ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glGetPixelMapuiv )(GLenum, GLuint *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glGetPixelMapusv ( GLenum map , GLushort * values ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glGetPixelMapusv )(GLenum, GLushort *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glBitmap ( GLsizei width , GLsizei height , GLfloat xorig , GLfloat yorig , GLfloat xmove , GLfloat ymove , const GLubyte * bitmap ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glBitmap )(GLsizei, GLsizei, GLfloat, GLfloat, GLfloat, GLfloat, const GLubyte *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glReadPixels ( GLint x , GLint y , GLsizei width , GLsizei height , GLenum format , GLenum type , GLvoid * pixels ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glReadPixels )(GLint, GLint, GLsizei, GLsizei, GLenum, GLenum, GLvoid *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glDrawPixels ( GLsizei width , GLsizei height , GLenum format , GLenum type , const GLvoid * pixels ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glDrawPixels )(GLsizei, GLsizei, GLenum, GLenum, const GLvoid *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glCopyPixels ( GLint x , GLint y , GLsizei width , GLsizei height , GLenum type ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glCopyPixels )(GLint, GLint, GLsizei, GLsizei, GLenum);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glStencilFunc ( GLenum func , GLint ref , GLuint mask ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glStencilFunc )(GLenum, GLint, GLuint);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glStencilMask ( GLuint mask ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glStencilMask )(GLuint);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glStencilOp ( GLenum fail , GLenum zfail , GLenum zpass ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glStencilOp )(GLenum, GLenum, GLenum);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glClearStencil ( GLint s ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glClearStencil )(GLint);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glTexGend ( GLenum coord , GLenum pname , GLdouble param ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glTexGend )(GLenum, GLenum, GLdouble);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glTexGenf ( GLenum coord , GLenum pname , GLfloat param ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glTexGenf )(GLenum, GLenum, GLfloat);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glTexGeni ( GLenum coord , GLenum pname , GLint param ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glTexGeni )(GLenum, GLenum, GLint);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glTexGendv ( GLenum coord , GLenum pname , const GLdouble * params ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glTexGendv )(GLenum, GLenum, const GLdouble *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glTexGenfv ( GLenum coord , GLenum pname , const GLfloat * params ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glTexGenfv )(GLenum, GLenum, const GLfloat *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glTexGeniv ( GLenum coord , GLenum pname , const GLint * params ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glTexGeniv )(GLenum, GLenum, const GLint *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glGetTexGendv ( GLenum coord , GLenum pname , GLdouble * params ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glGetTexGendv )(GLenum, GLenum, GLdouble *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glGetTexGenfv ( GLenum coord , GLenum pname , GLfloat * params ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glGetTexGenfv )(GLenum, GLenum, GLfloat *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glGetTexGeniv ( GLenum coord , GLenum pname , GLint * params ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glGetTexGeniv )(GLenum, GLenum, GLint *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glTexEnvf ( GLenum target , GLenum pname , GLfloat param ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glTexEnvf )(GLenum, GLenum, GLfloat);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glTexEnvi ( GLenum target , GLenum pname , GLint param ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glTexEnvi )(GLenum, GLenum, GLint);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glTexEnvfv ( GLenum target , GLenum pname , const GLfloat * params ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glTexEnvfv )(GLenum, GLenum, const GLfloat *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glTexEnviv ( GLenum target , GLenum pname , const GLint * params ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glTexEnviv )(GLenum, GLenum, const GLint *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glGetTexEnvfv ( GLenum target , GLenum pname , GLfloat * params ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glGetTexEnvfv )(GLenum, GLenum, GLfloat *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glGetTexEnviv ( GLenum target , GLenum pname , GLint * params ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glGetTexEnviv )(GLenum, GLenum, GLint *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glTexParameterf ( GLenum target , GLenum pname , GLfloat param ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glTexParameterf )(GLenum, GLenum, GLfloat);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glTexParameteri ( GLenum target , GLenum pname , GLint param ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glTexParameteri )(GLenum, GLenum, GLint);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glTexParameterfv ( GLenum target , GLenum pname , const GLfloat * params ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glTexParameterfv )(GLenum, GLenum, const GLfloat *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glTexParameteriv ( GLenum target , GLenum pname , const GLint * params ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glTexParameteriv )(GLenum, GLenum, const GLint *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glGetTexParameterfv ( GLenum target , GLenum pname , GLfloat * params ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glGetTexParameterfv )(GLenum, GLenum, GLfloat *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glGetTexParameteriv ( GLenum target , GLenum pname , GLint * params ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glGetTexParameteriv )(GLenum, GLenum, GLint *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glGetTexLevelParameterfv ( GLenum target , GLint level , GLenum pname , GLfloat * params ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glGetTexLevelParameterfv )(GLenum, GLint, GLenum, GLfloat *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glGetTexLevelParameteriv ( GLenum target , GLint level , GLenum pname , GLint * params ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glGetTexLevelParameteriv )(GLenum, GLint, GLenum, GLint *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glTexImage1D ( GLenum target , GLint level , GLint internalFormat , GLsizei width , GLint border , GLenum format , GLenum type , const GLvoid * pixels ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glTexImage1D )(GLenum, GLint, GLint, GLsizei, GLint, GLenum, GLenum, const GLvoid *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glTexImage2D ( GLenum target , GLint level , GLint internalFormat , GLsizei width , GLsizei height , GLint border , GLenum format , GLenum type , const GLvoid * pixels ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glTexImage2D )(GLenum, GLint, GLint, GLsizei, GLsizei, GLint, GLenum, GLenum, const GLvoid *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glGetTexImage ( GLenum target , GLint level , GLenum format , GLenum type , GLvoid * pixels ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glGetTexImage )(GLenum, GLint, GLenum, GLenum, GLvoid *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glGenTextures ( GLsizei n , GLuint * textures ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glGenTextures )(GLsizei, GLuint *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glDeleteTextures ( GLsizei n , const GLuint * textures ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glDeleteTextures )(GLsizei, const GLuint *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glBindTexture ( GLenum target , GLuint texture ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glBindTexture )(GLenum, GLuint);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glPrioritizeTextures ( GLsizei n , const GLuint * textures , const GLclampf * priorities ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glPrioritizeTextures )(GLsizei, const GLuint *, const GLclampf *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern GLboolean glAreTexturesResident ( GLsizei n , const GLuint * textures , GLboolean * residences ) ;
+ * </pre> 
+ */
+	LIBAPI GLboolean (CALLBACK * disp__glAreTexturesResident )(GLsizei, const GLuint *, GLboolean *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern GLboolean glIsTexture ( GLuint texture ) ;
+ * </pre> 
+ */
+	LIBAPI GLboolean (CALLBACK * disp__glIsTexture )(GLuint);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glTexSubImage1D ( GLenum target , GLint level , GLint xoffset , GLsizei width , GLenum format , GLenum type , const GLvoid * pixels ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glTexSubImage1D )(GLenum, GLint, GLint, GLsizei, GLenum, GLenum, const GLvoid *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glTexSubImage2D ( GLenum target , GLint level , GLint xoffset , GLint yoffset , GLsizei width , GLsizei height , GLenum format , GLenum type , const GLvoid * pixels ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glTexSubImage2D )(GLenum, GLint, GLint, GLint, GLsizei, GLsizei, GLenum, GLenum, const GLvoid *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glCopyTexImage1D ( GLenum target , GLint level , GLenum internalformat , GLint x , GLint y , GLsizei width , GLint border ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glCopyTexImage1D )(GLenum, GLint, GLenum, GLint, GLint, GLsizei, GLint);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glCopyTexImage2D ( GLenum target , GLint level , GLenum internalformat , GLint x , GLint y , GLsizei width , GLsizei height , GLint border ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glCopyTexImage2D )(GLenum, GLint, GLenum, GLint, GLint, GLsizei, GLsizei, GLint);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glCopyTexSubImage1D ( GLenum target , GLint level , GLint xoffset , GLint x , GLint y , GLsizei width ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glCopyTexSubImage1D )(GLenum, GLint, GLint, GLint, GLint, GLsizei);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glCopyTexSubImage2D ( GLenum target , GLint level , GLint xoffset , GLint yoffset , GLint x , GLint y , GLsizei width , GLsizei height ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glCopyTexSubImage2D )(GLenum, GLint, GLint, GLint, GLint, GLint, GLsizei, GLsizei);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glMap1d ( GLenum target , GLdouble u1 , GLdouble u2 , GLint stride , GLint order , const GLdouble * points ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glMap1d )(GLenum, GLdouble, GLdouble, GLint, GLint, const GLdouble *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glMap1f ( GLenum target , GLfloat u1 , GLfloat u2 , GLint stride , GLint order , const GLfloat * points ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glMap1f )(GLenum, GLfloat, GLfloat, GLint, GLint, const GLfloat *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glMap2d ( GLenum target , GLdouble u1 , GLdouble u2 , GLint ustride , GLint uorder , GLdouble v1 , GLdouble v2 , GLint vstride , GLint vorder , const GLdouble * points ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glMap2d )(GLenum, GLdouble, GLdouble, GLint, GLint, GLdouble, GLdouble, GLint, GLint, const GLdouble *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glMap2f ( GLenum target , GLfloat u1 , GLfloat u2 , GLint ustride , GLint uorder , GLfloat v1 , GLfloat v2 , GLint vstride , GLint vorder , const GLfloat * points ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glMap2f )(GLenum, GLfloat, GLfloat, GLint, GLint, GLfloat, GLfloat, GLint, GLint, const GLfloat *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glGetMapdv ( GLenum target , GLenum query , GLdouble * v ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glGetMapdv )(GLenum, GLenum, GLdouble *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glGetMapfv ( GLenum target , GLenum query , GLfloat * v ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glGetMapfv )(GLenum, GLenum, GLfloat *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glGetMapiv ( GLenum target , GLenum query , GLint * v ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glGetMapiv )(GLenum, GLenum, GLint *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glEvalCoord1d ( GLdouble u ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glEvalCoord1d )(GLdouble);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glEvalCoord1f ( GLfloat u ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glEvalCoord1f )(GLfloat);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glEvalCoord1dv ( const GLdouble * u ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glEvalCoord1dv )(const GLdouble *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glEvalCoord1fv ( const GLfloat * u ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glEvalCoord1fv )(const GLfloat *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glEvalCoord2d ( GLdouble u , GLdouble v ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glEvalCoord2d )(GLdouble, GLdouble);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glEvalCoord2f ( GLfloat u , GLfloat v ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glEvalCoord2f )(GLfloat, GLfloat);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glEvalCoord2dv ( const GLdouble * u ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glEvalCoord2dv )(const GLdouble *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glEvalCoord2fv ( const GLfloat * u ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glEvalCoord2fv )(const GLfloat *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glMapGrid1d ( GLint un , GLdouble u1 , GLdouble u2 ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glMapGrid1d )(GLint, GLdouble, GLdouble);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glMapGrid1f ( GLint un , GLfloat u1 , GLfloat u2 ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glMapGrid1f )(GLint, GLfloat, GLfloat);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glMapGrid2d ( GLint un , GLdouble u1 , GLdouble u2 , GLint vn , GLdouble v1 , GLdouble v2 ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glMapGrid2d )(GLint, GLdouble, GLdouble, GLint, GLdouble, GLdouble);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glMapGrid2f ( GLint un , GLfloat u1 , GLfloat u2 , GLint vn , GLfloat v1 , GLfloat v2 ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glMapGrid2f )(GLint, GLfloat, GLfloat, GLint, GLfloat, GLfloat);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glEvalPoint1 ( GLint i ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glEvalPoint1 )(GLint);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glEvalPoint2 ( GLint i , GLint j ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glEvalPoint2 )(GLint, GLint);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glEvalMesh1 ( GLenum mode , GLint i1 , GLint i2 ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glEvalMesh1 )(GLenum, GLint, GLint);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glEvalMesh2 ( GLenum mode , GLint i1 , GLint i2 , GLint j1 , GLint j2 ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glEvalMesh2 )(GLenum, GLint, GLint, GLint, GLint);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glFogf ( GLenum pname , GLfloat param ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glFogf )(GLenum, GLfloat);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glFogi ( GLenum pname , GLint param ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glFogi )(GLenum, GLint);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glFogfv ( GLenum pname , const GLfloat * params ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glFogfv )(GLenum, const GLfloat *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glFogiv ( GLenum pname , const GLint * params ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glFogiv )(GLenum, const GLint *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glFeedbackBuffer ( GLsizei size , GLenum type , GLfloat * buffer ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glFeedbackBuffer )(GLsizei, GLenum, GLfloat *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glPassThrough ( GLfloat token ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glPassThrough )(GLfloat);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glSelectBuffer ( GLsizei size , GLuint * buffer ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glSelectBuffer )(GLsizei, GLuint *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glInitNames ( void ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glInitNames )(void);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glLoadName ( GLuint name ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glLoadName )(GLuint);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glPushName ( GLuint name ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glPushName )(GLuint);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glPopName ( void ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glPopName )(void);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glDrawRangeElements ( GLenum mode , GLuint start , GLuint end , GLsizei count , GLenum type , const GLvoid * indices ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glDrawRangeElements )(GLenum, GLuint, GLuint, GLsizei, GLenum, const GLvoid *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glTexImage3D ( GLenum target , GLint level , GLint internalFormat , GLsizei width , GLsizei height , GLsizei depth , GLint border , GLenum format , GLenum type , const GLvoid * pixels ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glTexImage3D )(GLenum, GLint, GLint, GLsizei, GLsizei, GLsizei, GLint, GLenum, GLenum, const GLvoid *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glTexSubImage3D ( GLenum target , GLint level , GLint xoffset , GLint yoffset , GLint zoffset , GLsizei width , GLsizei height , GLsizei depth , GLenum format , GLenum type , const GLvoid * pixels ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glTexSubImage3D )(GLenum, GLint, GLint, GLint, GLint, GLsizei, GLsizei, GLsizei, GLenum, GLenum, const GLvoid *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glCopyTexSubImage3D ( GLenum target , GLint level , GLint xoffset , GLint yoffset , GLint zoffset , GLint x , GLint y , GLsizei width , GLsizei height ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glCopyTexSubImage3D )(GLenum, GLint, GLint, GLint, GLint, GLint, GLint, GLsizei, GLsizei);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glColorTable ( GLenum target , GLenum internalformat , GLsizei width , GLenum format , GLenum type , const GLvoid * table ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glColorTable )(GLenum, GLenum, GLsizei, GLenum, GLenum, const GLvoid *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glColorSubTable ( GLenum target , GLsizei start , GLsizei count , GLenum format , GLenum type , const GLvoid * data ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glColorSubTable )(GLenum, GLsizei, GLsizei, GLenum, GLenum, const GLvoid *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glColorTableParameteriv ( GLenum target , GLenum pname , const GLint * params ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glColorTableParameteriv )(GLenum, GLenum, const GLint *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glColorTableParameterfv ( GLenum target , GLenum pname , const GLfloat * params ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glColorTableParameterfv )(GLenum, GLenum, const GLfloat *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glCopyColorSubTable ( GLenum target , GLsizei start , GLint x , GLint y , GLsizei width ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glCopyColorSubTable )(GLenum, GLsizei, GLint, GLint, GLsizei);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glCopyColorTable ( GLenum target , GLenum internalformat , GLint x , GLint y , GLsizei width ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glCopyColorTable )(GLenum, GLenum, GLint, GLint, GLsizei);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glGetColorTable ( GLenum target , GLenum format , GLenum type , GLvoid * table ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glGetColorTable )(GLenum, GLenum, GLenum, GLvoid *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glGetColorTableParameterfv ( GLenum target , GLenum pname , GLfloat * params ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glGetColorTableParameterfv )(GLenum, GLenum, GLfloat *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glGetColorTableParameteriv ( GLenum target , GLenum pname , GLint * params ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glGetColorTableParameteriv )(GLenum, GLenum, GLint *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glBlendEquation ( GLenum mode ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glBlendEquation )(GLenum);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glBlendColor ( GLclampf red , GLclampf green , GLclampf blue , GLclampf alpha ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glBlendColor )(GLclampf, GLclampf, GLclampf, GLclampf);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glHistogram ( GLenum target , GLsizei width , GLenum internalformat , GLboolean sink ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glHistogram )(GLenum, GLsizei, GLenum, GLboolean);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glResetHistogram ( GLenum target ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glResetHistogram )(GLenum);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glGetHistogram ( GLenum target , GLboolean reset , GLenum format , GLenum type , GLvoid * values ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glGetHistogram )(GLenum, GLboolean, GLenum, GLenum, GLvoid *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glGetHistogramParameterfv ( GLenum target , GLenum pname , GLfloat * params ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glGetHistogramParameterfv )(GLenum, GLenum, GLfloat *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glGetHistogramParameteriv ( GLenum target , GLenum pname , GLint * params ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glGetHistogramParameteriv )(GLenum, GLenum, GLint *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glMinmax ( GLenum target , GLenum internalformat , GLboolean sink ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glMinmax )(GLenum, GLenum, GLboolean);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glResetMinmax ( GLenum target ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glResetMinmax )(GLenum);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glGetMinmax ( GLenum target , GLboolean reset , GLenum format , GLenum types , GLvoid * values ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glGetMinmax )(GLenum, GLboolean, GLenum, GLenum, GLvoid *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glGetMinmaxParameterfv ( GLenum target , GLenum pname , GLfloat * params ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glGetMinmaxParameterfv )(GLenum, GLenum, GLfloat *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glGetMinmaxParameteriv ( GLenum target , GLenum pname , GLint * params ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glGetMinmaxParameteriv )(GLenum, GLenum, GLint *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glConvolutionFilter1D ( GLenum target , GLenum internalformat , GLsizei width , GLenum format , GLenum type , const GLvoid * image ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glConvolutionFilter1D )(GLenum, GLenum, GLsizei, GLenum, GLenum, const GLvoid *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glConvolutionFilter2D ( GLenum target , GLenum internalformat , GLsizei width , GLsizei height , GLenum format , GLenum type , const GLvoid * image ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glConvolutionFilter2D )(GLenum, GLenum, GLsizei, GLsizei, GLenum, GLenum, const GLvoid *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glConvolutionParameterf ( GLenum target , GLenum pname , GLfloat params ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glConvolutionParameterf )(GLenum, GLenum, GLfloat);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glConvolutionParameterfv ( GLenum target , GLenum pname , const GLfloat * params ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glConvolutionParameterfv )(GLenum, GLenum, const GLfloat *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glConvolutionParameteri ( GLenum target , GLenum pname , GLint params ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glConvolutionParameteri )(GLenum, GLenum, GLint);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glConvolutionParameteriv ( GLenum target , GLenum pname , const GLint * params ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glConvolutionParameteriv )(GLenum, GLenum, const GLint *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glCopyConvolutionFilter1D ( GLenum target , GLenum internalformat , GLint x , GLint y , GLsizei width ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glCopyConvolutionFilter1D )(GLenum, GLenum, GLint, GLint, GLsizei);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glCopyConvolutionFilter2D ( GLenum target , GLenum internalformat , GLint x , GLint y , GLsizei width , GLsizei height ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glCopyConvolutionFilter2D )(GLenum, GLenum, GLint, GLint, GLsizei, GLsizei);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glGetConvolutionFilter ( GLenum target , GLenum format , GLenum type , GLvoid * image ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glGetConvolutionFilter )(GLenum, GLenum, GLenum, GLvoid *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glGetConvolutionParameterfv ( GLenum target , GLenum pname , GLfloat * params ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glGetConvolutionParameterfv )(GLenum, GLenum, GLfloat *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glGetConvolutionParameteriv ( GLenum target , GLenum pname , GLint * params ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glGetConvolutionParameteriv )(GLenum, GLenum, GLint *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glSeparableFilter2D ( GLenum target , GLenum internalformat , GLsizei width , GLsizei height , GLenum format , GLenum type , const GLvoid * row , const GLvoid * column ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glSeparableFilter2D )(GLenum, GLenum, GLsizei, GLsizei, GLenum, GLenum, const GLvoid *, const GLvoid *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glGetSeparableFilter ( GLenum target , GLenum format , GLenum type , GLvoid * row , GLvoid * column , GLvoid * span ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glGetSeparableFilter )(GLenum, GLenum, GLenum, GLvoid *, GLvoid *, GLvoid *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glBlendColorEXT ( GLclampf red , GLclampf green , GLclampf blue , GLclampf alpha ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glBlendColorEXT )(GLclampf, GLclampf, GLclampf, GLclampf);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glPolygonOffsetEXT ( GLfloat factor , GLfloat bias ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glPolygonOffsetEXT )(GLfloat, GLfloat);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glTexImage3DEXT ( GLenum target , GLint level , GLenum internalFormat , GLsizei width , GLsizei height , GLsizei depth , GLint border , GLenum format , GLenum type , const GLvoid * pixels ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glTexImage3DEXT )(GLenum, GLint, GLenum, GLsizei, GLsizei, GLsizei, GLint, GLenum, GLenum, const GLvoid *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glTexSubImage3DEXT ( GLenum target , GLint level , GLint xoffset , GLint yoffset , GLint zoffset , GLsizei width , GLsizei height , GLsizei depth , GLenum format , GLenum type , const GLvoid * pixels ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glTexSubImage3DEXT )(GLenum, GLint, GLint, GLint, GLint, GLsizei, GLsizei, GLsizei, GLenum, GLenum, const GLvoid *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glCopyTexSubImage3DEXT ( GLenum target , GLint level , GLint xoffset , GLint yoffset , GLint zoffset , GLint x , GLint y , GLsizei width , GLsizei height ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glCopyTexSubImage3DEXT )(GLenum, GLint, GLint, GLint, GLint, GLint, GLint, GLsizei, GLsizei);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glGenTexturesEXT ( GLsizei n , GLuint * textures ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glGenTexturesEXT )(GLsizei, GLuint *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glDeleteTexturesEXT ( GLsizei n , const GLuint * textures ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glDeleteTexturesEXT )(GLsizei, const GLuint *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glBindTextureEXT ( GLenum target , GLuint texture ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glBindTextureEXT )(GLenum, GLuint);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glPrioritizeTexturesEXT ( GLsizei n , const GLuint * textures , const GLclampf * priorities ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glPrioritizeTexturesEXT )(GLsizei, const GLuint *, const GLclampf *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern GLboolean glAreTexturesResidentEXT ( GLsizei n , const GLuint * textures , GLboolean * residences ) ;
+ * </pre> 
+ */
+	LIBAPI GLboolean (CALLBACK * disp__glAreTexturesResidentEXT )(GLsizei, const GLuint *, GLboolean *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern GLboolean glIsTextureEXT ( GLuint texture ) ;
+ * </pre> 
+ */
+	LIBAPI GLboolean (CALLBACK * disp__glIsTextureEXT )(GLuint);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glVertexPointerEXT ( GLint size , GLenum type , GLsizei stride , GLsizei count , const GLvoid * ptr ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glVertexPointerEXT )(GLint, GLenum, GLsizei, GLsizei, const GLvoid *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glNormalPointerEXT ( GLenum type , GLsizei stride , GLsizei count , const GLvoid * ptr ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glNormalPointerEXT )(GLenum, GLsizei, GLsizei, const GLvoid *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glColorPointerEXT ( GLint size , GLenum type , GLsizei stride , GLsizei count , const GLvoid * ptr ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glColorPointerEXT )(GLint, GLenum, GLsizei, GLsizei, const GLvoid *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glIndexPointerEXT ( GLenum type , GLsizei stride , GLsizei count , const GLvoid * ptr ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glIndexPointerEXT )(GLenum, GLsizei, GLsizei, const GLvoid *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glTexCoordPointerEXT ( GLint size , GLenum type , GLsizei stride , GLsizei count , const GLvoid * ptr ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glTexCoordPointerEXT )(GLint, GLenum, GLsizei, GLsizei, const GLvoid *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glEdgeFlagPointerEXT ( GLsizei stride , GLsizei count , const GLboolean * ptr ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glEdgeFlagPointerEXT )(GLsizei, GLsizei, const GLboolean *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glGetPointervEXT ( GLenum pname , void * * params ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glGetPointervEXT )(GLenum, void **);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glArrayElementEXT ( GLint i ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glArrayElementEXT )(GLint);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glDrawArraysEXT ( GLenum mode , GLint first , GLsizei count ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glDrawArraysEXT )(GLenum, GLint, GLsizei);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glBlendEquationEXT ( GLenum mode ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glBlendEquationEXT )(GLenum);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glPointParameterfEXT ( GLenum pname , GLfloat param ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glPointParameterfEXT )(GLenum, GLfloat);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glPointParameterfvEXT ( GLenum pname , const GLfloat * params ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glPointParameterfvEXT )(GLenum, const GLfloat *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glColorTableEXT ( GLenum target , GLenum internalformat , GLsizei width , GLenum format , GLenum type , const GLvoid * table ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glColorTableEXT )(GLenum, GLenum, GLsizei, GLenum, GLenum, const GLvoid *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glColorSubTableEXT ( GLenum target , GLsizei start , GLsizei count , GLenum format , GLenum type , const GLvoid * data ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glColorSubTableEXT )(GLenum, GLsizei, GLsizei, GLenum, GLenum, const GLvoid *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glGetColorTableEXT ( GLenum target , GLenum format , GLenum type , GLvoid * table ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glGetColorTableEXT )(GLenum, GLenum, GLenum, GLvoid *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glGetColorTableParameterfvEXT ( GLenum target , GLenum pname , GLfloat * params ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glGetColorTableParameterfvEXT )(GLenum, GLenum, GLfloat *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glGetColorTableParameterivEXT ( GLenum target , GLenum pname , GLint * params ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glGetColorTableParameterivEXT )(GLenum, GLenum, GLint *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glLockArraysEXT ( GLint first , GLsizei count ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glLockArraysEXT )(GLint, GLsizei);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glUnlockArraysEXT ( void ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glUnlockArraysEXT )(void);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glActiveTextureARB ( GLenum texture ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glActiveTextureARB )(GLenum);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glClientActiveTextureARB ( GLenum texture ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glClientActiveTextureARB )(GLenum);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glMultiTexCoord1dARB ( GLenum target , GLdouble s ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glMultiTexCoord1dARB )(GLenum, GLdouble);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glMultiTexCoord1dvARB ( GLenum target , const GLdouble * v ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glMultiTexCoord1dvARB )(GLenum, const GLdouble *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glMultiTexCoord1fARB ( GLenum target , GLfloat s ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glMultiTexCoord1fARB )(GLenum, GLfloat);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glMultiTexCoord1fvARB ( GLenum target , const GLfloat * v ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glMultiTexCoord1fvARB )(GLenum, const GLfloat *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glMultiTexCoord1iARB ( GLenum target , GLint s ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glMultiTexCoord1iARB )(GLenum, GLint);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glMultiTexCoord1ivARB ( GLenum target , const GLint * v ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glMultiTexCoord1ivARB )(GLenum, const GLint *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glMultiTexCoord1sARB ( GLenum target , GLshort s ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glMultiTexCoord1sARB )(GLenum, GLshort);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glMultiTexCoord1svARB ( GLenum target , const GLshort * v ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glMultiTexCoord1svARB )(GLenum, const GLshort *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glMultiTexCoord2dARB ( GLenum target , GLdouble s , GLdouble t ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glMultiTexCoord2dARB )(GLenum, GLdouble, GLdouble);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glMultiTexCoord2dvARB ( GLenum target , const GLdouble * v ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glMultiTexCoord2dvARB )(GLenum, const GLdouble *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glMultiTexCoord2fARB ( GLenum target , GLfloat s , GLfloat t ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glMultiTexCoord2fARB )(GLenum, GLfloat, GLfloat);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glMultiTexCoord2fvARB ( GLenum target , const GLfloat * v ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glMultiTexCoord2fvARB )(GLenum, const GLfloat *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glMultiTexCoord2iARB ( GLenum target , GLint s , GLint t ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glMultiTexCoord2iARB )(GLenum, GLint, GLint);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glMultiTexCoord2ivARB ( GLenum target , const GLint * v ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glMultiTexCoord2ivARB )(GLenum, const GLint *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glMultiTexCoord2sARB ( GLenum target , GLshort s , GLshort t ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glMultiTexCoord2sARB )(GLenum, GLshort, GLshort);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glMultiTexCoord2svARB ( GLenum target , const GLshort * v ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glMultiTexCoord2svARB )(GLenum, const GLshort *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glMultiTexCoord3dARB ( GLenum target , GLdouble s , GLdouble t , GLdouble r ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glMultiTexCoord3dARB )(GLenum, GLdouble, GLdouble, GLdouble);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glMultiTexCoord3dvARB ( GLenum target , const GLdouble * v ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glMultiTexCoord3dvARB )(GLenum, const GLdouble *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glMultiTexCoord3fARB ( GLenum target , GLfloat s , GLfloat t , GLfloat r ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glMultiTexCoord3fARB )(GLenum, GLfloat, GLfloat, GLfloat);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glMultiTexCoord3fvARB ( GLenum target , const GLfloat * v ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glMultiTexCoord3fvARB )(GLenum, const GLfloat *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glMultiTexCoord3iARB ( GLenum target , GLint s , GLint t , GLint r ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glMultiTexCoord3iARB )(GLenum, GLint, GLint, GLint);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glMultiTexCoord3ivARB ( GLenum target , const GLint * v ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glMultiTexCoord3ivARB )(GLenum, const GLint *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glMultiTexCoord3sARB ( GLenum target , GLshort s , GLshort t , GLshort r ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glMultiTexCoord3sARB )(GLenum, GLshort, GLshort, GLshort);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glMultiTexCoord3svARB ( GLenum target , const GLshort * v ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glMultiTexCoord3svARB )(GLenum, const GLshort *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glMultiTexCoord4dARB ( GLenum target , GLdouble s , GLdouble t , GLdouble r , GLdouble q ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glMultiTexCoord4dARB )(GLenum, GLdouble, GLdouble, GLdouble, GLdouble);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glMultiTexCoord4dvARB ( GLenum target , const GLdouble * v ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glMultiTexCoord4dvARB )(GLenum, const GLdouble *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glMultiTexCoord4fARB ( GLenum target , GLfloat s , GLfloat t , GLfloat r , GLfloat q ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glMultiTexCoord4fARB )(GLenum, GLfloat, GLfloat, GLfloat, GLfloat);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glMultiTexCoord4fvARB ( GLenum target , const GLfloat * v ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glMultiTexCoord4fvARB )(GLenum, const GLfloat *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glMultiTexCoord4iARB ( GLenum target , GLint s , GLint t , GLint r , GLint q ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glMultiTexCoord4iARB )(GLenum, GLint, GLint, GLint, GLint);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glMultiTexCoord4ivARB ( GLenum target , const GLint * v ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glMultiTexCoord4ivARB )(GLenum, const GLint *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glMultiTexCoord4sARB ( GLenum target , GLshort s , GLshort t , GLshort r , GLshort q ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glMultiTexCoord4sARB )(GLenum, GLshort, GLshort, GLshort, GLshort);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void glMultiTexCoord4svARB ( GLenum target , const GLshort * v ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__glMultiTexCoord4svARB )(GLenum, const GLshort *);
+
+/* C2J Parser Version 2.0:  Java program parsed successfully. */ 
diff --git a/src/unix/video-drivers/gl-disp-var.hc b/src/unix/video-drivers/gl-disp-var.hc
new file mode 100644
index 0000000..9b732fe
--- /dev/null
+++ b/src/unix/video-drivers/gl-disp-var.hc
@@ -0,0 +1,889 @@
+/* WARNING ! WARNING *** THIS FILE IS GENERATED BY C2J !!!
+
+   DO NOT MAKE ANY CHANGES *** MAKE CHANGES IN THE SKELETON FILES !!!
+*/
+
+
+	const GLubyte *(CALLBACK * disp__glGetString )( GLenum name ) = NULL;
+/**
+ * C2J Parser Version 2.0
+ * Jausoft - Sven Goethel Software Development
+ * Reading from file: gl-proto-auto.orig.h . . .
+ * Destination-Class: gl4java_GLUFuncJauJNI ! 
+ */
+
+	void (CALLBACK * disp__glClearIndex )(GLfloat) = NULL;
+
+	void (CALLBACK * disp__glClearColor )(GLclampf, GLclampf, GLclampf, GLclampf) = NULL;
+
+	void (CALLBACK * disp__glClear )(GLbitfield) = NULL;
+
+	void (CALLBACK * disp__glIndexMask )(GLuint) = NULL;
+
+	void (CALLBACK * disp__glColorMask )(GLboolean, GLboolean, GLboolean, GLboolean) = NULL;
+
+	void (CALLBACK * disp__glAlphaFunc )(GLenum, GLclampf) = NULL;
+
+	void (CALLBACK * disp__glBlendFunc )(GLenum, GLenum) = NULL;
+
+	void (CALLBACK * disp__glLogicOp )(GLenum) = NULL;
+
+	void (CALLBACK * disp__glCullFace )(GLenum) = NULL;
+
+	void (CALLBACK * disp__glFrontFace )(GLenum) = NULL;
+
+	void (CALLBACK * disp__glPointSize )(GLfloat) = NULL;
+
+	void (CALLBACK * disp__glLineWidth )(GLfloat) = NULL;
+
+	void (CALLBACK * disp__glLineStipple )(GLint, GLushort) = NULL;
+
+	void (CALLBACK * disp__glPolygonMode )(GLenum, GLenum) = NULL;
+
+	void (CALLBACK * disp__glPolygonOffset )(GLfloat, GLfloat) = NULL;
+
+	void (CALLBACK * disp__glPolygonStipple )(const GLubyte *) = NULL;
+
+	void (CALLBACK * disp__glGetPolygonStipple )(GLubyte *) = NULL;
+
+	void (CALLBACK * disp__glEdgeFlag )(GLboolean) = NULL;
+
+	void (CALLBACK * disp__glEdgeFlagv )(const GLboolean *) = NULL;
+
+	void (CALLBACK * disp__glScissor )(GLint, GLint, GLsizei, GLsizei) = NULL;
+
+	void (CALLBACK * disp__glClipPlane )(GLenum, const GLdouble *) = NULL;
+
+	void (CALLBACK * disp__glGetClipPlane )(GLenum, GLdouble *) = NULL;
+
+	void (CALLBACK * disp__glDrawBuffer )(GLenum) = NULL;
+
+	void (CALLBACK * disp__glReadBuffer )(GLenum) = NULL;
+
+	void (CALLBACK * disp__glEnable )(GLenum) = NULL;
+
+	void (CALLBACK * disp__glDisable )(GLenum) = NULL;
+
+	GLboolean (CALLBACK * disp__glIsEnabled )(GLenum) = NULL;
+
+	void (CALLBACK * disp__glEnableClientState )(GLenum) = NULL;
+
+	void (CALLBACK * disp__glDisableClientState )(GLenum) = NULL;
+
+	void (CALLBACK * disp__glGetBooleanv )(GLenum, GLboolean *) = NULL;
+
+	void (CALLBACK * disp__glGetDoublev )(GLenum, GLdouble *) = NULL;
+
+	void (CALLBACK * disp__glGetFloatv )(GLenum, GLfloat *) = NULL;
+
+	void (CALLBACK * disp__glGetIntegerv )(GLenum, GLint *) = NULL;
+
+	void (CALLBACK * disp__glPushAttrib )(GLbitfield) = NULL;
+
+	void (CALLBACK * disp__glPopAttrib )(void) = NULL;
+
+	void (CALLBACK * disp__glPushClientAttrib )(GLbitfield) = NULL;
+
+	void (CALLBACK * disp__glPopClientAttrib )(void) = NULL;
+
+	GLint (CALLBACK * disp__glRenderMode )(GLenum) = NULL;
+
+	GLenum (CALLBACK * disp__glGetError )(void) = NULL;
+
+	void (CALLBACK * disp__glFinish )(void) = NULL;
+
+	void (CALLBACK * disp__glFlush )(void) = NULL;
+
+	void (CALLBACK * disp__glHint )(GLenum, GLenum) = NULL;
+
+	void (CALLBACK * disp__glClearDepth )(GLclampd) = NULL;
+
+	void (CALLBACK * disp__glDepthFunc )(GLenum) = NULL;
+
+	void (CALLBACK * disp__glDepthMask )(GLboolean) = NULL;
+
+	void (CALLBACK * disp__glDepthRange )(GLclampd, GLclampd) = NULL;
+
+	void (CALLBACK * disp__glClearAccum )(GLfloat, GLfloat, GLfloat, GLfloat) = NULL;
+
+	void (CALLBACK * disp__glAccum )(GLenum, GLfloat) = NULL;
+
+	void (CALLBACK * disp__glMatrixMode )(GLenum) = NULL;
+
+	void (CALLBACK * disp__glOrtho )(GLdouble, GLdouble, GLdouble, GLdouble, GLdouble, GLdouble) = NULL;
+
+	void (CALLBACK * disp__glFrustum )(GLdouble, GLdouble, GLdouble, GLdouble, GLdouble, GLdouble) = NULL;
+
+	void (CALLBACK * disp__glViewport )(GLint, GLint, GLsizei, GLsizei) = NULL;
+
+	void (CALLBACK * disp__glPushMatrix )(void) = NULL;
+
+	void (CALLBACK * disp__glPopMatrix )(void) = NULL;
+
+	void (CALLBACK * disp__glLoadIdentity )(void) = NULL;
+
+	void (CALLBACK * disp__glLoadMatrixd )(const GLdouble *) = NULL;
+
+	void (CALLBACK * disp__glLoadMatrixf )(const GLfloat *) = NULL;
+
+	void (CALLBACK * disp__glMultMatrixd )(const GLdouble *) = NULL;
+
+	void (CALLBACK * disp__glMultMatrixf )(const GLfloat *) = NULL;
+
+	void (CALLBACK * disp__glRotated )(GLdouble, GLdouble, GLdouble, GLdouble) = NULL;
+
+	void (CALLBACK * disp__glRotatef )(GLfloat, GLfloat, GLfloat, GLfloat) = NULL;
+
+	void (CALLBACK * disp__glScaled )(GLdouble, GLdouble, GLdouble) = NULL;
+
+	void (CALLBACK * disp__glScalef )(GLfloat, GLfloat, GLfloat) = NULL;
+
+	void (CALLBACK * disp__glTranslated )(GLdouble, GLdouble, GLdouble) = NULL;
+
+	void (CALLBACK * disp__glTranslatef )(GLfloat, GLfloat, GLfloat) = NULL;
+
+	GLboolean (CALLBACK * disp__glIsList )(GLuint) = NULL;
+
+	void (CALLBACK * disp__glDeleteLists )(GLuint, GLsizei) = NULL;
+
+	GLuint (CALLBACK * disp__glGenLists )(GLsizei) = NULL;
+
+	void (CALLBACK * disp__glNewList )(GLuint, GLenum) = NULL;
+
+	void (CALLBACK * disp__glEndList )(void) = NULL;
+
+	void (CALLBACK * disp__glCallList )(GLuint) = NULL;
+
+	void (CALLBACK * disp__glCallLists )(GLsizei, GLenum, const GLvoid *) = NULL;
+
+	void (CALLBACK * disp__glListBase )(GLuint) = NULL;
+
+	void (CALLBACK * disp__glBegin )(GLenum) = NULL;
+
+	void (CALLBACK * disp__glEnd )(void) = NULL;
+
+	void (CALLBACK * disp__glVertex2d )(GLdouble, GLdouble) = NULL;
+
+	void (CALLBACK * disp__glVertex2f )(GLfloat, GLfloat) = NULL;
+
+	void (CALLBACK * disp__glVertex2i )(GLint, GLint) = NULL;
+
+	void (CALLBACK * disp__glVertex2s )(GLshort, GLshort) = NULL;
+
+	void (CALLBACK * disp__glVertex3d )(GLdouble, GLdouble, GLdouble) = NULL;
+
+	void (CALLBACK * disp__glVertex3f )(GLfloat, GLfloat, GLfloat) = NULL;
+
+	void (CALLBACK * disp__glVertex3i )(GLint, GLint, GLint) = NULL;
+
+	void (CALLBACK * disp__glVertex3s )(GLshort, GLshort, GLshort) = NULL;
+
+	void (CALLBACK * disp__glVertex4d )(GLdouble, GLdouble, GLdouble, GLdouble) = NULL;
+
+	void (CALLBACK * disp__glVertex4f )(GLfloat, GLfloat, GLfloat, GLfloat) = NULL;
+
+	void (CALLBACK * disp__glVertex4i )(GLint, GLint, GLint, GLint) = NULL;
+
+	void (CALLBACK * disp__glVertex4s )(GLshort, GLshort, GLshort, GLshort) = NULL;
+
+	void (CALLBACK * disp__glVertex2dv )(const GLdouble *) = NULL;
+
+	void (CALLBACK * disp__glVertex2fv )(const GLfloat *) = NULL;
+
+	void (CALLBACK * disp__glVertex2iv )(const GLint *) = NULL;
+
+	void (CALLBACK * disp__glVertex2sv )(const GLshort *) = NULL;
+
+	void (CALLBACK * disp__glVertex3dv )(const GLdouble *) = NULL;
+
+	void (CALLBACK * disp__glVertex3fv )(const GLfloat *) = NULL;
+
+	void (CALLBACK * disp__glVertex3iv )(const GLint *) = NULL;
+
+	void (CALLBACK * disp__glVertex3sv )(const GLshort *) = NULL;
+
+	void (CALLBACK * disp__glVertex4dv )(const GLdouble *) = NULL;
+
+	void (CALLBACK * disp__glVertex4fv )(const GLfloat *) = NULL;
+
+	void (CALLBACK * disp__glVertex4iv )(const GLint *) = NULL;
+
+	void (CALLBACK * disp__glVertex4sv )(const GLshort *) = NULL;
+
+	void (CALLBACK * disp__glNormal3b )(GLbyte, GLbyte, GLbyte) = NULL;
+
+	void (CALLBACK * disp__glNormal3d )(GLdouble, GLdouble, GLdouble) = NULL;
+
+	void (CALLBACK * disp__glNormal3f )(GLfloat, GLfloat, GLfloat) = NULL;
+
+	void (CALLBACK * disp__glNormal3i )(GLint, GLint, GLint) = NULL;
+
+	void (CALLBACK * disp__glNormal3s )(GLshort, GLshort, GLshort) = NULL;
+
+	void (CALLBACK * disp__glNormal3bv )(const GLbyte *) = NULL;
+
+	void (CALLBACK * disp__glNormal3dv )(const GLdouble *) = NULL;
+
+	void (CALLBACK * disp__glNormal3fv )(const GLfloat *) = NULL;
+
+	void (CALLBACK * disp__glNormal3iv )(const GLint *) = NULL;
+
+	void (CALLBACK * disp__glNormal3sv )(const GLshort *) = NULL;
+
+	void (CALLBACK * disp__glIndexd )(GLdouble) = NULL;
+
+	void (CALLBACK * disp__glIndexf )(GLfloat) = NULL;
+
+	void (CALLBACK * disp__glIndexi )(GLint) = NULL;
+
+	void (CALLBACK * disp__glIndexs )(GLshort) = NULL;
+
+	void (CALLBACK * disp__glIndexub )(GLubyte) = NULL;
+
+	void (CALLBACK * disp__glIndexdv )(const GLdouble *) = NULL;
+
+	void (CALLBACK * disp__glIndexfv )(const GLfloat *) = NULL;
+
+	void (CALLBACK * disp__glIndexiv )(const GLint *) = NULL;
+
+	void (CALLBACK * disp__glIndexsv )(const GLshort *) = NULL;
+
+	void (CALLBACK * disp__glIndexubv )(const GLubyte *) = NULL;
+
+	void (CALLBACK * disp__glColor3b )(GLbyte, GLbyte, GLbyte) = NULL;
+
+	void (CALLBACK * disp__glColor3d )(GLdouble, GLdouble, GLdouble) = NULL;
+
+	void (CALLBACK * disp__glColor3f )(GLfloat, GLfloat, GLfloat) = NULL;
+
+	void (CALLBACK * disp__glColor3i )(GLint, GLint, GLint) = NULL;
+
+	void (CALLBACK * disp__glColor3s )(GLshort, GLshort, GLshort) = NULL;
+
+	void (CALLBACK * disp__glColor3ub )(GLubyte, GLubyte, GLubyte) = NULL;
+
+	void (CALLBACK * disp__glColor3ui )(GLuint, GLuint, GLuint) = NULL;
+
+	void (CALLBACK * disp__glColor3us )(GLushort, GLushort, GLushort) = NULL;
+
+	void (CALLBACK * disp__glColor4b )(GLbyte, GLbyte, GLbyte, GLbyte) = NULL;
+
+	void (CALLBACK * disp__glColor4d )(GLdouble, GLdouble, GLdouble, GLdouble) = NULL;
+
+	void (CALLBACK * disp__glColor4f )(GLfloat, GLfloat, GLfloat, GLfloat) = NULL;
+
+	void (CALLBACK * disp__glColor4i )(GLint, GLint, GLint, GLint) = NULL;
+
+	void (CALLBACK * disp__glColor4s )(GLshort, GLshort, GLshort, GLshort) = NULL;
+
+	void (CALLBACK * disp__glColor4ub )(GLubyte, GLubyte, GLubyte, GLubyte) = NULL;
+
+	void (CALLBACK * disp__glColor4ui )(GLuint, GLuint, GLuint, GLuint) = NULL;
+
+	void (CALLBACK * disp__glColor4us )(GLushort, GLushort, GLushort, GLushort) = NULL;
+
+	void (CALLBACK * disp__glColor3bv )(const GLbyte *) = NULL;
+
+	void (CALLBACK * disp__glColor3dv )(const GLdouble *) = NULL;
+
+	void (CALLBACK * disp__glColor3fv )(const GLfloat *) = NULL;
+
+	void (CALLBACK * disp__glColor3iv )(const GLint *) = NULL;
+
+	void (CALLBACK * disp__glColor3sv )(const GLshort *) = NULL;
+
+	void (CALLBACK * disp__glColor3ubv )(const GLubyte *) = NULL;
+
+	void (CALLBACK * disp__glColor3uiv )(const GLuint *) = NULL;
+
+	void (CALLBACK * disp__glColor3usv )(const GLushort *) = NULL;
+
+	void (CALLBACK * disp__glColor4bv )(const GLbyte *) = NULL;
+
+	void (CALLBACK * disp__glColor4dv )(const GLdouble *) = NULL;
+
+	void (CALLBACK * disp__glColor4fv )(const GLfloat *) = NULL;
+
+	void (CALLBACK * disp__glColor4iv )(const GLint *) = NULL;
+
+	void (CALLBACK * disp__glColor4sv )(const GLshort *) = NULL;
+
+	void (CALLBACK * disp__glColor4ubv )(const GLubyte *) = NULL;
+
+	void (CALLBACK * disp__glColor4uiv )(const GLuint *) = NULL;
+
+	void (CALLBACK * disp__glColor4usv )(const GLushort *) = NULL;
+
+	void (CALLBACK * disp__glTexCoord1d )(GLdouble) = NULL;
+
+	void (CALLBACK * disp__glTexCoord1f )(GLfloat) = NULL;
+
+	void (CALLBACK * disp__glTexCoord1i )(GLint) = NULL;
+
+	void (CALLBACK * disp__glTexCoord1s )(GLshort) = NULL;
+
+	void (CALLBACK * disp__glTexCoord2d )(GLdouble, GLdouble) = NULL;
+
+	void (CALLBACK * disp__glTexCoord2f )(GLfloat, GLfloat) = NULL;
+
+	void (CALLBACK * disp__glTexCoord2i )(GLint, GLint) = NULL;
+
+	void (CALLBACK * disp__glTexCoord2s )(GLshort, GLshort) = NULL;
+
+	void (CALLBACK * disp__glTexCoord3d )(GLdouble, GLdouble, GLdouble) = NULL;
+
+	void (CALLBACK * disp__glTexCoord3f )(GLfloat, GLfloat, GLfloat) = NULL;
+
+	void (CALLBACK * disp__glTexCoord3i )(GLint, GLint, GLint) = NULL;
+
+	void (CALLBACK * disp__glTexCoord3s )(GLshort, GLshort, GLshort) = NULL;
+
+	void (CALLBACK * disp__glTexCoord4d )(GLdouble, GLdouble, GLdouble, GLdouble) = NULL;
+
+	void (CALLBACK * disp__glTexCoord4f )(GLfloat, GLfloat, GLfloat, GLfloat) = NULL;
+
+	void (CALLBACK * disp__glTexCoord4i )(GLint, GLint, GLint, GLint) = NULL;
+
+	void (CALLBACK * disp__glTexCoord4s )(GLshort, GLshort, GLshort, GLshort) = NULL;
+
+	void (CALLBACK * disp__glTexCoord1dv )(const GLdouble *) = NULL;
+
+	void (CALLBACK * disp__glTexCoord1fv )(const GLfloat *) = NULL;
+
+	void (CALLBACK * disp__glTexCoord1iv )(const GLint *) = NULL;
+
+	void (CALLBACK * disp__glTexCoord1sv )(const GLshort *) = NULL;
+
+	void (CALLBACK * disp__glTexCoord2dv )(const GLdouble *) = NULL;
+
+	void (CALLBACK * disp__glTexCoord2fv )(const GLfloat *) = NULL;
+
+	void (CALLBACK * disp__glTexCoord2iv )(const GLint *) = NULL;
+
+	void (CALLBACK * disp__glTexCoord2sv )(const GLshort *) = NULL;
+
+	void (CALLBACK * disp__glTexCoord3dv )(const GLdouble *) = NULL;
+
+	void (CALLBACK * disp__glTexCoord3fv )(const GLfloat *) = NULL;
+
+	void (CALLBACK * disp__glTexCoord3iv )(const GLint *) = NULL;
+
+	void (CALLBACK * disp__glTexCoord3sv )(const GLshort *) = NULL;
+
+	void (CALLBACK * disp__glTexCoord4dv )(const GLdouble *) = NULL;
+
+	void (CALLBACK * disp__glTexCoord4fv )(const GLfloat *) = NULL;
+
+	void (CALLBACK * disp__glTexCoord4iv )(const GLint *) = NULL;
+
+	void (CALLBACK * disp__glTexCoord4sv )(const GLshort *) = NULL;
+
+	void (CALLBACK * disp__glRasterPos2d )(GLdouble, GLdouble) = NULL;
+
+	void (CALLBACK * disp__glRasterPos2f )(GLfloat, GLfloat) = NULL;
+
+	void (CALLBACK * disp__glRasterPos2i )(GLint, GLint) = NULL;
+
+	void (CALLBACK * disp__glRasterPos2s )(GLshort, GLshort) = NULL;
+
+	void (CALLBACK * disp__glRasterPos3d )(GLdouble, GLdouble, GLdouble) = NULL;
+
+	void (CALLBACK * disp__glRasterPos3f )(GLfloat, GLfloat, GLfloat) = NULL;
+
+	void (CALLBACK * disp__glRasterPos3i )(GLint, GLint, GLint) = NULL;
+
+	void (CALLBACK * disp__glRasterPos3s )(GLshort, GLshort, GLshort) = NULL;
+
+	void (CALLBACK * disp__glRasterPos4d )(GLdouble, GLdouble, GLdouble, GLdouble) = NULL;
+
+	void (CALLBACK * disp__glRasterPos4f )(GLfloat, GLfloat, GLfloat, GLfloat) = NULL;
+
+	void (CALLBACK * disp__glRasterPos4i )(GLint, GLint, GLint, GLint) = NULL;
+
+	void (CALLBACK * disp__glRasterPos4s )(GLshort, GLshort, GLshort, GLshort) = NULL;
+
+	void (CALLBACK * disp__glRasterPos2dv )(const GLdouble *) = NULL;
+
+	void (CALLBACK * disp__glRasterPos2fv )(const GLfloat *) = NULL;
+
+	void (CALLBACK * disp__glRasterPos2iv )(const GLint *) = NULL;
+
+	void (CALLBACK * disp__glRasterPos2sv )(const GLshort *) = NULL;
+
+	void (CALLBACK * disp__glRasterPos3dv )(const GLdouble *) = NULL;
+
+	void (CALLBACK * disp__glRasterPos3fv )(const GLfloat *) = NULL;
+
+	void (CALLBACK * disp__glRasterPos3iv )(const GLint *) = NULL;
+
+	void (CALLBACK * disp__glRasterPos3sv )(const GLshort *) = NULL;
+
+	void (CALLBACK * disp__glRasterPos4dv )(const GLdouble *) = NULL;
+
+	void (CALLBACK * disp__glRasterPos4fv )(const GLfloat *) = NULL;
+
+	void (CALLBACK * disp__glRasterPos4iv )(const GLint *) = NULL;
+
+	void (CALLBACK * disp__glRasterPos4sv )(const GLshort *) = NULL;
+
+	void (CALLBACK * disp__glRectd )(GLdouble, GLdouble, GLdouble, GLdouble) = NULL;
+
+	void (CALLBACK * disp__glRectf )(GLfloat, GLfloat, GLfloat, GLfloat) = NULL;
+
+	void (CALLBACK * disp__glRecti )(GLint, GLint, GLint, GLint) = NULL;
+
+	void (CALLBACK * disp__glRects )(GLshort, GLshort, GLshort, GLshort) = NULL;
+
+	void (CALLBACK * disp__glRectdv )(const GLdouble *, const GLdouble *) = NULL;
+
+	void (CALLBACK * disp__glRectfv )(const GLfloat *, const GLfloat *) = NULL;
+
+	void (CALLBACK * disp__glRectiv )(const GLint *, const GLint *) = NULL;
+
+	void (CALLBACK * disp__glRectsv )(const GLshort *, const GLshort *) = NULL;
+
+	void (CALLBACK * disp__glVertexPointer )(GLint, GLenum, GLsizei, const GLvoid *) = NULL;
+
+	void (CALLBACK * disp__glNormalPointer )(GLenum, GLsizei, const GLvoid *) = NULL;
+
+	void (CALLBACK * disp__glColorPointer )(GLint, GLenum, GLsizei, const GLvoid *) = NULL;
+
+	void (CALLBACK * disp__glIndexPointer )(GLenum, GLsizei, const GLvoid *) = NULL;
+
+	void (CALLBACK * disp__glTexCoordPointer )(GLint, GLenum, GLsizei, const GLvoid *) = NULL;
+
+	void (CALLBACK * disp__glEdgeFlagPointer )(GLsizei, const GLvoid *) = NULL;
+
+	void (CALLBACK * disp__glGetPointerv )(GLenum, void **) = NULL;
+
+	void (CALLBACK * disp__glArrayElement )(GLint) = NULL;
+
+	void (CALLBACK * disp__glDrawArrays )(GLenum, GLint, GLsizei) = NULL;
+
+	void (CALLBACK * disp__glDrawElements )(GLenum, GLsizei, GLenum, const GLvoid *) = NULL;
+
+	void (CALLBACK * disp__glInterleavedArrays )(GLenum, GLsizei, const GLvoid *) = NULL;
+
+	void (CALLBACK * disp__glShadeModel )(GLenum) = NULL;
+
+	void (CALLBACK * disp__glLightf )(GLenum, GLenum, GLfloat) = NULL;
+
+	void (CALLBACK * disp__glLighti )(GLenum, GLenum, GLint) = NULL;
+
+	void (CALLBACK * disp__glLightfv )(GLenum, GLenum, const GLfloat *) = NULL;
+
+	void (CALLBACK * disp__glLightiv )(GLenum, GLenum, const GLint *) = NULL;
+
+	void (CALLBACK * disp__glGetLightfv )(GLenum, GLenum, GLfloat *) = NULL;
+
+	void (CALLBACK * disp__glGetLightiv )(GLenum, GLenum, GLint *) = NULL;
+
+	void (CALLBACK * disp__glLightModelf )(GLenum, GLfloat) = NULL;
+
+	void (CALLBACK * disp__glLightModeli )(GLenum, GLint) = NULL;
+
+	void (CALLBACK * disp__glLightModelfv )(GLenum, const GLfloat *) = NULL;
+
+	void (CALLBACK * disp__glLightModeliv )(GLenum, const GLint *) = NULL;
+
+	void (CALLBACK * disp__glMaterialf )(GLenum, GLenum, GLfloat) = NULL;
+
+	void (CALLBACK * disp__glMateriali )(GLenum, GLenum, GLint) = NULL;
+
+	void (CALLBACK * disp__glMaterialfv )(GLenum, GLenum, const GLfloat *) = NULL;
+
+	void (CALLBACK * disp__glMaterialiv )(GLenum, GLenum, const GLint *) = NULL;
+
+	void (CALLBACK * disp__glGetMaterialfv )(GLenum, GLenum, GLfloat *) = NULL;
+
+	void (CALLBACK * disp__glGetMaterialiv )(GLenum, GLenum, GLint *) = NULL;
+
+	void (CALLBACK * disp__glColorMaterial )(GLenum, GLenum) = NULL;
+
+	void (CALLBACK * disp__glPixelZoom )(GLfloat, GLfloat) = NULL;
+
+	void (CALLBACK * disp__glPixelStoref )(GLenum, GLfloat) = NULL;
+
+	void (CALLBACK * disp__glPixelStorei )(GLenum, GLint) = NULL;
+
+	void (CALLBACK * disp__glPixelTransferf )(GLenum, GLfloat) = NULL;
+
+	void (CALLBACK * disp__glPixelTransferi )(GLenum, GLint) = NULL;
+
+	void (CALLBACK * disp__glPixelMapfv )(GLenum, GLint, const GLfloat *) = NULL;
+
+	void (CALLBACK * disp__glPixelMapuiv )(GLenum, GLint, const GLuint *) = NULL;
+
+	void (CALLBACK * disp__glPixelMapusv )(GLenum, GLint, const GLushort *) = NULL;
+
+	void (CALLBACK * disp__glGetPixelMapfv )(GLenum, GLfloat *) = NULL;
+
+	void (CALLBACK * disp__glGetPixelMapuiv )(GLenum, GLuint *) = NULL;
+
+	void (CALLBACK * disp__glGetPixelMapusv )(GLenum, GLushort *) = NULL;
+
+	void (CALLBACK * disp__glBitmap )(GLsizei, GLsizei, GLfloat, GLfloat, GLfloat, GLfloat, const GLubyte *) = NULL;
+
+	void (CALLBACK * disp__glReadPixels )(GLint, GLint, GLsizei, GLsizei, GLenum, GLenum, GLvoid *) = NULL;
+
+	void (CALLBACK * disp__glDrawPixels )(GLsizei, GLsizei, GLenum, GLenum, const GLvoid *) = NULL;
+
+	void (CALLBACK * disp__glCopyPixels )(GLint, GLint, GLsizei, GLsizei, GLenum) = NULL;
+
+	void (CALLBACK * disp__glStencilFunc )(GLenum, GLint, GLuint) = NULL;
+
+	void (CALLBACK * disp__glStencilMask )(GLuint) = NULL;
+
+	void (CALLBACK * disp__glStencilOp )(GLenum, GLenum, GLenum) = NULL;
+
+	void (CALLBACK * disp__glClearStencil )(GLint) = NULL;
+
+	void (CALLBACK * disp__glTexGend )(GLenum, GLenum, GLdouble) = NULL;
+
+	void (CALLBACK * disp__glTexGenf )(GLenum, GLenum, GLfloat) = NULL;
+
+	void (CALLBACK * disp__glTexGeni )(GLenum, GLenum, GLint) = NULL;
+
+	void (CALLBACK * disp__glTexGendv )(GLenum, GLenum, const GLdouble *) = NULL;
+
+	void (CALLBACK * disp__glTexGenfv )(GLenum, GLenum, const GLfloat *) = NULL;
+
+	void (CALLBACK * disp__glTexGeniv )(GLenum, GLenum, const GLint *) = NULL;
+
+	void (CALLBACK * disp__glGetTexGendv )(GLenum, GLenum, GLdouble *) = NULL;
+
+	void (CALLBACK * disp__glGetTexGenfv )(GLenum, GLenum, GLfloat *) = NULL;
+
+	void (CALLBACK * disp__glGetTexGeniv )(GLenum, GLenum, GLint *) = NULL;
+
+	void (CALLBACK * disp__glTexEnvf )(GLenum, GLenum, GLfloat) = NULL;
+
+	void (CALLBACK * disp__glTexEnvi )(GLenum, GLenum, GLint) = NULL;
+
+	void (CALLBACK * disp__glTexEnvfv )(GLenum, GLenum, const GLfloat *) = NULL;
+
+	void (CALLBACK * disp__glTexEnviv )(GLenum, GLenum, const GLint *) = NULL;
+
+	void (CALLBACK * disp__glGetTexEnvfv )(GLenum, GLenum, GLfloat *) = NULL;
+
+	void (CALLBACK * disp__glGetTexEnviv )(GLenum, GLenum, GLint *) = NULL;
+
+	void (CALLBACK * disp__glTexParameterf )(GLenum, GLenum, GLfloat) = NULL;
+
+	void (CALLBACK * disp__glTexParameteri )(GLenum, GLenum, GLint) = NULL;
+
+	void (CALLBACK * disp__glTexParameterfv )(GLenum, GLenum, const GLfloat *) = NULL;
+
+	void (CALLBACK * disp__glTexParameteriv )(GLenum, GLenum, const GLint *) = NULL;
+
+	void (CALLBACK * disp__glGetTexParameterfv )(GLenum, GLenum, GLfloat *) = NULL;
+
+	void (CALLBACK * disp__glGetTexParameteriv )(GLenum, GLenum, GLint *) = NULL;
+
+	void (CALLBACK * disp__glGetTexLevelParameterfv )(GLenum, GLint, GLenum, GLfloat *) = NULL;
+
+	void (CALLBACK * disp__glGetTexLevelParameteriv )(GLenum, GLint, GLenum, GLint *) = NULL;
+
+	void (CALLBACK * disp__glTexImage1D )(GLenum, GLint, GLint, GLsizei, GLint, GLenum, GLenum, const GLvoid *) = NULL;
+
+	void (CALLBACK * disp__glTexImage2D )(GLenum, GLint, GLint, GLsizei, GLsizei, GLint, GLenum, GLenum, const GLvoid *) = NULL;
+
+	void (CALLBACK * disp__glGetTexImage )(GLenum, GLint, GLenum, GLenum, GLvoid *) = NULL;
+
+	void (CALLBACK * disp__glGenTextures )(GLsizei, GLuint *) = NULL;
+
+	void (CALLBACK * disp__glDeleteTextures )(GLsizei, const GLuint *) = NULL;
+
+	void (CALLBACK * disp__glBindTexture )(GLenum, GLuint) = NULL;
+
+	void (CALLBACK * disp__glPrioritizeTextures )(GLsizei, const GLuint *, const GLclampf *) = NULL;
+
+	GLboolean (CALLBACK * disp__glAreTexturesResident )(GLsizei, const GLuint *, GLboolean *) = NULL;
+
+	GLboolean (CALLBACK * disp__glIsTexture )(GLuint) = NULL;
+
+	void (CALLBACK * disp__glTexSubImage1D )(GLenum, GLint, GLint, GLsizei, GLenum, GLenum, const GLvoid *) = NULL;
+
+	void (CALLBACK * disp__glTexSubImage2D )(GLenum, GLint, GLint, GLint, GLsizei, GLsizei, GLenum, GLenum, const GLvoid *) = NULL;
+
+	void (CALLBACK * disp__glCopyTexImage1D )(GLenum, GLint, GLenum, GLint, GLint, GLsizei, GLint) = NULL;
+
+	void (CALLBACK * disp__glCopyTexImage2D )(GLenum, GLint, GLenum, GLint, GLint, GLsizei, GLsizei, GLint) = NULL;
+
+	void (CALLBACK * disp__glCopyTexSubImage1D )(GLenum, GLint, GLint, GLint, GLint, GLsizei) = NULL;
+
+	void (CALLBACK * disp__glCopyTexSubImage2D )(GLenum, GLint, GLint, GLint, GLint, GLint, GLsizei, GLsizei) = NULL;
+
+	void (CALLBACK * disp__glMap1d )(GLenum, GLdouble, GLdouble, GLint, GLint, const GLdouble *) = NULL;
+
+	void (CALLBACK * disp__glMap1f )(GLenum, GLfloat, GLfloat, GLint, GLint, const GLfloat *) = NULL;
+
+	void (CALLBACK * disp__glMap2d )(GLenum, GLdouble, GLdouble, GLint, GLint, GLdouble, GLdouble, GLint, GLint, const GLdouble *) = NULL;
+
+	void (CALLBACK * disp__glMap2f )(GLenum, GLfloat, GLfloat, GLint, GLint, GLfloat, GLfloat, GLint, GLint, const GLfloat *) = NULL;
+
+	void (CALLBACK * disp__glGetMapdv )(GLenum, GLenum, GLdouble *) = NULL;
+
+	void (CALLBACK * disp__glGetMapfv )(GLenum, GLenum, GLfloat *) = NULL;
+
+	void (CALLBACK * disp__glGetMapiv )(GLenum, GLenum, GLint *) = NULL;
+
+	void (CALLBACK * disp__glEvalCoord1d )(GLdouble) = NULL;
+
+	void (CALLBACK * disp__glEvalCoord1f )(GLfloat) = NULL;
+
+	void (CALLBACK * disp__glEvalCoord1dv )(const GLdouble *) = NULL;
+
+	void (CALLBACK * disp__glEvalCoord1fv )(const GLfloat *) = NULL;
+
+	void (CALLBACK * disp__glEvalCoord2d )(GLdouble, GLdouble) = NULL;
+
+	void (CALLBACK * disp__glEvalCoord2f )(GLfloat, GLfloat) = NULL;
+
+	void (CALLBACK * disp__glEvalCoord2dv )(const GLdouble *) = NULL;
+
+	void (CALLBACK * disp__glEvalCoord2fv )(const GLfloat *) = NULL;
+
+	void (CALLBACK * disp__glMapGrid1d )(GLint, GLdouble, GLdouble) = NULL;
+
+	void (CALLBACK * disp__glMapGrid1f )(GLint, GLfloat, GLfloat) = NULL;
+
+	void (CALLBACK * disp__glMapGrid2d )(GLint, GLdouble, GLdouble, GLint, GLdouble, GLdouble) = NULL;
+
+	void (CALLBACK * disp__glMapGrid2f )(GLint, GLfloat, GLfloat, GLint, GLfloat, GLfloat) = NULL;
+
+	void (CALLBACK * disp__glEvalPoint1 )(GLint) = NULL;
+
+	void (CALLBACK * disp__glEvalPoint2 )(GLint, GLint) = NULL;
+
+	void (CALLBACK * disp__glEvalMesh1 )(GLenum, GLint, GLint) = NULL;
+
+	void (CALLBACK * disp__glEvalMesh2 )(GLenum, GLint, GLint, GLint, GLint) = NULL;
+
+	void (CALLBACK * disp__glFogf )(GLenum, GLfloat) = NULL;
+
+	void (CALLBACK * disp__glFogi )(GLenum, GLint) = NULL;
+
+	void (CALLBACK * disp__glFogfv )(GLenum, const GLfloat *) = NULL;
+
+	void (CALLBACK * disp__glFogiv )(GLenum, const GLint *) = NULL;
+
+	void (CALLBACK * disp__glFeedbackBuffer )(GLsizei, GLenum, GLfloat *) = NULL;
+
+	void (CALLBACK * disp__glPassThrough )(GLfloat) = NULL;
+
+	void (CALLBACK * disp__glSelectBuffer )(GLsizei, GLuint *) = NULL;
+
+	void (CALLBACK * disp__glInitNames )(void) = NULL;
+
+	void (CALLBACK * disp__glLoadName )(GLuint) = NULL;
+
+	void (CALLBACK * disp__glPushName )(GLuint) = NULL;
+
+	void (CALLBACK * disp__glPopName )(void) = NULL;
+
+	void (CALLBACK * disp__glDrawRangeElements )(GLenum, GLuint, GLuint, GLsizei, GLenum, const GLvoid *) = NULL;
+
+	void (CALLBACK * disp__glTexImage3D )(GLenum, GLint, GLint, GLsizei, GLsizei, GLsizei, GLint, GLenum, GLenum, const GLvoid *) = NULL;
+
+	void (CALLBACK * disp__glTexSubImage3D )(GLenum, GLint, GLint, GLint, GLint, GLsizei, GLsizei, GLsizei, GLenum, GLenum, const GLvoid *) = NULL;
+
+	void (CALLBACK * disp__glCopyTexSubImage3D )(GLenum, GLint, GLint, GLint, GLint, GLint, GLint, GLsizei, GLsizei) = NULL;
+
+	void (CALLBACK * disp__glColorTable )(GLenum, GLenum, GLsizei, GLenum, GLenum, const GLvoid *) = NULL;
+
+	void (CALLBACK * disp__glColorSubTable )(GLenum, GLsizei, GLsizei, GLenum, GLenum, const GLvoid *) = NULL;
+
+	void (CALLBACK * disp__glColorTableParameteriv )(GLenum, GLenum, const GLint *) = NULL;
+
+	void (CALLBACK * disp__glColorTableParameterfv )(GLenum, GLenum, const GLfloat *) = NULL;
+
+	void (CALLBACK * disp__glCopyColorSubTable )(GLenum, GLsizei, GLint, GLint, GLsizei) = NULL;
+
+	void (CALLBACK * disp__glCopyColorTable )(GLenum, GLenum, GLint, GLint, GLsizei) = NULL;
+
+	void (CALLBACK * disp__glGetColorTable )(GLenum, GLenum, GLenum, GLvoid *) = NULL;
+
+	void (CALLBACK * disp__glGetColorTableParameterfv )(GLenum, GLenum, GLfloat *) = NULL;
+
+	void (CALLBACK * disp__glGetColorTableParameteriv )(GLenum, GLenum, GLint *) = NULL;
+
+	void (CALLBACK * disp__glBlendEquation )(GLenum) = NULL;
+
+	void (CALLBACK * disp__glBlendColor )(GLclampf, GLclampf, GLclampf, GLclampf) = NULL;
+
+	void (CALLBACK * disp__glHistogram )(GLenum, GLsizei, GLenum, GLboolean) = NULL;
+
+	void (CALLBACK * disp__glResetHistogram )(GLenum) = NULL;
+
+	void (CALLBACK * disp__glGetHistogram )(GLenum, GLboolean, GLenum, GLenum, GLvoid *) = NULL;
+
+	void (CALLBACK * disp__glGetHistogramParameterfv )(GLenum, GLenum, GLfloat *) = NULL;
+
+	void (CALLBACK * disp__glGetHistogramParameteriv )(GLenum, GLenum, GLint *) = NULL;
+
+	void (CALLBACK * disp__glMinmax )(GLenum, GLenum, GLboolean) = NULL;
+
+	void (CALLBACK * disp__glResetMinmax )(GLenum) = NULL;
+
+	void (CALLBACK * disp__glGetMinmax )(GLenum, GLboolean, GLenum, GLenum, GLvoid *) = NULL;
+
+	void (CALLBACK * disp__glGetMinmaxParameterfv )(GLenum, GLenum, GLfloat *) = NULL;
+
+	void (CALLBACK * disp__glGetMinmaxParameteriv )(GLenum, GLenum, GLint *) = NULL;
+
+	void (CALLBACK * disp__glConvolutionFilter1D )(GLenum, GLenum, GLsizei, GLenum, GLenum, const GLvoid *) = NULL;
+
+	void (CALLBACK * disp__glConvolutionFilter2D )(GLenum, GLenum, GLsizei, GLsizei, GLenum, GLenum, const GLvoid *) = NULL;
+
+	void (CALLBACK * disp__glConvolutionParameterf )(GLenum, GLenum, GLfloat) = NULL;
+
+	void (CALLBACK * disp__glConvolutionParameterfv )(GLenum, GLenum, const GLfloat *) = NULL;
+
+	void (CALLBACK * disp__glConvolutionParameteri )(GLenum, GLenum, GLint) = NULL;
+
+	void (CALLBACK * disp__glConvolutionParameteriv )(GLenum, GLenum, const GLint *) = NULL;
+
+	void (CALLBACK * disp__glCopyConvolutionFilter1D )(GLenum, GLenum, GLint, GLint, GLsizei) = NULL;
+
+	void (CALLBACK * disp__glCopyConvolutionFilter2D )(GLenum, GLenum, GLint, GLint, GLsizei, GLsizei) = NULL;
+
+	void (CALLBACK * disp__glGetConvolutionFilter )(GLenum, GLenum, GLenum, GLvoid *) = NULL;
+
+	void (CALLBACK * disp__glGetConvolutionParameterfv )(GLenum, GLenum, GLfloat *) = NULL;
+
+	void (CALLBACK * disp__glGetConvolutionParameteriv )(GLenum, GLenum, GLint *) = NULL;
+
+	void (CALLBACK * disp__glSeparableFilter2D )(GLenum, GLenum, GLsizei, GLsizei, GLenum, GLenum, const GLvoid *, const GLvoid *) = NULL;
+
+	void (CALLBACK * disp__glGetSeparableFilter )(GLenum, GLenum, GLenum, GLvoid *, GLvoid *, GLvoid *) = NULL;
+
+	void (CALLBACK * disp__glBlendColorEXT )(GLclampf, GLclampf, GLclampf, GLclampf) = NULL;
+
+	void (CALLBACK * disp__glPolygonOffsetEXT )(GLfloat, GLfloat) = NULL;
+
+	void (CALLBACK * disp__glTexImage3DEXT )(GLenum, GLint, GLenum, GLsizei, GLsizei, GLsizei, GLint, GLenum, GLenum, const GLvoid *) = NULL;
+
+	void (CALLBACK * disp__glTexSubImage3DEXT )(GLenum, GLint, GLint, GLint, GLint, GLsizei, GLsizei, GLsizei, GLenum, GLenum, const GLvoid *) = NULL;
+
+	void (CALLBACK * disp__glCopyTexSubImage3DEXT )(GLenum, GLint, GLint, GLint, GLint, GLint, GLint, GLsizei, GLsizei) = NULL;
+
+	void (CALLBACK * disp__glGenTexturesEXT )(GLsizei, GLuint *) = NULL;
+
+	void (CALLBACK * disp__glDeleteTexturesEXT )(GLsizei, const GLuint *) = NULL;
+
+	void (CALLBACK * disp__glBindTextureEXT )(GLenum, GLuint) = NULL;
+
+	void (CALLBACK * disp__glPrioritizeTexturesEXT )(GLsizei, const GLuint *, const GLclampf *) = NULL;
+
+	GLboolean (CALLBACK * disp__glAreTexturesResidentEXT )(GLsizei, const GLuint *, GLboolean *) = NULL;
+
+	GLboolean (CALLBACK * disp__glIsTextureEXT )(GLuint) = NULL;
+
+	void (CALLBACK * disp__glVertexPointerEXT )(GLint, GLenum, GLsizei, GLsizei, const GLvoid *) = NULL;
+
+	void (CALLBACK * disp__glNormalPointerEXT )(GLenum, GLsizei, GLsizei, const GLvoid *) = NULL;
+
+	void (CALLBACK * disp__glColorPointerEXT )(GLint, GLenum, GLsizei, GLsizei, const GLvoid *) = NULL;
+
+	void (CALLBACK * disp__glIndexPointerEXT )(GLenum, GLsizei, GLsizei, const GLvoid *) = NULL;
+
+	void (CALLBACK * disp__glTexCoordPointerEXT )(GLint, GLenum, GLsizei, GLsizei, const GLvoid *) = NULL;
+
+	void (CALLBACK * disp__glEdgeFlagPointerEXT )(GLsizei, GLsizei, const GLboolean *) = NULL;
+
+	void (CALLBACK * disp__glGetPointervEXT )(GLenum, void **) = NULL;
+
+	void (CALLBACK * disp__glArrayElementEXT )(GLint) = NULL;
+
+	void (CALLBACK * disp__glDrawArraysEXT )(GLenum, GLint, GLsizei) = NULL;
+
+	void (CALLBACK * disp__glBlendEquationEXT )(GLenum) = NULL;
+
+	void (CALLBACK * disp__glPointParameterfEXT )(GLenum, GLfloat) = NULL;
+
+	void (CALLBACK * disp__glPointParameterfvEXT )(GLenum, const GLfloat *) = NULL;
+
+	void (CALLBACK * disp__glColorTableEXT )(GLenum, GLenum, GLsizei, GLenum, GLenum, const GLvoid *) = NULL;
+
+	void (CALLBACK * disp__glColorSubTableEXT )(GLenum, GLsizei, GLsizei, GLenum, GLenum, const GLvoid *) = NULL;
+
+	void (CALLBACK * disp__glGetColorTableEXT )(GLenum, GLenum, GLenum, GLvoid *) = NULL;
+
+	void (CALLBACK * disp__glGetColorTableParameterfvEXT )(GLenum, GLenum, GLfloat *) = NULL;
+
+	void (CALLBACK * disp__glGetColorTableParameterivEXT )(GLenum, GLenum, GLint *) = NULL;
+
+	void (CALLBACK * disp__glLockArraysEXT )(GLint, GLsizei) = NULL;
+
+	void (CALLBACK * disp__glUnlockArraysEXT )(void) = NULL;
+
+	void (CALLBACK * disp__glActiveTextureARB )(GLenum) = NULL;
+
+	void (CALLBACK * disp__glClientActiveTextureARB )(GLenum) = NULL;
+
+	void (CALLBACK * disp__glMultiTexCoord1dARB )(GLenum, GLdouble) = NULL;
+
+	void (CALLBACK * disp__glMultiTexCoord1dvARB )(GLenum, const GLdouble *) = NULL;
+
+	void (CALLBACK * disp__glMultiTexCoord1fARB )(GLenum, GLfloat) = NULL;
+
+	void (CALLBACK * disp__glMultiTexCoord1fvARB )(GLenum, const GLfloat *) = NULL;
+
+	void (CALLBACK * disp__glMultiTexCoord1iARB )(GLenum, GLint) = NULL;
+
+	void (CALLBACK * disp__glMultiTexCoord1ivARB )(GLenum, const GLint *) = NULL;
+
+	void (CALLBACK * disp__glMultiTexCoord1sARB )(GLenum, GLshort) = NULL;
+
+	void (CALLBACK * disp__glMultiTexCoord1svARB )(GLenum, const GLshort *) = NULL;
+
+	void (CALLBACK * disp__glMultiTexCoord2dARB )(GLenum, GLdouble, GLdouble) = NULL;
+
+	void (CALLBACK * disp__glMultiTexCoord2dvARB )(GLenum, const GLdouble *) = NULL;
+
+	void (CALLBACK * disp__glMultiTexCoord2fARB )(GLenum, GLfloat, GLfloat) = NULL;
+
+	void (CALLBACK * disp__glMultiTexCoord2fvARB )(GLenum, const GLfloat *) = NULL;
+
+	void (CALLBACK * disp__glMultiTexCoord2iARB )(GLenum, GLint, GLint) = NULL;
+
+	void (CALLBACK * disp__glMultiTexCoord2ivARB )(GLenum, const GLint *) = NULL;
+
+	void (CALLBACK * disp__glMultiTexCoord2sARB )(GLenum, GLshort, GLshort) = NULL;
+
+	void (CALLBACK * disp__glMultiTexCoord2svARB )(GLenum, const GLshort *) = NULL;
+
+	void (CALLBACK * disp__glMultiTexCoord3dARB )(GLenum, GLdouble, GLdouble, GLdouble) = NULL;
+
+	void (CALLBACK * disp__glMultiTexCoord3dvARB )(GLenum, const GLdouble *) = NULL;
+
+	void (CALLBACK * disp__glMultiTexCoord3fARB )(GLenum, GLfloat, GLfloat, GLfloat) = NULL;
+
+	void (CALLBACK * disp__glMultiTexCoord3fvARB )(GLenum, const GLfloat *) = NULL;
+
+	void (CALLBACK * disp__glMultiTexCoord3iARB )(GLenum, GLint, GLint, GLint) = NULL;
+
+	void (CALLBACK * disp__glMultiTexCoord3ivARB )(GLenum, const GLint *) = NULL;
+
+	void (CALLBACK * disp__glMultiTexCoord3sARB )(GLenum, GLshort, GLshort, GLshort) = NULL;
+
+	void (CALLBACK * disp__glMultiTexCoord3svARB )(GLenum, const GLshort *) = NULL;
+
+	void (CALLBACK * disp__glMultiTexCoord4dARB )(GLenum, GLdouble, GLdouble, GLdouble, GLdouble) = NULL;
+
+	void (CALLBACK * disp__glMultiTexCoord4dvARB )(GLenum, const GLdouble *) = NULL;
+
+	void (CALLBACK * disp__glMultiTexCoord4fARB )(GLenum, GLfloat, GLfloat, GLfloat, GLfloat) = NULL;
+
+	void (CALLBACK * disp__glMultiTexCoord4fvARB )(GLenum, const GLfloat *) = NULL;
+
+	void (CALLBACK * disp__glMultiTexCoord4iARB )(GLenum, GLint, GLint, GLint, GLint) = NULL;
+
+	void (CALLBACK * disp__glMultiTexCoord4ivARB )(GLenum, const GLint *) = NULL;
+
+	void (CALLBACK * disp__glMultiTexCoord4sARB )(GLenum, GLshort, GLshort, GLshort, GLshort) = NULL;
+
+	void (CALLBACK * disp__glMultiTexCoord4svARB )(GLenum, const GLshort *) = NULL;
+
+/* C2J Parser Version 2.0:  Java program parsed successfully. */ 
diff --git a/src/unix/video-drivers/glcab.c b/src/unix/video-drivers/glcab.c
new file mode 100644
index 0000000..721d06d
--- /dev/null
+++ b/src/unix/video-drivers/glcab.c
@@ -0,0 +1,493 @@
+#ifdef xgl
+
+#include "xmame.h"
+#include "glmame.h"
+
+GLubyte *read_JPEG_file(char *);
+
+GLuint cablist;
+int numtex;
+GLuint *cabtex=NULL;
+GLubyte **cabimg=NULL;
+
+#ifndef NDEBUG
+static int wirecabinet = 1;
+#else
+static int wirecabinet = 0;
+#endif
+
+struct CameraPan *cpan=NULL;
+int numpans;
+int pannum;
+int inpan=0;
+
+static int inscreen=0;
+static int scrvert;
+static int inlist=0;
+static int ingeom=0;
+
+static int inbegin=0;
+
+extern GLdouble vx_cscr_p1,vy_cscr_p1,vz_cscr_p1,vx_cscr_p2,vy_cscr_p2,vz_cscr_p2,
+  vx_cscr_p3,vy_cscr_p3,vz_cscr_p3,vx_cscr_p4,vy_cscr_p4,vz_cscr_p4;
+
+
+/* Skip until we hit whitespace */
+
+char *SkipToSpace(char *buf)
+{
+  while(*buf&&!(isspace(*buf)||*buf==',')) buf++;
+
+  return buf;
+}
+
+/* Skip whitespace and commas */
+
+char *SkipSpace(char *buf)
+{
+  while(*buf&&(isspace(*buf)||*buf==',')) buf++;
+
+  return buf;
+}
+
+/* Parse a string for a 4-component vector */
+
+char *ParseVec4(char *buf,GLdouble *x,GLdouble *y,GLdouble *z,GLdouble *a)
+{
+  *x=atof(buf);
+
+  buf=SkipSpace(buf);
+  buf=SkipToSpace(buf);
+  buf=SkipSpace(buf);
+
+  *y=atof(buf);
+
+  buf=SkipSpace(buf);
+  buf=SkipToSpace(buf);
+  buf=SkipSpace(buf);
+
+  *z=atof(buf);
+
+  buf=SkipSpace(buf);
+  buf=SkipToSpace(buf);
+  buf=SkipSpace(buf);
+
+  *a=atof(buf);
+
+  buf=SkipSpace(buf);
+  buf=SkipToSpace(buf);
+
+  return buf;
+}
+
+/* Parse a string for a 3-component vector */
+
+char *ParseVec3(char *buf,GLdouble *x,GLdouble *y,GLdouble *z)
+{
+  *x=atof(buf);
+
+  buf=SkipSpace(buf);
+  buf=SkipToSpace(buf);
+  buf=SkipSpace(buf);
+
+  *y=atof(buf);
+
+  buf=SkipSpace(buf);
+  buf=SkipToSpace(buf);
+  buf=SkipSpace(buf);
+
+  *z=atof(buf);
+
+  buf=SkipSpace(buf);
+  buf=SkipToSpace(buf);
+
+  return buf;
+}
+
+/* Parse a string for a 2-component vector */
+
+char  *ParseVec2(char *buf,GLdouble *x,GLdouble *y)
+{
+  *x=atof(buf);
+
+  buf=SkipSpace(buf);
+  buf=SkipToSpace(buf);
+  buf=SkipSpace(buf);
+
+  *y=atof(buf);
+
+  buf=SkipSpace(buf);
+  buf=SkipToSpace(buf);
+
+  return buf;
+}
+
+char  *ParseArg(char *buf,GLdouble *a)
+{
+  *a=atof(buf);
+
+  buf=SkipSpace(buf);
+  buf=SkipToSpace(buf);
+
+  return buf;
+}
+
+/* Null-terminate a string after the text is done */
+
+void MakeString(char *buf)
+{
+  while(*buf&&!isspace(*buf)) buf++;
+
+  *buf='\0';
+}
+
+/* Parse a camera pan */
+
+void ParsePan(char *buf,PanType type)
+{
+  if(pannum==numpans) {
+	printf("GLError (cab): too many camera pans specified\n");
+	return;
+  }
+
+  cpan[pannum].type=type;
+  buf=ParseVec3(buf,&cpan[pannum].lx,&cpan[pannum].ly,&cpan[pannum].lz);
+  buf=ParseVec3(buf,&cpan[pannum].px,&cpan[pannum].py,&cpan[pannum].pz);
+  buf=ParseVec3(buf,&cpan[pannum].nx,&cpan[pannum].ny,&cpan[pannum].nz);
+
+  if(type==pan_moveto) cpan[pannum].frames=atoi(buf);
+
+  pannum++;
+}
+
+/* Parse a line of the .cab file */
+
+void ParseLine(char *buf)
+{
+  GLdouble x,y,z,a;
+  int texnum;
+  int xdim,ydim;
+
+  buf=SkipSpace(buf);
+
+  if(!*buf||*buf=='#'||*buf=='\n') return;
+
+  if(!strncasecmp(buf,"startgeom",9)) {
+        CHECK_GL_BEGINEND();
+
+	if(ingeom) printf("GLError (cab): second call to startgeom\n");
+	ingeom=1;
+  }
+  else if(!strncasecmp(buf,"numtex",6)) {
+        CHECK_GL_BEGINEND();
+
+	if(ingeom)
+	  printf("GLError (cab):numtex must be called before beginning model geometry\n");
+	else {
+	  numtex=atoi(buf+7);
+
+	  if(numtex) {
+		cabtex=(GLuint *)malloc(numtex*sizeof(GLuint));
+		cabimg=(GLubyte **)malloc(numtex*sizeof(GLubyte *));
+	  }
+	}
+  }
+  else if(!strncasecmp(buf,"loadtex",7)) {
+        CHECK_GL_BEGINEND();
+
+	if(ingeom)
+	  printf("GLError (cab):loadtex calls cannot come after beginning model geometry\n");
+	else {
+	  if(!cabtex)
+		printf("GLError (cab): Number of textures must be declared before texture loading\n");
+	  else {
+		buf=SkipToSpace(buf);
+		buf=SkipSpace(buf);
+		
+		texnum=atoi(buf);
+		
+		if(texnum>=numtex)
+		  printf("GLError (cab): Hightest possible texture number is %d\n",numtex-1);
+		else {
+		  buf=SkipToSpace(buf);
+		  buf=SkipSpace(buf);
+		  
+		  xdim=atoi(buf);
+		  
+		  buf=SkipToSpace(buf);
+		  buf=SkipSpace(buf);
+		  
+		  ydim=atoi(buf);
+		  
+		  buf=SkipToSpace(buf);
+		  buf=SkipSpace(buf);
+		  
+		  MakeString(buf);
+		  
+		  #ifndef NDEBUG
+		    printf("GLINFO (cab): Loading texture %d (%dx%d) from %s\n",
+		  	   texnum,xdim,ydim,buf);
+		  #endif
+		  
+		  if(!wirecabinet)
+		  {
+			  disp__glGenTextures(1,&(cabtex[texnum]));
+			  disp__glBindTexture(GL_TEXTURE_2D,cabtex[texnum]);
+		  }
+		  
+		  cabimg[texnum]=read_JPEG_file(buf);
+		  if(!cabimg[texnum])
+			printf("GLError (cab): Unable to read %s\n",buf);
+		  
+		  if(!wirecabinet)
+		  	disp__glTexImage2D(GL_TEXTURE_2D,0,3,xdim,ydim,0,
+					   GL_RGB,GL_UNSIGNED_BYTE, cabimg[texnum]);
+		  
+		  disp__glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_LINEAR);
+		  disp__glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_LINEAR);
+		  
+		  disp__glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_WRAP_S,GL_CLAMP);
+		  disp__glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_WRAP_T,GL_CLAMP);
+		}
+	  }
+	}
+  }
+  else if(!strncasecmp(buf,"camerapan",9)) {
+	numpans=atoi(buf+9);
+
+	cpan=(struct CameraPan *)malloc(numpans*sizeof(struct CameraPan));
+
+	pannum=0;
+	inpan=1;
+  }
+  else if(!strncasecmp(buf,"goto",4)) {
+	if(!inpan) printf("GLError (cab): pan command outside of camerapan\n");
+	else ParsePan(buf+4,pan_goto);
+  }
+  else if(!strncasecmp(buf,"moveto",6)) {
+	if(!inpan) printf("GLError (cab): pan command outside of camerapan\n");
+	else ParsePan(buf+6,pan_moveto);
+  }
+  else if(!strncasecmp(buf,"end",3)) {
+	if(inbegin==1)
+	{
+		GL_END();
+		inbegin=0;
+	} 
+	else if(inpan==1)
+		inpan=0;
+	else if(inscreen==1)
+		inscreen=0;
+	else
+	{
+	          printf("GLError (cab): end command without begin, screen or camerapan\n");
+	}
+  } else {
+	if(!ingeom) 
+	{
+		printf("GLError (cab): A startgeom call is needed before specifying any geometry\n");
+        } else if(!strncasecmp(buf,"pointsize",9)) 
+	{
+	      if(inbegin) 
+	          printf("GLError (cab): pointsize command within begin/end\n");
+	      else 
+	      {
+		  ParseArg(buf+10, &a);
+		  disp__glPointSize(a);
+	      }
+        } else if(!strncasecmp(buf,"begin",5)) 
+	{
+	  if(inbegin!=0)
+	  {
+		printf("GLError (cab): begin is called within begin/end !\n");
+	  }
+	  if(!strncasecmp(buf+6,"points",6)) {
+		CHECK_GL_BEGINEND();
+		GL_BEGIN(GL_POINTS); 
+		inbegin=1;
+	  }
+	  else if(!strncasecmp(buf+6,"polygon",7)) {
+	  	if(wirecabinet) {
+			disp__glPolygonMode(GL_BACK , GL_LINE);
+			disp__glPolygonMode(GL_FRONT, GL_LINE);
+		}
+		GL_BEGIN(GL_POLYGON);
+		inbegin=1;
+	  }
+	  else if(!strncasecmp(buf+6,"quads",5)) {
+		GL_BEGIN(GL_QUADS);
+		inbegin=1;
+	  }
+	  else if(!strncasecmp(buf+6,"quad_strip",10)) {
+		GL_BEGIN(GL_QUAD_STRIP);
+		inbegin=1;
+	  }
+	  else if(!strncasecmp(buf+6,"screen",6)) {
+		inscreen=1;
+		scrvert=1;
+	  }
+	  else printf("GLError (cab): Invalid object type -- %s",buf+6);
+	}
+	else if(!strncasecmp(buf,"color3",6)) {
+	  ParseVec3(buf+7,&x,&y,&z);
+	  disp__glColor3d(x,y,z);
+	}
+	else if(!strncasecmp(buf,"color4",6)) {
+	  ParseVec4(buf+7,&x,&y,&z,&a);
+	  disp__glColor4d(x,y,z,a);
+	}
+	else if(!strncasecmp(buf,"vertex",6)) {
+	  if(inscreen) {
+		switch(scrvert) {
+		case 4:
+		  ParseVec3(buf+7,&vx_cscr_p1,&vy_cscr_p1,&vz_cscr_p1);
+		  break;
+		case 3:
+		  ParseVec3(buf+7,&vx_cscr_p2,&vy_cscr_p2,&vz_cscr_p2);
+		  break;
+		case 2:
+		  ParseVec3(buf+7,&vx_cscr_p3,&vy_cscr_p3,&vz_cscr_p3);
+		  break;
+		case 1:
+		  ParseVec3(buf+7,&vx_cscr_p4,&vy_cscr_p4,&vz_cscr_p4);
+		  break;
+		default:
+		  printf("GLError (cab): Error: Too many vertices in screen definition\n");
+		  break;
+		}
+		
+		scrvert++;
+	  }
+	  else {
+		ParseVec3(buf+7,&x,&y,&z);
+		disp__glVertex3d(x,y,z);
+	  }
+	}
+	else if(!strncasecmp(buf,"shading",7)) {
+	  if(!strncasecmp(buf+8,"flat",4))
+		disp__glShadeModel(GL_FLAT);
+	  else if(!strncasecmp(buf+8,"smooth",6))
+		disp__glShadeModel(GL_SMOOTH);
+	  else printf("GLError (cab): Invalid shading model -- %s",buf+8);
+	}
+	else if(!strncasecmp(buf,"enable",6)) {
+	  if(!strncasecmp(buf+7,"texture",7))
+		disp__glEnable(GL_TEXTURE_2D);
+	  else printf("GLError (cab): Invalid feature to enable -- %s",buf+7);
+	}
+	else if(!strncasecmp(buf,"disable",7)) {
+	  if(!strncasecmp(buf+8,"texture",7))
+		disp__glDisable(GL_TEXTURE_2D);
+	  else printf("GLError (cab): Invalid feature to disable -- %s",buf+7);
+	}
+	else if(!strncasecmp(buf,"settex",6)) {
+	  texnum=atoi(buf+7);
+	  
+	  if(texnum>=numtex)
+		printf("GLError (cab): Hightest possible texture number is %d\n",numtex-1);
+	  else if(!wirecabinet)
+		disp__glBindTexture(GL_TEXTURE_2D,cabtex[texnum]);
+	}
+	else if(!strncasecmp(buf,"texcoord",8)) {
+	  ParseVec2(buf+9,&x,&y);
+	  disp__glTexCoord2d(x,y);
+	}
+	else printf("GLError (cab): Invalid command -- %s",buf);
+  }
+}
+
+void InitCabGlobals()
+{
+  int i;
+
+  disp__glDeleteLists(cablist, 1);
+  cablist=0;
+
+  if(cabtex!=0) 
+  {
+          disp__glDeleteTextures(numtex, cabtex);
+	  free(cabtex);
+  }
+  cabtex=0;
+
+  for(i=0; cabimg!=0 && i<numtex; i++)
+  {
+	    if(cabimg[i]!=0)
+		{
+			free(cabimg[i]);
+			cabimg[i]=0;
+		}
+  }
+
+  if(cabimg!=0) 
+	free(cabimg);
+  cabimg=0;
+
+  if(cpan!=0) 
+	free(cpan);
+  cpan=0;
+
+  numtex=0;
+  inlist=0;
+  ingeom=0;
+  numpans=0;
+  pannum=0;
+  inpan=0;
+  inscreen=0;
+  scrvert=0;
+}
+
+/* Load the cabinet */
+
+int LoadCabinet(char *cabname)
+{
+  FILE *cfp;
+  char buf[256];
+
+  InitCabGlobals();
+
+  sprintf(buf,"%s/cab/%s/%s.cab",XMAMEROOT,cabname,cabname);
+
+  if(!(cfp=fopen(buf,"r")))
+	return 0;
+
+  #ifndef NDEBUG
+    printf("GLINFO: Loading Cabinet from %s\n",buf);
+  #endif
+
+  cablist=disp__glGenLists(1);
+
+  disp__glNewList(cablist,GL_COMPILE);
+  inlist=1;
+
+  if(!fgets(buf,256,cfp)) {
+	printf("GLError (cab): File is empty\n");
+	return 0;
+  }
+
+  if(strncasecmp(buf,"cabv1.0",7) &&
+     strncasecmp(buf,"cabv1.1",7)
+    ) 
+  {
+	printf("GLError (cab): File is not a v1.0, or v1.1 cabinet file -- cannot load\n");
+	return 0;
+  }
+
+  while(fgets(buf,256,cfp)) {
+	ParseLine(buf);
+  }
+
+  if(wirecabinet) {
+	disp__glPolygonMode(GL_BACK , GL_FILL);
+	disp__glPolygonMode(GL_FRONT, GL_FILL);
+  }
+
+  disp__glEndList();
+  inlist=0;
+
+  fclose(cfp);
+
+  return(1);
+}
+
+#endif
diff --git a/src/unix/video-drivers/glcaps.c b/src/unix/video-drivers/glcaps.c
new file mode 100644
index 0000000..3f6c019
--- /dev/null
+++ b/src/unix/video-drivers/glcaps.c
@@ -0,0 +1,35 @@
+/**
+ * glcaps.c
+ *
+ * Copyright (C) 2001  Sven Goethel
+ *
+ * GNU Library General Public License 
+ * as published by the Free Software Foundation
+ *
+ * http://www.gnu.org/copyleft/lgpl.html
+ * General dynamical loading OpenGL (GL/GLU) support for:
+ */
+
+#include "gltool.h"
+
+void LIBAPIENTRY printGLCapabilities ( GLCapabilities *glCaps )
+{
+    fprintf(stdout, "\t gl_supported: %d !\n", glCaps->gl_supported);
+    fprintf(stdout, "\t doubleBuff: %d, ", (int)glCaps->buffer);
+    fprintf(stdout, " rgba: %d, ", (int)glCaps->color);
+    fprintf(stdout, " stereo: %d, ", (int)glCaps->stereo);
+    fprintf(stdout, " depthSize: %d, ", (int)glCaps->depthBits);
+    fprintf(stdout, " stencilSize: %d !\n", (int)glCaps->stencilBits);
+    fprintf(stdout, "\t red: %d, ", (int)glCaps->redBits);
+    fprintf(stdout, " green: %d, ", (int)glCaps->greenBits);
+    fprintf(stdout, " blue: %d, ", (int)glCaps->blueBits);
+    fprintf(stdout, " alpha: %d !\n", (int)glCaps->alphaBits);
+    fprintf(stdout, "\t red accum: %d, ", (int)glCaps->accumRedBits);
+    fprintf(stdout, " green accum: %d, ", (int)glCaps->accumGreenBits);
+    fprintf(stdout, " blue accum: %d, ", (int)glCaps->accumBlueBits);
+    fprintf(stdout, " alpha accum: %d !\n", (int)glCaps->accumAlphaBits);
+    fprintf(stdout, "\t nativeVisualID: %ld !\n", (long)glCaps->nativeVisualID);
+
+    fflush(stdout);
+}
+
diff --git a/src/unix/video-drivers/glcaps.h b/src/unix/video-drivers/glcaps.h
new file mode 100644
index 0000000..8f55d3d
--- /dev/null
+++ b/src/unix/video-drivers/glcaps.h
@@ -0,0 +1,57 @@
+#ifndef _GLCAPS_H
+	/**
+	 * glcaps.h
+	 *
+	 * Copyright (C) 2001  Sven Goethel
+	 *
+	 * GNU Library General Public License 
+	 * as published by the Free Software Foundation
+	 *
+	 * http://www.gnu.org/copyleft/lgpl.html
+	 * General dynamical loading OpenGL (GL/GLU) support for:
+	 */
+
+	#define _GLCAPS_H
+
+	#ifndef LIBAPIENTRY
+                #define LIBAPIENTRY
+        #endif
+        #ifndef LIBAPI
+                #define LIBAPI
+        #endif
+
+	#define BUFFER_SINGLE 0
+	#define BUFFER_DOUBLE 1
+	 
+	#define COLOR_INDEX 0
+	#define COLOR_RGBA  1
+	 
+	#define STEREO_OFF 0
+	#define STEREO_ON  1
+
+	typedef struct {
+	  int buffer;
+	  int color;
+	  int stereo;
+	  int depthBits;
+	  int stencilBits;
+
+	  int redBits;
+	  int greenBits;
+	  int blueBits;
+	  int alphaBits;
+	  int accumRedBits;
+	  int accumGreenBits;
+	  int accumBlueBits;
+	  int accumAlphaBits;
+
+	  /* internal use only */
+	  int  gl_supported;
+	  long nativeVisualID;
+	} GLCapabilities;
+
+	/**
+	 * prints the contents of the GLCapabilities to stdout !
+	 */
+	LIBAPI void LIBAPIENTRY printGLCapabilities ( GLCapabilities *glCaps );
+#endif
diff --git a/src/unix/video-drivers/gldirty.c b/src/unix/video-drivers/gldirty.c
new file mode 100644
index 0000000..075c984
--- /dev/null
+++ b/src/unix/video-drivers/gldirty.c
@@ -0,0 +1,85 @@
+#ifdef xgl
+#include "gldirty.h"
+
+const Rectangle nullRect = { 0, 0, 0, 0};
+
+Rectangle firstDirtyRect;
+
+int       dirtyRectNumber = 0;  
+
+int 	  screendirty;	/* Has the bitmap been modified since the last frame? */
+
+int gl_dirty_init()
+{
+   firstDirtyRect = nullRect;
+   dirtyRectNumber = 0;
+
+   return OSD_OK;
+}
+
+void gl_dirty_close(void)
+{
+   firstDirtyRect = nullRect;
+   dirtyRectNumber = 0;
+}
+
+void gl_mark_dirty(int x1, int y1, int x2, int y2)
+{
+	screendirty = 1;
+
+	if (!use_dirty)
+		return;
+
+	if (x1 < visual.min_x) x1=visual.min_x;
+	if (y1 < visual.min_y) y1=visual.min_y;
+	if (x2 > visual.max_x) x2=visual.max_x;
+	if (y2 > visual.max_y) y2=visual.max_y;
+
+	if(dirtyRectNumber==1)
+	{
+		/**
+		 * if the firstDirtyRect is _not_
+		 * included by the new one,
+		 * increase dirtyRectNumber (to skip the dirty usage)
+		 * and exit .. :-(
+		 */
+		if( !
+		    (
+		     firstDirtyRect.min_x>=x1 &&
+		     firstDirtyRect.min_y>=y1 &&
+		     firstDirtyRect.max_x<=x2 &&
+		     firstDirtyRect.max_y<=y2
+		    )
+		  ) 
+		{
+			dirtyRectNumber++;
+			return;
+		}
+		/**
+		 * if the firstDirtyRect includes the new one,
+		 * just ignore the new one ;-)
+		 *
+		 * otherwise, we use the bigger new one ..
+		 */
+		if(  firstDirtyRect.min_x<=x1 &&
+		     firstDirtyRect.min_y<=y1 &&
+		     firstDirtyRect.max_x>=x2 &&
+		     firstDirtyRect.max_y>=y2
+		  )
+		  return;
+
+	} else {
+		/**
+		 * the first dirty rectangle ..
+		 */
+		dirtyRectNumber++;
+	}
+
+	firstDirtyRect.min_x=x1;
+	firstDirtyRect.min_y=y1;
+	firstDirtyRect.max_x=x2;
+	firstDirtyRect.max_y=y2;
+}
+
+#endif /* #if !defined xgl */
+
diff --git a/src/unix/video-drivers/gldirty.h b/src/unix/video-drivers/gldirty.h
new file mode 100644
index 0000000..82a7976
--- /dev/null
+++ b/src/unix/video-drivers/gldirty.h
@@ -0,0 +1,23 @@
+#ifndef GLDIRTY_H
+	#define GLDIRTY_H
+
+	#include "xmame.h"
+	#include "driver.h"
+
+	#include "glmame.h"
+
+	#include "drawgfx.h"
+
+	typedef struct rectangle Rectangle;
+
+	extern const Rectangle nullRect;
+	extern       Rectangle firstDirtyRect;
+	extern       int       dirtyRectNumber;
+	extern       int       screendirty;
+
+	int gl_dirty_init();
+	void gl_dirty_close(void);
+	void gl_mark_dirty(int x1, int y1, int x2, int y2);
+#endif
+
+
diff --git a/src/unix/video-drivers/glexport.c b/src/unix/video-drivers/glexport.c
new file mode 100644
index 0000000..2213ac8
--- /dev/null
+++ b/src/unix/video-drivers/glexport.c
@@ -0,0 +1,128 @@
+#include "driver.h"
+#include "../../png.h"
+#include "glmame.h"
+#include <stdarg.h>
+
+extern int snapno;
+
+void gl_save_screen_snapshot()
+{
+        void *fp;
+        char name[20];
+ 
+ 
+        /* avoid overwriting existing files */
+        /* first of all try with "gamename.png" */
+        sprintf(name,"%.8s", Machine->gamedrv->name);
+        if (mame_faccess(name,FILETYPE_SCREENSHOT))
+        {
+                do
+                {
+                        /* otherwise use "nameNNNN.png" */
+                        sprintf(name,"%.4s%04d",Machine->gamedrv->name,snapno++);
+                } while (mame_faccess(name, FILETYPE_SCREENSHOT));
+        }
+ 
+        if ((fp = mame_fopen(Machine->gamedrv->name, name, FILETYPE_SCREENSHOT, 1)) != NULL)
+        {
+                gl_png_write_bitmap(fp);
+                mame_fclose(fp);
+        }
+}
+
+int gl_png_write_bitmap(void *fp)
+{
+	UINT8 *ip;
+	struct png_info p;
+
+	memset (&p, 0, sizeof (struct png_info));
+	p.xscale = p.yscale = p.source_gamma = 0.0;
+	p.palette = p.trans = p.image = p.zimage = p.fimage = NULL;
+	p.width = winwidth;
+	p.height = winheight;
+
+	p.color_type = 2;
+
+	p.rowbytes = p.width * 3;
+	p.bit_depth = 8;
+	if((p.image = (UINT8 *)malloc (p.height * p.rowbytes))==NULL)
+	{
+		logerror("Out of memory\n");
+		return 0;
+	}
+
+	ip = p.image;
+
+        disp__glPixelStorei(GL_PACK_ALIGNMENT, 1);
+        disp__glPixelStorei(GL_PACK_ROW_LENGTH, p.width);
+        disp__glPixelStorei(GL_PACK_LSB_FIRST, GL_TRUE);
+
+        disp__glReadPixels(0,0, p.width, p.height,
+		     GL_RGB, GL_UNSIGNED_BYTE,
+		     ip);
+
+        disp__glPixelStorei(GL_PACK_ALIGNMENT,4);
+        disp__glPixelStorei(GL_PACK_ROW_LENGTH, 0);
+
+	if(png_filter (&p)==0)
+		return 0;
+
+	if (png_deflate_image(&p)==0)
+		return 0;
+
+	if(png_write_sig(fp) == 0)
+		return 0;
+
+	if (png_write_datastream(fp, &p)==0)
+		return 0;
+
+	if (p.palette) free (p.palette);
+	if (p.image) free (p.image);
+	if (p.zimage) free (p.zimage);
+	if (p.fimage) free (p.fimage);
+	return 1;
+}
+
+
+void ppm_save_snapshot (void *fp)
+{
+  FILE						*file = fp;
+  int						pixelsize, m, i, pixelnum;
+  static unsigned char		*pixels;
+
+  int width  = winwidth;
+  int height = winheight;
+
+  if(gl_is_initialized==0) return;
+
+  m         = width * 3 /*RGB*/ ;
+  pixelsize = width * height  * 3 /*RGB*/ ;
+
+  pixels=(unsigned char *)calloc(pixelsize, 1);
+
+  disp__glPixelStorei(GL_PACK_ALIGNMENT, 1);
+  disp__glPixelStorei(GL_PACK_ROW_LENGTH, width);
+  disp__glPixelStorei(GL_PACK_LSB_FIRST, GL_TRUE);
+
+  disp__glReadPixels(0,0, width, height,
+			   GL_RGB, GL_UNSIGNED_BYTE,
+			   pixels);
+
+  disp__glPixelStorei(GL_PACK_ALIGNMENT,4);
+  disp__glPixelStorei(GL_PACK_ROW_LENGTH, 0);
+
+  fprintf(file,"P6\n#GLmame screenshot\n%d %d\n255\n",
+		  (int)width, (int)height);
+  
+  
+  for(pixelnum=0, i=height-1;i>=0;i--) 
+  {
+	fwrite(&pixels[i*m], sizeof(unsigned char), m, file);
+  }
+
+  free(pixels); pixels=0;
+
+  return;
+}
+
+
diff --git a/src/unix/video-drivers/glgen.c b/src/unix/video-drivers/glgen.c
new file mode 100644
index 0000000..be5ddfb
--- /dev/null
+++ b/src/unix/video-drivers/glgen.c
@@ -0,0 +1,2750 @@
+/*****************************************************************
+
+  Generic OpenGL routines
+
+  Copyright 1998 by Mike Oliphant - oliphant@ling.ed.ac.uk
+
+    http://www.ling.ed.ac.uk/~oliphant/glmame
+
+  Improved by Sven Goethel, http://www.jausoft.com, sgoethel@jausoft.com
+
+  This code may be used and distributed under the terms of the
+  Mame license
+
+*****************************************************************/
+
+#ifdef xgl
+
+#include "xmame.h"
+#include "driver.h"
+#include "glmame.h"
+#include <math.h>
+#include "effect.h"
+
+static int use_dirty = 0;
+
+int LoadCabinet (const char *fname);
+void SwapBuffers (void);
+VIDEO_UPDATE(vector);
+void vector_clear_list (void);
+
+GLdouble CompareVec (GLdouble i, GLdouble j, GLdouble k,
+	    GLdouble x, GLdouble y, GLdouble z);
+void TranslatePointInPlane   (
+	      GLdouble vx_p1, GLdouble vy_p1, GLdouble vz_p1,
+	      GLdouble vx_nw, GLdouble vy_nw, GLdouble vz_nw,
+	      GLdouble vx_nh, GLdouble vy_nh, GLdouble vz_nh,
+	      GLdouble x_off, GLdouble y_off,
+	      GLdouble *vx_p, GLdouble *vy_p, GLdouble *vz_p );
+void ScaleThisVec (GLdouble i, GLdouble j, GLdouble k,
+	      GLdouble * x, GLdouble * y, GLdouble * z);
+void AddToThisVec (GLdouble i, GLdouble j, GLdouble k,
+	      GLdouble * x, GLdouble * y, GLdouble * z);
+GLdouble LengthOfVec (GLdouble x, GLdouble y, GLdouble z);
+void NormThisVec (GLdouble * x, GLdouble * y, GLdouble * z);
+void DeltaVec (GLdouble x1, GLdouble y1, GLdouble z1,
+	       GLdouble x2, GLdouble y2, GLdouble z2,
+	       GLdouble * dx, GLdouble * dy, GLdouble * dz);
+void CrossVec (GLdouble a1, GLdouble a2, GLdouble a3,
+	  GLdouble b1, GLdouble b2, GLdouble b3,
+	  GLdouble * c1, GLdouble * c2, GLdouble * c3);
+void CopyVec(GLdouble *ax,GLdouble *ay,GLdouble *az,                   /* dest   */
+	     const GLdouble bx,const GLdouble by,const GLdouble bz     /* source */
+                  );
+void SwapVec(GLdouble *ax,GLdouble *ay,GLdouble *az,
+	          GLdouble *bx,GLdouble *by,GLdouble *bz
+                  );
+void CalcFlatTexPoint( int x, int y, GLdouble texwpervw, GLdouble texhpervh, 
+		       GLdouble * px, GLdouble * py);
+void CalcCabPointbyWorldpoint( 
+		   GLdouble vx_gscr, GLdouble vy_gscr, 
+                   GLdouble *vx_p, GLdouble *vy_p, GLdouble *vz_p
+		 );
+void CalcCabPointbyViewpoint( 
+		   GLdouble vx_gscr_view, GLdouble vy_gscr_view, 
+                   GLdouble *vx_p, GLdouble *vy_p, GLdouble *vz_p
+		 );
+
+void SetupFrustum (void);
+void SetupOrtho (void);
+
+
+void WAvg (GLdouble perc, GLdouble x1, GLdouble y1, GLdouble z1,
+	   GLdouble x2, GLdouble y2, GLdouble z2,
+	   GLdouble * ax, GLdouble * ay, GLdouble * az);
+void UpdateCabDisplay (struct mame_bitmap *bitmap);
+void UpdateFlatDisplay (struct mame_bitmap *bitmap);
+void UpdateGLDisplayBegin (struct mame_bitmap *bitmap);
+void UpdateGLDisplayEnd   (struct mame_bitmap *bitmap);
+
+int cabspecified;
+
+/**
+ *
+ * Flat-Screen Ratio:
+ *
+ * scrnaspect : orig screen width/height ratio (view-coord)
+ * vscrnaspect: zoomed screen width/height ratio (view-coord)
+ * vscrnwidth : final screen width (view-coord)
+ * vscrnheight: final screen height (view-coord)
+ * vscrndx: 	  final screen dx to start of game-screen (view-coord)
+ * vscrndy: 	  final screen dy to start of game-screen (view-coord)
+ *
+ */
+double scrnaspect, vscrnaspect;
+static GLdouble vscrnwidth;
+static GLdouble vscrnheight;
+static GLdouble vscrndx;
+static GLdouble vscrndy;
+
+int use_mod_ctable;
+GLubyte  *ctable;
+GLushort *rcolmap, *gcolmap, *bcolmap, *acolmap;
+int ctable_size;		/* the true color table size */
+
+GLint      gl_internal_format;
+GLenum     gl_bitmap_format;
+GLenum	   gl_bitmap_type;
+GLenum     gl_ctable_format;
+GLenum	   gl_ctable_type;
+GLsizei text_width;
+GLsizei text_height;
+
+int force_text_width_height;
+
+static GLdouble mxModel[16];
+static GLdouble mxProjection[16];
+static GLint    dimView[4];
+
+/* int cabview=0;  .. Do we want a cabinet view or not? */
+int cabload_err;
+
+int drawbitmap;
+int dopersist;
+int dodepth;
+
+int totalcolors;
+unsigned char gl_alpha_value;
+static int frame;
+
+static int screendirty;
+/* The squares that are tiled to make up the game screen polygon */
+
+struct TexSquare
+{
+  GLubyte *texture;
+  GLuint texobj;
+  int isTexture;
+  GLdouble x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, z4;
+  GLdouble fx1, fy1, fx2, fy2, fx3, fy3, fx4, fy4;
+  GLdouble xcov, ycov;
+  int isDirty;
+  int dirtyXoff, dirtyYoff, dirtyWidth, dirtyHeight;
+};
+
+static struct TexSquare *texgrid;
+
+static int texnumx;
+static int texnumy;
+
+static GLint memory_x_len;
+static GLint memory_x_start_offset;
+static int bytes_per_pixel;
+
+/**
+ * VERY IMPORTANT: osd_alloc_bitmap must allocate also a "safety area" 16 pixels 
+ * wide all
+ * around the bitmap. This is required because, for performance reasons, some graphic
+ * routines don't clip at boundaries of the bitmap.
+ */
+#define BITMAP_SAFETY			16
+static unsigned char *colorBlittedMemory;
+
+/**
+ * cscr..: cabinet screen points:
+ * 
+ * are defined within <model>.cab in the following order:
+ *	1.) left  - top
+ *	2.) right - top
+ *	3.) right - bottom
+ *	4.) left  - bottom
+ *
+ * are read in reversed:
+ *	1.) left  - bottom
+ *	2.) right - bottom
+ *	3.) right - top
+ *	4.) left  - top
+ *
+ * so we do have a positiv (Q I) coord system ;-), of course:
+ *	left   < right
+ *	bottom < top
+ */
+GLdouble vx_cscr_p1, vy_cscr_p1, vz_cscr_p1, 
+        vx_cscr_p2, vy_cscr_p2, vz_cscr_p2,
+        vx_cscr_p3, vy_cscr_p3, vz_cscr_p3, 
+	vx_cscr_p4, vy_cscr_p4, vz_cscr_p4;
+
+/**
+ * cscr..: cabinet screen dimension vectors
+ *	
+ * 	these are the cabinet-screen's width/height in the cabinet's world-coord !!
+ */
+GLdouble  vx_cscr_dw, vy_cscr_dw, vz_cscr_dw; /* the width (world-coord) , p1-p2 */
+GLdouble  vx_cscr_dh, vy_cscr_dh, vz_cscr_dh; /* the height (world-coord), p1-p4 */
+
+GLdouble  s__cscr_w,  s__cscr_h;              /* scalar width/height (world-coord) */
+GLdouble  s__cscr_w_view, s__cscr_h_view;     /* scalar width/height (view-coord) */
+
+/* screen x-axis (world-coord), normalized v__cscr_dw */
+GLdouble vx_scr_nx, vy_scr_nx, vz_scr_nx; 
+
+/* screen y-axis (world-coord), normalized v__cscr_dh */
+GLdouble vx_scr_ny, vy_scr_ny, vz_scr_ny; 
+
+/* screen z-axis (world-coord), the normalized cross product of v__cscr_dw,v__cscr_dh */
+GLdouble vx_scr_nz, vy_scr_nz, vz_scr_nz; 
+
+/* x/y-factor for view/world coord translation */
+GLdouble cab_vpw_fx; /* s__cscr_w_view / s__cscr_w */
+GLdouble cab_vpw_fy; /* s__cscr_h_view / s__cscr_h */
+
+/**
+ * gscr..: game screen dimension vectors
+ *	
+ * 	these are the game portion of the cabinet-screen's width/height 
+ *      in the cabinet's world-coord !!
+ *
+ *	gscr[wh]d[xyz] <= cscr[wh]d[xyz]
+ */
+
+GLdouble vx_gscr_dw, vy_gscr_dw, vz_gscr_dw; /* the width (world-coord) */
+GLdouble vx_gscr_dh, vy_gscr_dh, vz_gscr_dh; /* the height (world-coord) */
+
+GLdouble  s__gscr_w, s__gscr_h;              /* scalar width/height (world-coord) */
+GLdouble  s__gscr_w_view, s__gscr_h_view;    /* scalar width/height (view-coord) */
+
+GLdouble  s__gscr_offx, s__gscr_offy;          /* delta game start (world-coord) */
+
+GLdouble  s__gscr_offx_view, s__gscr_offy_view;/* delta game-start (view-coord) */
+
+/**
+*
+* ALL GAME SCREEN VECTORS ARE IN FINAL ORIENTATION (e.g. if blit_swapxy)
+*
+* v__gscr_p1 = v__cscr_p1   + 
+*              s__gscr_offx * v__scr_nx + s__gscr_offy * v__scr_ny ;
+*
+* v__gscr_p2  = v__gscr_p1  + 
+*              s__gscr_w    * v__scr_nx + 0.0          * v__scr_ny ;
+*
+* v__gscr_p3  = v__gscr_p2  + 
+*              0.0          * v__scr_nx + s__gscr_h    * v__scr_ny ;
+*
+* v__gscr_p4  = v__gscr_p3  - 
+*              s__gscr_w    * v__scr_nx - 0.0          * v__scr_ny ;
+*
+* v__gscr_p4b = v__gscr_p1  + 
+*              0.0          * v__scr_nx + s__gscr_h    * v__scr_ny ;
+*
+* v__gscr_p4a == v__gscr_p4b
+*/
+GLdouble vx_gscr_p1, vy_gscr_p1, vz_gscr_p1; 
+GLdouble vx_gscr_p2, vy_gscr_p2, vz_gscr_p2; 
+GLdouble vx_gscr_p3, vy_gscr_p3, vz_gscr_p3; 
+GLdouble vx_gscr_p4, vy_gscr_p4, vz_gscr_p4; 
+
+
+extern GLubyte *cabimg[5];
+extern GLuint cabtex[5];
+
+extern struct CameraPan *cpan;
+extern int numpans;
+int currentpan = 0;
+int lastpan = 0;
+int panframe = 0;
+
+/* Vector variables */
+
+int vecgame = 0;
+
+extern GLuint veclist;
+extern int inlist;
+
+int gl_is_initialized;
+
+int useGLEXT78; /* paletted texture */
+int useColorIndex; 
+int isGL12;
+
+int useColorBlitter = 0;
+
+static int do_snapshot;
+static int do_xgl_resize=0;
+
+void gl_bootstrap_resources()
+{
+  #ifndef NDEBUG
+    printf("GLINFO: gl_bootstrap_resources\n");
+  #endif
+
+  blit_hardware_rotation=1; /* no rotation by the blitter macro, or else !! */
+
+  cabspecified = 0;
+  if(cabname!=NULL) cabname[0]=0;
+
+  scrnaspect=0; vscrnaspect=0;
+  ctable = 0;
+  rcolmap = 0; gcolmap = 0; bcolmap = 0; acolmap = 0;
+  ctable_size=0;
+  gl_bitmap_type=0;
+  gl_bitmap_format=0;
+  gl_ctable_format=0;
+  gl_ctable_type=0;
+  text_width=0;
+  text_height=0;
+  force_text_width_height = 0;
+  cabload_err=0;
+  drawbitmap = 1;
+  dopersist = 0;
+  dodepth = 1;
+  totalcolors=0;
+  gl_alpha_value = 255;
+  frame = 0;
+  screendirty = 1;
+
+  texnumx=0;
+  texnumy=0;
+  vscrndx=0;
+  vscrndy=0;
+  vscrnwidth=0;
+  vscrnheight=0;
+  
+  memory_x_len=0;;
+  memory_x_start_offset=0;;
+  bytes_per_pixel=0;
+  colorBlittedMemory=NULL;
+  
+  vx_cscr_p1=0; vy_cscr_p1=0; vz_cscr_p1=0; vx_cscr_p2=0; vy_cscr_p2=0; vz_cscr_p2=0;
+  vx_cscr_p3=0; vy_cscr_p3=0; vz_cscr_p3=0; vx_cscr_p4=0; vy_cscr_p4=0; vz_cscr_p4=0;
+  
+  cabimg[0]=0;
+  cabtex[0]=0;
+  cpan=0;
+  numpans=0;
+  currentpan = 0;
+  lastpan = 0;
+  panframe = 0;
+  
+  vecgame = 0;
+  veclist=0;
+  inlist=0;
+
+  gl_is_initialized = 0;
+#ifdef NOGLEXT78
+  useGLEXT78 = GL_FALSE;
+#else
+  useGLEXT78 = GL_TRUE;
+#endif
+  isGL12=GL_TRUE;
+  useColorIndex = GL_FALSE; 
+  use_mod_ctable = 1;
+  useColorBlitter = 0;
+
+  do_snapshot=0;
+  do_xgl_resize=0;
+}
+
+void gl_reset_resources()
+{
+  #ifndef NDEBUG
+    printf("GLINFO: gl_reset_resources\n");
+  #endif
+
+  if(texgrid) free(texgrid);
+  if(ctable) free(ctable);
+  if(rcolmap) free(rcolmap);
+  if(gcolmap) free(gcolmap);
+  if(bcolmap) free(bcolmap);
+  if(acolmap) free(acolmap);
+  if(cpan) free(cpan);
+
+  ctable = 0;
+  rcolmap = 0; gcolmap = 0; bcolmap = 0; acolmap = 0;
+  texgrid = 0;
+  cpan=0;
+
+  scrnaspect=0; vscrnaspect=0;
+  ctable_size=0;
+  gl_bitmap_type=0;
+  gl_bitmap_format=0;
+  gl_ctable_format=0;
+  gl_ctable_type=0;
+  cabload_err=0;
+  dopersist = 0;
+  dodepth = 1;
+  gl_alpha_value = 255;
+  frame = 0;
+  screendirty = 1;
+
+  texnumx=0;
+  texnumy=0;
+  vscrndx=0;
+  vscrndy=0;
+  vscrnwidth=0;
+  vscrnheight=0;
+  
+  memory_x_len=0;
+  memory_x_start_offset=0;
+  bytes_per_pixel=0;
+  colorBlittedMemory=NULL;
+  
+  vx_cscr_p1=0; vy_cscr_p1=0; vz_cscr_p1=0; vx_cscr_p2=0; vy_cscr_p2=0; vz_cscr_p2=0;
+  vx_cscr_p3=0; vy_cscr_p3=0; vz_cscr_p3=0; vx_cscr_p4=0; vy_cscr_p4=0; vz_cscr_p4=0;
+  
+  cabimg[0]=0;
+  cabtex[0]=0;
+  cpan=0;
+  numpans=0;
+  currentpan = 0;
+  lastpan = 0;
+  panframe = 0;
+  
+  vecgame = 0;
+  veclist=0;
+  inlist=0;
+
+  if(cabname!=NULL && strlen(cabname)>0)
+  	cabspecified = 1;
+
+  gl_is_initialized = 0;
+  
+  do_snapshot=0;
+  do_xgl_resize=0;
+}
+
+/* ---------------------------------------------------------------------- */
+/* ------------ New OpenGL Specials ------------------------------------- */
+/* ---------------------------------------------------------------------- */
+
+int glHasEXT78 (void)
+{
+  if (gl_is_initialized)
+    fetch_GL_FUNCS (libGLName, libGLUName, 0);
+  return disp__glColorTableEXT != NULL;
+}
+
+void glSetUseEXT78 (int val)
+{
+  if (gl_is_initialized == 0 || val==GL_FALSE || 
+      (disp__glColorTableEXT!=NULL && disp__glColorSubTableEXT!=NULL) )
+    useGLEXT78 = val;
+}
+
+int glGetUseEXT78 (void)
+{ return useGLEXT78; }
+
+void gl_set_bilinear (int new_value)
+{
+  int x, y;
+  bilinear = new_value;
+
+  if (gl_is_initialized == 0)
+    return;
+
+  if (bilinear)
+  {
+    disp__glBindTexture (GL_TEXTURE_2D, cabtex[0]);
+
+    disp__glTexParameteri (GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
+    disp__glTexParameteri (GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
+
+    disp__glPixelStorei (GL_UNPACK_ROW_LENGTH, memory_x_len);
+    disp__glPixelStorei (GL_UNPACK_ALIGNMENT, 8);
+    CHECK_GL_ERROR ();
+
+    for (y = 0; y < texnumy; y++)
+    {
+      for (x = 0; x < texnumx; x++)
+      {
+        disp__glBindTexture (GL_TEXTURE_2D, texgrid[y * texnumx + x].texobj);
+
+        disp__glTexParameteri (GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
+        disp__glTexParameteri (GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
+
+        disp__glPixelStorei (GL_UNPACK_ROW_LENGTH, 0);
+        disp__glPixelStorei (GL_UNPACK_ALIGNMENT, 4);
+        CHECK_GL_ERROR ();
+      }
+    }
+  }
+  else
+  {
+    disp__glBindTexture (GL_TEXTURE_2D, cabtex[0]);
+
+    disp__glTexParameteri (GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
+    disp__glTexParameteri (GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
+
+    disp__glPixelStorei (GL_UNPACK_ROW_LENGTH, memory_x_len);
+    disp__glPixelStorei (GL_UNPACK_ALIGNMENT, 8);
+    CHECK_GL_ERROR ();
+
+    for (y = 0; y < texnumy; y++)
+    {
+      for (x = 0; x < texnumx; x++)
+      {
+        disp__glBindTexture (GL_TEXTURE_2D, texgrid[y * texnumx + x].texobj);
+
+        disp__glTexParameteri (GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
+        disp__glTexParameteri (GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
+
+        disp__glPixelStorei (GL_UNPACK_ROW_LENGTH, 0);
+        disp__glPixelStorei (GL_UNPACK_ALIGNMENT, 4);
+        CHECK_GL_ERROR ();
+      }
+    }
+  }
+}
+
+void gl_init_cabview ()
+{
+  if (glContext == 0)
+    return;
+
+        currentpan=1;
+	lastpan = 0;
+	panframe = 0;
+
+	#ifdef WIN32
+	  __try
+	  {
+	#endif
+	    if (!cabspecified || !LoadCabinet (cabname))
+	    {
+	      if (cabspecified)
+		printf ("GLERROR: Unable to load cabinet %s\n", cabname);
+	      strcpy (cabname, "glmamejau");
+	      cabspecified = 1;
+	      LoadCabinet (cabname);
+	      cabload_err = 0;
+	    }
+
+	#ifdef WIN32
+	  }
+	  __except (GetExceptionCode ())
+	  {
+	    fprintf (stderr, "\nGLERROR: Cabinet loading is still buggy - sorry !\n");
+	    cabload_err = 1;
+	  }
+	#endif
+}
+
+void gl_set_cabview (int new_value)
+{
+  if (glContext == 0)
+    return;
+
+  cabview = new_value;
+
+  if (cabview)
+  {
+        currentpan=1;
+	lastpan = 0;
+	panframe = 0;
+
+	SetupFrustum ();
+  } else {
+	SetupOrtho ();
+  }
+}
+
+int gl_stream_antialias (int aa)
+{
+  if (gl_is_initialized == 0)
+    return aa;
+
+  if (aa)
+  {
+    disp__glShadeModel (GL_SMOOTH);
+    disp__glEnable (GL_POLYGON_SMOOTH);
+    disp__glEnable (GL_LINE_SMOOTH);
+    disp__glEnable (GL_POINT_SMOOTH);
+  }
+  else
+  {
+    disp__glShadeModel (GL_FLAT);
+    disp__glDisable (GL_POLYGON_SMOOTH);
+    disp__glDisable (GL_LINE_SMOOTH);
+    disp__glDisable (GL_POINT_SMOOTH);
+  }
+
+  return aa;
+}
+
+void gl_set_antialias (int new_value)
+{
+  antialias = gl_stream_antialias(new_value);
+}
+
+int gl_stream_alphablending (int alpha)
+{
+  if (gl_is_initialized == 0)
+    return alpha;
+
+  if (alpha)
+  {
+    disp__glEnable (GL_BLEND);
+    disp__glBlendFunc (GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
+  }
+  else
+  {
+    disp__glDisable (GL_BLEND);
+  }
+
+  return alpha;
+}
+
+void gl_set_alphablending (int new_value)
+{
+  alphablending = gl_stream_alphablending(new_value);
+}
+
+/* ---------------------------------------------------------------------- */
+/* ---------------------------------------------------------------------- */
+/* ---------------------------------------------------------------------- */
+
+static int blit_notified = 0;
+
+void gl_update_16_to_16bpp (struct mame_bitmap *bitmap)
+{
+   if(current_palette->lookup)
+   {
+   	if(!blit_notified) printf("GLINFO: 16bpp color palette lookup bitblit\n");
+	#define SRC_PIXEL  unsigned short
+	#define DEST_PIXEL unsigned short
+	#define DEST texgrid->texture
+	#define DEST_WIDTH memory_x_len
+	#define INDIRECT current_palette->lookup
+	#include "blit.h"
+	#undef INDIRECT
+	#undef DEST
+	#undef DEST_WIDTH
+	#undef SRC_PIXEL
+	#undef DEST_PIXEL
+   } else {
+   	if(!blit_notified) printf("GLINFO: 16bpp swapping ... !! JAU \n");
+	#define SRC_PIXEL  unsigned short
+	#define DEST_PIXEL unsigned short
+	#define DEST texgrid->texture
+	#define DEST_WIDTH memory_x_len
+	#undef INDIRECT
+	#include "blit.h"
+	#undef INDIRECT
+	#undef DEST
+	#undef DEST_WIDTH
+	#undef SRC_PIXEL
+	#undef DEST_PIXEL
+   }
+   blit_notified = 1;
+}
+
+void gl_update_32_to_32bpp(struct mame_bitmap *bitmap)
+{
+   if(current_palette->lookup)
+   {
+   	if(!blit_notified) printf("GLINFO: 32bpp palette lookup bitblit\n");
+	#define SRC_PIXEL  unsigned int
+	#define DEST_PIXEL unsigned int
+	#define DEST texgrid->texture
+	#define DEST_WIDTH memory_x_len
+	#define INDIRECT current_palette->lookup
+	#include "blit.h"
+	#undef INDIRECT
+	#undef DEST
+	#undef DEST_WIDTH
+	#undef SRC_PIXEL
+	#undef DEST_PIXEL
+   } else {
+   	if(!blit_notified) printf("GLINFO: 32bpp swapping ... !! JAU \n");
+	#define SRC_PIXEL  unsigned int
+	#define DEST_PIXEL unsigned int
+	#define DEST texgrid->texture
+	#define DEST_WIDTH memory_x_len
+	#undef  INDIRECT
+	#include "blit.h"
+	#undef INDIRECT
+	#undef DEST
+	#undef DEST_WIDTH
+	#undef SRC_PIXEL
+	#undef DEST_PIXEL
+   }
+   blit_notified = 1;
+}
+
+int sysdep_display_16bpp_capable (void)
+{
+  #ifndef NDEBUG
+    printf("GLINFO: sysdep_display_16bpp_capable\n");
+  #endif
+
+  return 1; /* direct color */
+}
+
+void InitVScreen (int depth)
+{
+  const unsigned char * glVersion;
+  double game_aspect ;
+  double cabn_aspect ;
+  GLdouble vx_gscr_p4b, vy_gscr_p4b, vz_gscr_p4b; 
+  GLdouble t1;
+
+  #ifndef NDEBUG
+    GLdouble t1x, t1y, t1z;
+
+    printf("GLINFO: InitVScreen (glContext=%p)\n", glContext);
+    printf("GLINFO: InitVScreen: useColorIndex=%d, alphablending=%d, doublebuffer=%d\n",
+	   useColorIndex, alphablending, doublebuffer);
+  #endif
+
+  gl_reset_resources();
+
+  /* clear the buffer */
+
+  if (glContext == 0)
+    return;
+
+  fetch_GL_FUNCS (libGLName, libGLUName, 0);
+
+  CHECK_GL_BEGINEND();
+
+  glVersion = disp__glGetString(GL_VERSION);
+
+  printf("\nGLINFO: OpenGL Driver Information:\n");
+  printf("\tvendor: %s,\n\trenderer %s,\n\tversion %s\n", 
+  	disp__glGetString(GL_VENDOR), 
+	disp__glGetString(GL_RENDERER),
+	glVersion);
+
+  printf("GLINFO: GLU Driver Information:\n");
+  printf("\tversion %s\n", 
+	disp__gluGetString(GLU_VERSION));
+
+  if(glVersion[0]>'1' ||
+     (glVersion[0]=='1' && glVersion[2]>='2') )
+	  isGL12 = GL_TRUE;
+  else
+	  isGL12 = GL_FALSE;
+
+  if(isGL12)
+  {
+	printf("GLINFO: You have an OpenGL >= 1.2 capable drivers, GOOD (16bpp is ok !)\n");
+  } else {
+	printf("GLINFO: You have an OpenGL < 1.2 drivers, BAD (16bpp may be damaged  !)\n");
+  }
+
+  glSetUseEXT78 (useGLEXT78);
+
+  printf("GLINFO: swapxy=%d, flipx=%d, flipy=%d\n",
+  	blit_swapxy, blit_flipx, blit_flipy);
+
+  disp__glClearColor (0, 0, 0, 1);
+  disp__glClear (GL_COLOR_BUFFER_BIT);
+  disp__glFlush ();
+
+  if (!dodepth)
+    cabview = 0;
+
+  gl_init_cabview ();
+
+  xgl_resize(winwidth, winheight,1);
+
+  if (dodepth)
+    disp__glDepthFunc (GL_LEQUAL);
+
+  /* Calulate delta vectors for screen height and width */
+
+  DeltaVec (vx_cscr_p1, vy_cscr_p1, vz_cscr_p1, vx_cscr_p2, vy_cscr_p2, vz_cscr_p2,
+	    &vx_cscr_dw, &vy_cscr_dw, &vz_cscr_dw);
+  DeltaVec (vx_cscr_p1, vy_cscr_p1, vz_cscr_p1, vx_cscr_p4, vy_cscr_p4, vz_cscr_p4,
+	    &vx_cscr_dh, &vy_cscr_dh, &vz_cscr_dh);
+
+  s__cscr_w = LengthOfVec (vx_cscr_dw, vy_cscr_dw, vz_cscr_dw);
+  s__cscr_h = LengthOfVec (vx_cscr_dh, vy_cscr_dh, vz_cscr_dh);
+
+
+	  /*	  
+	  ScaleThisVec ( -1.0,  1.0,  1.0, &vx_cscr_dh, &vy_cscr_dh, &vz_cscr_dh);
+	  ScaleThisVec ( -1.0,  1.0,  1.0, &vx_cscr_dw, &vy_cscr_dw, &vz_cscr_dw);
+	  */
+
+  CopyVec( &vx_scr_nx, &vy_scr_nx, &vz_scr_nx,
+	    vx_cscr_dw,  vy_cscr_dw,  vz_cscr_dw);
+  NormThisVec (&vx_scr_nx, &vy_scr_nx, &vz_scr_nx);
+
+  CopyVec( &vx_scr_ny, &vy_scr_ny, &vz_scr_ny,
+	    vx_cscr_dh,  vy_cscr_dh,  vz_cscr_dh);
+  NormThisVec (&vx_scr_ny, &vy_scr_ny, &vz_scr_ny);
+
+  CrossVec (vx_cscr_dw, vy_cscr_dw, vz_cscr_dw,
+  	    vx_cscr_dh, vy_cscr_dh, vz_cscr_dh,
+	    &vx_scr_nz, &vy_scr_nz, &vz_scr_nz);
+  NormThisVec (&vx_scr_nz, &vy_scr_nz, &vz_scr_nz);
+
+#ifndef NDEBUG
+  /**
+   * assertions ...
+   */
+  CopyVec( &t1x, &t1y, &t1z,
+	   vx_scr_nx, vy_scr_nx, vz_scr_nx);
+  ScaleThisVec (s__cscr_w,s__cscr_w,s__cscr_w,
+                &t1x, &t1y, &t1z);
+  t1 =  CompareVec (t1x, t1y, t1z, vx_cscr_dw,  vy_cscr_dw,  vz_cscr_dw);
+
+  printf("GLINFO: test v__cscr_dw - ( v__scr_nx * s__cscr_w ) = %f\n", t1);
+  printf("\t v__cscr_dw = %f / %f / %f\n", vx_cscr_dw,  vy_cscr_dw,  vz_cscr_dw);
+  printf("\t v__scr_nx = %f / %f / %f\n", vx_scr_nx, vy_scr_nx, vz_scr_nx);
+  printf("\t s__cscr_w  = %f \n", s__cscr_w);
+
+  CopyVec( &t1x, &t1y, &t1z,
+	   vx_scr_ny, vy_scr_ny, vz_scr_ny);
+  ScaleThisVec (s__cscr_h,s__cscr_h,s__cscr_h,
+                &t1x, &t1y, &t1z);
+  t1 =  CompareVec (t1x, t1y, t1z, vx_cscr_dh,  vy_cscr_dh,  vz_cscr_dh);
+
+  printf("GLINFO: test v__cscr_dh - ( v__scr_ny * s__cscr_h ) = %f\n", t1);
+  printf("\t v__cscr_dh = %f / %f / %f\n", vx_cscr_dh,  vy_cscr_dh,  vz_cscr_dh);
+  printf("\t v__scr_ny  = %f / %f / %f\n", vx_scr_ny, vy_scr_ny, vz_scr_ny);
+  printf("\t s__cscr_h   = %f \n", s__cscr_h);
+#endif
+
+  /**
+   *
+   * Cabinet-Screen Ratio:
+   */
+   game_aspect = (double)visual_orientated_width / (double)visual_orientated_height;
+
+   cabn_aspect = (double)s__cscr_w        / (double)s__cscr_h;
+
+   if( game_aspect <= cabn_aspect )
+   {
+   	/**
+	 * cabinet_width  >  game_width
+	 * cabinet_height == game_height 
+	 *
+	 * cabinet_height(view-coord) := visual_orientated_height(view-coord) 
+	 */
+	s__cscr_h_view  = (GLdouble) visual_orientated_height;
+	s__cscr_w_view  = s__cscr_h_view * cabn_aspect;
+
+	s__gscr_h_view  = s__cscr_h_view;
+	s__gscr_w_view  = s__gscr_h_view * game_aspect; 
+
+	s__gscr_offy_view = 0.0;
+	s__gscr_offx_view = ( s__cscr_w_view - s__gscr_w_view ) / 2.0;
+
+   } else {
+   	/**
+	 * cabinet_width  <  game_width
+	 * cabinet_width  == game_width 
+	 *
+	 * cabinet_width(view-coord) := visual_orientated_width(view-coord) 
+	 */
+	s__cscr_w_view  = (GLdouble) visual_orientated_width;
+	s__cscr_h_view  = s__cscr_w_view / cabn_aspect;
+
+	s__gscr_w_view  = s__cscr_w_view;
+	s__gscr_h_view  = s__gscr_w_view / game_aspect; 
+
+	s__gscr_offx_view = 0.0;
+	s__gscr_offy_view = ( s__cscr_h_view - s__gscr_h_view ) / 2.0;
+
+   }
+   cab_vpw_fx = (GLdouble)s__cscr_w_view / (GLdouble)s__cscr_w ;
+   cab_vpw_fy = (GLdouble)s__cscr_h_view / (GLdouble)s__cscr_h ;
+
+   s__gscr_w   = (GLdouble)s__gscr_w_view  / cab_vpw_fx ;
+   s__gscr_h   = (GLdouble)s__gscr_h_view  / cab_vpw_fy ;
+   s__gscr_offx = (GLdouble)s__gscr_offx_view / cab_vpw_fx ;
+   s__gscr_offy = (GLdouble)s__gscr_offy_view / cab_vpw_fy ;
+
+
+   /**
+    * ALL GAME SCREEN VECTORS ARE IN FINAL ORIENTATION (e.g. if blit_swapxy)
+    *
+    * v__gscr_p1 = v__cscr_p1   + 
+    *              s__gscr_offx * v__scr_nx + s__gscr_offy * v__scr_ny ;
+    *
+    * v__gscr_p2  = v__gscr_p1  + 
+    *              s__gscr_w    * v__scr_nx + 0.0          * v__scr_ny ;
+    *
+    * v__gscr_p3  = v__gscr_p2  + 
+    *              0.0          * v__scr_nx + s__gscr_h    * v__scr_ny ;
+    *
+    * v__gscr_p4  = v__gscr_p3  - 
+    *              s__gscr_w    * v__scr_nx - 0.0          * v__scr_ny ;
+    *
+    * v__gscr_p4b = v__gscr_p1  + 
+    *              0.0          * v__scr_nx + s__gscr_h    * v__scr_ny ;
+    *
+    * v__gscr_p4  == v__gscr_p4b
+    */
+   TranslatePointInPlane ( vx_cscr_p1, vy_cscr_p1, vz_cscr_p1,
+                           vx_scr_nx, vy_scr_nx, vz_scr_nx,
+			   vx_scr_ny, vy_scr_ny, vz_scr_ny,
+			   s__gscr_offx, s__gscr_offy,
+			   &vx_gscr_p1, &vy_gscr_p1, &vz_gscr_p1);
+
+   TranslatePointInPlane ( vx_gscr_p1, vy_gscr_p1, vz_gscr_p1,
+                           vx_scr_nx, vy_scr_nx, vz_scr_nx,
+			   vx_scr_ny, vy_scr_ny, vz_scr_ny,
+			   s__gscr_w, 0.0,
+			   &vx_gscr_p2, &vy_gscr_p2, &vz_gscr_p2);
+
+   TranslatePointInPlane ( vx_gscr_p2, vy_gscr_p2, vz_gscr_p2,
+                           vx_scr_nx, vy_scr_nx, vz_scr_nx,
+			   vx_scr_ny, vy_scr_ny, vz_scr_ny,
+			   0.0, s__gscr_h,
+			   &vx_gscr_p3, &vy_gscr_p3, &vz_gscr_p3);
+
+   TranslatePointInPlane ( vx_gscr_p3, vy_gscr_p3, vz_gscr_p3,
+                           vx_scr_nx, vy_scr_nx, vz_scr_nx,
+			   vx_scr_ny, vy_scr_ny, vz_scr_ny,
+			   -s__gscr_w, 0.0,
+			   &vx_gscr_p4, &vy_gscr_p4, &vz_gscr_p4);
+
+   TranslatePointInPlane ( vx_gscr_p1, vy_gscr_p1, vz_gscr_p1,
+                           vx_scr_nx, vy_scr_nx, vz_scr_nx,
+			   vx_scr_ny, vy_scr_ny, vz_scr_ny,
+			   0.0, s__gscr_h,
+			   &vx_gscr_p4b, &vy_gscr_p4b, &vz_gscr_p4b);
+
+   t1 =  CompareVec (vx_gscr_p4,  vy_gscr_p4,  vz_gscr_p4,
+   		     vx_gscr_p4b, vy_gscr_p4b, vz_gscr_p4b);
+
+  DeltaVec (vx_gscr_p1, vy_gscr_p1, vz_gscr_p1, vx_gscr_p2, vy_gscr_p2, vz_gscr_p2,
+	    &vx_gscr_dw, &vy_gscr_dw, &vz_gscr_dw);
+  DeltaVec (vx_gscr_p1, vy_gscr_p1, vz_gscr_p1, vx_gscr_p4, vy_gscr_p4, vz_gscr_p4,
+	    &vx_gscr_dh, &vy_gscr_dh, &vz_gscr_dh);
+
+#ifndef NDEBUG
+  printf("GLINFO: test v__cscr_dh - ( v__scr_ny * s__cscr_h ) = %f\n", t1);
+  printf("GLINFO: cabinet vectors\n");
+  printf("\t cab p1     : %f / %f / %f \n", vx_cscr_p1, vy_cscr_p1, vz_cscr_p1);
+  printf("\t cab p2     : %f / %f / %f \n", vx_cscr_p2, vy_cscr_p2, vz_cscr_p2);
+  printf("\t cab p3     : %f / %f / %f \n", vx_cscr_p3, vy_cscr_p3, vz_cscr_p3);
+  printf("\t cab p4     : %f / %f / %f \n", vx_cscr_p4, vy_cscr_p4, vz_cscr_p4);
+  printf("\n") ;
+  printf("\t cab width  : %f / %f / %f \n", vx_cscr_dw, vy_cscr_dw, vz_cscr_dw);
+  printf("\t cab height : %f / %f / %f \n", vx_cscr_dh, vy_cscr_dh, vz_cscr_dh);
+  printf("\n");
+  printf("\t x axis : %f / %f / %f \n", vx_scr_nx, vy_scr_nx, vz_scr_nx);
+  printf("\t y axis : %f / %f / %f \n", vx_scr_ny, vy_scr_ny, vz_scr_ny);
+  printf("\t z axis : %f / %f / %f \n", vx_scr_nz, vy_scr_nz, vz_scr_nz);
+  printf("\n");
+  printf("\n");
+  printf("\t cab wxh scal wd: %f x %f \n", s__cscr_w, s__cscr_h);
+  printf("\t cab wxh scal vw: %f x %f \n", s__cscr_w_view, s__cscr_h_view);
+  printf("\n");
+  printf("\t gam p1     : %f / %f / %f \n", vx_gscr_p1, vy_gscr_p1, vz_gscr_p1);
+  printf("\t gam p2     : %f / %f / %f \n", vx_gscr_p2, vy_gscr_p2, vz_gscr_p2);
+  printf("\t gam p3     : %f / %f / %f \n", vx_gscr_p3, vy_gscr_p3, vz_gscr_p3);
+  printf("\t gam p4     : %f / %f / %f \n", vx_gscr_p4, vy_gscr_p4, vz_gscr_p4);
+  printf("\t gam p4b    : %f / %f / %f \n", vx_gscr_p4b, vy_gscr_p4b, vz_gscr_p4b);
+  printf("\t gam p4-p4b : %f\n", t1);
+  printf("\n");
+  printf("\t gam width  : %f / %f / %f \n", vx_gscr_dw, vy_gscr_dw, vz_gscr_dw);
+  printf("\t gam height : %f / %f / %f \n", vx_gscr_dh, vy_gscr_dh, vz_gscr_dh);
+  printf("\n");
+  printf("\t gam wxh scal wd: %f x %f \n", s__gscr_w, s__gscr_h);
+  printf("\t gam wxh scal vw: %f x %f \n", s__gscr_w_view, s__gscr_h_view);
+  printf("\n");
+  printf("\t gam off  wd: %f / %f\n", s__gscr_offx, s__gscr_offy);
+  printf("\t gam off  vw: %f / %f\n", s__gscr_offx_view, s__gscr_offy_view);
+  printf("\n");
+#endif
+
+  if (Machine->drv->video_attributes & VIDEO_TYPE_VECTOR)
+    vecgame = 1;
+  else
+    vecgame = 0;
+
+  /* fill the display_palette_info struct */
+  memset (&display_palette_info, 0, sizeof (struct sysdep_palette_info));
+
+  if( (depth==8 /* || depth==16 JAU - STILL NOT WORKING */ ) && useColorIndex && !useColorBlitter )
+  {
+	  display_palette_info.depth=depth;
+
+#ifndef NOGLEXT78
+	  if(useGLEXT78)
+	  {
+	  	if(depth==8)
+		 gl_internal_format=GL_COLOR_INDEX8_EXT;
+		else if(depth==16)
+		 gl_internal_format=GL_COLOR_INDEX16_EXT;
+	  } else
+#endif
+		 gl_internal_format=(alphablending)?GL_RGBA:GL_RGB;
+
+	  gl_bitmap_format = GL_COLOR_INDEX;
+
+	  if(depth==8)
+		  gl_bitmap_type   = GL_UNSIGNED_BYTE;
+	  else
+		  gl_bitmap_type   = GL_UNSIGNED_SHORT;
+
+	  printf("GLINFO: Offering depth=%d, writable colors=%d (color index mode 8/16)\n",
+	  	display_palette_info.depth, display_palette_info.writable_colors);
+          fflush(NULL);
+  } else {
+	  useColorBlitter = useColorIndex || vecgame; /* JAU vecgames .. */
+
+	  useColorIndex = 0;
+
+	  if(depth<24 && !isGL12)
+	  {
+	  	depth=32;
+		printf("GLINFO: you have no OpenGL 1.2 capable drivers, so the 16bpp is disabled -> 32bpp!\n");
+	  }
+
+	  display_palette_info.depth = depth;
+
+	  /* no alpha .. important, because mame has no alpha set ! */
+	  gl_internal_format=GL_RGB;
+  }
+
+  switch(display_palette_info.depth)
+  {
+	case  8:  /* ... */
+		  if( ! useColorIndex ) {
+			  printf("GLERROR: color blitter mode not supported for 8bpp color map's, use 15bpp, 16bpp or 32bpp instead !\n");
+			  exit(1);
+		  } else {
+		    display_palette_info.red_mask   = 0x0;
+		    display_palette_info.green_mask = 0x0;
+		    display_palette_info.blue_mask  = 0x0;
+		  }
+		case 15:
+	case 16:
+		  if(!useColorBlitter)
+		  {
+		    /* ARGB1555 */
+		    display_palette_info.red_mask   = 0x00007C00;
+		    display_palette_info.green_mask = 0x000003E0;
+		    display_palette_info.blue_mask  = 0x0000001F;
+		    if( ! useColorIndex ) {
+			    gl_bitmap_format = GL_BGRA;
+			    /*                                   A R G B */
+			    gl_bitmap_type   = GL_UNSIGNED_SHORT_1_5_5_5_REV;
+		    }
+		  } 
+		  else 
+		  {
+		    /* RGBA5551 */
+		    display_palette_info.red_mask   = 0x0000F800;
+		    display_palette_info.green_mask = 0x000007C0;
+		    display_palette_info.blue_mask  = 0x0000003E;
+		    if( ! useColorIndex ) {
+			    gl_bitmap_format = GL_RGBA;
+			    /*                                   R G B A */
+			    gl_bitmap_type   = GL_UNSIGNED_SHORT_5_5_5_1;
+		    }
+		  }
+		  break;
+	case 24:
+		  /* RGB888 */
+		  display_palette_info.red_mask   = 0xFF000000;
+		  display_palette_info.green_mask = 0x00FF0000;
+		  display_palette_info.blue_mask  = 0x0000FF00;
+		  gl_bitmap_format = GL_RGB;         
+		  gl_bitmap_type   = GL_UNSIGNED_BYTE;
+		  break;
+	case 32:
+		 /**
+		  * skip the D of DRGB 
+		  */
+		  /* ABGR8888 */
+		  display_palette_info.blue_mask   = 0x00FF0000;
+		  display_palette_info.green_mask  = 0x0000FF00;
+		  display_palette_info.red_mask    = 0x000000FF;
+		  if(!useColorBlitter)
+			  gl_bitmap_format = GL_BGRA;
+		  else
+			  gl_bitmap_format = GL_RGBA;
+		  /*                                 A B G R */
+		  gl_bitmap_type   = GL_UNSIGNED_INT_8_8_8_8_REV;
+		  break;
+  }
+
+  printf("GLINFO: Offering colors=%d, depth=%d, rgb 0x%X, 0x%X, 0x%X (true color mode)\n",
+		display_palette_info.writable_colors,
+		display_palette_info.depth, 
+		display_palette_info.red_mask, display_palette_info.green_mask, 
+		display_palette_info.blue_mask);
+
+  if(useColorBlitter) {
+	printf("GLINFO: Using bit blit to map color indices !!\n");
+	heightscale =1; widthscale=1; use_scanlines=0;
+  } else {
+	printf("GLINFO: Using true color mode (no color indices, but direct color)!!\n");
+  }
+}
+
+/* Close down the virtual screen */
+
+void CloseVScreen (void)
+{
+  #ifndef NDEBUG
+    printf("GLINFO: CloseVScreen (gl_is_initialized=%d)\n", gl_is_initialized);
+  #endif
+
+  if(colorBlittedMemory!=NULL)
+  	free(colorBlittedMemory);
+
+  if (gl_is_initialized == 0)
+    return;
+
+  CHECK_GL_BEGINEND();
+
+  gl_reset_resources();
+}
+
+/* Not needed under GL */
+#ifndef WIN32
+void sysdep_clear_screen (void)
+{
+}
+#endif
+
+static int texture_init = 0;
+
+int sysdep_display_alloc_palette (int writable_colors)
+{
+  #ifndef NDEBUG
+    fprintf (stderr, "GLINFO: sysdep_display_alloc_palette:\n\twritable_colors=%d,\n\tMachine->drv->total_colors=%d\n",writable_colors,Machine->drv->total_colors);
+  #endif
+
+  if (glContext == 0)
+    return 1;
+
+  /*totalcolors = writable_colors; */
+  totalcolors = Machine->drv->total_colors;
+
+  if (totalcolors > 256)
+  {
+    if(useColorIndex)
+    {
+        printf("GLERROR: OpenGL color index mode not supported for colors == %d / only for depth == 8 (<= 256 colors) !\n", totalcolors);
+        exit(1); /* JAU */
+    }
+  }
+
+  ctable_size = 1;
+  while(ctable_size<totalcolors)
+  	ctable_size*=2;
+
+  /* some bitmap fix data values .. 
+   * independent of the mame bitmap line arrangement !
+   */
+  bytes_per_pixel = (Machine->color_depth+7) / 8;
+
+  if(useColorIndex)
+  {
+      switch (bytes_per_pixel)
+      {
+      	case 1: gl_ctable_type   = GL_UNSIGNED_BYTE; break;
+      	case 2: gl_ctable_type   = GL_UNSIGNED_SHORT; break;
+      	default:
+		printf("GLERROR: OpenGL color index mode not supported for index byte-size (%d) > 2\n", bytes_per_pixel);
+		exit(1);
+      }
+
+      if (useGLEXT78)
+      {
+      	    int err;
+
+  	    gl_ctable_format = (alphablending)?GL_RGBA:GL_RGB;
+  
+	    ctable = (GLubyte *) 
+		  calloc (ctable_size * (alphablending?4:3), 1);
+
+	    disp__glColorTableEXT (GL_TEXTURE_2D,
+			       gl_ctable_format,
+			       ctable_size, gl_ctable_format, 
+			       gl_ctable_type, ctable); /* JAU COLOR */
+
+	    err = disp__glGetError ();
+	    if(err!=GL_NO_ERROR) 
+	    {
+	      /**
+	       * ok .. but, we only use this mode for 256 color's,
+	       * which is usually supported 
+	       */
+	      printf("GLERROR: ColorTable (glColorTableEXT) is unallocabel (color table too large := %d)!\n", err==GL_TABLE_TOO_LARGE);
+	      exit(1);
+	    }
+      }
+
+      if (!useGLEXT78)
+      {
+      	    int max_pixel_map_table;
+
+      	    disp__glGetIntegerv(GL_MAX_PIXEL_MAP_TABLE, &max_pixel_map_table);
+	    if(max_pixel_map_table<ctable_size)
+	    {
+	       /**
+	        * ok .. but, we only use this mode for 256 color's,
+	        * which is usually supported 
+	        */
+	    	printf("GLERROR: ColorTable (glPixelMapusv) size %d is too large, maximum is = %d !! \n", ctable_size, max_pixel_map_table);
+		exit(1);
+	    }
+	    rcolmap = (GLushort *) calloc (ctable_size * sizeof (GLushort), 1);
+	    gcolmap = (GLushort *) calloc (ctable_size * sizeof (GLushort), 1);
+	    bcolmap = (GLushort *) calloc (ctable_size * sizeof (GLushort), 1);
+	    if (alphablending)
+	      acolmap = (GLushort *) calloc (ctable_size * sizeof (GLushort), 1);
+	    else
+	      acolmap = 0;
+      }
+  }
+
+  fprintf (stderr, "GLINFO: totalcolors = %d / colortable size= %d,\n\tdepth = %d alphablending=%d,\n\tuse_mod_ctable=%d\n\tuseColorIndex=%d\n",
+	   totalcolors, ctable_size,
+	   Machine->color_depth, alphablending, 
+	   use_mod_ctable,
+	   useColorIndex);
+
+  if(useColorIndex)
+  {
+	  if(useGLEXT78)
+	  {
+	      if (disp__glColorTableEXT == 0)
+	        printf("GLINFO: glColorTableEXT not available .. BAD & SLOW\n");
+	      else
+	        printf("GLINFO: glColorTableEXT available .. GOOD & FAST\n");
+
+	      if (disp__glColorSubTableEXT == 0)
+	        printf("GLINFO: glColorSubTableEXT not available .. BAD & SLOW\n");
+	      else
+	        printf("GLINFO: glColorSubTableEXT available .. GOOD & FAST\n");
+	  } else
+	      fprintf (stderr, "GLINFO: useGLEXT78 = 0 (BAD & SLOW)\n");
+  }
+
+  texture_init = 0;
+
+  return 0;
+}
+
+/**
+ * the given bitmap MUST be the original mame core bitmap !!!
+ *    - no swapxy, flipx or flipy and no resize !
+ *    - shall be Machine->scrbitmap
+ */
+void InitTextures (struct mame_bitmap *bitmap)
+{
+  int e_x, e_y, s, i=0;
+  int x=0, y=0, line_len=0, raw_line_len=0;
+  GLint format=0;
+  GLint tidxsize=0;
+  GLenum err;
+  unsigned char *line_1=0, *line_2=0;
+  struct TexSquare *tsq=0;
+  GLdouble texwpervw=0.0;
+  GLdouble texhpervh=0.0;
+
+  if (glContext == 0 || texture_init == 1)
+    return;
+
+  texture_init = 1;
+
+  text_width  = visual_width;
+  text_height = visual_height;
+
+  CHECK_GL_BEGINEND();
+
+  texnumx = 1;
+  texnumy = 1;
+
+  if(force_text_width_height>0)
+  {
+  	text_height=force_text_width_height;
+  	text_width=force_text_width_height;
+	fprintf (stderr, "GLINFO: force_text_width_height := %d x %d\n",
+		text_height, text_width);
+  }
+  
+  /* achieve the 2**e_x:=text_width, 2**e_y:=text_height */
+  e_x=0; s=1;
+  while (s<text_width)
+  { s*=2; e_x++; }
+  text_width=s;
+
+  e_y=0; s=1;
+  while (s<text_height)
+  { s*=2; e_y++; }
+  text_height=s;
+
+  CHECK_GL_BEGINEND();
+
+#ifndef NDEBUG
+  fprintf (stderr, "GLINFO: gl_internal_format= 0x%X,\n\tgl_bitmap_format =  0x%X,\n\tgl_bitmap_type = 0x%X\n", gl_internal_format, gl_bitmap_format, gl_bitmap_type);
+#endif
+
+  /* Test the max texture size */
+  do
+  {
+    disp__glTexImage2D (GL_PROXY_TEXTURE_2D, 0,
+		  gl_internal_format,
+		  text_width, text_height,
+		  0, gl_bitmap_format, gl_bitmap_type, 0);
+
+    CHECK_GL_ERROR ();
+
+    disp__glGetTexLevelParameteriv
+      (GL_PROXY_TEXTURE_2D, 0, GL_TEXTURE_INTERNAL_FORMAT, &format);
+
+#ifndef NOTEXIDXSIZE
+    disp__glGetTexLevelParameteriv
+      (GL_PROXY_TEXTURE_2D, 0, GL_TEXTURE_INDEX_SIZE_EXT, &tidxsize);
+#else
+    tidxsize = -1;
+#endif
+    CHECK_GL_ERROR ();
+
+    if (format == gl_internal_format &&
+	force_text_width_height > 0 &&
+	(force_text_width_height < text_width ||
+	 force_text_width_height < text_height))
+    {
+      format = 0;
+    }
+
+    if (format != gl_internal_format)
+    {
+      fprintf (stderr, "GLINFO: Needed texture [%dx%d] too big (format=0x%X,idxsize=%d), trying ",
+		text_height, text_width, format, tidxsize);
+
+      if (text_width > text_height)
+      {
+	e_x--;
+	text_width = 1;
+	for (i = e_x; i > 0; i--)
+	  text_width *= 2;
+      }
+      else
+      {
+	e_y--;
+	text_height = 1;
+	for (i = e_y; i > 0; i--)
+	  text_height *= 2;
+      }
+
+      fprintf (stderr, "[%dx%d] !\n", text_height, text_width);
+
+      if(text_width < 64 || text_height < 64)
+      {
+      	fprintf (stderr, "GLERROR: Give up .. usable texture size not available, or texture config error !\n");
+	exit(1);
+      }
+    }
+  }
+  while (format != gl_internal_format && text_width > 1 && text_height > 1);
+
+  texnumx = visual_width / text_width;
+  if ((visual_width % text_width) > 0)
+    texnumx++;
+
+  texnumy = visual_height / text_height;
+  if ((visual_height % text_height) > 0)
+    texnumy++;
+
+  /* Allocate the texture memory */
+
+  /**
+   * texwpervw, texhpervh:
+   * 	how much the texture covers the visual,
+   * 	for both components (width/height) (percent).
+   */
+  texwpervw = (GLdouble) text_width / (GLdouble) visual_width;
+  if (texwpervw > 1.0)
+    texwpervw = 1.0;
+
+  texhpervh = (GLdouble) text_height / (GLdouble) visual_height;
+  if (texhpervh > 1.0)
+    texhpervh = 1.0;
+
+  texgrid = (struct TexSquare *)
+    calloc (texnumx * texnumy, sizeof (struct TexSquare));
+
+  line_1 = (unsigned char *) bitmap->line[visual.min_y];
+  line_2 = (unsigned char *) bitmap->line[visual.min_y + 1];
+
+  raw_line_len = line_2 - line_1;
+
+  if (blit_swapxy)
+    line_len = ((Machine->drv->screen_height + 7) & ~7) + 2 * BITMAP_SAFETY;
+  else
+    line_len = ((Machine->drv->screen_width + 7) & ~7) + 2 * BITMAP_SAFETY;
+
+  /* multiply line length by pixel size in bytes */
+  if (Machine->color_depth == 15 || Machine->color_depth == 16)
+    line_len *= 2;
+  else if (Machine->color_depth == 32)
+    line_len *= 4;
+
+  memory_x_len = raw_line_len / bytes_per_pixel;
+
+  fprintf (stderr, "GLINFO: line_len = %d, raw_line_len= %d\n",
+  	line_len, raw_line_len);
+
+  fprintf (stderr, "GLINFO: texture-usage %d*width=%d, %d*height=%d\n",
+		 (int) texnumx, (int) text_width, (int) texnumy,
+		 (int) text_height);
+
+  /*
+   * JAU vecgames: hw-access error, while using Machine bitmap (e.g. tac-scan) !!
+   * vegames only ... ?!?!?!?!
+   */
+  if(useColorBlitter) 
+  {
+    colorBlittedMemory = malloc( (text_width+2*BITMAP_SAFETY)*texnumx*
+                                 (text_height+2*BITMAP_SAFETY)*texnumy*
+				 bytes_per_pixel);
+    line_1 = colorBlittedMemory;
+  }
+
+  for (y = 0; y < texnumy; y++)
+  {
+    for (x = 0; x < texnumx; x++)
+    {
+      tsq = texgrid + y * texnumx + x;
+
+      if (x == texnumx - 1 && visual_width % text_width)
+	tsq->xcov =
+	  (GLdouble) (visual_width % text_width) / (GLdouble) text_width;
+      else
+	tsq->xcov = 1.0;
+
+      if (y == texnumy - 1 && visual_height % text_height)
+	tsq->ycov =
+	  (GLdouble) (visual_height % text_height) / (GLdouble) text_height;
+      else
+	tsq->ycov = 1.0;
+
+      CalcFlatTexPoint (x, y, texwpervw, texhpervh, &(tsq->fx1), &(tsq->fy1));
+      CalcFlatTexPoint (x + 1, y, texwpervw, texhpervh, &(tsq->fx2), &(tsq->fy2));
+      CalcFlatTexPoint (x + 1, y + 1, texwpervw, texhpervh, &(tsq->fx3), &(tsq->fy3));
+      CalcFlatTexPoint (x, y + 1, texwpervw, texhpervh, &(tsq->fx4), &(tsq->fy4));
+
+      CalcCabPointbyViewpoint( x*(GLdouble)text_width,
+      		    y*(GLdouble)text_height,
+                   &(tsq->x1), &(tsq->y1), &(tsq->z1));
+
+      CalcCabPointbyViewpoint( x*(GLdouble)text_width  + tsq->xcov*(GLdouble)text_width,
+      		    y*(GLdouble)text_height,
+                   &(tsq->x2), &(tsq->y2), &(tsq->z2));
+
+      CalcCabPointbyViewpoint( x*(GLdouble)text_width  + tsq->xcov*(GLdouble)text_width,
+      		    y*(GLdouble)text_height + tsq->ycov*(GLdouble)text_height,
+                   &(tsq->x3), &(tsq->y3), &(tsq->z3));
+
+      CalcCabPointbyViewpoint( x*(GLdouble)text_width,
+      		    y*(GLdouble)text_height + tsq->ycov*(GLdouble)text_height,
+                   &(tsq->x4), &(tsq->y4), &(tsq->z4));
+
+      /* calculate the pixel store data,
+         to use the machine-bitmap for our texture 
+      */
+      memory_x_start_offset = visual.min_x * bytes_per_pixel + 
+                              x * text_width * bytes_per_pixel;
+
+      tsq->texture = line_1 +                           
+		     y * text_height * raw_line_len +  
+		     memory_x_start_offset;           
+
+      #ifndef NDEBUG
+      if (x == 0 && y == 0)
+      {
+	fprintf(stderr, "Machine bitmap: w=%d, h=%d, d=%d,\n\trowpixels=%d, rowbytes=%d\n",
+		Machine->scrbitmap->width,  Machine->scrbitmap->height, 
+		Machine->scrbitmap->depth,
+		Machine->scrbitmap->rowpixels, Machine->scrbitmap->rowbytes);
+
+	fprintf(stderr, "bitmap: w=%d, h=%d, d=%d,\n\trowpixels=%d, rowbytes=%d\n",
+		bitmap->width,  bitmap->height, 
+		bitmap->depth,
+		bitmap->rowpixels, bitmap->rowbytes);
+
+
+	fprintf (stderr, "visual (min_x=%d / min_y=%d)\n",
+		 visual.min_x, visual.min_y);
+
+	fprintf (stderr, "visual (w=%d / h=%d)\n",
+		 visual_width, visual_height);
+
+	fprintf (stderr, "win (w=%d / h=%d)\n", winwidth, winheight);
+
+	fprintf (stderr, "game (w=%d / h=%d)\n",
+		 Machine->drv->default_visible_area.max_x -
+		 Machine->drv->default_visible_area.min_x + 1,
+		 Machine->drv->default_visible_area.max_y -
+		 Machine->drv->default_visible_area.min_y + 1);
+
+	fprintf (stderr, "texture-usage x=%f%% y=%f%%\n",
+		 texwpervw, texhpervh);
+
+	fprintf (stderr,
+		 "row_len=%d, x_ofs=%d, bytes_per_pixel=%d\n",
+		 (int) memory_x_len, (int) memory_x_start_offset,
+		 (int) bytes_per_pixel);
+
+	fflush(stderr);
+      }
+      fprintf (stderr, "\t texture mem %p\n", tsq->texture);
+      fflush(stderr);
+
+      #endif
+
+      tsq->isTexture=GL_FALSE;
+      tsq->texobj=0;
+
+      tsq->dirtyXoff=0; tsq->dirtyYoff=0; 
+      if (use_dirty)
+      {
+	      tsq->isDirty=GL_FALSE;
+	      tsq->dirtyWidth=-1; tsq->dirtyHeight=-1;
+      } else {
+	      tsq->isDirty=GL_TRUE;
+	      tsq->dirtyWidth=text_width; tsq->dirtyHeight=text_height;
+      }
+
+      disp__glGenTextures (1, &(tsq->texobj));
+
+      disp__glBindTexture (GL_TEXTURE_2D, tsq->texobj);
+      err = disp__glGetError ();
+      if(err==GL_INVALID_ENUM)
+      {
+	fprintf (stderr, "GLERROR glBindTexture (glGenText) := GL_INVALID_ENUM, texnum x=%d, y=%d, texture=%d\n", x, y, tsq->texobj);
+      } 
+      #ifndef NDEBUG
+	      else if(err==GL_INVALID_OPERATION) {
+		fprintf (stderr, "GLERROR glBindTexture (glGenText) := GL_INVALID_OPERATION, texnum x=%d, y=%d, texture=%d\n", x, y, tsq->texobj);
+	      }
+      #endif
+
+      if(disp__glIsTexture(tsq->texobj) == GL_FALSE)
+      {
+	fprintf (stderr, "GLERROR ain't a texture (glGenText): texnum x=%d, y=%d, texture=%d\n",
+		x, y, tsq->texobj);
+      } else {
+        tsq->isTexture=GL_TRUE;
+      }
+
+      CHECK_GL_ERROR ();
+
+      if(useColorIndex)
+      {
+	      if (useGLEXT78)
+	      {
+		  disp__glColorTableEXT (GL_TEXTURE_2D,
+				     gl_ctable_format,
+				     ctable_size, gl_ctable_format, 
+				     /*gl_ctable_type, ctable); JAU COLOR */
+				     gl_ctable_type, current_palette->lookup);
+
+		  CHECK_GL_ERROR ();
+	      }
+	      else
+	      {
+		disp__glPixelMapusv (GL_PIXEL_MAP_I_TO_R, ctable_size, rcolmap);
+		disp__glPixelMapusv (GL_PIXEL_MAP_I_TO_G, ctable_size, gcolmap);
+		disp__glPixelMapusv (GL_PIXEL_MAP_I_TO_B, ctable_size, bcolmap);
+		if (alphablending)
+		  disp__glPixelMapusv (GL_PIXEL_MAP_I_TO_A, ctable_size, acolmap);
+
+		CHECK_GL_ERROR ();
+	      }
+      }
+
+      disp__glTexImage2D (GL_TEXTURE_2D, 0,
+		    gl_internal_format,
+		    text_width, text_height,
+		    0, gl_bitmap_format, gl_bitmap_type, tsq->texture);
+
+      CHECK_GL_ERROR ();
+
+      disp__glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_PRIORITY, 1.0);
+
+      CHECK_GL_ERROR ();
+
+      disp__glTexParameteri (GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
+      disp__glTexParameteri (GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
+
+      disp__glTexParameteri (GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP);
+      disp__glTexParameteri (GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP);
+
+      disp__glTexEnvf (GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE);
+
+      CHECK_GL_ERROR ();
+    }	/* for all texnumx */
+  }  /* for all texnumy */
+
+  gl_is_initialized = 1;
+
+  CHECK_GL_BEGINEND();
+
+  /* lets init the rest of the custumizings ... */
+  gl_set_bilinear (bilinear);
+  gl_set_antialias (antialias);
+  gl_set_alphablending (alphablending);
+  gl_set_cabview (cabview);
+
+  CHECK_GL_BEGINEND();
+
+  CHECK_GL_ERROR ();
+}
+
+
+/**
+ * returns the length of the |(x,y,z)-(i,j,k)|
+ */
+GLdouble
+CompareVec (GLdouble i, GLdouble j, GLdouble k,
+	    GLdouble x, GLdouble y, GLdouble z)
+{
+  GLdouble dx = x-i;
+  GLdouble dy = y-j;
+  GLdouble dz = z-k;
+
+  return LengthOfVec(dx, dy, dz);
+}
+
+void
+AddToThisVec (GLdouble i, GLdouble j, GLdouble k,
+	      GLdouble * x, GLdouble * y, GLdouble * z)
+{
+  *x += i ;
+  *y += j ;
+  *z += k ;
+}
+
+/**
+ * TranslatePointInPlane:
+ *
+ * v__p = v__p1 + 
+ *        x_off * v__nw +
+ *        y_off * v__nh;
+ */
+void
+TranslatePointInPlane   (
+	      GLdouble vx_p1, GLdouble vy_p1, GLdouble vz_p1,
+	      GLdouble vx_nw, GLdouble vy_nw, GLdouble vz_nw,
+	      GLdouble vx_nh, GLdouble vy_nh, GLdouble vz_nh,
+	      GLdouble x_off, GLdouble y_off,
+	      GLdouble *vx_p, GLdouble *vy_p, GLdouble *vz_p )
+{
+   GLdouble tx, ty, tz;
+
+   CopyVec( vx_p, vy_p, vz_p,
+            vx_p1, vy_p1, vz_p1); 
+
+   CopyVec( &tx, &ty, &tz,
+	    vx_nw, vy_nw, vz_nw);
+
+   ScaleThisVec (x_off, x_off, x_off,
+                 &tx, &ty, &tz);
+
+   AddToThisVec (tx, ty, tz,
+                 vx_p, vy_p, vz_p);
+
+   CopyVec( &tx, &ty, &tz,
+	    vx_nh, vy_nh, vz_nh);
+
+   ScaleThisVec (y_off, y_off, y_off,
+                 &tx, &ty, &tz);
+
+   AddToThisVec (tx, ty, tz,
+                 vx_p, vy_p, vz_p);
+}
+
+void
+ScaleThisVec (GLdouble i, GLdouble j, GLdouble k,
+	      GLdouble * x, GLdouble * y, GLdouble * z)
+{
+  *x *= i ;
+  *y *= j ;
+  *z *= k ;
+}
+
+GLdouble
+LengthOfVec (GLdouble x, GLdouble y, GLdouble z)
+{
+  return sqrt(x*x+y*y+z*z);
+}
+
+void
+NormThisVec (GLdouble * x, GLdouble * y, GLdouble * z)
+{
+  double len = LengthOfVec (*x, *y, *z);
+
+  *x /= len ;
+  *y /= len ;
+  *z /= len ;
+}
+
+/* Compute a delta vector between two points */
+
+void
+DeltaVec (GLdouble x1, GLdouble y1, GLdouble z1,
+	  GLdouble x2, GLdouble y2, GLdouble z2,
+	  GLdouble * dx, GLdouble * dy, GLdouble * dz)
+{
+  *dx = x2 - x1;
+  *dy = y2 - y1;
+  *dz = z2 - z1;
+}
+
+/* Compute a crossproduct vector of two vectors ( plane ) */
+
+void
+CrossVec (GLdouble a1, GLdouble a2, GLdouble a3,
+	  GLdouble b1, GLdouble b2, GLdouble b3,
+	  GLdouble * c1, GLdouble * c2, GLdouble * c3)
+{
+  *c1 = a2*b3 - a3*b2; 
+  *c2 = a3*b1 - a1*b3;
+  *c3 = a1*b2 - a1*b1;
+}
+
+void CopyVec(GLdouble *ax,GLdouble *ay,GLdouble *az,                   /* dest   */
+	          const GLdouble bx,const GLdouble by,const GLdouble bz     /* source */
+                  )
+{
+	*ax=bx;
+	*ay=by;
+	*az=bz;
+}
+
+void SwapVec(GLdouble *ax,GLdouble *ay,GLdouble *az,
+	          GLdouble *bx,GLdouble *by,GLdouble *bz
+                  )
+{
+	GLdouble t;
+
+	t= *ax; *ax=*bx; *bx=t;
+	t= *ay; *ay=*by; *by=t;
+	t= *az; *ax=*bz; *bz=t;
+}
+
+
+/**
+ * Calculate texture points (world) for flat screen 
+ *
+ * x,y: 
+ * 	texture index (scalar)
+ *	
+ * texwpervw, texhpervh:
+ * 	how much the texture covers the visual,
+ * 	for both components (width/height) (percent).
+ *
+ * px,py,pz:
+ * 	the resulting cabinet point
+ *
+ */
+void CalcFlatTexPoint( int x, int y, GLdouble texwpervw, GLdouble texhpervh, 
+		       GLdouble *px,GLdouble *py)
+{
+  *px=(double)x*texwpervw;
+  if(*px>1.0) *px=1.0;
+  *py=(double)y*texhpervh;
+  if(*py>1.0) *py=1.0;
+}
+
+/**
+ * vx_gscr,vy_gscr:
+ * 	world-corrd within game-screen
+ *
+ * vx_p,vy_p,vz_p: 
+ * 	world-coord within cab-screen
+ */
+void CalcCabPointbyWorldpoint( 
+		   GLdouble vx_gscr, GLdouble vy_gscr, 
+                   GLdouble *vx_p, GLdouble *vy_p, GLdouble *vz_p
+		 )
+{
+   /**
+    * v__p  = v__gscr_p1  + vx_gscr * v__scr_nx + vy_gscr * v__scr_ny ;
+    */
+
+   TranslatePointInPlane ( vx_gscr_p1, vy_gscr_p1, vz_gscr_p1,
+                           vx_scr_nx, vy_scr_nx, vz_scr_nx,
+			   vx_scr_ny, vy_scr_ny, vz_scr_ny,
+			   vx_gscr, vy_gscr,
+			   vx_p, vy_p, vz_p);
+}
+
+/**
+ * vx_gscr_view,vy_gscr_view:
+ * 	view-corrd within game-screen
+ *
+ * vx_p,vy_p,vz_p: 
+ * 	world-coord within cab-screen
+ */
+void CalcCabPointbyViewpoint( 
+		   GLdouble vx_gscr_view, GLdouble vy_gscr_view, 
+                   GLdouble *vx_p, GLdouble *vy_p, GLdouble *vz_p
+		 )
+{
+  GLdouble vx_gscr = (GLdouble)vx_gscr_view/cab_vpw_fx;
+  GLdouble vy_gscr = (GLdouble)vy_gscr_view/cab_vpw_fy;
+
+   /**
+    * v__p  = v__gscr_p1  + vx_gscr * v__scr_nx + vy_gscr * v__scr_ny ;
+    */
+
+   TranslatePointInPlane ( vx_gscr_p1, vy_gscr_p1, vz_gscr_p1,
+                           vx_scr_nx, vy_scr_nx, vz_scr_nx,
+			   vx_scr_ny, vy_scr_ny, vz_scr_ny,
+			   vx_gscr, vy_gscr,
+			   vx_p, vy_p, vz_p);
+}
+
+/* Set up a frustum projection */
+
+void
+SetupFrustum (void)
+{
+  CHECK_GL_BEGINEND();
+
+  disp__glMatrixMode (GL_PROJECTION);
+  disp__glLoadIdentity ();
+
+  if(!do_snapshot)
+	  disp__glFrustum (-vscrnaspect, vscrnaspect, -1.0, 1.0, 5.0, 100.0);
+  else
+	  disp__glFrustum (-vscrnaspect, vscrnaspect, 1.0, -1.0, 5.0, 100.0);
+
+  CHECK_GL_ERROR ();
+
+  disp__glGetDoublev(GL_PROJECTION_MATRIX, mxProjection);
+  CHECK_GL_ERROR ();
+
+  disp__glMatrixMode (GL_MODELVIEW);
+  disp__glLoadIdentity ();
+  disp__glTranslatef (0.0, 0.0, -20.0);
+
+  disp__glGetDoublev(GL_MODELVIEW_MATRIX, mxModel);
+  CHECK_GL_ERROR ();
+}
+
+
+/* Set up an orthographic projection */
+
+void SetupOrtho (void)
+{
+  CHECK_GL_BEGINEND();
+
+  disp__glMatrixMode (GL_PROJECTION);
+  disp__glLoadIdentity ();
+
+  if(!do_snapshot)
+  {
+	  disp__glOrtho (-0.5,  0.5, -0.5,  0.5,  1.0,  -1.0); /* normal display ! */
+  } else {
+	  disp__glOrtho (-0.5,  0.5,  0.5, -0.5,  1.0,  -1.0); /* normal display ! */
+  }
+
+  disp__glMatrixMode (GL_MODELVIEW);
+  disp__glLoadIdentity ();
+
+  disp__glRotated ( 180.0 , 1.0, 0.0, 0.0);
+
+  if ( blit_flipx )
+	disp__glRotated (  180.0 , 0.0, 1.0, 0.0);
+
+  if ( blit_flipy )
+	disp__glRotated ( -180.0 , 1.0, 0.0, 0.0);
+
+  if( blit_swapxy ) {
+	disp__glRotated ( 180.0 , 0.0, 1.0, 0.0);
+  	disp__glRotated (  90.0 , 0.0, 0.0, 1.0 );
+  }
+
+  disp__glTranslated ( -0.5 , -0.5, 0.0 );
+  	
+}
+
+/* Set up the virtual screen */
+
+static void SetWindowRatio()
+{
+  /**
+   *
+   * Flat-Screen Ratio:
+   *
+   * scrnaspect : orig screen width/height ratio (view-coord)
+   * vscrnaspect: zoomed screen width/height ratio (view-coord)
+   * vscrnwidth : final screen width (view-coord)
+   * vscrnheight: final screen height (view-coord)
+   * vscrndx: 	  final screen dx to start of game-screen (view-coord)
+   * vscrndy: 	  final screen dy to start of game-screen (view-coord)
+   *
+   */
+
+  scrnaspect = (double) visual_orientated_width / (double) visual_orientated_height;
+  vscrnaspect = (double) winwidth / (double) winheight;
+
+  if (scrnaspect < vscrnaspect)
+  {
+    vscrnheight = (GLdouble) winheight;
+    vscrnwidth = vscrnheight * scrnaspect;
+    vscrndx = ((GLdouble) winwidth - vscrnwidth) / 2.0;
+    vscrndy = 0.0;
+  }
+  else
+  {
+    vscrnwidth = (GLdouble) winwidth;
+    vscrnheight = vscrnwidth / scrnaspect;
+    vscrndx = 0.0;
+    vscrndy = ((GLdouble) winheight - vscrnheight) / 2.0;
+  }
+
+#ifndef NDEBUG
+	fprintf (stderr, "GLINFO: SetWindowRatio: win (%dx%d), visual (%dx%d)\n",
+		winwidth, winheight, visual_orientated_width, visual_orientated_height);
+	fprintf (stderr, "\t vscrnwidth %f, vscrnheight %f\n",
+		vscrnwidth, vscrnheight);
+	fprintf (stderr, "\t x-diff %f, y-diff %f\n",
+		(double)winwidth - vscrnwidth, (double)winheight - vscrnheight);
+	fprintf (stderr, "\t scrnaspect=%f, vscrnaspect=%f\n",
+		scrnaspect, vscrnaspect);
+	fflush(stderr);
+#endif
+}
+
+void xgl_fixaspectratio(int *w, int *h)
+{
+	vscrnaspect = (double) *w / (double) *h;
+
+	if (scrnaspect < vscrnaspect)
+		*w = *h * scrnaspect;
+	else
+		*h= *w / scrnaspect;
+}
+
+void xgl_resize(int w, int h, int now)
+{
+  winheight= h;
+  winwidth = w;
+
+  if(!now)
+  {
+	do_xgl_resize=1;
+	return;
+  }
+
+  do_xgl_resize=0;
+
+  CHECK_GL_BEGINEND();
+
+  if (glContext!=NULL)
+  {
+	SetWindowRatio();
+
+	if (cabview)
+		disp__glViewport (0, 0, winwidth, winheight);
+	else
+		disp__glViewport ((int)(vscrndx+0.5), (int)(vscrndy+0.5),
+		            (int)(vscrnwidth+0.5), (int)(vscrnheight+0.5));
+
+/*
+		disp__glViewport (0, 0, winwidth, winheight);
+			    */
+
+        disp__glGetIntegerv(GL_VIEWPORT, dimView);
+
+	if (cabview)
+		SetupFrustum ();
+	else
+		SetupOrtho ();
+
+	fprintf(stderr, "GLINFO: xgl_resize to %dx%d\n", winwidth, winheight);
+	fflush(stderr);
+  }
+}
+
+/* Compute an average between two sets of 3D coordinates */
+
+void
+WAvg (GLdouble perc, GLdouble x1, GLdouble y1, GLdouble z1,
+      GLdouble x2, GLdouble y2, GLdouble z2,
+      GLdouble * ax, GLdouble * ay, GLdouble * az)
+{
+  *ax = (1.0 - perc) * x1 + perc * x2;
+  *ay = (1.0 - perc) * y1 + perc * y2;
+  *az = (1.0 - perc) * z1 + perc * z2;
+}
+
+void gl_dirty_init(void)
+{
+	printf ("GLINFO: dirty strategie on!\n");
+}
+
+void gl_dirty_close(void)
+{
+	printf ("GLINFO: dirty strategie off!\n");
+}
+
+void gl_mark_dirty(int x, int y, int x2, int y2)
+{
+	struct TexSquare *square;
+	int xi, yi, wd, ht, wh, hh;
+	int wdecr, hdecr, xh, yh;
+	int w = (x2-x)+1;
+	int h = (y2-y)+1;
+
+	screendirty = 1;
+
+	if (!use_dirty)
+		return;
+
+	wdecr=w; hdecr=h; xh=x; yh=y;
+
+	for (yi = 0; hdecr>0 && yi < texnumy; yi++)
+	{
+	    if (yi < texnumy - 1)
+	      ht = text_height;
+	    else
+	      ht = visual_height - text_height * yi;
+
+	    xh =x;
+	    wdecr =w;
+
+	    for (xi = 0; wdecr>0 && xi < texnumx; xi++)
+	    {
+		square = texgrid + yi * texnumx + xi;
+
+		if (xi < texnumx - 1)
+		  wd = text_width;
+		else
+		  wd = visual_width - text_width * xi;
+
+		if( 0 <= xh && xh < wd &&
+		    0 <= yh && yh < ht
+		  )
+		{
+			square->isDirty=GL_TRUE;
+
+			wh=(wdecr<wd)?wdecr:wd-xh;
+			if(wh<0) wh=0;
+
+			hh=(hdecr<ht)?hdecr:ht-yh;
+			if(hh<0) hh=0;
+
+			/*
+			#ifndef NDEBUG
+			     printf("\t %dx%d, %d/%d (%dx%d): %d/%d (%dx%d)\n", 
+				xi, yi, xh, yh, wdecr, hdecr, xh, yh, wh, hh);
+			#endif
+			*/
+
+			if(xh<square->dirtyXoff)
+				square->dirtyXoff=xh;
+
+			if(yh<square->dirtyYoff)
+				square->dirtyYoff=yh;
+
+			square->dirtyWidth = wd-square->dirtyXoff;
+			square->dirtyHeight = ht-square->dirtyYoff;
+			
+			wdecr-=wh;
+
+			if ( xi == texnumx - 1 )
+				hdecr-=hh;
+		}
+
+		xh-=wd;
+		if(xh<0) xh=0;
+	    }
+	    yh-=ht;
+	    if(yh<0) yh=0;
+       }
+}
+
+
+void drawGameAxis ()
+{
+  GLdouble tx, ty, tz;
+
+	disp__glPushMatrix ();
+
+	disp__glLineWidth(1.5f);
+	disp__glBegin(GL_LINES);
+
+	/** x-axis **/
+	disp__glColor3d (1.0,1.0,1.0);
+	disp__glVertex3d(0,0,0);
+
+	disp__glColor3d (1.0,0.0,0.0);
+        CopyVec( &tx, &ty, &tz,
+	         vx_scr_nx, vy_scr_nx, vz_scr_nx);
+        ScaleThisVec ( 5.0, 5.0, 5.0, &tx, &ty, &tz);
+	disp__glVertex3d( tx, ty, tz );
+
+
+	/** y-axis **/
+	disp__glColor3d (1.0,1.0,1.0);
+	disp__glVertex3d(0,0,0);
+
+	disp__glColor3d (0.0,1.0,0.0);
+        CopyVec( &tx, &ty, &tz,
+	         vx_scr_ny, vy_scr_ny, vz_scr_ny);
+        ScaleThisVec ( 5.0, 5.0, 5.0, &tx, &ty, &tz);
+	disp__glVertex3d( tx, ty, tz );
+
+
+	/** z-axis **/
+	disp__glColor3d (1.0,1.0,1.0);
+	disp__glVertex3d(0,0,0);
+
+	disp__glColor3d (0.0,0.0,1.0);
+        CopyVec( &tx, &ty, &tz,
+	         vx_scr_nz, vy_scr_nz, vz_scr_nz);
+        ScaleThisVec ( 5.0, 5.0, 5.0, &tx, &ty, &tz);
+	disp__glVertex3d( tx, ty, tz );
+
+	disp__glEnd();
+
+	disp__glPopMatrix ();
+	disp__glColor3d (1.0,1.0,1.0);
+        CHECK_GL_ERROR ();
+}
+
+
+void cabinetTextureRotationTranslation ()
+{
+	/**
+	 * Be aware, this matrix is written in reverse logical
+	 * order of GL commands !
+	 *
+	 * This is the way OpenGL stacks does work !
+	 *
+	 * So if you interprete this code,
+	 * you have to start from the bottom from this block !!
+	 *
+	 * !!!!!!!!!!!!!!!!!!!!!!
+	 */
+
+	/** END  READING ... TRANSLATION / ROTATION **/
+
+	/* go back on screen */
+	disp__glTranslated ( vx_gscr_p1, vy_gscr_p1, vz_gscr_p1); 
+
+	/* x-border -> I. Q */
+	disp__glTranslated ( vx_gscr_dw/2.0, vy_gscr_dw/2.0, vz_gscr_dw/2.0);
+
+	/* y-border -> I. Q */
+	disp__glTranslated ( vx_gscr_dh/2.0, vy_gscr_dh/2.0, vz_gscr_dh/2.0);
+
+	/********* CENTERED AT ORIGIN END  ****************/
+
+	if ( blit_flipx )
+		disp__glRotated ( -180.0 , vx_scr_ny, vy_scr_ny, vz_scr_ny);
+
+	if ( blit_flipy )
+		disp__glRotated ( -180.0 , vx_scr_nx, vy_scr_nx, vz_scr_nx);
+
+
+
+	/********* CENTERED AT ORIGIN BEGIN ****************/
+
+	if( blit_swapxy )
+	{
+		disp__glRotated ( -180.0 , vx_scr_ny, vy_scr_ny, vz_scr_ny);
+
+		/* x-center */
+		disp__glTranslated ( vx_gscr_dw/2.0, vy_gscr_dw/2.0, vz_gscr_dw/2.0);
+
+		/* y-center */
+		disp__glTranslated ( vx_gscr_dh/2.0, vy_gscr_dh/2.0, vz_gscr_dh/2.0);
+
+		/* swap -> III. Q */
+		disp__glRotated ( -90.0 , vx_scr_nz, vy_scr_nz, vz_scr_nz);
+	} else {
+		/* x-center */
+		disp__glTranslated ( -vx_gscr_dw/2.0, -vy_gscr_dw/2.0, -vz_gscr_dw/2.0);
+
+		/* y-center */
+		disp__glTranslated ( vx_gscr_dh/2.0, vy_gscr_dh/2.0, vz_gscr_dh/2.0);
+	}
+
+	/* re-flip -> IV. Q     (normal) */
+	disp__glRotated ( 180.0 , vx_scr_nx, vy_scr_nx, vz_scr_nx);
+
+	/* go to origin -> I. Q (flipx) */
+	disp__glTranslated ( -vx_gscr_p1, -vy_gscr_p1, -vz_gscr_p1); 
+
+	/** START READING ... TRANSLATION / ROTATION **/
+}
+
+
+void
+drawTextureDisplay (struct mame_bitmap *bitmap, int useCabinet, int updateTexture)
+{
+  struct TexSquare *square;
+  int x = 0, y = 0;
+  GLenum err;
+  static const double z_pos = 0.9f;
+
+  if(gl_is_initialized == 0)
+  	return;
+
+  CHECK_GL_BEGINEND();
+
+  if (updateTexture)
+  {
+    disp__glPixelStorei (GL_UNPACK_ROW_LENGTH, memory_x_len);
+    disp__glPixelStorei (GL_UNPACK_ALIGNMENT, 8);
+    if (!useGLEXT78 && useColorIndex)
+    	disp__glPixelTransferi (GL_MAP_COLOR, GL_TRUE);
+
+    if(useColorBlitter)  /* JAU vecgames .. hw_access error .. */
+    {
+	if(bytes_per_pixel==2)
+		gl_update_16_to_16bpp(bitmap);
+	else if(bytes_per_pixel==4)
+		gl_update_32_to_32bpp(bitmap);
+	else {
+		printf("GLERROR: blitter mode only for 8bpp, 16bpp and 32bpp !\n");
+		exit(1);
+	}
+    }
+  }
+
+  disp__glEnable (GL_TEXTURE_2D);
+
+  for (y = 0; y < texnumy; y++)
+  {
+    for (x = 0; x < texnumx; x++)
+    {
+      square = texgrid + y * texnumx + x;
+
+      if(square->isTexture==GL_FALSE)
+      {
+	#ifndef NDEBUG
+	  fprintf (stderr, "GLINFO ain't a texture(update): texnum x=%d, y=%d, texture=%d\n",
+	  	x, y, square->texobj);
+	#endif
+        continue;
+      }
+
+      disp__glBindTexture (GL_TEXTURE_2D, square->texobj);
+      err = disp__glGetError ();
+      if(err==GL_INVALID_ENUM)
+      {
+	fprintf (stderr, "GLERROR glBindTexture := GL_INVALID_ENUM, texnum x=%d, y=%d, texture=%d\n", x, y, square->texobj);
+      }
+      #ifndef NDEBUG
+	      else if(err==GL_INVALID_OPERATION) {
+		fprintf (stderr, "GLERROR glBindTexture := GL_INVALID_OPERATION, texnum x=%d, y=%d, texture=%d\n", x, y, square->texobj);
+	      }
+      #endif
+
+      if(disp__glIsTexture(square->texobj) == GL_FALSE)
+      {
+        square->isTexture=GL_FALSE;
+	fprintf (stderr, "GLERROR ain't a texture(update): texnum x=%d, y=%d, texture=%d\n",
+		x, y, square->texobj);
+      }
+
+      if (current_palette->dirty && useColorIndex)
+      {
+
+	if (useGLEXT78)
+	{
+	    disp__glColorTableEXT (GL_TEXTURE_2D, gl_ctable_format,
+			       ctable_size, gl_ctable_format, 
+			       /*gl_ctable_type, ctable); JAU COLOR */
+			       gl_ctable_type, current_palette->lookup);
+	}
+	else
+	{
+	  disp__glPixelMapusv (GL_PIXEL_MAP_I_TO_R, ctable_size, rcolmap);
+	  disp__glPixelMapusv (GL_PIXEL_MAP_I_TO_G, ctable_size, gcolmap);
+	  disp__glPixelMapusv (GL_PIXEL_MAP_I_TO_B, ctable_size, bcolmap);
+	  if (alphablending)
+	    disp__glPixelMapusv (GL_PIXEL_MAP_I_TO_A, ctable_size, acolmap);
+	}
+      }
+
+      /* This is the quickest way I know of to update the texture */
+      if (updateTexture && square->isDirty)
+      {
+	disp__glTexSubImage2D (GL_TEXTURE_2D, 0, 
+		square->dirtyXoff, square->dirtyYoff,
+		square->dirtyWidth, square->dirtyHeight,
+		gl_bitmap_format, gl_bitmap_type, square->texture);
+
+	square->dirtyXoff=0; square->dirtyYoff=0;
+
+	if (use_dirty)
+	{
+	      square->isDirty=GL_FALSE;
+	      square->dirtyWidth=-1; square->dirtyHeight=-1;
+        } else {
+	      square->isDirty=GL_TRUE;
+	}
+      }
+
+      if (useCabinet)
+      {
+  	GL_BEGIN(GL_QUADS);
+	disp__glTexCoord2d (0, 0);
+	disp__glVertex3d (square->x1, square->y1, square->z1);
+	disp__glTexCoord2d (square->xcov, 0);
+	disp__glVertex3d (square->x2, square->y2, square->z2);
+	disp__glTexCoord2d (square->xcov, square->ycov);
+	disp__glVertex3d (square->x3, square->y3, square->z3);
+	disp__glTexCoord2d (0, square->ycov);
+	disp__glVertex3d (square->x4, square->y4, square->z4);
+	GL_END();
+      }
+      else
+      {
+	GL_BEGIN(GL_QUADS);
+	disp__glTexCoord2d (0, 0);
+	disp__glVertex3d (square->fx1, square->fy1, z_pos);
+	disp__glTexCoord2d (square->xcov, 0);
+	disp__glVertex3d (square->fx2, square->fy2, z_pos);
+	disp__glTexCoord2d (square->xcov, square->ycov);
+	disp__glVertex3d (square->fx3, square->fy3, z_pos);
+	disp__glTexCoord2d (0, square->ycov);
+	disp__glVertex3d (square->fx4, square->fy4, z_pos);
+	GL_END();
+      }
+    } /* for all texnumx */
+  } /* for all texnumy */
+
+  if (updateTexture)
+  {
+    disp__glPixelStorei (GL_UNPACK_ROW_LENGTH, 0);
+    disp__glPixelStorei (GL_UNPACK_ALIGNMENT, 4);
+    disp__glPixelTransferi (GL_MAP_COLOR, GL_FALSE);
+  }
+
+  disp__glDisable (GL_TEXTURE_2D);
+
+  CHECK_GL_BEGINEND();
+
+  /* YES - lets catch this error ... 
+   */
+  (void) disp__glGetError ();
+}
+
+/* Draw a frame in Cabinet mode */
+
+void UpdateCabDisplay (struct mame_bitmap *bitmap)
+{
+  int glerrid;
+  int shadeModel;
+  GLdouble camx, camy, camz;
+  GLdouble dirx, diry, dirz;
+  GLdouble normx, normy, normz;
+  GLdouble perc;
+  struct CameraPan *pan, *lpan;
+
+  if (gl_is_initialized == 0)
+    return;
+
+  CHECK_GL_BEGINEND();
+
+  disp__glClear (GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
+
+  CHECK_GL_ERROR ();
+
+  disp__glPushMatrix ();
+
+
+  /* Do the camera panning */
+
+  if (cpan)
+  {
+    pan = cpan + currentpan;
+
+/*
+    printf("GLINFO (glcab): pan %d/%d panframe %d/%d\n", 
+    	currentpan, numpans, panframe, pan->frames);
+*/
+
+    if (0 >= panframe || panframe >= pan->frames)
+    {
+      lastpan = currentpan;
+      currentpan += 1;
+      if(currentpan>=numpans) currentpan=1;
+      panframe = 0;
+/*
+      printf("GLINFO (glcab): finished pan %d/%d\n", currentpan, numpans);
+*/
+    }
+
+    switch (pan->type)
+    {
+    case pan_goto:
+      camx = pan->lx;
+      camy = pan->ly;
+      camz = pan->lz;
+      dirx = pan->px;
+      diry = pan->px;
+      dirz = pan->pz;
+      normx = pan->nx;
+      normy = pan->ny;
+      normz = pan->nz;
+      break;
+    case pan_moveto:
+      lpan = cpan + lastpan;
+      perc = (GLdouble) panframe / (GLdouble) pan->frames;
+      WAvg (perc, lpan->lx, lpan->ly, lpan->lz,
+	    pan->lx, pan->ly, pan->lz, &camx, &camy, &camz);
+      WAvg (perc, lpan->px, lpan->py, lpan->pz,
+	    pan->px, pan->py, pan->pz, &dirx, &diry, &dirz);
+      WAvg (perc, lpan->nx, lpan->ny, lpan->nz,
+	    pan->nx, pan->ny, pan->nz, &normx, &normy, &normz);
+      break;
+    default:
+      break;
+    }
+
+    disp__gluLookAt (camx, camy, camz, dirx, diry, dirz, normx, normy, normz);
+
+    panframe++;
+  }
+  else
+    disp__gluLookAt (-5.0, 0.0, 5.0, 0.0, 0.0, -5.0, 0.0, 1.0, 0.0);
+
+  disp__glEnable (GL_DEPTH_TEST);
+
+  /* Draw the cabinet */
+  disp__glCallList (cablist);
+
+  /* YES - lets catch this error ... */
+  glerrid = disp__glGetError ();
+  if (0x502 != glerrid)
+  {
+    CHECK_GL_ERROR ();
+  }
+
+  /* Draw the screen if in vector mode */
+
+  cabinetTextureRotationTranslation ();
+
+  if (vecgame)
+  {
+    if (drawbitmap)
+    {
+      disp__glColor4d (1.0, 1.0, 1.0, 1.0);
+
+      drawTextureDisplay (bitmap, 1 /*cabinet */ , screendirty);
+    }
+    disp__glDisable (GL_TEXTURE_2D);
+    disp__glGetIntegerv(GL_SHADE_MODEL, &shadeModel);
+    disp__glShadeModel (GL_FLAT);
+
+    if (antialiasvec)
+    {
+      disp__glEnable (GL_LINE_SMOOTH);
+      disp__glEnable (GL_POINT_SMOOTH);
+    }
+
+    disp__glCallList (veclist);
+
+    if (antialiasvec && !antialias)
+    {
+      disp__glDisable (GL_LINE_SMOOTH);
+      disp__glDisable (GL_POINT_SMOOTH);
+    }
+
+    disp__glShadeModel (shadeModel);
+  }
+  else
+  {				/* Draw the screen of a bitmapped game */
+
+    if (drawbitmap)
+	    drawTextureDisplay (bitmap, 1 /*cabinet */ , screendirty);
+
+  }
+
+  disp__glDisable (GL_DEPTH_TEST);
+
+  disp__glPopMatrix ();
+
+  if (do_snapshot)
+  {
+    gl_save_screen_snapshot();
+    do_snapshot = 0;
+    /* reset upside down .. */
+    xgl_resize(winwidth, winheight, 1);
+  }
+
+  if (doublebuffer)
+  {
+#ifdef WIN32
+    BOOL ret = SwapBuffers (glHDC);
+    if (ret != TRUE)
+    {
+      CHECK_WGL_ERROR (glWnd, __FILE__, __LINE__);
+      doublebuffer = FALSE;
+    }
+#else
+    SwapBuffers ();
+#endif
+  }
+  else
+    disp__glFlush ();
+
+  CHECK_GL_BEGINEND();
+
+  CHECK_GL_ERROR ();
+
+}
+
+void
+UpdateFlatDisplay (struct mame_bitmap *bitmap)
+{
+  int shadeModel;
+
+  if (gl_is_initialized == 0)
+    return;
+
+  CHECK_GL_BEGINEND();
+
+  if (!vecgame || !dopersist)
+    disp__glClear (GL_COLOR_BUFFER_BIT);
+
+  disp__glPushMatrix ();
+
+  CHECK_GL_BEGINEND();
+
+  if (dopersist && vecgame)
+  {
+    disp__glColor4d (0.0, 0.0, 0.0, 0.2);
+
+    GL_BEGIN(GL_QUADS);
+    disp__glVertex2d (0.0, 0.0);
+    disp__glVertex2d ((GLdouble) winwidth, 0.0);
+    disp__glVertex2d ((GLdouble) winwidth, (GLdouble) winheight);
+    disp__glVertex2d (0.0, (GLdouble) winheight);
+    GL_END();
+  }
+
+  CHECK_GL_ERROR ();
+
+
+  disp__glColor4d (1.0, 1.0, 1.0, 1.0);
+
+  if(drawbitmap)
+	  drawTextureDisplay (bitmap, 0, screendirty);
+
+  if (vecgame)
+  {
+    disp__glDisable (GL_TEXTURE_2D);
+    disp__glGetIntegerv(GL_SHADE_MODEL, &shadeModel);
+    disp__glShadeModel (GL_FLAT);
+
+    if (antialiasvec)
+    {
+      disp__glEnable (GL_LINE_SMOOTH);
+      disp__glEnable (GL_POINT_SMOOTH);
+    }
+
+    disp__glCallList (veclist);
+
+    if (antialiasvec && !antialias)
+    {
+      disp__glDisable (GL_LINE_SMOOTH);
+      disp__glDisable (GL_POINT_SMOOTH);
+    }
+
+    disp__glShadeModel (shadeModel);
+
+  }
+
+  CHECK_GL_BEGINEND();
+
+  /* YES - lets catch this error ... 
+   */
+  (void) disp__glGetError ();
+
+  disp__glPopMatrix ();
+
+  CHECK_GL_ERROR ();
+
+  if (do_snapshot)
+  {
+    gl_save_screen_snapshot();
+    do_snapshot = 0;
+    /* reset upside down .. */
+    xgl_resize(winwidth, winheight, 1);
+  }
+
+  if (doublebuffer)
+  {
+#ifdef WIN32
+    BOOL ret = SwapBuffers (glHDC);
+    if (ret != TRUE)
+    {
+      CHECK_WGL_ERROR (glWnd, __FILE__, __LINE__);
+      doublebuffer = FALSE;
+    }
+#else
+    SwapBuffers ();
+#endif
+  }
+  else
+    disp__glFlush ();
+}
+
+/**
+ * the given bitmap MUST be the original mame core bitmap !!!
+ *    - no swapxy, flipx or flipy and no resize !
+ *    - shall be Machine->scrbitmap
+ */
+void UpdateGLDisplayBegin (struct mame_bitmap *bitmap)
+{
+  if ( ! texture_init ) InitTextures (bitmap);
+
+  if (gl_is_initialized == 0)
+    return;
+
+  if (vecgame)
+  {
+#ifdef MESS
+    video_update_vector (NULL, NULL, NULL);
+#else
+    video_update_vector (NULL, NULL);
+#endif
+    CHECK_GL_BEGINEND();
+
+    /**
+     * after this vh_update, everything from vector
+     * (begin/end, list) should be closed ..)
+     */
+  }
+
+  if (do_xgl_resize)
+	xgl_resize(winwidth, winheight, 1);
+
+  /* upside down .. to make a good snapshot ;-) */
+  if (do_snapshot)
+	xgl_resize(winwidth, winheight, 1);
+
+  if (cabview && !cabload_err)
+    UpdateCabDisplay (bitmap);
+  else
+    UpdateFlatDisplay (bitmap);
+
+
+  CHECK_GL_BEGINEND();
+  CHECK_GL_ERROR ();
+}
+
+/**
+ * the given bitmap MUST be the original mame core bitmap !!!
+ *    - no swapxy, flipx or flipy and no resize !
+ *    - shall be Machine->scrbitmap
+ */
+void UpdateGLDisplayEnd (struct mame_bitmap *bitmap)
+{
+  if (vecgame)
+  {
+    vector_clear_list ();
+    /* be aware: a GL_BEGIN was called at last .. */
+  }
+
+  /* screendirty = 0; */
+}
+
+/* used when expose events received */
+
+void
+osd_refresh_screen (void)
+{
+  /* Just re-draw the whole screen */
+  UpdateGLDisplayBegin (NULL);
+  UpdateGLDisplayEnd (NULL);
+}
+
+/* invoked by main tree code to update bitmap into screen */
+
+/**
+ * the given bitmap MUST be the original mame core bitmap !!!
+ *    - no swapxy, flipx or flipy and no resize !
+ *    - shall be Machine->scrbitmap
+ */
+void
+sysdep_update_display (struct mame_bitmap *bitmap)
+{
+  UpdateGLDisplayBegin (bitmap);
+
+  frame++;
+
+  if (keyboard_pressed (KEYCODE_RALT))
+  {
+    if (keyboard_pressed_memory (KEYCODE_A))
+    {
+    	  if(vecgame)
+	  {
+		  antialiasvec = 1-antialiasvec;
+		  printf("GLINFO: switched antialias := %d\n", antialiasvec);
+	  } else {
+		  gl_set_antialias (1-antialias);
+		  printf("GLINFO: switched antialias := %d\n", antialias);
+	  }
+    }
+    else if (keyboard_pressed_memory (KEYCODE_B))
+    {
+      gl_set_bilinear (1 - bilinear);
+      printf("GLINFO: switched bilinear := %d\n", bilinear);
+    }
+    else if (keyboard_pressed_memory (KEYCODE_C) && dodepth)
+    {
+      gl_set_cabview (1-cabview);
+      printf("GLINFO: switched cabinet := %d\n", cabview);
+    }
+    else if (keyboard_pressed_memory (KEYCODE_F) && dodepth)
+    {
+	toggleFullscreen();
+    }
+    else if (keyboard_pressed_memory (KEYCODE_O))
+    {
+      drawbitmap = 1 - drawbitmap;
+      printf("GLINFO: switched drawbitmap := %d\n", drawbitmap);
+    }
+    else if (keyboard_pressed_memory (KEYCODE_T))
+    {
+      dopersist = 1 - dopersist;
+      drawbitmap = 1 - dopersist;
+      printf("GLINFO: switched dopersist := %d (drawbitmap:=%d) \n", dopersist, drawbitmap);
+    }
+    else if (keyboard_pressed_memory (KEYCODE_PLUS_PAD))
+    {
+	set_gl_beam(get_gl_beam()+0.5);
+    }
+    else if (keyboard_pressed_memory (KEYCODE_MINUS_PAD))
+    {
+	set_gl_beam(get_gl_beam()-0.5);
+    }
+  }
+
+  UpdateGLDisplayEnd (bitmap);
+}
+
+struct mame_bitmap *osd_override_snapshot(struct mame_bitmap *bitmap,
+		struct rectangle *bounds)
+{
+	do_snapshot = 1;
+	return NULL;
+}
+
+
+#endif /* ifdef xgl */
diff --git a/src/unix/video-drivers/gljpg.c b/src/unix/video-drivers/gljpg.c
new file mode 100644
index 0000000..9468c79
--- /dev/null
+++ b/src/unix/video-drivers/gljpg.c
@@ -0,0 +1,96 @@
+/*****************************************************************
+
+  JPEG loading code for GLmame
+
+  This code is basically taken verbatim from the libjpeg distribution,
+  which is under to GNU Public License
+
+*****************************************************************/
+
+#ifdef xgl
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include "jpeglib.h"
+#include <setjmp.h>
+#include <GL/glu.h>
+
+extern char *cabname;
+
+struct my_error_mgr {
+  struct jpeg_error_mgr pub;    /* "public" fields */
+
+  jmp_buf setjmp_buffer;        /* for return to caller */
+};
+
+typedef struct my_error_mgr * my_error_ptr;
+
+METHODDEF(void)
+my_error_exit (j_common_ptr cinfo)
+{
+  my_error_ptr myerr = (my_error_ptr) cinfo->err;
+
+  (*cinfo->err->output_message) (cinfo);
+
+  longjmp(myerr->setjmp_buffer, 1);
+}
+
+GLubyte *read_JPEG_file (char * fname)
+{
+  struct jpeg_decompress_struct cinfo;
+  struct my_error_mgr jerr;
+  FILE * infile;		/* source file */
+  JSAMPARRAY buffer;		/* Output row buffer */
+  int row_stride;		/* physical row width in output buffer */
+  long cont;
+  JSAMPLE *image_buffer;
+  char filename[256];
+
+  sprintf(filename,"%s/cab/%s/%s",XMAMEROOT,cabname,fname);
+
+  if ((infile = fopen(filename, "rb")) == NULL) {
+    fprintf(stderr, "can't open %s\n", filename);
+    return NULL;
+  }
+
+  cinfo.err = jpeg_std_error(&jerr.pub);
+  jerr.pub.error_exit = my_error_exit;
+
+  if (setjmp(jerr.setjmp_buffer)) {
+    jpeg_destroy_decompress(&cinfo);
+    fclose(infile);
+    return NULL;
+  }
+
+  jpeg_create_decompress(&cinfo);
+
+  jpeg_stdio_src(&cinfo, infile);
+
+  (void) jpeg_read_header(&cinfo, TRUE);
+  (void) jpeg_start_decompress(&cinfo);
+  row_stride = cinfo.output_width * cinfo.output_components;
+
+  buffer = (*cinfo.mem->alloc_sarray)
+		((j_common_ptr) &cinfo, JPOOL_IMAGE, row_stride, 1);
+
+ image_buffer=(JSAMPLE *) malloc(cinfo.image_width*cinfo.image_height*3);
+
+  cont=(long)cinfo.output_height-1;
+  while (cinfo.output_scanline < cinfo.output_height) {
+    (void) jpeg_read_scanlines(&cinfo, buffer, 1);
+    memcpy(image_buffer+cinfo.image_width*3*cont,buffer[0],row_stride);
+    cont--;
+  }
+
+  (void) jpeg_finish_decompress(&cinfo);
+
+  jpeg_destroy_decompress(&cinfo);
+
+  fclose(infile);
+
+  return image_buffer;
+}
+
+
+#endif /* ifdef xgl */
diff --git a/src/unix/video-drivers/glmame.h b/src/unix/video-drivers/glmame.h
new file mode 100644
index 0000000..6e6b04f
--- /dev/null
+++ b/src/unix/video-drivers/glmame.h
@@ -0,0 +1,154 @@
+/*****************************************************************
+
+  GLmame include file
+
+  Copyright 1998 by Mike Oliphant - oliphant@ling.ed.ac.uk
+
+    http://www.ling.ed.ac.uk/~oliphant/glmame
+
+  Improved by Sven Goethel, http://www.jausoft.com, sgoethel@jausoft.com
+
+  This code may be used and distributed under the terms of the
+  Mame license
+
+*****************************************************************/
+
+#ifndef _GLMAME_H
+#define _GLMAME_H
+
+#ifdef WIN32
+#define WIN32_LEAN_AND_MEAN
+#include <windows.h>
+#include <windowsx.h>
+#include <assert.h>
+#include <math.h>
+#include "MAME32.h"
+#include "wgl_tool.h"
+#include "wgl_GDIDisplay.h"
+#else
+#include <ctype.h>
+#include <math.h>
+#include <dlfcn.h>
+#define CALLBACK
+#endif
+
+#include "gltool.h"
+
+/* Camera panning stuff */
+
+typedef enum {pan_goto,pan_moveto,pan_repeat,pan_end,pan_nocab} PanType;
+
+struct CameraPan {
+  PanType type;      /* Type of pan */
+  GLdouble lx,ly,lz;  /* Location of camera */
+  GLdouble px,py,pz;  /* Vector to point camera along */
+  GLdouble nx,ny,nz;  /* Normal to camera direction */
+  int frames;        /* Number of frames for transition */
+};
+
+/* xgl.c */
+extern char * libGLName;
+extern char * libGLUName;
+
+extern GLXContext glContext;
+extern int antialias;
+extern int antialiasvec;
+extern int fullscreen_width;
+extern int fullscreen_height;
+extern int winwidth;
+extern int winheight;
+extern int orig_width;
+extern int orig_height;
+extern int visual_orientated_width;
+extern int visual_orientated_height;
+extern int bilinear;
+extern int alphablending;
+extern int fullscreen;
+
+/* glvec.c */
+extern float gl_beam;
+extern float gl_translucency;
+
+/* glgen.c */
+extern int totalcolors;
+extern int use_mod_ctable;
+extern GLubyte *ctable;
+extern GLushort *rcolmap, *gcolmap, *bcolmap, *acolmap;
+extern int ctable_size; /* the true color table size */
+extern GLint  gl_internal_format;
+extern GLenum gl_bitmap_format;
+extern GLenum gl_bitmap_type;
+extern unsigned char gl_alpha_value; /* customize it :-) */
+extern double scrnaspect, vscrnaspect;
+extern GLsizei text_width;
+extern GLsizei text_height;
+extern int force_text_width_height;
+extern int dodepth;
+extern int cabview;
+extern int cabload_err;
+extern int drawbitmap;
+extern int dopersist;
+extern int useGLEXT78; /* paletted texture */
+extern int useColorIndex; 
+extern int isGL12;
+extern int useColorBlitter;
+
+extern char *cabname; /* 512 bytes reserved ... */
+extern int cabspecified;
+extern int gl_is_initialized;
+extern GLuint cablist;
+extern int gl_is_initialized;
+
+/* xgl.c */
+void toggleFullscreen();
+
+/* glvec.c */
+extern void set_gl_beam(float new_value);
+extern float get_gl_beam();
+
+/* glcab.c */
+void InitCabGlobals();
+
+/* glgen.c
+ * 
+ * the calling order is the listed order:
+ * 
+ * first the start sequence, then the quit sequence ..
+ */
+
+/* start sequence */
+void gl_bootstrap_resources();
+int sysdep_display_16bpp_capable (void);
+void InitVScreen (int depth);
+void gl_reset_resources();
+int sysdep_display_alloc_palette (int writable_colors);
+void InitTextures (struct mame_bitmap *bitmap);
+
+extern void gl_dirty_init(void);
+extern void gl_dirty_close(void);
+extern void gl_mark_dirty(int x1, int y1, int x2, int y2);
+
+/* quit sequence */
+void CloseVScreen (void);
+void gl_reset_resources();
+
+/* misc sequence */
+void  gl_set_bilinear(int new_value);
+void  gl_init_cabview ();
+void  gl_set_cabview(int new_value);
+int   gl_stream_antialias (int aa);
+void  gl_set_antialias(int new_value);
+int   gl_stream_alphablending (int alpha);
+void  gl_set_alphablending(int new_value);
+void  xgl_fixaspectratio(int *w, int *h);
+void xgl_resize(int w, int h, int now);
+extern int glHasEXT78 (void);
+extern void glSetUseEXT78 (int val);
+extern int glGetUseEXT78 (void);
+
+/* glexport */
+void gl_save_screen_snapshot();
+int gl_png_write_bitmap(void *fp);
+void ppm_save_snapshot (void *fp);
+
+#endif /* _GLMAME_H */
diff --git a/src/unix/video-drivers/gltool.c b/src/unix/video-drivers/gltool.c
new file mode 100644
index 0000000..5fdd0be
--- /dev/null
+++ b/src/unix/video-drivers/gltool.c
@@ -0,0 +1,638 @@
+/**
+ * gltool.c
+ *
+ * Copyright (C) 2001  Sven Goethel
+ *
+ * GNU Library General Public License 
+ * as published by the Free Software Foundation
+ *
+ * http://www.gnu.org/copyleft/lgpl.html
+ * General dynamical loading OpenGL (GL/GLU) support for:
+ *
+ *
+ * <OS - System>          <#define>  commentary
+ * -----------------------------------------------
+ * GNU/Linux, Unices/X11  _X11_      (loads glx also)
+ * Macinstosh OS9         _MAC_OS9_
+ * Macinstosh OSX         _MAC_OSX_
+ * Win32                  _WIN32_
+ *
+ */
+
+#include "gltool.h"
+
+#include "gl-disp-var.hc"
+#include "glu-disp-var.hc"
+
+#ifdef _X11_
+	#include "glxtool.h"
+#endif
+
+#ifdef _WIN32_
+	#include "wgltool.h"
+#endif
+
+static int _glLibsLoaded = 0;
+
+#ifdef _WIN32_
+  static HMODULE hDLL_OPENGL32 = 0;
+  static HMODULE hDLL_OPENGLU32 = 0;
+#endif
+
+#ifdef _X11_
+  static void *libHandleGLX=0;
+  static void *libHandleGL=0;
+  static void *libHandleGLU=0;
+#endif
+
+#ifdef _MAC_OS9_
+  Ptr glLibMainAddr = 0;
+  CFragConnectionID glLibConnectId = 0;
+#endif
+
+static int gl_begin_ctr;
+
+const char * GLTOOL_USE_GLLIB  = "GLTOOL_USE_GLLIB";
+const char * GLTOOL_USE_GLULIB = "GLTOOL_USE_GLULIB";
+
+void LIBAPIENTRY print_gl_error (const char *msg, const char *file, int line, GLenum errorcode)
+{
+  if (errorcode != GL_NO_ERROR)
+  {
+    const char *errstr = (const char *) disp__gluErrorString (errorcode);
+    if (errstr != 0)
+      fprintf (stderr, "\n\n****\n**%s %s:%d>0x%X %s\n****\n", msg, file, line, errorcode, errstr);
+    else
+      fprintf (stderr, "\n\n****\n**%s %s:%d>0x%X <unknown>\n****\n", msg, file, line, errorcode);
+  }
+}
+
+#ifdef _WIN32_
+void LIBAPIENTRY check_wgl_error (HWND wnd, const char *file, int line)
+{
+  LPVOID lpMsgBuf;
+
+  FormatMessage (FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
+		 0, GetLastError (), MAKELANGID (LANG_NEUTRAL, SUBLANG_DEFAULT),	// Default language
+		 (LPTSTR) & lpMsgBuf, 0, 0);	// Display the string.
+
+  fprintf (stderr, "\n\n****\n** %s:%d>%s\n****\n", file, line, lpMsgBuf);
+
+  // Free the buffer.
+  LocalFree (lpMsgBuf);
+}
+#endif
+
+void LIBAPIENTRY check_gl_error (const char *file, int line)
+{
+  print_gl_error("GLCHECK", file, line, disp__glGetError());
+}
+
+void LIBAPIENTRY __sglBegin(const char * file, int line, GLenum mode)
+{
+  	print_gl_error("GL-PreBEGIN-CHECK", file, line, disp__glGetError());
+
+	if(gl_begin_ctr!=0)
+	{
+		printf("\n\n****\n** GL-BEGIN-ERROR %s:%d> glBegin was called %d times (reset now)\n****\n", 
+			file, line, gl_begin_ctr);
+		gl_begin_ctr=0;
+	} else
+		gl_begin_ctr++;
+
+	disp__glBegin(mode);
+}
+
+void LIBAPIENTRY __sglEnd(const char * file, int line)
+{
+	if(gl_begin_ctr!=1)
+	{
+		printf("\n\n****\n** GL-END-ERROR %s:%d> glBegin was called %d times (reset now)\n****\n", 
+			file, line, gl_begin_ctr);
+		gl_begin_ctr=1;
+	} else
+		gl_begin_ctr--;
+
+	disp__glEnd();
+
+  	print_gl_error("GL-PostEND-CHECK", file, line, disp__glGetError());
+}
+
+/** 
+ * call this function only if you 
+ * are not within a glBegin/glEnd block,
+ * or you think your are not ;-)
+ */
+void LIBAPIENTRY checkGlBeginEndBalance(const char *file, int line)
+{
+	if(gl_begin_ctr!=0)
+	{
+		printf("\n****\n** GL-BeginEnd-ERROR %s:%d> glBegin was called %d times\n****\n", 
+			file, line, gl_begin_ctr);
+	}
+  	print_gl_error("GL-BeginEnd-CHECK", file, line, disp__glGetError());
+}
+
+void LIBAPIENTRY showGlBeginEndBalance(const char *file, int line)
+{
+	printf("\n****\n** GL-BeginEnd %s:%d> glBegin was called %d times\n****\n", 
+		file, line, gl_begin_ctr);
+}
+
+int LIBAPIENTRY unloadGLLibrary ()
+{
+#ifdef _WIN32_
+      if(hDLL_OPENGL32!=NULL)
+      {
+		FreeLibrary(hDLL_OPENGL32);
+		hDLL_OPENGL32=NULL;
+      }
+      if(hDLL_OPENGLU32!=NULL)
+      {
+		FreeLibrary(hDLL_OPENGLU32);
+		hDLL_OPENGLU32=NULL;
+      }
+#endif
+
+#ifdef _X11_
+      if(libHandleGL!=NULL)
+      {
+	      dlclose (libHandleGL);
+	      libHandleGL = NULL;
+      }
+      if(libHandleGLU!=NULL)
+      {
+	      dlclose (libHandleGLU);
+	      libHandleGLU = NULL;
+      }
+      if(libHandleGLX!=NULL)
+      {
+	      dlclose (libHandleGLX);
+	      libHandleGLX = NULL;
+      }
+#endif
+
+#ifdef _MAC_OS9_
+      if (glLibConnectId!=NULL)
+      {
+	(void) CloseConnection(&glLibConnectId);
+	glLibConnectId=0;
+      }
+      glLibMainAddr = 0;
+#endif
+
+      _glLibsLoaded = 0;
+      return 1;
+
+}
+
+int LIBAPIENTRY loadGLLibrary (const char * libGLName, const char * libGLUName)
+{
+  const char *envGLName  = NULL;
+  const char *envGLUName = NULL;
+#ifdef _MAC_OS9_
+  Str255 errName;
+  OSErr returnError=fragNoErr;
+#endif
+
+  if(_glLibsLoaded) return 1;
+
+  envGLName = getenv(GLTOOL_USE_GLLIB);
+  envGLUName = getenv(GLTOOL_USE_GLULIB);
+
+  if(envGLName!=NULL)
+  {
+  	libGLName = envGLName;
+	printf("GLTOOL: using env's GLTOOL_USE_GLLIB = %s\n", libGLName);
+  }
+
+  if(envGLUName!=NULL)
+  {
+  	libGLUName = envGLUName;
+	printf("GLTOOL: using env's GLTOOL_USE_GLULIB = %s\n", libGLUName);
+  }
+
+#ifdef _WIN32_
+  if(hDLL_OPENGL32!=NULL) return 1;
+
+  hDLL_OPENGL32 = LoadLibrary (libGLName);
+  hDLL_OPENGLU32 = LoadLibrary (libGLUName);
+
+  if (hDLL_OPENGL32 == NULL)
+  {
+      printf ("GLERROR: cannot access OpenGL library %s\n", libGLName);
+      fflush (NULL);
+      return 0;
+  }
+
+  if (hDLL_OPENGLU32 == NULL)
+  {
+      printf ("GLERROR: cannot access GLU library %s\n", libGLUName);
+      fflush (NULL);
+      return 0;
+  }
+
+#endif
+
+#ifdef _X11_
+  if(libHandleGL!=NULL) return 1;
+
+#ifdef SUN_FORTE_DLOPEN_LIBCRUN
+  {
+     void *libcrun;
+
+     libcrun = dlopen (SUN_FORTE_DLOPEN_LIBCRUN, RTLD_LAZY | RTLD_GLOBAL);
+     if (libcrun == NULL)
+     {
+        printf ("GLERROR: cannot access library %s\n", SUN_FORTE_DLOPEN_LIBCRUN);
+        printf ("GLERROR: dlerror() returns [%s]\n", dlerror());
+        fflush (NULL);
+        return 0;
+     }
+  }
+#endif
+
+  libHandleGL = dlopen (libGLName, RTLD_LAZY | RTLD_GLOBAL);
+  if (libHandleGL == NULL)
+  {
+      printf ("GLERROR: cannot access OpenGL library %s\n", libGLName);
+      printf ("GLERROR: dlerror() returns [%s]\n", dlerror());
+      fflush (NULL);
+      return 0;
+  }
+
+  libHandleGLU = dlopen (libGLUName, RTLD_LAZY | RTLD_GLOBAL);
+  if (libHandleGLU == NULL)
+  {
+      printf ("GLERROR: cannot access GLU library %s\n", libGLUName);
+      printf ("GLERROR: dlerror() returns [%s]\n", dlerror());
+      fflush (NULL);
+      return 0;
+  }
+
+  libHandleGLX = dlopen (GLXLIB_NAME, RTLD_LAZY | RTLD_GLOBAL);
+  if (libHandleGLX == NULL)
+  {
+      printf ("GLINFO: cannot access GLX library %s directly ...\n", GLXLIB_NAME);
+      printf ("GLERROR: dlerror() returns [%s]\n", dlerror());
+      fflush (NULL);
+  }
+
+#endif
+
+#ifdef _MAC_OS9_
+        returnError =
+                GetSharedLibrary("\pOpenGLLibrary",
+                               kPowerPCCFragArch,
+                               kReferenceCFrag,
+                               &glLibConnectId,
+                               &glLibMainAddr,
+                   errName);
+ 
+        if (returnError != fragNoErr)
+        {
+                printf ("GetSharedLibrary Err(%d): Ahhh!  Didn't find LIBRARY !\n",
+                        returnError);
+		return 0;
+        }
+#endif
+
+#ifdef _MAC_OSX_
+  printf ("GLINFO: loadGLLibrary - no special code implemented !\n");
+#else
+  printf ("GLINFO: loaded OpenGL library %s!\n", libGLName);
+  printf ("GLINFO: loaded GLU    library %s!\n", libGLUName);
+#endif
+  fflush (NULL);
+  
+  _glLibsLoaded = 1;
+
+  return 1;
+}
+
+void * LIBAPIENTRY getGLProcAddressHelper 
+	(const char * libGLName, const char * libGLUName,
+         const char *func, int *method, int debug, int verbose)
+{
+  void * funcPtr = NULL;
+  int lmethod;
+
+#ifdef _WIN32_
+  static int __firstAccess = 1;
+
+  if(!loadGLLibrary (libGLName, libGLUName))
+  	return NULL;
+
+  if (disp__wglGetProcAddress == NULL && __firstAccess)
+  {
+	  disp__wglGetProcAddress = ( PROC  (CALLBACK *)(LPCSTR) )
+      	GetProcAddress (hDLL_OPENGL32, "wglGetProcAddress");
+
+      if (disp__wglGetProcAddress != NULL /* && verbose */)
+      {
+			printf ("GLINFO: found wglGetProcAddress in %s\n", libGLName);
+			fflush (NULL);
+      }
+
+      if (disp__wglGetProcAddress == NULL)
+      {
+	printf ("GLINFO: can't find wglGetProcAddress in %s\n", libGLName);
+      }
+  }
+  __firstAccess = 0;
+
+  if (disp__wglGetProcAddress != NULL)
+	  funcPtr = disp__wglGetProcAddress (func);
+
+  if (funcPtr == NULL)
+  {
+    lmethod = 2;
+
+    funcPtr = GetProcAddress (hDLL_OPENGL32, func);
+  }
+  else
+    lmethod = 1;
+
+  if (funcPtr == NULL)
+  {
+    lmethod = 3;
+
+    funcPtr = GetProcAddress (hDLL_OPENGLU32, func);
+  }
+
+#endif
+
+#ifdef _X11_
+  typedef void *(CALLBACK * procPtr) (const GLubyte *);
+
+  /*
+   * void (*glXGetProcAddressARB(const GLubyte *procName))
+   */
+  static int __firstAccess = 1;
+
+  if(!loadGLLibrary (libGLName, libGLUName))
+  	return NULL;
+
+  if (disp__glXGetProcAddress == NULL && __firstAccess)
+  {
+      disp__glXGetProcAddress = (procPtr) dlsym (libHandleGL, SYMBOL_PREFIX
+        "glXGetProcAddressARB");
+
+      if (disp__glXGetProcAddress != NULL && verbose)
+      {
+	printf ("GLINFO: found glXGetProcAddressARB in %s\n", libGLName);
+	fflush (NULL);
+      }
+
+      if (disp__glXGetProcAddress == NULL)
+      {
+	disp__glXGetProcAddress = (procPtr) dlsym (libHandleGL, SYMBOL_PREFIX
+	  "glXGetProcAddressEXT");
+
+	if (disp__glXGetProcAddress != NULL && verbose)
+	{
+	  printf ("GLINFO: found glXGetProcAddressEXT in %s\n", libGLName);
+	  fflush (NULL);
+	}
+      }
+
+      if (disp__glXGetProcAddress == NULL)
+      {
+	disp__glXGetProcAddress = (procPtr) dlsym (libHandleGL, SYMBOL_PREFIX
+	  "glXGetProcAddress");
+
+	if (disp__glXGetProcAddress != NULL && verbose)
+	{
+	  printf ("GLINFO: found glXGetProcAddress in %s\n", libGLName);
+	  fflush (NULL);
+	}
+      }
+
+      if (disp__glXGetProcAddress == NULL)
+      {
+	printf
+	  ("GLINFO: cannot find glXGetProcAddress* in OpenGL library %s\n", libGLName);
+	fflush (NULL);
+	if (libHandleGLX != NULL)
+	{
+	  disp__glXGetProcAddress = (procPtr) dlsym (libHandleGLX, SYMBOL_PREFIX
+	    "glXGetProcAddressARB");
+
+	  if (disp__glXGetProcAddress != NULL && verbose)
+	  {
+	    printf ("GLINFO: found glXGetProcAddressARB in %s\n", GLXLIB_NAME);
+	    fflush (NULL);
+	  }
+
+	  if (disp__glXGetProcAddress == NULL)
+	  {
+	    disp__glXGetProcAddress = (procPtr) dlsym (libHandleGLX,
+	      SYMBOL_PREFIX "glXGetProcAddressEXT");
+
+	    if (disp__glXGetProcAddress != NULL && verbose)
+	    {
+	      printf ("GLINFO: found glXGetProcAddressEXT in %s\n", GLXLIB_NAME);
+	      fflush (NULL);
+	    }
+	  }
+
+	  if (disp__glXGetProcAddress == NULL)
+	  {
+	    disp__glXGetProcAddress = (procPtr) dlsym (libHandleGLX,
+	      SYMBOL_PREFIX "glXGetProcAddress");
+
+	    if (disp__glXGetProcAddress != NULL && verbose)
+	    {
+	      printf ("GLINFO: found glXGetProcAddress in %s\n", GLXLIB_NAME);
+	      fflush (NULL);
+	    }
+	  }
+	  if (disp__glXGetProcAddress == NULL)
+	  {
+	    printf ("GLINFO: cannot find glXGetProcAddress* in GLX library %s\n", GLXLIB_NAME);
+	    fflush (NULL);
+	  }
+	}
+      }
+  }
+  __firstAccess = 0;
+
+  if (disp__glXGetProcAddress != NULL)
+    funcPtr = disp__glXGetProcAddress ((const unsigned char *) func);
+
+  if (funcPtr == NULL)
+  {
+    lmethod = 2;
+    funcPtr = dlsym (libHandleGL, func);
+  }
+  else
+    lmethod = 1;
+
+  if (funcPtr == NULL)
+  {
+    lmethod = 3;
+    funcPtr = dlsym (libHandleGLU, func);
+  }
+#endif
+
+#ifdef _MAC_OS9_
+        Str255 errName;
+        Str255 funcName;
+        CFragSymbolClass glLibSymClass = 0;
+        OSErr returnError=fragNoErr;
+        #ifndef NDEBUG
+		static int firstTime = 1;
+        #endif
+ 
+        if(!loadGLLibrary (libGLName, libGLUName))
+  		return NULL;
+
+	c2pstrcpy ( funcName, func );
+
+	#ifndef NDEBUG
+	 if(firstTime)
+	 {
+		PrintSymbolNamesByConnection (glLibConnectId);
+		firstTime=0;
+	 }
+	 funcPtr = (void *)
+		SeekSymbolNamesByConnection (glLibConnectId, funcName);
+	#endif
+
+	if(funcPtr==NULL)
+	{
+	  returnError =
+	    FindSymbol (glLibConnectId, funcName,
+			&funcPtr, & glLibSymClass );
+	    lmethod=2;
+	}
+	#ifndef NDEBUG
+	 else lmethod=3;
+	#endif
+
+	if (returnError != fragNoErr)
+	{
+	  printf ("GetSharedLibrary Err(%d): Ahhh!  Didn't find SYMBOL: %s !\n",
+		returnError, func);
+	}
+#endif
+
+#ifdef _MAC_OSX_
+    char underscoreName[256];
+    strcpy(underscoreName, "_");
+    strcat(underscoreName, func);
+ 
+    if ( NSIsSymbolNameDefined(underscoreName) ) {
+        NSSymbol sym = NSLookupAndBindSymbol(underscoreName);
+        funcPtr = (void *)NSAddressOfSymbol(sym);
+    }
+ 
+#endif
+
+  if (funcPtr == NULL)
+  {
+    if (debug || verbose)
+    {
+      printf ("GLINFO: %s (%d): not implemented !\n", func, lmethod);
+      fflush (NULL);
+    }
+  }
+  else if (verbose)
+  {
+    printf ("GLINFO: %s (%d): loaded !\n", func, lmethod);
+    fflush (NULL);
+  }
+  if (method != NULL)
+    *method = lmethod;
+  return funcPtr;
+}
+
+
+void LIBAPIENTRY fetch_GL_FUNCS (const char * libGLName, 
+			         const char * libGLUName, int force)
+{
+  static int _firstRun = 1;
+
+  if(force)
+  {
+	unloadGLLibrary();
+        _firstRun = 1;
+  }
+
+  if(!_firstRun)
+  	return;
+
+  if(!loadGLLibrary (libGLName, libGLUName))
+  	return;
+
+  #define GET_GL_PROCADDRESS(a) getGLProcAddressHelper (libGLName, libGLUName, (SYMBOL_PREFIX a), NULL, 1, 0);
+
+  #include "gl-disp-fetch.hc"
+  #include "glu-disp-fetch.hc"
+
+  _firstRun=0;
+
+#ifdef _X11_
+  fetch_GLX_FUNCS (libGLName, libGLUName, force);
+#endif
+
+#ifdef _WIN32_
+  fetch_WGL_FUNCS (libGLName, libGLUName, force);
+#endif
+
+}
+
+#ifdef _MAC_OS9_
+
+#ifndef NDEBUG
+
+static void PrintSymbolNamesByConnection (CFragConnectionID myConnID)
+{
+       long           myIndex;
+       long           myCount;       /*number of exported symbols in fragment*/
+       OSErr          myErr;
+       Str255         myName;        /*symbol name*/
+       Ptr            myAddr;        /*symbol address*/
+       CFragSymbolClass       myClass;       /*symbol class*/
+       static char buffer[256];
+
+       myErr = CountSymbols(myConnID, &myCount);
+       if (!myErr)
+          for (myIndex = 1; myIndex <= myCount; myIndex++)
+             {
+                myErr = GetIndSymbol(myConnID, myIndex, myName, 
+                                        &myAddr, &myClass);
+                if (!myErr)
+		{
+			p2cstrcpy (buffer, myName);
+								 
+            printf("%d/%d: class %d - name %s\n", 
+		   		myIndex, myCount, myClass, buffer);
+		}
+             }
+}
+
+static Ptr SeekSymbolNamesByConnection (CFragConnectionID myConnID, Str255 name)
+{
+       long           myIndex;
+       long           myCount;       /*number of exported symbols in fragment*/
+       OSErr          myErr;
+       Str255         myName;        /*symbol name*/
+       Ptr            myAddr;        /*symbol address*/
+       CFragSymbolClass       myClass;       /*symbol class*/
+
+       myErr = CountSymbols(myConnID, &myCount);
+       if (!myErr)
+          for (myIndex = 1; myIndex <= myCount; myIndex++)
+             {
+                myErr = GetIndSymbol(myConnID, myIndex, myName, 
+                                        &myAddr, &myClass);
+                if (!myErr && EqualString (myName, name, true, true) == true )
+			return myAddr;
+             }
+}
+
+#endif /* ifndef NDEBUG */
+
+#endif /* ifdef _MAC_OS9_ */
+
diff --git a/src/unix/video-drivers/gltool.h b/src/unix/video-drivers/gltool.h
new file mode 100644
index 0000000..f2879f7
--- /dev/null
+++ b/src/unix/video-drivers/gltool.h
@@ -0,0 +1,160 @@
+#ifndef _GLTOOL_H
+	#define _GLTOOL_H
+
+	/**
+	 * gltool.h
+	 *
+	 * Copyright (C) 2001  Sven Goethel
+	 *
+	 * GNU Library General Public License 
+	 * as published by the Free Software Foundation
+	 *
+	 * http://www.gnu.org/copyleft/lgpl.html
+	 * General dynamical loading OpenGL (GL/GLU) support for:
+	 *
+	 *
+	 * <OS - System>          <#define>  commentary
+	 * -----------------------------------------------
+	 * GNU/Linux, Unices/X11  _X11_      (loads glx also)
+	 * Macinstosh OS9         _MAC_OS9_
+	 * Macinstosh OSX         _MAC_OSX_
+	 * Win32                  _WIN32_
+	 *
+	 */
+
+	#include <stdio.h>
+	#include <stdlib.h>
+	#include <stdarg.h>
+	#include <string.h>
+
+	#ifdef _WIN32_
+		#include <windows.h>
+
+		#ifdef LIBAPIENTRY
+			#undef LIBAPIENTRY
+		#endif
+		#ifdef LIBAPI
+			#undef LIBAPI
+		#endif
+	 
+		#define LIBAPI          __declspec(dllexport)
+		#define LIBAPIENTRY    __stdcall
+	#else
+		#include <ctype.h>
+		#include <math.h>
+		#define CALLBACK
+	#endif
+
+	#ifdef _X11_
+		#include <dlfcn.h>
+		#include <X11/Xlib.h>
+		#include <X11/Xutil.h>
+		#include <X11/Xatom.h>
+		#include <GL/glx.h>
+	#endif
+
+	#ifdef _MAC_OS9_
+		#include <agl.h>
+		#include <CodeFragments.h>
+		#include <Errors.h>
+		#include <TextUtils.h>
+		#include <StringCompare.h>
+	 
+		#define fragNoErr 0
+	#endif
+
+	#include <GL/gl.h>
+	#include <GL/glu.h>
+
+	#ifndef LIBAPIENTRY
+                #define LIBAPIENTRY
+        #endif
+        #ifndef LIBAPI
+                #define LIBAPI extern
+        #endif
+
+	LIBAPI const char * GLTOOL_USE_GLLIB ;
+	LIBAPI const char * GLTOOL_USE_GLULIB ;
+
+	#include "glcaps.h"
+
+	#include "gl-disp-var.h"
+	#include "glu-disp-var.h"
+
+	#ifndef GLDEBUG
+		#ifndef NDEBUG
+			#define NDEBUG
+		#endif
+	#else
+		#ifdef NDEBUG
+			#undef NDEBUG
+		#endif
+	#endif
+
+	#ifndef USE_64BIT_POINTER
+		typedef int  PointerHolder;
+	#else
+		typedef long PointerHolder;
+	#endif
+
+	#ifdef _WIN32_
+		#ifndef NDEBUG
+			#define CHECK_WGL_ERROR(a,b,c) check_wgl_error(a,b,c)
+		#else
+			#define CHECK_WGL_ERROR(a,b,c)
+		#endif
+	#else
+		#define CHECK_WGL_ERROR(a,b,c)
+	#endif
+
+	#ifndef NDEBUG
+		#define PRINT_GL_ERROR(a, b)	print_gl_error((a), __FILE__, __LINE__, (b))
+		#define CHECK_GL_ERROR()  	check_gl_error(__FILE__,__LINE__)
+		#define GL_BEGIN(m) 		__sglBegin(__FILE__, __LINE__, (m))
+		#define GL_END()    		__sglEnd  (__FILE__, __LINE__)
+		#define SHOW_GL_BEGINEND()	showGlBeginEndBalance(__FILE__, __LINE__)
+		#define CHECK_GL_BEGINEND()	checkGlBeginEndBalance(__FILE__, __LINE__)
+	#else
+		#define PRINT_GL_ERROR(a, b)	
+		#define CHECK_GL_ERROR()  
+		#define GL_BEGIN(m) 		disp__glBegin(m)
+		#define GL_END()    		disp__glEnd  ()
+		#define SHOW_GL_BEGINEND()	
+		#define CHECK_GL_BEGINEND()	
+	#endif
+
+	#ifdef _WIN32_
+		LIBAPI void LIBAPIENTRY check_wgl_error 
+			(HWND wnd, const char *file, int line);
+	#endif
+
+	LIBAPI void LIBAPIENTRY print_gl_error 
+		(const char *msg, const char *file, int line, GLenum errorcode);
+
+	LIBAPI void LIBAPIENTRY check_gl_error 
+		(const char *file, int line);
+
+	LIBAPI void LIBAPIENTRY showGlBeginEndBalance
+		(const char *file, int line);
+
+	LIBAPI void LIBAPIENTRY checkGlBeginEndBalance
+		(const char *file, int line);
+
+	LIBAPI void LIBAPIENTRY __sglBegin
+		(const char * file, int line, GLenum mode);
+
+	LIBAPI void LIBAPIENTRY __sglEnd
+		(const char * file, int line);
+
+	LIBAPI int LIBAPIENTRY unloadGLLibrary (void);
+
+	LIBAPI int LIBAPIENTRY loadGLLibrary 
+        	(const char * libGLName, const char * libGLUName);
+
+	LIBAPI void * LIBAPIENTRY getGLProcAddressHelper 
+		(const char * libGLName, const char * libGLUName,
+		 const char *func, int *method, int debug, int verbose);
+
+        LIBAPI void LIBAPIENTRY fetch_GL_FUNCS 
+		(const char * libGLName, const char * libGLUName, int force);
+#endif
diff --git a/src/unix/video-drivers/glu-disp-fetch.hc b/src/unix/video-drivers/glu-disp-fetch.hc
new file mode 100644
index 0000000..336c1f9
--- /dev/null
+++ b/src/unix/video-drivers/glu-disp-fetch.hc
@@ -0,0 +1,168 @@
+/* WARNING ! WARNING *** THIS FILE IS GENERATED BY C2J !!!
+
+   DO NOT MAKE ANY CHANGES *** MAKE CHANGES IN THE SKELETON FILES !!!
+*/
+
+
+	disp__gluGetString = (const GLubyte *(CALLBACK *)( GLenum))
+		GET_GL_PROCADDRESS ("gluGetString");
+
+
+    disp__gluErrorString = ( const GLubyte * (CALLBACK *) ( GLenum) )
+    	GET_GL_PROCADDRESS("gluErrorString");
+
+    disp__gluQuadricCallback= ( void (CALLBACK *) ( GLUquadricObj*, GLenum, GLvoid (CALLBACK *)()) )
+    	GET_GL_PROCADDRESS("gluQuadricCallback");
+
+    disp__gluNurbsCallback=  ( void (CALLBACK *) ( GLUnurbsObj*, GLenum, GLvoid (CALLBACK *)()) )
+    	GET_GL_PROCADDRESS("gluNurbsCallback");
+
+    disp__gluTessCallback=  ( void (CALLBACK *) ( GLUtesselator*, GLenum, GLvoid (CALLBACK *)()) )
+    	GET_GL_PROCADDRESS("gluTessCallback");
+
+    disp__gluDeleteQuadric= ( void (CALLBACK *) ( GLUquadricObj*) )
+    	GET_GL_PROCADDRESS("gluDeleteQuadric");
+
+    disp__gluDeleteNurbsRenderer= ( void (CALLBACK *) ( GLUnurbsObj*) )
+    	GET_GL_PROCADDRESS("gluDeleteNurbsRenderer");
+
+    disp__gluDeleteTess= ( void (CALLBACK *) ( GLUtesselator*) )
+    	GET_GL_PROCADDRESS("gluDeleteTess");
+
+    disp__gluNewQuadric= ( GLUquadricObj* (CALLBACK *) (void) )
+    	GET_GL_PROCADDRESS("gluNewQuadric");
+
+    disp__gluNewNurbsRenderer=  ( GLUnurbsObj* (CALLBACK *) (void) )
+    	GET_GL_PROCADDRESS("gluNewNurbsRenderer");
+
+    disp__gluNewTess= ( GLUtesselator* (CALLBACK *) (void) )
+    	GET_GL_PROCADDRESS("gluNewTess");
+
+/**
+ * C2J Parser Version 2.0
+ * Jausoft - Sven Goethel Software Development
+ * Reading from file: glu-proto-auto.orig.h . . .
+ * Destination-Class: gl4java_GLUFuncJauJNI ! 
+ */
+
+	disp__gluLookAt = (void (CALLBACK *)(GLdouble, GLdouble, GLdouble, GLdouble, GLdouble, GLdouble, GLdouble, GLdouble, GLdouble))
+	  GET_GL_PROCADDRESS ("gluLookAt");
+
+	disp__gluOrtho2D = (void (CALLBACK *)(GLdouble, GLdouble, GLdouble, GLdouble))
+	  GET_GL_PROCADDRESS ("gluOrtho2D");
+
+	disp__gluPerspective = (void (CALLBACK *)(GLdouble, GLdouble, GLdouble, GLdouble))
+	  GET_GL_PROCADDRESS ("gluPerspective");
+
+	disp__gluPickMatrix = (void (CALLBACK *)(GLdouble, GLdouble, GLdouble, GLdouble, GLint *))
+	  GET_GL_PROCADDRESS ("gluPickMatrix");
+
+	disp__gluProject = (GLint (CALLBACK *)(GLdouble, GLdouble, GLdouble, const GLdouble *, const GLdouble *, const GLint *, GLdouble *, GLdouble *, GLdouble *))
+	  GET_GL_PROCADDRESS ("gluProject");
+
+	disp__gluUnProject = (GLint (CALLBACK *)(GLdouble, GLdouble, GLdouble, const GLdouble *, const GLdouble *, const GLint *, GLdouble *, GLdouble *, GLdouble *))
+	  GET_GL_PROCADDRESS ("gluUnProject");
+
+	disp__gluScaleImage = (GLint (CALLBACK *)(GLenum, GLsizei, GLsizei, GLenum, const char *, GLsizei, GLsizei, GLenum, char *))
+	  GET_GL_PROCADDRESS ("gluScaleImage");
+
+	disp__gluBuild1DMipmaps = (GLint (CALLBACK *)(GLenum, GLint, GLint, GLenum, GLenum, const void *))
+	  GET_GL_PROCADDRESS ("gluBuild1DMipmaps");
+
+	disp__gluBuild2DMipmaps = (GLint (CALLBACK *)(GLenum, GLint, GLint, GLint, GLenum, GLenum, const void *))
+	  GET_GL_PROCADDRESS ("gluBuild2DMipmaps");
+
+	disp__gluQuadricDrawStyle = (void (CALLBACK *)(GLUquadricObj *, GLenum))
+	  GET_GL_PROCADDRESS ("gluQuadricDrawStyle");
+
+	disp__gluQuadricOrientation = (void (CALLBACK *)(GLUquadricObj *, GLenum))
+	  GET_GL_PROCADDRESS ("gluQuadricOrientation");
+
+	disp__gluQuadricNormals = (void (CALLBACK *)(GLUquadricObj *, GLenum))
+	  GET_GL_PROCADDRESS ("gluQuadricNormals");
+
+	disp__gluQuadricTexture = (void (CALLBACK *)(GLUquadricObj *, GLboolean))
+	  GET_GL_PROCADDRESS ("gluQuadricTexture");
+
+	disp__gluCylinder = (void (CALLBACK *)(GLUquadricObj *, GLdouble, GLdouble, GLdouble, GLint, GLint))
+	  GET_GL_PROCADDRESS ("gluCylinder");
+
+	disp__gluSphere = (void (CALLBACK *)(GLUquadricObj *, GLdouble, GLint, GLint))
+	  GET_GL_PROCADDRESS ("gluSphere");
+
+	disp__gluDisk = (void (CALLBACK *)(GLUquadricObj *, GLdouble, GLdouble, GLint, GLint))
+	  GET_GL_PROCADDRESS ("gluDisk");
+
+	disp__gluPartialDisk = (void (CALLBACK *)(GLUquadricObj *, GLdouble, GLdouble, GLint, GLint, GLdouble, GLdouble))
+	  GET_GL_PROCADDRESS ("gluPartialDisk");
+
+	disp__gluLoadSamplingMatrices = (void (CALLBACK *)(GLUnurbsObj *, const GLfloat *, const GLfloat *, const GLint *))
+	  GET_GL_PROCADDRESS ("gluLoadSamplingMatrices");
+
+	disp__gluNurbsProperty = (void (CALLBACK *)(GLUnurbsObj *, GLenum, GLfloat))
+	  GET_GL_PROCADDRESS ("gluNurbsProperty");
+
+	disp__gluGetNurbsProperty = (void (CALLBACK *)(GLUnurbsObj *, GLenum, GLfloat *))
+	  GET_GL_PROCADDRESS ("gluGetNurbsProperty");
+
+	disp__gluBeginCurve = (void (CALLBACK *)(GLUnurbsObj *))
+	  GET_GL_PROCADDRESS ("gluBeginCurve");
+
+	disp__gluEndCurve = (void (CALLBACK *)(GLUnurbsObj *))
+	  GET_GL_PROCADDRESS ("gluEndCurve");
+
+	disp__gluNurbsCurve = (void (CALLBACK *)(GLUnurbsObj *, GLint, GLfloat *, GLint, GLfloat *, GLint, GLenum))
+	  GET_GL_PROCADDRESS ("gluNurbsCurve");
+
+	disp__gluBeginSurface = (void (CALLBACK *)(GLUnurbsObj *))
+	  GET_GL_PROCADDRESS ("gluBeginSurface");
+
+	disp__gluEndSurface = (void (CALLBACK *)(GLUnurbsObj *))
+	  GET_GL_PROCADDRESS ("gluEndSurface");
+
+	disp__gluNurbsSurface = (void (CALLBACK *)(GLUnurbsObj *, GLint, GLfloat *, GLint, GLfloat *, GLint, GLint, GLfloat *, GLint, GLint, GLenum))
+	  GET_GL_PROCADDRESS ("gluNurbsSurface");
+
+	disp__gluBeginTrim = (void (CALLBACK *)(GLUnurbsObj *))
+	  GET_GL_PROCADDRESS ("gluBeginTrim");
+
+	disp__gluEndTrim = (void (CALLBACK *)(GLUnurbsObj *))
+	  GET_GL_PROCADDRESS ("gluEndTrim");
+
+	disp__gluPwlCurve = (void (CALLBACK *)(GLUnurbsObj *, GLint, GLfloat *, GLint, GLenum))
+	  GET_GL_PROCADDRESS ("gluPwlCurve");
+
+	disp__gluTessBeginPolygon = (void (CALLBACK *)(GLUtesselator *, void *))
+	  GET_GL_PROCADDRESS ("gluTessBeginPolygon");
+
+	disp__gluTessBeginContour = (void (CALLBACK *)(GLUtesselator *))
+	  GET_GL_PROCADDRESS ("gluTessBeginContour");
+
+	disp__gluTessVertex = (void (CALLBACK *)(GLUtesselator *, GLdouble *, void *))
+	  GET_GL_PROCADDRESS ("gluTessVertex");
+
+	disp__gluTessEndContour = (void (CALLBACK *)(GLUtesselator *))
+	  GET_GL_PROCADDRESS ("gluTessEndContour");
+
+	disp__gluTessEndPolygon = (void (CALLBACK *)(GLUtesselator *))
+	  GET_GL_PROCADDRESS ("gluTessEndPolygon");
+
+	disp__gluTessProperty = (void (CALLBACK *)(GLUtesselator *, GLenum, GLdouble))
+	  GET_GL_PROCADDRESS ("gluTessProperty");
+
+	disp__gluTessNormal = (void (CALLBACK *)(GLUtesselator *, GLdouble, GLdouble, GLdouble))
+	  GET_GL_PROCADDRESS ("gluTessNormal");
+
+	disp__gluGetTessProperty = (void (CALLBACK *)(GLUtesselator *, GLenum, GLdouble *))
+	  GET_GL_PROCADDRESS ("gluGetTessProperty");
+
+	disp__gluBeginPolygon = (void (CALLBACK *)(GLUtesselator *))
+	  GET_GL_PROCADDRESS ("gluBeginPolygon");
+
+	disp__gluNextContour = (void (CALLBACK *)(GLUtesselator *, GLenum))
+	  GET_GL_PROCADDRESS ("gluNextContour");
+
+	disp__gluEndPolygon = (void (CALLBACK *)(GLUtesselator *))
+	  GET_GL_PROCADDRESS ("gluEndPolygon");
+
+/* C2J Parser Version 2.0:  Java program parsed successfully. */ 
diff --git a/src/unix/video-drivers/glu-disp-var.h b/src/unix/video-drivers/glu-disp-var.h
new file mode 100644
index 0000000..29ecc5a
--- /dev/null
+++ b/src/unix/video-drivers/glu-disp-var.h
@@ -0,0 +1,355 @@
+/* WARNING ! WARNING *** THIS FILE IS GENERATED BY C2J !!!
+
+   DO NOT MAKE ANY CHANGES *** MAKE CHANGES IN THE SKELETON FILES !!!
+*/
+
+
+LIBAPI const GLubyte *(CALLBACK * disp__gluGetString )( GLenum name );
+
+LIBAPI const GLubyte * (CALLBACK * disp__gluErrorString) ( GLenum);
+
+LIBAPI void (CALLBACK * disp__gluQuadricCallback) ( GLUquadricObj* quad, GLenum which, GLvoid (CALLBACK *)());
+
+LIBAPI void (CALLBACK * disp__gluNurbsCallback) ( GLUnurbsObj* nurb, GLenum which, GLvoid (CALLBACK *)());
+
+LIBAPI void (CALLBACK * disp__gluTessCallback) ( GLUtesselator* tess, GLenum which, GLvoid (CALLBACK *)());
+
+LIBAPI void (CALLBACK * disp__gluDeleteQuadric) ( GLUquadricObj* quad );   
+
+LIBAPI void (CALLBACK * disp__gluDeleteNurbsRenderer) ( GLUnurbsObj* nurb );
+
+LIBAPI void (CALLBACK * disp__gluDeleteTess) ( GLUtesselator* tess );
+
+LIBAPI GLUquadricObj* (CALLBACK * disp__gluNewQuadric) ( void );
+
+LIBAPI GLUnurbsObj* (CALLBACK * disp__gluNewNurbsRenderer) ( void );
+
+LIBAPI GLUtesselator* (CALLBACK * disp__gluNewTess) ( void );
+/**
+ * C2J Parser Version 2.0
+ * Jausoft - Sven Goethel Software Development
+ * Reading from file: glu-proto-auto.orig.h . . .
+ * Destination-Class: gl4java_GLUFuncJauJNI ! 
+ */
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void gluLookAt ( GLdouble eyex , GLdouble eyey , GLdouble eyez , GLdouble centerx , GLdouble centery , GLdouble centerz , GLdouble upx , GLdouble upy , GLdouble upz ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__gluLookAt )(GLdouble, GLdouble, GLdouble, GLdouble, GLdouble, GLdouble, GLdouble, GLdouble, GLdouble);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void gluOrtho2D ( GLdouble left , GLdouble right , GLdouble bottom , GLdouble top ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__gluOrtho2D )(GLdouble, GLdouble, GLdouble, GLdouble);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void gluPerspective ( GLdouble fovy , GLdouble aspect , GLdouble zNear , GLdouble zFar ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__gluPerspective )(GLdouble, GLdouble, GLdouble, GLdouble);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void gluPickMatrix ( GLdouble x , GLdouble y , GLdouble width , GLdouble height , GLint * viewport ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__gluPickMatrix )(GLdouble, GLdouble, GLdouble, GLdouble, GLint *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern GLint gluProject ( GLdouble objx , GLdouble objy , GLdouble objz , const GLdouble modelMatrix [ 16 ] , const GLdouble projMatrix [ 16 ] , const GLint viewport [ 4 ] , GLdouble * winx , GLdouble * winy , GLdouble * winz ) ;
+ * </pre> 
+ */
+	LIBAPI GLint (CALLBACK * disp__gluProject )(GLdouble, GLdouble, GLdouble, const GLdouble *, const GLdouble *, const GLint *, GLdouble *, GLdouble *, GLdouble *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern GLint gluUnProject ( GLdouble winx , GLdouble winy , GLdouble winz , const GLdouble modelMatrix [ 16 ] , const GLdouble projMatrix [ 16 ] , const GLint viewport [ 4 ] , GLdouble * objx , GLdouble * objy , GLdouble * objz ) ;
+ * </pre> 
+ */
+	LIBAPI GLint (CALLBACK * disp__gluUnProject )(GLdouble, GLdouble, GLdouble, const GLdouble *, const GLdouble *, const GLint *, GLdouble *, GLdouble *, GLdouble *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern GLint gluScaleImage ( GLenum format , GLsizei widthin , GLsizei heightin , GLenum typein , const char * datain , GLsizei widthout , GLsizei heightout , GLenum typeout , char * dataout ) ;
+ * </pre> 
+ */
+	LIBAPI GLint (CALLBACK * disp__gluScaleImage )(GLenum, GLsizei, GLsizei, GLenum, const char *, GLsizei, GLsizei, GLenum, char *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern GLint gluBuild1DMipmaps ( GLenum target , GLint components , GLint width , GLenum format , GLenum type , const void * data ) ;
+ * </pre> 
+ */
+	LIBAPI GLint (CALLBACK * disp__gluBuild1DMipmaps )(GLenum, GLint, GLint, GLenum, GLenum, const void *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern GLint gluBuild2DMipmaps ( GLenum target , GLint components , GLint width , GLint height , GLenum format , GLenum type , const void * data ) ;
+ * </pre> 
+ */
+	LIBAPI GLint (CALLBACK * disp__gluBuild2DMipmaps )(GLenum, GLint, GLint, GLint, GLenum, GLenum, const void *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void gluQuadricDrawStyle ( GLUquadricObj * quadObject , GLenum drawStyle ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__gluQuadricDrawStyle )(GLUquadricObj *, GLenum);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void gluQuadricOrientation ( GLUquadricObj * quadObject , GLenum orientation ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__gluQuadricOrientation )(GLUquadricObj *, GLenum);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void gluQuadricNormals ( GLUquadricObj * quadObject , GLenum normals ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__gluQuadricNormals )(GLUquadricObj *, GLenum);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void gluQuadricTexture ( GLUquadricObj * quadObject , GLboolean textureCoords ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__gluQuadricTexture )(GLUquadricObj *, GLboolean);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void gluCylinder ( GLUquadricObj * qobj , GLdouble baseRadius , GLdouble topRadius , GLdouble height , GLint slices , GLint stacks ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__gluCylinder )(GLUquadricObj *, GLdouble, GLdouble, GLdouble, GLint, GLint);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void gluSphere ( GLUquadricObj * qobj , GLdouble radius , GLint slices , GLint stacks ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__gluSphere )(GLUquadricObj *, GLdouble, GLint, GLint);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void gluDisk ( GLUquadricObj * qobj , GLdouble innerRadius , GLdouble outerRadius , GLint slices , GLint loops ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__gluDisk )(GLUquadricObj *, GLdouble, GLdouble, GLint, GLint);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void gluPartialDisk ( GLUquadricObj * qobj , GLdouble innerRadius , GLdouble outerRadius , GLint slices , GLint loops , GLdouble startAngle , GLdouble sweepAngle ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__gluPartialDisk )(GLUquadricObj *, GLdouble, GLdouble, GLint, GLint, GLdouble, GLdouble);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void gluLoadSamplingMatrices ( GLUnurbsObj * nobj , const GLfloat modelMatrix [ 16 ] , const GLfloat projMatrix [ 16 ] , const GLint viewport [ 4 ] ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__gluLoadSamplingMatrices )(GLUnurbsObj *, const GLfloat *, const GLfloat *, const GLint *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void gluNurbsProperty ( GLUnurbsObj * nobj , GLenum property , GLfloat value ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__gluNurbsProperty )(GLUnurbsObj *, GLenum, GLfloat);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void gluGetNurbsProperty ( GLUnurbsObj * nobj , GLenum property , GLfloat * value ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__gluGetNurbsProperty )(GLUnurbsObj *, GLenum, GLfloat *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void gluBeginCurve ( GLUnurbsObj * nobj ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__gluBeginCurve )(GLUnurbsObj *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void gluEndCurve ( GLUnurbsObj * nobj ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__gluEndCurve )(GLUnurbsObj *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void gluNurbsCurve ( GLUnurbsObj * nobj , GLint nknots , GLfloat * knot , GLint stride , GLfloat * ctlarray , GLint order , GLenum type ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__gluNurbsCurve )(GLUnurbsObj *, GLint, GLfloat *, GLint, GLfloat *, GLint, GLenum);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void gluBeginSurface ( GLUnurbsObj * nobj ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__gluBeginSurface )(GLUnurbsObj *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void gluEndSurface ( GLUnurbsObj * nobj ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__gluEndSurface )(GLUnurbsObj *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void gluNurbsSurface ( GLUnurbsObj * nobj , GLint sknot_count , GLfloat * sknot , GLint tknot_count , GLfloat * tknot , GLint s_stride , GLint t_stride , GLfloat * ctlarray , GLint sorder , GLint torder , GLenum type ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__gluNurbsSurface )(GLUnurbsObj *, GLint, GLfloat *, GLint, GLfloat *, GLint, GLint, GLfloat *, GLint, GLint, GLenum);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void gluBeginTrim ( GLUnurbsObj * nobj ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__gluBeginTrim )(GLUnurbsObj *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void gluEndTrim ( GLUnurbsObj * nobj ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__gluEndTrim )(GLUnurbsObj *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void gluPwlCurve ( GLUnurbsObj * nobj , GLint count , GLfloat * array , GLint stride , GLenum type ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__gluPwlCurve )(GLUnurbsObj *, GLint, GLfloat *, GLint, GLenum);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void gluTessBeginPolygon ( GLUtesselator * tobj , void * polygon_data ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__gluTessBeginPolygon )(GLUtesselator *, void *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void gluTessBeginContour ( GLUtesselator * tobj ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__gluTessBeginContour )(GLUtesselator *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void gluTessVertex ( GLUtesselator * tobj , GLdouble coords [ 3 ] , void * vertex_data ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__gluTessVertex )(GLUtesselator *, GLdouble *, void *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void gluTessEndContour ( GLUtesselator * tobj ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__gluTessEndContour )(GLUtesselator *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void gluTessEndPolygon ( GLUtesselator * tobj ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__gluTessEndPolygon )(GLUtesselator *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void gluTessProperty ( GLUtesselator * tobj , GLenum which , GLdouble value ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__gluTessProperty )(GLUtesselator *, GLenum, GLdouble);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void gluTessNormal ( GLUtesselator * tobj , GLdouble x , GLdouble y , GLdouble z ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__gluTessNormal )(GLUtesselator *, GLdouble, GLdouble, GLdouble);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void gluGetTessProperty ( GLUtesselator * tobj , GLenum which , GLdouble * value ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__gluGetTessProperty )(GLUtesselator *, GLenum, GLdouble *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void gluBeginPolygon ( GLUtesselator * tobj ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__gluBeginPolygon )(GLUtesselator *);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void gluNextContour ( GLUtesselator * tobj , GLenum type ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__gluNextContour )(GLUtesselator *, GLenum);
+
+/**
+ * Original Function-Prototype :
+ * <pre> 
+   extern void gluEndPolygon ( GLUtesselator * tobj ) ;
+ * </pre> 
+ */
+	LIBAPI void (CALLBACK * disp__gluEndPolygon )(GLUtesselator *);
+
+/* C2J Parser Version 2.0:  Java program parsed successfully. */ 
diff --git a/src/unix/video-drivers/glu-disp-var.hc b/src/unix/video-drivers/glu-disp-var.hc
new file mode 100644
index 0000000..496955e
--- /dev/null
+++ b/src/unix/video-drivers/glu-disp-var.hc
@@ -0,0 +1,116 @@
+/* WARNING ! WARNING *** THIS FILE IS GENERATED BY C2J !!!
+
+   DO NOT MAKE ANY CHANGES *** MAKE CHANGES IN THE SKELETON FILES !!!
+*/
+
+
+
+const GLubyte *(CALLBACK * disp__gluGetString )( GLenum name ) = NULL;
+
+const GLubyte * (CALLBACK * disp__gluErrorString) ( GLenum) = NULL;
+
+void (CALLBACK * disp__gluQuadricCallback) ( GLUquadricObj* quad, GLenum which, GLvoid (CALLBACK *)( )) = NULL;
+
+void (CALLBACK * disp__gluNurbsCallback) ( GLUnurbsObj* nurb, GLenum which, GLvoid (CALLBACK *)( )) = NULL;
+
+void (CALLBACK * disp__gluTessCallback) ( GLUtesselator* tess, GLenum which, GLvoid (CALLBACK *)( )) = NULL;
+
+void (CALLBACK * disp__gluDeleteQuadric) ( GLUquadricObj* quad ) = NULL;   
+
+void (CALLBACK * disp__gluDeleteNurbsRenderer) ( GLUnurbsObj* nurb ) = NULL;
+
+void (CALLBACK * disp__gluDeleteTess) ( GLUtesselator* tess ) = NULL;
+
+GLUquadricObj* (CALLBACK * disp__gluNewQuadric) ( void ) = NULL;
+
+GLUnurbsObj* (CALLBACK * disp__gluNewNurbsRenderer) ( void ) = NULL;
+
+GLUtesselator* (CALLBACK * disp__gluNewTess) ( void ) = NULL;
+/**
+ * C2J Parser Version 2.0
+ * Jausoft - Sven Goethel Software Development
+ * Reading from file: glu-proto-auto.orig.h . . .
+ * Destination-Class: gl4java_GLUFuncJauJNI ! 
+ */
+
+	void (CALLBACK * disp__gluLookAt )(GLdouble, GLdouble, GLdouble, GLdouble, GLdouble, GLdouble, GLdouble, GLdouble, GLdouble) = NULL;
+
+	void (CALLBACK * disp__gluOrtho2D )(GLdouble, GLdouble, GLdouble, GLdouble) = NULL;
+
+	void (CALLBACK * disp__gluPerspective )(GLdouble, GLdouble, GLdouble, GLdouble) = NULL;
+
+	void (CALLBACK * disp__gluPickMatrix )(GLdouble, GLdouble, GLdouble, GLdouble, GLint *) = NULL;
+
+	GLint (CALLBACK * disp__gluProject )(GLdouble, GLdouble, GLdouble, const GLdouble *, const GLdouble *, const GLint *, GLdouble *, GLdouble *, GLdouble *) = NULL;
+
+	GLint (CALLBACK * disp__gluUnProject )(GLdouble, GLdouble, GLdouble, const GLdouble *, const GLdouble *, const GLint *, GLdouble *, GLdouble *, GLdouble *) = NULL;
+
+	GLint (CALLBACK * disp__gluScaleImage )(GLenum, GLsizei, GLsizei, GLenum, const char *, GLsizei, GLsizei, GLenum, char *) = NULL;
+
+	GLint (CALLBACK * disp__gluBuild1DMipmaps )(GLenum, GLint, GLint, GLenum, GLenum, const void *) = NULL;
+
+	GLint (CALLBACK * disp__gluBuild2DMipmaps )(GLenum, GLint, GLint, GLint, GLenum, GLenum, const void *) = NULL;
+
+	void (CALLBACK * disp__gluQuadricDrawStyle )(GLUquadricObj *, GLenum) = NULL;
+
+	void (CALLBACK * disp__gluQuadricOrientation )(GLUquadricObj *, GLenum) = NULL;
+
+	void (CALLBACK * disp__gluQuadricNormals )(GLUquadricObj *, GLenum) = NULL;
+
+	void (CALLBACK * disp__gluQuadricTexture )(GLUquadricObj *, GLboolean) = NULL;
+
+	void (CALLBACK * disp__gluCylinder )(GLUquadricObj *, GLdouble, GLdouble, GLdouble, GLint, GLint) = NULL;
+
+	void (CALLBACK * disp__gluSphere )(GLUquadricObj *, GLdouble, GLint, GLint) = NULL;
+
+	void (CALLBACK * disp__gluDisk )(GLUquadricObj *, GLdouble, GLdouble, GLint, GLint) = NULL;
+
+	void (CALLBACK * disp__gluPartialDisk )(GLUquadricObj *, GLdouble, GLdouble, GLint, GLint, GLdouble, GLdouble) = NULL;
+
+	void (CALLBACK * disp__gluLoadSamplingMatrices )(GLUnurbsObj *, const GLfloat *, const GLfloat *, const GLint *) = NULL;
+
+	void (CALLBACK * disp__gluNurbsProperty )(GLUnurbsObj *, GLenum, GLfloat) = NULL;
+
+	void (CALLBACK * disp__gluGetNurbsProperty )(GLUnurbsObj *, GLenum, GLfloat *) = NULL;
+
+	void (CALLBACK * disp__gluBeginCurve )(GLUnurbsObj *) = NULL;
+
+	void (CALLBACK * disp__gluEndCurve )(GLUnurbsObj *) = NULL;
+
+	void (CALLBACK * disp__gluNurbsCurve )(GLUnurbsObj *, GLint, GLfloat *, GLint, GLfloat *, GLint, GLenum) = NULL;
+
+	void (CALLBACK * disp__gluBeginSurface )(GLUnurbsObj *) = NULL;
+
+	void (CALLBACK * disp__gluEndSurface )(GLUnurbsObj *) = NULL;
+
+	void (CALLBACK * disp__gluNurbsSurface )(GLUnurbsObj *, GLint, GLfloat *, GLint, GLfloat *, GLint, GLint, GLfloat *, GLint, GLint, GLenum) = NULL;
+
+	void (CALLBACK * disp__gluBeginTrim )(GLUnurbsObj *) = NULL;
+
+	void (CALLBACK * disp__gluEndTrim )(GLUnurbsObj *) = NULL;
+
+	void (CALLBACK * disp__gluPwlCurve )(GLUnurbsObj *, GLint, GLfloat *, GLint, GLenum) = NULL;
+
+	void (CALLBACK * disp__gluTessBeginPolygon )(GLUtesselator *, void *) = NULL;
+
+	void (CALLBACK * disp__gluTessBeginContour )(GLUtesselator *) = NULL;
+
+	void (CALLBACK * disp__gluTessVertex )(GLUtesselator *, GLdouble *, void *) = NULL;
+
+	void (CALLBACK * disp__gluTessEndContour )(GLUtesselator *) = NULL;
+
+	void (CALLBACK * disp__gluTessEndPolygon )(GLUtesselator *) = NULL;
+
+	void (CALLBACK * disp__gluTessProperty )(GLUtesselator *, GLenum, GLdouble) = NULL;
+
+	void (CALLBACK * disp__gluTessNormal )(GLUtesselator *, GLdouble, GLdouble, GLdouble) = NULL;
+
+	void (CALLBACK * disp__gluGetTessProperty )(GLUtesselator *, GLenum, GLdouble *) = NULL;
+
+	void (CALLBACK * disp__gluBeginPolygon )(GLUtesselator *) = NULL;
+
+	void (CALLBACK * disp__gluNextContour )(GLUtesselator *, GLenum) = NULL;
+
+	void (CALLBACK * disp__gluEndPolygon )(GLUtesselator *) = NULL;
+
+/* C2J Parser Version 2.0:  Java program parsed successfully. */ 
diff --git a/src/unix/video-drivers/glvec.c b/src/unix/video-drivers/glvec.c
new file mode 100644
index 0000000..3276894
--- /dev/null
+++ b/src/unix/video-drivers/glvec.c
@@ -0,0 +1,488 @@
+/*****************************************************************
+
+  OpenGL vector routines
+
+  Copyright 1998 by Mike Oliphant - oliphant@ling.ed.ac.uk
+
+    http://www.ling.ed.ac.uk/~oliphant/glmame
+
+  Improved by Sven Goethel, http://www.jausoft.com, sgoethel@jausoft.com
+
+  This code may be used and distributed under the terms of the
+  Mame license
+
+*****************************************************************/
+
+#ifdef xgl
+
+#include "xmame.h"
+#include "glmame.h"
+#include "driver.h"
+#include "artwork.h"
+#include "vidhrdw/vector.h"
+
+#include "osinline.h"
+
+void CalcCabPointbyViewpoint( 
+		   GLdouble vx_gscr_view, GLdouble vy_gscr_view, 
+                   GLdouble *vx_p, GLdouble *vy_p, GLdouble *vz_p
+		 );
+
+extern int winwidth,winheight;
+extern GLdouble  s__cscr_w_view, s__cscr_h_view;
+
+
+unsigned char *vectorram;
+size_t vectorram_size;
+
+GLuint veclist=0;
+
+int listcreated=0;
+int inlist=0;
+int inbegin=0;
+
+static int vec_min_x;
+static int vec_min_y;
+static int vec_max_x;
+static int vec_max_y;
+static int vec_cent_x;
+static int vec_cent_y;
+static int vecwidth;
+static int vecheight;
+static int vecshift;
+
+static GLdouble vecoldx,vecoldy;
+
+float gl_beam=1.0;
+static int flicker;                              /* beam flicker value     */
+
+static int vector_orientation;
+
+/*
+static double gamma_correction = 1.2;
+*/
+static double flicker_correction = 0.0;
+static double intensity_correction = 1.5;
+
+vector_pixel_t *vector_dirty_list;
+
+double osd_get_gamma(void);
+
+/*
+ * multiply and divide routines for drawing lines
+ * can be be replaced by an assembly routine in osinline.h
+ */
+#ifndef vec_mult
+INLINE int vec_mult(int parm1, int parm2)
+{
+	int temp,result;
+
+	temp     = abs(parm1);
+	result   = (temp&0x0000ffff) * (parm2&0x0000ffff);
+	result >>= 16;
+	result  += (temp&0x0000ffff) * (parm2>>16       );
+	result  += (temp>>16       ) * (parm2&0x0000ffff);
+	result >>= 16;
+	result  += (temp>>16       ) * (parm2>>16       );
+
+	if( parm1 < 0 )
+		return(-result);
+	else
+		return( result);
+}
+#endif
+
+/* can be be replaced by an assembly routine in osinline.h */
+#ifndef vec_div
+INLINE int vec_div(int parm1, int parm2)
+{
+	if( (parm2>>12) )
+	{
+		parm1 = (parm1<<4) / (parm2>>12);
+		if( parm1 > 0x00010000 )
+			return( 0x00010000 );
+		if( parm1 < -0x00010000 )
+			return( -0x00010000 );
+		return( parm1 );
+	}
+	return( 0x00010000 );
+}
+#endif
+
+void set_gl_beam(float new_value)
+{
+	gl_beam = new_value;
+	disp__glLineWidth(gl_beam);
+	disp__glPointSize(gl_beam);
+	printf("GLINFO (vec): beamer size %f\n", gl_beam);
+}
+
+float get_gl_beam()
+{ return gl_beam; }
+
+void vector_set_flip_x (int flip)
+{
+	if (flip)
+		vector_orientation |= ORIENTATION_FLIP_X;
+	else
+		vector_orientation &= ~ORIENTATION_FLIP_X;
+}
+
+void vector_set_flip_y (int flip)
+{
+	if (flip)
+		vector_orientation |= ORIENTATION_FLIP_Y;
+	else
+		vector_orientation &= ~ORIENTATION_FLIP_Y;
+}
+
+void vector_set_swap_xy (int swap)
+{
+	if (swap)
+		vector_orientation |= ORIENTATION_SWAP_XY;
+	else
+		vector_orientation &= ~ORIENTATION_SWAP_XY;
+}
+
+/*
+void vector_set_gamma(double _gamma)
+{
+	gamma_correction = _gamma;
+}
+
+double vector_get_gamma(void)
+{
+	return gamma_correction;
+}
+*/
+
+void vector_set_flicker(float _flicker)
+{
+	flicker_correction = _flicker;
+	flicker = (int)(flicker_correction * 2.55);
+}
+
+float vector_get_flicker(void)
+{
+	return flicker_correction;
+}
+
+void vector_set_intensity(float _intensity)
+{
+	intensity_correction = _intensity;
+}
+
+float vector_get_intensity(void)
+{
+	return intensity_correction;
+}
+
+
+/*
+ * Initializes vector game video emulation
+ */
+
+VIDEO_START( vector )
+{
+        vec_min_x =Machine->visible_area.min_x;
+        vec_min_y =Machine->visible_area.min_y;
+        vec_max_x =Machine->visible_area.max_x;
+        vec_max_y =Machine->visible_area.max_y;
+        vecwidth  =vec_max_x-vec_min_x;
+        vecheight =vec_max_y-vec_min_y;
+        vec_cent_x=(vec_max_x+vec_min_x)/2;
+        vec_cent_y=(vec_max_y+vec_min_y)/2;
+
+	printf("GLINFO (vec): min %d/%d, max %d/%d, cent %d/%d,\n\t vecsize %dx%d\n", 
+		vec_min_x, vec_min_y, vec_max_x, vec_max_y,
+		vec_cent_x, vec_cent_y, vecwidth, vecheight);
+
+        veclist=disp__glGenLists(1);
+	listcreated=1;
+
+	set_gl_beam(gl_beam);
+	vector_set_flicker(options.vector_flicker);
+
+  	return 0;
+}
+
+/*
+ * Stop the vector video hardware emulation. Free memory.
+ */
+
+void vector_vh_stop (void)
+{
+	if(inlist && inbegin)
+	{
+		GL_END();
+		inbegin=0;
+	}
+
+	CHECK_GL_BEGINEND();
+	CHECK_GL_ERROR ();
+
+	if(inlist) {
+		disp__glEndList();
+		inlist=0;
+	}
+
+	if(listcreated)
+	{
+		disp__glDeleteLists(veclist, 1);
+		listcreated=0;
+	}
+}
+
+/*
+ * Setup scaling. Currently the Sega games are stuck at VECSHIFT 15
+ * and the the AVG games at VECSHIFT 16
+ */
+
+void vector_set_shift (int shift)
+{
+  vecshift=shift;
+}
+
+/* Convert an xy point to xyz in the 3D scene */
+
+int PointConvert(int x,int y,GLdouble *sx,GLdouble *sy,GLdouble *sz)
+{
+  int x1, y1;
+  GLdouble dx,dy,tmp;
+
+  x1=x>>vecshift;
+  y1=y>>vecshift;
+
+  dx=(GLdouble)x1/(GLdouble)vecwidth;
+  dy=(GLdouble)y1/(GLdouble)vecheight;
+
+  if(!cabview) {
+	  if(Machine->orientation&ORIENTATION_SWAP_XY) {
+	    tmp=dx;
+	    dx=dy;
+	    dy=tmp;
+	  }
+
+	  if(Machine->orientation&ORIENTATION_FLIP_X)
+	    dx=1.0-dx;
+
+	  if(Machine->orientation&ORIENTATION_FLIP_Y)
+	    dy=1.0-dy;
+
+	  *sx=dx;
+	  *sy=dy;
+  } else {
+	CalcCabPointbyViewpoint ( dx*s__cscr_w_view,
+	                          dy*s__cscr_h_view,
+				  sx, sy, sz );
+  }
+
+  if( 0<=*sx && *sx<=1.0 &&
+      0<=*sy && *sy<=1.0 
+    )
+    return 1;
+
+  /*
+  printf("GLINFO (vec): x/y %d/%d,\n\tx1/y1 %d/%d, dx/dy %f/%f, size %dx%d\n",
+  	x, y, x>>vecshift, y>>vecshift, dx, dy, vecwidth, vecheight);
+  */
+
+  return 0;
+}
+
+static void vector_begin_list(void)
+{
+  disp__glNewList(veclist,GL_COMPILE);
+  inlist=1;
+
+  CHECK_GL_ERROR ();
+
+  disp__glColor4d(1.0,1.0,1.0,1.0);
+
+  GL_BEGIN(GL_LINE_STRIP);
+  inbegin=1;
+}
+
+
+/*
+ * Adds a line end point to the vertices list. The vector processor emulation
+ * needs to call this.
+ */
+void vector_add_point (int x, int y, rgb_t color, int intensity)
+{
+  unsigned char r1,g1,b1;
+  double red=0.0, green=0.0, blue=0.0;
+  GLdouble sx,sy,sz;
+  int ptHack=0;
+  int ok;
+  double gamma_correction = palette_get_global_gamma();
+
+  if(!inlist)
+	vector_begin_list();
+
+  ok = PointConvert(x,y,&sx,&sy,&sz);
+
+  b1 =   color        & 0xff ;
+  g1 =  (color >>  8) & 0xff ;
+  r1 =  (color >> 16) & 0xff ;
+
+  if(intensity<0)
+	intensity=0;
+
+  if(sx==vecoldx&&sy==vecoldy&&inbegin&&intensity>0) 
+  {
+	  /**
+	   * Hack to draw points -- zero-length lines don't show up
+	   *
+	   * But games, e.g. tacscan have zero lines within the LINE_STRIP,
+	   * so we do try to continue the line strip :-)
+	   *
+	   * Part 1
+	   */
+	  GL_END();
+	  inbegin=0;
+  	  ptHack=1;
+  } else {
+  	  
+	  /**
+	   * the usual "normal" way ..
+	   */
+	  if(intensity==0&&inbegin)
+	  {
+		GL_END();
+		inbegin=0;
+	  }
+
+	  if(!inbegin)
+	  {
+		GL_BEGIN(GL_LINE_STRIP);
+		inbegin=1;
+	  }
+  	  ptHack=0;
+  }
+
+  intensity *= intensity_correction;
+  if (intensity > 0xff)
+	intensity = 0xff;
+
+  if (flicker && (intensity > 0))
+  {
+	intensity += (intensity * (0x80-(rand()&0xff)) * flicker)>>16;
+	if (intensity < 0)
+		intensity = 0;
+	if (intensity > 0xff)
+		intensity = 0xff;
+  }
+
+  if(use_mod_ctable)
+  {
+	  red   = (double)intensity/255.0 * pow (r1 / 255.0, 1 / gamma_correction);
+	  green = (double)intensity/255.0 * pow (g1 / 255.0, 1 / gamma_correction);
+	  blue  = (double)intensity/255.0 * pow (b1 / 255.0, 1 / gamma_correction);
+	  disp__glColor3d(red, green, blue);
+  } else {
+	  disp__glColor3ub(r1, g1, b1);
+  }
+
+  if(ptHack)
+  {
+	/**
+	 * Hack to draw points -- zero-length lines don't show up
+	 *
+	 * But games, e.g. tacscan have zero lines within the LINE_STRIP,
+	 * so we do try to continue the line strip :-)
+	 *
+	 * Part 2
+	 */
+  	if(inbegin) {
+	        /* see above Part 1 */
+		fprintf(stderr,"GLERROR: never ever at %s, %d\n",
+			__FILE__, __LINE__);
+	}
+	GL_BEGIN(GL_POINTS);
+	inbegin=1;
+
+	if(cabview)
+	  disp__glVertex3d(sx,sy,sz);
+	else disp__glVertex2d(sx,sy);
+
+	GL_END();
+	inbegin=0;
+
+	GL_BEGIN(GL_LINE_STRIP);
+	inbegin=1;
+  }
+
+  if(cabview)
+    disp__glVertex3d(sx,sy,sz);
+  else disp__glVertex2d(sx,sy);
+
+  vecoldx=sx; vecoldy=sy;
+}
+
+void vector_add_point_callback (int x, int y, rgb_t (*color_callback)(void), int intensity)
+{
+  vector_add_point(x, y, (*color_callback)(), intensity);
+}
+
+/*
+ * Add new clipping info to the list
+ */
+
+void vector_add_clip (int x1, int yy1, int x2, int y2)
+{
+}
+
+/*
+ * The vector CPU creates a new display list.
+ */
+
+void vector_clear_list(void)
+{
+  if(inbegin) {
+	GL_END();
+	inbegin=0;
+  }
+
+  CHECK_GL_BEGINEND();
+  CHECK_GL_ERROR ();
+
+  if(!listcreated)
+  {
+	  CHECK_GL_BEGINEND();
+	  veclist=disp__glGenLists(1);
+	  listcreated=1;
+  }
+
+  CHECK_GL_ERROR ();
+
+  if(inlist) {
+	disp__glEndList();
+	inlist=0;
+  }
+
+  CHECK_GL_ERROR ();
+}
+
+/* Called when the frame is complete */
+
+VIDEO_UPDATE( vector )
+{
+  if (!cliprect && bitmap!=NULL)
+  {
+	fillbitmap(bitmap,Machine->uifont->colortable[0],NULL);
+  }
+
+  if(inlist && inbegin)
+  {
+	GL_END();
+	inbegin=0;
+  }
+
+  if(inlist) {
+	disp__glEndList();
+	inlist=0;
+  }
+}
+
+#endif /* ifdef xgl */
diff --git a/src/unix/video-drivers/glx-disp-fetch.hc b/src/unix/video-drivers/glx-disp-fetch.hc
new file mode 100644
index 0000000..b3ee5c9
--- /dev/null
+++ b/src/unix/video-drivers/glx-disp-fetch.hc
@@ -0,0 +1,43 @@
+/* WARNING ! WARNING *** THIS FILE IS GENERATED BY C2J !!!
+
+   DO NOT MAKE ANY CHANGES *** MAKE CHANGES IN THE SKELETON FILES !!!
+*/
+
+
+
+    disp__glXWaitGL = (void (CALLBACK *)( void ))
+        GET_GL_PROCADDRESS("glXWaitGL");
+
+    disp__glXDestroyGLXPixmap = (void (CALLBACK *)( Display *, GLXPixmap))
+       GET_GL_PROCADDRESS("glXDestroyGLXPixmap");
+
+    disp__glXQueryExtension = (Bool (CALLBACK *)( Display *, int *, int *))
+        GET_GL_PROCADDRESS("glXQueryExtension");
+
+    disp__glXGetClientString = (const char * (CALLBACK *)( Display *, int ))
+        GET_GL_PROCADDRESS("glXGetClientString");
+
+    disp__glXCreateGLXPixmap = (GLXPixmap (CALLBACK *)( Display *, XVisualInfo *, Pixmap))
+        GET_GL_PROCADDRESS("glXCreateGLXPixmap");
+
+    disp__glXChooseVisual = (XVisualInfo* (CALLBACK *) (Display *, int , int *)) 
+    	GET_GL_PROCADDRESS("glXChooseVisual");
+
+    disp__glXCreateContext = (GLXContext (CALLBACK *) (Display *, XVisualInfo *, GLXContext, Bool))
+    	GET_GL_PROCADDRESS("glXCreateContext");
+
+    disp__glXGetCurrentContext = (GLXContext (CALLBACK *) ())
+    	GET_GL_PROCADDRESS("glXGetCurrentContext");
+
+    disp__glXDestroyContext = (void (CALLBACK *) (Display *, GLXContext))
+    	GET_GL_PROCADDRESS("glXDestroyContext");
+
+    disp__glXGetConfig = (int (CALLBACK *) (Display *, XVisualInfo *, int, int *)) 
+    	GET_GL_PROCADDRESS("glXGetConfig");
+
+    disp__glXMakeCurrent = (Bool (CALLBACK *) (Display *, GLXDrawable, GLXContext)) 
+    	GET_GL_PROCADDRESS("glXMakeCurrent");
+
+    disp__glXSwapBuffers = (void (CALLBACK *) (Display *, GLXDrawable)) 
+    	GET_GL_PROCADDRESS("glXSwapBuffers");
+
diff --git a/src/unix/video-drivers/glx-disp-var.h b/src/unix/video-drivers/glx-disp-var.h
new file mode 100644
index 0000000..2ac07c7
--- /dev/null
+++ b/src/unix/video-drivers/glx-disp-var.h
@@ -0,0 +1,21 @@
+/* WARNING ! WARNING *** THIS FILE IS GENERATED BY C2J !!!
+
+   DO NOT MAKE ANY CHANGES *** MAKE CHANGES IN THE SKELETON FILES !!!
+*/
+
+
+
+LIBAPI void *(CALLBACK * disp__glXGetProcAddress) (const GLubyte *);
+LIBAPI void (CALLBACK *  disp__glXWaitGL)( void );
+LIBAPI void (CALLBACK *  disp__glXDestroyGLXPixmap)( Display *dpy, GLXPixmap pix );
+LIBAPI Bool (CALLBACK *  disp__glXQueryExtension)( Display *dpy, int *errorBase, int *eventBase );
+LIBAPI const char * (CALLBACK *  disp__glXGetClientString)( Display *dpy, int name );
+LIBAPI GLXPixmap (CALLBACK * disp__glXCreateGLXPixmap)( Display *, XVisualInfo *, Pixmap);
+LIBAPI XVisualInfo* (CALLBACK * disp__glXChooseVisual) (Display *, int , int *);
+LIBAPI GLXContext (CALLBACK * disp__glXCreateContext) (Display *, XVisualInfo *, GLXContext, Bool);
+LIBAPI GLXContext (CALLBACK * disp__glXGetCurrentContext) (void);
+LIBAPI void (CALLBACK * disp__glXDestroyContext) (Display *, GLXContext);
+LIBAPI int (CALLBACK * disp__glXGetConfig) (Display *, XVisualInfo *, int, int *);
+LIBAPI Bool (CALLBACK * disp__glXMakeCurrent) (Display *, GLXDrawable, GLXContext);
+LIBAPI void (CALLBACK * disp__glXSwapBuffers) (Display *, GLXDrawable);
+
diff --git a/src/unix/video-drivers/glx-disp-var.hc b/src/unix/video-drivers/glx-disp-var.hc
new file mode 100644
index 0000000..5c04c37
--- /dev/null
+++ b/src/unix/video-drivers/glx-disp-var.hc
@@ -0,0 +1,21 @@
+/* WARNING ! WARNING *** THIS FILE IS GENERATED BY C2J !!!
+
+   DO NOT MAKE ANY CHANGES *** MAKE CHANGES IN THE SKELETON FILES !!!
+*/
+
+
+
+void *(CALLBACK * disp__glXGetProcAddress) (const GLubyte *) = NULL;
+void (CALLBACK *  disp__glXWaitGL)( ) = NULL;
+void (CALLBACK *  disp__glXDestroyGLXPixmap)( Display *dpy, GLXPixmap pix ) = NULL;
+Bool (CALLBACK *  disp__glXQueryExtension)( Display *dpy, int *errorBase, int *eventBase ) = NULL;
+const char * (CALLBACK *  disp__glXGetClientString)( Display *dpy, int name ) = NULL;
+GLXPixmap (CALLBACK * disp__glXCreateGLXPixmap)( Display *, XVisualInfo *, Pixmap) = NULL;
+XVisualInfo* (CALLBACK * disp__glXChooseVisual) (Display *, int , int *) = NULL;
+GLXContext (CALLBACK * disp__glXCreateContext) (Display *, XVisualInfo *, GLXContext, Bool) = NULL;
+GLXContext (CALLBACK * disp__glXGetCurrentContext) () = NULL;
+void (CALLBACK * disp__glXDestroyContext) (Display *, GLXContext) = NULL;
+int (CALLBACK * disp__glXGetConfig) (Display *, XVisualInfo *, int, int *) = NULL;
+Bool (CALLBACK * disp__glXMakeCurrent) (Display *, GLXDrawable, GLXContext) = NULL;
+void (CALLBACK * disp__glXSwapBuffers) (Display *, GLXDrawable) = NULL;
+
diff --git a/src/unix/video-drivers/glxtool.c b/src/unix/video-drivers/glxtool.c
new file mode 100644
index 0000000..4965ad6
--- /dev/null
+++ b/src/unix/video-drivers/glxtool.c
@@ -0,0 +1,877 @@
+/**
+ * glxtool.c
+ *
+ * Copyright (C) 2001  Sven Goethel
+ *
+ * GNU Library General Public License 
+ * as published by the Free Software Foundation
+ *
+ * http://www.gnu.org/copyleft/lgpl.html
+ * General dynamical loading OpenGL (GL/GLU) support for:
+ */
+
+#include "glxtool.h"
+
+#include "glx-disp-var.hc"
+
+/**
+ * do not call this one directly,
+ * use fetch_GL_FUNCS (gltool.c) instead
+ */
+void LIBAPIENTRY fetch_GLX_FUNCS (const char * libGLName, 
+			          const char * libGLUName, int force)
+{
+  static int _firstRun = 1;
+
+  if(force)
+        _firstRun = 1;
+
+  if(!_firstRun)
+  	return;
+
+  #define GET_GL_PROCADDRESS(a) getGLProcAddressHelper (libGLName, libGLUName, ( SYMBOL_PREFIX a), NULL, 1, 0);
+
+  #include "glx-disp-fetch.hc"
+
+  _firstRun=0;
+}
+
+/*
+ * Name      : get_GC
+ *
+ * Parameters: win    - the X window use to the OpenGL context with
+ *             visual - The visual to create the context for
+ *             gc     - a pointer to a GLXContext structure. This is how
+ *                      the created context will be returned to the caller
+ *
+ * Returns   : a pointer to a created GLXContext is returned through the
+ *             gc argument.
+ *             int - an error code: 0 means everything was fine
+ *                                 -1 context creation failed
+ *                                 -2 context/window association failed
+ *
+ * Purpose   : create an X window Graphics context and assocaite it with
+ *             the window. It returns 0 if everything was fine, -1 if the
+ *             context could not be created, -2 if the context could not
+ *             be associated with the window
+ */
+int LIBAPIENTRY get_GC( Display *display, Window win, XVisualInfo *visual,
+            GLXContext *gc, GLXContext gc_share,
+	    int verbose )
+{
+    int trial = 2;
+
+    while(trial>0)
+    {
+    	switch(trial)
+	{
+	  case 2:
+	    *gc = disp__glXCreateContext( display, visual, gc_share, GL_TRUE );
+	    break;
+	  case 1:
+	    *gc = disp__glXCreateContext( display, visual, gc_share, GL_FALSE );
+	    break;
+	}
+    	trial--;
+
+        /* check if the context could be created */
+        if( *gc == NULL ) {
+	    continue;
+        }
+
+        /* associated the context with the X window */
+        if( disp__glXMakeCurrent( display, win, *gc ) == False) {
+	    disp__glXDestroyContext( display, *gc );
+            if(verbose)
+	    {
+	      fprintf(stderr, "GLINFO: glXCreateContext/glXDestroyContext trial(%d) %p\n", trial, (void *)*gc);
+	    }
+	    continue;
+        } else {
+	    if(verbose)
+		fprintf(stderr, "GLINFO: glXCreateContext trial (%d) sure %p\n", trial, (void *)*gc);
+	    return 0;
+        }
+    }
+
+    return -2;
+}
+
+
+int LIBAPIENTRY setVisualAttribListByGLCapabilities( 
+					int visualAttribList[/*>=32*/],
+				        GLCapabilities *glCaps )
+{
+    int i=0;
+    visualAttribList[i++] = GLX_USE_GL;    /* paranoia .. */
+    visualAttribList[i++] = GLX_RED_SIZE;
+    visualAttribList[i++] = 1;
+    visualAttribList[i++] = GLX_GREEN_SIZE;
+    visualAttribList[i++] = 1;
+    visualAttribList[i++] = GLX_BLUE_SIZE;
+    visualAttribList[i++] = 1;
+    visualAttribList[i++] = GLX_DEPTH_SIZE;
+    visualAttribList[i++] = 1;
+    visualAttribList[i++] = GLX_ACCUM_RED_SIZE;
+    visualAttribList[i++] = (glCaps->accumRedBits>0)?1:0;
+    visualAttribList[i++] = GLX_ACCUM_GREEN_SIZE;
+    visualAttribList[i++] = (glCaps->accumGreenBits>0)?1:0;
+    visualAttribList[i++] = GLX_ACCUM_BLUE_SIZE;
+    visualAttribList[i++] = (glCaps->accumBlueBits>0)?1:0;
+
+    if(COLOR_RGBA == glCaps->color)
+    {
+	    visualAttribList[i++] = GLX_RGBA;
+	    visualAttribList[i++] = GLX_ALPHA_SIZE;
+	    visualAttribList[i++] = (glCaps->alphaBits>0)?1:0;
+	    visualAttribList[i++] = GLX_ACCUM_ALPHA_SIZE;
+	    visualAttribList[i++] = (glCaps->accumAlphaBits>0)?1:0;
+    }
+    if(BUFFER_DOUBLE==glCaps->buffer)
+	    visualAttribList[i++] = GLX_DOUBLEBUFFER;
+
+    if(STEREO_ON==glCaps->stereo)
+	    visualAttribList[i++] = GLX_STEREO;
+
+    visualAttribList[i++] = GLX_STENCIL_SIZE;
+    visualAttribList[i++] = glCaps->stencilBits;
+    visualAttribList[i] = None;
+    return i;
+}
+
+/**
+ * Description for pWin:
+ *   if ownwin:
+ *      input: 	the parent window
+ *      output: the newly created window
+ *   else if ! ownwin:
+ *      i/o:    the window itself
+ */
+VisualGC LIBAPIENTRY findVisualGlX( Display *display, 
+			       Window rootWin,
+			       Window * pWin, 
+			       int width, int height,
+    			       GLCapabilities * glCaps,
+			       int * pOwnWin,
+			       XSetWindowAttributes * pOwnWinAttr,
+			       unsigned long ownWinmask,
+			       GLXContext shareWith,
+			       int offscreen,
+			       Pixmap *pix,
+			       int verbose
+			     )
+{
+    Window newWin = 0;
+    int visualAttribList[64];
+    int j=0;
+    int done=0;
+    VisualGC vgc = { NULL, 0, 0 };
+    int tryChooseVisual = 1;
+    int gc_ret = 0;
+    int ownwin = 0;
+    GLCapabilities _glCaps;
+    int accumTestDone=0;
+
+    /** 
+     * The Visual seeked by Function: findVisualIdByFeature !
+     */
+    XVisualInfo * visualList=NULL; /* the visual list, to be XFree-ed */
+
+    /* paranoia .. */
+    glCaps->gl_supported = 1;
+
+    /* backup ... */
+    _glCaps = *glCaps;
+
+    if(pOwnWin) ownwin=*pOwnWin;
+
+    do {
+            if(verbose)
+	    {
+	         fprintf(stderr, "GLINFO: seeking visual loop# %d\n", j);
+	         fprintf(stderr, "GLINFO: seeking gl capabilities:\n");
+		 printGLCapabilities ( glCaps );
+	    }
+
+            if(glCaps->nativeVisualID>=0 && j==0)
+	    {
+	        /**
+		 * if somebody passes us a nativeVisualID,
+		 * we will try to use it .. the 1st time only
+		 */
+	    	vgc.visual = findVisualIdByID(&visualList, 
+		                              (int)(glCaps->nativeVisualID), 
+					       display, *pWin, verbose);
+	    }
+
+	    if(vgc.visual==NULL)
+	    {
+                glCaps->nativeVisualID=0;
+                (void) setVisualAttribListByGLCapabilities( 
+						visualAttribList, glCaps);
+	    }
+
+            if(tryChooseVisual && vgc.visual==NULL)
+	    {
+		    vgc.visual = disp__glXChooseVisual( display,
+						  DefaultScreen( display ),
+						  visualAttribList );
+		    if(verbose)
+		    {
+			if(vgc.visual!=NULL)
+			{
+			    fprintf(stdout, "findVisualGlX.glXChooseVisual: found visual(ID:%d(0x%X))\n", 
+				(int) vgc.visual->visualid,
+				(int) vgc.visual->visualid);
+			        printVisualInfo ( display, vgc.visual );
+			} else {
+			    fprintf(stdout, "findVisualGlX.glXChooseVisual: no visual\n");
+			}
+			fflush(stdout);
+		    }
+	    }
+
+	    if(vgc.visual==NULL)
+	    {
+	        vgc.visual = findVisualIdByFeature( &visualList, 
+				                      display, *pWin,
+						      glCaps,
+						      verbose);
+	    }
+
+	    if( ownwin && vgc.visual!=NULL)
+	    {
+		if(verbose)
+		{
+		    fprintf(stdout, "findVisualGlX: CREATING OWN WINDOW !\n");
+		    fflush(stdout);
+		}
+		newWin = createOwnOverlayWin(display, 
+					     rootWin, 
+					     *pWin /* the parent */,
+			       		     pOwnWinAttr,
+			                     ownWinmask,
+					     vgc.visual, width, height);
+	    }
+
+	    if( offscreen && vgc.visual!=NULL)
+	    {
+	        if(pix!=NULL && *pix!=0)
+		{
+			XFreePixmap(display, *pix);
+		}
+		if(pix!=NULL && vgc.visual !=NULL)
+	    		*pix = XCreatePixmap( display, rootWin, width, height, 
+		                              vgc.visual->depth); 
+		if(pix!=NULL && *pix!=0)
+		{
+	           *pWin = disp__glXCreateGLXPixmap( display,  vgc.visual, *pix );
+		   if(*pWin==0)
+		   {
+		   	XFreePixmap(display, *pix);
+			*pix=0;
+			fprintf(stderr, "GLINFO(%d): glXCreateGLXPixmap failed\n", j);
+			fflush(stderr);
+		   }
+		} else {
+		   fprintf(stderr, "GLINFO(%d): XCreatePixmap failed\n", j);
+		   fflush(stderr);
+		   *pWin = 0;
+		}
+                if(verbose)
+		{
+			if(*pWin!=0)
+			{
+			   fprintf(stderr, "GLINFO(%d): pixmap ok\n", j);
+			   fflush(stderr);
+			}
+		}
+	    }
+
+	    gc_ret = -100;
+
+	    if( ownwin && newWin!=0 && 
+	        gc_ret==-100 /* just a poss. test stage */ &&
+	        (gc_ret=get_GC( display, newWin,
+			        vgc.visual, &(vgc.gc), shareWith, verbose)) == 0
+              )
+	    {
+		    vgc.success=1;
+		    *pWin = newWin ;
+	    }
+	    else if( vgc.visual!=NULL &&  !ownwin && *pWin!=0 &&
+	             (gc_ret=get_GC( display, *pWin,
+			             vgc.visual, &(vgc.gc), shareWith, verbose)) == 0
+	           )    
+	    {
+		    vgc.success=1;
+            } else 
+	    {
+	    	    j++; /* trial counter */
+		    if(verbose)
+		    {
+		        fprintf(stderr, "GLINFO(%d): Visual fetching failed (gc_get=%d)\n", j, gc_ret);
+			fflush(stderr);
+		    }
+
+		    if(pix!=NULL && *pix!=0)
+		    {
+		   	XFreePixmap(display, *pix);
+			*pix=0;
+		    }
+
+		    if(ownwin && newWin!=0)
+		    {
+		        if(verbose)
+		        {
+		          fprintf(stdout, "findVisualGlX: FREE OWN WINDOW !\n");
+		          fflush(stdout);
+		        }
+		        destroyOwnOverlayWin(display, &newWin,
+			                     pOwnWinAttr);
+		    }
+
+		    if(visualList!=NULL)
+		    {
+			XFree(visualList);
+			visualList=NULL;
+	    		vgc.visual=NULL;
+		    } else if(vgc.visual!=NULL)
+		    {
+			XFree(vgc.visual);
+	    		vgc.visual=NULL;
+		    }
+
+                    glCaps->nativeVisualID=-1;
+
+		    /**
+		     * Falling-Back the exact (min. requirement) parameters ..
+		     */
+		    if(!ownwin && !offscreen) {
+		        *glCaps=_glCaps;
+			ownwin=1;
+			if(pOwnWin) *pOwnWin=ownwin;
+		    } else if(glCaps->stereo==STEREO_ON) {
+			glCaps->stereo=STEREO_OFF;
+		    } else if(glCaps->stencilBits>32) {
+		        glCaps->stencilBits=32;
+		    } else if(glCaps->stencilBits>16) {
+		        glCaps->stencilBits=16;
+		    } else if(glCaps->stencilBits>8) {
+		        glCaps->stencilBits=8;
+		    } else if(glCaps->stencilBits>0) {
+		        glCaps->stencilBits=0;
+		    } else if( glCaps->alphaBits>0 ||
+		               glCaps->accumAlphaBits>0
+			     )
+	            {
+			glCaps->alphaBits=0;
+			glCaps->accumAlphaBits=0;
+		    } else if( accumTestDone==0 &&
+		               ( glCaps->accumRedBits==0 ||
+		                 glCaps->accumGreenBits==0 ||
+		                 glCaps->accumBlueBits==0
+			       )
+			     ) 
+	            {
+		        glCaps->accumRedBits=1;
+			glCaps->accumGreenBits=1;
+			glCaps->accumBlueBits=1;
+		    } else if( glCaps->accumRedBits>0 ||
+		               glCaps->accumGreenBits>0 ||
+		               glCaps->accumBlueBits>0
+			     ) 
+	            {
+		        glCaps->accumRedBits=0;
+			glCaps->accumGreenBits=0;
+			glCaps->accumBlueBits=0;
+			accumTestDone=1;
+		    } else if(glCaps->buffer==BUFFER_SINGLE && 
+		              offscreen) 
+		    {
+		        glCaps->buffer=BUFFER_DOUBLE;
+		    } else if(glCaps->buffer==BUFFER_DOUBLE) {
+		        glCaps->buffer=BUFFER_SINGLE;
+		    } else if(tryChooseVisual) {
+		        *glCaps=_glCaps;
+			tryChooseVisual=0;
+			accumTestDone=0;
+		    } else done=1;
+	    }
+    } while (vgc.success==0 && done==0) ;
+
+    if(vgc.success==1 && verbose)
+    {
+	    (void) setGLCapabilities (display, vgc.visual, glCaps);
+
+	    fprintf(stderr, "\nfindVisualGlX results vi(ID:%d): \n screen %d, depth %d, class %d,\n clrmapsz %d, bitsPerRGB %d, shared with %d\n",
+		(int)vgc.visual->visualid,
+		(int)vgc.visual->screen,
+		(int)vgc.visual->depth,
+		(int)vgc.visual->class,
+		(int)vgc.visual->colormap_size,
+		(int)vgc.visual->bits_per_rgb,
+		(int)shareWith);
+    }
+
+    return vgc;
+}
+
+
+XVisualInfo * LIBAPIENTRY findVisualIdByID( XVisualInfo ** visualList, 
+			        int visualID, Display *disp,
+			        Window win, int verbose)
+{
+    XVisualInfo    *    vi=0;
+    XVisualInfo    	viTemplate;
+    int 		i, numReturns;
+    XWindowAttributes 	xwa;
+    int 		done=0;
+
+    if(XGetWindowAttributes(disp, win, &xwa) == 0)
+    {
+	fprintf(stderr, "\nERROR while fetching XWindowAttributes\n");
+	fflush(stderr);
+	return 0;
+    }
+
+    viTemplate.screen = DefaultScreen( disp );
+    viTemplate.class = (xwa.visual)->class ;
+    viTemplate.depth = xwa.depth;
+
+    *visualList = XGetVisualInfo( disp, VisualScreenMask,
+	                          &viTemplate, &numReturns ); 
+
+    for(i=0; done==0 && i<numReturns; i++)
+    {
+        vi = &((*visualList)[i]);
+
+	if(vi->visualid==visualID)
+	{
+                if(verbose)
+		{
+		    fprintf(stderr, "findVisualIdByID: Found matching Visual:\n");
+		    printVisualInfo ( disp, vi);
+		}
+		return vi;
+	}
+    }
+
+    if(verbose)
+    {
+	    if( numReturns==0 )
+		fprintf(stderr, "findVisualIdByID: No available visuals. Exiting...\n" );
+	    else if( i>=numReturns )
+		fprintf(stderr, "findVisualIdByID: No matching visualID found ...\n" );
+	    fflush(stderr);
+    }
+     
+    XFree(*visualList);
+    *visualList=NULL;
+    return NULL;
+}
+
+XVisualInfo * LIBAPIENTRY findVisualIdByFeature( XVisualInfo ** visualList, 
+                                     Display *disp, Window win,
+				     GLCapabilities *glCaps,
+				     int verbose)
+{
+    XVisualInfo    *    vi=0;
+    XVisualInfo    	viTemplate;
+    int 		i, numReturns;
+    XWindowAttributes 	xwa;
+    int 		done=0;
+
+    if(XGetWindowAttributes(disp, win, &xwa) == 0)
+    {
+	fprintf(stderr, "\nERROR while fetching XWindowAttributes\n");
+	fflush(stderr);
+	return 0;
+    }
+
+    viTemplate.screen = DefaultScreen( disp );
+    viTemplate.class = (xwa.visual)->class ;
+    viTemplate.depth = xwa.depth;
+
+    *visualList = XGetVisualInfo( disp, VisualScreenMask,
+	                          &viTemplate, &numReturns ); 
+
+    for(i=0; done==0 && i<numReturns; i++)
+    {
+        vi = &((*visualList)[i]);
+	if ( testVisualInfo ( disp, vi, glCaps, verbose ) )
+	{
+                if(verbose)
+		{
+		    fprintf(stderr, "findVisualIdByFeature: Found matching Visual:\n");
+		    printVisualInfo ( disp, vi);
+		}
+		return vi;
+	}
+    }
+
+    if(verbose)
+    {
+	    if( numReturns==0 )
+		fprintf(stderr, "findVisualIdByFeature: No available visuals. Exiting...\n" );
+	    else if( i>=numReturns )
+		fprintf(stderr, "findVisualIdByFeature: No matching visual found ...\n" );
+	    fflush(stderr);
+    }
+     
+    XFree(*visualList);
+    *visualList=NULL;
+    return NULL;
+}
+
+int LIBAPIENTRY setGLCapabilities ( Display * disp, 
+                        XVisualInfo * visual, GLCapabilities *glCaps)
+{
+    int iValue=0;
+    int iValue1=0;
+    int iValue2=0;
+    int iValue3=0;
+
+    memset(glCaps, 0, sizeof(GLCapabilities));
+
+    if(disp__glXGetConfig( disp, visual, GLX_USE_GL, &iValue)==0)
+    {
+	glCaps->gl_supported=(iValue==True)?1:0;
+    } else {
+	fprintf(stderr,"GLINFO: fetching GLX_USE_GL state failed\n");
+	fflush(stderr);
+    }
+
+    if( ! glCaps->gl_supported )
+    	return 0;
+
+    if(disp__glXGetConfig( disp, visual, GLX_DOUBLEBUFFER, &iValue)==0)
+    {
+	glCaps->buffer=iValue?BUFFER_DOUBLE:BUFFER_SINGLE;
+    } else {
+	fprintf(stderr,"GLINFO: fetching doubleBuffer state failed\n");
+	fflush(stderr);
+    }
+
+    if(disp__glXGetConfig( disp, visual, GLX_RGBA, &iValue)==0)
+    {
+	glCaps->color=iValue?COLOR_RGBA:COLOR_INDEX;
+    } else {
+	fprintf(stderr,"GLINFO: fetching rgba state failed\n");
+	fflush(stderr);
+    }
+
+    if(disp__glXGetConfig( disp, visual, GLX_STEREO, &iValue)==0)
+    {
+	glCaps->stereo=iValue?STEREO_ON:STEREO_OFF;
+    } else {
+	fprintf(stderr,"GLINFO: fetching stereoView state failed\n");
+	fflush(stderr);
+    }
+
+    if(disp__glXGetConfig( disp, visual, GLX_DEPTH_SIZE, &iValue)==0)
+    {
+        glCaps->depthBits = iValue;
+    } else {
+	fprintf(stderr,"GLINFO: fetching depthBits state failed\n");
+	fflush(stderr);
+    }
+
+    if(disp__glXGetConfig( disp, visual, GLX_STENCIL_SIZE, &iValue)==0)
+    {
+        glCaps->stencilBits = iValue;
+    } else {
+	fprintf(stderr,"GLINFO: fetching stencilBits state failed\n");
+	fflush(stderr);
+    }
+
+    if(disp__glXGetConfig(disp,visual,GLX_RED_SIZE, &iValue)==0 &&
+       disp__glXGetConfig(disp,visual,GLX_GREEN_SIZE, &iValue1)==0 &&
+       disp__glXGetConfig(disp,visual,GLX_BLUE_SIZE, &iValue2)==0 &&
+       disp__glXGetConfig(disp,visual,GLX_ALPHA_SIZE, &iValue3)==0 )
+    {
+        glCaps->redBits = iValue;
+        glCaps->greenBits= iValue1;
+        glCaps->blueBits= iValue2;
+        glCaps->alphaBits= iValue3;
+    } else {
+	fprintf(stderr,"GLINFO: fetching rgba Size states failed\n");
+	fflush(stderr);
+    }
+
+    if(disp__glXGetConfig(disp,visual,GLX_ACCUM_RED_SIZE, &iValue)==0 &&
+       disp__glXGetConfig(disp,visual,GLX_ACCUM_GREEN_SIZE, &iValue1)==0 &&
+       disp__glXGetConfig(disp,visual,GLX_ACCUM_BLUE_SIZE, &iValue2)==0 &&
+       disp__glXGetConfig(disp,visual,GLX_ACCUM_ALPHA_SIZE, &iValue3)==0 )
+    {
+        glCaps->accumRedBits = iValue;
+        glCaps->accumGreenBits= iValue1;
+        glCaps->accumBlueBits= iValue2;
+        glCaps->accumAlphaBits= iValue3;
+    } else {
+	fprintf(stderr,"GLINFO: fetching rgba AccumSize states failed\n");
+	fflush(stderr);
+    }
+    glCaps->nativeVisualID=(long) (visual->visualid);
+
+    return 1;
+}
+
+int LIBAPIENTRY testVisualInfo ( Display *display, XVisualInfo * vi, 
+		     GLCapabilities *glCaps, int verbose)
+{
+    GLCapabilities _glCaps;
+    setGLCapabilities ( display, vi, &_glCaps);
+
+    /*
+    if(verbose)
+    {
+            fprintf(stderr, "testVisualInfo vi(ID:%d(0x%X)):\n",
+	            (int) vi->visualid, (int) vi->visualid);
+	    printGLCapabilities ( &_glCaps );
+    }
+    */
+
+    if(_glCaps.gl_supported != glCaps->gl_supported) return 0;
+
+    if(_glCaps.buffer!=glCaps->buffer) return 0;
+
+    if(_glCaps.color!=glCaps->color) return 0;
+
+    if(_glCaps.stereo!=glCaps->stereo) return 0;
+
+    if( ( glCaps->stencilBits>0 && 
+          _glCaps.stencilBits<glCaps->stencilBits
+	) ||
+        (
+	  glCaps->stencilBits==0 &&
+	  _glCaps.stencilBits!=glCaps->stencilBits
+	)
+      )
+    	return 0;
+
+    if( ( glCaps->accumRedBits>0 && 
+          _glCaps.accumRedBits<glCaps->accumRedBits
+	) ||
+        (
+	  glCaps->accumRedBits==0 &&
+          _glCaps.accumRedBits!=glCaps->accumRedBits
+	)
+      )
+    	return 0;
+
+    if( ( glCaps->accumGreenBits>0 && 
+          _glCaps.accumGreenBits<glCaps->accumGreenBits
+	) ||
+        (
+	  glCaps->accumGreenBits==0 &&
+          _glCaps.accumGreenBits!=glCaps->accumGreenBits
+	)
+      )
+    	return 0;
+
+    if( ( glCaps->accumBlueBits>0 && 
+          _glCaps.accumBlueBits<glCaps->accumBlueBits
+	) ||
+        (
+	  glCaps->accumBlueBits==0 &&
+          _glCaps.accumBlueBits!=glCaps->accumBlueBits
+	)
+      )
+    	return 0;
+
+    if( ( glCaps->alphaBits>0 && 
+	  _glCaps.alphaBits<glCaps->alphaBits
+	) ||
+        (
+	  glCaps->alphaBits==0 &&
+	  _glCaps.alphaBits!=glCaps->alphaBits
+	)
+      )
+	return 0;
+
+    if( glCaps->alphaBits>0 )
+    {
+	    if( ( glCaps->accumAlphaBits>0 && 
+		  _glCaps.accumAlphaBits<glCaps->accumAlphaBits
+		) ||
+                (
+	          glCaps->accumAlphaBits==0 &&
+		  _glCaps.accumAlphaBits!=glCaps->accumAlphaBits
+	        )
+	      )
+		return 0;
+    }
+
+    return 1;
+}
+
+
+void LIBAPIENTRY printVisualInfo ( Display *display, XVisualInfo * vi)
+{
+    GLCapabilities glCaps;
+
+    setGLCapabilities ( display, vi, &glCaps);
+
+    fprintf(stdout, "\nvi(ID:%d(0x%X)): \n screen %d, depth %d, class %d,\n clrmapsz %d, bitsPerRGB %d\n",
+	(int) vi->visualid,
+	(int) vi->visualid,
+	(int) vi->screen,
+	(int) vi->depth,
+	(int) vi->class,
+	(int) vi->colormap_size,
+	(int) vi->bits_per_rgb );
+
+    printGLCapabilities ( &glCaps );
+}
+
+void LIBAPIENTRY printAllVisualInfo ( Display *disp, Window win, int verbose)
+{
+    XVisualInfo    *	visualInfo=0;    
+    XVisualInfo    *    vi=0;
+    XVisualInfo    	viTemplate;
+    int 		i, numReturns;
+    XWindowAttributes 	xwa;
+
+    if(XGetWindowAttributes(disp, win, &xwa) == 0)
+    {
+	fprintf(stderr, "\nERROR while fetching XWindowAttributes\n");
+	fflush(stderr);
+	return;
+    }
+
+    viTemplate.screen = DefaultScreen( disp );
+    viTemplate.class = (xwa.visual)->class ;
+    viTemplate.depth = xwa.depth;
+
+    visualInfo = XGetVisualInfo( disp, VisualScreenMask,
+	&viTemplate, &numReturns ); 
+
+    if(verbose)
+    {
+	    fprintf(stderr, "\nNum of Visuals : %d\n", numReturns );
+
+	    for(i=0; i<numReturns; i++)
+	    {
+	    	    vi = &(visualInfo[i]);
+		    printVisualInfo ( disp, vi);
+	    }
+    }
+
+    XFree(visualInfo); 	
+}
+
+Window LIBAPIENTRY createOwnOverlayWin
+			(Display *display, Window rootwini, Window parentWin,
+			   XSetWindowAttributes * pOwnWinAttr,
+			   unsigned long ownWinmask,
+                           XVisualInfo *visual, int width, int height)
+{				  
+  /*
+  //------------------------------------------------------------------------//
+  // Some Systems (SGI) wont give up the window and so we have to create a  //
+  // window that fits on top of the Java Canvas.                            //
+  //------------------------------------------------------------------------//
+  */
+  Window window=0;
+  XSetWindowAttributes   attribs ;
+  unsigned long winmask = 0;
+
+  memset(&attribs, 0, sizeof(XSetWindowAttributes));
+
+  if(pOwnWinAttr) attribs=*pOwnWinAttr;
+  if(ownWinmask!=0) winmask=ownWinmask;
+
+  if(winmask==0)
+  {
+  	winmask= CWBitGravity  | CWColormap | CWBorderPixel | CWBackPixel ;
+  }
+
+  /*
+    //----------------------------------------------------------------------//
+    // now we have the visual with the best depth so lets make a color map  //
+    // for it.  we use allocnone because this is a true colour visual and   //
+    // the color map is read only anyway. This must be done because we      //
+    // cannot call XCreateSimpleWindow.                                     // 
+    //----------------------------------------------------------------------//
+  */
+  if(attribs.colormap==0 && (winmask & CWColormap)>0 )
+    attribs.colormap = XCreateColormap ( display
+                               , rootwini
+                               , visual->visual
+                               , AllocNone 
+                               );
+
+  /*
+    //----------------------------------------------------------------------//
+    // Set up the window attributes.                                        //
+    //----------------------------------------------------------------------//
+  */
+  if(pOwnWinAttr==NULL)
+  {
+    attribs.event_mask       = ExposureMask                              ;
+    attribs.border_pixel     = BlackPixel(display, DefaultScreen(display)) ;
+    attribs.bit_gravity      = SouthWestGravity ;                          ;
+    attribs.background_pixel = 0xFF00FFFF                                  ;  
+  }
+   
+  /*
+    //----------------------------------------------------------------------//
+    // Create a window.                                                     //
+    //----------------------------------------------------------------------//
+  */
+    window = XCreateWindow( display
+                          , parentWin  
+                          , 0
+                          , 0
+                          , width
+                          , height
+                          , 0
+                          , visual->depth
+                          , InputOutput
+                          , visual->visual
+			  , winmask
+                          , &attribs);
+    
+    if(pOwnWinAttr) *pOwnWinAttr=attribs;
+
+    return window;
+}
+
+void LIBAPIENTRY destroyOwnOverlayWin(Display *display, Window *newWin,
+			   XSetWindowAttributes * pOwnWinAttr)
+{				  
+  if(newWin!=NULL)
+  {
+  	XDestroyWindow( display, *newWin );
+	*newWin=0;
+  }
+
+  if(pOwnWinAttr!=NULL && pOwnWinAttr->colormap!=0)
+  {
+    XFreeColormap(display, pOwnWinAttr->colormap);
+    pOwnWinAttr->colormap=0;
+  }
+}
+
+int LIBAPIENTRY x11gl_myErrorHandler(Display *pDisp, XErrorEvent *p_error)
+{
+	char err_msg[80];
+
+	XGetErrorText(pDisp, p_error->error_code, err_msg, 80);
+	fprintf(stderr, "X11 Error detected.\n %s\n", err_msg);
+	fprintf(stderr, " Protocol request: %d\n", p_error->request_code);
+	fprintf(stderr, " Resource ID : 0x%x\n", (int)p_error->resourceid);
+	fprintf(stderr, " \ntrying to continue ... \n");
+	fflush(stderr);
+	return 0;
+}
+
+int LIBAPIENTRY x11gl_myIOErrorHandler(Display *pDisp)
+{
+	fprintf(stderr, "X11 I/O Error detected.\n");
+	fprintf(stderr, " \ndo not know what to do ... \n");
+	fflush(stderr);
+	return 0;
+}
+
diff --git a/src/unix/video-drivers/glxtool.h b/src/unix/video-drivers/glxtool.h
new file mode 100644
index 0000000..a3fdf32
--- /dev/null
+++ b/src/unix/video-drivers/glxtool.h
@@ -0,0 +1,113 @@
+#ifndef _GLXTOOL_H
+	/**
+	 * glxtool.h
+	 *
+	 * Copyright (C) 2001  Sven Goethel
+	 *
+	 * GNU Library General Public License 
+	 * as published by the Free Software Foundation
+	 *
+	 * http://www.gnu.org/copyleft/lgpl.html
+	 * General dynamical loading OpenGL (GL/GLU) support for:
+	 */
+
+	#define _GLXTOOL_H
+
+    #include <X11/Xlib.h>
+  	#include <X11/Xutil.h>
+  	#include <X11/Xatom.h>
+
+	#ifndef SYMBOL_PREFIX
+		#ifndef __ELF__
+			#ifdef  __sgi
+				#define SYMBOL_PREFIX   ""
+			#else
+				#define SYMBOL_PREFIX   "_"
+			#endif
+		#else
+			#define SYMBOL_PREFIX	""
+		#endif
+	#endif
+  
+	#include "gltool.h"
+	  
+	#include "glx-disp-var.h"
+
+	typedef struct {
+		XVisualInfo * visual;
+		GLXContext    gc;
+		int           success;  /* 1: OK, 0: ERROR */
+	} VisualGC;
+  
+	LIBAPI int LIBAPIENTRY get_GC
+		( Display *display, Window win, XVisualInfo *visual,
+		    GLXContext *gc, GLXContext gc_share,
+		    int verbose );
+
+        LIBAPI int LIBAPIENTRY setVisualAttribListByGLCapabilities( 
+					int visualAttribList[/*>=32*/],
+				        GLCapabilities *glCaps );
+
+	LIBAPI VisualGC LIBAPIENTRY findVisualGlX( Display *display, 
+				       Window rootWin,
+				       Window * pWin, 
+				       int width, int height,
+				       GLCapabilities * glCaps,
+				       int * pOwnWin,
+			               XSetWindowAttributes * pOwnWinAttr,
+				       unsigned long ownWinmask,
+				       GLXContext shareWith,
+				       int offscreen,
+				       Pixmap *pix,
+				       int verbose
+				     );
+
+	LIBAPI XVisualInfo * LIBAPIENTRY findVisualIdByID
+				( XVisualInfo ** visualList, 
+					int visualID, Display *disp,
+					Window win, int verbose);
+
+	LIBAPI XVisualInfo * LIBAPIENTRY findVisualIdByFeature
+					( XVisualInfo ** visualList, 
+					     Display *disp, Window win,
+					     GLCapabilities *glCaps,
+					     int verbose);
+
+	LIBAPI int LIBAPIENTRY testVisualInfo 
+			( Display *display, XVisualInfo * vi, 
+			     GLCapabilities *glCaps, int verbose);
+
+	LIBAPI int LIBAPIENTRY setGLCapabilities 
+				( Display * disp, 
+				XVisualInfo * visual, GLCapabilities *glCaps);
+
+	LIBAPI void LIBAPIENTRY printAllVisualInfo 
+				( Display *disp, Window win, int verbose);
+	LIBAPI void LIBAPIENTRY printVisualInfo 
+				( Display *display, XVisualInfo * vi);
+
+	LIBAPI Window LIBAPIENTRY createOwnOverlayWin
+			          (Display *display, 
+				   Window rootwini, Window parentWin,
+			           XSetWindowAttributes * pOwnWinAttr,
+				   unsigned long ownWinmask,
+				   XVisualInfo *visual, int width, int height);
+
+	LIBAPI void LIBAPIENTRY destroyOwnOverlayWin
+				 (Display *display, Window *newWin,
+				  XSetWindowAttributes * pOwnWinAttr);
+
+	/**
+	 * do not call this one directly,
+	 * use fetch_GL_FUNCS (gltool.h) instead
+	 */
+	LIBAPI void LIBAPIENTRY fetch_GLX_FUNCS 
+				(const char * libGLName, 
+					 const char * libGLUName, int force);
+
+	LIBAPI int LIBAPIENTRY x11gl_myErrorHandler(
+				  Display *pDisp, XErrorEvent *p_error);
+
+	LIBAPI int LIBAPIENTRY x11gl_myIOErrorHandler(Display *pDisp);
+
+#endif
diff --git a/src/unix/video-drivers/openstep.m b/src/unix/video-drivers/openstep.m
new file mode 100644
index 0000000..b438918
--- /dev/null
+++ b/src/unix/video-drivers/openstep.m
@@ -0,0 +1,431 @@
+/*
+ * OpenStep specific file for XMAME. Here we define OpenStep specific
+ * versions of all the MAME functions necessary to get it running under
+ * OpenStep. The lastest version of this code now draws in a more conventional
+ * manner to try and aid portability between this and Mac OS X. Thus all the
+ * DisplayPostScript has been removed and the drawing embedded within a
+ * custom NSView.
+ *
+ * -bat. 12/11/2000
+ */
+
+#import <stdio.h> 
+#import <stdlib.h>
+#import <unistd.h> 
+#import <AppKit/AppKit.h>
+
+#import "xmame.h"
+#import "osdepend.h"
+#import "driver.h"
+#import "keyboard.h"
+#import "devices.h"
+#import "effect.h"
+
+/*
+ * There are two flavours of OpenStep - the original Display PostScript
+ * based one and the new Mac OS X version. Sadly there is no good way of
+ * distinguishing the two, thus we make a few intelligent guesses here.
+ * If we have 'Apple' we are probably an OSX machine, and if we have 'BSD43'
+ * then we are probably an old NeXT system. GNUstep is neither (and has not
+ * been tried with this driver) so the default is old style.
+ */
+
+#ifdef __APPLE__
+#define COCOA 1
+#endif
+
+#ifdef BSD43
+#undef COCOA
+#endif
+
+/* display options */
+
+struct rc_option display_opts[] = {
+	{
+	"OpenStep related", NULL, rc_seperator, NULL, NULL, 0, 0, NULL, NULL
+	}, {
+	NULL, NULL, rc_end, NULL, NULL, 0, 0, NULL, NULL
+	}
+};
+
+/*
+ * Size of the black border
+ */
+
+#define BORDER 12
+
+/*
+ * Variables used by command-line window.
+ */
+
+NSWindow *theWindow = nil;		/* needed by keyboard code */
+static NSBitmapImageRep *thisBitmap = nil;
+static int bitmap_width, bitmap_height;
+static double gameAspect;
+
+static NSDate *thePast = nil;		/* avoid memory leak on pause */
+
+int isMinaturised = 0;			/* used to disable sound */
+
+/*
+ * Screen bitmap variable
+ */
+
+static unsigned short *screen12bit = NULL;
+
+/*
+ * Autorelease pool variables. We have an outer pool which is never freed
+ * due to lessons learnt from EOF about always having at least *one* pool
+ * active ! We also have a pool that exists across display open and closes
+ * to make sure that everthing we make in a display open vanishes properly.
+ */
+
+static NSAutoreleasePool *outer_pool = nil;
+static NSAutoreleasePool *display_pool = nil;
+
+/*
+ * Intialise the two pools. Create the application object.
+ */
+
+int
+sysdep_init(void)
+{
+	outer_pool = [NSAutoreleasePool new];
+	NSApp = [[NSApplication sharedApplication] retain];
+	thePast = [NSDate distantPast];
+	return OSD_OK;
+}
+
+/*
+ * Free up the autorelease pools before exitting.
+ */
+
+void
+sysdep_close(void)
+{
+	[NSApp release];
+	[outer_pool release];
+}
+
+/*
+ * Shut down the display. We close the dps window and exit.
+ */
+
+void
+sysdep_display_close(void)
+{
+	[theWindow close];
+	theWindow = nil;
+	[display_pool release];
+}
+
+extern void openstep_keyboard_init(void);
+
+/*
+ * This is the custom view we use to do all the drawing into the window, and
+ * also to handle the resizing methods to enable us to maintain the windows
+ * aspect ratio to allow resizing. The view is opaque and draws eveything
+ * on top of a black background which extends just beyound the frame being
+ * displayed to provide a black border for games such as PacMan.
+ */
+
+@interface MameView : NSView
+
+- (void)drawRect:(NSRect)aRect;
+- (BOOL)isOpaque;
+- (NSSize)windowWillResize:(NSWindow*)sender toSize:(NSSize)proposedFrameSize;
+
+@end
+
+@implementation MameView : NSView
+
+/*
+ * Maintain the aspect ratio of the game area when resizing.
+ */
+
+- (NSSize)windowWillResize:(NSWindow*)sender toSize:(NSSize)proposedFrameSize
+{
+	NSSize originalFrameSize = [sender frame].size;
+	NSSize originalViewSize = [self frame].size;
+	float extraWidth = originalFrameSize.width - originalViewSize.width;
+	float extraHeight = originalFrameSize.height - originalViewSize.height;
+
+	/* remove extras to make new view size */
+	proposedFrameSize.width -= (extraWidth + (BORDER*2));
+	proposedFrameSize.height -= (extraHeight + (BORDER*2));
+
+	/* make new view have correct aspect ratio */
+	if((proposedFrameSize.width / proposedFrameSize.height) < gameAspect)
+		proposedFrameSize.width =
+				proposedFrameSize.height * gameAspect;
+	else
+		proposedFrameSize.height =
+				proposedFrameSize.width / gameAspect;
+
+	/* add extras and return */
+	proposedFrameSize.width += (extraWidth + (BORDER*2));
+	proposedFrameSize.height += (extraHeight + (BORDER*2));
+	return proposedFrameSize;
+}
+
+/*
+ * Get the view bounds, draw the borders and then the bitmap into the
+ * centre of it. We probably do not need to redraw the borders each time,
+ * but we get strange effects onm OS X if we do not.
+ */
+
+-(void)drawRect:(NSRect)aRect
+{
+	NSRect blackRect, theRect = [self bounds];
+
+	/* draw the borders */
+	[[NSColor blackColor] set];
+	blackRect = theRect;
+	blackRect.size.width = BORDER;
+	NSRectFill(blackRect);
+	blackRect.origin.x = theRect.size.width - BORDER;
+	NSRectFill(blackRect);
+	blackRect = theRect;
+	blackRect.size.height = BORDER;
+	NSRectFill(blackRect);
+	blackRect.origin.y = theRect.size.height - BORDER;
+	NSRectFill(blackRect);
+
+	/* draw the bitmap */
+	theRect.size.width -= (BORDER*2);
+	theRect.size.height -= (BORDER*2);
+	theRect.origin.x += BORDER;
+	theRect.origin.y += BORDER;
+
+	[thisBitmap drawInRect:theRect];
+}
+
+/*
+ * This view is always opaque
+ */
+
+- (BOOL)isOpaque
+{
+	return YES;
+}
+
+@end
+
+/*
+ * Create the display. We create a window of the appropriate size, then
+ * make it display on the screen. Keyboard initialisation is also called
+ * from this function. The view contains a custom content view with it's
+ * own graphics state (for speed) that does the actual drawing of the bitmap.
+ */
+
+int
+sysdep_create_display(int depth)
+{
+	MameView *theView = nil;
+	NSRect content_rect = { {100,100}, {0,0} };
+
+	/* make the display pool */
+	display_pool = [NSAutoreleasePool new];
+
+	bitmap_width = visual_width * widthscale;
+	bitmap_height = visual_height * heightscale;
+
+	/* set the size of the view */
+	gameAspect = (double)bitmap_width / (double)bitmap_height;
+	content_rect.size.width = bitmap_width + (BORDER*2);
+	content_rect.size.height = bitmap_height + (BORDER*2);
+
+	/* allocate memory for 12 bit colour version */
+	screen12bit = [[NSMutableData dataWithLength:
+			(2*bitmap_width*bitmap_height)] mutableBytes];
+	if(!screen12bit) {
+		fprintf(stderr,"12 bit memory allocate failed\n");
+		[display_pool release];
+		display_pool = nil;
+		return OSD_NOT_OK;
+	}
+
+	/* create bitmap object  */
+	thisBitmap = [[NSBitmapImageRep alloc]
+		initWithBitmapDataPlanes:(void*)&screen12bit
+		pixelsWide:bitmap_width pixelsHigh:bitmap_height
+		bitsPerSample:4 samplesPerPixel:3
+		hasAlpha:NO isPlanar:NO
+		colorSpaceName:NSDeviceRGBColorSpace
+		bytesPerRow:2*bitmap_width bitsPerPixel:16];
+	if(!thisBitmap) {
+		fprintf(stderr,"Bitmap creation failed\n");
+		[display_pool release];
+		display_pool = nil;
+		return OSD_NOT_OK;
+	}
+	[thisBitmap autorelease];
+
+	/* create a window - retained is broken on public beta */
+	theWindow = [[NSWindow alloc] initWithContentRect:content_rect
+			styleMask:(NSTitledWindowMask |
+			NSMiniaturizableWindowMask |
+			NSResizableWindowMask)
+#ifdef COCOA
+			backing:NSBackingStoreBuffered
+#else
+			backing:NSBackingStoreRetained
+#endif
+			defer:NO];
+	[theWindow setTitle:[NSString
+		stringWithCString:Machine->gamedrv->description]];
+	[theWindow setReleasedWhenClosed:YES];
+
+	/* create the custom content view */
+	theView = [[MameView alloc] initWithFrame:
+			[[theWindow contentView] frame]];
+	[theView allocateGState];
+	[theWindow setContentView:theView];
+	[theWindow setMinSize:[theWindow frame].size];
+	[theWindow setDelegate:theView];
+
+	/* send it front and display the game name */
+	[theWindow makeKeyAndOrderFront:nil];
+	puts(Machine->gamedrv->description);
+
+	/* set up the structure for the palette code */
+	display_palette_info.writable_colors = 0;
+	display_palette_info.depth = 16;
+
+#ifdef LSB_FIRST
+	display_palette_info.red_mask = 0x00f0;
+	display_palette_info.green_mask = 0x000f;
+	display_palette_info.blue_mask = 0xf000;
+#else
+	/* untested due to lack of big-endian machines at present */
+	display_palette_info.red_mask = 0xf000;
+	display_palette_info.green_mask = 0x0f00;
+	display_palette_info.blue_mask = 0x00f0;
+#endif
+
+	/* shifts will be calculated from above settings */
+	display_palette_info.red_shift = 0;
+	display_palette_info.green_shift = 0;
+	display_palette_info.blue_shift = 0;
+
+	/* initialise the keyboard and return */
+	openstep_keyboard_init();
+	return OSD_OK;
+}
+
+/*
+ * 8 bit display update. We use dirty unless the palette has been
+ * changed, in which case the whole screen is updated.
+ */
+
+static void
+update_display_8bpp(struct mame_bitmap *bitmap)
+{
+#define	SRC_PIXEL	unsigned char
+#define	DEST_PIXEL	unsigned short
+#define	DEST		screen12bit
+#define	DEST_WIDTH	bitmap_width
+#define	INDIRECT	current_palette->lookup
+#include "blit.h"
+#undef	SRC_PIXEL
+#undef	DEST_PIXEL
+#undef	DEST
+#undef	DEST_WIDTH
+#undef	INDIRECT
+}
+
+/*
+ * 16 bit display update
+ */
+
+static void
+update_display_16bpp(struct mame_bitmap *bitmap)
+{
+#define	SRC_PIXEL	unsigned short
+#define	DEST_PIXEL	unsigned short
+#define	DEST		screen12bit
+#define	DEST_WIDTH	bitmap_width
+	if(current_palette->lookup) {
+#define	INDIRECT	current_palette->lookup
+#include "blit.h"
+#undef	INDIRECT
+	} else {
+#include "blit.h"
+	}
+
+#undef	SRC_PIXEL
+#undef	DEST_PIXEL
+#undef	DEST
+#undef	DEST_WIDTH
+}
+
+/*
+ * Update the display.  We create the bitmapped data for the current frame
+ * and draw it into the window. If the window is minaturised however, then
+ * we go into a loop catching events and passing them until such a time as it
+ * is no longer minaturised. This is to avoid a huge drain on CPU time when
+ * not actually playing and effectively acts like a pause.
+ */
+
+void
+sysdep_update_display(struct mame_bitmap *bitmap)
+{
+	/* pause if minturised, setting the flag */
+	while([theWindow isMiniaturized]) {
+		NSEvent *thisEvent;
+		isMinaturised = 1;
+		thisEvent = [NSApp nextEventMatchingMask:NSAnyEventMask
+				untilDate:thePast inMode:NSDefaultRunLoopMode
+				dequeue:YES];
+		if(thisEvent)
+			[NSApp sendEvent:thisEvent];
+		else
+			usleep(50000);
+	}
+	isMinaturised = 0;
+
+	/* call appropriate function with dirty */
+	if(bitmap->depth == 16)
+		update_display_16bpp(bitmap);
+	else
+		update_display_8bpp(bitmap);
+
+	/* make the view as dirty and redisplay the window */
+	[[theWindow contentView] setNeedsDisplay:YES];
+	[theWindow displayIfNeeded];
+
+	/* flushing is done differently on the two variants */
+#ifdef COCOA
+	[[NSGraphicsContext currentContext] flushGraphics];
+#else
+	PSWait();
+#endif
+}
+
+/*
+ * OpenStep system are always 16bpp capable.
+ */
+
+int
+sysdep_display_16bpp_capable(void)
+{
+	return 1;
+}
+
+/*
+ * The following functions are dummies - we always generate 16 bit
+ * colour output on OpenStep systems.
+ */
+
+int
+sysdep_display_alloc_palette(int writable_colours)
+{
+	return OSD_OK;
+}
+
+int
+sysdep_display_set_pen(int pen,
+		unsigned char r, unsigned char g, unsigned char b)
+{
+	return OSD_OK;
+}
diff --git a/src/unix/video-drivers/openstep_input.m b/src/unix/video-drivers/openstep_input.m
new file mode 100644
index 0000000..39daea8
--- /dev/null
+++ b/src/unix/video-drivers/openstep_input.m
@@ -0,0 +1,423 @@
+/*
+ * OpenStep input functions - placed here to separate them out from the
+ * display functions. This code handles keyboard and mouse input using the
+ * OpenStep event queue mechanism. Unknown events are passed onward to allow
+ * minaturisation of the window.
+ *
+ * -bat. 14/3/2000
+ */
+
+#import <stdio.h> 
+#import <stdlib.h>
+#import <unistd.h> 
+#import <AppKit/AppKit.h>
+#import "xmame.h"
+#import "osdepend.h"
+#import "driver.h"
+#import "keyboard.h"
+#import "devices.h"
+
+/*
+ * Keyboard variables
+ */
+
+typedef struct {
+	unsigned char scancode;
+	unsigned short unicode;
+} key_pair;
+static key_pair ibm_keymap[256];	/* map ascii to ibm keycodes */
+static NSDate *the_past = nil;
+
+/*
+ * External window variable
+ */
+
+extern NSWindow *theWindow;
+
+/*
+ * Keyboard init - all I really do here is set up the keymapping array
+ * between ASCII values and MAME keycodes. Yes, it was all done by
+ * hand, though there aren't actually that many of them. We also initialise
+ * the "distant past" variable here as it belongs to the keyboard code.
+ * This array was slightly over complexified by the introduction of unicode
+ * support, but I *think* I have got it right !
+ */
+
+void
+openstep_keyboard_init(void)
+{
+	int i;
+
+	/* create the past */
+	the_past = [NSDate distantPast];
+	[the_past retain];
+
+	/* zero certain arrays */
+	for(i=0;i<256;i++)
+		ibm_keymap[i]=(key_pair){0,0};
+
+	/* and now we set up this big tedious array	*/
+	ibm_keymap['0']=(key_pair){KEY_0,KEYCODE_0};
+	ibm_keymap['1']=(key_pair){KEY_1,KEYCODE_1};
+	ibm_keymap['2']=(key_pair){KEY_2,KEYCODE_2};
+	ibm_keymap['3']=(key_pair){KEY_3,KEYCODE_3};
+	ibm_keymap['4']=(key_pair){KEY_4,KEYCODE_4};
+	ibm_keymap['5']=(key_pair){KEY_5,KEYCODE_5};
+	ibm_keymap['6']=(key_pair){KEY_6,KEYCODE_6};
+	ibm_keymap['7']=(key_pair){KEY_7,KEYCODE_7};
+	ibm_keymap['8']=(key_pair){KEY_8,KEYCODE_8};
+	ibm_keymap['9']=(key_pair){KEY_9,KEYCODE_9};
+
+	ibm_keymap['-']=(key_pair){KEY_MINUS,KEYCODE_MINUS};
+	ibm_keymap['_']=(key_pair){KEY_MINUS,KEYCODE_MINUS};
+	ibm_keymap['+']=(key_pair){KEY_EQUALS,KEYCODE_EQUALS};
+	ibm_keymap['=']=(key_pair){KEY_EQUALS,KEYCODE_EQUALS};
+	ibm_keymap['\t']=(key_pair){KEY_TAB,KEYCODE_TAB};
+
+	ibm_keymap['=']=(key_pair){KEY_EQUALS,KEYCODE_EQUALS};
+	ibm_keymap['\t']=(key_pair){KEY_TAB,KEYCODE_TAB};
+	ibm_keymap['\r']=(key_pair){KEY_ENTER,KEYCODE_ENTER};
+	ibm_keymap['\n']=(key_pair){KEY_ENTER,KEYCODE_ENTER};
+
+	ibm_keymap['q']=(key_pair){KEY_Q,KEYCODE_Q};
+	ibm_keymap['w']=(key_pair){KEY_W,KEYCODE_W};
+	ibm_keymap['e']=(key_pair){KEY_E,KEYCODE_E};
+	ibm_keymap['r']=(key_pair){KEY_R,KEYCODE_R};
+	ibm_keymap['t']=(key_pair){KEY_T,KEYCODE_T};
+	ibm_keymap['y']=(key_pair){KEY_Y,KEYCODE_Y};
+	ibm_keymap['u']=(key_pair){KEY_U,KEYCODE_U};
+	ibm_keymap['i']=(key_pair){KEY_I,KEYCODE_I};
+	ibm_keymap['o']=(key_pair){KEY_O,KEYCODE_O};
+	ibm_keymap['p']=(key_pair){KEY_P,KEYCODE_P};
+	ibm_keymap['[']=(key_pair){KEY_OPENBRACE,KEYCODE_OPENBRACE};
+	ibm_keymap[']']=(key_pair){KEY_CLOSEBRACE,KEYCODE_CLOSEBRACE};
+
+	ibm_keymap['a']=(key_pair){KEY_A,KEYCODE_A};
+	ibm_keymap['s']=(key_pair){KEY_S,KEYCODE_S};
+	ibm_keymap['d']=(key_pair){KEY_D,KEYCODE_D};
+	ibm_keymap['f']=(key_pair){KEY_F,KEYCODE_F};
+	ibm_keymap['g']=(key_pair){KEY_G,KEYCODE_G};
+	ibm_keymap['h']=(key_pair){KEY_H,KEYCODE_H};
+	ibm_keymap['j']=(key_pair){KEY_J,KEYCODE_J};
+	ibm_keymap['k']=(key_pair){KEY_K,KEYCODE_K};
+	ibm_keymap['l']=(key_pair){KEY_L,KEYCODE_L};
+	ibm_keymap[';']=(key_pair){KEY_COLON,KEYCODE_COLON};
+	ibm_keymap[':']=(key_pair){KEY_COLON,KEYCODE_COLON};
+	ibm_keymap['\'']=(key_pair){KEY_QUOTE,KEYCODE_QUOTE};
+	ibm_keymap['@']=(key_pair){KEY_QUOTE,KEYCODE_QUOTE};
+	ibm_keymap['~']=(key_pair){KEY_TILDE,KEYCODE_TILDE};
+	ibm_keymap['#']=(key_pair){KEY_TILDE,KEYCODE_TILDE};
+
+	ibm_keymap['z']=(key_pair){KEY_Z,KEYCODE_Z};
+	ibm_keymap['x']=(key_pair){KEY_X,KEYCODE_X};
+	ibm_keymap['c']=(key_pair){KEY_C,KEYCODE_C};
+	ibm_keymap['v']=(key_pair){KEY_V,KEYCODE_V};
+	ibm_keymap['b']=(key_pair){KEY_B,KEYCODE_B};
+	ibm_keymap['n']=(key_pair){KEY_N,KEYCODE_N};
+	ibm_keymap['m']=(key_pair){KEY_M,KEYCODE_M};
+	ibm_keymap[',']=(key_pair){KEY_COMMA,KEYCODE_COMMA};
+	ibm_keymap['<']=(key_pair){KEY_COMMA,KEYCODE_COMMA};
+	ibm_keymap['.']=(key_pair){KEY_STOP,KEYCODE_STOP};
+	ibm_keymap['>']=(key_pair){KEY_STOP,KEYCODE_STOP};
+	ibm_keymap['/']=(key_pair){KEY_SLASH,KEYCODE_SLASH};
+	ibm_keymap['?']=(key_pair){KEY_SLASH,KEYCODE_SLASH};
+
+	ibm_keymap['*']=(key_pair){KEY_ASTERISK,KEYCODE_ASTERISK};
+	ibm_keymap[' ']=(key_pair){KEY_SPACE,KEYCODE_SPACE};
+
+	ibm_keymap[8]=(key_pair){KEY_BACKSPACE,KEYCODE_BACKSPACE};
+	ibm_keymap[27]=(key_pair){KEY_ESC,KEYCODE_ESC};
+	ibm_keymap[96]=(key_pair){KEY_NUMLOCK,KEYCODE_NUMLOCK};
+	ibm_keymap[127]=(key_pair){KEY_DEL,KEYCODE_DEL};
+}
+
+
+/*
+ * Nothing needs doing to close the keybaord, but we release the variable
+ * used to hold the distant past here as it is a keyboard variable.
+ */
+
+void
+sysdep_keyboard_close(void)
+{
+	[the_past release];
+	the_past = nil;
+}
+
+/*
+ * Get the mouse location and use this to set the deltas relative to
+ * the last time. We only use this to get the position of the mouse, it's
+ * buttons come in as events in the normal way.
+ */
+
+void
+sysdep_mouse_poll(void)
+{
+	static NSPoint last = {0.0, 0.0};
+	NSPoint current;
+
+	current = [theWindow mouseLocationOutsideOfEventStream];
+
+	mouse_data[0].deltas[0] = current.x - last.x;
+	mouse_data[0].deltas[1] = last.y - current.y; /* inverted */
+
+	last = current;
+}
+
+/*
+ * Here we are passed an NSEvent from the keyboard and expected to queue
+ * the MAME key event associated with it. For ASCII characters there
+ * is a simple lookup table, for Unicode characters we use a switch statement
+ * with the constants defined in NSEvent.h. This function also deals with
+ * using the command key to emulate the function keys.
+ */
+
+static inline void
+queue_key_event(NSEvent *keyevent)
+{
+	struct xmame_keyboard_event event;
+	unichar buf[2];	/* just in case theres more than 1 */
+	NSString *string = [keyevent charactersIgnoringModifiers];
+	[string getCharacters:buf range:NSMakeRange(0,1)];
+
+	/* check to see if string is ASCII */
+	if([string canBeConvertedToEncoding:NSASCIIStringEncoding]) {
+		event.scancode = ibm_keymap[buf[0]].scancode;
+		event.unicode = ibm_keymap[buf[0]].unicode;
+	} else {
+		 switch(buf[0]) {
+			 case NSUpArrowFunctionKey:
+				event.scancode = KEY_UP;
+				event.unicode = KEYCODE_UP;
+				break;
+			 case NSDownArrowFunctionKey:
+				event.scancode = KEY_DOWN;
+				event.unicode = KEYCODE_DOWN;
+				break;
+			 case NSLeftArrowFunctionKey:
+				event.scancode = KEY_LEFT;
+				event.unicode = KEYCODE_LEFT;
+				break;
+			 case NSRightArrowFunctionKey:
+				event.scancode = KEY_RIGHT;
+				event.unicode = KEYCODE_RIGHT;
+				break;
+			 case NSF1FunctionKey:
+				event.scancode = KEY_F1;
+				event.unicode = KEYCODE_F1;
+				break;
+			 case NSF2FunctionKey:
+				event.scancode = KEY_F2;
+				event.unicode = KEYCODE_F2;
+				break;
+			 case NSF3FunctionKey:
+				event.scancode = KEY_F3;
+				event.unicode = KEYCODE_F3;
+				break;
+			 case NSF4FunctionKey:
+				event.scancode = KEY_F4;
+				event.unicode = KEYCODE_F4;
+				break;
+			 case NSF5FunctionKey:
+				event.scancode = KEY_F5;
+				event.unicode = KEYCODE_F5;
+				break;
+			 case NSF6FunctionKey:
+				event.scancode = KEY_F6;
+				event.unicode = KEYCODE_F6;
+				break;
+			 case NSF7FunctionKey:
+				event.scancode = KEY_F7;
+				event.unicode = KEYCODE_F7;
+				break;
+			 case NSF8FunctionKey:
+				event.scancode = KEY_F8;
+				event.unicode = KEYCODE_F8;
+				break;
+			 case NSF9FunctionKey:
+				event.scancode = KEY_F9;
+				event.unicode = KEYCODE_F9;
+				break;
+			 case NSF10FunctionKey:
+				event.scancode = KEY_F10;
+				event.unicode = KEYCODE_F10;
+				break;
+			 case NSF11FunctionKey:
+				event.scancode = KEY_F11;
+				event.unicode = KEYCODE_F11;
+				break;
+			 case NSF12FunctionKey:
+				event.scancode = KEY_F12;
+				event.unicode = KEYCODE_F12;
+				break;
+			 case NSInsertFunctionKey:
+				event.scancode = KEY_INSERT;
+				event.unicode = KEYCODE_INSERT;
+				break;
+			 case NSDeleteFunctionKey:
+				event.scancode = KEY_DEL;
+				event.unicode = KEYCODE_DEL;
+				break;
+			 case NSHomeFunctionKey:
+				event.scancode = KEY_HOME;
+				event.unicode = KEYCODE_HOME;
+				break;
+			 case NSEndFunctionKey:
+				event.scancode = KEY_END;
+				event.unicode = KEYCODE_END;
+				break;
+			 case NSPageUpFunctionKey:
+				event.scancode = KEY_PGUP;
+				event.unicode = KEYCODE_PGUP;
+				break;
+			 case NSPageDownFunctionKey:
+				event.scancode = KEY_PGDN;
+				event.unicode = KEYCODE_PGDN;
+				break;
+			 case NSPrintScreenFunctionKey:
+				event.scancode = KEY_PRTSCR;
+				event.unicode = KEYCODE_PRTSCR;
+				break;
+			 case NSScrollLockFunctionKey:
+				event.scancode = KEY_SCRLOCK;
+				event.unicode = KEYCODE_SCRLOCK;
+				break;
+			 case NSPauseFunctionKey:
+				event.scancode = KEY_PAUSE;
+				event.unicode = KEYCODE_PAUSE;
+				break;
+			 default:
+				return;
+		 }
+	}
+
+	/* deal with command key */
+	if([keyevent modifierFlags] & NSCommandKeyMask)
+		switch(event.scancode) {
+			case KEY_1:
+				event.scancode = KEY_F1;
+				event.unicode = KEYCODE_F1;
+				break;
+			case KEY_2:
+				event.scancode = KEY_F2;
+				event.unicode = KEYCODE_F2;
+				break;
+			case KEY_3:
+				event.scancode = KEY_F3;
+				event.unicode = KEYCODE_F3;
+				break;
+			case KEY_4:
+				event.scancode = KEY_F4;
+				event.unicode = KEYCODE_F4;
+				break;
+			case KEY_5:
+				event.scancode = KEY_F5;
+				event.unicode = KEYCODE_F5;
+				break;
+			case KEY_6:
+				event.scancode = KEY_F6;
+				event.unicode = KEYCODE_F6;
+				break;
+			case KEY_7:
+				event.scancode = KEY_F7;
+				event.unicode = KEYCODE_F7;
+				break;
+			case KEY_8:
+				event.scancode = KEY_F8;
+				event.unicode = KEYCODE_F8;
+				break;
+			case KEY_9:
+				event.scancode = KEY_F9;
+				event.unicode = KEYCODE_F9;
+				break;
+			case KEY_0:
+				event.scancode = KEY_F10;
+				event.unicode = KEYCODE_F10;
+				break;
+			case KEY_MINUS:
+				event.scancode = KEY_F11;
+				event.unicode = KEYCODE_F11;
+				break;
+			case KEY_EQUALS:
+				event.scancode = KEY_F12;
+				event.unicode = KEYCODE_F12;
+				break;
+		}
+
+	/* now queue it */
+	switch([keyevent type]) {
+		case NSKeyUp:
+			event.press = FALSE;
+			xmame_keyboard_register_event(&event);
+			break;
+		case NSKeyDown:
+			event.press = TRUE;
+			xmame_keyboard_register_event(&event);
+			break;
+		default:
+			break;
+	}
+}
+
+/*
+ * This loop collect all events from the queue and deals with them by
+ * queueing key up and down events to the xmame fifo. Anything we dont
+ * use gets passed on to whoever might want it. We handle the mouse
+ * button events in this loop too, passing them downwards to allow other
+ * things such as minaturisation to happen. This loop is surrounded by an
+ * autorelease pool as we do create some objects here.
+ */
+
+void
+sysdep_update_keyboard(void)
+{
+	NSAutoreleasePool *pool = [NSAutoreleasePool new];
+	NSEvent *event=nil;
+
+	for(;;) {
+		/* get the next event */
+		event= [NSApp nextEventMatchingMask:NSAnyEventMask
+				untilDate:the_past inMode:NSDefaultRunLoopMode
+				dequeue:YES];
+		/* break out of the loop if there are no more events */
+		if(event==nil)
+			break;
+
+		/* deal with the event */
+		switch([event type]) {
+			case NSKeyUp:
+			case NSKeyDown:
+				queue_key_event(event);
+				break;
+			case NSLeftMouseDown:
+				mouse_data[0].buttons[0] = 1;
+				[NSApp sendEvent:event];
+				break;
+			case NSLeftMouseUp:
+				mouse_data[0].buttons[0] = 0;
+				[NSApp sendEvent:event]; 
+				break;
+			case NSRightMouseDown:
+				mouse_data[0].buttons[1] = 1;
+				[NSApp sendEvent:event];
+				break;
+			case NSRightMouseUp:
+				mouse_data[0].buttons[1] = 0;
+				[NSApp sendEvent:event];
+				break;
+			default:
+				[NSApp sendEvent:event];
+				break;
+		}
+	}
+
+	[pool release];
+}
+
+/*
+ * We do not have access to the keyboard LED's
+ */
+
+void sysdep_set_leds(int leds)
+{
+}
diff --git a/src/unix/video-drivers/phkeyboard.h b/src/unix/video-drivers/phkeyboard.h
new file mode 100644
index 0000000..2c1f312
--- /dev/null
+++ b/src/unix/video-drivers/phkeyboard.h
@@ -0,0 +1,838 @@
+/* MAME Neutrino Keyboard Code
+ *
+ * Writen By: Travis Coady
+ * Origional Code By: David Rempel
+ *
+ * web: http://www.classicgaming.com/phmame/
+ * e-mail: smallfri@bigfoot.com
+ *
+ * Copyright (C) 2000-2001, The PhMAME Developement Team.
+*/
+
+/* TRAVIS'S NOTE: This may be removed at a later date.... */
+
+#include "keyboard.h"
+
+/* translation table from Photon codes to raw keyboard scan codes */
+/* the idea is make a re-definable lookup table, instead a long case switch */
+
+/* following code is taken from keysmdef.h */
+
+/******************************************************************/
+/* $XConsortium: keysymdef.h /main/24 1996/02/02 14:28:10 kaleb $ */
+/******************************************************************/
+
+/* XK_VoidSymbol	0xFFFFFF	*/ /* void symbol */
+
+static int extended_code_table[512] = {
+#if 0
+/*                      		0xFE00  */ KEY_NONE,
+/* XK_ISO_Lock				0xFE01  */ KEY_NONE,
+/* XK_ISO_Level2_Latch			0xFE02  */ KEY_NONE,
+/* XK_ISO_Level3_Shift			0xFE03  */ KEY_NONE,
+/* XK_ISO_Level3_Latch			0xFE04  */ KEY_NONE,
+/* XK_ISO_Level3_Lock			0xFE05  */ KEY_NONE,
+/* XK_ISO_Group_Latch			0xFE06  */ KEY_NONE,
+/* XK_ISO_Group_Lock			0xFE07  */ KEY_NONE,
+/* XK_ISO_Next_Group			0xFE08  */ KEY_BACKSPACE,
+/* XK_ISO_Next_Group_Lock		0xFE09  */ KEY_TAB,
+/* XK_ISO_Prev_Group			0xFE0A  */ KEY_ENTER,
+/* XK_ISO_Prev_Group_Lock		0xFE0B  */ KEY_DEL,
+/* XK_ISO_First_Group			0xFE0C  */ KEY_ENTER,
+/* XK_ISO_First_Group_Lock		0xFE0D  */ KEY_ENTER,
+/* XK_ISO_Last_Group			0xFE0E  */ KEY_NONE,
+/* XK_ISO_Last_Group_Lock		0xFE0F  */ KEY_NONE,
+/*					0xFE10  */ KEY_NONE,
+/*					0xFE11  */ KEY_NONE,
+/*					0xFE12  */ KEY_NONE,
+/*					0xFE13  */ KEY_PAUSE,
+/*					0xFE14  */ KEY_NONE,
+/*					0xFE15  */ KEY_NONE,
+/*					0xFE16  */ KEY_NONE,
+/*					0xFE17  */ KEY_NONE,
+/*					0xFE18  */ KEY_NONE,
+/*					0xFE19  */ KEY_NONE,
+/*					0xFE1A  */ KEY_NONE,
+/*					0xFE1B  */ KEY_ESC,
+/*					0xFE1C  */ KEY_NONE,
+/*					0xFE1D  */ KEY_NONE,
+/*					0xFE1E  */ KEY_NONE,
+/*					0xFE1F  */ KEY_NONE,
+/* XK_ISO_Left_Tab			0xFE20  */ KEY_NONE,
+/* XK_ISO_Move_Line_Up			0xFE21  */ KEY_NONE,
+/* XK_ISO_Move_Line_Down		0xFE22  */ KEY_NONE,
+/* XK_ISO_Partial_Line_Up		0xFE23  */ KEY_NONE,
+/* XK_ISO_Partial_Line_Down		0xFE24  */ KEY_NONE,
+/* XK_ISO_Partial_Space_Left		0xFE25  */ KEY_NONE,
+/* XK_ISO_Partial_Space_Right		0xFE26  */ KEY_NONE,
+/* XK_ISO_Set_Margin_Left		0xFE27  */ KEY_NONE,
+/* XK_ISO_Set_Margin_Right		0xFE28  */ KEY_NONE,
+/* XK_ISO_Release_Margin_Left		0xFE29  */ KEY_NONE,
+/* XK_ISO_Release_Margin_Right		0xFE2A  */ KEY_NONE,
+/* XK_ISO_Release_Both_Margins		0xFE2B  */ KEY_NONE,
+/* XK_ISO_Fast_Cursor_Left		0xFE2C  */ KEY_NONE,
+/* XK_ISO_Fast_Cursor_Right		0xFE2D  */ KEY_NONE,
+/* XK_ISO_Fast_Cursor_Up		0xFE2E  */ KEY_NONE,
+/* XK_ISO_Fast_Cursor_Down		0xFE2F  */ KEY_NONE,
+/* XK_ISO_Continuous_Underline		0xFE30  */ KEY_NONE,
+/* XK_ISO_Discontinuous_Underline	0xFE31  */ KEY_NONE,
+/* XK_ISO_Emphasize			0xFE32  */ KEY_NONE,
+/* XK_ISO_Center_Object			0xFE33  */ KEY_NONE,
+/* XK_ISO_Enter				0xFE34  */ KEY_NONE,
+/*					0xFE35  */ KEY_NONE,
+/*					0xFE36  */ KEY_NONE,
+/*					0xFE37  */ KEY_NONE,
+/*					0xFE38  */ KEY_NONE,
+/*					0xFE39  */ KEY_NONE,
+/*					0xFE3A  */ KEY_NONE,
+/*					0xFE3B  */ KEY_NONE,
+/*					0xFE3C  */ KEY_NONE,
+/*					0xFE3D  */ KEY_NONE,
+/*					0xFE3E  */ KEY_NONE,
+/*					0xFE3F  */ KEY_NONE,
+/*					0xFE40  */ KEY_NONE,
+/*					0xFE41  */ KEY_NONE,
+/*					0xFE42  */ KEY_NONE,
+/*					0xFE43  */ KEY_NONE,
+/*					0xFE44  */ KEY_NONE,
+/*					0xFE45  */ KEY_NONE,
+/*					0xFE46  */ KEY_NONE,
+/*					0xFE47  */ KEY_NONE,
+/*					0xFE48  */ KEY_NONE,
+/*					0xFE49  */ KEY_NONE,
+/*					0xFE4A  */ KEY_NONE,
+/*					0xFE4B  */ KEY_NONE,
+/*					0xFE4C  */ KEY_NONE,
+/*					0xFE4D  */ KEY_NONE,
+/*					0xFE4E  */ KEY_NONE,
+/*					0xFE4F  */ KEY_NONE,
+/* XK_dead_grave			0xFE50  */ KEY_HOME,
+/* XK_dead_acute			0xFE51  */ KEY_LEFT,
+/* XK_dead_circumflex			0xFE52  */ KEY_UP,
+/* XK_dead_tilde			0xFE53  */ KEY_RIGHT,
+/* XK_dead_macron			0xFE54  */ KEY_DOWN,
+/* XK_dead_breve			0xFE55  */ KEY_PGUP,
+/* XK_dead_abovedot			0xFE56  */ KEY_PGDN,
+/* XK_dead_diaeresis			0xFE57  */ KEY_END,
+/* XK_dead_abovering			0xFE58  */ KEY_NONE,
+/* XK_dead_doubleacute			0xFE59  */ KEY_NONE,
+/* XK_dead_caron			0xFE5A  */ KEY_NONE,
+/* XK_dead_cedilla			0xFE5B  */ KEY_NONE,
+/* XK_dead_ogonek			0xFE5C  */ KEY_NONE,
+/* XK_dead_iota				0xFE5D  */ KEY_NONE,
+/* XK_dead_voiced_sound			0xFE5E  */ KEY_NONE,
+/* XK_dead_semivoiced_sound		0xFE5F  */ KEY_NONE,
+/* XK_dead_belowdot			0xFE60  */ KEY_NONE,
+/*					0xFE61  */ KEY_NONE,
+/*					0xFE62  */ KEY_NONE,
+/*					0xFE63  */ KEY_NONE,
+/*					0xFE64  */ KEY_NONE,
+/*					0xFE65  */ KEY_NONE,
+/*					0xFE66  */ KEY_NONE,
+/*					0xFE67  */ KEY_NONE,
+/*					0xFE68  */ KEY_NONE,
+/*					0xFE69  */ KEY_NONE,
+/*					0xFE6A  */ KEY_NONE,
+/*					0xFE6B  */ KEY_NONE,
+/*					0xFE6C  */ KEY_NONE,
+/*					0xFE6D  */ KEY_NONE,
+/*					0xFE6E  */ KEY_NONE,
+/*					0xFE6F  */ KEY_NONE,
+/* XK_AccessX_Enable			0xFE70  */ KEY_NONE,
+/* XK_AccessX_Feedback_Enable		0xFE71  */ KEY_NONE,
+/* XK_RepeatKeys_Enable			0xFE72  */ KEY_NONE,
+/* XK_SlowKeys_Enable			0xFE73  */ KEY_NONE,
+/* XK_BounceKeys_Enable			0xFE74  */ KEY_NONE,
+/* XK_StickyKeys_Enable			0xFE75  */ KEY_NONE,
+/* XK_MouseKeys_Enable			0xFE76  */ KEY_NONE,
+/* XK_MouseKeys_Accel_Enable		0xFE77  */ KEY_NONE,
+/* XK_Overlay1_Enable			0xFE78  */ KEY_NONE,
+/* XK_Overlay2_Enable			0xFE79  */ KEY_NONE,
+/* XK_AudibleBell_Enable		0xFE7A  */ KEY_NONE,
+/*					0xFE7B  */ KEY_NONE,
+/*					0xFE7C  */ KEY_NONE,
+/*					0xFE7D  */ KEY_NONE,
+/*					0xFE7E  */ KEY_NONE,
+/*					0xFE7F  */ KEY_NONE,
+/*					0xFE80  */ KEY_NONE,
+/*					0xFE81  */ KEY_NONE,
+/*					0xFE82  */ KEY_NONE,
+/*					0xFE83  */ KEY_NONE,
+/*					0xFE84  */ KEY_NONE,
+/*					0xFE85  */ KEY_NONE,
+/*					0xFE86  */ KEY_NONE,
+/*					0xFE87  */ KEY_NONE,
+/*					0xFE88  */ KEY_NONE,
+/*					0xFE89  */ KEY_NONE,
+/*					0xFE8A  */ KEY_NONE,
+/*					0xFE8B  */ KEY_NONE,
+/*					0xFE8C  */ KEY_NONE,
+/*					0xFE8D  */ KEY_ENTER_PAD,
+/*					0xFE8E  */ KEY_NONE,
+/*					0xFE8F  */ KEY_NONE,
+/*					0xFE90  */ KEY_NONE,
+/*					0xFE91  */ KEY_NONE,
+/*					0xFE92  */ KEY_NONE,
+/*					0xFE93  */ KEY_NONE,
+/*					0xFE94  */ KEY_NONE,
+/*					0xFE95  */ KEY_NONE,
+/*					0xFE96  */ KEY_NONE,
+/*					0xFE97  */ KEY_NONE,
+/*					0xFE98  */ KEY_NONE,
+/*					0xFE99  */ KEY_NONE,
+/*					0xFE9A  */ KEY_NONE,
+/*					0xFE9B  */ KEY_NONE,
+/*					0xFE9C  */ KEY_NONE,
+/*					0xFE9D  */ KEY_NONE,
+/*					0xFE9E  */ KEY_NONE,
+/*					0xFE9F  */ KEY_NONE,
+/*					0xFEA0  */ KEY_NONE,
+/*					0xFEA1  */ KEY_NONE,
+/*					0xFEA2  */ KEY_NONE,
+/*					0xFEA3  */ KEY_NONE,
+/*					0xFEA4  */ KEY_NONE,
+/*					0xFEA5  */ KEY_NONE,
+/*					0xFEA6  */ KEY_NONE,
+/*					0xFEA7  */ KEY_NONE,
+/*					0xFEA8  */ KEY_NONE,
+/*					0xFEA9  */ KEY_NONE,
+/*					0xFEAA  */ KEY_NONE,
+/*					0xFEAB  */ KEY_NONE,
+/*					0xFEAC  */ KEY_NONE,
+/*					0xFEAD  */ KEY_NONE,
+/*					0xFEAE  */ KEY_NONE,
+/*					0xFEAF  */ KEY_NONE,
+/*					0xFEB0  */ KEY_NONE,
+/*					0xFEB1  */ KEY_NONE,
+/*					0xFEB2  */ KEY_NONE,
+/*					0xFEB3  */ KEY_NONE,
+/*					0xFEB4  */ KEY_NONE,
+/*					0xFEB5  */ KEY_NONE,
+/*					0xFEB6  */ KEY_NONE,
+/*					0xFEB7  */ KEY_NONE,
+/*					0xFEB8  */ KEY_NONE,
+/*					0xFEB9  */ KEY_NONE,
+/*					0xFEBA  */ KEY_NONE,
+/*					0xFEBB  */ KEY_NONE,
+/*					0xFEBC  */ KEY_NONE,
+/*					0xFEBD  */ KEY_NONE,
+/*					0xFEBE  */ KEY_NONE,
+/*					0xFEBF  */ KEY_NONE,
+/*					0xFEC0  */ KEY_NONE,
+/*					0xFEC1  */ KEY_NONE,
+/*					0xFEC2  */ KEY_NONE,
+/*					0xFEC3  */ KEY_NONE,
+/*					0xFEC4  */ KEY_NONE,
+/*					0xFEC5  */ KEY_NONE,
+/*					0xFEC6  */ KEY_NONE,
+/*					0xFEC7  */ KEY_NONE,
+/*					0xFEC8  */ KEY_NONE,
+/*					0xFEC9  */ KEY_NONE,
+/*					0xFECA  */ KEY_NONE,
+/*					0xFECB  */ KEY_NONE,
+/*					0xFECC  */ KEY_NONE,
+/*					0xFECD  */ KEY_NONE,
+/*					0xFECE  */ KEY_NONE,
+/*					0xFECF  */ KEY_NONE,
+/* XK_First_Virtual_Screen		0xFED0  */ KEY_NONE,
+/* XK_Prev_Virtual_Screen		0xFED1  */ KEY_NONE,
+/* XK_Next_Virtual_Screen		0xFED2  */ KEY_NONE,
+/*					0xFED3  */ KEY_NONE,
+/* XK_Last_Virtual_Screen		0xFED4  */ KEY_NONE,
+/* XK_Terminate_Server			0xFED5  */ KEY_NONE,
+/*					0xFED6  */ KEY_NONE,
+/*					0xFED7  */ KEY_NONE,
+/*					0xFED8  */ KEY_NONE,
+/*					0xFED9  */ KEY_NONE,
+/*					0xFEDA  */ KEY_NONE,
+/*					0xFEDB  */ KEY_NONE,
+/*					0xFEDC  */ KEY_NONE,
+/*					0xFEDD  */ KEY_NONE,
+/*					0xFEDE  */ KEY_NONE,
+/*					0xFEDF  */ KEY_NONE,
+/* XK_Pointer_Left			0xFEE0  */ KEY_NONE,
+/* XK_Pointer_Right			0xFEE1  */ KEY_LSHIFT,
+/* XK_Pointer_Up			0xFEE2  */ KEY_RSHIFT,
+/* XK_Pointer_Down			0xFEE3  */ KEY_LCONTROL,
+/* XK_Pointer_UpLeft			0xFEE4  */ KEY_RCONTROL,
+/* XK_Pointer_UpRight			0xFEE5  */ KEY_NONE,
+/* XK_Pointer_DownLeft			0xFEE6  */ KEY_NONE,
+/* XK_Pointer_DownRight			0xFEE7  */ KEY_NONE,
+/* XK_Pointer_Button_Dflt		0xFEE8  */ KEY_NONE,
+/* XK_Pointer_Button1			0xFEE9  */ KEY_ALT,
+/* XK_Pointer_Button2			0xFEEA  */ KEY_ALT,
+/* XK_Pointer_Button3			0xFEEB  */ KEY_NONE,
+/* XK_Pointer_Button4			0xFEEC  */ KEY_NONE,
+/* XK_Pointer_Button5			0xFEED  */ KEY_NONE,
+/* XK_Pointer_DblClick_Dflt		0xFEEE  */ KEY_NONE,
+/* XK_Pointer_DblClick1			0xFEEF  */ KEY_NONE,
+/* XK_Pointer_DblClick2			0xFEF0  */ KEY_NONE,
+/* XK_Pointer_DblClick3			0xFEF1  */ KEY_NONE,
+/* XK_Pointer_DblClick4			0xFEF2  */ KEY_NONE,
+/* XK_Pointer_DblClick5			0xFEF3  */ KEY_NONE,
+/* XK_Pointer_Drag_Dflt			0xFEF4  */ KEY_NONE,
+/* XK_Pointer_Drag1			0xFEF5  */ KEY_NONE,
+/* XK_Pointer_Drag2			0xFEF6  */ KEY_NONE,
+/* XK_Pointer_Drag3			0xFEF7  */ KEY_NONE,
+/* XK_Pointer_Drag4			0xFEF8  */ KEY_NONE,
+/* XK_Pointer_EnableKeys		0xFEF9  */ KEY_NONE,
+/* XK_Pointer_Accelerate		0xFEFA  */ KEY_NONE,
+/* XK_Pointer_DfltBtnNext		0xFEFB  */ KEY_NONE,
+/* XK_Pointer_DfltBtnPrev		0xFEFC  */ KEY_NONE,
+/* XK_Pointer_Drag5			0xFEFD  */ KEY_NONE,
+/*					0xFEFE  */ KEY_NONE,
+/*					0xFEFF  */ KEY_NONE,
+#endif
+/*					0xFF00  */ KEY_NONE,
+/*					0xFF01  */ KEY_NONE,
+/*					0xFF02  */ KEY_NONE,
+/*					0xFF03  */ KEY_NONE,
+/*					0xFF04  */ KEY_NONE,
+/*					0xFF05  */ KEY_NONE,
+/*					0xFF06  */ KEY_NONE,
+/*					0xFF07  */ KEY_NONE,
+/* XK_BackSpace				0xFF08	*/ KEY_BACKSPACE,
+/* XK_Tab				0xFF09	*/ KEY_TAB,
+/* XK_Linefeed				0xFF0A	*/ KEY_ENTER,
+/* XK_Clear				0xFF0B  */ KEY_DEL,
+/*					0xFF0C  */ KEY_NONE,
+/* XK_Return				0xFF0D	*/ KEY_ENTER,
+/*					0xFF0E  */ KEY_NONE,
+/*					0xFF0F  */ KEY_NONE,
+/*					0xFF10  */ KEY_F11,
+/*					0xFF11  */ KEY_F12,
+/*					0xFF12  */ KEY_NONE,
+/* XK_Pause				0xFF13	*/ KEY_PAUSE,
+/* XK_Scroll_Lock			0xFF14  */ KEY_SCRLOCK,
+/* XK_Sys_Req				0xFF15  */ KEY_PRTSCR,
+/*					0xFF16  */ KEY_NONE,
+/*					0xFF17  */ KEY_NONE,
+/*					0xFF18  */ KEY_NONE,
+/*					0xFF19  */ KEY_NONE,
+/*					0xFF1A  */ KEY_NONE,
+/* XK_Escape				0xFF1B  */ KEY_ESC,
+/*					0xFF1C  */ KEY_NONE,
+/*					0xFF1D  */ KEY_NONE,
+/*					0xFF1E  */ KEY_NONE,
+/*					0xFF1F  */ KEY_NONE,
+/* XK_Multi_key				0xFF20  */ KEY_NONE,
+/* XK_Kanji				0xFF21	*/ KEY_NONE,
+/* XK_Muhenkan				0xFF22  */ KEY_NONE,
+/* XK_Henkan_Mode			0xFF23  */ KEY_NONE,
+/* XK_Henkan				0xFF23  duplicated */
+/* XK_Romaji				0xFF24  */ KEY_NONE,
+/* XK_Hiragana				0xFF25  */ KEY_NONE,
+/* XK_Katakana				0xFF26  */ KEY_NONE,
+/* XK_Hiragana_Katakana			0xFF27  */ KEY_NONE,
+/* XK_Zenkaku				0xFF28  */ KEY_NONE,
+/* XK_Hankaku				0xFF29  */ KEY_NONE,
+/* XK_Zenkaku_Hankaku			0xFF2A  */ KEY_NONE,
+/* XK_Touroku				0xFF2B  */ KEY_NONE,
+/* XK_Massyo				0xFF2C  */ KEY_NONE,
+/* XK_Kana_Lock				0xFF2D  */ KEY_NONE,
+/* XK_Kana_Shift			0xFF2E  */ KEY_NONE,
+/* XK_Eisu_Shift			0xFF2F  */ KEY_NONE,
+/* XK_Eisu_toggle			0xFF30  */ KEY_NONE,
+/*					0xFF31  */ KEY_NONE,
+/*					0xFF32  */ KEY_NONE,
+/*					0xFF33  */ KEY_NONE,
+/*					0xFF34  */ KEY_NONE,
+/*					0xFF35  */ KEY_NONE,
+/*					0xFF36  */ KEY_NONE,
+/*					0xFF37  */ KEY_NONE,
+/*					0xFF38  */ KEY_NONE,
+/*					0xFF39  */ KEY_NONE,
+/*					0xFF3A  */ KEY_NONE,
+/*					0xFF3B  */ KEY_NONE,
+/*					0xFF3C  */ KEY_NONE,
+/*					0xFF3D  */ KEY_NONE,
+/*					0xFF3E  */ KEY_NONE,
+/*					0xFF3F  */ KEY_NONE,
+/*					0xFF40  */ KEY_NONE,
+/*					0xFF41  */ KEY_NONE,
+/*					0xFF42  */ KEY_NONE,
+/*					0xFF43  */ KEY_NONE,
+/*					0xFF44  */ KEY_NONE,
+/*					0xFF45  */ KEY_NONE,
+/*					0xFF46  */ KEY_NONE,
+/*					0xFF47  */ KEY_NONE,
+/*					0xFF48  */ KEY_NONE,
+/*					0xFF49  */ KEY_NONE,
+/*					0xFF4A  */ KEY_NONE,
+/*					0xFF4B  */ KEY_NONE,
+/*					0xFF4C  */ KEY_NONE,
+/*					0xFF4D  */ KEY_NONE,
+/*					0xFF4E  */ KEY_NONE,
+/*					0xFF4F  */ KEY_NONE,
+/* XK_Home				0xFF50  */ KEY_HOME,
+/* XK_Left				0xFF51	*/ KEY_LEFT,
+/* XK_Up				0xFF52	*/ KEY_UP,
+/* XK_Right				0xFF53	*/ KEY_RIGHT,
+/* XK_Down				0xFF54	*/ KEY_DOWN,
+/* XK_Prior				0xFF55	*/ KEY_PGUP,
+/* XK_Page_Up				0xFF55  duplicated */
+/* XK_Next				0xFF56	*/ KEY_PGDN,
+/* XK_Page_Down				0xFF56  duplicated */
+/* XK_End				0xFF57	*/ KEY_END,
+/* XK_Begin				0xFF58	*/ KEY_HOME,
+/*					0xFF59  */ KEY_NONE,
+/*					0xFF5A  */ KEY_NONE,
+/*					0xFF5B  */ KEY_NONE,
+/*					0xFF5C  */ KEY_NONE,
+/*					0xFF5D  */ KEY_NONE,
+/*					0xFF5E  */ KEY_NONE,
+/*					0xFF5F  */ KEY_NONE,
+/* XK_Select				0xFF60	*/ KEY_NONE,
+/* XK_Print				0xFF61  */ KEY_PRTSCR,
+/* XK_Execute				0xFF62	*/ KEY_ENTER,
+/* XK_Insert				0xFF63	*/ KEY_INSERT,
+/*					0xFF64	*/ KEY_NONE,
+/* XK_Undo				0xFF65	*/ KEY_NONE,
+/* XK_Redo				0xFF66	*/ KEY_NONE,
+/* XK_Menu				0xFF67  */ KEY_MENU,
+/* XK_Find				0xFF68	*/ KEY_NONE,
+/* XK_Cancel				0xFF69	*/ KEY_NONE,
+/* XK_Help				0xFF6A	*/ KEY_NONE,
+/* XK_Break				0xFF6B  */ KEY_NONE,
+/* 					0xFF6C  */ KEY_NONE,
+/* 					0xFF6D  */ KEY_NONE,
+/* 					0xFF6E  */ KEY_NONE,
+/* 					0xFF6F  */ KEY_NONE,
+/* 					0xFF70  */ KEY_NONE,
+/* 					0xFF71  */ KEY_NONE,
+/* 					0xFF72  */ KEY_NONE,
+/* 					0xFF73  */ KEY_NONE,
+/* 					0xFF74  */ KEY_NONE,
+/* 					0xFF75  */ KEY_NONE,
+/* 					0xFF76  */ KEY_NONE,
+/* 					0xFF77  */ KEY_NONE,
+/* 					0xFF78  */ KEY_NONE,
+/* 					0xFF79  */ KEY_NONE,
+/* 					0xFF7A  */ KEY_NONE,
+/* 					0xFF7B  */ KEY_NONE,
+/* 					0xFF7C  */ KEY_NONE,
+/* 					0xFF7D  */ KEY_NONE,
+/* XK_Mode_switch			0xFF7E	*/ KEY_ALTGR,
+/* XK_script_switch			0xFF7E  duplicated */
+/* XK_Num_Lock				0xFF7F  */ KEY_NUMLOCK,
+/* XK_KP_Space				0xFF80	*/ KEY_SPACE,
+/* 					0xFF81  */ KEY_NONE,
+/* 					0xFF82  */ KEY_NONE,
+/* 					0xFF83  */ KEY_NONE,
+/* 					0xFF84  */ KEY_NONE,
+/* 					0xFF85  */ KEY_NONE,
+/* 					0xFF86  */ KEY_NONE,
+/* 					0xFF87  */ KEY_NONE,
+/* 					0xFF88  */ KEY_NONE,
+/* XK_KP_Tab				0xFF89  */ KEY_TAB,
+/* 					0xFF8A  */ KEY_NONE,
+/* 					0xFF8B  */ KEY_NONE,
+/* 					0xFF8C  */ KEY_NONE,
+/* XK_KP_Enter				0xFF8D	*/ KEY_ENTER_PAD,
+/* 					0xFF8E  */ KEY_NONE,
+/* 					0xFF8F  */ KEY_NONE,
+/* 					0xFF90  */ KEY_NONE,
+/* XK_KP_F1				0xFF91	*/ KEY_F1,
+/* XK_KP_F2				0xFF92  */ KEY_F2,
+/* XK_KP_F3				0xFF93  */ KEY_F3,
+/* XK_KP_F4				0xFF94  */ KEY_F4,
+/* XK_KP_Home				0xFF95  */ KEY_7_PAD,
+/* XK_KP_Left				0xFF96  */ KEY_4_PAD,
+/* XK_KP_Up				0xFF97  */ KEY_8_PAD,
+/* XK_KP_Right				0xFF98  */ KEY_6_PAD,
+/* XK_KP_Down				0xFF99  */ KEY_2_PAD,
+/* XK_KP_Prior				0xFF9A  */ KEY_9_PAD,
+/* XK_KP_Page_Up			0xFF9A  duplicated */
+/* XK_KP_Next				0xFF9B  */ KEY_3_PAD,
+/* XK_KP_Page_Down			0xFF9B  duplicated */
+/* XK_KP_End				0xFF9C  */ KEY_1_PAD,
+/* XK_KP_Begin				0xFF9D  */ KEY_5_PAD,
+/* XK_KP_Insert				0xFF9E  */ KEY_0_PAD,
+/* XK_KP_Delete				0xFF9F  */ KEY_DEL_PAD,
+/* 					0xFFA0  */ KEY_NONE,
+/* 					0xFFA1  */ KEY_NONE,
+/* 					0xFFA2  */ KEY_NONE,
+/* 					0xFFA3  */ KEY_NONE,
+/* 					0xFFA4  */ KEY_NONE,
+/* 					0xFFA5  */ KEY_NONE,
+/* 					0xFFA6  */ KEY_NONE,
+/* 					0xFFA7  */ KEY_NONE,
+/* 					0xFFA8  */ KEY_NONE,
+/* 					0xFFA9  */ KEY_NONE,
+/* XK_KP_Multiply			0xFFAA  */ KEY_ASTERISK,
+/* XK_KP_Add				0xFFAB  */ KEY_PLUS_PAD,
+/* XK_KP_Separator			0xFFAC	*/ KEY_NONE,
+/* XK_KP_Subtract			0xFFAD  */ KEY_MINUS_PAD,
+/* XK_KP_Decimal			0xFFAE  */ KEY_DEL_PAD,
+/* XK_KP_Divide				0xFFAF  */ KEY_SLASH_PAD,
+/* XK_KP_0				0xFFB0  */ KEY_0_PAD,
+/* XK_KP_1				0xFFB1  */ KEY_1_PAD,
+/* XK_KP_2				0xFFB2  */ KEY_2_PAD,
+/* XK_KP_3				0xFFB3  */ KEY_3_PAD,
+/* XK_KP_4				0xFFB4  */ KEY_4_PAD,
+/* XK_KP_5				0xFFB5  */ KEY_5_PAD,
+/* XK_KP_6				0xFFB6  */ KEY_6_PAD,
+/* XK_KP_7				0xFFB7  */ KEY_7_PAD,
+/* XK_KP_8				0xFFB8  */ KEY_8_PAD,
+/* XK_KP_9				0xFFB9  */ KEY_9_PAD,
+/* 					0xFFBA  */ KEY_NONE,
+/* 					0xFFBB  */ KEY_NONE,
+/* 					0xFFBC  */ KEY_NONE,
+/* XK_KP_Equal				0xFFBD	*/ KEY_ENTER_PAD,
+/* XK_F1				0xFFBE  */ KEY_F1,
+/* XK_F2				0xFFBF  */ KEY_F2,
+/* XK_F3				0xFFC0  */ KEY_F3,
+/* XK_F4				0xFFC1  */ KEY_F4,
+/* XK_F5				0xFFC2  */ KEY_F5,
+/* XK_F6				0xFFC3  */ KEY_F6,
+/* XK_F7				0xFFC4  */ KEY_F7,
+/* XK_F8				0xFFC5  */ KEY_F8,
+/* XK_F9				0xFFC6  */ KEY_F9,
+/* XK_F10				0xFFC7  */ KEY_F10,
+/* XK_F11				0xFFC8  */ KEY_F11,
+/* XK_L1				0xFFC8  duplicated */
+/* XK_F12				0xFFC9  */ KEY_F12,
+/* XK_L2				0xFFC9  duplicated */
+/* XK_F13				0xFFCA  */ KEY_NONE,
+/* XK_L3				0xFFCA  duplicated */
+/* XK_F14				0xFFCB  */ KEY_NONE,
+/* XK_L4				0xFFCB  duplicated */
+/* XK_F15				0xFFCC  */ KEY_NONE,
+/* XK_L5				0xFFCC  duplicated */
+/* XK_F16				0xFFCD  */ KEY_NONE,
+/* XK_L6				0xFFCD  duplicated */
+/* XK_F17				0xFFCE  */ KEY_NONE,
+/* XK_L7				0xFFCE  duplicated */
+/* XK_F18				0xFFCF  */ KEY_NONE,
+/* XK_L8				0xFFCF  duplicated */
+/* XK_F19				0xFFD0  */ KEY_NONE,
+/* XK_L9				0xFFD0  duplicated */
+/* XK_F20				0xFFD1  */ KEY_NONE,
+/* XK_L10				0xFFD1  duplicated */
+/* XK_F21				0xFFD2  */ KEY_NONE,
+/* XK_R1				0xFFD2  duplicated */
+/* XK_F22				0xFFD3  */ KEY_NONE,
+/* XK_R2				0xFFD3  duplicated */
+/* XK_F23				0xFFD4  */ KEY_NONE,
+/* XK_R3				0xFFD4  duplicated */
+/* XK_F24				0xFFD5  */ KEY_NONE,
+/* XK_R4				0xFFD5  duplicated */
+/* XK_F25				0xFFD6  */ KEY_NONE,
+/* XK_R5				0xFFD6  duplicated */
+/* XK_F26				0xFFD7  */ KEY_NONE,
+/* XK_R6				0xFFD7  duplicated */
+/* XK_F27				0xFFD8  */ KEY_NONE,
+/* XK_R7				0xFFD8  duplicated */
+/* XK_F28				0xFFD9  */ KEY_NONE,
+/* XK_R8				0xFFD9  duplicated */
+/* XK_F29				0xFFDA  */ KEY_NONE,
+/* XK_R9				0xFFDA  duplicated */
+/* XK_F30				0xFFDB  */ KEY_NONE,
+/* XK_R10				0xFFDB  duplicated */
+/* XK_F31				0xFFDC  */ KEY_NONE,
+/* XK_R11				0xFFDC  duplicated */
+/* XK_F32				0xFFDD  */ KEY_NONE,
+/* XK_R12				0xFFDD  duplicated */
+/* XK_F33				0xFFDE  */ KEY_NONE,
+/* XK_R13				0xFFDE  duplicated */
+/* XK_F34				0xFFDF  */ KEY_NONE,
+/* XK_R14				0xFFDF  duplicated */
+/* XK_F35				0xFFE0  */ KEY_NONE,
+/* XK_R15				0xFFE0  duplicated */
+/* XK_Shift_L				0xFFE1	*/ KEY_LSHIFT,
+/* XK_Shift_R				0xFFE2	*/ KEY_RSHIFT,
+/* XK_Control_L				0xFFE3	*/ KEY_LCONTROL,
+/* XK_Control_R				0xFFE4	*/ KEY_RCONTROL,
+/* XK_Caps_Lock				0xFFE5	*/ KEY_CAPSLOCK,
+/* XK_Shift_Lock			0xFFE6	*/ KEY_CAPSLOCK,
+/* XK_Meta_L				0xFFE7	*/ KEY_ALT,
+/* XK_Meta_R				0xFFE8	*/ KEY_ALT, 
+/* XK_Alt_L				0xFFE9	*/ KEY_ALT,
+/* XK_Alt_R				0xFFEA	*/ KEY_ALTGR,
+/* XK_Super_L				0xFFEB	*/ KEY_NONE,
+/* XK_Super_R				0xFFEC	*/ KEY_NONE,
+/* XK_Hyper_L				0xFFED	*/ KEY_NONE,
+/* XK_Hyper_R				0xFFEE	*/ KEY_NONE,
+/* 					0xFFEF  */ KEY_NONE,
+/* 					0xFFF0  */ KEY_NONE,
+/* 					0xFFF1  */ KEY_NONE,
+/* 					0xFFF2  */ KEY_NONE,
+/* 					0xFFF3  */ KEY_NONE,
+/* 					0xFFF4  */ KEY_NONE,
+/* 					0xFFF5  */ KEY_NONE,
+/* 					0xFFF6  */ KEY_NONE,
+/* 					0xFFF7  */ KEY_NONE,
+/* 					0xFFF8  */ KEY_NONE,
+/* 					0xFFF9  */ KEY_NONE,
+/* 					0xFFFA  */ KEY_NONE,
+/* 					0xFFFB  */ KEY_NONE,
+/* 					0xFFFC  */ KEY_NONE,
+/* 					0xFFFD  */ KEY_NONE,
+/* 					0xFFFE  */ KEY_NONE,
+/* XK_Delete				0xFFFF	*/ KEY_DEL
+}; 	/* extended_code_table */
+
+static int code_table[] = {
+
+/* 			  0x000  */ KEY_NONE,
+/* 			  0x001  */ KEY_NONE,
+/* 			  0x002  */ KEY_NONE,
+/* 			  0x003  */ KEY_NONE,
+/* 			  0x004  */ KEY_NONE,
+/* 			  0x005  */ KEY_NONE,
+/* 			  0x006  */ KEY_NONE,
+/* 			  0x007  */ KEY_NONE,
+/* 			  0x008  */ KEY_NONE,
+/* 			  0x009  */ KEY_NONE,
+/* 			  0x00a  */ KEY_NONE,
+/* 			  0x00b  */ KEY_NONE,
+/* 			  0x00c  */ KEY_NONE,
+/* 			  0x00d  */ KEY_NONE,
+/* 			  0x00e  */ KEY_NONE,
+/* 			  0x00f  */ KEY_NONE,
+/* 			  0x010  */ KEY_NONE,
+/* 			  0x011  */ KEY_NONE,
+/* 			  0x012  */ KEY_NONE,
+/* 			  0x013  */ KEY_NONE,
+/* 			  0x014  */ KEY_NONE,
+/* 			  0x015  */ KEY_NONE,
+/* 			  0x016  */ KEY_NONE,
+/* 			  0x017  */ KEY_NONE,
+/* 			  0x018  */ KEY_NONE,
+/* 			  0x019  */ KEY_NONE,
+/* 			  0x01a  */ KEY_NONE,
+/* 			  0x01b  */ KEY_NONE,
+/* 			  0x01c  */ KEY_NONE,
+/* 			  0x01d  */ KEY_NONE,
+/* 			  0x01e  */ KEY_NONE,
+/* 			  0x01f  */ KEY_NONE,
+/* XK_space               0x020  */ KEY_SPACE,
+/* XK_exclam              0x021  */ KEY_1,
+/* XK_quotedbl            0x022  */ KEY_QUOTE,
+/* XK_numbersign          0x023  */ KEY_3,
+/* XK_dollar              0x024  */ KEY_4,
+/* XK_percent             0x025  */ KEY_5,
+/* XK_ampersand           0x026  */ KEY_7,
+/* XK_apostrophe          0x027  */ KEY_MINUS, /* keyboard dependent */
+/* XK_quoteright          0x027	 duplicated */ 
+/* XK_parenleft           0x028  */ KEY_9,
+/* XK_parenright          0x029  */ KEY_0,
+/* XK_asterisk            0x02a  */ KEY_ASTERISK,
+/* XK_plus                0x02b  */ KEY_CLOSEBRACE, /* keyboard dependent */
+/* XK_comma               0x02c  */ KEY_COMMA,
+/* XK_minus               0x02d  */ KEY_MINUS,
+/* XK_period              0x02e  */ KEY_STOP,
+/* XK_slash               0x02f  */ KEY_SLASH,
+/* XK_0                   0x030  */ KEY_0,
+/* XK_1                   0x031  */ KEY_1,
+/* XK_2                   0x032  */ KEY_2,
+/* XK_3                   0x033  */ KEY_3,
+/* XK_4                   0x034  */ KEY_4,
+/* XK_5                   0x035  */ KEY_5,
+/* XK_6                   0x036  */ KEY_6,
+/* XK_7                   0x037  */ KEY_7,
+/* XK_8                   0x038  */ KEY_8,
+/* XK_9                   0x039  */ KEY_9,
+/* XK_colon               0x03a  */ KEY_COLON,
+/* XK_semicolon           0x03b  */ KEY_COLON,
+/* XK_less                0x03c  */ KEY_COMMA,
+/* XK_equal               0x03d  */ KEY_EQUALS,
+/* XK_greater             0x03e  */ KEY_STOP,
+/* XK_question            0x03f  */ KEY_SLASH,
+/* XK_at                  0x040  */ KEY_2,
+/* XK_A                   0x041  */ KEY_A,
+/* XK_B                   0x042  */ KEY_B,
+/* XK_C                   0x043  */ KEY_C,
+/* XK_D                   0x044  */ KEY_D,
+/* XK_E                   0x045  */ KEY_E,
+/* XK_F                   0x046  */ KEY_F,
+/* XK_G                   0x047  */ KEY_G,
+/* XK_H                   0x048  */ KEY_H,
+/* XK_I                   0x049  */ KEY_I,
+/* XK_J                   0x04a  */ KEY_J,
+/* XK_K                   0x04b  */ KEY_K,
+/* XK_L                   0x04c  */ KEY_L,
+/* XK_M                   0x04d  */ KEY_M,
+/* XK_N                   0x04e  */ KEY_N,
+/* XK_O                   0x04f  */ KEY_O,
+/* XK_P                   0x050  */ KEY_P,
+/* XK_Q                   0x051  */ KEY_Q,
+/* XK_R                   0x052  */ KEY_R,
+/* XK_S                   0x053  */ KEY_S,
+/* XK_T                   0x054  */ KEY_T,
+/* XK_U                   0x055  */ KEY_U,
+/* XK_V                   0x056  */ KEY_V,
+/* XK_W                   0x057  */ KEY_W,
+/* XK_X                   0x058  */ KEY_X,
+/* XK_Y                   0x059  */ KEY_Y,
+/* XK_Z                   0x05a  */ KEY_Z,
+/* XK_bracketleft         0x05b  */ KEY_OPENBRACE,
+/* XK_backslash           0x05c  */ KEY_BACKSLASH,
+/* XK_bracketright        0x05d  */ KEY_CLOSEBRACE,
+/* XK_asciicircum         0x05e  */ KEY_TILDE,
+/* XK_underscore          0x05f  */ KEY_MINUS,
+/* XK_grave               0x060  */ KEY_TILDE, /* keyboard dependent */
+/* XK_quoteleft           0x060  duplicated */
+/* XK_a                   0x061  */ KEY_A,
+/* XK_b                   0x062  */ KEY_B,
+/* XK_c                   0x063  */ KEY_C,
+/* XK_d                   0x064  */ KEY_D,
+/* XK_e                   0x065  */ KEY_E,
+/* XK_f                   0x066  */ KEY_F,
+/* XK_g                   0x067  */ KEY_G,
+/* XK_h                   0x068  */ KEY_H,
+/* XK_i                   0x069  */ KEY_I,
+/* XK_j                   0x06a  */ KEY_J,
+/* XK_k                   0x06b  */ KEY_K,
+/* XK_l                   0x06c  */ KEY_L,
+/* XK_m                   0x06d  */ KEY_M,
+/* XK_n                   0x06e  */ KEY_N,
+/* XK_o                   0x06f  */ KEY_O,
+/* XK_p                   0x070  */ KEY_P,
+/* XK_q                   0x071  */ KEY_Q,
+/* XK_r                   0x072  */ KEY_R,
+/* XK_s                   0x073  */ KEY_S,
+/* XK_t                   0x074  */ KEY_T,
+/* XK_u                   0x075  */ KEY_U,
+/* XK_v                   0x076  */ KEY_V,
+/* XK_w                   0x077  */ KEY_W,
+/* XK_x                   0x078  */ KEY_X,
+/* XK_y                   0x079  */ KEY_Y,
+/* XK_z                   0x07a  */ KEY_Z,
+/* XK_braceleft           0x07b  */ KEY_OPENBRACE,
+/* XK_bar                 0x07c  */ KEY_NONE,
+/* XK_braceright          0x07d  */ KEY_CLOSEBRACE,
+/* XK_asciitilde          0x07e  */ KEY_TILDE,
+/*                        0x07f  */ KEY_NONE,
+/* 			  0x080  */ KEY_NONE,
+/* 			  0x081  */ KEY_NONE,
+/* 			  0x082  */ KEY_NONE,
+/* 			  0x083  */ KEY_NONE,
+/* 			  0x084  */ KEY_NONE,
+/* 			  0x085  */ KEY_NONE,
+/* 			  0x086  */ KEY_NONE,
+/* 			  0x087  */ KEY_NONE,
+/* 			  0x088  */ KEY_NONE,
+/* 			  0x089  */ KEY_NONE,
+/* 			  0x08a  */ KEY_NONE,
+/* 			  0x08b  */ KEY_NONE,
+/* 			  0x08c  */ KEY_NONE,
+/* 			  0x08d  */ KEY_NONE,
+/* 			  0x08e  */ KEY_NONE,
+/* 			  0x08f  */ KEY_NONE,
+/* 			  0x090  */ KEY_NONE,
+/* 			  0x091  */ KEY_NONE,
+/* 			  0x092  */ KEY_NONE,
+/* 			  0x093  */ KEY_NONE,
+/* 			  0x094  */ KEY_NONE,
+/* 			  0x095  */ KEY_NONE,
+/* 			  0x096  */ KEY_NONE,
+/* 			  0x097  */ KEY_NONE,
+/* 			  0x098  */ KEY_NONE,
+/* 			  0x099  */ KEY_NONE,
+/* 			  0x09a  */ KEY_NONE,
+/* 			  0x09b  */ KEY_NONE,
+/* 			  0x09c  */ KEY_NONE,
+/* 			  0x09d  */ KEY_NONE,
+/* 			  0x09e  */ KEY_NONE,
+/* 			  0x09f  */ KEY_NONE,
+/* XK_nobreakspace        0x0a0  */ KEY_NONE,
+/* XK_exclamdown          0x0a1  */ KEY_EQUALS, /* keyboard dependent */
+/* XK_cent                0x0a2  */ KEY_NONE,
+/* XK_sterling            0x0a3  */ KEY_NONE,
+/* XK_currency            0x0a4  */ KEY_NONE,
+/* XK_yen                 0x0a5  */ KEY_NONE,
+/* XK_brokenbar           0x0a6  */ KEY_NONE,
+/* XK_section             0x0a7  */ KEY_TILDE,
+/* XK_diaeresis           0x0a8  */ KEY_NONE,
+/* XK_copyright           0x0a9  */ KEY_NONE,
+/* XK_ordfeminine         0x0aa  */ KEY_NONE,
+/* XK_guillemotleft       0x0ab  */ KEY_NONE,
+/* XK_notsign             0x0ac  */ KEY_NONE,
+/* XK_hyphen              0x0ad  */ KEY_NONE,
+/* XK_registered          0x0ae  */ KEY_NONE,
+/* XK_macron              0x0af  */ KEY_NONE,
+/* XK_degree              0x0b0  */ KEY_NONE,
+/* XK_plusminus           0x0b1  */ KEY_NONE,
+/* XK_twosuperior         0x0b2  */ KEY_NONE,
+/* XK_treesuperior        0x0b3  */ KEY_NONE,
+/* XK_acute               0x0b4  */ KEY_QUOTE, /* keyboard dependent */
+/* XK_mu                  0x0b5  */ KEY_NONE,
+/* XK_paragraph           0x0b6  */ KEY_NONE,
+/* XK_periodcentered      0x0b7  */ KEY_NONE,
+/* XK_cedilla             0x0b8  */ KEY_NONE,
+/* XK_onesuperior         0x0b9  */ KEY_NONE,
+/* XK_masculine           0x0ba  */ KEY_NONE,
+/* XK_guillemotright      0x0bb  */ KEY_NONE,
+/* XK_onequarter          0x0bc  */ KEY_NONE,
+/* XK_onehalf             0x0bd  */ KEY_NONE,
+/* XK_threequarters       0x0be  */ KEY_NONE,
+/* XK_questiondown        0x0bf  */ KEY_NONE,
+/* XK_Agrave              0x0c0  */ KEY_NONE,
+/* XK_Aacute              0x0c1  */ KEY_NONE,
+/* XK_Acircumflex         0x0c2  */ KEY_NONE,
+/* XK_Atilde              0x0c3  */ KEY_NONE,
+/* XK_Adiaeresis          0x0c4  */ KEY_NONE,
+/* XK_Aring               0x0c5  */ KEY_NONE,
+/* XK_AE                  0x0c6  */ KEY_NONE,
+/* XK_Ccedilla            0x0c7  */ KEY_NONE,
+/* XK_Egrave              0x0c8  */ KEY_NONE,
+/* XK_Eacute              0x0c9  */ KEY_NONE,
+/* XK_Ecircumflex         0x0ca  */ KEY_NONE,
+/* XK_Ediaeresis          0x0cb  */ KEY_NONE,
+/* XK_Igrave              0x0cc  */ KEY_NONE,
+/* XK_Iacute              0x0cd  */ KEY_NONE,
+/* XK_Icircumflex         0x0ce  */ KEY_NONE,
+/* XK_Idiaeresis          0x0cf  */ KEY_NONE,
+/* XK_ETH                 0x0d0  */ KEY_NONE,
+/* XK_Eth                 0x0d0  duplicated */
+/* XK_Ntilde              0x0d1  */ KEY_NONE,
+/* XK_Ograve              0x0d2  */ KEY_NONE,
+/* XK_Oacute              0x0d3  */ KEY_NONE,
+/* XK_Ocircumflex         0x0d4  */ KEY_NONE,
+/* XK_Otilde              0x0d5  */ KEY_NONE,
+/* XK_Odiaeresis          0x0d6  */ KEY_NONE,
+/* XK_multiply            0x0d7  */ KEY_NONE,
+/* XK_Ooblique            0x0d8  */ KEY_NONE,
+/* XK_Ugrave              0x0d9  */ KEY_NONE,
+/* XK_Uacute              0x0da  */ KEY_NONE,
+/* XK_Ucircumflex         0x0db  */ KEY_NONE,
+/* XK_Udiaeresis          0x0dc  */ KEY_NONE,
+/* XK_Yacute              0x0dd  */ KEY_NONE,
+/* XK_THORN               0x0de  */ KEY_NONE,
+/* XK_Thorn               0x0de  duplicated */
+/* XK_ssharp              0x0df  */ KEY_NONE,
+/* XK_agrave              0x0e0  */ KEY_NONE,
+/* XK_aacute              0x0e1  */ KEY_NONE,
+/* XK_acircumflex         0x0e2  */ KEY_NONE,
+/* XK_atilde              0x0e3  */ KEY_NONE,
+/* XK_adiaeresis          0x0e4  */ KEY_NONE,
+/* XK_aring               0x0e5  */ KEY_NONE,
+/* XK_ae                  0x0e6  */ KEY_NONE,
+/* XK_ccedilla            0x0e7  */ KEY_SLASH, /* keyboard dependent */
+/* XK_egrave              0x0e8  */ KEY_NONE,
+/* XK_eacute              0x0e9  */ KEY_NONE,
+/* XK_ecircumflex         0x0ea  */ KEY_NONE,
+/* XK_ediaeresis          0x0eb  */ KEY_NONE,
+/* XK_igrave              0x0ec  */ KEY_NONE,
+/* XK_iacute              0x0ed  */ KEY_NONE,
+/* XK_icircumflex         0x0ee  */ KEY_NONE,
+/* XK_idiaeresis          0x0ef  */ KEY_NONE,
+/* XK_eth                 0x0f0  */ KEY_NONE,
+/* XK_ntilde              0x0f1  */ KEY_COLON, /* keyboard dependent */
+/* XK_ograve              0x0f2  */ KEY_NONE,
+/* XK_oacute              0x0f3  */ KEY_NONE,
+/* XK_ocircumflex         0x0f4  */ KEY_NONE,
+/* XK_otilde              0x0f5  */ KEY_NONE,
+/* XK_odiaeresis          0x0f6  */ KEY_NONE,
+/* XK_division            0x0f7  */ KEY_NONE,
+/* XK_oslash              0x0f8  */ KEY_NONE,
+/* XK_ugrave              0x0f9  */ KEY_NONE,
+/* XK_uacute              0x0fa  */ KEY_NONE,
+/* XK_ucircumflex         0x0fb  */ KEY_NONE,
+/* XK_udiaeresis          0x0fc  */ KEY_NONE,
+/* XK_yacute              0x0fd  */ KEY_NONE,
+/* XK_thorn               0x0fe  */ KEY_NONE,
+/* XK_ydiaeresis          0x0ff  */ KEY_NONE
+
+}; /* code_table */
diff --git a/src/unix/video-drivers/photon2.c b/src/unix/video-drivers/photon2.c
new file mode 100644
index 0000000..92b878c
--- /dev/null
+++ b/src/unix/video-drivers/photon2.c
@@ -0,0 +1,264 @@
+/* MAME Photon 2 Code
+ *
+ * Writen By: Travis Coady
+ * Origional Code By: David Rempel
+ *
+ * web: http://www.classicgaming.com/phmame/
+ * e-mail: smallfri@bigfoot.com
+ *
+ * Copyright (C) 2000-2001, The PhMAME Developement Team.
+*/
+
+/* Include files */
+#define __PH_C__
+
+#include <math.h>
+#include "xmame.h"
+#include "photon2.h"
+#include "input.h"
+
+struct rc_option display_opts[] = {
+   /* name, shortname, type, dest, deflt, min, max, func, help */
+   { "Photon Related",	NULL,			rc_seperator,	NULL,
+     NULL,		0,			0,		NULL,
+     NULL },
+   { "render-mode",	NULL,			rc_int,		&ph_video_mode,
+     "0",		0,			PH_MODE_COUNT-1, NULL,
+     "Select Photon rendering video mode:\n0 Normal window  (hotkey left-alt + insert)\n1 Fullscreen Video Overlay (hotkey left-alt + home)" },
+   { NULL,		NULL,			rc_link,	ph_window_opts,
+     NULL,		0,			0,		NULL,
+     NULL },
+     /*
+   { NULL,		NULL,			rc_link,	ph_ovr_opts,
+     NULL,		0,			0,		NULL,
+     NULL },
+     */
+   { NULL,		NULL,			rc_link,	ph_input_opts,
+     NULL,		0,			0,		NULL,
+     NULL },
+   { NULL,		NULL,			rc_end,		NULL,
+     NULL,		0,			0,		NULL,
+     NULL }
+};
+
+struct ph_func_struct {
+   int  (*init)(void);
+   int  (*create_display)(int depth);
+   void (*close_display)(void);
+   void (*update_display)(struct mame_bitmap *bitmap);
+   int  (*alloc_palette)(int writable_colors);
+   int  (*modify_pen)(int pen, unsigned char red, unsigned char green, unsigned char blue);
+   int  (*_16bpp_capable)(void);
+};
+
+struct ph_func_struct ph_func[PH_MODE_COUNT] = {
+{ NULL,
+  ph_window_create_display,
+  ph_window_close_display,
+  ph_window_update_display,
+  ph_window_alloc_palette,
+  ph_window_modify_pen,
+  ph_window_16bpp_capable },
+#if 1
+/*
+{ NULL,
+  ph_ovr_create_display,
+  ph_ovr_close_display,
+  ph_ovr_update_display,
+  ph_ovr_alloc_palette,
+  ph_ovr_modify_pen,
+  ph_ovr_16bpp_capable }
+*/
+#else
+  {NULL,NULL,NULL,NULL,NULL,NULL,NULL}
+#endif
+};
+
+int sysdep_init (void)
+{
+   int i;
+  
+   // attach to default photon server 
+   if(!(ph_ctx= PhAttach (NULL,NULL)))
+   {
+      /* Don't use stderr_file here it isn't assigned a value yet ! */
+      fprintf (stderr, "error: could not open display\n");
+      return OSD_NOT_OK;
+   }
+  
+   // Initialize the Widget Library
+   PtInit(NULL);  
+   
+   for (i=0;i<PH_MODE_COUNT;i++)
+   {
+      if(ph_func[i].create_display)
+         mode_available[i] = TRUE;
+      else
+         mode_available[i] = FALSE;
+      
+      if(ph_func[i].init && (*ph_func[i].init)() != OSD_OK)
+         return OSD_NOT_OK;
+   }
+   
+   return OSD_OK;
+}
+
+void sysdep_close(void)
+{
+   if(ph_ctx)
+      PhDetach(ph_ctx);
+}
+
+int sysdep_display_16bpp_capable(void)
+{
+   if (ph_video_mode >= PH_MODE_COUNT)
+   {
+      fprintf (stderr_file,
+         "info: photon-mode %d does not exist, falling back to normal window code\n",
+         ph_video_mode);
+      ph_video_mode = PH_WINDOW;
+   }
+
+   if (!mode_available[ph_video_mode])
+   {
+      fprintf (stderr_file,
+         "info: photon-mode %d not available, falling back to normal window code\n",
+         ph_video_mode);
+      ph_video_mode = PH_WINDOW;
+   }
+
+   return (*ph_func[ph_video_mode]._16bpp_capable) ();
+}
+
+/* This name doesn't really cover this function, since it also sets up mouse
+   and keyboard. This is done over here, since on most display targets the
+   mouse and keyboard can't be setup before the display has. */
+int sysdep_create_display (int depth)
+{
+   /* first setup the keyboard that's the same for all X video modes */
+//   local_key=phkey;
+   memset((void *)&phkey[0], FALSE, 128*sizeof(unsigned char) );
+  
+
+   return (*ph_func[ph_video_mode].create_display)(depth);
+}
+
+void sysdep_display_close (void)
+{
+   (*ph_func[ph_video_mode].close_display)();
+   /* free the bitmap after cleaning the dirty stuff as it uses the bitmap */
+   //osd_free_bitmap (bitmap);
+}
+
+int ph_init_palette_info(void)
+{
+   memset(&display_palette_info, 0, sizeof(struct sysdep_palette_info));
+#if 1   
+	switch (depth)
+	{
+		case 16 :
+			display_palette_info.red_mask = 0xF800;
+			display_palette_info.green_mask = 0x07E0;
+			display_palette_info.blue_mask = 0x001F;
+			break;
+		case 24 :
+		case 32	:
+			display_palette_info.red_mask = 0xFF0000;
+			display_palette_info.green_mask = 0x00FF00;
+			display_palette_info.blue_mask = 0x0000FF;
+			break;
+		return -1;	
+	}
+	display_palette_info.depth=depth;
+#endif
+   return OSD_OK;
+}
+
+int sysdep_display_alloc_palette (int writable_colors)
+{
+   return (*ph_func[ph_video_mode].alloc_palette) (writable_colors);
+}
+
+int sysdep_display_set_pen (int pen, unsigned char red, unsigned char green,
+   unsigned char blue)
+{
+   return (*ph_func[ph_video_mode].modify_pen) (pen, red, green, blue);
+}
+
+void sysdep_update_display (struct mame_bitmap *bitmap)
+{
+   extern unsigned short *shrinked_pens;
+   int new_video_mode = ph_video_mode;
+   
+   int bitmap_depth = bitmap->depth;
+
+   if (keyboard_pressed (KEYCODE_LALT))
+   { 
+      if (keyboard_pressed_memory (KEYCODE_INSERT))
+         new_video_mode = PH_WINDOW;
+         /*
+      if (keyboard_pressed_memory (KEYCODE_HOME))
+         new_video_mode = PH_OVR;
+         */
+   }
+
+   if (new_video_mode != ph_video_mode && mode_available[new_video_mode])
+   {
+      (*ph_func[ph_video_mode].close_display)();
+      if ((*ph_func[new_video_mode].create_display)(bitmap_depth) != OSD_OK)
+      {
+         fprintf(stderr_file,
+            "warning: could not create display for new photon-mode\n"
+            "   Trying again with the old photon-mode\n");
+         (*ph_func[new_video_mode].close_display)();
+         if ((*ph_func[ph_video_mode].create_display)(bitmap_depth) != OSD_OK)
+            goto barf;
+         {
+            sysdep_display_close();   /* This cleans up and must be called to
+                                      restore the videomode with dga */
+            osd_exit();
+            sysdep_close();
+            fprintf (stderr_file,
+               "error: could not create new photon display while switching display modes\n");
+            exit (1);              /* ugly, anyone know a better way ? */
+         }
+      }
+      else
+         ph_video_mode = new_video_mode;
+
+      if(sysdep_palette_change_display(&current_palette))
+         goto barf;
+      
+      memset((void *)&phkey[0], FALSE, 128*sizeof(unsigned char) );
+      /* poll mouse twice to clear internal vars */
+      if (use_mouse)
+      {
+         sysdep_mouse_poll ();
+         sysdep_mouse_poll ();
+      }
+   }
+
+   (*ph_func[ph_video_mode].update_display) (bitmap);
+   return;
+   
+barf:   
+   sysdep_display_close();   /* This cleans up and must be called to
+                             restore the videomode with dga */
+   osd_exit();
+   sysdep_close();
+   fprintf (stderr_file,
+      "error: could not create new display while switching display modes\n");
+   exit (1);              /* ugly, anyone know a better way ? */
+}
+
+/* these aren't nescesarry under photon since we have both a graphics window and
+   a textwindow (pterm) */
+int sysdep_set_video_mode (void)
+{
+   return OSD_OK;
+}
+
+void sysdep_set_text_mode (void)
+{
+
+}
diff --git a/src/unix/video-drivers/photon2.h b/src/unix/video-drivers/photon2.h
new file mode 100644
index 0000000..0baeaf5
--- /dev/null
+++ b/src/unix/video-drivers/photon2.h
@@ -0,0 +1,128 @@
+/* MAME Photon 2 Header
+ *
+ * Writen By: Travis Coady
+ * Origional Code By: David Rempel
+ *
+ * web: http://www.classicgaming.com/phmame/
+ * e-mail: smallfri@bigfoot.com
+ *
+ * Copyright (C) 2000-2001, The PhMAME Developement Team.
+*/
+
+/* There is wayyyy... to much X11 crap left
+   over here, remove later */
+
+#ifndef __MAME_PHOTON_H_
+#define __MAME_PHOTON_H_
+
+#include <Ph.h>
+#include <Pt.h>
+#include "effect.h"
+
+/* Commented... */
+enum { PH_WINDOW, PH_OVR };
+#define PH_MODE_COUNT 2
+
+#ifdef __PH_C__
+#define EXTERN
+#else
+#define EXTERN extern
+#endif
+
+EXTERN int 		ph_video_mode;
+EXTERN int 		mode_available[PH_MODE_COUNT];
+EXTERN int 		ph_grab_mouse;
+EXTERN int 		depth;
+EXTERN int		show_cursor;
+EXTERN unsigned char    *scaled_buffer_ptr;
+EXTERN PtWidget_t	*P_mainWindow;
+EXTERN struct _Ph_ctrl  *ph_ctx;
+extern struct rc_option ph_window_opts[];
+extern struct rc_option ph_ovr_opts[];
+extern struct rc_option ph_input_opts[];
+EXTERN char		phkey[128];
+
+
+#if 0
+
+EXTERN Display 		*display;
+EXTERN Window		window;
+EXTERN char	 	xkey[128];
+EXTERN Screen 		*screen;
+EXTERN Colormap		colormap;
+EXTERN Visual		*xvisual;
+EXTERN int		depth;
+EXTERN unsigned char	*scaled_buffer_ptr;
+EXTERN int		mode_available[X11_MODE_COUNT];
+EXTERN Cursor		normal_cursor;
+EXTERN Cursor		invisible_cursor;
+EXTERN int		x11_video_mode;
+EXTERN int		x11_grab_mouse;
+EXTERN int		run_in_root_window;
+EXTERN int		show_cursor;
+EXTERN int		use_private_cmap;
+EXTERN int		use_xil;
+EXTERN int		use_mt_xil;
+extern struct rc_option xf86_dga_opts[];
+extern struct rc_option x11_window_opts[];
+extern struct rc_option	x11_input_opts[];
+
+#if defined x11 && defined USE_DGA
+EXTERN int		xf86_dga_fix_viewport;
+EXTERN int		xf86_dga_first_click;
+#endif
+
+#ifdef X11_JOYSTICK
+EXTERN int devicebuttonpress;
+EXTERN int devicebuttonrelease;
+EXTERN int devicemotionnotify;
+EXTERN int devicebuttonmotion;
+#endif
+
+/*** prototypes ***/
+
+/* device related */
+void process_x11_joy_event(XEvent *event);
+#endif
+
+
+/* Normal photon window functions */
+int  ph_window_create_display(int depth);
+void ph_window_close_display(void);
+int  ph_window_modify_pen(int pen, unsigned char red,unsigned char green,unsigned char blue);
+void ph_window_update_display(struct mame_bitmap *bitmap);
+int  ph_window_alloc_palette(int writable_colors);
+void ph_window_refresh_screen(void);
+int  ph_window_16bpp_capable(void);
+
+/* photon video overlay functions */
+int  ph_ovr_init(void);
+int  ph_ovr_create_display(int depth);
+void ph_ovr_close_display(void);
+int  ph_ovr_modify_pen(int pen, unsigned char red,unsigned char green,unsigned char blue);
+void ph_ovr_update_display(struct mame_bitmap *bitmap);
+int  ph_ovr_alloc_palette(int writable_colors);
+int  ph_ovr_16bpp_capable(void);
+
+#if 0
+/* XIL functions */
+#ifdef USE_XIL
+void init_xil( void );
+void setup_xil_images( int, int );
+void refresh_xil_screen( void );
+#endif
+
+/* DBE functions */
+#ifdef USE_DBE
+void setup_dbe( void );
+void swap_dbe_buffers( void );
+#endif
+
+/* generic helper functions */
+int x11_init_palette_info(void);
+#endif
+
+/* generic helper functions */
+int ph_init_palette_info(void);
+
+#endif /* ifndef __MAME_PHOTON_H */
diff --git a/src/unix/video-drivers/photon2_input.c b/src/unix/video-drivers/photon2_input.c
new file mode 100644
index 0000000..5be653e
--- /dev/null
+++ b/src/unix/video-drivers/photon2_input.c
@@ -0,0 +1,280 @@
+/* MAME Photon 2 (Neutrino) Input Code
+ *
+ * Writen By: Travis Coady
+ * Origional Code By: David Rempel
+ *
+ * web: http://www.classicgaming.com/phmame/
+ * e-mail: smallfri@bigfoot.com
+ *
+ * Copyright (C) 2000-2001, The PhMAME Developement Team.
+*/
+
+#include <Ph.h>
+#include <Pt.h>
+#include "xmame.h"
+#include "devices.h"
+#include "photon2.h"
+#include "phkeyboard.h"
+
+int current_mouse[MOUSE_AXIS] = {0,0,0,0,0,0,0,0};
+int update_mouse=FALSE;
+
+static int ph_use_winkeys = 0;
+
+static int ph_mapkey(struct rc_option *option, const char *arg, int priority);
+
+struct rc_option ph_input_opts[] = {
+   /* name, shortname, type, dest, deflt, min, max, func, help */
+   { "Photon-input related", NULL,		rc_seperator,	NULL,
+     NULL,		0,			0,		NULL,
+     NULL },
+   { "grabmouse",	"nograbmouse",		rc_bool,	&ph_grab_mouse,
+     "0",		0,			0,		NULL,
+     "Enable/disable mousegrabbing (also alt + pagedown)" },
+   { "winkeys",		"nowinkeys",		rc_bool,	&ph_use_winkeys,
+     "0",		0,			0,		NULL,
+     "Enable/disable mapping of windowskeys under Photon" },
+   { "mapkey",		NULL,			rc_use_function, NULL,
+     NULL,		0,			0,		ph_mapkey,
+     "Set a specific key mapping, see phmamerc.dist" },
+   { NULL,		NULL,			rc_end,		NULL,
+     NULL,		0,			0,		NULL,
+     NULL }
+};
+
+/*
+ * Parse keyboard events
+ */
+
+#define EVENT_SIZE      sizeof(PhEvent_t) + 1000
+unsigned char cevent[EVENT_SIZE];
+
+void sysdep_update_keyboard (void)
+{
+	PhEvent_t *event=&cevent;
+
+	while ( PhEventPeek (event,EVENT_SIZE) == Ph_EVENT_MSG)
+	{
+		PtEventHandler(event);
+	}
+	
+
+// This is where the photon event handling code goes
+	  
+#if 0
+  XEvent 		E;
+  int	 		keycode,code;
+  int			mask;
+  int 			*pt;
+  static int		old_grab_mouse = FALSE;
+  /* grrr some windowmanagers send multiple focus events, this is used to
+     filter them. */
+  static int            focus = FALSE;
+  
+  /* handle winkey mappings */
+  if (x11_use_winkeys)
+  {
+    extended_code_table[XK_Meta_L&0x1FF] = KEY_LWIN; 
+    extended_code_table[XK_Meta_R&0x1FF] = KEY_RWIN; 
+  }
+
+#ifdef x11
+  if(run_in_root_window && x11_video_mode == X11_WINDOW)
+  {
+     static int i=0;
+     i = ++i % 3;
+     switch (i)
+     {
+        case 0:
+           xkey[KEY_O] = 0;
+           xkey[KEY_K] = 0;
+           break;
+        case 1:
+           xkey[KEY_O] = 1;
+           xkey[KEY_K] = 0;
+           break;
+        case 2:
+           xkey[KEY_O] = 0;
+           xkey[KEY_K] = 1;
+           break;
+     }
+  }
+  else
+#endif
+
+  /* query all events that we have previously requested */
+  while ( XPending(display) )
+  {
+    mask = FALSE;
+    
+    XNextEvent(display,&E);
+/*  fprintf(stderr_file,"Event: %d\n",E.type); */
+
+    /* we don't have to check x11_video_mode or extensions like xil here,
+       since our eventmask should make sure that we only get the event's matching
+       the current update method */
+    switch (E.type)
+    {
+      /* display events */
+#ifdef x11
+      case Expose:
+  	if ( E.xexpose.count == 0 ) x11_window_refresh_screen();
+	break;
+#endif
+      case FocusIn:
+        /* check for multiple events and ignore them */
+        if (focus) break;
+        focus = TRUE;
+	/* to avoid some meta-keys to get locked when wm iconify xmame, we must
+	perform a key reset whenever we retrieve keyboard focus */
+	memset((void *)&xkey[0], FALSE, 128*sizeof(unsigned char) );
+	if (old_grab_mouse)
+	{
+            if (!XGrabPointer(display, window, True, 0, GrabModeAsync,
+                GrabModeAsync, window, None, CurrentTime))
+            {
+                if (show_cursor) XDefineCursor(display,window,invisible_cursor);
+                x11_grab_mouse = TRUE;
+            }
+	}
+	break;
+      case FocusOut:
+        /* check for multiple events and ignore them */
+        if (!focus) break;
+        focus = FALSE;
+        old_grab_mouse = x11_grab_mouse;
+        if (x11_grab_mouse)
+        {
+            XUngrabPointer(display, CurrentTime);
+            if (show_cursor) XDefineCursor(display,window,normal_cursor);
+            x11_grab_mouse = FALSE;
+        }
+        break;
+      case EnterNotify:
+	if (use_private_cmap) XInstallColormap(display,colormap);
+	break;	
+      case LeaveNotify:
+	if (use_private_cmap) XInstallColormap(display,DefaultColormapOfScreen(screen));
+	break;	
+#ifdef USE_XIL
+      case ConfigureNotify:
+	update_xil_window_size( E.xconfigure.width, E.xconfigure.height );
+	break;
+#endif
+      /* input events */    
+      case MotionNotify:
+        current_mouse[0] += E.xmotion.x_root;
+        current_mouse[1] += E.xmotion.y_root;
+        break;
+      case ButtonPress:
+        mask = TRUE;
+#ifdef USE_DGA
+        /* Some buggy combination of XFree and virge screwup the viewport
+           on the first mouseclick */
+        if(xf86_dga_first_click) { xf86_dga_first_click = 0; xf86_dga_fix_viewport = 1; }
+#endif          
+      case ButtonRelease:
+        mouse_data[0].buttons[E.xbutton.button-1] = mask;
+        break;
+      case KeyPress:
+        mask = TRUE;
+      case KeyRelease:
+	keycode = XLookupKeysym ((XKeyEvent *) &E, 0);
+	/* fprintf(stderr, "Keyevent key:%04X\n", keycode); */
+	/* look which table should be used */
+	pt=code_table;
+        if ( (keycode & 0xfe00) == 0xfe00 )
+        {
+          pt=extended_code_table;
+	  code=keycode&0x01ff;
+	}
+	else
+	  code=keycode&0x00ff;
+	/* if unnasigned key ignore it */
+	if ( *(pt+code) ) xkey [ *(pt+code) ] = mask;
+	break;
+#ifdef X11_JOYSTICK
+      /* grrr we can't use case here since the event types for XInput devices
+         aren't hardcoded, since we should have caught anything else above,
+         just asume it's an XInput event */
+      default:
+	  process_x11_joy_event(&E);
+	  break;
+#endif
+    } /* switch */
+  } /* while */
+#endif
+}
+
+/*
+ *  keyboard remapping routine
+ *  invoiced in startup code
+ *  returns 0-> success 1-> invalid from or to
+ */
+static int ph_mapkey(struct rc_option *option, const char *arg, int priority)
+{
+   int from,to;
+   /* ultrix sscanf() requires explicit leading of 0x for hex numbers */
+   if ( sscanf(arg,"0x%x,0x%x",&from,&to) == 2)
+   {
+      /* perform tests */
+      /* fprintf(stderr_file,"trying to map %x to%x\n",from,to); */
+      if ( (to>=0) || (to<=127) )
+      {
+         if ( (from>=0) && (from<=0x00ff) ) 
+         {
+            code_table[from]=to; return OSD_OK;
+         }
+         if ( (from>=0xfe00) && (from<=0xffff) ) 
+         {
+            extended_code_table[from&0x01ff]=to; return OSD_OK;
+         }
+      }
+      /* stderr_file isn't defined yet when we're called. */
+      fprintf(stderr,"Invalid keymapping %s. Ignoring...\n", arg);
+   }
+   return OSD_NOT_OK;
+}
+
+void sysdep_mouse_poll (void)
+{
+#if 1
+	int i;
+	PhCursorInfo_t buf;
+	PhPoint_t	windowpos;
+	int ig;
+
+	ig=PhInputGroup(NULL);
+	
+	if (PhQueryCursor(ig,&buf) != 0 )
+	{
+		fprintf(stderr,"error: mouse Error\n");
+		mouse_data[0].deltas[0] = 0;
+		mouse_data[0].deltas[1] = 0;
+		return;
+	}
+
+	if ( ph_grab_mouse )
+	{
+//		fprintf(stderr,"grabbing mouse\n");
+		PtGetAbsPosition(P_mainWindow,&windowpos.x, &windowpos.y);
+		PhMoveCursorAbs(ig, windowpos.x+(visual_width/2), windowpos.y+(visual_height/2));
+		mouse_data[0].deltas[0] = buf.pos.x - (windowpos.x+(visual_width/2));
+		mouse_data[0].deltas[1] = buf.pos.y - (windowpos.y+(visual_height/2));
+
+	}
+	else
+	{
+		if (update_mouse==FALSE)
+		{
+			mouse_data[0].deltas[0]=0;
+			mouse_data[0].deltas[0]=0;
+		}
+		update_mouse=FALSE;
+	}
+#endif
+}
+
+void sysdep_set_leds(int leds)
+{
+}
diff --git a/src/unix/video-drivers/photon2_overlay.c b/src/unix/video-drivers/photon2_overlay.c
new file mode 100644
index 0000000..5aff81b
--- /dev/null
+++ b/src/unix/video-drivers/photon2_overlay.c
@@ -0,0 +1,489 @@
+/* MAME Photon 2 Overlay Code
+ *
+ * Writen By: Travis Coady
+ * Origional Code By: David Rempel
+ *
+ * web: http://www.classicgaming.com/phmame/
+ * e-mail: smallfri@bigfoot.com
+ *
+ * Copyright (C) 2000-2001, The PhMAME Developement Team.
+*/
+
+/* TRAVIS'S NOTE: This needs an overhaul. */
+
+/*
+ * Include files.
+ */
+
+/* for FLT_MAX */
+#include <float.h>
+#include <Ph.h>
+#include <Pt.h>
+#include "xmame.h"
+#include "photon2.h"
+#include "driver.h"
+//#include "phkeyboard.h"
+static void ph_ovr_update_16_to_16bpp (struct mame_bitmap *bitmap);
+static void ph_ovr_update_16_to_24bpp (struct mame_bitmap *bitmap);
+static void ph_ovr_update_16_to_32bpp (struct mame_bitmap *bitmap);
+static void ph_window_update_32_to_32bpp_direct (struct mame_bitmap *bitmap);
+static void (*ph_ovr_update_display_func) (struct mame_bitmap *bitmap) = NULL;
+
+/* hmm we need these to do the clean up correctly, or we could just 
+   trust unix & X to clean up after us but lett's keep things clean */
+
+static int private_cmap_allocated = 0;
+static PdOffscreenContext_t *image = NULL;
+static int orig_widthscale, orig_heightscale;
+enum { PH_NORMAL };
+PhDim_t  view_size;
+static int ph_ovr_update_method = PH_NORMAL;
+static int startx = 0;
+static int starty = 0;
+static unsigned long black_pen;
+static int use_xsync = 0;
+static int root_window_id; /* root window id (for swallowing the mame window) */
+static char *geometry = NULL;
+static float scrnaspect,vscrnaspect;
+static float vscrntlx;
+static float vscrntly;
+static float vscrnwidth;
+static float vscrnheight;
+static float vw,vh;
+static char *pseudo_color_allocated;
+static unsigned long *pseudo_color_lookup;
+static int pseudo_color_lookup_dirty;
+static int pseudo_color_use_rw_palette;
+static int pseudo_color_warn_low_on_colors;
+
+static PgVideoChannel_t *channel;
+static PgScalerCaps_t   caps;
+static PgScalerProps_t  props;
+
+static unsigned char   *ybuf0, *ybuf1;
+static unsigned char   *ubuf0, *ubuf1;
+static unsigned char   *vbuf0, *vbuf1;
+
+static int swidth ;
+static int sheight;
+static int dwidth ;
+static int dheight;
+
+static int overlay_on=0;
+
+extern int I_GetEvent(PtWidget_t *widget, void *data, PtCallbackInfo_t *cbinfo );
+
+extern int phovr_filteron;
+
+int ph_ovr_16bpp_capable(void)
+{
+	return 1;
+}
+
+/* I've commented out the fprintf's in this function.
+   It'll keep the compiler quiet. I'm not exacally
+   sure why there even here (debuggin?), but the Raw
+   Drawing & Animation Chapter in the docs gives me a
+   good idea <evil grin at dave>. */
+void grab_ptrs(PgVideoChannel_t *channel)
+{
+	/* Buffers have moved; re-obtain the pointers */
+	ybuf0 = PdGetOffscreenContextPtr(channel->yplane1);
+	ybuf1 = PdGetOffscreenContextPtr(channel->yplane2);
+	ubuf0 = PdGetOffscreenContextPtr(channel->uplane1);
+	ubuf1 = PdGetOffscreenContextPtr(channel->uplane2);
+	vbuf0 = PdGetOffscreenContextPtr(channel->vplane1);
+	vbuf1 = PdGetOffscreenContextPtr(channel->vplane2);
+
+	if (channel->yplane1)
+		//fprintf(stderr, "Photon 2 Overlay: ybuf0: %x, stride %d\n", ybuf0, channel->yplane1->pitch);
+		printf("info: photon2 overlay: bleh.\n");
+	if (channel->uplane1)
+		//fprintf(stderr, "Photon 2 Overlay: ubuf0: %x, stride %d\n", ubuf0, channel->uplane1->pitch);
+		printf("info: photon2 overlay: bleh.\n");
+	if (channel->vplane1)
+		//fprintf(stderr, "Photon 2 Overlay: vbuf0: %x, stride %d\n", vbuf0, channel->vplane1->pitch);
+		printf("info: photon2 overlay: bleh.\n");
+	if (channel->yplane2)
+		//fprintf(stderr, "Photon 2 Overlay: ybuf1: %x, stride %d\n", ybuf1, channel->yplane2->pitch);
+		printf("info: photon2 overlay: bleh.\n");
+	if (channel->uplane2)
+		//fprintf(stderr, "Photon 2 Overlay: ubuf1: %x, stride %d\n", ubuf1, channel->uplane2->pitch);
+		printf("info: photon2 overlay: bleh.\n");
+	if (channel->vplane2)
+		//fprintf(stderr, "Photon 2 Overlay: vbuf1: %x, stride %d\n", vbuf1, channel->vplane2->pitch);
+		printf("info: photon2 overlay: bleh.\n");
+}
+
+unsigned char *setup_overlay(int src_width, int src_height, int dst_width, int dst_height, int dst_x, int dst_y )
+{
+	void    *p;
+	int i = 0;
+	int bCont;
+
+	swidth = src_width;
+	sheight = src_height;
+	dwidth = dst_width;
+	dheight = dst_height;
+
+        if ((channel = PgCreateVideoChannel(Pg_VIDEO_CHANNEL_SCALER,0)) == NULL) 
+	{
+		fprintf(stderr, "error: could not create channel!\n");
+		return 0;
+	}
+
+
+	caps.size = sizeof (caps);
+	bCont = TRUE;
+
+	/* XXX could support 888 and 555 as well */
+	while ((bCont) &&(PgGetScalerCapabilities(channel, i++, &caps) == 0))
+        {
+		if(caps.format == Pg_VIDEO_FORMAT_RGB8888)
+                {
+			printf("info: overlay supports RGB8888\n");
+			props.format = Pg_VIDEO_FORMAT_RGB8888;
+                        bCont = FALSE;
+                }
+                else if(caps.format  == Pg_VIDEO_FORMAT_RGB565)
+                {
+                        printf("info: overlay supports RGB565\n");
+                        props.format = Pg_VIDEO_FORMAT_RGB565;
+                        bCont = FALSE;
+                }
+                if(!bCont)
+                   break;
+
+                caps.size = sizeof (caps);
+        }
+
+
+        props.size = sizeof (props);
+        props.src_dim.w = swidth;
+        props.src_dim.h = sheight;
+
+        props.viewport.ul.x = dst_x;
+        props.viewport.ul.y = dst_y;
+	props.viewport.lr.x = dst_x+(dwidth-1);
+        props.viewport.lr.y = dst_y+(dheight-1);
+        props.flags = Pg_SCALER_PROP_SCALER_ENABLE | ((phovr_filteron) ? Pg_SCALER_PROP_DISABLE_FILTERING : 0);
+
+        if (PgConfigScalerChannel(channel, &props) == -1) 
+	{
+		fprintf(stderr, "error: could not configure channel!\n");
+                return 0;
+        }
+
+        grab_ptrs(channel);
+
+        overlay_on = 1;
+
+	return ybuf0;
+}
+
+/* This name doesn't really cover this function, since it also sets up mouse
+   and keyboard. This is done over here, since on most display targets the
+   mouse and keyboard can't be setup before the display has. */
+int ph_ovr_create_display (int bitmap_depth)
+{
+	PtArg_t arg[8];
+	PhRect_t rect;
+	PhRegion_t region_info;	
+	
+	// Create the Photon Window
+	view_size.w = widthscale * visual_width;
+	view_size.h = heightscale * visual_height;
+
+	PhWindowQueryVisible( Ph_QUERY_GRAPHICS, 0, 1, &rect );
+	
+	PtSetArg( &arg[0], Pt_ARG_FILL_COLOR, Pg_BLACK, 0 );
+	PtSetArg( &arg[1], Pt_ARG_WINDOW_MANAGED_FLAGS, 0, Ph_WM_MAX | Ph_WM_RESIZE | Ph_WM_MENU );
+	PtSetArg( &arg[2], Pt_ARG_DIM, &rect, 0 );
+	PtSetArg( &arg[3], Pt_ARG_WINDOW_NOTIFY_FLAGS, Ph_WM_FOCUS, Ph_WM_FOCUS | Ph_WM_RESIZE );
+	PtSetArg( &arg[4], Pt_ARG_WINDOW_RENDER_FLAGS, Pt_FALSE, ~0 );
+	PtSetArg( &arg[5], Pt_ARG_WINDOW_TITLE, title, 0 );
+	PtSetArg( &arg[6], Pt_ARG_WINDOW_STATE, Pt_TRUE, Ph_WM_STATE_ISALTKEY | Ph_WM_STATE_ISFRONT | Ph_WM_STATE_ISMAX | Ph_WM_STATE_ISFOCUS );
+	PtSetArg(&arg[7], Pt_ARG_WINDOW_MANAGED_FLAGS,Pt_TRUE, Ph_WM_FFRONT |Ph_WM_TOFRONT |Ph_WM_CONSWITCH );	
+	PtSetParentWidget(NULL);
+	if((P_mainWindow = PtCreateWidget(PtWindow, NULL, 8, arg)) == NULL)
+		fprintf(stderr,"error: could not create main photon window!\n");
+
+	/* add raw callback handler */
+	PtAddEventHandler( P_mainWindow,      Ph_EV_BUT_PRESS |
+					      Ph_EV_BUT_RELEASE |
+					      Ph_EV_BOUNDARY |
+					      Ph_EV_EXPOSE |
+					      Ph_EV_PTR_MOTION |
+					      Ph_EV_KEY, I_GetEvent, NULL );
+
+	/* set draw buffer size */
+	PgSetDrawBufferSize( 0xFF00 );
+	
+	region_info.cursor_type = Ph_CURSOR_NONE;
+        region_info.rid = PtWidgetRid(P_mainWindow);
+	
+	/* add background handler */
+	PhWindowQueryVisible( Ph_QUERY_GRAPHICS, 0, 1, &rect );
+	
+	scrnaspect=(float)view_size.w/(float)view_size.h;
+
+	vw=rect.lr.x - rect.ul.x + 1;
+	vh=rect.lr.y - rect.ul.y + 1;
+	
+	vscrnaspect=(float)(vw)/(float)(vh);
+   
+	if(scrnaspect<vscrnaspect) 
+	{
+		vscrnheight=(float)vh;
+		vscrnwidth=vscrnheight*scrnaspect;
+		vscrntlx=((float)vw-vscrnwidth)/2.0;
+		vscrntly=0.0;
+	}
+	else 
+	{
+		vscrnwidth=(float)vw;
+		vscrnheight=vscrnwidth/scrnaspect;
+		vscrntlx=0.0;
+		vscrntly=((float)vh-vscrnheight)/2.0;
+	}
+	
+	scaled_buffer_ptr=setup_overlay(view_size.w, view_size.h, 
+					     vscrnwidth, 
+					     vscrnheight, vscrntlx, vscrntly);
+	
+	if (scaled_buffer_ptr == NULL)
+		return OSD_NOT_OK;
+	
+	PtRealizeWidget( P_mainWindow );
+	PtFlush();
+	memset(&region_info,0,sizeof(region_info));
+	region_info.cursor_type = Ph_CURSOR_NONE;
+        region_info.rid = PtWidgetRid(P_mainWindow);
+	PhRegionChange (Ph_REGION_CURSOR, 0, &region_info, NULL, NULL); // turn off cursor
+ 
+	/* create and setup the image */
+	switch (ph_ovr_update_method)
+		
+	{
+		case PH_NORMAL:
+
+#if 0
+		image = PdCreateOffscreenContext(0, ((view_size.w+7) & ~7), view_size.h, Pg_OSC_MEM_PAGE_ALIGN);
+	 	if (image == NULL)
+	 	{
+			fprintf(stderr_file, "error: failed to create offscreen context\n");
+			return OSD_NOT_OK;
+		}
+
+		scaled_buffer_ptr = PdGetOffscreenContextPtr (image);
+		if (!scaled_buffer_ptr)
+		{
+			fprintf (stderr_file, "error: failed get a pointer to offscreen context.\n");
+			PhDCRelease (image);
+			return OSD_NOT_OK;
+		}
+#endif
+		depth = 0;
+
+		switch (props.format)
+		{
+			case Pg_VIDEO_FORMAT_RGB565  :
+				depth = 16;
+			break;
+			case Pg_VIDEO_FORMAT_RGB555  :
+			// TODO:
+			break;
+			case Pg_VIDEO_FORMAT_RGB8888 :
+				depth = 32;
+			break;
+		}
+		break;
+	
+		default:
+			fprintf (stderr_file, "error: unknown photon update method, this shouldn't happen\n");
+		return OSD_NOT_OK;
+	}
+
+	/* setup the palette_info struct now we have the depth */
+	if (ph_init_palette_info() != OSD_OK)
+	return OSD_NOT_OK;
+
+	fprintf(stderr_file, "info: actual bits per pixel = %d...\n", depth);
+	if (bitmap_depth == 16)
+	{
+		switch(depth)
+		{
+			case 16:
+				ph_ovr_update_display_func = ph_ovr_update_16_to_16bpp;
+			break;
+			case 24:
+				ph_ovr_update_display_func = ph_ovr_update_16_to_24bpp;
+			break;
+			case 32:
+				ph_ovr_update_display_func = ph_ovr_update_16_to_32bpp;
+			break;
+		}
+	}
+
+	if (ph_ovr_update_display_func == NULL)
+	{
+		fprintf(stderr_file, "error: unsupported\n");
+		return OSD_NOT_OK;
+	}
+
+	fprintf(stderr_file, "Ok\n");
+
+	return OSD_OK;
+}
+
+/*
+ * Shut down the display, also called by the core to clean up if any error
+ * happens when creating the display.
+ */
+/* This is insane, utterly, utterly, utterly insane. */
+int I_OverlayOff(void)
+{
+
+	//printf("I_OverlayOff\n");
+
+        if ( !overlay_on )
+                return 1;
+	props.size = sizeof (props);
+        props.src_dim.w = swidth;
+        props.src_dim.h = sheight;
+
+        props.viewport.ul.x = 0;
+	props.viewport.ul.y = 0;
+        props.viewport.lr.x = swidth;
+        props.viewport.lr.y = sheight;
+        props.flags &= ~Pg_SCALER_PROP_SCALER_ENABLE;
+        switch(PgConfigScalerChannel(channel, &props)){
+	        case -1:
+	           fprintf(stderr, "error: configure channel failed!\n");
+	           exit(1);
+                break;
+		case 1:
+			grab_ptrs(channel);
+		break;
+		case 0:
+		default:
+                break;
+        }
+
+        overlay_on = 0;
+
+}
+
+void ph_ovr_close_display (void)
+{
+	/* This is only allocated/done if we succeeded to get a window */
+	if (P_mainWindow)
+	{
+		I_OverlayOff();
+		scaled_buffer_ptr = NULL;
+	}
+ 
+	PtUnrealizeWidget(P_mainWindow);
+	P_mainWindow=NULL;
+}
+
+/*
+ * Set the screen colors using the given palette.
+ *
+ */
+int ph_ovr_alloc_palette (int writable_colors)
+{
+	return 0;
+}
+ 
+int ph_ovr_modify_pen (int pen, unsigned char red, unsigned char green, unsigned char blue)
+{
+	return 0;
+}
+
+//* invoked by main tree code to update bitmap into screen */
+void ph_ovr_update_display (struct mame_bitmap *bitmap)
+{
+   PhRegion_t region_info;	
+	
+   (*ph_ovr_update_display_func) (bitmap);
+
+   if (use_mouse &&
+       keyboard_pressed (KEYCODE_LALT) &&
+       keyboard_pressed_memory (KEYCODE_PGDN))
+   {
+      if (ph_grab_mouse)
+      {
+         region_info.cursor_type = 0;
+	 region_info.rid = PtWidgetRid(P_mainWindow);
+	 ph_grab_mouse = FALSE;
+      }
+      else
+      {
+	 region_info.cursor_type = Ph_CURSOR_NONE;
+	 region_info.rid = PtWidgetRid(P_mainWindow);      
+	 ph_grab_mouse = TRUE;
+      }
+
+      PhRegionChange (Ph_REGION_CURSOR, 0, &region_info, NULL, NULL);
+   }
+
+//   PgFlush();         /* flush buffer to server */
+}
+
+void ph_ovr_refresh_screen (void)
+{
+}
+
+INLINE void ph_ovr_put_image (int x, int y, int width, int height)
+{
+}
+
+#define DEST_WIDTH swidth
+#define DEST scaled_buffer_ptr
+#define SRC_PIXEL unsigned short
+#define PUT_IMAGE(X, Y, WIDTH, HEIGHT) ph_ovr_put_image(X, Y, WIDTH, HEIGHT);
+
+static void ph_ovr_update_16_to_16bpp (struct mame_bitmap *bitmap)
+{
+#define DEST_PIXEL unsigned short
+
+   if (current_palette->lookup)
+   {
+#include "blit.h"
+   }
+   else
+   {
+#undef  INDIRECT
+#include "blit.h"
+#define INDIRECT current_palette->lookup
+   }
+
+#undef DEST_PIXEL
+}
+
+#define DEST_PIXEL unsigned int
+
+static void ph_ovr_update_16_to_24bpp (struct mame_bitmap *bitmap)
+{
+#define PACK_BITS
+#include "blit.h"
+#undef PACK_BITS
+}
+
+static void ph_ovr_update_16_to_32bpp (struct mame_bitmap *bitmap)
+{
+#include "blit.h"
+}
+
+#undef  INDIRECT
+#undef  SRC_PIXEL
+#define SRC_PIXEL unsigned int
+
+static void ph_window_update_32_to_32bpp_direct(struct mame_bitmap *bitmap)
+{
+#include "blit.h"
+}
+
+#undef  DEST_PIXEL
+#undef SRC_PIXEL
diff --git a/src/unix/video-drivers/photon2_window.c b/src/unix/video-drivers/photon2_window.c
new file mode 100644
index 0000000..515481d
--- /dev/null
+++ b/src/unix/video-drivers/photon2_window.c
@@ -0,0 +1,739 @@
+/* MAME Photon 2 Window Code
+ *
+ * Writen By: Travis Coady
+ * Origional Code By: David Rempel
+ *
+ * web: http://www.classicgaming.com/phmame/
+ * e-mail: smallfri@bigfoot.com
+ *
+ * Copyright (C) 2000-2001, The PhMAME Developement Team.
+*/
+
+#ifdef photon2
+#define __PH_WINDOW_C_
+
+/* TODO: - Remove some unwanted code...
+		 - Add anything that needs adding...
+		 - Make the remaing code better.
+*/
+
+/*
+ * Include files.
+ */
+
+/* for FLT_MAX */
+#include <float.h>
+#include <Ph.h>
+#include <Pt.h>
+#include "xmame.h"
+#include "photon2.h"
+#include "driver.h"
+#include "phkeyboard.h"
+#include "devices.h"
+
+static void ph_window_update_16_to_16bpp (struct mame_bitmap *bitmap);
+static void ph_window_update_16_to_24bpp (struct mame_bitmap *bitmap);
+static void ph_window_update_16_to_32bpp (struct mame_bitmap *bitmap);
+static void ph_window_update_32_to_32bpp_direct (struct mame_bitmap *bitmap);
+static void (*ph_window_update_display_func) (struct mame_bitmap *bitmap) = NULL;
+
+/* hmm we need these to do the clean up correctly, or we could just 
+   trust unix & X to clean up after us but lett's keep things clean */
+
+static int private_cmap_allocated = 0;
+static PdOffscreenContext_t *image = NULL;
+static int orig_widthscale, orig_heightscale;
+enum { PH_NORMAL };
+static int image_width;
+PhDim_t  view_size;
+static int ph_window_update_method = PH_NORMAL;
+static int startx = 0;
+static int starty = 0;
+static unsigned long black_pen;
+static int use_xsync = 0;
+static int root_window_id; /* root window id (for swallowing the mame window) */
+static char *geometry = NULL;
+
+static char *pseudo_color_allocated;
+static unsigned long *pseudo_color_lookup;
+static int pseudo_color_lookup_dirty;
+static int pseudo_color_use_rw_palette;
+static int pseudo_color_warn_low_on_colors;
+
+static int pixels_per_line;
+
+int phovr_fullscreen,phovr_filteron;
+extern int update_mouse;
+
+struct ph_func_struct {
+   int  (*init)(void);
+   int  (*create_display)(int depth);
+   void (*close_display)(void);
+   void (*update_display)(struct mame_bitmap *bitmap);
+   int  (*alloc_palette)(int writable_colors);
+   int  (*modify_pen)(int pen, unsigned char red, unsigned char green, unsigned char blue);
+   int  (*_16bpp_capable)(void);
+};
+
+extern struct ph_func_struct ph_func[];
+extern int current_mouse[MOUSE_AXIS] ;
+struct rc_option ph_window_opts[] = {
+   /* name, shortname, type, dest, deflt, min, max, func, help */
+   { "Photon-window Related", NULL,		rc_seperator,	NULL,
+     NULL,		0,			0,		NULL,
+     NULL },
+   { "cursor",		"nocursor",		rc_bool,       &show_cursor,
+     "1",		0,			0,		NULL,
+     "Show / don't show the cursor." },
+   { NULL,		NULL,			rc_end,		NULL,
+     NULL,		0,			0,		NULL,
+     NULL }
+};
+
+struct rc_option ph_ovr_opts[] = {
+
+{ "Photon-overlay Related", NULL,	rc_seperator,	NULL,
+  NULL,	0,	0,	NULL,
+  NULL },
+{ "fullscreen",	"window",	rc_bool,	&phovr_fullscreen,
+  "1",		0,	0,	NULL,
+  "Full Screen/Windowed"},
+/*
+{ "filteroff",	"filteron", rc_bool,	&phovr_filteron,
+  "1",		0,	0,	NULL,
+  "Filtering of scaled image on/off (if available)"},
+*/
+
+{NULL, NULL, rc_end, NULL, NULL, 0, 0, NULL, NULL}
+	
+};
+/*
+ * Create a display screen, or window, large enough to accomodate a bitmap
+ * of the given dimensions.
+ */
+int I_GetEvent(PtWidget_t *widget, void *data, PtCallbackInfo_t *cbinfo, int bitmap_depth )
+{
+	int mask=FALSE;
+	int kdosomething=FALSE;
+	PhKeyEvent_t *kevent;
+	PhPointerEvent_t *pevent;	
+	int                         keycode,code;
+	int                         *pt;
+	struct xmame_keyboard_event mame_key_event;
+	char                        keyname[16+1];
+	
+   	mame_key_event.press = FALSE;
+   
+	switch (cbinfo->event->type)
+	{
+		case Ph_EV_KEY:
+		{
+			kevent = PhGetData (cbinfo->event);
+			if (PkIsFirstDown (kevent->key_flags))
+			{
+              	mask=TRUE;
+				mame_key_event.press=TRUE;
+				kdosomething = TRUE;
+			}
+			else if (!PkIsKeyDown(kevent->key_flags))
+				kdosomething = TRUE;
+
+				
+        	if (kdosomething)
+			{
+				if (kevent->key_flags & Pk_KF_Cap_Valid)
+					keycode = kevent->key_cap;
+				else 
+					goto getevent_done;		
+
+				if ((keycode & 0xF000) == 0xF000)
+				{
+					pt=extended_code_table;
+					keycode &= 0x00FF;
+				}
+				else
+				{
+					pt=code_table;
+				}
+				
+		 		mame_key_event.scancode = *(pt+keycode);
+				if (PhKeyToMb (keyname, kevent) == -1)
+				{
+					keyname[0]=0;
+				}
+				mame_key_event.unicode = keyname[0];
+				//phkey [ *(pt+keycode) ] = mask;
+				xmame_keyboard_register_event(&mame_key_event); }		
+			break;
+		}
+		case Ph_EV_BUT_PRESS:
+			pevent = PhGetData( cbinfo->event );
+			
+			if (pevent->buttons & Ph_BUTTON_SELECT)
+			{
+				mouse_data[0].buttons[0] = TRUE;
+			}
+			if (pevent->buttons & Ph_BUTTON_MENU)
+			{
+				mouse_data[0].buttons[1] = TRUE;
+			}	
+			if (pevent->buttons & Ph_BUTTON_ADJUST)
+			{
+				mouse_data[0].buttons[2] = TRUE;
+			}
+		break;
+		case Ph_EV_BUT_RELEASE:
+			
+			if( cbinfo->event->subtype != Ph_EV_RELEASE_REAL )
+				break;
+
+			pevent = PhGetData( cbinfo->event );
+			
+			if (pevent->buttons & Ph_BUTTON_SELECT)
+			{
+				mouse_data[0].buttons[0] = FALSE;
+			}
+			if (pevent->buttons & Ph_BUTTON_MENU)
+			{
+				mouse_data[0].buttons[1] = FALSE;
+			}	
+			if (pevent->buttons & Ph_BUTTON_ADJUST)
+			{
+				mouse_data[0].buttons[2] = FALSE;
+			}
+		break;
+
+		case Ph_EV_PTR_MOTION_NOBUTTON:
+		case Ph_EV_PTR_MOTION_BUTTON:
+			if (ph_grab_mouse == FALSE)
+			{
+				pevent = PhGetData( cbinfo->event );
+				update_mouse=TRUE;
+				mouse_data[0].deltas[0] = pevent->pos.x-current_mouse[0];
+				mouse_data[0].deltas[1] = pevent->pos.y-current_mouse[1];
+        		current_mouse[0] = pevent->pos.x;
+        		current_mouse[1] = pevent->pos.y;
+			}
+	 	break;
+		case Ph_EV_EXPOSE:
+			if (ph_video_mode==0)
+			{
+				ph_window_refresh_screen();
+				PgFlush();
+			}
+
+		break;
+		case Ph_EV_INFO:
+		{
+			switch (cbinfo->event->subtype)
+			{
+				case Ph_OFFSCREEN_INVALID :
+				fprintf (stderr,"info: got offscreen invalid\n");
+				if (image != NULL)
+				{
+					fprintf(stderr,"info: creating new image\n");
+					PhDCRelease(image);
+					image = PdCreateOffscreenContext(0, view_size.w, view_size.h, Pg_OSC_MEM_PAGE_ALIGN);
+					if (image == NULL)
+					{
+						fprintf(stderr_file, "error: failed to create offscreen context\n");
+						exit(1);
+					}
+
+					scaled_buffer_ptr = PdGetOffscreenContextPtr (image);
+					if (!scaled_buffer_ptr)
+					{
+						fprintf (stderr_file, "error: failed get a pointer to offscreen context.\n");
+						PhDCRelease (image);
+						exit(1);
+					}
+	
+					depth = 0;
+
+					switch (image->format)
+					{
+						case Pg_IMAGE_PALETTE_BYTE   :
+						// TODO :
+						break;
+						case Pg_IMAGE_DIRECT_565  :
+						depth = 16;
+						pixels_per_line = image->pitch >> 1;
+						break;
+						case Pg_IMAGE_DIRECT_555  :
+						// TODO:
+						break;
+						case Pg_IMAGE_DIRECT_888  :
+						depth = 24;
+						pixels_per_line = image->pitch / 3;
+						break;	
+						case Pg_IMAGE_DIRECT_8888 :
+						depth = 32;
+						pixels_per_line = image->pitch >> 2;
+						break;
+					}
+					ph_init_palette_info();
+					ph_window_update_display_func=NULL;
+					if (bitmap_depth == 16)
+					{
+						switch(depth)
+						{
+							case 16:
+								ph_window_update_display_func = ph_window_update_16_to_16bpp;
+							break;
+							case 24:
+								ph_window_update_display_func = ph_window_update_16_to_24bpp;
+							break;
+							case 32:
+								ph_window_update_display_func = ph_window_update_16_to_32bpp;
+							break;
+						}
+					}
+
+					if (ph_window_update_display_func == NULL)
+					{
+						fprintf(stderr_file, "error: Unsupported\n");
+						exit(1);
+					}
+				}
+				break;
+				
+			}
+		} 
+		break;
+	}
+
+getevent_done:
+	return (Pt_CONTINUE);
+															
+}
+
+int ph_window_16bpp_capable(void)
+{
+   return 1;
+}
+
+int ph_window_create_display (int bitmap_depth)
+{
+	PtArg_t arg[9];
+	PhRect_t rect;
+    PhRegion_t region_info;
+    
+    // Only image_height??!!
+    int image_height;
+    int window_width, window_height;
+
+	// Create the Photon Window
+
+	view_size.w = widthscale * visual_width;
+	view_size.h = heightscale * visual_height;
+	
+    image_width      = widthscale  * visual_width;
+    image_height     = heightscale * visual_height;
+    
+    // TODO: Finish always ontop (Make phearbear happy)
+	PtSetArg( &arg[0], Pt_ARG_FILL_COLOR, Pg_TRANSPARENT, 0 );
+	PtSetArg( &arg[1], Pt_ARG_WINDOW_MANAGED_FLAGS, 0, Ph_WM_MAX | Ph_WM_RESIZE | Ph_WM_MENU | Ph_WM_CLOSE | Ph_WM_HIDE );
+	PtSetArg( &arg[2], Pt_ARG_DIM, &view_size, 0 );
+	PtSetArg( &arg[3], Pt_ARG_WINDOW_NOTIFY_FLAGS, Ph_WM_FOCUS, Ph_WM_FOCUS | Ph_WM_RESIZE | Ph_WM_CLOSE );
+	PtSetArg( &arg[4], Pt_ARG_WINDOW_RENDER_FLAGS, Pt_FALSE, Ph_WM_RENDER_MENU | Ph_WM_RENDER_CLOSE | Ph_WM_RENDER_MAX | Ph_WM_RENDER_MIN | Ph_WM_RENDER_COLLAPSE | Ph_WM_RENDER_RESIZE );
+	PtSetArg( &arg[5], Pt_ARG_WINDOW_TITLE, title, 0);
+	//PtSetArg( &arg[6], Pt_ARG_WINDOW_STATE, 0, Ph_WM_STATE_ISFRONT );
+	
+	PtSetParentWidget(NULL);
+	if((P_mainWindow = PtCreateWidget(PtWindow, NULL, 6, arg)) == NULL)
+		fprintf(stderr,"error: could not create main photon window.\n");
+
+	/* add raw callback handler */
+	PtAddEventHandler( P_mainWindow,
+		Ph_EV_BUT_PRESS |
+		Ph_EV_BUT_RELEASE |
+		Ph_EV_BOUNDARY |
+		Ph_EV_EXPOSE |
+		Ph_EV_PTR_MOTION |
+		Ph_EV_KEY |
+		Ph_EV_INFO,
+		I_GetEvent,
+		NULL );
+
+	/* set draw buffer size */
+	PgSetDrawBufferSize( 0xFF00 );
+
+	PtRealizeWidget( P_mainWindow );
+
+	if (show_cursor == FALSE)
+	{
+    	region_info.cursor_type = Ph_CURSOR_NONE;
+    	region_info.rid = PtWidgetRid(P_mainWindow);
+    	PhRegionChange (Ph_REGION_CURSOR, 0, &region_info, NULL, NULL); // turn off cursor
+	}
+
+
+	/* create and setup the image */
+	switch (ph_window_update_method)
+	{
+		case PH_NORMAL:
+
+//		image = PdCreateOffscreenContext(0, ((view_size.w+7) & ~7), view_size.h, Pg_OSC_MEM_PAGE_ALIGN);
+		image = PdCreateOffscreenContext(0, view_size.w, view_size.h, Pg_OSC_MEM_PAGE_ALIGN);
+	 	if (image == NULL)
+	 	{
+			fprintf(stderr_file, "error: failed to create offscreen context\n");
+			return OSD_NOT_OK;
+		}
+
+		scaled_buffer_ptr = PdGetOffscreenContextPtr (image);
+		if (!scaled_buffer_ptr)
+		{
+			fprintf (stderr_file, "error: failed get a pointer to offscreen context.\n");
+			PhDCRelease (image);
+			return OSD_NOT_OK;
+		}
+
+		depth = 0;
+
+		switch (image->format)
+		{
+			case Pg_IMAGE_PALETTE_BYTE   :
+			// TODO :
+			break;
+			case Pg_IMAGE_DIRECT_565  :
+				depth = 16;
+				pixels_per_line = image->pitch >> 1;
+			break;
+			case Pg_IMAGE_DIRECT_555  :
+			// TODO:
+			break;
+			case Pg_IMAGE_DIRECT_888  :
+				depth = 24;
+				pixels_per_line = image->pitch / 3;
+			break;	
+			case Pg_IMAGE_DIRECT_8888 :
+				depth = 32;
+				pixels_per_line = image->pitch >> 2;
+			break;
+		}
+		break;
+	
+		default:
+			fprintf (stderr_file, "error: unknown photon update method, this shouldn't happen\n");
+		return OSD_NOT_OK;
+	}
+
+	/* setup the palette_info struct now we have the depth */
+	if (ph_init_palette_info() != OSD_OK)
+	return OSD_NOT_OK;
+
+	fprintf(stderr_file, "Actual bits per pixel = %d...\n", depth);
+    if (bitmap_depth == 32)
+   {
+      if (depth == 32)
+         ph_window_update_display_func = ph_window_update_32_to_32bpp_direct;
+   }
+	else if (bitmap_depth == 16)
+	{
+		switch(depth)
+		{
+			case 16:
+				ph_window_update_display_func = ph_window_update_16_to_16bpp;
+			break;
+			case 24:
+				ph_window_update_display_func = ph_window_update_16_to_24bpp;
+			break;
+			case 32:
+				ph_window_update_display_func = ph_window_update_16_to_32bpp;
+			break;
+		}
+	}
+
+	if (ph_window_update_display_func == NULL)
+	{
+		fprintf(stderr_file, "error: unsupported\n");
+		return OSD_NOT_OK;
+	}
+
+	fprintf(stderr_file, "Ok\n");
+
+	return OSD_OK;
+}
+
+void ph_window_close_display (void)
+{
+   /* FIXME: free cursors */
+   int i;
+
+   widthscale  = orig_widthscale;
+   heightscale = orig_heightscale;
+  
+   /* This is only allocated/done if we succeeded to get a window */
+   if (P_mainWindow)
+   {
+     if (image)
+      {
+         PhDCRelease (image);
+         scaled_buffer_ptr = NULL;
+	 image=NULL;
+      }
+  
+      PtUnrealizeWidget(P_mainWindow);
+      P_mainWindow=NULL;
+   }
+}
+
+
+int ph_window_alloc_palette (int writable_colors)
+{
+#if 0
+   int i;
+   
+   if(!(pseudo_color_lookup = malloc(writable_colors * sizeof(unsigned long))))
+   {
+      fprintf(stderr_file, "error: malloc failed for pseudo color lookup table\n");
+      return -1;
+   }
+   
+   /* set the palette to black */
+   for (i = 0; i < writable_colors; i++)
+      pseudo_color_lookup[i] = black_pen;
+
+   /* allocate color cells */
+   if (XAllocColorCells (display, colormap, 0, 0, 0, pseudo_color_lookup,
+      writable_colors))
+   {
+      pseudo_color_use_rw_palette = 1;
+      fprintf (stderr_file, "info: using r/w palette entries to speed up, good\n");
+      for (i = 0; i < writable_colors; i++)
+         if (pseudo_color_lookup[i] != i) break;
+   }
+   else
+   {
+      if (!(pseudo_color_allocated = calloc(writable_colors, sizeof(char))))
+      {
+         fprintf(stderr_file, "error: malloc failed for pseudo color lookup table\n");
+         free(pseudo_color_lookup);
+         pseudo_color_lookup=NULL;
+         return -1;
+      }
+   }
+   
+   display_palette_info.writable_colors = writable_colors;
+#endif
+   return 0;
+}
+
+int ph_window_modify_pen (int pen, unsigned char red, unsigned char green,
+   unsigned char blue)
+{
+#if 0
+   PgColor_t color;
+
+   /* Translate 0-255 values of new color to X 0-65535 values. */
+   color.flags = (DoRed | DoGreen | DoBlue);
+   color.red = (int) red << 8;
+   color.green = (int) green << 8;
+   color.blue = (int) blue << 8;
+   color.pixel = pseudo_color_lookup[pen];
+
+   if (pseudo_color_use_rw_palette)
+   {
+      XStoreColor (display, colormap, &color);
+   }
+   else
+   {
+      /* free previously allocated color */
+      if (pseudo_color_allocated[pen])
+      {
+         XFreeColors (display, colormap, &pseudo_color_lookup[pen], 1, 0);
+         pseudo_color_allocated[pen] = FALSE;
+      }
+
+      /* allocate new color and assign it to pen index */
+      if (XAllocColor (display, colormap, &color))
+      {
+         if (pseudo_color_lookup[pen] != color.pixel)
+            pseudo_color_lookup_dirty = TRUE;
+         pseudo_color_lookup[pen] = color.pixel;
+         pseudo_color_allocated[pen] = TRUE;
+      }
+      else /* try again with the closest match */
+      {
+         int i;
+         XColor colors[256];
+         int my_red   = (int)red << 8;
+         int my_green = (int)green << 8;
+         int my_blue  = (int)blue << 8;
+         int best_pixel = black_pen;
+         float best_diff = FLT_MAX;
+         
+         for(i=0;i<256;i++)
+            colors[i].pixel = i;
+         
+         XQueryColors(display, colormap, colors, 256);
+         for(i=0;i<256;i++)
+         {
+            #define SQRT(x) ((float)(x)*(x))
+            float diff = SQRT(my_red - colors[i].red) + 
+               SQRT(my_green - colors[i].green) +
+               SQRT(my_blue - colors[i].blue);
+            if (diff < best_diff)
+            {
+               best_pixel = colors[i].pixel;
+               best_diff  = diff;
+            }
+         }
+         
+         color = colors[best_pixel];
+         
+         if (XAllocColor (display, colormap, &color))
+         {
+            if (pseudo_color_lookup[pen] != color.pixel)
+               pseudo_color_lookup_dirty = TRUE;
+            pseudo_color_lookup[pen] = color.pixel;
+            pseudo_color_allocated[pen] = TRUE;
+         }
+         else
+         {
+            if (pseudo_color_warn_low_on_colors)
+            {
+               pseudo_color_warn_low_on_colors = 0;
+               fprintf (stderr_file,
+                  "warning: Closest color match alloc failed\n"
+                  "Couldn't allocate all colors, some parts of the emulation may be black\n"
+                  "Try running mame with the -privatecmap option\n");
+            }
+            
+            /* If color allocation failed, use black to ensure the
+               pen is not left set to an invalid color */
+            pseudo_color_lookup[pen] = black_pen;
+            return -1;
+         }
+      }
+   }
+#endif
+   return 0;
+}
+
+/* invoked by main tree code to update bitmap into screen */
+void ph_window_update_display (struct mame_bitmap *bitmap)
+{
+   PhRegion_t region_info;	
+
+//	fprintf(stderr,"Calling update display\n");
+
+// TODO:  Not sure just yet what this is for...if it's only x related we can probably
+//	  toss it.   
+   (*ph_window_update_display_func) (bitmap);
+
+   if (use_mouse &&
+       keyboard_pressed (KEYCODE_LALT) &&
+       keyboard_pressed_memory (KEYCODE_PGDN))
+   {
+      if (ph_grab_mouse)
+      {
+         region_info.cursor_type = 0;
+	 region_info.rid = PtWidgetRid(P_mainWindow);
+	 ph_grab_mouse = FALSE;
+      }
+      else
+      {
+	 region_info.cursor_type = Ph_CURSOR_NONE;
+	 region_info.rid = PtWidgetRid(P_mainWindow);      
+	 ph_grab_mouse = TRUE;
+      }
+
+      PhRegionChange (Ph_REGION_CURSOR, 0, &region_info, NULL, NULL);
+   }
+
+   PgFlush();         /* flush buffer to server */
+}
+
+void ph_window_refresh_screen (void)
+{
+	PhArea_t sarea, darea;
+	
+//	fprintf(stderr,"refresh screen\n");
+	switch (ph_window_update_method)
+	{
+		case PH_NORMAL:
+			sarea.pos.x=sarea.pos.y=darea.pos.x=darea.pos.y=0;
+			sarea.size.w=darea.size.w=image->dim.w;
+			sarea.size.h=darea.size.h=image->dim.h;
+			
+			PgSetRegion(PtWidgetRid(P_mainWindow));
+			PgSetClipping (0,NULL);
+			PgContextBlitArea (image,&sarea,NULL,&darea);
+		break;
+	}
+}
+
+INLINE void ph_window_put_image (int x, int y, int width, int height)
+{
+	PhArea_t sarea, darea;
+
+
+	switch (ph_window_update_method)
+	{
+		case PH_NORMAL:
+			sarea.pos.x=x; sarea.pos.y=y;
+			sarea.size.w=darea.size.w=width;
+			sarea.size.h=darea.size.h=height;
+			darea.pos.x=x+startx; darea.pos.y=y+starty;
+
+			PgSetRegion(PtWidgetRid(P_mainWindow));
+			PgSetClipping (0,NULL);
+			PgContextBlitArea (image,&sarea,NULL,&darea);
+		break;
+	}
+}
+
+/* CHECK THIS! */
+//#define DEST_WIDTH image->dim.w
+#define DEST_WIDTH image_width
+#define DEST scaled_buffer_ptr
+#define SRC_PIXEL unsigned short
+#define PUT_IMAGE(X, Y, WIDTH, HEIGHT) ph_window_put_image(X, Y, WIDTH, HEIGHT);
+
+static void ph_window_update_16_to_16bpp (struct mame_bitmap *bitmap)
+{
+#define DEST_PIXEL unsigned short
+
+   if (current_palette->lookup)
+   {
+#include "blit.h"
+   }
+   else
+   {
+#undef  INDIRECT
+#include "blit.h"
+#define INDIRECT current_palette->lookup
+   }
+
+#undef DEST_PIXEL
+}
+
+#define DEST_PIXEL unsigned int
+
+static void ph_window_update_16_to_24bpp (struct mame_bitmap *bitmap)
+{
+#define PACK_BITS
+#include "blit.h"
+#undef PACK_BITS
+}
+
+static void ph_window_update_16_to_32bpp (struct mame_bitmap *bitmap)
+{
+#include "blit.h"
+}
+
+#undef  INDIRECT
+#undef  SRC_PIXEL
+#define SRC_PIXEL unsigned int
+
+static void ph_window_update_32_to_32bpp_direct(struct mame_bitmap *bitmap)
+{
+#include "blit.h"
+}
+
+#undef DEST_PIXEL
+#undef SRC_PIXEL
+
+#endif /* ifdef photon2 */
diff --git a/src/unix/video-drivers/svgafx.c b/src/unix/video-drivers/svgafx.c
new file mode 100644
index 0000000..dcaa7ab
--- /dev/null
+++ b/src/unix/video-drivers/svgafx.c
@@ -0,0 +1,97 @@
+/***************************************************************************
+
+  Xmame 3Dfx console-mode driver
+
+  Written based on Phillip Ezolt's svgalib driver by Mike Oliphant -
+
+    oliphant@ling.ed.ac.uk
+
+    http://www.ling.ed.ac.uk/~oliphant/glmame
+
+***************************************************************************/
+#define __SVGAFX_C
+
+#include <vga.h>
+#include <glide.h>
+#include "xmame.h"
+#include "svgainput.h"
+
+int  InitVScreen(void);
+void CloseVScreen(void);
+int  InitGlide(void);
+int  SetResolution(struct rc_option *option, const char *arg, int priority);
+
+extern struct rc_option fx_opts[];
+
+struct rc_option display_opts[] = {
+   /* name, shortname, type, dest, deflt, min, max, func, help */
+   { NULL, 		NULL,			rc_link,	fx_opts,
+     NULL,		0,			0,		NULL,
+     NULL },
+   { NULL,		NULL,			rc_end,		NULL,
+     NULL,		0,			0,		NULL,
+     NULL }
+};
+
+int sysdep_init(void)
+{
+   fprintf(stderr,
+      "info: using FXmame v0.5 driver for xmame, written by Mike Oliphant\n");
+   
+   if (InitGlide()!=OSD_OK)
+      return OSD_NOT_OK;
+   if (vga_init())
+      return OSD_NOT_OK;
+   if (svga_input_init())
+      return OSD_NOT_OK;
+   
+   return OSD_OK;
+}
+
+void sysdep_close(void)
+{
+   svga_input_exit();
+}
+
+static void release_function(void)
+{
+   grSstControl(GR_CONTROL_DEACTIVATE);
+}
+
+static void acquire_function(void)
+{
+   grSstControl(GR_CONTROL_ACTIVATE);
+}
+
+/* This name doesn't really cover this function, since it also sets up mouse
+   and keyboard. This is done over here, since on most display targets the
+   mouse and keyboard can't be setup before the display has. */
+int sysdep_create_display(int depth)
+{
+  if (InitVScreen() != OSD_OK)
+     return OSD_NOT_OK;
+     
+  /* with newer svgalib's the console switch signals are only active if a
+     graphics mode is set, so we set one which each card should support */
+  vga_setmode(G320x200x16);
+  
+  /* init input */
+  if(svga_input_open(release_function, acquire_function))
+     return OSD_NOT_OK;
+   
+  return OSD_OK;
+}
+
+
+/* shut up the display */
+void sysdep_display_close(void)
+{
+   /* close input */
+   svga_input_close();
+   
+   /* close svgalib */
+   vga_setmode(TEXT);
+   
+   /* close glide */
+   CloseVScreen();
+}
diff --git a/src/unix/video-drivers/svgainput.c b/src/unix/video-drivers/svgainput.c
new file mode 100644
index 0000000..6d78827
--- /dev/null
+++ b/src/unix/video-drivers/svgainput.c
@@ -0,0 +1,351 @@
+#include <vga.h>
+#include <vgakeyboard.h>
+/* fix ansi compilation */
+#define inline
+#include <vgamouse.h>
+#undef inline
+#include <signal.h>
+#include <linux/kd.h>
+#include <sys/ioctl.h>
+#include "svgainput.h"
+#include "xmame.h"
+#include "devices.h"
+#include "keyboard.h"
+
+#ifdef __FreeBSD__ 
+#define	SIGUNUSED	SIGUSR2
+#endif
+
+#if defined(__ARCH_freebsd)
+#define	SIGUNUSED	SIGUSR2
+#endif
+
+static int console_fd       = -1;
+static int mouse_fd         = -1;
+static int leds             =  0;
+static int release_signal   =  0;
+static int acquire_signal   =  0;
+static struct sigaction release_sa;
+static struct sigaction oldrelease_sa;
+static struct sigaction acquire_sa;
+static struct sigaction oldacquire_sa;
+static void (*release_function)(void) = NULL;
+static void (*acquire_function)(void) = NULL;
+
+static const char scancode_to_unicode[128][2] = {
+   { 0,   0   }, /* 0 */
+   { 0,   0   },
+   { '1', '!' },
+   { '2', '@' },
+   { '3', '#' },
+   { '4', '$' },
+   { '5', '%' },
+   { '6', '^' },
+   { '7', '&' },
+   { '8', '*' },
+   { '9', '(' }, /* 10 */
+   { '0', ')' },
+   { '-', '_' },
+   { '=', '+' },
+   { 0x8, 0x8 },
+   { 0,   0   },
+   { 'q', 'Q' },
+   { 'w', 'W' },
+   { 'e', 'E' },
+   { 'r', 'R' },
+   { 't', 'T' }, /* 20 */
+   { 'y', 'Y' },
+   { 'u', 'U' },
+   { 'i', 'I' },
+   { 'o', 'O' },
+   { 'p', 'P' },
+   { '[', '{' },
+   { ']', '}' },
+   { 0,   0   },
+   { 0,   0   },
+   { 'a', 'A' }, /* 30 */
+   { 's', 'S' },
+   { 'd', 'D' },
+   { 'f', 'F' },
+   { 'g', 'G' },
+   { 'h', 'H' },
+   { 'j', 'J' },
+   { 'k', 'K' },
+   { 'l', 'L' },
+   { ';', ':' },
+   { '\'', '"' },/* 40 */
+   { '`', '~' },
+   { 0,   0   },
+   { '\\', '|' },
+   { 'z', 'Z' },
+   { 'x', 'X' },
+   { 'c', 'C' },
+   { 'v', 'V' },
+   { 'b', 'B' },
+   { 'n', 'N' },
+   { 'm', 'M' }, /* 50 */
+   { ',', '<' },
+   { '.', '>' },
+   { '/', '?' },
+   { 0,   0   },
+   { '*', '*' },
+   { 0,   0   },
+   { ' ', ' ' },
+   { 0,   0   },
+   { 0,   0   },
+   { 0,   0   }, /* 60 */
+   { 0,   0   },
+   { 0,   0   },
+   { 0,   0   },
+   { 0,   0   },
+   { 0,   0   },
+   { 0,   0   },
+   { 0,   0   },
+   { 0,   0   },
+   { 0,   0   },
+   { 0,   0   }, /* 70 */
+   { '7', '7' },
+   { '8', '8' },
+   { '9', '9' },
+   { '-', '-' },
+   { '4', '4' },
+   { '5', '5' },
+   { '6', '6' },
+   { '+', '+' },
+   { '1', '1' },
+   { '2', '2' }, /* 80 */
+   { '3', '3' },
+   { '0', '0' },
+   { '.', '.' },
+   { 0,   0   },
+   { 0,   0   },
+   { '\\', '|' },
+   { 0,   0   },
+   { 0,   0   },
+   { 0,   0   },
+   { 0,   0   }, /* 90 */
+   { 0,   0   },
+   { 0,   0   },
+   { 0,   0   },
+   { 0,   0   },
+   { 0,   0   },
+   { 0,   0   },
+   { 0,   0   },
+   { '/', '/' },
+   { 0,   0   },
+   { 0,   0   }, /* 100 */
+   { 0,   0   },
+   { 0,   0   },
+   { 0,   0   },
+   { 0,   0   },
+   { 0,   0   },
+   { 0,   0   },
+   { 0,   0   },
+   { 0,   0   },
+   { 0,   0   },
+   { 0,   0   }, /* 110 */
+   { 0,   0   },
+   { 0,   0   },
+   { 0,   0   },
+   { 0,   0   },
+   { 0,   0   },
+   { 0,   0   },
+   { 0,   0   },
+   { 0,   0   },
+   { 0,   0   },
+   { 0,   0   }, /* 120 */
+   { 0,   0   },
+   { 0,   0   },
+   { 0,   0   },
+   { 0,   0   },
+   { 0,   0   },
+   { 0,   0   },
+   { 0,   0   }
+};
+
+void release_handler(int n)
+{
+   if (release_function)
+      release_function();
+   oldrelease_sa.sa_handler(n);
+   sigaction(release_signal, &release_sa, NULL);
+   sigaction(acquire_signal, &acquire_sa, NULL);
+}
+
+void acquire_handler(int n)
+{
+   oldacquire_sa.sa_handler(n);
+   sigaction(release_signal, &release_sa, NULL);
+   sigaction(acquire_signal, &acquire_sa, NULL);
+   keyboard_clearstate();
+   xmame_keyboard_clear();
+   if (console_fd >= 0)
+      ioctl(console_fd, KDSETLED, leds);
+   if (acquire_function)
+      acquire_function();
+}
+
+void keyboard_handler(int scancode, int press)
+{
+   static int shift = 0;
+   int shift_mask = 0;
+   struct xmame_keyboard_event event;
+   
+   switch (scancode)
+   {
+      case KEY_LSHIFT:
+         shift_mask = 0x01;
+         break;
+      case KEY_RSHIFT:
+         shift_mask = 0x02;
+         break;
+   }
+   
+   if (press)
+      shift |= shift_mask;
+   else
+      shift &= ~shift_mask;
+   
+   event.press = press;   
+   event.scancode = scancode;
+   event.unicode = scancode_to_unicode[scancode][shift? 1:0];
+   xmame_keyboard_register_event(&event);
+}
+
+int svga_input_init(void)
+{
+   /* open the mouse here and not in open/close, this is not done
+      because this requires root rights, but because open/close can
+      be called multiple times, and svgalib's mouse_open/close can't
+      handle that */
+   mouse_fd = mouse_init_return_fd("/dev/mouse", vga_getmousetype(),
+      MOUSE_DEFAULTSAMPLERATE);
+   if(mouse_fd < 0)
+   {
+      perror("mouse_init");
+      fprintf(stderr_file,"SVGALib: failed to open mouse device\n");
+   }
+   
+   return 0;
+}
+
+void svga_input_exit(void)
+{
+   if (mouse_fd >= 0)
+      mouse_close();
+}
+
+int svga_input_open(void (*release_func)(void), void (*acquire_func)(void))
+{
+   release_function = release_func;
+   acquire_function = acquire_func;
+   
+   /* newer svgalib's use different signals */
+   if (vga_setmode(-1)<0x1410)
+   {
+      fprintf(stderr_file, "info: svgalib version older then 1.4.1 detected, using old style signals\n");
+      release_signal = SIGUSR1;
+      acquire_signal = SIGUSR2;
+   }
+   else
+   {
+      fprintf(stderr_file, "info: svgalib version 1.4.1 or newer detected, using new style signals\n");
+      release_signal = SIGPROF;
+      acquire_signal = SIGUNUSED;
+   }
+  
+   /* catch console switch signals to enable / disable the vga pass through */
+   memset(&release_sa, 0, sizeof(struct sigaction));
+   memset(&acquire_sa, 0, sizeof(struct sigaction));
+   release_sa.sa_handler = release_handler;
+   acquire_sa.sa_handler = acquire_handler;
+   sigaction(release_signal, &release_sa, &oldrelease_sa);
+   sigaction(acquire_signal, &acquire_sa, &oldacquire_sa);
+
+   /* init the keyboard */
+   if ((console_fd = keyboard_init_return_fd()) < 0)
+   {
+      fprintf(stderr_file, "Svgalib: Error: Couldn't open keyboard\n");
+      return -1;
+   }
+   keyboard_seteventhandler(keyboard_handler);
+   ioctl(console_fd, KDSETLED, leds);
+
+   /* init the mouse */
+   if((mouse_fd >= 0) && use_mouse)
+   {
+	/* fix ranges and initial position of mouse */
+	mouse_setrange_6d(-500,500, -500,500, -500,500, -500,500,
+                  -500,500, -500,500, MOUSE_6DIM);
+	mouse_setposition_6d(0, 0, 0, 0, 0, 0, MOUSE_6DIM);
+   }
+   else
+      use_mouse = 0;
+   
+   return 0;
+}
+
+void svga_input_close(void)
+{
+   /* restore the old handlers */
+   sigaction(release_signal, &oldrelease_sa, NULL);
+   sigaction(acquire_signal, &oldacquire_sa, NULL);
+
+   if (console_fd >= 0)
+   {
+      ioctl(console_fd, KDSETLED, 8);
+      keyboard_close();
+   }
+}
+
+void sysdep_mouse_poll (void)
+{
+	int i, mouse_buttons;
+	
+	if (mouse_fd < 0)
+	   return;
+	
+	mouse_update();
+	
+	mouse_getposition_6d(&mouse_data[0].deltas[0],
+           &mouse_data[0].deltas[1],
+           &mouse_data[0].deltas[2],
+           &mouse_data[0].deltas[3],
+           &mouse_data[0].deltas[4],
+           &mouse_data[0].deltas[5]);
+	
+	/* scale down the delta's to some more sane values */
+	for(i=0; i<6; i++)
+	   mouse_data[0].deltas[i] /= 20;
+
+	mouse_buttons = mouse_getbutton();
+
+        for(i=0; i<MOUSE_BUTTONS; i++)
+        {
+           mouse_data[0].buttons[i] = mouse_buttons & (0x01 << i);
+        }
+
+	mouse_setposition_6d(0, 0, 0, 0, 0, 0, MOUSE_6DIM);
+}
+
+void sysdep_set_leds(int new_leds)
+{
+   static int old_leds = 0;
+   
+   if (old_leds != new_leds)
+   {
+      leds = 0;
+      
+      if (new_leds & 0x01)
+         leds |= LED_NUM;
+      if (new_leds & 0x02)
+         leds |= LED_CAP;
+      if (new_leds & 0x04)
+         leds |= LED_SCR;
+      
+      if (console_fd >= 0)
+         ioctl(console_fd, KDSETLED, leds);
+      
+      old_leds = new_leds;
+   }
+}
diff --git a/src/unix/video-drivers/svgainput.h b/src/unix/video-drivers/svgainput.h
new file mode 100644
index 0000000..be4a375
--- /dev/null
+++ b/src/unix/video-drivers/svgainput.h
@@ -0,0 +1,9 @@
+#ifndef __SVGAINPUT_H
+#define __SVGAINPUT_H
+
+int svga_input_init(void);
+int svga_input_open(void (*release_func)(void), void (*aqcuire_func)(void));
+void svga_input_close(void);
+void svga_input_exit(void);
+
+#endif
diff --git a/src/unix/video-drivers/svgalib.c b/src/unix/video-drivers/svgalib.c
new file mode 100644
index 0000000..01c0a56
--- /dev/null
+++ b/src/unix/video-drivers/svgalib.c
@@ -0,0 +1,559 @@
+/***************************************************************************
+
+ Linux SVGALib adaptation by Phillip Ezolt pe28+@andrew.cmu.edu
+  
+***************************************************************************/
+#define __SVGALIB_C
+
+#include <math.h>
+#include <vga.h>
+#include <vgagl.h>
+#include "xmame.h"
+#include "svgainput.h"
+#include "effect.h"
+
+static int startx, starty;
+static int scaled_visual_width, scaled_visual_height;
+static int video_mode       = -1;
+static int tweaked_mode     = -1;
+static int update_function  = -1;
+static int text_mode        = TRUE;
+static unsigned char *video_mem = NULL;
+static unsigned char *doublebuffer_buffer = NULL;
+static int use_tweak = 0;
+static int use_planar = 1;
+static int use_linear = 0;
+static int center_x = 0;
+static int center_y = 0;
+static vga_modeinfo video_modeinfo;
+static void svgalib_update_linear(struct mame_bitmap *bitmap);
+static void svgalib_update_planar(struct mame_bitmap *bitmap);
+static void svgalib_update_gl(struct mame_bitmap *bitmap);
+static void svgalib_update_gl_scaled(struct mame_bitmap *bitmap);
+static void svgalib_update_linear_16bpp(struct mame_bitmap *bitmap);
+static void svgalib_update_gl_16bpp(struct mame_bitmap *bitmap);
+static void svgalib_update_gl_scaled_16bpp(struct mame_bitmap *bitmap);
+
+struct rc_option display_opts[] = {
+   /* name, shortname, type, dest, deflt, min, max, func, help */
+   { "Svgalib Related",	NULL,			rc_seperator,	NULL,
+     NULL,		0,			0,		NULL,
+     NULL },
+   { "tweak",		NULL,			rc_bool,	&use_tweak,
+     "0",		0,			0,		NULL,
+     "Enable/disable svgalib tweaked video modes" },
+   { "planar",		NULL,			rc_bool,	&use_planar,
+     "1",		0,			0,		NULL,
+     "Enable/disable use of planar (modeX) modes (slow)" },
+   { "linear",		NULL,			rc_bool,	&use_linear,
+     "0",		0,			0,		NULL,
+     "Enable/disable use of linear framebuffer (fast)" },
+   { "centerx",		NULL,			rc_int,		&center_x,
+     "0",		0,			0,		NULL,
+     "Adjust the horizontal center of tweaked vga modes" },
+   { "centery",		NULL,			rc_int,		&center_y,
+     "0",		0,			0,		NULL,
+     "Adjust the vertical center of tweaked vga modes" },
+   { NULL,		NULL,			rc_link,	mode_opts,
+     NULL,		0,			0,		NULL,
+     NULL },
+   { NULL,		NULL,			rc_end,		NULL,
+     NULL,		0,			0,		NULL,
+     NULL }
+};
+
+
+typedef void (*update_func)(struct mame_bitmap *bitmap);
+
+static update_func update_functions[8] = {
+   svgalib_update_linear,
+   svgalib_update_planar,
+   svgalib_update_gl,
+   svgalib_update_gl_scaled,
+   svgalib_update_linear_16bpp,
+   NULL,
+   svgalib_update_gl_16bpp,
+   svgalib_update_gl_scaled_16bpp
+};
+
+/* tweaked modes */
+#ifdef __CPU_i386
+#include "twkuser.c"
+#include "twkmodes.h"
+
+struct tweaked_mode_struct
+{
+   int width;
+   int height;
+   Register *registers;
+   Register *registers_scanline;
+   int planar;
+   int horizontal_squashed;
+};
+
+/* all available videomodes */
+static struct tweaked_mode_struct tweaked_modes[] = {
+{  384, 256, scr384x256,    NULL,		 1, 0 },
+{  384, 240, scr384x240,    NULL,		 1, 0 },
+{  384, 224, scr384x224,    NULL,		 1, 0 },
+{  336, 240, scr336x240,    NULL,		 1, 0 },
+{  320, 240, scr320x240,    NULL,		 1, 0 },
+{  320, 204, scr320x204,    NULL,                0, 0 },
+{  288, 224, scr288x224,    NULL,                0, 0 },
+{  256, 240, scr256x240,    NULL,                0, 0 },
+{  256, 256, scr256x256,    NULL,                0, 0 },
+{  256, 256, scr256x256ver, NULL,                0, 1 },
+{  240, 256, scr240x256,    NULL,                0, 0 },
+{  224, 288, scr224x288,    scr224x288scanlines, 0, 0 },
+{  200, 320, scr200x320,    NULL,                0, 0 },
+{    0,   0, NULL,          NULL,                0, 0 }
+};
+
+static void set_tweaked_mode(void)
+{
+	if (!text_mode && tweaked_mode >= 0)
+	{
+	   Register *r = tweaked_modes[tweaked_mode].registers;
+	   center_mode(r);
+	   if (use_scanlines)
+	   {
+	      if (tweaked_modes[tweaked_mode].registers_scanline)
+	         r = tweaked_modes[tweaked_mode].registers_scanline;
+	      else
+	         r = make_scanline_mode(r, 21);
+	   }
+	   outRegArray(r, 21);
+	}
+}
+#endif /* ifdef __CPU_i386 */
+
+int sysdep_init(void)
+{
+   vga_init();
+   
+   if(svga_input_init())
+      return OSD_NOT_OK;
+   
+   return OSD_OK;
+}
+
+void sysdep_close(void)
+{
+   svga_input_exit();
+
+   /* close svgalib */
+   vga_setmode(TEXT);
+}
+
+int sysdep_display_16bpp_capable(void)
+{
+   int i;
+   vga_modeinfo *my_modeinfo;
+   
+   for (i=1; (my_modeinfo=vga_getmodeinfo(i)); i++)
+      if( (my_modeinfo->colors == 32768) ||
+          (my_modeinfo->colors == 65536) )
+         return 1;
+         
+   return 0;
+}
+
+int sysdep_set_video_mode (void)
+{
+   int i;
+   
+   if (!text_mode) return OSD_NOT_OK;
+   
+   vga_setmode(video_mode);
+   gl_setcontextvga(video_mode);
+   text_mode = FALSE;
+   set_tweaked_mode();
+
+   if (video_modeinfo.flags & IS_MODEX)
+      update_function=1;
+   else
+   {
+#ifdef __CPU_i386
+      /* do we have a linear framebuffer ? */
+      i = video_modeinfo.width * video_modeinfo.height *
+         video_modeinfo.bytesperpixel;
+      if (i <= 65536 || 
+          (video_modeinfo.flags & IS_LINEAR) ||
+          (use_linear && (video_modeinfo.flags && CAPABLE_LINEAR) &&
+           vga_setlinearaddressing() >=  i))
+      {
+         video_mem  = vga_getgraphmem();
+         video_mem += startx * video_modeinfo.bytesperpixel;
+         video_mem += starty * video_modeinfo.width *
+            video_modeinfo.bytesperpixel;
+         if ((widthscale > 1 || heightscale > 1 || yarbsize) &&
+             doublebuffer_buffer == NULL)
+         {
+            doublebuffer_buffer = malloc(scaled_visual_width * 
+               video_modeinfo.bytesperpixel);
+            if (!doublebuffer_buffer)
+            {
+               fprintf(stderr_file, "Svgalib: Error: Couldn't allocate doublebuffer buffer\n");
+               return OSD_NOT_OK;
+            }
+         }
+         update_function=0;
+         fprintf(stderr_file, "Svgalib: Info: Using a linear framebuffer to speed up\n");
+      }
+      else
+#endif
+      {
+         if((widthscale == 1) && (heightscale == 1) && (yarbsize == 0))
+            update_function=2;
+         else
+            update_function=3;
+         /* we might need the doublebuffer_buffer for 1x1 in 16bpp, since it
+            could be paletised */
+         if( ((widthscale > 1) || (heightscale > 1) || (yarbsize) ||
+	      (video_modeinfo.bytesperpixel == 2))
+             && !doublebuffer_buffer)
+         {
+            doublebuffer_buffer = malloc(scaled_visual_width*scaled_visual_height*
+               video_modeinfo.bytesperpixel);
+            if (!doublebuffer_buffer)
+            {
+               fprintf(stderr_file, "Svgalib: Error: Couldn't allocate doublebuffer buffer\n");
+               return OSD_NOT_OK;
+            }
+         }
+      }
+   }
+      
+   if (video_modeinfo.bytesperpixel == 2)
+      update_function+=4;
+   
+   return OSD_OK;
+}
+
+void sysdep_set_text_mode (void)
+{
+   if (text_mode) return;
+   vga_setmode(TEXT);
+   text_mode=TRUE;
+}
+
+/* This name doesn't really cover this function, since it also sets up mouse
+   and keyboard. This is done over here, since on most display targets the
+   mouse and keyboard can't be setup before the display has. */
+int sysdep_create_display(int depth)
+{
+   int i;
+   int score, best_score = 0;
+   vga_modeinfo *my_modeinfo;
+   
+   video_mode       = -1;
+   tweaked_mode     = -1;
+   update_function  = -1;
+   text_mode        = TRUE;
+   video_mem        = NULL;
+   doublebuffer_buffer = NULL;
+   
+   scaled_visual_width  = visual_width  * widthscale;
+   scaled_visual_height = yarbsize ? yarbsize : visual_height * heightscale;
+   
+   for (i=1; (my_modeinfo=vga_getmodeinfo(i)); i++)
+   {
+      if(depth == 16)
+      {
+         if(my_modeinfo->colors != 32768 &&
+            my_modeinfo->colors != 65536)
+            continue;
+      }
+      else
+      {
+         if(my_modeinfo->colors != 256)
+            continue;
+         if((my_modeinfo->flags & IS_MODEX) &&
+            (!use_planar || widthscale != 1 || heightscale != 1 || yarbsize))
+            continue;
+      }
+      if (!vga_hasmode(i))
+         continue;
+      /* we only want modes which are a multiple of 8 width, due to alignment
+         issues */
+      if (my_modeinfo->width & 7)
+         continue;
+      if (mode_disabled(my_modeinfo->width, my_modeinfo->height, depth))
+         continue;
+      score = mode_match(my_modeinfo->width, my_modeinfo->height);
+      if (score && score >= best_score)
+      {
+         best_score = score;
+         video_mode = i;
+         video_modeinfo = *my_modeinfo;
+      }
+      fprintf(stderr_file, "Svgalib: Info: Found videomode %dx%dx%d\n",
+         my_modeinfo->width, my_modeinfo->height, my_modeinfo->colors);
+   }
+   
+   if (use_tweak && depth == 8 && vga_hasmode(G320x200x256) &&
+       vga_hasmode(G320x240x256))
+   {
+      float orig_display_aspect_ratio = display_aspect_ratio;
+      for(i=0; tweaked_modes[i].width; i++)
+      {
+         if (mode_disabled(tweaked_modes[i].width, tweaked_modes[i].height, depth))
+            continue;
+         if((tweaked_modes[i].planar) &&
+            (!use_planar || widthscale != 1 || heightscale != 1 || yarbsize))
+            continue;
+         if (tweaked_modes[i].horizontal_squashed)
+            display_aspect_ratio = display_aspect_ratio * 9.0 / 16.0;
+         score = mode_match(tweaked_modes[i].width, tweaked_modes[i].height);
+         display_aspect_ratio = orig_display_aspect_ratio;
+         if (score && score >= best_score)
+         {
+            best_score   = score;
+            tweaked_mode = i;
+            memset(&video_modeinfo, 0, sizeof(video_modeinfo));
+            if (tweaked_modes[i].planar)
+            {
+               video_mode = G320x240x256;
+               video_modeinfo.bytesperpixel = 0;
+               video_modeinfo.maxpixels     = 262144;
+               video_modeinfo.flags         = IS_MODEX;
+            }
+            else
+            {
+               video_mode = G320x200x256;
+               video_modeinfo.bytesperpixel = 1;
+               video_modeinfo.maxpixels     = 65536;
+               video_modeinfo.flags         = IS_LINEAR;
+            }
+            video_modeinfo.colors = 256;
+            video_modeinfo.width  = video_modeinfo.linewidth =
+               tweaked_modes[i].width;
+            video_modeinfo.height = tweaked_modes[i].height;
+         }
+         fprintf(stderr_file, "Svgalib: Info: Found videomode %dx%dx256\n",
+            tweaked_modes[i].width, tweaked_modes[i].height);
+      }
+   }
+   
+   if (best_score == 0)
+   {
+      fprintf(stderr_file, "Svgalib: Couldn't find a suitable mode for a resolution of %d x %d\n",
+         scaled_visual_width, scaled_visual_height);
+      return OSD_NOT_OK;
+   }
+   
+   fprintf(stderr_file, "Svgalib: Info: Choose videomode %dx%dx%d\n",
+      video_modeinfo.width, video_modeinfo.height, video_modeinfo.colors);
+   
+   startx = ((video_modeinfo.width  - scaled_visual_width ) / 2) & ~7;
+   starty =  (video_modeinfo.height - scaled_visual_height) / 2;
+   
+   if (sysdep_set_video_mode()!=OSD_OK) return OSD_NOT_OK;
+   
+   fprintf(stderr_file, "Using a mode with a resolution of %d x %d, starting at %d x %d\n",
+      video_modeinfo.width, video_modeinfo.height, startx, starty);
+
+   /* fill the display_palette_info struct */
+   memset(&display_palette_info, 0, sizeof(struct sysdep_palette_info));
+   display_palette_info.depth = depth;
+   if (depth == 8)
+      display_palette_info.writable_colors = 256;
+   else
+      if (video_modeinfo.colors == 32768)
+      {
+         display_palette_info.red_mask   = 0x001F;
+         display_palette_info.green_mask = 0x03E0;
+         display_palette_info.blue_mask  = 0xEC00;
+      }
+      else
+      {
+         display_palette_info.red_mask   = 0xF800;
+         display_palette_info.green_mask = 0x07E0;
+         display_palette_info.blue_mask  = 0x001F;
+      }
+
+
+   effect_init2(depth, display_palette_info.depth, scaled_visual_width);
+
+   /* init input */
+#ifdef __CPU_i386
+   if(svga_input_open(NULL, set_tweaked_mode))
+#else
+   if(svga_input_open(NULL, NULL))
+#endif
+      return OSD_NOT_OK;
+   
+   return OSD_OK;
+}
+
+/* shut up the display */
+void sysdep_display_close(void)
+{
+   /* close input */
+   svga_input_close();
+   
+   /* close svgalib */
+   sysdep_set_text_mode();
+
+   /* and don't forget to free our other resources */
+   if (doublebuffer_buffer)
+   {
+      free(doublebuffer_buffer);
+      doublebuffer_buffer = NULL;
+   }
+}
+
+int sysdep_display_alloc_palette(int writable_colors)
+{
+   return 0;
+}
+
+int sysdep_display_set_pen(int pen,unsigned char red, unsigned char green,
+   unsigned char blue)
+{
+   gl_setpalettecolor(pen,(red>>2),(green>>2),(blue>>2));
+   return 0;
+}
+
+/* Update the display. */
+void sysdep_update_display(struct mame_bitmap *bitmap)
+{
+   update_functions[update_function](bitmap);
+}
+
+
+static void svgalib_update_linear(struct mame_bitmap *bitmap)
+{
+#define SRC_PIXEL  unsigned char
+#define DEST_PIXEL unsigned char
+#define DEST video_mem
+#define DEST_WIDTH video_modeinfo.linewidth
+#define DOUBLEBUFFER
+#include "blit.h"
+#undef DEST
+#undef DEST_WIDTH
+#undef DOUBLEBUFFER
+#undef SRC_PIXEL
+#undef DEST_PIXEL
+}
+
+static void svgalib_update_planar(struct mame_bitmap *bitmap)
+{
+  /* use page flipping otherwise the screen tears in planar modes,
+     unfortunatly this also means we can't use dirty in planar modes */
+  static int page=0;
+  if (page) page=0;
+   else page=131072;
+  vga_copytoplanar256(bitmap->line[visual.min_y] + visual.min_x,
+     bitmap->line[1] - bitmap->line[0],
+     (starty*video_modeinfo.width + startx + page)/4,
+      video_modeinfo.width/4, visual_width, visual_height);
+  vga_setdisplaystart(page);
+}
+
+static void svgalib_update_gl(struct mame_bitmap *bitmap)
+{
+   int bitmap_linewidth = (bitmap->line[1] - bitmap->line[0]) /
+      video_modeinfo.bytesperpixel;
+#define PUT_IMAGE(X, Y, WIDTH, HEIGHT) \
+      gl_putboxpart( \
+         startx + X, starty + Y, \
+         WIDTH, HEIGHT, \
+         bitmap_linewidth, bitmap->height, \
+         bitmap->line[0], X + visual.min_x, Y + visual.min_y);
+         /* Note: we calculate the real bitmap->width, as used in
+            osd_create_bitmap, this fixes the scewing bug in tempest
+            & others */
+#include "blit.h"
+#undef PUT_IMAGE
+}
+
+static void svgalib_update_gl_scaled(struct mame_bitmap *bitmap)
+{
+#define SRC_PIXEL  unsigned char
+#define DEST_PIXEL unsigned char
+#define DEST doublebuffer_buffer
+#define DEST_WIDTH scaled_visual_width
+#define PUT_IMAGE(X, Y, WIDTH, HEIGHT) \
+      gl_putboxpart( \
+         startx + X, starty + Y, \
+         WIDTH, HEIGHT, \
+         scaled_visual_width, scaled_visual_height, \
+         doublebuffer_buffer, X, Y );
+#include "blit.h"
+#undef DEST
+#undef DEST_WIDTH
+#undef PUT_IMAGE
+#undef SRC_PIXEL
+#undef DEST_PIXEL
+}
+
+static void svgalib_update_linear_16bpp(struct mame_bitmap *bitmap)
+{
+   int linewidth = video_modeinfo.linewidth/2;
+#define SRC_PIXEL  unsigned short
+#define DEST_PIXEL unsigned short
+#define DEST video_mem
+#define DEST_WIDTH linewidth
+#define DOUBLEBUFFER
+   if(current_palette->lookup)
+   {
+#define INDIRECT current_palette->lookup
+#include "blit.h"
+#undef INDIRECT
+   }
+   else
+   {
+#include "blit.h"
+   }
+#undef DEST
+#undef DEST_WIDTH
+#undef DOUBLEBUFFER
+#undef SRC_PIXEL
+#undef DEST_PIXEL
+}
+
+static void svgalib_update_gl_16bpp(struct mame_bitmap *bitmap)
+{
+   if(current_palette->lookup)
+   {
+      /* since we need the lookups we need to go through an extra buffer,
+         just like svgalib_update_gl_scaled_16bpp() does */
+      svgalib_update_gl_scaled_16bpp(bitmap);
+   }
+   else
+   {
+      /* we can just call svgalib_update_gl which only uses gllib functions
+         and thus doesn't care about 8 / 16 bpp */
+      svgalib_update_gl(bitmap);
+   }
+}
+
+static void svgalib_update_gl_scaled_16bpp(struct mame_bitmap *bitmap)
+{
+#define SRC_PIXEL  unsigned short
+#define DEST_PIXEL unsigned short
+#define DEST doublebuffer_buffer
+#define DEST_WIDTH scaled_visual_width
+#define PUT_IMAGE(X, Y, WIDTH, HEIGHT) \
+      gl_putboxpart( \
+         startx + X, starty + Y, \
+         WIDTH, HEIGHT, \
+         scaled_visual_width, scaled_visual_height, \
+         doublebuffer_buffer, X, Y );
+   if(current_palette->lookup)
+   {
+#define INDIRECT current_palette->lookup
+#include "blit.h"
+#undef INDIRECT
+   }
+   else
+   {
+#include "blit.h"
+   }
+#undef DEST
+#undef DEST_WIDTH
+#undef PUT_IMAGE
+#undef SRC_PIXEL
+#undef DEST_PIXEL
+}
diff --git a/src/unix/video-drivers/twkmodes.h b/src/unix/video-drivers/twkmodes.h
new file mode 100644
index 0000000..a3a95b1
--- /dev/null
+++ b/src/unix/video-drivers/twkmodes.h
@@ -0,0 +1,470 @@
+#ifndef __TWKMODES_H
+#define __TWKMODES_H
+
+/* Tweaked modes definitions, taken from mame-dos */
+
+/* indices into our register array */
+#define	CLOCK_INDEX		0
+#define	H_TOTAL_INDEX		1
+#define	H_DISPLAY_INDEX		2
+#define	H_BLANKING_START_INDEX	3
+#define	H_BLANKING_END_INDEX	4
+#define	H_RETRACE_START_INDEX	5
+#define	H_RETRACE_END_INDEX	6
+#define	V_TOTAL_INDEX		7
+#define	OVERFLOW_INDEX		8
+#define	MAXIMUM_SCANLINE_INDEX	10
+#define	V_RETRACE_START_INDEX	11
+#define	V_RETRACE_END_INDEX	12
+#define	V_END_INDEX		13
+#define	MEM_OFFSET_INDEX	14
+#define	UNDERLINE_LOC_INDEX	15
+#define	V_BLANKING_START_INDEX	16
+#define	V_BLANKING_END_INDEX	17
+#define MODE_CONTROL_INDEX	18
+#define	MEMORY_MODE_INDEX	20
+
+/* -----------------------------------------------------------------------------------------*/
+/* NOTES:                                                                                   */
+/* horizontal/vertical retrace and blanking timings are genereted by - center_mode()        */
+/* most 'scanline' versions of tweaked modes are generated by        - make_scanline_mode() */
+/* but some mode's need a custom scanline register set                                      */
+/* -----------------------------------------------------------------------------------------*/
+
+/* PC Monitor Tweaked Modes */
+/* ------------------------ */
+
+
+/* 224x288 - vertical mode */
+/* Dot Clock - 28MHz */
+/* Horizontal Scanrate ~ 35.0KHz*/
+/* Vertical Refresh Rate ~60Hz */
+/* Mode Type - Linear */
+/* Notes: uses a very high horizontal scanrate to fit 288 display lines into 60Hz refresh cycle */
+Register scr224x288[] =
+{
+	{ 0x3c2, 0x00, 0xe7},{ 0x3d4, 0x00, 0x5f},{ 0x3d4, 0x01, 0x37},
+	{ 0x3d4, 0x02, 0x38},{ 0x3d4, 0x03, 0x82},{ 0x3d4, 0x04, 0x49},
+	{ 0x3d4, 0x05, 0x9a},{ 0x3d4, 0x06, 0x54},{ 0x3d4, 0x07, 0xf0},
+	{ 0x3d4, 0x08, 0x00},{ 0x3d4, 0x09, 0x61},{ 0x3d4, 0x10, 0x40},
+	{ 0x3d4, 0x11, 0xac},{ 0x3d4, 0x12, 0x3f},{ 0x3d4, 0x13, 0x1c},
+	{ 0x3d4, 0x14, 0x40},{ 0x3d4, 0x15, 0x40},{ 0x3d4, 0x16, 0x4a},
+	{ 0x3d4, 0x17, 0xa3},{ 0x3c4, 0x01, 0x01},{ 0x3c4, 0x04, 0x0e}
+};
+
+Register scr224x288scanlines[] =
+{
+	{ 0x3c2, 0x00, 0xe3},{ 0x3d4, 0x00, 0x5f},{ 0x3d4, 0x01, 0x37},
+	{ 0x3d4, 0x02, 0x38},{ 0x3d4, 0x03, 0x82},{ 0x3d4, 0x04, 0x4a},
+	{ 0x3d4, 0x05, 0x9a},{ 0x3d4, 0x06, 0x43},{ 0x3d4, 0x07, 0x1f},
+	{ 0x3d4, 0x08, 0x00},{ 0x3d4, 0x09, 0x60},{ 0x3d4, 0x10, 0x2a},
+	{ 0x3d4, 0x11, 0xac},{ 0x3d4, 0x12, 0x1f},{ 0x3d4, 0x13, 0x1c},
+	{ 0x3d4, 0x14, 0x40},{ 0x3d4, 0x15, 0x27},{ 0x3d4, 0x16, 0x3a},
+	{ 0x3d4, 0x17, 0xa3},{ 0x3c4, 0x01, 0x01},{ 0x3c4, 0x04, 0x0e}
+};
+
+/* Dot Clock - 28MHz */
+/* Horizontal Scanrate ~ 32.4KHz*/
+/* Vertical Refresh Rate ~60Hz */
+/* Mode Type - Linear */
+/* Notes: uses a high horizontal scanrate to fit 256 display lines into 60Hz refresh cycle */
+Register scr240x256[] =
+{
+	{ 0x3c2, 0x00, 0xe7},{ 0x3D4, 0x00, 0x67},{ 0x3d4, 0x01, 0x3b},
+	{ 0x3d4, 0x02, 0x40},{ 0x3D4, 0x03, 0x42},{ 0x3d4, 0x04, 0x4e},
+	{ 0x3d4, 0x05, 0x9a},{ 0x3D4, 0x06, 0x23},{ 0x3d4, 0x07, 0xb2},
+	{ 0x3d4, 0x08, 0x00},{ 0x3D4, 0x09, 0x61},{ 0x3d4, 0x10, 0x0a},
+	{ 0x3d4, 0x11, 0xac},{ 0x3D4, 0x12, 0xff},{ 0x3d4, 0x13, 0x1e},
+	{ 0x3d4, 0x14, 0x40},{ 0x3d4, 0x15, 0x07},{ 0x3D4, 0x16, 0x11},
+	{ 0x3d4, 0x17, 0xa3},{ 0x3c4, 0x01, 0x01},{ 0x3c4, 0x04, 0x0e}
+};
+
+/* 256x240 - horizontal mode */
+/* Dot Clock - 25MHz */
+/* Horizontal Scanrate ~ 34.7KHz*/
+/* Vertical Refresh Rate ~60Hz */
+/* Mode Type - Linear */
+Register scr256x240[] =
+{
+	{ 0x3c2, 0x00, 0xe3},{ 0x3d4, 0x00, 0x55},{ 0x3d4, 0x01, 0x3f},
+	{ 0x3d4, 0x02, 0x80},{ 0x3d4, 0x03, 0x90},{ 0x3d4, 0x04, 0x49},
+	{ 0x3d4, 0x05, 0x80},{ 0x3D4, 0x06, 0x43},{ 0x3d4, 0x07, 0xb2},
+	{ 0x3d4, 0x08, 0x00},{ 0x3D4, 0x09, 0x61},{ 0x3d4, 0x10, 0x04},
+	{ 0x3d4, 0x11, 0xac},{ 0x3D4, 0x12, 0xdf},{ 0x3d4, 0x13, 0x20},
+	{ 0x3d4, 0x14, 0x40},{ 0x3d4, 0x15, 0x07},{ 0x3D4, 0x16, 0x11},
+	{ 0x3d4, 0x17, 0xa3},{ 0x3c4, 0x01, 0x01},{ 0x3c4, 0x04, 0x0e}
+};
+
+/* 256x256 - horizontal mode */
+/* Dot Clock - 25MHz */
+/* Horizontal Scanrate ~34.7KHz*/
+/* Vertical Refresh Rate ~57Hz */
+/* Mode Type - Linear */
+Register scr256x256[] =
+{
+	{ 0x3c2, 0x00, 0xe3},{ 0x3d4, 0x00, 0x55},{ 0x3d4, 0x01, 0x3f},
+	{ 0x3d4, 0x02, 0x40},{ 0x3d4, 0x03, 0x90},{ 0x3d4, 0x04, 0x49},
+	{ 0x3d4, 0x05, 0x80},{ 0x3D4, 0x06, 0x60},{ 0x3d4, 0x07, 0xb2},
+	{ 0x3d4, 0x08, 0x00},{ 0x3D4, 0x09, 0x61},{ 0x3d4, 0x10, 0x28},
+	{ 0x3d4, 0x11, 0xac},{ 0x3D4, 0x12, 0xff},{ 0x3d4, 0x13, 0x20},
+	{ 0x3d4, 0x14, 0x40},{ 0x3d4, 0x15, 0x07},{ 0x3D4, 0x16, 0x11},
+	{ 0x3d4, 0x17, 0xa3},{ 0x3c4, 0x01, 0x01},{ 0x3c4, 0x04, 0x0e}
+};
+
+/* 256x256 - vertical mode */
+/* Dot Clock - 28MHz */
+/* Horizontal Scanrate ~ 31KHz*/
+/* Vertical Refresh Rate ~57Hz */
+/* Mode Type - Linear */
+/* Notes: uses a faster dot clock than horizontal the 256x256 mode to make a thinner display */
+Register scr256x256ver[] =
+{
+	{ 0x3c2, 0x00, 0xe7},{ 0x3D4, 0x00, 0x6c},{ 0x3d4, 0x01, 0x3f},
+	{ 0x3d4, 0x02, 0x40},{ 0x3D4, 0x03, 0x42},{ 0x3d4, 0x04, 0x51},
+	{ 0x3d4, 0x05, 0x9a},{ 0x3D4, 0x06, 0x23},{ 0x3d4, 0x07, 0xb2},
+	{ 0x3d4, 0x08, 0x00},{ 0x3D4, 0x09, 0x61},{ 0x3d4, 0x10, 0x0a},
+	{ 0x3d4, 0x11, 0xac},{ 0x3D4, 0x12, 0xff},{ 0x3d4, 0x13, 0x20},
+	{ 0x3d4, 0x14, 0x40},{ 0x3d4, 0x15, 0x07},{ 0x3D4, 0x16, 0x11},
+	{ 0x3d4, 0x17, 0xa3},{ 0x3c4, 0x01, 0x01},{ 0x3c4, 0x04, 0x0e}
+};
+
+/* 288x224 - horizontal mode */
+/* Dot Clock - 25MHz */
+/* Horizontal Scanrate ~31.2KHz*/
+/* Vertical Refresh Rate ~60Hz */
+/* Mode Type - Linear */
+Register scr288x224[] =
+{
+	{ 0x3c2, 0x00, 0xe3},{ 0x3d4, 0x00, 0x5f},{ 0x3d4, 0x01, 0x47},
+	{ 0x3d4, 0x02, 0x49},{ 0x3d4, 0x03, 0x90},{ 0x3d4, 0x04, 0x50},
+	{ 0x3d4, 0x05, 0x80},{ 0x3d4, 0x06, 0x0c},{ 0x3d4, 0x07, 0x3e},
+	{ 0x3d4, 0x08, 0x00},{ 0x3d4, 0x09, 0x41},{ 0x3d4, 0x10, 0xd8},
+	{ 0x3d4, 0x11, 0xac},{ 0x3d4, 0x12, 0xbf},{ 0x3d4, 0x13, 0x24},
+	{ 0x3d4, 0x14, 0x40},{ 0x3d4, 0x15, 0xc2},{ 0x3d4, 0x16, 0xf4},
+	{ 0x3d4, 0x17, 0xa3},{ 0x3c4, 0x01, 0x01},{ 0x3c4, 0x04, 0x0e}
+};
+
+/* 240x320 - vertical mode */
+/* Dot Clock - 28MHz */
+/* Horizontal Scanrate ~36.8KHz*/
+/* Vertical Refresh Rate ~56Hz */
+/* Mode Type - Planar */
+/* Notes: uses a very high horizontal scanrate to fit 320 display lines into 56Hz refresh cycle */
+Register scr240x320[] =
+{
+	{ 0x3c2, 0x00, 0xe7},{ 0x3d4, 0x00, 0x5a},{ 0x3d4, 0x01, 0x3b},
+	{ 0x3d4, 0x02, 0x3c},{ 0x3d4, 0x03, 0x96},{ 0x3d4, 0x04, 0x47},
+	{ 0x3d4, 0x05, 0x14},{ 0x3d4, 0x06, 0x8c},{ 0x3d4, 0x07, 0xf0},
+	{ 0x3d4, 0x08, 0x00},{ 0x3d4, 0x09, 0x61},{ 0x3d4, 0x10, 0x80},
+	{ 0x3d4, 0x11, 0x92},{ 0x3d4, 0x12, 0x7f},{ 0x3d4, 0x13, 0x1e},
+	{ 0x3d4, 0x14, 0x00},{ 0x3d4, 0x15, 0x80},{ 0x3d4, 0x16, 0x84},
+	{ 0x3d4, 0x17, 0xe3},{ 0x3c4, 0x01, 0x01},{ 0x3c4, 0x04, 0x06}
+};
+
+/* 320x240 - horizontal mode */
+/* Dot Clock - 25MHz */
+/* Horizontal Scanrate ~ 31.2KHz*/
+/* Vertical Refresh Rate ~60Hz */
+/* Mode Type - Planar */
+Register scr320x240[] =
+{
+	{ 0x3c2, 0x00, 0xe3},{ 0x3d4, 0x00, 0x5f},{ 0x3d4, 0x01, 0x4f},
+	{ 0x3d4, 0x02, 0x50},{ 0x3d4, 0x03, 0x82},{ 0x3d4, 0x04, 0x54},
+	{ 0x3d4, 0x05, 0x80},{ 0x3d4, 0x06, 0x0c},{ 0x3d4, 0x07, 0x3e},
+	{ 0x3d4, 0x08, 0x00},{ 0x3d4, 0x09, 0x41},{ 0x3d4, 0x10, 0xe9},
+	{ 0x3d4, 0x11, 0xac},{ 0x3d4, 0x12, 0xdf},{ 0x3d4, 0x13, 0x28},
+	{ 0x3d4, 0x14, 0x00},{ 0x3d4, 0x15, 0xe7},{ 0x3d4, 0x16, 0x06},
+	{ 0x3d4, 0x17, 0xe3},{ 0x3c4, 0x01, 0x01},{ 0x3c4, 0x04, 0x06}
+};
+
+/* 336x240 - horizontal mode */
+/* Dot Clock - 25MHz */
+/* Horizontal Scanrate ~ 31.2KHz*/
+/* Vertical Refresh Rate ~60Hz */
+/* Mode Type - Planar */
+Register scr336x240[] =
+{
+	{ 0x3c2, 0x00, 0xe3},{ 0x3d4, 0x00, 0x5f},{ 0x3d4, 0x01, 0x53},
+	{ 0x3d4, 0x02, 0x56},{ 0x3d4, 0x03, 0x80},{ 0x3d4, 0x04, 0x57},
+	{ 0x3d4, 0x05, 0x9b},{ 0x3d4, 0x06, 0x0c},{ 0x3d4, 0x07, 0x3e},
+	{ 0x3d4, 0x08, 0x00},{ 0x3d4, 0x09, 0x41},{ 0x3d4, 0x10, 0xe5},
+	{ 0x3d4, 0x11, 0xac},{ 0x3d4, 0x12, 0xdf},{ 0x3d4, 0x13, 0x2a},
+	{ 0x3d4, 0x14, 0x00},{ 0x3d4, 0x15, 0xe8},{ 0x3d4, 0x16, 0x02},
+	{ 0x3d4, 0x17, 0xe3},{ 0x3c4, 0x01, 0x01},{ 0x3c4, 0x04, 0x06}
+};
+
+/* 384x224 - horizontal mode */
+/* Dot Clock - 28MHz */
+/* Horizontal Scanrate ~ 31KHz*/
+/* Vertical Refresh Rate ~60Hz */
+/* Mode Type - Planar */
+/* Notes: this mode is basically identical to 384x240, but allows VGA triple buffering */
+Register scr384x224[] =
+{
+	{ 0x3c2, 0x00, 0xe7},{ 0x3d4, 0x00, 0x6c},{ 0x3d4, 0x01, 0x5f},
+	{ 0x3d4, 0x02, 0x61},{ 0x3d4, 0x03, 0x8b},{ 0x3d4, 0x04, 0x62},
+	{ 0x3d4, 0x05, 0x86},{ 0x3d4, 0x06, 0x0c},{ 0x3d4, 0x07, 0x3e},
+	{ 0x3d4, 0x08, 0x00},{ 0x3d4, 0x09, 0x41},{ 0x3d4, 0x10, 0xd8},
+	{ 0x3d4, 0x11, 0xac},{ 0x3d4, 0x12, 0xbf},{ 0x3d4, 0x13, 0x30},
+	{ 0x3d4, 0x14, 0x00},{ 0x3d4, 0x15, 0xc2},{ 0x3d4, 0x16, 0xf4},
+	{ 0x3d4, 0x17, 0xe3},{ 0x3c4, 0x01, 0x01},{ 0x3c4, 0x04, 0x06}
+};
+
+/* 384x240 - horizontal mode */
+/* Dot Clock - 28MHz */
+/* Horizontal Scanrate ~ 31KHz*/
+/* Vertical Refresh Rate ~60Hz */
+/* Mode Type - Planar */
+Register scr384x240[] =
+{
+	{ 0x3c2, 0x00, 0xe7},{ 0x3d4, 0x00, 0x6c},{ 0x3d4, 0x01, 0x5f},
+	{ 0x3d4, 0x02, 0x61},{ 0x3d4, 0x03, 0x8b},{ 0x3d4, 0x04, 0x62},
+	{ 0x3d4, 0x05, 0x86},{ 0x3d4, 0x06, 0x0c},{ 0x3d4, 0x07, 0x3e},
+	{ 0x3d4, 0x08, 0x00},{ 0x3d4, 0x09, 0x41},{ 0x3d4, 0x10, 0xe9},
+	{ 0x3d4, 0x11, 0xac},{ 0x3d4, 0x12, 0xdf},{ 0x3d4, 0x13, 0x30},
+	{ 0x3d4, 0x14, 0x00},{ 0x3d4, 0x15, 0xe8},{ 0x3d4, 0x16, 0x04},
+	{ 0x3d4, 0x17, 0xe3},{ 0x3c4, 0x01, 0x01},{ 0x3c4, 0x04, 0x06}
+};
+
+/* 384x256 - horizontal mode */
+/* Dot Clock - 28MHz */
+/* Horizontal Scanrate ~ 31KHz*/
+/* Vertical Refresh Rate ~57Hz */
+/* Mode Type - Planar */
+Register scr384x256[] =
+{
+	{ 0x3c2, 0x00, 0xe7},{ 0x3d4, 0x00, 0x6c},{ 0x3d4, 0x01, 0x5f},
+	{ 0x3d4, 0x02, 0x61},{ 0x3d4, 0x03, 0x8b},{ 0x3d4, 0x04, 0x62},
+	{ 0x3d4, 0x05, 0x86},{ 0x3D4, 0x06, 0x23},{ 0x3d4, 0x07, 0x36},
+	{ 0x3d4, 0x08, 0x00},{ 0x3D4, 0x09, 0x61},{ 0x3d4, 0x10, 0xff},
+	{ 0x3d4, 0x11, 0xac},{ 0x3D4, 0x12, 0xff},{ 0x3d4, 0x13, 0x30},
+	{ 0x3d4, 0x14, 0x00},{ 0x3d4, 0x15, 0x07},{ 0x3D4, 0x16, 0x11},
+	{ 0x3d4, 0x17, 0xe3},{ 0x3c4, 0x01, 0x01},{ 0x3c4, 0x04, 0x06}
+};
+
+/* old svgalib tweak modes */
+
+/* 320x204 - horizontal mode */
+/* Mode Type - Linear */
+Register scr320x204[] =
+{
+	{ 0x3c2, 0x00, 0xe3},{ 0x3d4, 0x00, 0x5f},{ 0x3d4, 0x01, 0x4f},
+	{ 0x3d4, 0x02, 0x50},{ 0x3d4, 0x03, 0x82},{ 0x3d4, 0x04, 0x54},
+	{ 0x3d4, 0x05, 0x80},{ 0x3d4, 0x06, 0xbf},{ 0x3d4, 0x07, 0x1f},
+	{ 0x3d4, 0x08, 0x00},{ 0x3d4, 0x09, 0x41},{ 0x3d4, 0x10, 0x9c},
+	{ 0x3d4, 0x11, 0x8e},{ 0x3d4, 0x12, 0x97},{ 0x3d4, 0x13, 0x28},
+	{ 0x3d4, 0x14, 0x40},{ 0x3d4, 0x15, 0x96},{ 0x3d4, 0x16, 0xb9},
+	{ 0x3d4, 0x17, 0xa3},{ 0x3c4, 0x01, 0x01},{ 0x3c4, 0x04, 0x0e},
+};
+
+/* 200x320 - vertical mode */
+/* Mode Type - Linear */
+Register scr200x320[] =
+{
+	{ 0x3c2, 0x00, 0xe3},{ 0x3d4, 0x00, 0x5f},{ 0x3d4, 0x01, 0x31},
+	{ 0x3d4, 0x02, 0x38},{ 0x3d4, 0x03, 0x82},{ 0x3d4, 0x04, 0x4a},
+	{ 0x3d4, 0x05, 0x9a},{ 0x3d4, 0x06, 0x4e},{ 0x3d4, 0x07, 0x1f},
+	{ 0x3d4, 0x08, 0x00},{ 0x3d4, 0x09, 0x40},{ 0x3d4, 0x10, 0x40},
+	{ 0x3d4, 0x11, 0x90},{ 0x3d4, 0x12, 0x3f},{ 0x3d4, 0x13, 0x19},
+	{ 0x3d4, 0x14, 0x40},{ 0x3d4, 0x15, 0x80},{ 0x3d4, 0x16, 0x40},
+	{ 0x3d4, 0x17, 0xa3},{ 0x3c4, 0x01, 0x01},{ 0x3c4, 0x04, 0x0e}
+};
+
+Register *make_scanline_mode(Register *inreg,int entries)
+{
+	static Register outreg[32];
+	int maxscan,maxscanout;
+	int overflow,overflowout;
+	int ytotalin,ytotalout;
+	int ydispin,ydispout;
+	int vrsin,vrsout,vreout,vblksout,vblkeout;
+/* first - check's it not already a 'non doubled' line mode */
+	maxscan = inreg[MAXIMUM_SCANLINE_INDEX].value;
+	if ((maxscan & 1) == 0)
+	/* it is, so just return the array as is */
+  		return inreg;
+/* copy across our standard display array */
+	memcpy (&outreg, inreg, entries * sizeof(Register));
+/* keep hold of the overflow register - as we'll need to refer to it a lot */
+	overflow = inreg[OVERFLOW_INDEX].value;
+/* set a large line compare value  - as we won't be doing any split window scrolling etc.*/
+	maxscanout = 0x40;
+/* half all the y values */
+/* total */
+	ytotalin = inreg[V_TOTAL_INDEX].value;
+	ytotalin |= ((overflow & 1)<<0x08) | ((overflow & 0x20)<<0x04);
+    ytotalout = ytotalin >> 1;
+/* display enable end */
+	ydispin = inreg[13].value | ((overflow & 0x02)<< 0x07) | ((overflow & 0x040) << 0x03);
+	ydispin ++;
+	ydispout = ydispin >> 1;
+	ydispout --;
+	overflowout = ((ydispout & 0x100) >> 0x07) | ((ydispout && 0x200) >> 0x03);
+	outreg[V_END_INDEX].value = (ydispout & 0xff);
+/* avoid top over scan */
+	if ((ytotalin - ydispin) < 40 && !center_y)
+	{
+  		vrsout = ydispout;
+		/* give ourselves a scanline cushion */
+		ytotalout += 2;
+	}
+  	else
+	{
+/* vertical retrace start */
+		vrsin = inreg[V_RETRACE_START_INDEX].value | ((overflow & 0x04)<<0x06) | ((overflow & 0x80)<<0x02);
+		vrsout = vrsin >> 1;
+	}
+/* check it's legal */
+	if (vrsout < ydispout)
+		vrsout = ydispout;
+/*update our output overflow */
+	overflowout |= (((vrsout & 0x100) >> 0x06) | ((vrsout & 0x200) >> 0x02));
+	outreg[V_RETRACE_START_INDEX].value = (vrsout & 0xff);
+/* vertical retrace end */
+	vreout = vrsout + 2;
+/* make sure the retrace fits into our adjusted display size */
+	if (vreout > (ytotalout - 9))
+		ytotalout = vreout + 9;
+/* write out the vertical retrace end */
+	outreg[V_RETRACE_END_INDEX].value &= ~0x0f;
+	outreg[V_RETRACE_END_INDEX].value |= (vreout & 0x0f);
+/* vertical blanking start */
+	vblksout = ydispout + 1;
+/* check it's legal */
+	if(vblksout > vreout)
+		vblksout = vreout;
+/* save the overflow value */
+	overflowout |= ((vblksout & 0x100) >> 0x05);
+	maxscanout |= ((vblksout & 0x200) >> 0x04);
+/* write the v blank value out */
+	outreg[V_BLANKING_START_INDEX].value = (vblksout & 0xff);
+/* vertical blanking end */
+	vblkeout = vreout + 1;
+/* make sure the blanking fits into our adjusted display size */
+	if (vblkeout > (ytotalout - 9))
+		ytotalout = vblkeout + 9;
+/* write out the vertical blanking total */
+	outreg[V_BLANKING_END_INDEX].value = (vblkeout & 0xff);
+/* update our output overflow */
+	overflowout |= ((ytotalout & 0x100) >> 0x08) | ((ytotalout & 0x200) >> 0x04);
+/* write out the new vertical total */
+	outreg[V_TOTAL_INDEX].value = (ytotalout & 0xff);
+
+/* write out our over flows */
+	outreg[OVERFLOW_INDEX].value = overflowout;
+/* finally the max scan line */
+	outreg[MAXIMUM_SCANLINE_INDEX].value = maxscanout;
+/* and we're done */
+	return outreg;
+
+}
+
+void center_mode(Register *pReg)
+{
+	int center;
+	int hrt_start, hrt_end, hrt, hblnk_start, hblnk_end;
+	int vrt_start, vrt_end, vert_total, vert_display, vblnk_start, vrt, vblnk_end;
+/* check for empty array */
+	if (!pReg)
+		return;
+/* vertical retrace width */
+	vrt = 2;
+/* check the clock speed, to work out the retrace width */
+	if (pReg[CLOCK_INDEX].value == 0xe7)
+		hrt = 11;
+	else
+		hrt = 10;
+/* our center x tweak value */
+	center = center_x;
+/* check for double width scanline rather than half clock (15.75kHz modes) */
+	if( pReg[H_TOTAL_INDEX].value > 0x96)
+	{
+		center<<=1;
+		hrt<<=1;
+	}
+/* set the hz retrace */
+	hrt_start = pReg[H_RETRACE_START_INDEX].value;
+	hrt_start += center;
+/* make sure it's legal */
+	if (hrt_start <= pReg[H_DISPLAY_INDEX].value)
+		hrt_start = pReg[H_DISPLAY_INDEX].value + 1;
+	pReg[H_RETRACE_START_INDEX].value = hrt_start;
+/* set hz retrace end */
+	hrt_end = hrt_start + hrt;
+/* make sure it's legal */
+	if( hrt_end > pReg[H_TOTAL_INDEX].value)
+		hrt_end = pReg[H_TOTAL_INDEX].value;
+
+/* set the hz blanking */
+	hblnk_start = pReg[H_DISPLAY_INDEX].value + 1;
+/* make sure it's legal */
+	if (hblnk_start > hrt_start)
+		hblnk_start = pReg[H_RETRACE_START_INDEX].value;
+
+	pReg[H_BLANKING_START_INDEX].value = hblnk_start;
+/* the horizontal blanking end */
+	hblnk_end = hrt_end + 2;
+/* make sure it's legal */
+	if( hblnk_end > pReg[H_TOTAL_INDEX].value)
+		hblnk_end = pReg[H_TOTAL_INDEX].value;
+/* write horizontal blanking - include 7th test bit (always 1) */
+	pReg[H_BLANKING_END_INDEX].value = (hblnk_end & 0x1f) | 0x80;
+/* include the 5th bit of the horizontal blanking in the horizontal retrace reg. */
+	hrt_end = ((hrt_end & 0x1f) | ((hblnk_end & 0x20) << 2));
+	pReg[H_RETRACE_END_INDEX].value = hrt_end;
+
+
+/* get the vt retrace */
+	vrt_start = pReg[V_RETRACE_START_INDEX].value | ((pReg[OVERFLOW_INDEX].value & 0x04) << 6) |
+				((pReg[OVERFLOW_INDEX].value & 0x80) << 2);
+
+/* set the new retrace start */
+	vrt_start += center_y;
+/* check it's legal, get the display line count */
+	vert_display = (pReg[V_END_INDEX].value | ((pReg[OVERFLOW_INDEX].value & 0x02) << 7) |
+				((pReg[OVERFLOW_INDEX].value & 0x40) << 3)) + 1;
+
+	if (vrt_start < vert_display)
+		vrt_start = vert_display;
+
+/* and get the vertical line count */
+	vert_total = pReg[V_TOTAL_INDEX].value | ((pReg[OVERFLOW_INDEX].value & 0x01) << 8) |
+				((pReg[OVERFLOW_INDEX].value & 0x20) << 4);
+
+
+
+	pReg[V_RETRACE_START_INDEX].value = (vrt_start & 0xff);
+	pReg[OVERFLOW_INDEX].value &= ~0x84;
+	pReg[OVERFLOW_INDEX].value |= ((vrt_start & 0x100) >> 6);
+	pReg[OVERFLOW_INDEX].value |= ((vrt_start & 0x200) >> 2);
+	vrt_end = vrt_start + vrt;
+
+
+	if (vrt_end > vert_total)
+		vrt_end = vert_total;
+
+/* write retrace end, include CRT protection and IRQ2 bits */
+	pReg[V_RETRACE_END_INDEX].value = (vrt_end  & 0x0f) | 0x80 | 0x20;
+
+/* get the start of vt blanking */
+	vblnk_start = vert_display + 1;
+/* check it's legal */
+	if (vblnk_start > vrt_start)
+		vblnk_start = vrt_start;
+/* and the end */
+	vblnk_end = vrt_end + 2;
+/* check it's legal */
+	if (vblnk_end > vert_total)
+		vblnk_end = vert_total;
+/* set vblank start */
+	pReg[V_BLANKING_START_INDEX].value = (vblnk_start & 0xff);
+/* write out any overflows */
+	pReg[OVERFLOW_INDEX].value &= ~0x08;
+	pReg[OVERFLOW_INDEX].value |= ((vblnk_start & 0x100) >> 5);
+	pReg[MAXIMUM_SCANLINE_INDEX].value &= ~0x20;
+	pReg[MAXIMUM_SCANLINE_INDEX].value |= ((vblnk_start &0x200) >> 4);
+/* set the vblank end */
+	pReg[V_BLANKING_END_INDEX].value = (vblnk_end & 0xff);
+}
+
+#endif /* ifndef __TWKMODES_H */
diff --git a/src/unix/video-drivers/twkuser.c b/src/unix/video-drivers/twkuser.c
new file mode 100644
index 0000000..843c7e8
--- /dev/null
+++ b/src/unix/video-drivers/twkuser.c
@@ -0,0 +1,151 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <fcntl.h>
+/* make ansi compilation happy */
+#define inline __inline__
+#if defined(__ARCH_freebsd)
+#include <machine/cpufunc.h>
+#else
+#include <asm/io.h>
+#endif
+#undef inline
+#include "twkuser.h"
+
+/*
+    readyVgaRegs() does the initialization to make the VGA ready to
+	accept any combination of configuration register settings.
+
+	This involves enabling writes to index 0 to 7 of the CRT controller
+	(port 0x3d4), by clearing the most significant bit (bit 7) of index
+	0x11.
+*/
+
+void readyVgaRegs(void)
+	{
+	int v;
+
+	   /*
+	   outportb(0x3d4,0x11);
+    v = inportb(0x3d5) & 0x7f;
+	outportb(0x3d4,0x11);
+	outportb(0x3d5,v);
+	   */
+	   
+	   outb(0x11,0x3d4);
+	   v = inb(0x3d5) & 0x7f;
+	   outb(0x11,0x3d4);
+	   outb(v,0x3d5);
+	   
+	
+	}
+
+/*
+	outReg sets a single register according to the contents of the
+	passed Register structure.
+*/
+
+void outReg(Register r)
+	{
+	switch (r.port)
+		{
+		/* First handle special cases: */
+
+		case ATTRCON_ADDR:
+			inb(STATUS_ADDR);  		/* reset read/write flip-flop */
+			outb(r.index | 0x20,ATTRCON_ADDR);
+										/* ensure VGA output is enabled */
+			outb(r.value,ATTRCON_ADDR);
+			break;
+
+		case MISC_ADDR:
+		case VGAENABLE_ADDR:
+			outb(r.value,r.port);	/*	directly to the port */
+			break;
+
+		case SEQ_ADDR:
+		case GRACON_ADDR:
+		case CRTC_ADDR:
+		default:						/* This is the default method: */
+			outb(r.index,r.port);	/*	index to port			   */
+			outb(r.value,r.port+1);/*	value to port+1 		   */
+			break;
+		}
+	}
+
+
+/*
+	outRegArray sets n registers according to the array pointed to by r.
+	First, indexes 0-7 of the CRT controller are enabled for writing.
+*/
+
+void outRegArray(Register *r, int n)
+	{
+    readyVgaRegs();
+	while (n--)
+		outReg(*r++);
+	}
+
+
+/*
+	loadRegArray opens the given file, does some validity checking, then
+	reads the entire file into an array of Registers, which is returned
+	via the array parameter.
+
+	You will probably want to provide your own error handling code in
+	this function, as it never aborts the program, rather than just
+	printing an error message and returning NULL.
+
+	The returned value is the number of Registers read.  The &array
+	parameter is set to the allocated Register array.
+
+	If you use this function, remember to free() the returned array
+	pointer, as it was allocated dynamically using malloc() (unless NULL
+	is returned, which designates an error)!
+*/
+
+#if 0
+int loadRegArray(char *fpath, RegisterPtr *array)
+	{
+	int handle, regs;
+	long fsize;
+	*array = NULL;
+
+	if ((handle = open(fpath, O_BINARY | O_RDONLY)) == -1)
+		/* error opening file */
+		/* include your error handling code here */
+		goto fileerror;
+
+    if ((fsize = filelength(handle)) == -1)
+		/* error acquiring file size */
+		goto fileerror;
+	if (fsize % sizeof(Register))
+		{
+		fprintf(stderr_file, "Illegal TWEAK file size: %s\n", fpath);
+		return 0;
+		}
+	regs = fsize / sizeof(Register);
+
+    if (!(*array = (Register *)malloc(fsize)))
+		{
+		fprintf(stderr_file, "Out of memory allocating buffer for %s\n", fpath);
+		return 0;
+		}
+	if (read(handle, (void*)*array, fsize) == -1)
+		/* error reading file */
+		goto fileerror;
+
+    if (close(handle) == -1)
+		{
+		/* error closing file */
+		goto fileerror;
+		}
+
+	/* file read ok, return pointer to buffer */
+	return regs;
+
+fileerror:
+	perror(fpath);
+	if (*array) free(*array);
+	return 0;
+	}
+#endif
diff --git a/src/unix/video-drivers/twkuser.h b/src/unix/video-drivers/twkuser.h
new file mode 100644
index 0000000..c929f1b
--- /dev/null
+++ b/src/unix/video-drivers/twkuser.h
@@ -0,0 +1,45 @@
+#ifndef _TwkUser_h
+#define _TwkUser_h
+
+/*
+	xxxxADDR defines the base port number used to access VGA component xxxx,
+	and is defined for xxxx =
+		ATTRCON		-	Attribute Controller
+		MISC		-	Miscellaneous Register
+		VGAENABLE	-	VGA Enable Register
+		SEQ			-	Sequencer
+		GRACON		-	Graphics Controller
+		CRTC		-	Cathode Ray Tube Controller
+		STATUS		-	Status Register
+*/
+
+#define ATTRCON_ADDR	0x3c0
+#define MISC_ADDR		0x3c2
+#define VGAENABLE_ADDR	0x3c3
+#define SEQ_ADDR		0x3c4
+#define GRACON_ADDR		0x3ce
+#define CRTC_ADDR		0x3d4
+#define STATUS_ADDR		0x3da
+
+
+/*
+	Note that the following C definition of Register is not compatible
+	with the C++ definition used in the source code of TWEAK itself!
+*/
+
+typedef struct
+	{
+	unsigned port;
+	unsigned char index;
+	unsigned char value;
+	} Register;
+
+typedef Register *RegisterPtr;
+
+void readyVgaRegs(void);
+void outRegArray(Register *r, int n);
+void outReg(Register r);
+int loadRegArray(char *fpath, RegisterPtr *array);
+
+#endif
+
diff --git a/src/unix/video-drivers/vectorgen.c b/src/unix/video-drivers/vectorgen.c
new file mode 100644
index 0000000..7ff661a
--- /dev/null
+++ b/src/unix/video-drivers/vectorgen.c
@@ -0,0 +1,33 @@
+#include "xmame.h"
+#include "driver.h"
+#include "vidhrdw/vector.h"
+
+/* glvec.c, ... */
+extern void vector_vh_update(struct mame_bitmap *bitmap,int full_refresh);
+
+static float intensity_correction = 1.0;
+
+void vector_set_gamma(float gamma)
+{
+	palette_set_global_gamma(gamma);
+}
+
+float vector_get_gamma(void)
+{
+	return palette_get_global_gamma();
+}
+
+void vector_set_intensity(float _intensity)
+{
+	intensity_correction = _intensity;
+}
+
+float vector_get_intensity(void)
+{
+	return intensity_correction;
+}
+
+void vector_vh_screenrefresh(struct mame_bitmap *bitmap,int full_refresh)
+{
+	vector_vh_update(bitmap, full_refresh);
+}
diff --git a/src/unix/video-drivers/vroot.h b/src/unix/video-drivers/vroot.h
new file mode 100644
index 0000000..ba3e5d2
--- /dev/null
+++ b/src/unix/video-drivers/vroot.h
@@ -0,0 +1,126 @@
+/*****************************************************************************/
+/**                   Copyright 1991 by Andreas Stolcke                     **/
+/**               Copyright 1990 by Solbourne Computer Inc.                 **/
+/**                          Longmont, Colorado                             **/
+/**                                                                         **/
+/**                           All Rights Reserved                           **/
+/**                                                                         **/
+/**    Permission to use, copy, modify, and distribute this software and    **/
+/**    its documentation  for  any  purpose  and  without  fee is hereby    **/
+/**    granted, provided that the above copyright notice appear  in  all    **/
+/**    copies and that both  that  copyright  notice  and  this  permis-    **/
+/**    sion  notice appear in supporting  documentation,  and  that  the    **/
+/**    name of Solbourne not be used in advertising                         **/
+/**    in publicity pertaining to distribution of the  software  without    **/
+/**    specific, written prior permission.                                  **/
+/**                                                                         **/
+/**    ANDREAS STOLCKE AND SOLBOURNE COMPUTER INC. DISCLAIMS ALL WARRANTIES **/
+/**    WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF    **/
+/**    MERCHANTABILITY  AND  FITNESS,  IN  NO  EVENT SHALL ANDREAS STOLCKE  **/
+/**    OR SOLBOURNE BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL    **/
+/**    DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA   **/
+/**    OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER    **/
+/**    TORTIOUS ACTION, ARISING OUT OF OR IN  CONNECTION  WITH  THE  USE    **/
+/**    OR PERFORMANCE OF THIS SOFTWARE.                                     **/
+/*****************************************************************************/
+/*
+ * vroot.h -- Virtual Root Window handling header file
+ *
+ * This header file redefines the X11 macros RootWindow and DefaultRootWindow,
+ * making them look for a virtual root window as provided by certain `virtual'
+ * window managers like swm and tvtwm. If none is found, the ordinary root
+ * window is returned, thus retaining backward compatibility with standard
+ * window managers.
+ * The function implementing the virtual root lookup remembers the result of
+ * its last invocation to avoid overhead in the case of repeated calls
+ * on the same display and screen arguments. 
+ * The lookup code itself is taken from Tom LaStrange's ssetroot program.
+ *
+ * Most simple root window changing X programs can be converted to using
+ * virtual roots by just including
+ *
+ * #include <X11/vroot.h>
+ *
+ * after all the X11 header files.  It has been tested on such popular
+ * X clients as xphoon, xfroot, xloadimage, and xaqua.
+ * It also works with the core clients xprop, xwininfo, xwd, and editres
+ * (and is necessary to get those clients working under tvtwm).
+ * It does NOT work with xsetroot; get the xsetroot replacement included in
+ * the tvtwm distribution instead.
+ *
+ * Andreas Stolcke <stolcke@ICSI.Berkeley.EDU>, 9/7/90
+ * - replaced all NULL's with properly cast 0's, 5/6/91
+ * - free children list (suggested by Mark Martin <mmm@cetia.fr>), 5/16/91
+ * - include X11/Xlib.h and support RootWindowOfScreen, too 9/17/91
+ */
+
+#ifndef _VROOT_H_
+#define _VROOT_H_
+
+#if !defined(lint) && !defined(SABER)
+static const char vroot_rcsid[] = "#Id: vroot.h,v 1.4 1991/09/30 19:23:16 stolcke Exp stolcke #";
+#endif
+
+#include <X11/X.h>
+#include <X11/Xatom.h>
+#include <X11/Xlib.h>
+
+static Window
+#ifdef __STDC__ /* ANSIfication added by jwz, to avoid superfluous warnings. */
+VirtualRootWindowOfScreen(Screen *screen)
+#else /* !__STDC__ */
+VirtualRootWindowOfScreen(screen) Screen *screen;
+#endif /* !__STDC__ */
+{
+	static Screen *save_screen = (Screen *)0;
+	static Window root = (Window)0;
+
+	if (screen != save_screen) {
+		Display *dpy = DisplayOfScreen(screen);
+		Atom __SWM_VROOT = None;
+		int i;
+		Window rootReturn, parentReturn, *children;
+		unsigned int numChildren;
+
+		root = RootWindowOfScreen(screen);
+
+		/* go look for a virtual root */
+		__SWM_VROOT = XInternAtom(dpy, "__SWM_VROOT", False);
+		if (XQueryTree(dpy, root, &rootReturn, &parentReturn,
+				 &children, &numChildren)) {
+			for (i = 0; i < numChildren; i++) {
+				Atom actual_type;
+				int actual_format;
+				unsigned long nitems, bytesafter;
+				Window *newRoot = (Window *)0;
+
+				if (XGetWindowProperty(dpy, children[i],
+					__SWM_VROOT, 0, 1, False, XA_WINDOW,
+					&actual_type, &actual_format,
+					&nitems, &bytesafter,
+					(unsigned char **) &newRoot) == Success
+				    && newRoot) {
+				    root = *newRoot;
+				    break;
+				}
+			}
+			if (children)
+				XFree((char *)children);
+		}
+
+		save_screen = screen;
+	}
+
+	return root;
+}
+
+#undef RootWindowOfScreen
+#define RootWindowOfScreen(s) VirtualRootWindowOfScreen(s)
+
+#undef RootWindow
+#define RootWindow(dpy,screen) VirtualRootWindowOfScreen(ScreenOfDisplay(dpy,screen))
+
+#undef DefaultRootWindow
+#define DefaultRootWindow(dpy) VirtualRootWindowOfScreen(DefaultScreenOfDisplay(dpy))
+
+#endif /* _VROOT_H_ */
diff --git a/src/unix/video-drivers/wgl-disp-fetch.hc b/src/unix/video-drivers/wgl-disp-fetch.hc
new file mode 100644
index 0000000..8591d0c
--- /dev/null
+++ b/src/unix/video-drivers/wgl-disp-fetch.hc
@@ -0,0 +1,32 @@
+/* WARNING ! WARNING *** THIS FILE IS GENERATED BY C2J !!!
+
+   DO NOT MAKE ANY CHANGES *** MAKE CHANGES IN THE SKELETON FILES !!!
+*/
+
+
+
+	disp__wglCopyContext = (BOOL  (CALLBACK *)(HGLRC, HGLRC, UINT))
+        GET_GL_PROCADDRESS("wglCopyContext");
+
+	disp__wglCreateContext = (HGLRC  (CALLBACK *)(HDC))
+        GET_GL_PROCADDRESS("wglCreateContext");
+
+	disp__wglCreateLayerContext = (HGLRC  (CALLBACK *)(HDC, int))
+        GET_GL_PROCADDRESS("wglCreateLayerContext");
+
+	disp__wglDeleteContext = (BOOL  (CALLBACK *)(HGLRC))
+        GET_GL_PROCADDRESS("wglDeleteContext");
+
+	disp__wglGetCurrentContext = (HGLRC  (CALLBACK *)(VOID))
+        GET_GL_PROCADDRESS("wglGetCurrentContext");
+
+	disp__wglGetCurrentDC = (HDC  (CALLBACK *)(VOID))
+        GET_GL_PROCADDRESS("wglGetCurrentDC");
+
+	disp__wglMakeCurrent = (BOOL  (CALLBACK *)(HDC, HGLRC))
+        GET_GL_PROCADDRESS("wglMakeCurrent");
+
+	disp__wglShareLists = (BOOL  (CALLBACK *)(HGLRC, HGLRC))
+        GET_GL_PROCADDRESS("wglShareLists");
+
+
diff --git a/src/unix/video-drivers/wgl-disp-var.h b/src/unix/video-drivers/wgl-disp-var.h
new file mode 100644
index 0000000..642cd38
--- /dev/null
+++ b/src/unix/video-drivers/wgl-disp-var.h
@@ -0,0 +1,18 @@
+/* WARNING ! WARNING *** THIS FILE IS GENERATED BY C2J !!!
+
+   DO NOT MAKE ANY CHANGES *** MAKE CHANGES IN THE SKELETON FILES !!!
+*/
+
+
+
+LIBAPI PROC  (CALLBACK * disp__wglGetProcAddress)(LPCSTR);
+LIBAPI BOOL  (CALLBACK * disp__wglCopyContext)(HGLRC, HGLRC, UINT);
+LIBAPI HGLRC (CALLBACK * disp__wglCreateContext)(HDC);
+LIBAPI HGLRC (CALLBACK * disp__wglCreateLayerContext)(HDC, int);
+LIBAPI BOOL  (CALLBACK * disp__wglDeleteContext)(HGLRC);
+LIBAPI HGLRC (CALLBACK * disp__wglGetCurrentContext)(VOID);
+LIBAPI HDC   (CALLBACK * disp__wglGetCurrentDC)(VOID);
+LIBAPI BOOL  (CALLBACK * disp__wglMakeCurrent)(HDC, HGLRC);
+LIBAPI BOOL  (CALLBACK * disp__wglShareLists)(HGLRC, HGLRC);
+
+
diff --git a/src/unix/video-drivers/wgl-disp-var.hc b/src/unix/video-drivers/wgl-disp-var.hc
new file mode 100644
index 0000000..afebb31
--- /dev/null
+++ b/src/unix/video-drivers/wgl-disp-var.hc
@@ -0,0 +1,17 @@
+/* WARNING ! WARNING *** THIS FILE IS GENERATED BY C2J !!!
+
+   DO NOT MAKE ANY CHANGES *** MAKE CHANGES IN THE SKELETON FILES !!!
+*/
+
+
+PROC  (CALLBACK * disp__wglGetProcAddress)(LPCSTR) = NULL;
+BOOL  (CALLBACK * disp__wglCopyContext)(HGLRC, HGLRC, UINT) = NULL;
+HGLRC (CALLBACK * disp__wglCreateContext)(HDC) = NULL;
+HGLRC (CALLBACK * disp__wglCreateLayerContext)(HDC, int) = NULL;
+BOOL  (CALLBACK * disp__wglDeleteContext)(HGLRC) = NULL;
+HGLRC (CALLBACK * disp__wglGetCurrentContext)(VOID) = NULL;
+HDC   (CALLBACK * disp__wglGetCurrentDC)(VOID) = NULL;
+BOOL  (CALLBACK * disp__wglMakeCurrent)(HDC, HGLRC) = NULL;
+BOOL  (CALLBACK * disp__wglShareLists)(HGLRC, HGLRC) = NULL;
+
+
diff --git a/src/unix/video-drivers/wgltool.c b/src/unix/video-drivers/wgltool.c
new file mode 100644
index 0000000..d57335c
--- /dev/null
+++ b/src/unix/video-drivers/wgltool.c
@@ -0,0 +1,752 @@
+/**
+ * glxtool.c
+ *
+ * Copyright (C) 2001  Sven Goethel
+ *
+ * GNU Library General Public License 
+ * as published by the Free Software Foundation
+ *
+ * http://www.gnu.org/copyleft/lgpl.html
+ * General dynamical loading OpenGL (GL/GLU) support for:
+ */
+
+#include "wgltool.h"
+
+#include "wgl-disp-var.hc"
+
+/**
+ * do not call this one directly,
+ * use fetch_GL_FUNCS (gltool.c) instead
+ */
+void LIBAPIENTRY fetch_WGL_FUNCS (const char * libGLName, 
+			          const char * libGLUName, int force)
+{
+  static int _firstRun = 1;
+
+  if(force)
+        _firstRun = 1;
+
+  if(!_firstRun)
+  	return;
+
+  if(!loadGLLibrary (libGLName, libGLUName))
+  	return;
+
+  #define GET_GL_PROCADDRESS(a) getGLProcAddressHelper (libGLName, libGLUName, (a), NULL, 1, 0);
+
+
+  #include "wgl-disp-fetch.hc"
+
+  _firstRun=0;
+}
+
+
+HGLRC LIBAPIENTRY get_GC( HDC * hDC, GLCapabilities *glCaps,
+		HGLRC shareWith, 
+		int offScreenRenderer,
+		int width, int height, HBITMAP *pix,
+		int verbose)
+
+{
+	const char * text=0;
+	HDC hDCOrig = 0;
+
+	// Color Palette handle
+	HPALETTE hPalette = NULL;
+	HGLRC tempRC=0;
+
+    if( *hDC == 0 && !offScreenRenderer)
+		printf( "get_GC: Error, HDC is zero\n");
+
+	// Select the pixel format
+	if(offScreenRenderer)
+	{
+		hDCOrig = *hDC;
+		*hDC = CreateCompatibleDC(hDCOrig);
+		// setupDIB(*hDC, pix, width, height);
+		setupDIB(hDCOrig, *hDC, pix, width, height);
+		/* SetDCPixelFormat(hDCOffScr, doubleBuffer, stereo, stencilBits, offScreenRenderer); */
+		/* setupPalette(hDC); USE MY PROC */
+	}
+
+	SetDCPixelFormat(*hDC, glCaps, offScreenRenderer, verbose);
+
+	// Create palette if needed
+	hPalette = GetOpenGLPalette(*hDC);
+
+    tempRC = disp__wglCreateContext( *hDC );
+
+	if(verbose)
+	{
+		fprintf(stderr,"\n\nPIXELFORMAT OF GL-Context SETTINGS:\n");
+		text=GetTextualPixelFormatByHDC(*hDC);
+		fprintf(stderr,text);
+	}
+
+    /* check if the context could be created */
+    if( tempRC == NULL ) {
+        fprintf(stderr, "getGC context could NOT be created \n");
+        return( 0 );
+    }
+
+    /* associated the context with the X window */
+    if( disp__wglMakeCurrent( *hDC, tempRC ) == FALSE) {
+		fprintf(stderr,"wglMakeCurrent(%p,%p) failed on new context!!!\n", *hDC,tempRC);
+		fprintf(stderr,"Error code = %d\n",(int)GetLastError());
+		disp__wglMakeCurrent(NULL, NULL);
+		disp__wglDeleteContext( tempRC );
+        return( 0 );
+    }
+
+	if(shareWith!=NULL && disp__wglShareLists(shareWith, tempRC)==FALSE)
+	{
+		fprintf(stderr,"\nERROR: Could not share lists between the new and the given GLContext (Win32Native)!\n");
+		fprintf(stderr,"Error code = %d\n",(int)GetLastError());
+		disp__wglMakeCurrent(NULL, NULL);
+		disp__wglDeleteContext( tempRC );
+        return( 0 );
+	}
+
+    if(verbose)
+			printf( "HGLRC (glContext) created: %p\n", tempRC );
+
+    return tempRC;
+}
+
+void LIBAPIENTRY setPixelFormatByGLCapabilities( 
+					PIXELFORMATDESCRIPTOR *pfd,
+				        GLCapabilities *glCaps,
+					int offScreenRenderer,
+					HDC hdc)
+{
+
+	int colorBits = glCaps->redBits + glCaps->greenBits + glCaps->blueBits;
+
+	pfd->nSize=sizeof(PIXELFORMATDESCRIPTOR); 
+	pfd->nVersion=1; 
+	pfd->dwFlags=PFD_SUPPORT_OPENGL | PFD_GENERIC_ACCELERATED; /* refined later */
+	pfd->iPixelType=0; 
+	pfd->cColorBits=0; 
+	pfd->cRedBits=0; 
+	pfd->cRedShift=0; 
+	pfd->cGreenBits=0; 
+	pfd->cGreenShift=0; 
+	pfd->cBlueBits=0; 
+	pfd->cBlueShift=0; 
+	pfd->cAlphaBits=0; 
+	pfd->cAlphaShift=0; 
+	pfd->cAccumBits=0; 
+	pfd->cAccumRedBits=0; 
+	pfd->cAccumGreenBits=0; 
+	pfd->cAccumBlueBits=0; 
+	pfd->cAccumAlphaBits=0; 
+	pfd->cDepthBits=32; 
+	pfd->cStencilBits=0; 
+	pfd->cAuxBuffers=0; 
+	pfd->iLayerType=PFD_MAIN_PLANE; 
+	pfd->bReserved=0; 
+	pfd->dwLayerMask=0; 
+	pfd->dwVisibleMask=0; 
+	pfd->dwDamageMask=0; 
+ 
+    if(COLOR_RGBA == glCaps->color)
+		pfd->iPixelType=PFD_TYPE_RGBA; 
+	else
+		pfd->iPixelType=PFD_TYPE_COLORINDEX; 
+
+    if(offScreenRenderer)
+		pfd->dwFlags |= PFD_DRAW_TO_BITMAP;           // Draw to Bitmap
+	else
+		pfd->dwFlags |= PFD_DRAW_TO_WINDOW;           // Draw to Window (not to bitmap)
+
+
+    if(BUFFER_DOUBLE==glCaps->buffer)
+		pfd->dwFlags |= PFD_DOUBLEBUFFER ;  // Double buffered is optional
+
+    if(STEREO_ON==glCaps->stereo)
+		pfd->dwFlags |= PFD_STEREO ;        // Stereo is optional
+
+    if(hdc!=NULL && GetDeviceCaps(hdc, BITSPIXEL)<colorBits)
+    	    pfd->cColorBits = GetDeviceCaps(hdc, BITSPIXEL);
+        else
+    pfd->cColorBits = (BYTE)colorBits;
+
+	pfd->cStencilBits = (BYTE) glCaps->stencilBits;
+}
+
+
+void LIBAPIENTRY SetDCPixelFormat(HDC hDC, GLCapabilities *glCaps,
+		                  int offScreenRenderer, int verbose)
+{
+    int nPixelFormat=-1;
+	const char * text=0;
+
+    PIXELFORMATDESCRIPTOR pfd ;
+
+    if(verbose)
+    {
+	fprintf(stdout, "GL4Java SetDCPixelFormat: input capabilities:\n");
+	printGLCapabilities ( glCaps );
+    }
+
+    if(glCaps->nativeVisualID>=0)
+    {
+            if ( 0 < DescribePixelFormat( hDC, (int)(glCaps->nativeVisualID), 
+	                                  sizeof(pfd), &pfd ) )
+	    {
+	        nPixelFormat=(int)(glCaps->nativeVisualID);
+	        if(verbose)
+		{
+		  fprintf(stderr,"\n\nUSER found stored PIXELFORMAT number: %ld\n",
+		  	nPixelFormat);
+		  fflush(stderr);
+		}	
+	    } else {
+		  fprintf(stderr,"\n\nUSER no stored PIXELFORMAT number found !!\n");
+           nPixelFormat = -1;
+		  fflush(stderr);
+	    }
+	}
+
+    if(nPixelFormat<0)
+        setPixelFormatByGLCapabilities( &pfd, glCaps, offScreenRenderer, hDC);
+
+    if(verbose)
+    {
+		fprintf(stderr,"\n\nUSER CHOOSED PIXELFORMAT (TRYING):\n");
+		text=GetTextualPixelFormatByPFD(&pfd, nPixelFormat);			
+		fprintf(stderr,text);
+		fflush(stderr);
+    }
+
+    // Choose a pixel format that best matches that described in pfd
+    if( hDC == 0 )
+	    printf( "SetDCPixelFormat: Error, no HDC-Contex is given\n");
+    else if(nPixelFormat<0)
+	    nPixelFormat = ChoosePixelFormat(hDC, &pfd);
+
+    if( nPixelFormat == 0 )
+	    printf( "SetDCPixelFormat: Error with PixelFormat\n" );
+
+    // Set the pixel format for the device context
+    if( SetPixelFormat(hDC, nPixelFormat, &pfd) == FALSE)
+	    printf( "setpixel failed\n" );
+    else {
+            (void) setGLCapabilities ( hDC, nPixelFormat, glCaps );
+	    if(verbose)
+	    {
+	        fprintf(stdout, "GL4Java SetDCPixelFormat: used capabilities:\n");
+	        printGLCapabilities ( glCaps );
+	    }
+    }
+	fflush(stdout);
+	fflush(stderr);
+}
+
+
+// If necessary, creates a 3-3-2 palette for the device context listed.
+HPALETTE LIBAPIENTRY GetOpenGLPalette(HDC hDC)
+{
+    HPALETTE hRetPal = NULL;	// Handle to palette to be created
+    PIXELFORMATDESCRIPTOR pfd;	// Pixel Format Descriptor
+    LOGPALETTE *pPal=0;			// Pointer to memory for logical palette
+    int nPixelFormat=0;			// Pixel format index
+    int nColors=0;				// Number of entries in palette
+    int i=0;						// Counting variable
+    BYTE RedRange=0,GreenRange=0,BlueRange=0;
+							    // Range for each color entry (7,7,and 3)
+
+
+    // Get the pixel format index and retrieve the pixel format description
+    nPixelFormat = GetPixelFormat(hDC);
+    DescribePixelFormat(hDC, nPixelFormat, sizeof(PIXELFORMATDESCRIPTOR), &pfd);
+
+    // Does this pixel format require a palette?  If not, do not create a
+    // palette and just return NULL
+    if(!(pfd.dwFlags & PFD_NEED_PALETTE))
+	    return NULL;
+
+    // Number of entries in palette.  8 bits yeilds 256 entries
+    nColors = 1 << pfd.cColorBits;	
+
+    // Allocate space for a logical palette structure plus all the palette entries
+    pPal = (LOGPALETTE*)malloc(sizeof(LOGPALETTE) + nColors*sizeof(PALETTEENTRY));
+
+    // Fill in palette header
+    pPal->palVersion = 0x300;		// Windows 3.0
+    pPal->palNumEntries = nColors; // table size
+
+    // Build mask of all 1's.  This creates a number represented by having
+    // the low order x bits set, where x = pfd.cRedBits, pfd.cGreenBits, and
+    // pfd.cBlueBits.  
+    RedRange = (1 << pfd.cRedBits) -1;
+    GreenRange = (1 << pfd.cGreenBits) - 1;
+    BlueRange = (1 << pfd.cBlueBits) -1;
+
+    // Loop through all the palette entries
+    for(i = 0; i < nColors; i++)
+	    {
+	    // Fill in the 8-bit equivalents for each component
+	    pPal->palPalEntry[i].peRed = (i >> pfd.cRedShift) & RedRange;
+	    pPal->palPalEntry[i].peRed = (unsigned char)(
+		    (double) pPal->palPalEntry[i].peRed * 255.0 / RedRange);
+
+	    pPal->palPalEntry[i].peGreen = (i >> pfd.cGreenShift) & GreenRange;
+	    pPal->palPalEntry[i].peGreen = (unsigned char)(
+		    (double)pPal->palPalEntry[i].peGreen * 255.0 / GreenRange);
+
+	    pPal->palPalEntry[i].peBlue = (i >> pfd.cBlueShift) & BlueRange;
+	    pPal->palPalEntry[i].peBlue = (unsigned char)(
+		    (double)pPal->palPalEntry[i].peBlue * 255.0 / BlueRange);
+
+	    pPal->palPalEntry[i].peFlags = (unsigned char) NULL;
+	    }
+	    
+
+    // Create the palette
+    hRetPal = CreatePalette(pPal);
+
+    // Go ahead and select and realize the palette for this device context
+    SelectPalette(hDC,hRetPal,FALSE);
+    RealizePalette(hDC);
+
+    // Free the memory used for the logical palette structure
+    free(pPal);
+
+    // Return the handle to the new palette
+    return hRetPal;
+}
+
+
+static void
+PrintMessage( const char *Format, ... )
+{
+    va_list ArgList;
+    char Buffer[256];
+
+    va_start(ArgList, Format);
+    vsprintf(Buffer, Format, ArgList);
+    va_end(ArgList);
+
+	fprintf(stderr, Buffer);
+}
+
+
+int LIBAPIENTRY
+PixelFormatDescriptorFromDc( HDC Dc, PIXELFORMATDESCRIPTOR *Pfd )
+{
+    int PfdIndex;
+
+    if ( 0 < (PfdIndex = GetPixelFormat( Dc )) )
+    {
+        if ( 0 < DescribePixelFormat( Dc, PfdIndex, sizeof(*Pfd), Pfd ) )
+        {
+            return(PfdIndex);
+        }
+        else
+        {
+            PrintMessage("Could not get a description of pixel format %d\n",
+                PfdIndex );
+        }
+    }
+    else
+    {
+        PrintMessage("Could not get pixel format for Dc 0x%08lX\n", Dc );
+    }
+    return( 0 );
+}
+
+
+const char * LIBAPIENTRY
+GetTextualPixelFormatByPFD(PIXELFORMATDESCRIPTOR *ppfd, int format)
+{
+	static char buffer[2000];
+	char line[200];
+
+    sprintf(buffer,"Pixel format %d\n", format);
+    sprintf(line,"  dwFlags - 0x%x\n", ppfd->dwFlags); 
+	if (ppfd->dwFlags & PFD_DOUBLEBUFFER) { strcat(buffer, line); sprintf(line,"\tPFD_DOUBLEBUFFER\n "); }
+	if (ppfd->dwFlags & PFD_STEREO) { strcat(buffer, line); sprintf(line,"\tPFD_STEREO\n "); }
+	if (ppfd->dwFlags & PFD_DRAW_TO_WINDOW) { strcat(buffer, line); sprintf(line,"\tPFD_DRAW_TO_WINDOW\n "); }
+    if (ppfd->dwFlags & PFD_DRAW_TO_BITMAP) { strcat(buffer, line); sprintf(line,"\tPFD_DRAW_TO_BITMAP\n "); }
+    if (ppfd->dwFlags & PFD_SUPPORT_GDI) { strcat(buffer, line); sprintf(line,"\tPFD_SUPPORT_GDI\n "); }
+    if (ppfd->dwFlags & PFD_SUPPORT_OPENGL) { strcat(buffer, line); sprintf(line,"\tPFD_SUPPORT_OPENGL\n "); }
+    if (ppfd->dwFlags & PFD_GENERIC_ACCELERATED) { strcat(buffer, line); sprintf(line,"\tPFD_GENERIC_ACCELERATED\n "); }
+    if (ppfd->dwFlags & PFD_GENERIC_FORMAT) { strcat(buffer, line); sprintf(line,"\tPFD_GENERIC_FORMAT\n "); }
+    if (ppfd->dwFlags & PFD_NEED_PALETTE) { strcat(buffer, line); sprintf(line,"\tPFD_NEED_PALETTE\n "); }
+    if (ppfd->dwFlags & PFD_NEED_SYSTEM_PALETTE) { strcat(buffer, line); sprintf(line,"\tPFD_NEED_SYSTEM_PALETTE\n "); }
+    strcat(buffer, line); sprintf(line,"\n");
+    strcat(buffer, line); sprintf(line,"  iPixelType - %d\n", ppfd->iPixelType); 
+    if (ppfd->iPixelType == PFD_TYPE_RGBA) { strcat(buffer, line); sprintf(line,"\tPGD_TYPE_RGBA\n"); }
+    if (ppfd->iPixelType == PFD_TYPE_COLORINDEX) { strcat(buffer, line); sprintf(line,"\tPGD_TYPE_COLORINDEX\n"); }
+    strcat(buffer, line); sprintf(line,"  cColorBits - %d\n", ppfd->cColorBits);
+    strcat(buffer, line); sprintf(line,"  cRedBits - %d\n", ppfd->cRedBits);
+    strcat(buffer, line); sprintf(line,"  cRedShift - %d\n", ppfd->cRedShift);
+    strcat(buffer, line); sprintf(line,"  cGreenBits - %d\n", ppfd->cGreenBits);
+    strcat(buffer, line); sprintf(line,"  cGreenShift - %d\n", ppfd->cGreenShift);
+    strcat(buffer, line); sprintf(line,"  cBlueBits - %d\n", ppfd->cBlueBits);
+    strcat(buffer, line); sprintf(line,"  cBlueShift - %d\n", ppfd->cBlueShift);
+    strcat(buffer, line); sprintf(line,"  cAlphaBits - %d (N.A.)\n", ppfd->cAlphaBits);
+    strcat(buffer, line); sprintf(line,"  cAlphaShift - 0x%x (N.A.)\n", ppfd->cAlphaShift);
+    strcat(buffer, line); sprintf(line,"  cAccumBits - %d\n", ppfd->cAccumBits);
+    strcat(buffer, line); sprintf(line,"  cAccumRedBits - %d\n", ppfd->cAccumRedBits);
+    strcat(buffer, line); sprintf(line,"  cAccumGreenBits - %d\n", ppfd->cAccumGreenBits);
+    strcat(buffer, line); sprintf(line,"  cAccumBlueBits - %d\n", ppfd->cAccumBlueBits);
+    strcat(buffer, line); sprintf(line,"  cAccumAlphaBits - %d\n", ppfd->cAccumAlphaBits);
+    strcat(buffer, line); sprintf(line,"  cDepthBits - %d\n", ppfd->cDepthBits);
+    strcat(buffer, line); sprintf(line,"  cStencilBits - %d\n", ppfd->cStencilBits);
+    strcat(buffer, line); sprintf(line,"  cAuxBuffers - %d\n", ppfd->cAuxBuffers);
+    strcat(buffer, line); sprintf(line,"  iLayerType - %d\n", ppfd->iLayerType);
+    strcat(buffer, line); sprintf(line,"  bReserved - %d\n", ppfd->bReserved);
+    strcat(buffer, line); sprintf(line,"  dwLayerMask - 0x%x\n", ppfd->dwLayerMask);
+    strcat(buffer, line); sprintf(line,"  dwVisibleMask - 0x%x\n", ppfd->dwVisibleMask);
+    strcat(buffer, line); sprintf(line,"  dwDamageMask - 0x%x\n", ppfd->dwDamageMask);
+	strcat(buffer, line); 
+	return buffer;
+}
+
+const char * LIBAPIENTRY GetTextualPixelFormatByHDC(HDC hdc)
+{
+    PIXELFORMATDESCRIPTOR pfd, *ppfd=0;
+    int format=0;
+
+    ppfd   = &pfd;
+    format = PixelFormatDescriptorFromDc( hdc, ppfd );
+
+	return GetTextualPixelFormatByPFD(ppfd, format);
+}
+
+/*****************************************************************/
+
+/* Struct used to manage color ramps */
+typedef struct {
+    GLfloat amb[3];	/* ambient color / bottom of ramp */
+    GLfloat diff[3];	/* diffuse color / middle of ramp */
+    GLfloat spec[3];	/* specular color / top of ramp */
+    GLfloat ratio;	/* ratio of diffuse to specular in ramp */
+    GLint indexes[3];	/* where ramp was placed in palette */
+} colorIndexState ;
+
+#define NUM_COLORS (sizeof(colors) / sizeof(colors[0]))
+
+void LIBAPIENTRY
+setupDIB(HDC hDCOrig, HDC hDC, HBITMAP * hBitmap, int width, int height)
+{
+    BITMAPINFO *bmInfo=0;
+    BITMAPINFOHEADER *bmHeader=0;
+    UINT usage=0;
+    VOID *base=0;
+    int bmiSize=0;
+    int bitsPerPixel=0;
+	HBITMAP hOldBitmap=0;
+
+    bmiSize = sizeof(*bmInfo);
+    bitsPerPixel = GetDeviceCaps(hDC, BITSPIXEL);
+
+    switch (bitsPerPixel) {
+    case 8:
+	// bmiColors is 256 WORD palette indices 
+	bmiSize += (256 * sizeof(WORD)) - sizeof(RGBQUAD);
+	break;
+    case 16:
+	// bmiColors is 3 WORD component masks 
+	bmiSize += (3 * sizeof(DWORD)) - sizeof(RGBQUAD);
+	break;
+    case 24:
+    case 32:
+    default:
+	// bmiColors not used 
+	break;
+    }
+
+    bmInfo = (BITMAPINFO *) calloc(1, bmiSize);
+    bmHeader = &bmInfo->bmiHeader;
+
+    bmHeader->biSize = sizeof(*bmHeader);
+    bmHeader->biWidth = width;
+    bmHeader->biHeight = height;
+    bmHeader->biPlanes = 1;			// must be 1 
+    bmHeader->biBitCount = bitsPerPixel;
+    bmHeader->biXPelsPerMeter = 0;
+    bmHeader->biYPelsPerMeter = 0;
+    bmHeader->biClrUsed = 0;			// all are used 
+    bmHeader->biClrImportant = 0;		// all are important 
+
+    switch (bitsPerPixel) {
+    case 8:
+	bmHeader->biCompression = BI_RGB;
+	bmHeader->biSizeImage = 0;
+	usage = DIB_PAL_COLORS;
+	// bmiColors is 256 WORD palette indices 
+	{
+	    WORD *palIndex = (WORD *) &bmInfo->bmiColors[0];
+	    int i;
+
+	    for (i=0; i<256; i++) {
+		palIndex[i] = i;
+	    }
+	}
+	break;
+    case 16:
+	bmHeader->biCompression = BI_RGB;
+	bmHeader->biSizeImage = 0;
+	usage = DIB_RGB_COLORS;
+	// bmiColors is 3 WORD component masks 
+	{
+	    DWORD *compMask = (DWORD *) &bmInfo->bmiColors[0];
+
+	    compMask[0] = 0xF800;
+	    compMask[1] = 0x07E0;
+	    compMask[2] = 0x001F;
+	}
+	break;
+    case 24:
+    case 32:
+    default:
+	bmHeader->biCompression = BI_RGB;
+	bmHeader->biSizeImage = 0;
+	usage = DIB_RGB_COLORS;
+	// bmiColors not used 
+	break;
+    }
+
+    *hBitmap = CreateDIBSection(hDC, bmInfo, usage, &base, NULL, 0);
+    if (*hBitmap == NULL) {
+	(void) MessageBox(WindowFromDC(hDC),
+		"Failed to create DIBSection.",
+		"OpenGL application error",
+		MB_ICONERROR | MB_OK);
+	exit(1);
+    }
+
+    hOldBitmap = SelectObject(hDC, *hBitmap);
+	if(hOldBitmap!=0)
+		DeleteObject(hOldBitmap);
+
+    free(bmInfo);
+}
+
+
+/*
+static void
+setupDIB(HDC hDCOrig, HDC hDC, HBITMAP * hBitmap, int width, int height)
+{
+	HBITMAP hOldBitmap=0;
+
+	*hBitmap = CreateCompatibleBitmap(  hDCOrig, width, height );
+    if (*hBitmap == NULL) {
+        fprintf(stderr,"Failed to create CreateCompatibleBitmap! \n");
+		fflush(stderr);
+		return;
+    }
+
+    hOldBitmap = SelectObject(hDC, *hBitmap);
+	if(hOldBitmap!=0)
+		DeleteObject(hOldBitmap);
+}
+*/
+
+
+void LIBAPIENTRY resizeDIB(HDC hDC, HBITMAP *hOldBitmap, HBITMAP *hBitmap)
+{
+	/*
+    SelectObject(hDC, *hOldBitmap);
+    DeleteObject(*hBitmap);
+    setupDIB(hDC, hBitmap);
+	*/
+}
+
+HPALETTE LIBAPIENTRY setupPalette(HDC hDC)
+{
+	HPALETTE hPalette = NULL;
+    PIXELFORMATDESCRIPTOR pfd;
+    LOGPALETTE* pPal=0;
+    int pixelFormat = GetPixelFormat(hDC);
+    int paletteSize=0;
+	colorIndexState colors[] = {
+		{
+			{ 0.0F, 0.0F, 0.0F },
+			{ 0.1F, 0.6F, 0.3F },
+			{ 1.0F, 1.0F, 1.0F },
+			0.75F, { 0, 0, 0 },
+	    },
+		{
+			{ 0.0F, 0.0F, 0.0F },
+			{ 0.0F, 0.2F, 0.5F },
+			{ 1.0F, 1.0F, 1.0F },
+			0.75F, { 0, 0, 0 },
+		},
+		{
+			{ 0.0F, 0.05F, 0.05F },
+			{ 0.6F, 0.0F, 0.8F },
+			{ 1.0F, 1.0F, 1.0F },
+			0.75F, { 0, 0, 0 },
+		},
+	};
+
+
+    DescribePixelFormat(hDC, pixelFormat, sizeof(PIXELFORMATDESCRIPTOR), &pfd);
+
+    /*
+    ** Determine if a palette is needed and if so what size.
+    */
+    if (pfd.dwFlags & PFD_NEED_PALETTE) {
+		paletteSize = 1 << pfd.cColorBits;
+    } else if (pfd.iPixelType == PFD_TYPE_COLORINDEX) {
+		paletteSize = 4096;
+    } else {
+		return NULL;
+    }
+
+    pPal = (LOGPALETTE*)
+	malloc(sizeof(LOGPALETTE) + paletteSize * sizeof(PALETTEENTRY));
+    pPal->palVersion = 0x300;
+    pPal->palNumEntries = paletteSize;
+
+    if (pfd.iPixelType == PFD_TYPE_RGBA) {
+	/*
+	** Fill the logical paletee with RGB color ramps
+	*/
+	int redMask = (1 << pfd.cRedBits) - 1;
+	int greenMask = (1 << pfd.cGreenBits) - 1;
+	int blueMask = (1 << pfd.cBlueBits) - 1;
+	int i;
+
+
+
+	for (i=0; i<paletteSize; ++i) {
+	    pPal->palPalEntry[i].peRed =
+		    (((i >> pfd.cRedShift) & redMask) * 255) / redMask;
+	    pPal->palPalEntry[i].peGreen =
+		    (((i >> pfd.cGreenShift) & greenMask) * 255) / greenMask;
+	    pPal->palPalEntry[i].peBlue =
+		    (((i >> pfd.cBlueShift) & blueMask) * 255) / blueMask;
+	    pPal->palPalEntry[i].peFlags = 0;
+	}
+    } else {
+	/*
+	** Fill the logical palette with color ramps.
+	**
+	** Set up the logical palette so that it can be realized
+	** into the system palette as an identity palette.
+	**
+	** 1) The default static entries should be present and at the right
+	**    location.  The easiest way to do this is to grab them from
+	**    the current system palette.
+	**
+	** 2) All non-static entries should be initialized to unique values.
+	**    The easiest way to do this is to ensure that all of the non-static
+	**    entries have the PC_NOCOLLAPSE flag bit set.
+	*/
+	int numRamps = NUM_COLORS;
+	int rampSize = (paletteSize - 20) / numRamps;
+	int extra = (paletteSize - 20) - (numRamps * rampSize);
+	int i, r;
+
+	/*
+	** Initialize static entries by copying them from the
+	** current system palette.
+	*/
+	GetSystemPaletteEntries(hDC, 0, paletteSize, &pPal->palPalEntry[0]);
+
+	/*
+	** Fill in non-static entries with desired colors.
+	*/
+	for (r=0; r<numRamps; ++r) {
+	    int rampBase = r * rampSize + 10;
+	    PALETTEENTRY *pe = &pPal->palPalEntry[rampBase];
+	    int diffSize = (int) (rampSize * colors[r].ratio);
+	    int specSize = rampSize - diffSize;
+
+	    for (i=0; i<rampSize; ++i) {
+		GLfloat *c0, *c1;
+		GLint a;
+
+		if (i < diffSize) {
+		    c0 = colors[r].amb;
+		    c1 = colors[r].diff;
+		    a = (i * 255) / (diffSize - 1);
+		} else {
+		    c0 = colors[r].diff;
+		    c1 = colors[r].spec;
+		    a = ((i - diffSize) * 255) / (specSize - 1);
+		}
+
+		pe[i].peRed = (BYTE) (a * (c1[0] - c0[0]) + 255 * c0[0]);
+		pe[i].peGreen = (BYTE) (a * (c1[1] - c0[1]) + 255 * c0[1]);
+		pe[i].peBlue = (BYTE) (a * (c1[2] - c0[2]) + 255 * c0[2]);
+		pe[i].peFlags = PC_NOCOLLAPSE;
+	    }
+
+	    colors[r].indexes[0] = rampBase;
+	    colors[r].indexes[1] = rampBase + (diffSize-1);
+	    colors[r].indexes[2] = rampBase + (rampSize-1);
+	}
+
+	/*
+	** Initialize any remaining non-static entries.
+	*/
+	for (i=0; i<extra; ++i) {
+	    int index = numRamps*rampSize+10+i;
+	    PALETTEENTRY *pe = &pPal->palPalEntry[index];
+
+	    pe->peRed = (BYTE) 0;
+	    pe->peGreen = (BYTE) 0;
+	    pe->peBlue = (BYTE) 0;
+	    pe->peFlags = PC_NOCOLLAPSE;
+	}
+    }
+
+    hPalette = CreatePalette(pPal);
+    free(pPal);
+
+    if (hPalette) {
+	SelectPalette(hDC, hPalette, FALSE);
+	RealizePalette(hDC);
+    }
+
+	return hPalette;
+}
+
+
+int LIBAPIENTRY setGLCapabilities ( HDC hdc, 
+					 int nPixelFormat,
+ 					 GLCapabilities *glCaps )
+{
+    PIXELFORMATDESCRIPTOR pfd;
+
+    (void) PixelFormatDescriptorFromDc( hdc, &pfd);
+
+    if (pfd.dwFlags & PFD_DOUBLEBUFFER)
+	glCaps->buffer=BUFFER_DOUBLE;
+    else
+	glCaps->buffer=BUFFER_SINGLE;
+
+    if (pfd.dwFlags & PFD_STEREO)
+	glCaps->stereo=STEREO_ON;
+    else
+	glCaps->stereo=STEREO_OFF;
+
+    if (pfd.iPixelType == PFD_TYPE_RGBA)
+	glCaps->color=COLOR_RGBA;
+
+    if (pfd.iPixelType == PFD_TYPE_COLORINDEX)
+	glCaps->color=COLOR_INDEX;
+
+    glCaps->depthBits = pfd.cDepthBits;
+    glCaps->stencilBits = pfd.cStencilBits;
+
+    glCaps->redBits = pfd.cRedBits;
+    glCaps->greenBits= pfd.cGreenBits;
+    glCaps->blueBits=  pfd.cBlueBits;
+    /* glCaps->alphaBits= pfd.cAlphaBits; N.A. */
+    glCaps->accumRedBits = pfd.cAccumRedBits;
+    glCaps->accumGreenBits= pfd.cAccumGreenBits;
+    glCaps->accumBlueBits= pfd.cAccumBlueBits;
+    glCaps->accumAlphaBits= pfd.cAccumAlphaBits;
+
+    glCaps->nativeVisualID=nPixelFormat;
+
+    return 1;
+}
+
diff --git a/src/unix/video-drivers/wgltool.h b/src/unix/video-drivers/wgltool.h
new file mode 100644
index 0000000..cb64425
--- /dev/null
+++ b/src/unix/video-drivers/wgltool.h
@@ -0,0 +1,70 @@
+#ifndef _WGLTOOL_H
+	/**
+	 * glxtool.h
+	 *
+	 * Copyright (C) 2001  Sven Goethel
+	 *
+	 * GNU Library General Public License 
+	 * as published by the Free Software Foundation
+	 *
+	 * http://www.gnu.org/copyleft/lgpl.html
+	 * General dynamical loading OpenGL (GL/GLU) support for:
+	 */
+
+	#define _WGLTOOL_H
+
+	#include "gltool.h"
+
+	#include "glcaps.h"
+
+	#include <windows.h>
+	#include <wingdi.h>
+
+	#include "wgl-disp-var.h"
+
+	/**
+	 * do not call this one directly,
+	 * use fetch_GL_FUNCS (gltool.h) instead
+	 */
+	LIBAPI void LIBAPIENTRY fetch_WGL_FUNCS 
+				(const char * libGLName, 
+					 const char * libGLUName, int force);
+
+
+	LIBAPI void LIBAPIENTRY setPixelFormatByGLCapabilities( 
+						PIXELFORMATDESCRIPTOR *pfd,
+						GLCapabilities *glCaps,
+						int offScreenRenderer,
+						HDC hdc);
+
+	// Set Pixel Format function - forward declaration
+	LIBAPI void LIBAPIENTRY SetDCPixelFormat(HDC hDC, GLCapabilities *glCaps,
+			int offScreenRenderer, int verbose);
+
+	LIBAPI HPALETTE LIBAPIENTRY GetOpenGLPalette(HDC hDC);
+
+	LIBAPI HGLRC LIBAPIENTRY get_GC( HDC *hDC, GLCapabilities *glCaps,
+			HGLRC shareWith, int offScreenRenderer,
+			int width, int height, HBITMAP *pix,
+			int verbose);
+
+	LIBAPI int LIBAPIENTRY PixelFormatDescriptorFromDc( HDC Dc, 
+			PIXELFORMATDESCRIPTOR *Pfd );
+
+	const char * LIBAPIENTRY GetTextualPixelFormatByHDC(HDC hdc);
+
+	const char * LIBAPIENTRY GetTextualPixelFormatByPFD(
+			PIXELFORMATDESCRIPTOR *ppfd, int format);
+
+	LIBAPI void LIBAPIENTRY setupDIB(HDC hDCOrig, HDC hDC, HBITMAP * hBitmap, 
+			int width, int height);
+
+	LIBAPI void LIBAPIENTRY resizeDIB(HDC hDC, HBITMAP *hOldBitmap, 
+			HBITMAP *hBitmap);
+
+	LIBAPI HPALETTE LIBAPIENTRY setupPalette(HDC hDC);
+
+	LIBAPI int LIBAPIENTRY setGLCapabilities ( HDC hdc, int nPixelFormat,
+								GLCapabilities *glCaps );
+
+#endif
diff --git a/src/unix/video-drivers/x11-avi.c b/src/unix/video-drivers/x11-avi.c
new file mode 100644
index 0000000..91c1011
--- /dev/null
+++ b/src/unix/video-drivers/x11-avi.c
@@ -0,0 +1,201 @@
+
+#ifdef AVICAPTURE
+
+#include <math.h>
+#include <X11/Xlib.h>
+#include "xmame.h"
+#include "x11.h"
+#include "input.h"
+#include "keyboard.h"
+ 
+typedef unsigned char uint8_t;
+typedef unsigned short uint16_t;
+typedef unsigned int uint32_t;
+typedef unsigned long long uint64_t;
+
+#include <ffmpeg/common.h>
+#include <ffmpeg/avcodec.h>
+
+const int BUFFSIZE=1000000;
+FILE * video_outf;
+AVCodec * avc;
+AVCodecContext * avctx;
+AVPicture inpic, outpic;
+char * output_buffer;
+AVFrame * pic;
+
+int frame_halver=2; // save each frame=1,  save every other frame=2
+
+void init_dumper( int width, int height )
+{  
+  double fps = Machine->drv->frames_per_second / (double)frame_halver;
+
+  avcodec_init();
+  avcodec_register_all();
+#ifdef AVICAPTURE_DEBUG
+  av_log_set_level (99);
+#endif
+
+  avc = avcodec_find_encoder( CODEC_ID_MPEG1VIDEO );
+  if (avc == NULL)
+  {
+  	  printf ("cannot find MPEG encoder\n");
+     exit (1);
+  }
+
+  avctx = avcodec_alloc_context();
+    
+  /* sample parameters */
+  avctx->me_method = ME_LOG;
+  avctx->pix_fmt = PIX_FMT_YUV420P;
+  avctx->bit_rate = 2500000;
+  avctx->width = width;
+  avctx->height = height;
+  avctx->time_base.num = 1;
+  avctx->time_base.den = fps;
+  avctx->gop_size=10;
+  avctx->max_b_frames=1;
+  avctx->draw_horiz_band = NULL;
+  avctx->idct_algo = FF_IDCT_AUTO;
+
+  int ret = avcodec_open( avctx, avc );
+  if (ret)
+    {
+      printf("FAILED TO OPEN ENCODER, ret=%d, errno=%d\n", ret, errno);
+      exit( 1 );
+    }
+  
+  int size=height*width;
+  
+  pic = avcodec_alloc_frame();
+  
+  output_buffer=(char *)malloc(BUFFSIZE); /* Find where this value comes from */
+  
+  outpic.data[0]=(unsigned char *)malloc(size*3/2); /* YUV 420 Planar */
+  outpic.data[1]=outpic.data[0]+size;
+  outpic.data[2]=outpic.data[1]+size/4;
+  outpic.data[3]=NULL;
+  outpic.linesize[0]=width;
+  outpic.linesize[1]=outpic.linesize[2]=width/2;
+  outpic.linesize[3]=0;
+  
+  pic->data[0]=outpic.data[0];  /* Points to data portion of outpic     */
+  pic->data[1]=outpic.data[1];  /* Since encode_video takes an AVFrame, */
+  pic->data[2]=outpic.data[2];  /* and img_convert takes an AVPicture   */
+  pic->data[3]=outpic.data[3];
+  
+  pic->linesize[0]=outpic.linesize[0]; /* This doesn't change */
+  pic->linesize[1]=outpic.linesize[1];
+  pic->linesize[2]=outpic.linesize[2];
+  pic->linesize[3]=outpic.linesize[3];
+  
+  inpic.data[0]=(unsigned char *)malloc(size*3); /* RGB24 packed in 1 plane */
+  inpic.data[1]=inpic.data[2]=inpic.data[3]=NULL;
+  inpic.linesize[0]=width*3;
+  inpic.linesize[1]=inpic.linesize[2]=inpic.linesize[3]=0;
+
+  video_outf = fopen("video.outf","wb");
+  if (video_outf == NULL)
+  {
+    printf ("failed to open output video file\n");
+    exit (1);
+  }
+}
+
+void frame_dump ( struct mame_bitmap * bitmap )
+{
+  static unsigned int *dumpbig = NULL;
+  unsigned char *dumpd;
+  int y;
+  int xoff, yoff, xsize, ysize;
+  int outsz;
+  static int framecnt=0;
+  static unsigned char * myoutframe;
+
+  framecnt++;
+  if ((framecnt % frame_halver) != 0)
+    return; // skip this frame
+
+#if 0
+  xoff = Machine->visible_area.min_x;
+  yoff = Machine->visible_area.min_y;
+  xsize= Machine->visible_area.max_x-xoff+1;
+  ysize = Machine->visible_area.max_y-yoff+1;
+#endif
+
+  xsize = visual_width;
+  ysize = visual_height;
+  xoff=0;
+  yoff=0; 
+
+	if (!dumpbig)
+	{
+		int dstsize = bitmap->width *bitmap->height * sizeof (unsigned int);
+		dumpbig = malloc ( dstsize );
+		myoutframe = malloc( dstsize );
+  }
+
+  dumpd = (unsigned char*)dumpbig;
+
+	/* Blit into dumpbig */
+#define INDIRECT current_palette->lookup
+#define DEST dumpbig
+#define DEST_WIDTH (bitmap->width)
+#define SRC_PIXEL unsigned short
+#define DEST_PIXEL unsigned int
+#define PACK_BITS
+#include "blit.h"
+#undef PACK_BITS
+#undef SRC_PIXEL
+#undef DEST_PIXEL
+#undef INDIRECT
+
+	/* Now make some corrections. */
+	for (y=0; y < ysize; y++)
+   {
+   	int offs = bitmap->width*(y+yoff)*4;
+      int x;
+
+      for(x=0; x < xsize; x++)
+	   {
+	   	unsigned char c;
+	  		c = dumpd[offs+x*3+2];
+	  		dumpd[offs+x*3+2] = dumpd[offs+x*3];
+	      dumpd[offs+x*3] = c;
+	   }
+
+		memcpy( &myoutframe[xsize*y*3], &dumpd[offs+3*xoff], xsize*3 );
+	}
+
+	/* dumpd now contains a nice RGB (or somethiing) frame.. */
+  inpic.data[0] = myoutframe;
+
+  img_convert(&outpic, PIX_FMT_YUV420P, &inpic, PIX_FMT_RGB24, xsize, ysize); 
+  
+  outsz = avcodec_encode_video (avctx, 
+  		(unsigned char*)output_buffer, BUFFSIZE, pic);
+  fwrite(output_buffer, 1, outsz, video_outf);
+}
+
+
+void done_dumper()
+{
+  printf("killing dumper...\n");
+  avcodec_close(avctx);
+  // there might have been something with buffers and b frames that 
+  // i should have taken care of at this point.. oh well
+
+  if (video_outf)
+  {
+     fwrite("\0x00\0x00\0x01\0xb7", 1, 4, video_outf); // mpeg end sequence..
+     fclose(video_outf);
+	  video_outf = NULL;
+  }
+
+  av_free(pic);
+  av_free(avctx);
+}
+
+
+#endif /* AVICAPTURE */
+
diff --git a/src/unix/video-drivers/x11.c b/src/unix/video-drivers/x11.c
new file mode 100644
index 0000000..c211881
--- /dev/null
+++ b/src/unix/video-drivers/x11.c
@@ -0,0 +1,326 @@
+/*
+ * X-Mame video specifics code
+ *
+ */
+#ifdef x11
+#define __X11_C_
+
+/*
+ * Include files.
+ */
+
+#include <math.h>
+#include <X11/Xlib.h>
+#include "xmame.h"
+#include "x11.h"
+#include "input.h"
+#include "keyboard.h"
+
+#ifdef USE_HWSCALE
+long hwscale_redmask;
+long hwscale_greenmask;
+long hwscale_bluemask;
+#endif
+
+extern int force_dirty_palette;
+
+int x11_grab_keyboard;
+
+struct rc_option display_opts[] = {
+	/* name, shortname, type, dest, deflt, min, max, func, help */
+	{ "X11 Related", NULL, rc_seperator, NULL, NULL, 0, 0, NULL, NULL },
+	{ "x11-mode", "x11", rc_int, &x11_video_mode, "0", 0, X11_MODE_COUNT-1, NULL, "Select x11 video mode: (if compiled in)\n0 Normal windowed (hotkey left-alt + insert)\n1 DGA fullscreen (hotkey left-alt + home)\n2 Xv windowed\n3 Xv fullscreen" },
+	{ NULL, NULL, rc_link, x11_window_opts, NULL, 0, 0, NULL, NULL },
+#if defined DGA || defined USE_HWSCALE
+	{ NULL, NULL, rc_link, mode_opts, NULL, 0, 0, NULL, NULL },
+#endif
+	{ NULL, NULL, rc_link, x11_input_opts, NULL, 0, 0, NULL, NULL },
+	{ NULL, NULL, rc_end, NULL, NULL, 0, 0, NULL, NULL }
+};
+
+struct x_func_struct {
+	int  (*init)(void);
+	int  (*create_display)(int depth);
+	void (*close_display)(void);
+	void (*update_display)(struct mame_bitmap *bitmap);
+	int  (*alloc_palette)(int writable_colors);
+	int  (*modify_pen)(int pen, unsigned char red, unsigned char green, unsigned char blue);
+	int  (*_16bpp_capable)(void);
+};
+
+static struct x_func_struct x_func[X11_MODE_COUNT] = {
+{ NULL,
+  x11_window_create_display,
+  x11_window_close_display,
+  x11_window_update_display,
+  x11_window_alloc_palette,
+  x11_window_modify_pen,
+  x11_window_16bpp_capable },
+#ifdef USE_DGA
+{ xf86_dga_init,
+  xf86_dga_create_display,
+  xf86_dga_close_display,
+  xf86_dga_update_display,
+  xf86_dga_alloc_palette,
+  xf86_dga_modify_pen,
+  xf86_dga_16bpp_capable },
+#else
+{ NULL, NULL, NULL, NULL, NULL, NULL, NULL },
+#endif
+#ifdef USE_XV
+{ NULL,
+  x11_window_create_display,
+  x11_window_close_display,
+  x11_window_update_display,
+  x11_window_alloc_palette,
+  x11_window_modify_pen,
+  x11_window_16bpp_capable },
+{ NULL,
+  x11_window_create_display,
+  x11_window_close_display,
+  x11_window_update_display,
+  x11_window_alloc_palette,
+  x11_window_modify_pen,
+  x11_window_16bpp_capable }
+#else
+{ NULL, NULL, NULL, NULL, NULL, NULL, NULL },
+{ NULL, NULL, NULL, NULL, NULL, NULL, NULL }
+#endif
+};
+
+int sysdep_init (void)
+{
+	int i;
+
+	if(!(display = XOpenDisplay (NULL)))
+	{
+		/* Don't use stderr_file here it isn't assigned a value yet ! */
+		fprintf (stderr, "Could not open display\n");
+		return OSD_NOT_OK;
+	}
+
+	for (i=0;i<X11_MODE_COUNT;i++)
+	{
+		if(x_func[i].create_display)
+			mode_available[i] = TRUE;
+		else
+			mode_available[i] = FALSE;
+
+		if(x_func[i].init && (*x_func[i].init)() != OSD_OK)
+			return OSD_NOT_OK;
+	}
+
+	return OSD_OK;
+}
+
+void sysdep_close(void)
+{
+	if(display)
+		XCloseDisplay (display);
+}
+
+int sysdep_display_16bpp_capable(void)
+{
+	if (x11_video_mode >= X11_MODE_COUNT)
+	{
+		fprintf (stderr_file,
+				"X11-mode %d does not exist, falling back to normal window code\n",
+				x11_video_mode);
+		x11_video_mode = X11_WINDOW;
+	}
+
+	if (!mode_available[x11_video_mode])
+	{
+		fprintf (stderr_file,
+				"X11-mode %d not available, falling back to normal window code\n",
+				x11_video_mode);
+		x11_video_mode = X11_WINDOW;
+	}
+
+	return (*x_func[x11_video_mode]._16bpp_capable) ();
+}
+
+/* This name doesn't really cover this function, since it also sets up mouse
+   and keyboard. This is done over here, since on most display targets the
+   mouse and keyboard can't be setup before the display has. */
+int sysdep_create_display (int depth)
+{
+	return (*x_func[x11_video_mode].create_display)(depth);
+}
+
+void sysdep_display_close(void)
+{
+#ifdef AVICAPTURE
+	/// done_dumper ();
+#endif
+	(*x_func[x11_video_mode].close_display)();
+}
+
+int x11_init_palette_info(void)
+{
+	memset(&display_palette_info, 0, sizeof(struct sysdep_palette_info));
+
+	display_palette_info.depth = depth;
+
+	if (depth == 8)
+	{
+		if (xvisual->class != PseudoColor)
+		{
+			fprintf(stderr_file, "X11: Error 8 bpp only supported on PseudoColor visuals\n");
+			return OSD_NOT_OK;
+		}
+		display_palette_info.writable_colors = 256;
+	}
+	else
+	{
+		if (xvisual->class != TrueColor)
+		{
+			fprintf(stderr_file, "X11: Error: %d bpp modes only supported on TrueColor visuals\n",
+					depth);
+			return OSD_NOT_OK;
+		}
+#ifdef USE_HWSCALE
+		if(use_hwscale)
+		{
+			display_palette_info.red_mask   = hwscale_redmask;
+			display_palette_info.green_mask = hwscale_greenmask;
+			display_palette_info.blue_mask  = hwscale_bluemask;
+		}
+		else
+#endif
+		{
+			display_palette_info.red_mask   = xvisual->red_mask;
+			display_palette_info.green_mask = xvisual->green_mask;
+			display_palette_info.blue_mask  = xvisual->blue_mask;
+		}
+	}
+	return OSD_OK;
+}
+
+int sysdep_display_alloc_palette (int writable_colors)
+{
+	return (*x_func[x11_video_mode].alloc_palette) (writable_colors);
+}
+
+int sysdep_display_set_pen (int pen, unsigned char red, unsigned char green,
+		unsigned char blue)
+{
+	return (*x_func[x11_video_mode].modify_pen) (pen, red, green, blue);
+}
+
+void sysdep_update_display (struct mame_bitmap *bitmap)
+{
+	int new_video_mode = x11_video_mode;
+	int current_palette_normal = (current_palette == normal_palette);
+
+	int bitmap_depth = bitmap->depth;
+	if (bitmap_depth == 15)
+	{
+		bitmap_depth = 16;
+	}
+
+	if (keyboard_pressed (KEYCODE_LALT))
+	{
+		if (keyboard_pressed_memory(KEYCODE_INSERT))
+			new_video_mode = X11_WINDOW;
+
+		if (keyboard_pressed_memory(KEYCODE_HOME))
+			new_video_mode = X11_DGA;
+
+		if (keyboard_pressed_memory(KEYCODE_DEL))
+			new_video_mode = X11_XV_WINDOW;
+
+		if (keyboard_pressed_memory(KEYCODE_END))
+			new_video_mode = X11_XV_FULLSCREEN;
+	}
+
+	if (new_video_mode != x11_video_mode && mode_available[new_video_mode])
+	{
+		int old_video_mode = x11_video_mode;	
+		x11_video_mode = new_video_mode;
+
+		/* Close sound, my guess is DGA somehow (perhaps fork/exec?) makes
+		   the filehandle open twice, so closing it here and re-openeing after
+		   the transition should fix that.  Fixed it for me anyways.
+		   -- Steve bpk@hoopajoo.net */
+		osd_sound_enable( 0 );
+
+		(*x_func[old_video_mode].close_display)();
+		if ((*x_func[x11_video_mode].create_display)(bitmap_depth) != OSD_OK)
+		{
+			fprintf(stderr_file,
+					"X11: Warning: Couldn't create display for new x11-mode\n"
+					"   Trying again with the old x11-mode\n");
+			(*x_func[x11_video_mode].close_display)();
+			if ((*x_func[old_video_mode].create_display)(bitmap_depth) != OSD_OK)
+				goto barf;
+			else
+				x11_video_mode = old_video_mode;
+		}
+
+		if (sysdep_palette_change_display(&normal_palette))
+			goto barf;
+
+		if (debug_palette && sysdep_palette_change_display(&debug_palette))
+			goto barf;
+
+		if (current_palette_normal)
+			current_palette = normal_palette;
+		else
+			current_palette = debug_palette;
+
+		if (sysdep_display_alloc_palette(video_colors_used))
+			goto barf;
+
+		/* Force the palette lookup table to be updated.  This is necessary 
+		 * because switching to/from fullscreen mode could cause the screen 
+		 * depth to change. */
+		force_dirty_palette = 1;  
+
+		xmame_keyboard_clear();
+		/* poll mouse twice to clear internal vars */
+		if (use_mouse)
+		{
+			sysdep_mouse_poll ();
+			sysdep_mouse_poll ();
+		}
+
+		/* Re-enable sound */
+		osd_sound_enable( 1 );
+	}
+
+#ifdef AVICAPTURE
+   {
+     static int inited=0;
+     if (!inited)
+     {
+	     inited=1;
+        init_dumper( visual_width, visual_height );
+     }
+     frame_dump( bitmap );
+   }
+   sched_yield();
+#endif
+	(*x_func[x11_video_mode].update_display) (bitmap);
+	return;
+
+barf:
+	sysdep_display_close();   /* This cleans up and must be called to
+				     restore the videomode with dga */
+	fprintf (stderr_file,
+			"X11: Error: couldn't create new display while switching display modes\n");
+	exit (1);              /* ugly, anyone know a better way ? */
+}
+
+/* these aren't nescesarry under x11 since we have both a graphics window and
+   a textwindow (xterm) */
+int sysdep_set_video_mode (void)
+{
+	return OSD_OK;
+}
+
+void sysdep_set_text_mode (void)
+{
+}
+
+#endif /* ifdef x11 */
diff --git a/src/unix/video-drivers/x11.h b/src/unix/video-drivers/x11.h
new file mode 100644
index 0000000..fd8d2be
--- /dev/null
+++ b/src/unix/video-drivers/x11.h
@@ -0,0 +1,115 @@
+#ifndef __X11_H_
+#define __X11_H_
+
+#include <X11/Xlib.h>
+#include "effect.h"
+
+#ifdef __X11_C_
+#define EXTERN
+#else
+#define EXTERN extern
+#endif
+
+enum { X11_WINDOW, X11_DGA, X11_XV_WINDOW, X11_XV_FULLSCREEN };
+#define X11_MODE_COUNT 4
+
+EXTERN Display 		*display;
+EXTERN Window		window;
+EXTERN Screen 		*screen;
+EXTERN Colormap		colormap;
+EXTERN Visual		*xvisual;
+EXTERN int		depth;
+EXTERN unsigned char	*scaled_buffer_ptr;
+EXTERN int		mode_available[X11_MODE_COUNT];
+EXTERN Cursor		normal_cursor;
+EXTERN Cursor		invisible_cursor;
+EXTERN int		x11_video_mode;
+EXTERN int		x11_grab_mouse;
+EXTERN int		x11_grab_keyboard;
+EXTERN int		run_in_root_window;
+EXTERN int		show_cursor;
+EXTERN int		use_private_cmap;
+EXTERN int		use_xil;
+EXTERN int		use_mt_xil;
+#ifdef USE_HWSCALE
+EXTERN int		use_hwscale;
+EXTERN int		use_xv;
+EXTERN long		hwscale_redmask;
+EXTERN long		hwscale_greenmask;
+EXTERN long		hwscale_bluemask;
+#endif
+extern struct rc_option xf86_dga_opts[];
+extern struct rc_option x11_window_opts[];
+extern struct rc_option	x11_input_opts[];
+
+#if defined x11 && defined USE_DGA
+EXTERN int		xf86_dga_fix_viewport;
+EXTERN int		xf86_dga_first_click;
+#endif
+
+#ifdef X11_JOYSTICK
+EXTERN int devicebuttonpress;
+EXTERN int devicebuttonrelease;
+EXTERN int devicemotionnotify;
+EXTERN int devicebuttonmotion;
+#endif
+
+/*** prototypes ***/
+
+/* device related */
+void process_x11_joy_event(XEvent *event);
+
+#ifdef x11
+
+/* Normal x11_window functions */
+int  x11_window_create_display(int depth);
+void x11_window_close_display(void);
+int  x11_window_modify_pen(int pen, unsigned char red,unsigned char green,unsigned char blue);
+void x11_window_update_display(struct mame_bitmap *bitmap);
+int  x11_window_alloc_palette(int writable_colors);
+void x11_window_refresh_screen(void);
+int  x11_window_16bpp_capable(void);
+
+/* Xf86_dga functions */
+int  xf86_dga_init(void);
+int  xf86_dga_create_display(int depth);
+void xf86_dga_close_display(void);
+int  xf86_dga_modify_pen(int pen, unsigned char red,unsigned char green,unsigned char blue);
+void xf86_dga_update_display(struct mame_bitmap *bitmap);
+int  xf86_dga_alloc_palette(int writable_colors);
+int  xf86_dga_16bpp_capable(void);
+int  xf86_dga1_init(void);
+int  xf86_dga1_create_display(int depth);
+void xf86_dga1_close_display(void);
+int  xf86_dga1_modify_pen(int pen, unsigned char red,unsigned char green,unsigned char blue);
+void xf86_dga1_update_display(struct mame_bitmap *bitmap);
+int  xf86_dga1_alloc_palette(int writable_colors);
+int  xf86_dga1_16bpp_capable(void);
+int  xf86_dga2_init(void);
+int  xf86_dga2_create_display(int depth);
+void xf86_dga2_close_display(void);
+int  xf86_dga2_modify_pen(int pen, unsigned char red,unsigned char green,unsigned char blue);
+void xf86_dga2_update_display(struct mame_bitmap *bitmap);
+int  xf86_dga2_alloc_palette(int writable_colors);
+int  xf86_dga2_16bpp_capable(void);
+
+/* XIL functions */
+#ifdef USE_XIL
+void init_xil( void );
+void setup_xil_images( int, int );
+void refresh_xil_screen( void );
+#endif
+
+/* DBE functions */
+#ifdef USE_DBE
+void setup_dbe( void );
+void swap_dbe_buffers( void );
+#endif
+
+/* generic helper functions */
+int x11_init_palette_info(void);
+
+#endif /* ifdef x11 */
+
+#undef EXTERN
+#endif /* ifndef __X11_H_ */
diff --git a/src/unix/video-drivers/x11_window.c b/src/unix/video-drivers/x11_window.c
new file mode 100644
index 0000000..87e1080
--- /dev/null
+++ b/src/unix/video-drivers/x11_window.c
@@ -0,0 +1,1819 @@
+/*
+ * X-Mame video specifics code
+ *
+ */
+#ifdef x11
+#define __X11_WINDOW_C_
+
+/*
+ * Include files.
+ */
+
+/* for FLT_MAX */
+#include <float.h>
+#include <X11/Xlib.h>
+#include <X11/Xutil.h>
+#include <X11/cursorfont.h>
+#ifdef USE_MITSHM
+#include <sys/ipc.h>
+#include <sys/shm.h>
+#include <X11/extensions/XShm.h>
+#endif
+#ifdef USE_XV
+#include <X11/extensions/Xv.h>
+#include <X11/extensions/Xvlib.h>
+#endif
+
+#include "xmame.h"
+#include "x11.h"
+#include "driver.h"
+/* for xscreensaver support */
+/* Commented out for now since it causes problems with some 
+ * versions of KDE.
+ */
+/* #include "vroot.h" */
+
+#ifdef USE_HWSCALE
+static void x11_window_update_16_to_YUY2 (struct mame_bitmap *bitmap);
+static void x11_window_update_16_to_YV12 (struct mame_bitmap *bitmap);
+static void x11_window_update_16_to_YV12_perfect (struct mame_bitmap *bitmap);
+static void x11_window_update_32_to_YUY2_direct (struct mame_bitmap *bitmap);
+static void x11_window_update_32_to_YV12_direct (struct mame_bitmap *bitmap);
+static void x11_window_update_32_to_YV12_direct_perfect (struct mame_bitmap *bitmap);
+static void x11_window_make_yuv_lookup();
+#endif
+static void x11_window_update_16_to_16bpp (struct mame_bitmap *bitmap);
+static void x11_window_update_16_to_24bpp (struct mame_bitmap *bitmap);
+static void x11_window_update_16_to_32bpp (struct mame_bitmap *bitmap);
+static void x11_window_update_32_to_32bpp_direct (struct mame_bitmap *bitmap);
+static void (*x11_window_update_display_func) (struct mame_bitmap *bitmap) = NULL;
+
+/* hmm we need these to do the clean up correctly, or we could just
+   trust unix & X to clean up after us but lett's keep things clean */
+#ifdef USE_MITSHM
+static int mit_shm_attached = 0;
+static XShmSegmentInfo shm_info;
+static int use_mit_shm = 1;  /* use mitshm if available */
+#endif
+static int private_cmap_allocated = 0;
+
+#ifdef USE_HWSCALE
+static int hwscale_bpp=0;
+static long hwscale_format=0;
+static int hwscale_yuv=0;
+static int hwscale_yv12=0;
+static unsigned int *hwscale_yuvlookup=NULL;
+int hwscale_fullscreen = 0;
+int hwscale_widescreen = 0;
+#define FOURCC_YUY2 0x32595559
+#define FOURCC_YV12 0x32315659
+#define FOURCC_I420 0x30323449
+#define FOURCC_UYVY 0x59565955
+
+/* HACK - HACK - HACK for fullscreen */
+#define MWM_HINTS_DECORATIONS   2
+typedef struct {
+	long flags;
+	long functions;
+	long decorations;
+	long input_mode;
+} MotifWmHints;
+#endif
+
+#ifdef USE_XV
+static XvImage *xvimage = NULL;
+static int xv_port=-1;
+#define HWSCALE_WIDTH (xvimage->width)
+#define HWSCALE_HEIGHT (xvimage->height)
+#define HWSCALE_YPLANE (xvimage->data+xvimage->offsets[0])
+#define HWSCALE_UPLANE (xvimage->data+xvimage->offsets[1])
+#define HWSCALE_VPLANE (xvimage->data+xvimage->offsets[2])
+#endif
+
+static XImage *image = NULL;
+static GC gc;
+static int orig_widthscale, orig_heightscale;
+static int image_width;
+enum { X11_NORMAL, X11_MITSHM, X11_XV, X11_XIL };
+static int x11_window_update_method = X11_NORMAL;
+static int startx = 0;
+static int starty = 0;
+static unsigned long black_pen;
+static int use_xsync = 0;
+static int root_window_id; /* root window id (for swallowing the mame window) */
+static char *geometry = NULL;
+
+/* we need to look a lookup table for pseudo modes since X doesn't give us full
+   access to the palette */
+static char *pseudo_color_allocated;
+static unsigned long *pseudo_color_lookup;
+static int pseudo_color_lookup_dirty;
+static int pseudo_color_use_rw_palette;
+static int pseudo_color_warn_low_on_colors;
+
+struct rc_option x11_window_opts[] = {
+	/* name, shortname, type, dest, deflt, min, max, func, help */
+	{ "X11-window Related", NULL, rc_seperator, NULL, NULL, 0, 0, NULL,
+ NULL },
+	{ "cursor", "cu", rc_bool, &show_cursor, "1", 0, 0, NULL, "Show/don't show the cursor" },
+#ifdef USE_MITSHM
+	{ "mitshm", "ms", rc_bool, &use_mit_shm, "1", 0, 0, NULL, "Use/don't use MIT Shared Mem (if available and compiled in)" },
+#endif
+#ifdef USE_XV
+/*	{ "xvext", "xv", rc_bool, &use_xv,
+ "1", 0, 0, NULL,
+ "Use/don't use Xv extension for hardware scaling (if available and compiled in))" },*/
+#endif
+#ifdef USE_HWSCALE
+	{ "yuv", NULL, rc_bool, &hwscale_yuv, "0", 0, 0, NULL, "Force YUV mode (for video cards with broken RGB hwscales)" },
+	{ "yv12", NULL, rc_bool, &hwscale_yv12, "0", 0, 0, NULL, "Force YV12 mode (for video cards with broken RGB hwscales)" },
+	{ "widescreen", NULL, rc_bool, &hwscale_widescreen, "0", 0, 0, NULL, "Screen scales to 16:9" },
+#endif
+	{ "xsync", "xs", rc_bool, &use_xsync, "1", 0, 0, NULL, "Use/don't use XSync instead of XFlush as screen refresh method" },
+	{ "privatecmap", "p", rc_bool, &use_private_cmap, "0", 0, 0, NULL, "Enable/disable use of private color map" },
+	{ "xil", "x", rc_bool, &use_xil, "1", 0, 0, NULL, "Enable/disable use of XIL for scaling (if available and compiled in)" },
+	{ "mtxil", "mtx", rc_bool, &use_mt_xil, "0", 0, 0, NULL, "Enable/disable multi threading of XIL" },
+	{ "run-in-root-window", "root", rc_bool, &run_in_root_window, "0", 0, 0, NULL, "Enable/disable running in root window" },
+	{ "root_window_id", "rid", rc_int, &root_window_id,
+ "0", 0, 0, NULL, "Create the xmame-window in an alternate root-window, mostly usefull for frontends!" },
+	{ "geometry", "geo", rc_string, &geometry, "640x480", 0, 0, NULL, "Specify the location of the window" },
+	{ NULL, NULL, rc_end, NULL, NULL, 0, 0, NULL, NULL }
+};
+
+#if defined(__sgi)
+/* Needed for setting the application class */
+static XClassHint class_hints = {
+  NAME, NAME,
+};
+#endif
+
+/*
+ * Create a display screen, or window, large enough to accomodate a bitmap
+ * of the given dimensions.
+ */
+
+#ifdef USE_MITSHM
+/* following routine traps missused MIT-SHM if not available */
+int test_mit_shm (Display * display, XErrorEvent * error)
+{
+	char msg[256];
+	unsigned char ret = error->error_code;
+
+	XGetErrorText (display, ret, msg, 256);
+	/* if MIT-SHM request failed, note and continue */
+	if (ret == BadAccess)
+	{
+		use_mit_shm = 0;
+		return 0;
+	}
+	/* else unspected error code: notify and exit */
+	fprintf (stderr_file, "Unspected X Error %d: %s\n", ret, msg);
+	exit(1);
+	/* to make newer gcc's shut up, grrr */
+	return 0;
+}
+#endif
+
+#ifdef USE_XV
+int FindXvPort(Display *dpy, long format, int *port)
+{
+	int i,j,p,ret,num_formats;
+	unsigned int num_adaptors;
+	XvAdaptorInfo *ai;
+	XvImageFormatValues *fo;
+
+	ret = XvQueryAdaptors(dpy, DefaultRootWindow(dpy),
+			&num_adaptors, &ai);
+
+	if (ret != Success)
+	{
+		fprintf(stderr,"XV: QueryAdaptors failed\n");
+		return 0;
+	}
+
+	for (i = 0; i < num_adaptors; i++)
+	{
+		int firstport=ai[i].base_id;
+		int portcount=ai[i].num_ports;
+
+		for (p = firstport; p < ai[i].base_id+portcount; p++)
+		{
+			fo = XvListImageFormats(dpy, p, &num_formats);
+			for (j = 0; j < num_formats; j++)
+			{
+				if((fo[j].id==format))
+				{
+					if(XvGrabPort(dpy,p,CurrentTime)==Success)
+					{
+						*port=p;
+						XFree(fo);
+						return 1;
+					}
+				}
+			}
+			XFree(fo);
+		}
+	}
+	XvFreeAdaptorInfo(ai);
+	return 0;
+}
+
+int FindRGBXvFormat(Display *dpy, int *port,long *format,int *bpp)
+{
+	int i,j,p,ret,num_formats;
+	unsigned int num_adaptors;
+	XvAdaptorInfo *ai;
+	XvImageFormatValues *fo;
+
+	ret = XvQueryAdaptors(dpy, DefaultRootWindow(dpy),
+			&num_adaptors, &ai);
+
+	if (ret != Success)
+	{
+		fprintf(stderr,"XV: QueryAdaptors failed\n");
+		return 0;
+	}
+
+	for (i = 0; i < num_adaptors; i++)
+	{
+		int firstport=ai[i].base_id;
+		int portcount=ai[i].num_ports;
+
+		for (p = firstport; p < ai[i].base_id+portcount; p++)
+		{
+			fo = XvListImageFormats(dpy, p, &num_formats);
+			for (j = 0; j < num_formats; j++)
+			{
+				if((fo[j].type==XvRGB) && (fo[j].format==XvPacked))
+				{
+					if(XvGrabPort(dpy,p,CurrentTime)==Success)
+					{
+						*bpp=fo[j].bits_per_pixel;
+						*port=p;
+						*format=fo[j].id;
+						hwscale_redmask=fo[j].red_mask;
+						hwscale_greenmask=fo[j].green_mask;
+						hwscale_bluemask=fo[j].blue_mask;
+						XFree(fo);
+						return 1;
+					}
+				}
+			}
+			XFree(fo);
+		}
+	}
+	XvFreeAdaptorInfo(ai);
+	return 0;
+}
+
+#endif
+#ifdef USE_HWSCALE
+
+/* Since with YUV formats a field of zeros is generally
+   loud green, rather than black, it makes sense
+   to clear the image before use (since scanline algorithms
+   leave alternate lines "black") */
+void ClearYUY2()
+{
+  int i,j;
+  char *yuv=HWSCALE_YPLANE;
+  fprintf(stderr,"Clearing YUY2\n");
+  for (i = 0; i < HWSCALE_HEIGHT; i++)
+  {
+    for (j = 0; j < HWSCALE_WIDTH; j++)
+    {
+      int offset=(HWSCALE_WIDTH*i+j)*2;
+      yuv[offset] = 0;
+      yuv[offset+1]=-128;
+    }
+  }
+}
+
+void ClearYV12()
+{
+  int i,j;
+  char *y=HWSCALE_YPLANE;
+  char *u=HWSCALE_UPLANE;
+  char *v=HWSCALE_VPLANE;
+  fprintf(stderr,"Clearing YV12\n");
+  for (i = 0; i < HWSCALE_HEIGHT; i++) {
+    for (j = 0; j < HWSCALE_WIDTH; j++) {
+      int offset=(HWSCALE_WIDTH*i+j);
+      y[offset] = 0;
+      if((i&1) && (j&1))
+      {
+        offset = (HWSCALE_WIDTH/2)*(i/2) + (j/2);
+        u[offset] = -128;
+        v[offset] = -128;
+      }
+    }
+  }
+}
+
+#endif
+
+/*
+ * This function creates an invisible cursor.
+ *
+ * I got the idea and code fragment from in the Apple II+ Emulator
+ * version 0.06 for Linux by Aaron Culliney
+ * <chernabog@baldmountain.bbn.com>
+ *
+ * I also found a post from Steve Lamont <spl@szechuan.ucsd.edu> on
+ * xforms@bob.usuf2.usuhs.mil.  His comments read:
+ *
+ * Lifted from unclutter
+ * Mark M Martin. cetia 1991 mmm@cetia.fr
+ * Version 4 changes by Charles Hannum <mycroft@ai.mit.edu>
+ *
+ * So I guess this code has been around the block a few times.
+ */
+
+static Cursor create_invisible_cursor (Display * display, Window win)
+{
+   Pixmap cursormask;
+   XGCValues xgc;
+   XColor dummycolour;
+   Cursor cursor;
+   GC gc;
+
+   cursormask = XCreatePixmap (display, win, 1, 1, 1 /*depth */ );
+   xgc.function = GXclear;
+   gc = XCreateGC (display, cursormask, GCFunction, &xgc);
+   XFillRectangle (display, cursormask, gc, 0, 0, 1, 1);
+   dummycolour.pixel = 0;
+   dummycolour.red = 0;
+   dummycolour.flags = 04;
+   cursor = XCreatePixmapCursor (display, cursormask, cursormask,
+                                 &dummycolour, &dummycolour, 0, 0);
+   XFreeGC (display, gc);
+   XFreePixmap (display, cursormask);
+   return cursor;
+}
+
+static int x11_find_best_visual(int bitmap_depth)
+{
+   XVisualInfo visualinfo;
+   int screen_no = DefaultScreen (display);
+
+   if (XMatchVisualInfo (display, screen_no, 32, TrueColor, &visualinfo))
+   {
+      xvisual = visualinfo.visual;
+      depth   = 32;
+      return 0;
+   }
+
+   if (XMatchVisualInfo (display, screen_no, 24, TrueColor, &visualinfo))
+   {
+      xvisual = visualinfo.visual;
+      depth   = 24;
+      return 0;
+   }
+
+   if (XMatchVisualInfo (display, screen_no, 16, TrueColor, &visualinfo))
+   {
+      xvisual = visualinfo.visual;
+      depth   = 16;
+      return 0;
+   }
+
+   if (XMatchVisualInfo (display, screen_no, 15, TrueColor, &visualinfo))
+   {
+      xvisual = visualinfo.visual;
+      depth   = 15;
+      return 0;
+   }
+
+   if (bitmap_depth == 8 &&
+      XMatchVisualInfo (display, screen_no, 8, PseudoColor, &visualinfo))
+   {
+      xvisual = visualinfo.visual;
+      depth   = 8;
+      return 0;
+   }
+   return -1;
+}
+
+int x11_window_16bpp_capable(void)
+{
+   return !x11_find_best_visual(16);
+}
+
+/* This name doesn't really cover this function, since it also sets up mouse
+   and keyboard. This is done over here, since on most display targets the
+   mouse and keyboard can't be setup before the display has. */
+int x11_window_create_display (int bitmap_depth)
+{
+	XSetWindowAttributes winattr;
+	XGCValues xgcv;
+	int screen_no;
+	XEvent event;
+	XSizeHints hints;
+	XWMHints wm_hints;
+	int geom_width, geom_height;
+	int image_height;
+	int i;
+	int event_mask;
+	int window_width, window_height;
+	int my_use_private_cmap = use_private_cmap;
+
+	/* set all the default values */
+	window = 0;
+	image  = NULL;
+#ifdef USE_XV
+	xvimage = NULL;
+#endif
+#ifdef USE_MITSHM
+	mit_shm_attached = 0;
+#endif
+	private_cmap_allocated = 0;
+	pseudo_color_allocated = NULL;
+	pseudo_color_lookup = NULL;
+	pseudo_color_lookup_dirty = FALSE;
+	pseudo_color_use_rw_palette = FALSE;
+	pseudo_color_warn_low_on_colors = TRUE;
+
+	window_width     = widthscale  * visual_width;
+	window_height    = yarbsize ? yarbsize : (heightscale * visual_height);
+	image_width      = widthscale  * visual_width;
+	image_height     = yarbsize ? yarbsize : (heightscale * visual_height);
+	orig_widthscale  = widthscale;
+	orig_heightscale = heightscale;
+	screen           = DefaultScreenOfDisplay (display);
+	screen_no        = DefaultScreen (display);
+
+#ifdef USE_HWSCALE
+	use_xv = (x11_video_mode == X11_XV_WINDOW
+			|| x11_video_mode == X11_XV_FULLSCREEN);
+
+	hwscale_fullscreen = (x11_video_mode == X11_XV_FULLSCREEN);
+
+	if (hwscale_yv12)
+		hwscale_yuv=1;
+
+	if(use_xv)
+		use_hwscale=1;
+	else
+		use_hwscale=0;
+#endif
+
+	if(run_in_root_window)
+	{
+		xvisual = DefaultVisual(display, screen_no);
+		depth   = DefaultDepth(display, screen_no);
+		my_use_private_cmap = 0;
+	}
+	else
+	{
+		if(x11_find_best_visual(bitmap_depth))
+		{
+			fprintf(stderr_file, "X11: Error: Couldn't find a suitable visual\n");
+			return OSD_NOT_OK;
+		}
+		if ( (xvisual->class != DefaultVisual(display, screen_no)->class) ||
+				(DefaultDepth(display, screen_no) != depth) )
+		{
+			my_use_private_cmap = TRUE;
+		}
+	}
+
+	fprintf(stderr_file, "Using a Visual with a depth of %dbpp.\n", depth);
+
+	/* check the available extensions if compiled in */
+#ifdef USE_XIL
+	if (use_xil)
+	{
+		init_xil ();
+	}
+
+	/*
+	 *  If the XIL initialization worked, then use_xil will still be set.
+	 */
+	if (use_xil)
+	{
+		image_width  = visual_width;
+		image_height = visual_height;
+		widthscale   = 1;
+		heightscale  = 1;
+		x11_window_update_method = X11_XIL;
+	}
+#endif
+#if defined USE_XIL && defined USE_MITSHM
+	else
+#endif
+#ifdef USE_MITSHM
+		if (use_mit_shm)             /* look for available Mitshm extensions */
+		{
+			/* get XExtensions to be if mit shared memory is available */
+			if (XQueryExtension (display, "MIT-SHM", &i, &i, &i))
+			{
+				x11_window_update_method = X11_MITSHM;
+			}
+			else
+			{
+				fprintf (stderr_file, "X-Server Doesn't support MIT-SHM extension\n");
+				use_mit_shm = 0;
+			}
+		}
+#endif
+#ifdef USE_XV
+	if (use_xv)             /* look for available Xv extensions */
+	{
+		unsigned int p_version,p_release,p_request_base,p_event_base,p_error_base;
+		if(XvQueryExtension(display, &p_version, &p_release, &p_request_base,
+					&p_event_base, &p_error_base)==Success)
+		{
+			x11_window_update_method = X11_XV;
+		}
+		else
+		{
+			fprintf (stderr_file, "X-Server Doesn't support Xv extension\n");
+			use_xv = 0;
+#ifdef USE_HWSCALE
+			use_hwscale = 0;
+#endif
+		}
+	}
+#endif
+
+	/* create / asign a colormap */
+	if (my_use_private_cmap)
+	{
+		colormap = XCreateColormap (display, RootWindowOfScreen (screen), xvisual, AllocNone);
+		private_cmap_allocated = 1;
+		black_pen = 0;
+		fprintf (stderr_file, "Using private color map\n");
+	}
+	else
+	{
+		colormap = DefaultColormapOfScreen (screen);
+		black_pen = BlackPixelOfScreen (screen);
+	}
+
+
+	if (run_in_root_window)
+	{
+		int width  = DisplayWidth(display, screen_no);
+		int height = DisplayHeight(display, screen_no);
+		if (window_width > width || window_height > height)
+		{
+			fprintf (stderr_file, "OSD ERROR: Root window is to small: %dx%d, needed %dx%d\n",
+					width, height, window_width, window_height);
+			return OSD_NOT_OK;
+		}
+
+		startx        = ((width  - window_width)  / 2) & ~0x07;
+		starty        = ((height - window_height) / 2) & ~0x07;
+		window        = RootWindowOfScreen (screen);
+		window_width  = width;
+		window_height = height;
+		use_mouse     = FALSE;
+	}
+	else
+	{
+		/*  Placement hints etc. */
+
+#ifdef USE_XIL
+		/*
+		 *  XIL allows us to rescale the window on the fly,
+		 *  so in this case, we don't prevent the user from
+		 *  resizing.
+		 */
+		if (use_xil)
+		{
+			hints.flags = PSize;
+		}
+		else
+#endif
+			hints.flags = PSize | PMinSize | PMaxSize;
+
+#ifdef USE_HWSCALE
+		if(use_hwscale)
+		{
+			hints.flags = PSize;
+			if(hwscale_fullscreen)
+			{
+				hints.flags=PMinSize|PMaxSize;
+				hints.flags|=USPosition|USSize;
+				window_width  = DisplayWidth(display, screen_no);
+				window_height = DisplayHeight(display, screen_no);
+			}
+		}
+#endif
+		hints.min_width  = hints.max_width  = hints.base_width  = window_width;
+		hints.min_height = hints.max_height = hints.base_height = window_height;
+		hints.x = hints.y = 0;
+		hints.win_gravity = NorthWestGravity;
+
+		i = XWMGeometry(display, screen_no, geometry, NULL, 0, &hints, &hints.x,
+				&hints.y, &geom_width, &geom_height, &hints.win_gravity);
+		if ((i&XValue) && (i&YValue))
+			hints.flags |= PPosition | PWinGravity;
+
+#ifdef USE_HWSCALE
+		if (use_hwscale)
+		{
+			if (i&WidthValue)
+				window_width = geom_width;
+			if (i&HeightValue)
+				window_height = geom_height;
+		}
+#endif
+
+		/* Create and setup the window. No buttons, no fancy stuff. */
+
+		winattr.background_pixel  = black_pen;
+		winattr.border_pixel      = WhitePixelOfScreen (screen);
+		winattr.bit_gravity       = ForgetGravity;
+		winattr.win_gravity       = hints.win_gravity;
+		winattr.backing_store     = NotUseful;
+		winattr.override_redirect = False;
+		winattr.save_under        = False;
+		winattr.event_mask        = 0;
+		winattr.do_not_propagate_mask = 0;
+		winattr.colormap          = colormap;
+		winattr.cursor            = None;
+
+		if (root_window_id == 0)
+		{
+			root_window_id = RootWindowOfScreen (screen);
+		}
+		window = XCreateWindow (display, root_window_id, hints.x, hints.y,
+				window_width, window_height,
+				0, depth,
+				InputOutput, xvisual,
+				(CWBorderPixel | CWBackPixel | CWBitGravity |
+				 CWWinGravity | CWBackingStore |
+				 CWOverrideRedirect | CWSaveUnder | CWEventMask |
+				 CWDontPropagate | CWColormap | CWCursor),
+				&winattr);
+		if (!window)
+		{
+			fprintf (stderr_file, "OSD ERROR: failed in XCreateWindow().\n");
+			return OSD_NOT_OK;
+		}
+
+		wm_hints.input = TRUE;
+		wm_hints.flags = InputHint;
+
+		XSetWMHints (display, window, &wm_hints);
+		XSetWMNormalHints (display, window, &hints);
+#ifdef USE_HWSCALE
+		/* Hack to get rid of window title bar */
+		if(use_hwscale && hwscale_fullscreen)
+		{
+			Atom mwmatom;
+			MotifWmHints mwmhints;
+			mwmhints.flags=MWM_HINTS_DECORATIONS;
+			mwmhints.decorations=0;
+			mwmatom=XInternAtom(display,"_MOTIF_WM_HINTS",0);
+
+			XChangeProperty(display,window,mwmatom,mwmatom,32,
+					PropModeReplace,(unsigned char *)&mwmhints,4);
+		}
+#endif
+
+#if defined(__sgi)
+		/* Force first resource class char to be uppercase */
+		class_hints.res_class[0] &= 0xDF;
+		/*
+		 * Set the application class (WM_CLASS) so that 4Dwm can display
+		 * the appropriate pixmap when the application is iconified
+		 */
+		XSetClassHint(display, window, &class_hints);
+		/* Use a simpler name for the icon */
+		XSetIconName(display, window, NAME);
+#endif
+
+		XStoreName (display, window, title);
+
+		/* Select event mask */
+
+		event_mask = FocusChangeMask | ExposureMask |
+			EnterWindowMask | LeaveWindowMask |
+			KeyPressMask | KeyReleaseMask;
+		if (use_mouse)
+		{
+			event_mask |= ButtonPressMask | ButtonReleaseMask;
+		}
+
+#if defined(__sgi) && ! defined(MESS)
+		/*
+		 * In Xmame, we want to know when we are unmapped (iconified) or mapped,
+		 * so that the game can be paused/restarted automatically
+		 * (boss hanging around mode :)
+		 */
+		event_mask |= StructureNotifyMask;
+#endif
+
+#ifdef USE_XIL
+		if (use_xil)
+		{
+			event_mask |= StructureNotifyMask;
+		}
+#endif
+		XSelectInput (display, window, event_mask);
+
+		XMapRaised (display, window);
+		XClearWindow (display, window);
+		XWindowEvent (display, window, ExposureMask, &event);
+	}
+
+	/* create and setup the image */
+	switch (x11_window_update_method)
+	{
+		case X11_XIL:
+#ifdef USE_XIL
+			/*
+			 *  XIL takes priority over MITSHM
+			 */
+			setup_xil_images (image_width, image_height);
+#endif
+			break;
+		case X11_MITSHM:
+#ifdef USE_MITSHM
+			/* Create a MITSHM image. */
+			fprintf (stderr_file, "MIT-SHM Extension Available. trying to use... ");
+			XSetErrorHandler (test_mit_shm);
+
+			image = XShmCreateImage (display,
+					xvisual,
+					depth,
+					ZPixmap,
+					NULL,
+					&shm_info,
+					image_width,
+					image_height);
+			if (image)
+			{
+				shm_info.shmid = shmget (IPC_PRIVATE,
+						image->bytes_per_line * image->height,
+						(IPC_CREAT | 0777));
+				if (shm_info.shmid < 0)
+				{
+					fprintf (stderr_file, "\nError: failed to create MITSHM block.\n");
+					return OSD_NOT_OK;
+				}
+
+				/* And allocate the bitmap buffer. */
+				/* new pen color code force double buffering in every cases */
+				image->data = shm_info.shmaddr =
+					(char *) shmat (shm_info.shmid, 0, 0);
+
+				scaled_buffer_ptr = (unsigned char *) image->data;
+				if (!scaled_buffer_ptr)
+				{
+					fprintf (stderr_file, "\nError: failed to allocate MITSHM bitmap buffer.\n");
+					return OSD_NOT_OK;
+				}
+
+				shm_info.readOnly = FALSE;
+
+				/* Attach the MITSHM block. this will cause an exception if */
+				/* MIT-SHM is not available. so trap it and process         */
+				if (!XShmAttach (display, &shm_info))
+				{
+					fprintf (stderr_file, "\nError: failed to attach MITSHM block.\n");
+					return OSD_NOT_OK;
+				}
+				XSync (display, False);  /* be sure to get request processed */
+				sleep (2);          /* enought time to notify error if any */
+				XSetErrorHandler (None);  /* Restore error handler to default */
+				/* Mark segment as deletable after we attach.  When all processes
+				   detach from the segment (progam exits), it will be deleted.
+				   This way it won't be left in memory if we crash or something.
+				   Grr, have todo this after X attaches too since slowlaris doesn't
+				   like it otherwise */
+				shmctl(shm_info.shmid, IPC_RMID, NULL);
+
+				/* if use_mit_shm is still set we've succeeded */
+				if (use_mit_shm)
+				{
+					fprintf (stderr_file, "Success.\nUsing Shared Memory Features to speed up\n");
+					mit_shm_attached = 1;
+					break;
+				}
+				/* else we have failed clean up before retrying without MITSHM */
+				shmdt ((char *) scaled_buffer_ptr);
+				scaled_buffer_ptr = NULL;
+				XDestroyImage (image);
+				image = NULL;
+			}
+			fprintf (stderr_file, "Failed\nReverting to normal XPutImage() mode\n");
+			x11_window_update_method = X11_NORMAL;
+#endif
+		case X11_XV:
+#ifdef USE_XV
+			/* Create an XV MITSHM image. */
+			{
+				fprintf (stderr_file, "MIT-SHM & XV Extensions Available. trying to use... ");
+				XSetErrorHandler (test_mit_shm);
+				if(hwscale_yuv==0)
+				{
+					if(!(FindRGBXvFormat(display, &xv_port,&hwscale_format,&hwscale_bpp)))
+					{
+						hwscale_yuv=1;
+						fprintf(stderr,"\nCan't find a suitable RGB format - trying YUY2 instead... ");
+					}
+				}
+				if(hwscale_yuv)
+				{
+					hwscale_redmask=0xff0000;
+					hwscale_greenmask=0xff00;
+					hwscale_bluemask=0xff;
+					hwscale_bpp=32;
+					hwscale_format=FOURCC_YUY2;
+					if(hwscale_yv12 || !(FindXvPort(display, hwscale_format, &xv_port)))
+					{
+						if(!hwscale_yv12) fprintf(stderr,"\nYUY2 not available - trying YV12... ");
+						hwscale_format=FOURCC_YV12;
+						if(!(FindXvPort(display, hwscale_format, &xv_port)))
+						{
+							fprintf(stderr,"\nError: Couldn't initialise Xv port - ");
+							fprintf(stderr,"\n  Either all ports are in use, or the video card");
+							fprintf(stderr,"\n  doesn't provide a suitable format.\n");
+							return OSD_NOT_OK;
+						}
+						else
+							fprintf(stderr,"\nWarning: YV12 support is incomplete... ");
+
+					}
+				}
+
+				xvimage = XvShmCreateImage (display,
+						xv_port,
+						hwscale_format,
+						0,
+						image_width,
+						image_height,
+						&shm_info);
+				if (xvimage)
+				{
+					shm_info.shmid = shmget (IPC_PRIVATE,
+							xvimage->data_size,
+							(IPC_CREAT | 0777));
+					if (shm_info.shmid < 0)
+					{
+						fprintf (stderr_file, "\nError: failed to create MITSHM block.\n");
+						return OSD_NOT_OK;
+					}
+
+					/* And allocate the bitmap buffer. */
+					/* new pen color code force double buffering in every cases */
+					xvimage->data = shm_info.shmaddr =
+						(char *) shmat (shm_info.shmid, 0, 0);
+
+					scaled_buffer_ptr = (unsigned char *) xvimage->data;
+					if (!scaled_buffer_ptr)
+					{
+						fprintf (stderr_file, "\nError: failed to allocate MITSHM bitmap buffer.\n");
+						return OSD_NOT_OK;
+					}
+
+					shm_info.readOnly = FALSE;
+
+					/* Attach the MITSHM block. this will cause an exception if */
+					/* MIT-SHM is not available. so trap it and process         */
+					if (!XShmAttach (display, &shm_info))
+					{
+						fprintf (stderr_file, "\nError: failed to attach MITSHM block.\n");
+						return OSD_NOT_OK;
+					}
+					XSync (display, False);  /* be sure to get request processed */
+					sleep (2);          /* enought time to notify error if any */
+					XSetErrorHandler (None);  /* Restore error handler to default */
+					/* Mark segment as deletable after we attach.  When all processes
+					   detach from the segment (progam exits), it will be deleted.
+					   This way it won't be left in memory if we crash or something.
+					   Grr, have todo this after X attaches too since slowlaris doesn't
+					   like it otherwise */
+					shmctl(shm_info.shmid, IPC_RMID, NULL);
+
+					/* if use_mit_shm is still set we've succeeded */
+					if (use_mit_shm)
+					{
+						fprintf (stderr_file, "Success.\nUsing Xv & Shared Memory Features to speed up\n");
+						mit_shm_attached = 1;
+						break;
+					}
+					/* else we have failed clean up before retrying without MITSHM */
+					shmdt ((char *) scaled_buffer_ptr);
+					scaled_buffer_ptr = NULL;
+					XDestroyImage (image);
+					image = NULL;
+				}
+			}
+			fprintf (stderr_file, "Failed\nReverting to normal XPutImage() mode\n");
+			x11_window_update_method = X11_NORMAL;
+#endif
+		case X11_NORMAL:
+			scaled_buffer_ptr = malloc (4 * image_width * image_height);
+			if (!scaled_buffer_ptr)
+			{
+				fprintf (stderr_file, "Error: failed to allocate bitmap buffer.\n");
+				return OSD_NOT_OK;
+			}
+			image = XCreateImage (display,
+					xvisual,
+					depth,
+					ZPixmap,
+					0,
+					(char *) scaled_buffer_ptr,
+					image_width, image_height,
+					32, /* image_width always is a multiple of 8 */
+					0);
+
+			if (!image)
+			{
+				fprintf (stderr_file, "OSD ERROR: could not create image.\n");
+				return OSD_NOT_OK;
+			}
+			break;
+		default:
+			fprintf (stderr_file, "Error unknown X11 update method, this shouldn't happen\n");
+			return OSD_NOT_OK;
+	}
+
+	/* verify the number of bits per pixel and choose the correct update method */
+#ifdef USE_HWSCALE
+	if (use_hwscale)
+		depth = hwscale_bpp;
+	else
+#endif
+#ifdef USE_XIL
+		if (use_xil)
+			/* XIL uses 16 bit visuals and does any conversion it self */
+			depth = 16;
+		else
+#endif
+			depth = image->bits_per_pixel;
+
+	/* setup the palette_info struct now we have the depth */
+	if (x11_init_palette_info() != OSD_OK)
+		return OSD_NOT_OK;
+
+	fprintf(stderr_file, "Actual bits per pixel = %d... ", depth);
+	if (bitmap_depth == 32)
+	{
+#ifdef USE_HWSCALE
+		if(use_hwscale && hwscale_yuv)
+		{
+			switch(hwscale_format)
+			{
+				case FOURCC_YUY2:
+					ClearYUY2();
+					x11_window_update_display_func = x11_window_update_32_to_YUY2_direct;
+					break;
+				case FOURCC_YV12:
+					ClearYV12();
+					if (widthscale == 1 && heightscale == 1)
+						x11_window_update_display_func
+							= x11_window_update_32_to_YV12_direct;
+					else if (widthscale ==2 && heightscale == 2)
+						x11_window_update_display_func
+							= x11_window_update_32_to_YV12_direct_perfect;
+					else
+					{
+						fprintf(stderr_file, "\nScaling different from 1 or 2"
+								" is useless and unsupported\n");
+						return OSD_NOT_OK;
+					}
+					break;
+			}
+		}
+		else
+#endif
+			if (depth == 32)
+				x11_window_update_display_func = x11_window_update_32_to_32bpp_direct;
+	}
+	else if (bitmap_depth == 16)
+	{
+#ifdef USE_HWSCALE
+		if(use_hwscale && hwscale_yuv)
+		{
+			switch(hwscale_format)
+			{
+				case FOURCC_YUY2:
+					ClearYUY2();
+					x11_window_update_display_func = x11_window_update_16_to_YUY2;
+					break;
+				case FOURCC_YV12:
+					ClearYV12();
+					if (widthscale == 1 && heightscale == 1)
+						x11_window_update_display_func
+							= x11_window_update_16_to_YV12;
+					else if (widthscale ==2 && heightscale == 2)
+						x11_window_update_display_func
+							= x11_window_update_16_to_YV12_perfect;
+					else
+					{
+						fprintf(stderr_file, "\nScaling different from 1 or 2"
+								" is useless and unsupported\n");
+						return OSD_NOT_OK;
+					}
+					break;
+			}
+		}
+		else
+#endif
+			switch (depth)
+			{
+				case 16:
+					x11_window_update_display_func = x11_window_update_16_to_16bpp;
+					break;
+				case 24:
+					x11_window_update_display_func = x11_window_update_16_to_24bpp;
+					break;
+				case 32:
+					x11_window_update_display_func = x11_window_update_16_to_32bpp;
+					break;
+			}
+	}
+
+	if (x11_window_update_display_func == NULL)
+	{
+		fprintf(stderr_file, "Error: Unsupported bitmap depth = %dbpp, video depth = %dbpp\n", bitmap_depth, depth);
+		return OSD_NOT_OK;
+	}
+	fprintf(stderr_file, "Ok\n");
+
+	/* create gc */
+	gc = XCreateGC (display, window, 0, &xgcv);
+
+	/* mouse pointer stuff */
+	if (!use_mouse || (x11_grab_mouse &&  XGrabPointer (display, window, True,
+					0, GrabModeAsync, GrabModeAsync, window, None, CurrentTime)))
+		x11_grab_mouse = FALSE;
+
+	if (x11_grab_keyboard && XGrabKeyboard(display, window, True, GrabModeAsync, GrabModeAsync, CurrentTime))
+		fprintf(stderr_file, "Warning: keyboard grab failed\n");
+
+	if (!run_in_root_window)
+	{
+		normal_cursor = XCreateFontCursor (display, XC_trek);
+		invisible_cursor = create_invisible_cursor (display, window);
+
+		if (x11_grab_mouse || !show_cursor)
+			XDefineCursor (display, window, invisible_cursor);
+		else
+			XDefineCursor (display, window, normal_cursor);
+	}
+
+#ifdef USE_HWSCALE
+	if(use_hwscale && hwscale_yuv)
+		effect_init2(bitmap_depth, hwscale_format, window_width);
+	/* HACK - HACK - HACK - sending FourCC code for YUV format in place of depth... */
+	else
+#endif
+		effect_init2(bitmap_depth, depth, window_width);
+
+	return OSD_OK;
+}
+
+/*
+ * Shut down the display, also called by the core to clean up if any error
+ * happens when creating the display.
+ */
+void x11_window_close_display (void)
+{
+   /* FIXME: free cursors */
+   int i;
+
+   widthscale  = orig_widthscale;
+   heightscale = orig_heightscale;
+
+   /* better free any allocated colors before freeing the colormap */
+   if (pseudo_color_lookup)
+   {
+      if (pseudo_color_use_rw_palette)
+      {
+         XFreeColors (display, colormap, pseudo_color_lookup,
+            display_palette_info.writable_colors, 0);
+      }
+      else
+      {
+         for (i = 0; i < display_palette_info.writable_colors; i++)
+         {
+            if (pseudo_color_allocated[i])
+               XFreeColors (display, colormap, &pseudo_color_lookup[i], 1, 0);
+         }
+         free(pseudo_color_allocated);
+      }
+      free(pseudo_color_lookup);
+   }
+
+   /* This is only allocated/done if we succeeded to get a window */
+   if (window)
+   {
+      if (x11_grab_mouse)
+         XUngrabPointer (display, CurrentTime);
+
+      if (x11_grab_keyboard)
+         XUngrabKeyboard (display, CurrentTime);
+
+#ifdef USE_MITSHM
+      if (use_mit_shm)
+      {
+         if (mit_shm_attached)
+            XShmDetach (display, &shm_info);
+         if (scaled_buffer_ptr)
+            shmdt (scaled_buffer_ptr);
+         scaled_buffer_ptr = NULL;
+      }
+#endif
+      if (image)
+      {
+         XDestroyImage (image);
+         scaled_buffer_ptr = NULL;
+      }
+#ifdef USE_XV
+      if(use_xv && xv_port>-1)
+      {
+        XvUngrabPort(display,xv_port,CurrentTime);
+        xv_port=-1;
+      }
+      if(xvimage)
+      {
+         XFree(xvimage);
+         scaled_buffer_ptr = NULL;
+         xvimage=NULL;
+      }
+#endif
+      if (scaled_buffer_ptr)
+         free (scaled_buffer_ptr);
+
+      XDestroyWindow (display, window);
+   }
+
+   if (private_cmap_allocated)
+      XFreeColormap (display, colormap);
+
+   XSync (display, False);      /* send all events to sync; */
+}
+
+/*
+ * Set the screen colors using the given palette.
+ *
+ */
+int x11_window_alloc_palette (int writable_colors)
+{
+   int i;
+
+   /* this is only relevant for 8bpp displays */
+   if (depth != 8)
+      return 0;
+
+   if(!(pseudo_color_lookup = malloc(writable_colors * sizeof(unsigned long))))
+   {
+      fprintf(stderr_file, "X11-window: Error: Malloc failed for pseudo color lookup table\n");
+      return -1;
+   }
+
+   /* set the palette to black */
+   for (i = 0; i < writable_colors; i++)
+      pseudo_color_lookup[i] = black_pen;
+
+   /* allocate color cells */
+   if (XAllocColorCells (display, colormap, 0, 0, 0, pseudo_color_lookup,
+      writable_colors))
+   {
+      pseudo_color_use_rw_palette = 1;
+      fprintf (stderr_file, "Using r/w palette entries to speed up, good\n");
+      for (i = 0; i < writable_colors; i++)
+         if (pseudo_color_lookup[i] != i) break;
+   }
+   else
+   {
+      if (!(pseudo_color_allocated = calloc(writable_colors, sizeof(char))))
+      {
+         fprintf(stderr_file, "X11-window: Error: Malloc failed for pseudo color lookup table\n");
+         XFreeColors (display, colormap, pseudo_color_lookup,
+            writable_colors, 0);
+         free(pseudo_color_lookup);
+         pseudo_color_lookup=NULL;
+         return -1;
+      }
+   }
+
+   display_palette_info.writable_colors = writable_colors;
+   return 0;
+}
+
+int x11_window_modify_pen (int pen, unsigned char red, unsigned char green,
+   unsigned char blue)
+{
+   XColor color;
+
+   /* Translate 0-255 values of new color to X 0-65535 values. */
+   color.flags = (DoRed | DoGreen | DoBlue);
+   color.red = (int) red << 8;
+   color.green = (int) green << 8;
+   color.blue = (int) blue << 8;
+   color.pixel = pseudo_color_lookup[pen];
+
+   if (pseudo_color_use_rw_palette)
+   {
+      XStoreColor (display, colormap, &color);
+   }
+   else
+   {
+      /* free previously allocated color */
+      if (pseudo_color_allocated[pen])
+      {
+         XFreeColors (display, colormap, &pseudo_color_lookup[pen], 1, 0);
+         pseudo_color_allocated[pen] = FALSE;
+      }
+
+      /* allocate new color and assign it to pen index */
+      if (XAllocColor (display, colormap, &color))
+      {
+         if (pseudo_color_lookup[pen] != color.pixel)
+            pseudo_color_lookup_dirty = TRUE;
+         pseudo_color_lookup[pen] = color.pixel;
+         pseudo_color_allocated[pen] = TRUE;
+      }
+      else /* try again with the closest match */
+      {
+         int i;
+         XColor colors[256];
+         int my_red   = (int)red << 8;
+         int my_green = (int)green << 8;
+         int my_blue  = (int)blue << 8;
+         int best_pixel = black_pen;
+         float best_diff = FLT_MAX;
+
+         for(i=0;i<256;i++)
+            colors[i].pixel = i;
+
+         XQueryColors(display, colormap, colors, 256);
+         for(i=0;i<256;i++)
+         {
+            #define SQRT(x) ((float)(x)*(x))
+            float diff = SQRT(my_red - colors[i].red) +
+               SQRT(my_green - colors[i].green) +
+               SQRT(my_blue - colors[i].blue);
+            if (diff < best_diff)
+            {
+               best_pixel = colors[i].pixel;
+               best_diff  = diff;
+            }
+         }
+
+         color = colors[best_pixel];
+
+         if (XAllocColor (display, colormap, &color))
+         {
+            if (pseudo_color_lookup[pen] != color.pixel)
+               pseudo_color_lookup_dirty = TRUE;
+            pseudo_color_lookup[pen] = color.pixel;
+            pseudo_color_allocated[pen] = TRUE;
+         }
+         else
+         {
+            if (pseudo_color_warn_low_on_colors)
+            {
+               pseudo_color_warn_low_on_colors = 0;
+               fprintf (stderr_file,
+                  "X11-palette: Warning: Closest color match alloc failed\n"
+                  "Couldn't allocate all colors, some parts of the emulation may be black\n"
+                  "Try running xmame with the -privatecmap option\n");
+            }
+
+            /* If color allocation failed, use black to ensure the
+               pen is not left set to an invalid color */
+            pseudo_color_lookup[pen] = black_pen;
+            return -1;
+         }
+      }
+   }
+   return 0;
+}
+
+/* invoked by main tree code to update bitmap into screen */
+void x11_window_update_display (struct mame_bitmap *bitmap)
+{
+#ifdef USE_HWSCALE
+   if(use_hwscale && hwscale_yuv)
+     x11_window_make_yuv_lookup();
+#endif
+
+   (*x11_window_update_display_func) (bitmap);
+
+#ifdef USE_XV
+   if (use_xv)
+      x11_window_refresh_screen();
+#endif
+
+#ifdef USE_XIL
+   if (use_xil)
+      refresh_xil_screen ();
+#endif
+
+   if (use_mouse &&
+       keyboard_pressed (KEYCODE_LALT) &&
+       keyboard_pressed_memory (KEYCODE_PGDN))
+   {
+      if (x11_grab_mouse)
+      {
+         XUngrabPointer (display, CurrentTime);
+         if (show_cursor)
+            XDefineCursor (display, window, normal_cursor);
+         x11_grab_mouse = FALSE;
+      }
+      else
+      {
+         if (!XGrabPointer (display, window, True, 0, GrabModeAsync,
+                            GrabModeAsync, window, None, CurrentTime))
+         {
+            if (show_cursor)
+               XDefineCursor (display, window, invisible_cursor);
+            x11_grab_mouse = TRUE;
+         }
+      }
+   }
+
+   /* toggle keyboard grabbing */
+   if (keyboard_pressed (KEYCODE_LALT) &&
+       keyboard_pressed_memory (KEYCODE_PGUP))
+   {
+     if (x11_grab_keyboard)
+     {
+       XUngrabKeyboard (display, CurrentTime);
+       x11_grab_keyboard = FALSE;
+     }
+     else
+     {
+       if (!XGrabKeyboard(display, window, True, GrabModeAsync, GrabModeAsync, CurrentTime))
+	 x11_grab_keyboard = TRUE;
+       else
+	 fprintf(stderr_file, "Warning: keyboard grab failed\n");
+     }
+   }
+
+   /* some games "flickers" with XFlush, so command line option is provided */
+   if (use_xsync)
+      XSync (display, False);   /* be sure to get request processed */
+   else
+      XFlush (display);         /* flush buffer to server */
+}
+
+void x11_window_refresh_screen (void)
+{
+   switch (x11_window_update_method)
+   {
+      case X11_XIL:
+#ifdef USE_XIL
+         refresh_xil_screen ();
+#endif
+         break;
+      case X11_MITSHM:
+#ifdef USE_MITSHM
+         XShmPutImage (display, window, gc, image, 0, 0, 0, 0, image->width,
+                       image->height, FALSE);
+#endif
+         break;
+      case X11_XV:
+#ifdef USE_XV
+         {
+            Window _dw;
+            int _dint;
+	    unsigned int _w,_h,_duint;
+            long pw,ph;
+            XGetGeometry(display, window, &_dw, &_dint, &_dint, &_w, &_h, &_duint, &_duint);
+
+		if (normal_use_aspect_ratio)
+			pw = aspect_ratio * _h;
+		else
+			pw = ((double)HWSCALE_WIDTH / (double)HWSCALE_HEIGHT) * _h;
+		ph = _h;
+
+		if (hwscale_widescreen)
+			pw *= (double)0.75;
+
+		if (pw > _w)
+		{
+			ph *= ((double)_w / (double)pw);
+			pw = _w;
+		}
+
+            XvShmPutImage (display, xv_port, window, gc, xvimage,
+            0, 0, HWSCALE_WIDTH, HWSCALE_HEIGHT,
+            (_w-pw)/2, (_h-ph)/2, pw, ph, True);
+         }
+#endif
+         break;
+      case X11_NORMAL:
+         XPutImage (display, window, gc, image, 0, 0, 0, 0, image->width,
+                    image->height);
+         break;
+   }
+}
+
+INLINE void x11_window_put_image (int x, int y, int width, int height)
+{
+   switch (x11_window_update_method)
+   {
+      case X11_XV:
+         break;
+      case X11_XIL:
+         /* xil doesn't need a put_image */
+         break;
+      case X11_MITSHM:
+#ifdef USE_MITSHM
+         XShmPutImage (display, window, gc, image, x, y, x+startx, y+starty, width, height,
+                       FALSE);
+#endif
+         break;
+      case X11_NORMAL:
+         XPutImage (display, window, gc, image, x, y, x+startx, y+starty, width, height);
+         break;
+   }
+}
+
+#ifdef USE_HWSCALE
+#define RMASK 0xff0000
+#define GMASK 0x00ff00
+#define BMASK 0x0000ff
+
+#define RGB2YUV(r,g,b,y,u,v) \
+                (y) =  ( 9797*(r) + 19237*(g) +  3734*(b) ) >> 15;\
+                (u) =  (18492*((b)-(y)) >> 15) + 128;\
+                (v) =  (23372*((r)-(y)) >> 15) + 128;
+
+static void x11_window_make_yuv_lookup()
+{
+   int i,r,g,b,y,u,v,n;
+   n=current_palette->emulated.writable_colors;
+
+   if(!hwscale_yuvlookup)
+   {
+      fprintf(stderr,"Making YUV lookup\n");
+      hwscale_yuvlookup=malloc(sizeof(int)*n);
+   }
+
+   if(current_palette->dirty)
+   {
+      for(i=0;i<n;++i)
+      {
+        r=g=b=current_palette->lookup[i];
+        r=(r&RMASK)>>16;
+        g=(g&GMASK)>>8;
+        b=(b&BMASK);
+
+        RGB2YUV(r,g,b,y,u,v);
+
+        /* Storing this data in YUYV order simplifies using the data for
+           YUY2, both with and without smoothing... */
+        hwscale_yuvlookup[i]=(y<<0) | (u<<8) | (y<<16) | (v<<24);
+      }
+   }
+}
+
+/* Hacked into place, until I integrate YV12 support into the blit core... */
+static void x11_window_update_16_to_YV12(struct mame_bitmap *bitmap)
+{
+   int _x,_y;
+   char *dest_y;
+   char *dest_u;
+   char *dest_v;
+   unsigned short *src;
+   unsigned short *src2;
+   int u,v,y,u2,v2,y2,u3,v3,y3,u4,v4,y4;     /* 12 */
+   int *indirect=current_palette->lookup;    /* 34 */
+
+   for(_y=visual.min_y;_y<=visual.max_y;_y+=2)
+   {
+      src=bitmap->line[_y] ;
+      src+= visual.min_x;
+      src2=bitmap->line[_y+1];
+      src2+= visual.min_x;
+
+      dest_y=HWSCALE_YPLANE+(HWSCALE_WIDTH*(_y-visual.min_y));
+      dest_v=HWSCALE_UPLANE+((HWSCALE_WIDTH/2)*((_y-visual.min_y)/2));
+      dest_u=HWSCALE_VPLANE+((HWSCALE_WIDTH/2)*((_y-visual.min_y)/2));
+      for(_x=visual.min_x;_x<=visual.max_x;_x+=2)
+      {
+         if (indirect)
+         {
+            v = hwscale_yuvlookup[*src++];
+            y = (v)  & 0xff;
+            u = (v>>8) & 0xff;
+            v = (v>>24)     & 0xff;
+
+            v2 = hwscale_yuvlookup[*src++];
+            y2 = (v2)  & 0xff;
+            u2 = (v2>>8) & 0xff;
+            v2 = (v2>>24)     & 0xff;
+
+            v3 = hwscale_yuvlookup[*src2++];
+            y3 = (v3)  & 0xff;
+            u3 = (v3>>8) & 0xff;
+            v3 = (v3>>24)     & 0xff;
+
+            v4 = hwscale_yuvlookup[*src2++];
+            y4 = (v4)  & 0xff;
+            u4 = (v4>>8) & 0xff;
+            v4 = (v4>>24)     & 0xff;
+         }
+         else
+         { /* Can this really happen ? */
+            int r,g,b;
+            b = *src++;
+            r = (b>>16) & 0xFF;
+            g = (b>>8)  & 0xFF;
+            b = (b)     & 0xFF;
+            RGB2YUV(r,g,b,y,u,v);
+
+            b = *src++;
+            r = (b>>16) & 0xFF;
+            g = (b>>8)  & 0xFF;
+            b = (b)     & 0xFF;
+            RGB2YUV(r,g,b,y2,u2,v2);
+
+            b = *src2++;
+            r = (b>>16) & 0xFF;
+            g = (b>>8)  & 0xFF;
+            b = (b)     & 0xFF;
+            RGB2YUV(r,g,b,y3,u3,v3);
+
+            b = *src2++;
+            r = (b>>16) & 0xFF;
+            g = (b>>8)  & 0xFF;
+            b = (b)     & 0xFF;
+            RGB2YUV(r,g,b,y4,u4,v4);
+         }
+
+         *dest_y = y;
+         *(dest_y++ + HWSCALE_WIDTH) = y3;
+         *dest_y = y2;
+         *(dest_y++ + HWSCALE_WIDTH) = y4;
+
+         *dest_u++ = (u+u2+u3+u4)/4;
+         *dest_v++ = (v+v2+v3+v4)/4;
+
+         /* I thought that the following would be better, but it is not
+          * the case. The color gets blurred
+         if (y || y2 || y3 || y4) {
+                 *dest_u++ = (u*y+u2*y2+u3*y3+u4*y4)/(y+y2+y3+y4);
+                 *dest_v++ = (v*y+v2*y2+v3*y3+v4*y4)/(y+y2+y3+y4);
+         } else {
+                 *dest_u++ =128;
+                 *dest_v++ =128;
+         }
+         */
+      }
+   }
+}
+
+
+static void x11_window_update_16_to_YV12_perfect(struct mame_bitmap *bitmap)
+{      /* this one is used when scale==2 */
+   unsigned int _x,_y;
+   char *dest_y;
+   char *dest_u;
+   char *dest_v;
+   unsigned short *src;
+   unsigned short *src2;
+   int u,v,y;
+   int *indirect=current_palette->lookup;
+
+   for(_y=visual.min_y;_y<=visual.max_y;_y++)
+   {
+      src=bitmap->line[_y];
+      src += visual.min_x;
+      src2=bitmap->line[_y+1];
+      src2 += visual.min_x;
+
+      dest_y=HWSCALE_YPLANE+2*(HWSCALE_WIDTH*(_y-visual.min_y));
+      dest_v=HWSCALE_UPLANE+((HWSCALE_WIDTH/2)*((_y-visual.min_y)));
+      dest_u=HWSCALE_VPLANE+((HWSCALE_WIDTH/2)*((_y-visual.min_y)));
+      for(_x=visual.min_x;_x<=visual.max_x;_x++)
+      {
+         if (indirect)
+         {
+            v= hwscale_yuvlookup[*src++];
+            y = (v)  & 0xff;
+            u = (v>>8) & 0xff;
+            v = (v>>24)     & 0xff;
+         }
+         else
+         { /* Can this really happen ? */
+            int r,g,b;
+            b = *src++;
+            r = (b) & 0xFF;
+            g = (b>>8)  & 0xFF;
+            b = (b>>24)     & 0xFF;
+            RGB2YUV(r,g,b,y,u,v);
+         }
+
+         *(dest_y+HWSCALE_WIDTH)=y;
+         *dest_y++=y;
+         *(dest_y+HWSCALE_WIDTH)=y;
+         *dest_y++=y;
+         *dest_u++ = u;
+         *dest_v++ = v;
+      }
+   }
+}
+
+static void x11_window_update_32_to_YV12_direct(struct mame_bitmap *bitmap)
+{
+   int _x,_y,r,g,b;
+   char *dest_y;
+   char *dest_u;
+   char *dest_v;
+   unsigned int *src;
+   unsigned int *src2;
+   int u,v,y,u2,v2,y2,u3,v3,y3,u4,v4,y4;     /* 12 */
+                                             /* 34 */
+
+   for(_y=visual.min_y;_y<=visual.max_y;_y+=2)
+   {
+      src=bitmap->line[_y];
+      src+=visual.min_x;
+      src2=bitmap->line[_y+1];
+      src2 += visual.min_x;
+      dest_y=HWSCALE_YPLANE+(HWSCALE_WIDTH*(_y-visual.min_y));
+      dest_v=HWSCALE_UPLANE+((HWSCALE_WIDTH/2)*((_y-visual.min_y)/2));
+      dest_u=HWSCALE_VPLANE+((HWSCALE_WIDTH/2)*((_y-visual.min_y)/2));
+
+      for(_x=visual.min_x;_x<=visual.max_x;_x+=2)
+      {
+         b = *src++;
+         r = (b>>16) & 0xFF;
+         g = (b>>8)  & 0xFF;
+         b = (b)     & 0xFF;
+         RGB2YUV(r,g,b,y,u,v);
+
+         b = *src++;
+         r = (b>>16) & 0xFF;
+         g = (b>>8)  & 0xFF;
+         b = (b)     & 0xFF;
+         RGB2YUV(r,g,b,y2,u2,v2);
+
+         b = *src2++;
+         r = (b>>16) & 0xFF;
+         g = (b>>8)  & 0xFF;
+         b = (b)     & 0xFF;
+         RGB2YUV(r,g,b,y3,u3,v3);
+
+         b = *src2++;
+         r = (b>>16) & 0xFF;
+         g = (b>>8)  & 0xFF;
+         b = (b)     & 0xFF;
+         RGB2YUV(r,g,b,y4,u4,v4);
+
+         *dest_y = y;
+         *(dest_y++ + HWSCALE_WIDTH) = y3;
+         *dest_y = y2;
+         *(dest_y++ + HWSCALE_WIDTH) = y4;
+
+         r&=RMASK;  r>>=16;
+         g&=GMASK;  g>>=8;
+         b&=BMASK;  b>>=0;
+         *dest_u++ = (u+u2+u3+u4)/4;
+         *dest_v++ = (v+v2+v3+v4)/4;
+      }
+   }
+}
+
+static void x11_window_update_32_to_YV12_direct_perfect(struct mame_bitmap *bitmap)
+{ /* This one is used when scale == 2 */
+   int _x,_y,r,g,b;
+   char *dest_y;
+   char *dest_u;
+   char *dest_v;
+   unsigned int *src;
+   unsigned int *src2;
+   int u,v,y;
+
+   for(_y=visual.min_y;_y<=visual.max_y;_y++)
+   {
+      src  =  bitmap->line[_y];
+      src  += visual.min_x;
+      src2 =  bitmap->line[_y+1];
+      src2 += visual.min_x;
+
+      dest_y=HWSCALE_YPLANE+2*(HWSCALE_WIDTH*(_y-visual.min_y));
+      dest_v=HWSCALE_UPLANE+((HWSCALE_WIDTH/2)*((_y-visual.min_y)));
+      dest_u=HWSCALE_VPLANE+((HWSCALE_WIDTH/2)*((_y-visual.min_y)));
+      for(_x=visual.min_x;_x<=visual.max_x;_x++)
+      {
+         b = *src++;
+         r = (b>>16) & 0xFF;
+         g = (b>>8)  & 0xFF;
+         b = (b)     & 0xFF;
+         RGB2YUV(r,g,b,y,u,v);
+
+         *(dest_y+HWSCALE_WIDTH) = y;
+         *dest_y++ = y;
+         *(dest_y+HWSCALE_WIDTH) = y;
+         *dest_y++ = y;
+         *dest_u++ = u;
+         *dest_v++ = v;
+      }
+   }
+}
+#undef RMASK
+#undef GMASK
+#undef BMASK
+#endif
+
+#define DEST_WIDTH image_width
+#define DEST scaled_buffer_ptr
+#define SRC_PIXEL unsigned short
+#define PUT_IMAGE(X, Y, WIDTH, HEIGHT) x11_window_put_image(X, Y, WIDTH, HEIGHT);
+#define INDIRECT current_palette->lookup
+
+#ifdef USE_HWSCALE
+static void x11_window_update_16_to_YUY2(struct mame_bitmap *bitmap)
+{
+#define RMASK 0xff0000;
+#define GMASK 0x00ff00;
+#define BMASK 0x0000ff;
+#define DEST_PIXEL unsigned short
+#define BLIT_HWSCALE_YUY2
+#undef INDIRECT
+#define INDIRECT hwscale_yuvlookup
+   if (INDIRECT)
+   {
+#include "blit.h"
+   }
+   else
+   {
+#undef INDIRECT
+#include "blit.h"
+#define INDIRECT current_palette->lookup
+   }
+#undef BLIT_HWSCALE_YUY2
+#undef RMASK
+#undef GMASK
+#undef BMASK
+}
+#endif
+
+static void x11_window_update_16_to_16bpp (struct mame_bitmap *bitmap)
+{
+#ifdef USE_HWSCALE
+#define HWSCALE_16BPP_HACK
+#endif
+#define DEST_PIXEL unsigned short
+   if (current_palette->lookup)
+   {
+#include "blit.h"
+   }
+   else
+   {
+#undef  INDIRECT
+#include "blit.h"
+#define INDIRECT current_palette->lookup
+   }
+#undef HWSCALE_16BPP_HACK
+#undef DEST_PIXEL
+}
+
+#define DEST_PIXEL unsigned int
+
+static void x11_window_update_16_to_24bpp (struct mame_bitmap *bitmap)
+{
+#define PACK_BITS
+#include "blit.h"
+#undef PACK_BITS
+}
+
+static void x11_window_update_16_to_32bpp (struct mame_bitmap *bitmap)
+{
+#include "blit.h"
+}
+
+#undef  INDIRECT
+#undef  SRC_PIXEL
+#define SRC_PIXEL unsigned int
+
+static void x11_window_update_32_to_32bpp_direct(struct mame_bitmap *bitmap)
+{
+#include "blit.h"
+}
+
+#ifdef USE_HWSCALE
+static void x11_window_update_32_to_YUY2_direct(struct mame_bitmap *bitmap)
+{
+#define RMASK 0xff0000;
+#define GMASK 0x00ff00;
+#define BMASK 0x0000ff;
+#undef DEST_PIXEL
+#define DEST_PIXEL unsigned short
+#define BLIT_HWSCALE_YUY2
+#undef INDIRECT
+#include "blit.h"
+#undef BLIT_HWSCALE_YUY2
+#undef RMASK
+#undef GMASK
+#undef BMASK
+}
+#endif
+
+#undef DEST_PIXEL
+#undef SRC_PIXEL
+
+#endif /* ifdef x11 */
diff --git a/src/unix/video-drivers/xf86_dga.c b/src/unix/video-drivers/xf86_dga.c
new file mode 100644
index 0000000..b1ade64
--- /dev/null
+++ b/src/unix/video-drivers/xf86_dga.c
@@ -0,0 +1,105 @@
+/*
+ *     XFree86 VidMode and DGA support by Jens Vaasjo <jvaasjo@iname.com>
+ *     Modified for DGA 2.0 support
+ *                                      by Shyouzou Sugitani <shy@debian.or.jp>
+ *                                         Stea Greene <stea@cs.binghamton.edu>
+ */
+
+#ifdef USE_DGA
+#define __XF86_DGA_C
+
+#include <sys/types.h>
+#include <sys/wait.h>
+#include <X11/Xlib.h>
+#include <X11/Xutil.h>
+#include <X11/extensions/xf86dga.h>
+#include <X11/extensions/xf86vmode.h>
+#endif
+#include "xmame.h"
+#include "x11.h"
+
+static int  (*p_xf86_dga_create_display)(int);
+static void (*p_xf86_dga_close_display)(void);
+static int  (*p_xf86_dga_modify_pen)(int, unsigned char, unsigned char, unsigned char);
+static void (*p_xf86_dga_update_display)(struct mame_bitmap *);
+static int  (*p_xf86_dga_alloc_palette)(int);
+static int  (*p_xf86_dga_16bpp_capable)(void);
+
+#ifdef USE_DGA
+
+int xf86_dga_init(void)
+{
+	int i, j;
+	char *s;
+
+	mode_available[X11_DGA] = FALSE;
+
+
+	if(geteuid())
+		fprintf(stderr,"DGA requires root rights\n");
+	else if (!(s = getenv("DISPLAY")) || (s[0] != ':'))
+		fprintf(stderr,"DGA only works on a local display\n");
+	else if(!XF86DGAQueryExtension(display, &i, &i))
+		fprintf(stderr,"XF86DGAQueryExtension failed\n");
+	else if(!XF86DGAQueryVersion(display, &i, &j))
+		fprintf(stderr,"XF86DGAQueryVersion failed\n");
+#ifdef X_XDGASetMode
+	else if (i >= 2)
+	{
+		p_xf86_dga_create_display = xf86_dga2_create_display;
+		p_xf86_dga_close_display  = xf86_dga2_close_display;
+		p_xf86_dga_modify_pen     = xf86_dga2_modify_pen;
+		p_xf86_dga_update_display = xf86_dga2_update_display;
+		p_xf86_dga_alloc_palette  = xf86_dga2_alloc_palette;
+		p_xf86_dga_16bpp_capable  = xf86_dga2_16bpp_capable;
+		return xf86_dga2_init();
+	}
+#endif
+	else
+	{
+		p_xf86_dga_create_display = xf86_dga1_create_display;
+		p_xf86_dga_close_display  = xf86_dga1_close_display;
+		p_xf86_dga_modify_pen     = xf86_dga1_modify_pen;
+		p_xf86_dga_update_display = xf86_dga1_update_display;
+		p_xf86_dga_alloc_palette  = xf86_dga1_alloc_palette;
+		p_xf86_dga_16bpp_capable  = xf86_dga1_16bpp_capable;
+		return xf86_dga1_init();
+	}
+
+	if (!mode_available[X11_DGA])
+		fprintf(stderr,"Use of DGA-modes is disabled\n");
+
+	return OSD_OK;
+}
+
+int  xf86_dga_create_display(int depth)
+{
+	return (*p_xf86_dga_create_display)(depth);
+}
+
+void xf86_dga_close_display(void)
+{
+	(*p_xf86_dga_close_display)();
+}
+
+int  xf86_dga_modify_pen(int pen, unsigned char red,unsigned char green,unsigned char blue)
+{
+	return (*p_xf86_dga_modify_pen)(pen, red, green, blue);
+}
+
+void xf86_dga_update_display(struct mame_bitmap *bitmap)
+{
+	(*p_xf86_dga_update_display)(bitmap);
+}
+
+int  xf86_dga_alloc_palette(int writable_colors)
+{
+	return (*p_xf86_dga_alloc_palette)(writable_colors);
+}
+
+int  xf86_dga_16bpp_capable(void)
+{
+	return (*p_xf86_dga_16bpp_capable)();
+}
+
+#endif /*def USE_DGA*/
diff --git a/src/unix/video-drivers/xf86_dga1.c b/src/unix/video-drivers/xf86_dga1.c
new file mode 100644
index 0000000..dbf8192
--- /dev/null
+++ b/src/unix/video-drivers/xf86_dga1.c
@@ -0,0 +1,535 @@
+/*
+ *	XFree86 VidMode and DGA support by Jens Vaasjo <jvaasjo@iname.com>
+ */
+#ifdef USE_DGA
+#define __XF86_DGA_C
+
+#include <sys/types.h>
+#include <sys/wait.h>
+#include <X11/Xlib.h>
+#include <X11/Xutil.h>
+#include <X11/extensions/xf86dga.h>
+#include <X11/extensions/xf86vmode.h>
+#endif
+#include "driver.h"
+#include "xmame.h"
+#include "x11.h"
+
+#ifdef USE_DGA
+
+static void xf86_dga_update_display_16_to_16bpp(struct mame_bitmap *bitmap);
+static void xf86_dga_update_display_16_to_24bpp(struct mame_bitmap *bitmap);
+static void xf86_dga_update_display_16_to_32bpp(struct mame_bitmap *bitmap);
+static void xf86_dga_update_display_32_to_32bpp_direct(struct mame_bitmap *bitmap);
+
+static struct
+{
+	int screen;
+	unsigned char *addr;
+	int grabbed_keybd;
+	int grabbed_mouse;
+	int old_grab_mouse;
+	char *base_addr;
+	int width;
+	int bank_size;
+	int ram_size;
+	Colormap cmap;
+	void (*xf86_dga_update_display_func)(struct mame_bitmap *bitmap);
+	XF86VidModeModeInfo orig_mode;
+	int vidmode_changed;
+	int palette_dirty;
+} xf86ctx = {-1,NULL,FALSE,FALSE,FALSE,NULL,-1,-1,-1,0,NULL,{0},FALSE,FALSE};
+		
+static unsigned char *doublebuffer_buffer = NULL;
+
+
+int xf86_dga1_init(void)
+{
+	int i;
+	char *s;
+	
+	mode_available[X11_DGA] = FALSE;
+	xf86ctx.screen          = DefaultScreen(display);
+	
+	
+	if(geteuid())
+		fprintf(stderr,"DGA requires root rights\n");
+	else if (!(s = getenv("DISPLAY")) || (s[0] != ':'))
+		fprintf(stderr,"DGA only works on a local display\n");
+	else if(!XF86DGAQueryVersion(display, &i, &i))
+		fprintf(stderr,"XF86DGAQueryVersion failed\n");
+	else if(!XF86DGAQueryExtension(display, &i, &i))
+		fprintf(stderr,"XF86DGAQueryExtension failed\n");
+	else if(!XF86DGAQueryDirectVideo(display, xf86ctx.screen, &i))
+		fprintf(stderr,"XF86DGAQueryDirectVideo failed\n");
+	else if(!(i & XF86DGADirectPresent))
+		fprintf(stderr,"XF86DGADirectVideo support is not present\n");
+	else if(!XF86DGAGetVideo(display,xf86ctx.screen,
+		 &xf86ctx.base_addr,&xf86ctx.width,
+		 &xf86ctx.bank_size,&xf86ctx.ram_size))
+		fprintf(stderr,"XF86DGAGetVideo failed\n");
+	else
+		mode_available[X11_DGA] = TRUE; 
+		
+	if (!mode_available[X11_DGA])
+		fprintf(stderr,"Use of DGA-modes is disabled\n");
+
+	return OSD_OK;
+}
+
+int xf86_dga1_16bpp_capable(void)
+{
+   int screen_no = DefaultScreen (display);
+   return (DefaultDepth(display, screen_no) >= 15);
+}
+
+static int xf86_dga_vidmode_check_exts(void)
+{
+	int major,minor,event_base,error_base;
+
+	if(!XF86VidModeQueryVersion(display,&major,&minor))
+	{
+		fprintf(stderr_file,"XF86VidModeQueryVersion failed\n");
+		return OSD_NOT_OK;
+	}
+
+	if(!XF86VidModeQueryExtension(display,&event_base,&error_base))
+	{
+		fprintf(stderr_file,"XF86VidModeQueryExtension failed\n");
+		return OSD_NOT_OK;
+	}
+
+	return OSD_OK;
+}
+
+static XF86VidModeModeInfo *xf86_dga_vidmode_find_best_vidmode(int depth)
+{
+	XF86VidModeModeInfo **modes,*bestmode = NULL;
+	int score, best_score = 0;
+	int i,modecount = 0;
+
+	if(!XF86VidModeGetAllModeLines(display,xf86ctx.screen,
+						&modecount,&modes))
+	{
+		fprintf(stderr_file,"XF86VidModeGetAllModeLines failed\n");
+		return NULL;
+	}
+	
+	fprintf(stderr, "XF86DGA: info: found %d modes:\n", modecount);
+
+	for(i=0;i<modecount;i++)
+	{
+		if (mode_disabled(modes[i]->hdisplay, modes[i]->vdisplay, depth))
+			continue;
+		fprintf(stderr, "XF86DGA: info: found mode: %dx%d\n",
+		   modes[i]->hdisplay, modes[i]->vdisplay);
+		/* ignore modes with a width which is not 64 bit aligned */
+		if(modes[i]->hdisplay & 7) continue;
+		
+		score = mode_match(modes[i]->hdisplay, modes[i]->vdisplay);
+		if(score > best_score)
+		{
+			best_score = score;
+			bestmode   = modes[i];
+		}
+	}
+
+	return bestmode;
+}
+
+static Bool xf86_dga_vidmode_getmodeinfo(XF86VidModeModeInfo *modeinfo)
+{
+	XF86VidModeModeLine modeline;
+	int dotclock;
+	Bool err;
+
+	err = XF86VidModeGetModeLine(display,xf86ctx.screen,
+					&dotclock,&modeline);
+
+	modeinfo->dotclock = dotclock;
+	modeinfo->hdisplay = modeline.hdisplay;
+	modeinfo->hsyncstart = modeline.hsyncstart;
+	modeinfo->hsyncend = modeline.hsyncend;
+	modeinfo->htotal = modeline.htotal;
+	modeinfo->vdisplay = modeline.vdisplay;
+	modeinfo->vsyncstart = modeline.vsyncstart;
+	modeinfo->vsyncend = modeline.vsyncend;
+	modeinfo->vtotal = modeline.vtotal;
+	modeinfo->flags = modeline.flags;
+	modeinfo->privsize = modeline.privsize;
+	modeinfo->private = modeline.private;
+
+	return err;
+}
+
+static void xf86_dga_vidmode_restoremode(Display *disp)
+{
+	XF86VidModeSwitchToMode(disp, xf86ctx.screen, &xf86ctx.orig_mode);
+	/* 'Mach64-hack': restores screen when screwed up */
+	XF86VidModeSwitchMode(disp,xf86ctx.screen,-1);
+	XF86VidModeSwitchMode(disp,xf86ctx.screen,1);
+	/**************************************************/
+	XSync(disp,False);
+}
+
+static int xf86_dga_vidmode_setup_mode_restore(void)
+{
+	Display *disp;
+	int status;
+	pid_t pid;
+
+	if(!xf86_dga_vidmode_getmodeinfo(&xf86ctx.orig_mode))
+	{
+		fprintf(stderr_file,"XF86VidModeGetModeLine failed\n");
+		return OSD_NOT_OK;
+	}
+
+	pid = fork();
+	if(pid > 0)
+	{
+		waitpid(pid,&status,0);
+		disp = XOpenDisplay(NULL);
+		xf86_dga_vidmode_restoremode(disp);
+		XCloseDisplay(disp);
+		_exit(!WIFEXITED(status));
+	}
+
+	if (pid < 0)
+	{
+		perror("fork");
+		return OSD_NOT_OK;
+	}
+
+	return OSD_OK;
+}
+
+int xf86_dga1_alloc_palette(int writable_colors)
+{
+	XColor color;
+	int i;
+
+	/* this is only relevant for 8bpp displays */
+	if (depth != 8)
+	   return 0;
+
+	xf86ctx.cmap = XCreateColormap(display,window,xvisual,AllocAll);
+
+	for(i=0;i<writable_colors;i++)
+	{
+		color.pixel = i;
+		color.red   = 0;
+		color.green = 0;
+		color.blue  = 0;
+		color.flags = DoRed | DoGreen | DoBlue;
+
+		XStoreColor(display,xf86ctx.cmap,&color);
+	}
+	return 0;
+}
+
+static int xf86_dga_setup_graphics(XF86VidModeModeInfo *modeinfo, int bitmap_depth)
+{
+	int sizeof_pixel;
+	
+	if(xf86ctx.bank_size != (xf86ctx.ram_size * 1024))
+	{
+		fprintf(stderr_file,"banked graphics modes not supported\n");
+		return OSD_NOT_OK;
+	}
+
+	if (bitmap_depth == 32)
+	{
+	    if (depth == 32) 
+	    {
+		xf86ctx.xf86_dga_update_display_func =
+			xf86_dga_update_display_32_to_32bpp_direct;
+	    }
+	}
+	else if (bitmap_depth == 16)
+	{
+	    switch(depth)
+	    {
+		case 16:
+			xf86ctx.xf86_dga_update_display_func =
+				xf86_dga_update_display_16_to_16bpp;
+			break;
+		case 24:
+			xf86ctx.xf86_dga_update_display_func =
+				xf86_dga_update_display_16_to_24bpp;
+			break;
+		case 32:
+			xf86ctx.xf86_dga_update_display_func =
+				xf86_dga_update_display_16_to_32bpp;
+			break;
+	    }
+	}
+	
+	if (xf86ctx.xf86_dga_update_display_func == NULL)
+	{
+		fprintf(stderr_file, "unsupported depth %dbpp\n",depth);
+		return OSD_NOT_OK;
+	}
+	
+	fprintf(stderr_file, "XF86-DGA1 running at: %dbpp\n", depth);
+	
+	sizeof_pixel  = depth / 8;
+
+	xf86ctx.addr  = (unsigned char*)xf86ctx.base_addr;
+	xf86ctx.addr += (((modeinfo->hdisplay - visual_width*widthscale) / 2) & ~7)
+						* sizeof_pixel;
+	if (yarbsize)
+	  xf86ctx.addr += ((modeinfo->vdisplay - yarbsize) / 2)
+	    * xf86ctx.width * sizeof_pixel;
+	else
+	  xf86ctx.addr += ((modeinfo->vdisplay - visual_height*heightscale) / 2)
+	    * xf86ctx.width * sizeof_pixel;
+
+	return OSD_OK;
+}
+
+/* This name doesn't really cover this function, since it also sets up mouse
+   and keyboard. This is done over here, since on most display targets the
+   mouse and keyboard can't be setup before the display has. */
+int xf86_dga1_create_display(int bitmap_depth)
+{
+	int i, count;
+	XPixmapFormatValues *pixmaps;
+	XF86VidModeModeInfo *bestmode;
+	/* only have todo the fork's the first time we go DGA, otherwise people
+	   who do a lott of dga <-> window switching will get a lott of
+	   children */
+	static int first_time  = 1;
+	xf86_dga_fix_viewport  = 0;
+	xf86_dga_first_click   = 1;
+	xf86ctx.palette_dirty  = FALSE;
+	xf86ctx.old_grab_mouse = x11_grab_mouse;
+	x11_grab_mouse         = FALSE;
+	
+	xvisual = DefaultVisual(display,xf86ctx.screen);
+	window  = RootWindow(display,xf86ctx.screen);
+	/* dirty hack 24bpp can be either 24bpp packed or 32 bpp sparse */
+	pixmaps = XListPixmapFormats(display, &count);
+	if (!pixmaps)
+	{
+	   fprintf(stderr_file, "X11-Error: Couldn't list pixmap formats.\n"
+	      "Probably out of memory.\n");
+	   return OSD_NOT_OK;
+	}
+        for(i=0; i<count; i++)
+        {
+           if(pixmaps[i].depth==DefaultDepth(display,xf86ctx.screen))
+           {
+	      depth = pixmaps[i].bits_per_pixel;
+	      break;
+           }  
+        }
+        if(i==count)
+        {
+           fprintf(stderr_file, "Couldn't find a zpixmap with the defaultcolordepth\nThis should not happen!\n");
+           return OSD_NOT_OK;
+        }
+        XFree(pixmaps);
+        
+	/* setup the palette_info struct now we have the depth */
+	if (x11_init_palette_info() != OSD_OK)
+	    return OSD_NOT_OK;
+        
+        if (widthscale != 1 || heightscale != 1 ||
+	    yarbsize > visual_height)
+        {
+	   doublebuffer_buffer = malloc (visual_width * widthscale * depth / 8);
+	   if (doublebuffer_buffer == NULL)
+	   {
+	      fprintf(stderr, "Error: Couldn't alloc enough memory\n");
+	      return OSD_NOT_OK;
+	   }
+        }
+
+	if(xf86_dga_vidmode_check_exts())
+		return OSD_NOT_OK;
+
+	bestmode = xf86_dga_vidmode_find_best_vidmode(bitmap_depth);
+	if(!bestmode)
+	{
+		fprintf(stderr_file,"no suitable mode found\n");
+		return OSD_NOT_OK;
+	}
+
+	if(xf86_dga_setup_graphics(bestmode, bitmap_depth))
+		return OSD_NOT_OK;
+	
+	if (first_time)
+	{
+		if(xf86_dga_vidmode_setup_mode_restore())
+			return OSD_NOT_OK;
+	}
+
+	fprintf(stderr_file,"VidMode Switching To Mode: %d x %d\n",
+			bestmode->hdisplay,bestmode->vdisplay);
+
+	if(!XF86VidModeSwitchToMode(display,xf86ctx.screen,bestmode))
+	{
+		fprintf(stderr_file,"XF86VidModeSwitchToMode failed\n");
+		return OSD_NOT_OK;
+	}
+	xf86ctx.vidmode_changed = TRUE;
+
+	if(XGrabKeyboard(display,window,True,
+		GrabModeAsync,GrabModeAsync,CurrentTime))
+	{
+		fprintf(stderr_file,"XGrabKeyboard failed\n");
+		return OSD_NOT_OK;
+	}
+	xf86ctx.grabbed_keybd = 1;
+
+	if(use_mouse)
+	{
+		if(XGrabPointer(display,window,True,
+			PointerMotionMask|ButtonPressMask|ButtonReleaseMask,
+			GrabModeAsync,GrabModeAsync,None,None,CurrentTime))
+		{
+			fprintf(stderr_file, "XGrabPointer failed, mouse disabled\n");
+			use_mouse = 0;
+		}
+		else
+			xf86ctx.grabbed_mouse = 1;
+	}
+
+	if(first_time)
+	{
+		if(XF86DGAForkApp(xf86ctx.screen))
+		{
+			perror("fork");
+			return OSD_NOT_OK;
+		}
+		first_time = 0;
+	}
+
+	if(!XF86DGADirectVideo(display,xf86ctx.screen,
+		XF86DGADirectGraphics|XF86DGADirectMouse|XF86DGADirectKeyb))
+	{
+		fprintf(stderr_file,"XF86DGADirectVideo failed\n");
+		return OSD_NOT_OK;
+	}
+
+	if(!XF86DGASetViewPort(display,xf86ctx.screen,0,0))
+	{
+		fprintf(stderr_file,"XF86DGASetViewPort failed\n");
+		return OSD_NOT_OK;
+	}
+
+	memset(xf86ctx.base_addr,0,xf86ctx.bank_size);
+
+	effect_init2(bitmap_depth, depth, xf86ctx.width);
+	
+	return OSD_OK;
+}
+
+
+int xf86_dga1_modify_pen(int pen,
+	unsigned char red,unsigned char green,unsigned char blue)
+{
+	XColor color;
+	color.pixel = pen;
+	color.red   = red   << 8;
+	color.green = green << 8;
+	color.blue  = blue  << 8;
+	color.flags = DoRed | DoGreen | DoBlue;
+
+	XStoreColor(display,xf86ctx.cmap,&color);
+	xf86ctx.palette_dirty = TRUE;
+	return 0;
+}
+
+#define DEST xf86ctx.addr
+#define DEST_WIDTH xf86ctx.width
+#define SRC_PIXEL unsigned short
+/* Use double buffering where it speeds things up */
+#define DOUBLEBUFFER
+
+#define INDIRECT current_palette->lookup
+
+static void xf86_dga_update_display_16_to_16bpp(struct mame_bitmap *bitmap)
+{
+#define DEST_PIXEL unsigned short
+   if (current_palette->lookup)
+   {
+#include "blit.h"
+   }
+   else
+   {
+#undef  INDIRECT
+#include "blit.h"
+#define INDIRECT current_palette->lookup
+   }
+#undef DEST_PIXEL
+}
+
+#define DEST_PIXEL unsigned int
+
+static void xf86_dga_update_display_16_to_24bpp(struct mame_bitmap *bitmap)
+{
+#define PACK_BITS
+#include "blit.h"
+#undef PACK_BITS
+}
+
+static void xf86_dga_update_display_16_to_32bpp(struct mame_bitmap *bitmap)
+{
+#include "blit.h"
+}
+
+#undef  INDIRECT
+#undef  SRC_PIXEL
+#define SRC_PIXEL unsigned int
+
+static void xf86_dga_update_display_32_to_32bpp_direct(struct mame_bitmap *bitmap)
+{
+#include "blit.h"
+}
+
+#undef DEST_PIXEL
+
+void xf86_dga1_update_display(struct mame_bitmap *bitmap)
+{
+	if(xf86_dga_fix_viewport)
+	{
+		XF86DGASetViewPort(display,xf86ctx.screen,0,0);
+		xf86_dga_fix_viewport = 0;
+	}
+	
+	(*xf86ctx.xf86_dga_update_display_func)(bitmap);
+}
+
+void xf86_dga1_close_display(void)
+{
+	if(doublebuffer_buffer)
+	{
+		free(doublebuffer_buffer);
+		doublebuffer_buffer = NULL;
+	}
+	if(xf86ctx.cmap)
+	{
+		XFreeColormap(display,xf86ctx.cmap);
+		xf86ctx.cmap = 0;
+	}
+	if(xf86ctx.grabbed_mouse)
+	{
+		XUngrabPointer(display,CurrentTime);
+		xf86ctx.grabbed_mouse = FALSE;
+	}
+	if(xf86ctx.grabbed_keybd)
+	{
+		XUngrabKeyboard(display,CurrentTime);
+		xf86ctx.grabbed_keybd = FALSE;
+	}
+	XF86DGADirectVideo(display,xf86ctx.screen, 0);
+	if(xf86ctx.vidmode_changed)
+	{
+		xf86_dga_vidmode_restoremode(display);
+		xf86ctx.vidmode_changed = FALSE;
+	}
+	x11_grab_mouse = xf86ctx.old_grab_mouse;
+}
+
+#endif /*def USE_DGA*/
diff --git a/src/unix/video-drivers/xf86_dga2.c b/src/unix/video-drivers/xf86_dga2.c
new file mode 100644
index 0000000..e0ee435
--- /dev/null
+++ b/src/unix/video-drivers/xf86_dga2.c
@@ -0,0 +1,537 @@
+/*
+ *	XFree86 VidMode and DGA support by Jens Vaasjo <jvaasjo@iname.com>
+ *      Modified for DGA 2.0 native API support
+ *                                      by Shyouzou Sugitani <shy@debian.or.jp>
+ *                                         Stea Greene <stea@cs.binghamton.edu>
+ */
+#ifdef USE_DGA
+#define __XF86_DGA_C
+
+#include <sys/types.h>
+#include <sys/wait.h>
+#include <X11/Xlib.h>
+#include <X11/Xutil.h>
+#include <X11/extensions/xf86dga.h>
+#include <X11/extensions/xf86vmode.h>
+#endif
+#include "driver.h"
+#include "xmame.h"
+#include "x11.h"
+
+#ifdef X_XDGASetMode
+
+#ifdef USE_DGA
+
+static void xf86_dga_update_display_16_to_16bpp(struct mame_bitmap *bitmap);
+static void xf86_dga_update_display_16_to_24bpp(struct mame_bitmap *bitmap);
+static void xf86_dga_update_display_16_to_32bpp(struct mame_bitmap *bitmap);
+static void xf86_dga_update_display_32_to_32bpp_direct(struct mame_bitmap *bitmap);
+
+static struct
+{
+	int screen;
+	unsigned char *addr;
+	int grabbed_keybd;
+	int grabbed_mouse;
+	int old_grab_mouse;
+	unsigned char *base_addr;
+	int width;
+	Colormap cmap;
+	void (*xf86_dga_update_display_func)(struct mame_bitmap *bitmap);
+	XDGADevice *device;
+	XDGAMode *modes;
+	int vidmode_changed;
+	int palette_dirty;
+} xf86ctx = {-1,NULL,FALSE,FALSE,FALSE,NULL,-1,0,NULL,NULL,NULL,FALSE,FALSE};
+	
+static Visual dga_xvisual;
+
+static unsigned char *doublebuffer_buffer = NULL;
+
+#ifdef TDFX_DGA_WORKAROUND
+static int current_X11_mode = 0;
+#endif
+
+int xf86_dga2_init(void)
+{
+	int i,j ;
+	char *s;
+	
+	mode_available[X11_DGA] = FALSE;
+	xf86ctx.screen          = DefaultScreen(display);
+	
+	
+	if(geteuid())
+		fprintf(stderr,"DGA requires root rights\n");
+	else if (!(s = getenv("DISPLAY")) || (s[0] != ':'))
+		fprintf(stderr,"DGA only works on a local display\n");
+	else if(!XDGAQueryVersion(display, &i, &j))
+		fprintf(stderr,"XDGAQueryVersion failed\n");
+	else if (i < 2)
+		fprintf(stderr,"This driver requires DGA 2.0 or newer\n");
+	else if(!XDGAQueryExtension(display, &i, &j))
+		fprintf(stderr,"XDGAQueryExtension failed\n");
+	else if(!XDGAOpenFramebuffer(display,xf86ctx.screen))
+		fprintf(stderr,"XDGAOpenFramebuffer failed\n");
+	else
+		mode_available[X11_DGA] = TRUE; 
+		
+	if (!mode_available[X11_DGA])
+		fprintf(stderr,"Use of DGA-modes is disabled\n");
+
+	return OSD_OK;
+}
+
+int xf86_dga2_16bpp_capable(void)
+{
+	int i, modecount = 0;
+	int result = 0;
+	XDGAMode *modes;
+
+	modes = XDGAQueryModes(display, xf86ctx.screen, &modecount);
+	for(i=0;i<modecount;i++)
+        {
+		if (modes[i].depth >= 16)
+		{
+			result = 1;
+			break;
+		}
+	}
+	XFree(modes);
+
+	return result;
+}
+
+static int xf86_dga_vidmode_find_best_vidmode(int bitmap_depth)
+{
+	int bestmode = 0;
+	int score, best_score = 0;
+	int i,modecount = 0;
+
+#ifdef TDFX_DGA_WORKAROUND
+	int dotclock;
+	XF86VidModeModeLine modeline;
+
+	XF86VidModeGetModeLine(display, xf86ctx.screen, &dotclock, &modeline);
+#endif
+
+	xf86ctx.modes = XDGAQueryModes(display, xf86ctx.screen, &modecount);
+	fprintf(stderr, "XDGA: info: found %d modes:\n", modecount);
+
+	for(i=0;i<modecount;i++)
+	{
+
+#ifdef TDFX_DGA_WORKAROUND
+		if (xf86ctx.modes[i].viewportWidth == modeline.hdisplay &&
+			xf86ctx.modes[i].viewportHeight == modeline.vdisplay)
+			current_X11_mode = xf86ctx.modes[i].num;
+#endif
+		
+		if (mode_disabled(xf86ctx.modes[i].viewportWidth, xf86ctx.modes[i].viewportHeight, bitmap_depth))
+			continue;
+		if (bitmap_depth == 32)
+		{
+			if (xf86ctx.modes[i].bitsPerPixel != 32)
+				continue;
+		}
+		else if (xf86ctx.modes[i].depth < bitmap_depth)
+			continue;
+#if 0 /* DEBUG */
+		fprintf(stderr, "XDGA: info: (%d) %s\n",
+		   xf86ctx.modes[i].num, xf86ctx.modes[i].name);
+		fprintf(stderr, "          : VRefresh = %f [Hz]\n",
+		   xf86ctx.modes[i].verticalRefresh);
+		/* flags */
+		fprintf(stderr, "          : viewport = %dx%d\n",
+		   xf86ctx.modes[i].viewportWidth, xf86ctx.modes[i].viewportHeight);
+		fprintf(stderr, "          : image = %dx%d\n",
+		   xf86ctx.modes[i].imageWidth, xf86ctx.modes[i].imageHeight);
+		if (xf86ctx.modes[i].flags & XDGAPixmap)
+			fprintf(stderr, "          : pixmap = %dx%d\n",
+				xf86ctx.modes[i].pixmapWidth, xf86ctx.modes[i].pixmapHeight);
+		fprintf(stderr, "          : bytes/scanline = %d\n",
+		   xf86ctx.modes[i].bytesPerScanline);
+		fprintf(stderr, "          : byte order = %s\n",
+			xf86ctx.modes[i].byteOrder == MSBFirst ? "MSBFirst" :
+			xf86ctx.modes[i].byteOrder == LSBFirst ? "LSBFirst" :
+			"Unknown");
+		fprintf(stderr, "          : bpp = %d, depth = %d\n",
+			xf86ctx.modes[i].bitsPerPixel, xf86ctx.modes[i].depth);
+		fprintf(stderr, "          : RGBMask = (%lx, %lx, %lx)\n",
+			xf86ctx.modes[i].redMask,
+			xf86ctx.modes[i].greenMask,
+			xf86ctx.modes[i].blueMask);
+		fprintf(stderr, "          : visual class = %s\n",
+			xf86ctx.modes[i].visualClass == TrueColor ? "TrueColor":
+			xf86ctx.modes[i].visualClass == DirectColor ? "DirectColor" :
+			xf86ctx.modes[i].visualClass == PseudoColor ? "PseudoColor" : "Unknown");
+		fprintf(stderr, "          : xViewportStep = %d, yViewportStep = %d\n",
+			xf86ctx.modes[i].xViewportStep, xf86ctx.modes[i].yViewportStep);
+		fprintf(stderr, "          : maxViewportX = %d, maxViewportY = %d\n",
+			xf86ctx.modes[i].maxViewportX, xf86ctx.modes[i].maxViewportY);
+		/* viewportFlags */
+#endif
+		/* ignore modes with a width which is not 64 bit aligned */
+		if(xf86ctx.modes[i].viewportWidth & 7) continue;
+		
+		score = mode_match(xf86ctx.modes[i].viewportWidth, xf86ctx.modes[i].viewportHeight);
+		if (xf86ctx.modes[i].depth != bitmap_depth)
+			score -= 10;
+		if(score > best_score)
+		{
+			best_score = score;
+			bestmode   = xf86ctx.modes[i].num;
+		}
+	}
+
+	return bestmode;
+}
+
+static int xf86_dga_vidmode_setup_mode_restore(void)
+{
+	Display *disp;
+	int status;
+	pid_t pid;
+
+	pid = fork();
+	if(pid > 0)
+	{
+		waitpid(pid,&status,0);
+		disp = XOpenDisplay(NULL);
+		XDGACloseFramebuffer(disp, xf86ctx.screen);
+		XDGASetMode(disp, xf86ctx.screen, 0);
+		XCloseDisplay(disp);
+		_exit(!WIFEXITED(status));
+	}
+
+	if (pid < 0)
+	{
+		perror("fork");
+		return OSD_NOT_OK;
+	}
+
+	return OSD_OK;
+}
+
+int xf86_dga2_alloc_palette(int writable_colors)
+{
+	XColor color;
+	int i;
+
+	if (xf86ctx.device->mode.depth != 8) {
+		xf86ctx.cmap = XDGACreateColormap(display, xf86ctx.screen,
+						  xf86ctx.device, AllocNone);
+	} else {
+		xf86ctx.cmap = XDGACreateColormap(display, xf86ctx.screen,
+						  xf86ctx.device, AllocAll);
+		for(i=0;i<writable_colors;i++)
+		{
+			color.pixel = i;
+			color.red   = 0;
+			color.green = 0;
+			color.blue  = 0;
+			color.flags = DoRed | DoGreen | DoBlue;
+
+			XStoreColor(display,xf86ctx.cmap,&color);
+		}
+	}
+	XDGAInstallColormap(display,xf86ctx.screen,xf86ctx.cmap);
+	return 0;
+}
+
+static int xf86_dga_setup_graphics(XDGAMode modeinfo, int bitmap_depth)
+{
+	int sizeof_pixel;
+
+	if (bitmap_depth == 32)
+	{
+	    if (depth == 32)
+	    {
+		xf86ctx.xf86_dga_update_display_func =
+			xf86_dga_update_display_32_to_32bpp_direct;
+	    }
+	}
+	else if (bitmap_depth == 16)
+	{
+	    switch(depth)
+	    {
+		case 16:
+			xf86ctx.xf86_dga_update_display_func =
+				xf86_dga_update_display_16_to_16bpp;
+			break;
+		case 24:
+			xf86ctx.xf86_dga_update_display_func =
+				xf86_dga_update_display_16_to_24bpp;
+			break;
+		case 32:
+			xf86ctx.xf86_dga_update_display_func =
+				xf86_dga_update_display_16_to_32bpp;
+			break;
+	    }
+	}
+	
+	if (xf86ctx.xf86_dga_update_display_func == NULL)
+	{
+		fprintf(stderr_file, "Error: Unsupported bitmap depth = %dbpp, video depth = %dbpp\n", bitmap_depth, depth);
+		return OSD_NOT_OK;
+	}
+	
+	fprintf(stderr_file, "XF86-DGA2 running at: %dbpp\n", depth);
+	
+	sizeof_pixel  = depth / 8;
+
+	xf86ctx.addr  = (unsigned char*)xf86ctx.base_addr;
+#if 1
+	xf86ctx.addr += (((modeinfo.viewportWidth - visual_width*widthscale) / 2) & ~7)
+						* sizeof_pixel;
+	if (yarbsize)
+	  xf86ctx.addr += ((modeinfo.viewportHeight - yarbsize) / 2)
+	    * modeinfo.bytesPerScanline;
+	else
+	  xf86ctx.addr += ((modeinfo.viewportHeight - visual_height*heightscale) / 2)
+	    * modeinfo.bytesPerScanline;
+#endif
+
+	return OSD_OK;
+}
+
+/* This name doesn't really cover this function, since it also sets up mouse
+   and keyboard. This is done over here, since on most display targets the
+   mouse and keyboard can't be setup before the display has. */
+int xf86_dga2_create_display(int bitmap_depth)
+{
+	int bestmode;
+	/* only have todo the fork's the first time we go DGA, otherwise people
+	   who do a lott of dga <-> window switching will get a lott of
+	   children */
+	static int first_time  = 1;
+	xf86_dga_first_click   = 0;
+	xf86ctx.palette_dirty  = FALSE;
+	xf86ctx.old_grab_mouse = x11_grab_mouse;
+	x11_grab_mouse         = FALSE;
+	
+	window  = RootWindow(display,xf86ctx.screen);
+	
+	if (first_time)
+	{
+		if(xf86_dga_vidmode_setup_mode_restore())
+			return OSD_NOT_OK;
+		first_time = 0;
+	}
+
+	bestmode = xf86_dga_vidmode_find_best_vidmode(bitmap_depth);
+	if (!bestmode)
+	{
+		fprintf(stderr_file,"no suitable mode found\n");
+		return OSD_NOT_OK;
+	}
+
+	xf86ctx.device = XDGASetMode(display,xf86ctx.screen,bestmode);
+	if (xf86ctx.device == NULL) {
+		fprintf(stderr_file,"XDGASetMode failed\n");
+		return OSD_NOT_OK;
+	}
+	xf86ctx.width = xf86ctx.device->mode.bytesPerScanline * 8
+		/ xf86ctx.device->mode.bitsPerPixel;
+	xf86ctx.base_addr = xf86ctx.device->data;
+	xf86ctx.vidmode_changed = TRUE;
+
+	depth = xf86ctx.device->mode.bitsPerPixel;
+
+#if 0 /* DEBUG */
+	fprintf(stderr_file, "Debug: bitmap_depth =%d   mode.bitsPerPixel = %d"
+			"   mode.depth = %d\n", bitmap_depth, 
+			xf86ctx.device->mode.bitsPerPixel, 
+			xf86ctx.device->mode.depth);
+#endif
+
+	fprintf(stderr_file,"VidMode Switching To Mode: %d x %d\n",
+		xf86ctx.device->mode.viewportWidth,
+		xf86ctx.device->mode.viewportHeight);
+
+	xvisual = &dga_xvisual;
+	dga_xvisual.class = xf86ctx.device->mode.visualClass;
+	dga_xvisual.red_mask = xf86ctx.device->mode.redMask;
+	dga_xvisual.green_mask = xf86ctx.device->mode.greenMask;
+	dga_xvisual.blue_mask = xf86ctx.device->mode.blueMask;
+
+	/* setup the palette_info struct now we have the depth */
+	if (x11_init_palette_info() != OSD_OK)
+	    return OSD_NOT_OK;
+        
+        if (widthscale != 1 || heightscale != 1 ||
+	    yarbsize > visual_height)
+        {
+	   doublebuffer_buffer = malloc (visual_width * widthscale * depth / 8);
+	   if (doublebuffer_buffer == NULL)
+	   {
+	      fprintf(stderr, "Error: Couldn't alloc enough memory\n");
+	      return OSD_NOT_OK;
+	   }
+        }
+
+	if(xf86_dga_setup_graphics(xf86ctx.device->mode, bitmap_depth))
+		return OSD_NOT_OK;
+	
+	if(XGrabKeyboard(display,window,True,
+		GrabModeAsync,GrabModeAsync,CurrentTime))
+	{
+		fprintf(stderr_file,"XGrabKeyboard failed\n");
+		return OSD_NOT_OK;
+	}
+	xf86ctx.grabbed_keybd = 1;
+
+	if(use_mouse)
+	{
+		if(XGrabPointer(display,window,True,
+			PointerMotionMask|ButtonPressMask|ButtonReleaseMask,
+			GrabModeAsync,GrabModeAsync,None,None,CurrentTime))
+		{
+			fprintf(stderr_file, "XGrabPointer failed, mouse disabled\n");
+			use_mouse = 0;
+		}
+		else
+			xf86ctx.grabbed_mouse = 1;
+	}
+
+	XDGASetViewport(display,xf86ctx.screen,0,0,0);
+	while(XDGAGetViewportStatus(display, xf86ctx.screen))
+		;
+
+	if (xf86ctx.device->mode.flags & XDGASolidFillRect) {
+		XDGAFillRectangle(display, xf86ctx.screen, 0, 0,
+			DisplayWidth(display, xf86ctx.screen),
+			DisplayHeight(display, xf86ctx.screen),
+			BlackPixel(display, xf86ctx.screen));
+		XDGASync(display, xf86ctx.screen);
+	} else {
+		memset(xf86ctx.base_addr, 0,
+		       xf86ctx.device->mode.bytesPerScanline
+		       * xf86ctx.device->mode.imageHeight);
+	}
+
+	effect_init2(bitmap_depth, depth, xf86ctx.width);
+	
+	return OSD_OK;
+}
+
+
+int xf86_dga2_modify_pen(int pen,
+	unsigned char red,unsigned char green,unsigned char blue)
+{
+	XColor color;
+	color.pixel = pen;
+	color.red   = red   << 8;
+	color.green = green << 8;
+	color.blue  = blue  << 8;
+	color.flags = DoRed | DoGreen | DoBlue;
+
+	XStoreColor(display,xf86ctx.cmap,&color);
+	xf86ctx.palette_dirty = TRUE;
+	return 0;
+}
+
+#define DEST xf86ctx.addr
+#define DEST_WIDTH xf86ctx.width
+#define SRC_PIXEL unsigned short
+/* Use double buffering where it speeds things up */
+#define DOUBLEBUFFER
+
+#define INDIRECT current_palette->lookup
+
+static void xf86_dga_update_display_16_to_16bpp(struct mame_bitmap *bitmap)
+{
+#define DEST_PIXEL unsigned short
+   if (current_palette->lookup)
+   {
+#include "blit.h"
+   }
+   else
+   {
+#undef  INDIRECT
+#include "blit.h"
+#define INDIRECT current_palette->lookup
+   }
+#undef DEST_PIXEL
+}
+
+#define DEST_PIXEL unsigned int
+
+static void xf86_dga_update_display_16_to_24bpp(struct mame_bitmap *bitmap)
+{
+#define PACK_BITS
+#include "blit.h"
+#undef PACK_BITS
+}
+
+static void xf86_dga_update_display_16_to_32bpp(struct mame_bitmap *bitmap)
+{
+#include "blit.h"
+}
+
+#undef  INDIRECT
+#undef  SRC_PIXEL
+#define SRC_PIXEL unsigned int
+
+static void xf86_dga_update_display_32_to_32bpp_direct(struct mame_bitmap *bitmap)
+{
+#include "blit.h"
+}
+
+#undef DEST_PIXEL
+
+void xf86_dga2_update_display(struct mame_bitmap *bitmap)
+{
+	(*xf86ctx.xf86_dga_update_display_func)(bitmap);
+	XDGASync(display,xf86ctx.screen);
+}
+
+void xf86_dga2_close_display(void)
+{
+	XDGASync(display,xf86ctx.screen);
+	if(xf86ctx.device)
+	{
+		XFree(xf86ctx.device);
+		xf86ctx.device = 0;
+	}
+	if(xf86ctx.modes)
+	{
+		XFree(xf86ctx.modes);
+		xf86ctx.modes = 0;
+	}
+	if(doublebuffer_buffer)
+	{
+		free(doublebuffer_buffer);
+		doublebuffer_buffer = NULL;
+	}
+	if(xf86ctx.cmap)
+	{
+		XFreeColormap(display,xf86ctx.cmap);
+		xf86ctx.cmap = 0;
+	}
+	if(xf86ctx.grabbed_mouse)
+	{
+		XUngrabPointer(display,CurrentTime);
+		xf86ctx.grabbed_mouse = FALSE;
+	}
+	if(xf86ctx.grabbed_keybd)
+	{
+		XUngrabKeyboard(display,CurrentTime);
+		xf86ctx.grabbed_keybd = FALSE;
+	}
+	if(xf86ctx.vidmode_changed)
+	{
+#ifdef TDFX_DGA_WORKAROUND
+		/* Restore the right video mode before leaving DGA  */
+		/* The tdfx driver would have to do it, but it doesn't work ...*/
+		XDGASetMode(display, xf86ctx.screen, current_X11_mode);
+#endif
+
+		XDGASetMode(display, xf86ctx.screen, 0);
+		xf86ctx.vidmode_changed = FALSE;
+	}
+	x11_grab_mouse = xf86ctx.old_grab_mouse;
+}
+
+#endif /*def X_XDGASetMode*/
+#endif /*def USE_DGA*/
diff --git a/src/unix/video-drivers/xfx.c b/src/unix/video-drivers/xfx.c
new file mode 100644
index 0000000..ec58edc
--- /dev/null
+++ b/src/unix/video-drivers/xfx.c
@@ -0,0 +1,237 @@
+/*****************************************************************
+
+  Xmame glide driver
+
+  Written based on the x11 driver by Mike Oliphant - oliphant@ling.ed.ac.uk
+
+    http://www.ling.ed.ac.uk/~oliphant/glmame
+
+  This code may be used and distributed under the terms of the
+  Mame license
+
+*****************************************************************/
+/* pretend we're x11.c otherwise display and a few other crucial things don't
+   get declared */
+#define __X11_C_   
+#define __XFX_C_
+
+
+#include <math.h>
+#include <X11/Xlib.h>
+#include <X11/Xutil.h>
+#include <X11/cursorfont.h>
+#include "xmame.h"
+#include "x11.h"
+
+int  InitVScreen(void);
+void CloseVScreen(void);
+int  InitGlide(void);
+
+extern int fxwidth;
+extern int fxheight;
+extern struct rc_option fx_opts[];
+
+static Cursor        cursor;
+static XVisualInfo   myvisual;
+
+struct rc_option display_opts[] = {
+   /* name, shortname, type, dest, deflt, min, max, func, help */
+   { NULL, 		NULL,			rc_link,	fx_opts,
+     NULL,		0,			0,		NULL,
+     NULL },
+   { NULL, 		NULL,			rc_link,	x11_input_opts,
+     NULL,		0,			0,		NULL,
+     NULL },
+   { NULL,		NULL,			rc_end,		NULL,
+     NULL,		0,			0,		NULL,
+     NULL }
+};
+
+typedef struct {
+#define MWM_HINTS_DECORATIONS   2
+  long flags;
+  long functions;
+  long decorations;
+  long input_mode;
+} MotifWmHints;
+
+int sysdep_init(void)
+{
+  fprintf(stderr,
+     "info: using FXmame v0.5 driver for xmame, written by Mike Oliphant\n");
+  
+  /* Open the display. */
+  display=XOpenDisplay(NULL);
+
+  if(!display) {
+	fprintf (stderr,"OSD ERROR: failed to open the display.\n");
+	return OSD_NOT_OK; 
+  }
+
+  return InitGlide();
+}
+
+void sysdep_close(void)
+{
+   XCloseDisplay(display);
+}
+
+/* This name doesn't really cover this function, since it also sets up mouse
+   and keyboard. This is done over here, since on most display targets the
+   mouse and keyboard can't be setup before the display has. */
+int sysdep_create_display(int depth)
+{
+  XSetWindowAttributes winattr;
+  int 		 myscreen;
+  XEvent	 event;
+  XSizeHints 	 hints;
+  XWMHints 	 wm_hints;
+  MotifWmHints mwmhints;
+  Atom mwmatom;
+  
+  screen=DefaultScreenOfDisplay(display);
+  myscreen=DefaultScreen(display);
+  cursor=XCreateFontCursor(display,XC_trek);
+  
+  if(!XMatchVisualInfo(display,myscreen,8,PseudoColor,&myvisual)) {
+	fprintf(stderr,"8bit depth PseudoColor X-Visual not available :-( \n");
+	/* test for a 8bpp environment */
+	if      (XMatchVisualInfo(display,myscreen,8,TrueColor,&myvisual))
+	  fprintf(stderr,"Using 8bpp TrueColor X-Visual Resource\n");
+	/* test for a 15bpp environment */
+	else if (XMatchVisualInfo(display,myscreen,15,TrueColor,&myvisual))
+	  fprintf(stderr,"Using 15bpp TrueColor X-Visual Resource\n");
+	/* test for a 16bpp environment */
+	else if (XMatchVisualInfo(display,myscreen,16,TrueColor,&myvisual))
+	  fprintf(stderr,"Using 16bpp TrueColor X-Visual Resource\n");
+	/* test for a 24bpp environment */
+	else if (XMatchVisualInfo(display,myscreen,24,TrueColor,&myvisual))
+	  fprintf(stderr,"Using 24bpp TrueColor X-Visual Resource\n");
+	/* test for a 32bpp environment */
+	else if (XMatchVisualInfo(display,myscreen,32,TrueColor,&myvisual))
+	  fprintf(stderr,"Using 32bpp TrueColor X-Visual Resource\n");
+	/* if arrives here means an error :-( */
+	else
+	  {
+		fprintf(stderr,"Cannot find any supported X-Visual resource\n");
+		sysdep_display_close(); /* this will clean up for us */
+		return OSD_NOT_OK; 
+	  }
+  } else fprintf(stderr,"Using 8bpp PseudoColor Visual. Good!\n");
+
+  colormap=XCreateColormap(display,
+						   RootWindow(display,myvisual.screen),
+						   myvisual.visual,AllocNone);
+
+  winattr.background_pixel=0;
+  winattr.border_pixel=WhitePixelOfScreen(screen);
+  winattr.bit_gravity=ForgetGravity;
+  winattr.win_gravity=NorthWestGravity;
+  winattr.backing_store=NotUseful;
+  winattr.override_redirect=False;
+  winattr.save_under=False;
+  winattr.event_mask=0;
+  winattr.do_not_propagate_mask=0;
+  winattr.colormap=colormap;
+  winattr.cursor=None;
+
+  window=XCreateWindow(display,RootWindowOfScreen(screen),0,0,fxwidth,fxheight,
+					   0,myvisual.depth,
+					   InputOutput,myvisual.visual,
+					   CWBorderPixel | CWBackPixel |
+					   CWEventMask | CWDontPropagate |
+					   CWColormap | CWCursor,&winattr);
+  
+  if (!window) {
+	fprintf(stderr,"OSD ERROR: failed in XCreateWindow().\n");
+	sysdep_display_close();
+	return OSD_NOT_OK; 
+  }
+  
+  /*  Placement hints etc. */
+
+  hints.flags=PMinSize|PMaxSize|USPosition|USSize;
+  
+  hints.min_width=hints.max_width=hints.base_width=screen->width;
+  hints.min_height=hints.max_height=hints.base_height=screen->height;
+
+  hints.x=hints.y=0;
+  
+  wm_hints.input=TRUE;
+  wm_hints.flags=InputHint;
+  
+  XSetWMHints(display,window,&wm_hints);
+  XSetWMNormalHints(display,window,&hints);
+  XStoreName(display,window,title);
+  
+  XDefineCursor(display,window,cursor);
+
+  /* Hack to get rid of window title bar */
+  
+  mwmhints.flags=MWM_HINTS_DECORATIONS;
+  mwmhints.decorations=0;
+  mwmatom=XInternAtom(display,"_MOTIF_WM_HINTS",0);
+  
+  XChangeProperty(display,window,mwmatom,mwmatom,32,
+				  PropModeReplace,(unsigned char *)&mwmhints,4);
+  
+  /* Map and expose the window. */
+
+  if(use_mouse) {
+	/* grab the pointer and query MotionNotify events */
+
+	XSelectInput(display, 
+				 window, 
+				 FocusChangeMask   | ExposureMask | 
+				 KeyPressMask      | KeyReleaseMask | 
+				 EnterWindowMask   | LeaveWindowMask |
+				 PointerMotionMask | ButtonMotionMask |
+				 ButtonPressMask   | ButtonReleaseMask
+				 );
+	
+	XGrabPointer(display,
+				 window, /* RootWindow(display,DefaultScreen(display)), */
+				 False,
+				 PointerMotionMask | ButtonMotionMask |
+				 ButtonPressMask   | ButtonReleaseMask | 
+				 EnterWindowMask   | LeaveWindowMask ,
+				 GrabModeAsync, GrabModeAsync,
+				 None, cursor, CurrentTime );
+  }
+  else {
+	XSelectInput(display, 
+				 window, 
+				 FocusChangeMask | ExposureMask | 
+				 KeyPressMask | KeyReleaseMask
+				 );
+  }
+  
+  XMapRaised(display,window);
+  XClearWindow(display,window);
+  XWindowEvent(display,window,ExposureMask,&event);
+  
+  if (InitVScreen() != OSD_OK)
+     return OSD_NOT_OK;
+  
+  return OSD_OK;
+}
+
+/*
+ * Shut down the display, also used to clean up if any error happens
+ * when creating the display
+ */
+
+void sysdep_display_close (void)
+{
+   XFreeColormap(display, colormap);
+     
+   if(window) {
+     /* ungrab the pointer */
+
+     if(use_mouse) XUngrabPointer(display,CurrentTime);
+
+     CloseVScreen();  /* Shut down glide stuff */
+   }
+
+   XSync(display,False); /* send all events to sync; */
+}
diff --git a/src/unix/video-drivers/xgl.c b/src/unix/video-drivers/xgl.c
new file mode 100644
index 0000000..a111c54
--- /dev/null
+++ b/src/unix/video-drivers/xgl.c
@@ -0,0 +1,529 @@
+/*****************************************************************
+
+  Xmame OpenGL driver
+
+  Written based on the x11 driver by Mike Oliphant - oliphant@ling.ed.ac.uk
+
+    http://www.ling.ed.ac.uk/~oliphant/glmame
+
+  Improved by Sven Goethel, http://www.jausoft.com, sgoethel@jausoft.com
+
+  This code may be used and distributed under the terms of the
+  Mame license
+
+*****************************************************************/
+/* pretend we're x11.c otherwise display and a few other crucial things don't
+   get declared */
+#define __X11_C_   
+#define __XOPENGL_C_
+
+#define RRand(range) (random()%range)
+
+#include <math.h>
+#include <X11/Xlib.h>
+#include <X11/Xutil.h>
+#include <X11/Xmd.h>
+#include <X11/cursorfont.h>
+
+#include "glxtool.h"
+
+#include "xmame.h"
+#include "glmame.h"
+#include "x11.h"
+
+#include "driver.h"
+#include "xmame.h"
+
+static Cursor        cursor;
+static XVisualInfo   *myvisual;
+
+typedef struct {
+#define MWM_HINTS_DECORATIONS   2
+  long flags;
+  long functions;
+  long decorations;
+  long input_mode;
+} MotifWmHints;
+
+int winwidth = 0;
+int winheight = 0;
+int fullscreen_width = 0;
+int fullscreen_height = 0;
+int orig_width = 0;
+int orig_height = 0;
+int visual_orientated_width = 0;
+int visual_orientated_height = 0;
+static int is_fullscreen=0;
+int bilinear=1; /* Do binlinear filtering? */
+int alphablending=0; /* alphablending */
+
+int fullscreen = 0;
+int antialias=0;
+int antialiasvec=1;
+int translucency = 0;
+
+static int drawbitmapvec;
+
+XSetWindowAttributes window_attr;
+GLXContext glContext=NULL;
+
+const GLCapabilities glCapsDef = { BUFFER_DOUBLE, COLOR_RGBA, STEREO_OFF,
+			           1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1,
+			           -1
+			         };
+
+GLCapabilities glCaps;
+
+char * libGLName=0;
+char * libGLUName=0;
+
+static char *gl_res = NULL;
+
+static const char * xgl_version_str = 
+	"\nGLmame v0.94 - the_peace_version , by Sven Goethel, http://www.jausoft.com, sgoethel@jausoft.com,\nbased upon GLmame v0.6 driver for xmame, written by Mike Oliphant\n\n";
+
+struct rc_option display_opts[] = {
+   /* name, shortname, type, dest, deflt, min, max, func, help */
+   { "OpenGL Related",	NULL,			rc_seperator,	NULL,
+     NULL,		0,			0,		NULL,
+     NULL },
+   { "fullscreen",   NULL,    rc_bool,       &fullscreen,
+      "0",           0,       0,             NULL,
+      "Start at fullscreen (default: false)" },
+   { "gldblbuffer",	NULL,			rc_bool,	&doublebuffer,
+     "1",		0,			0,		NULL,
+     "Enable/disable double buffering (default: true)" },
+   { "gltexture_size",	NULL,			rc_int,	&force_text_width_height,
+     "0",		0,			0,		NULL,
+     "Force the max width and height of one texture segment (default: autosize)" },
+   { "glforceblitmode", "glblit",		rc_bool,	&useColorBlitter,
+     "0",		0,			0,		NULL,
+     "Force blitter for true color modes 15/32bpp (default: true)" },
+#ifndef NOGLEXT78
+   { "glext78",	        "glext",		rc_bool,	&useGLEXT78,
+     "1",		0,			0,		NULL,
+     "Force the usage of the gl extension #78, if available (paletted texture, default: true)" },
+#endif
+   { "glbilinear",	"glbilin",		rc_bool,	&bilinear,
+     "1",		0,			0,		NULL,
+     "Enable/disable bilinear filtering (default: true)" },
+   { "gldrawbitmap",	"glbitmap",		rc_bool,	&drawbitmap,
+     "1",		0,			0,		NULL,
+     "Enable/Disable the drawing of the bitmap - e.g. disable it within vector games for a speedup (default: true)" },
+   { "gldrawbitmapvec",	"glbitmapv",		rc_bool,	&drawbitmapvec,
+     "1",		0,			0,		NULL,
+     "Enable/Disable the drawing of the bitmap only for vector games - speedup (default: true)" },
+   { "glcolormod",	"glcmod",		rc_bool,	&use_mod_ctable,
+     "1",		0,			0,		NULL,
+     "Enable/Disable color modulation (intensity,gamma) (default: true)" },
+   { "glbeam",		NULL,			rc_float,	&gl_beam,
+     "1.0",		1.0,			16.0,		NULL,
+     "Set the beam size for vector games (default: 1.0)" },
+   { "glalphablending",	"glalpha",		rc_bool,	&alphablending,
+     "1",		0,			0,		NULL,
+     "Enable/disable alphablending if available (default: true)" },
+   { "glantialias",	"glaa",			rc_bool,	&antialias,
+     "1",		0,			0,		NULL,
+     "Enable/disable antialiasing (default: true)" },
+   { "glantialiasvec",	"glaav",		rc_bool,	&antialiasvec,
+     "1",		0,			0,		NULL,
+     "Enable/disable vector antialiasing (default: true)" },
+   { "gllibname",	"gllib",		rc_string,	&libGLName,
+     "libGL.so",	0,			0,		NULL,
+     "Choose the dynamically loaded OpenGL Library (default libGL.so)" },
+   { "glulibname",	"glulib",		rc_string,	&libGLUName,
+     "libGLU.so",	0,			0,		NULL,
+     "Choose the dynamically loaded GLU Library (default libGLU.so)" },
+   { "cabview",		NULL,			rc_bool,	&cabview,
+     "0",		0,			0,		NULL,
+     "Start/Don't start in cabinet view mode (default: false)" },
+   { "cabinet",		NULL,			rc_string,	&cabname,
+     "glmamejau",	0,			0,		NULL,
+     "Specify which cabinet model to use (default: glmamejau)" },
+   { "glres",	        NULL,			rc_string,	&gl_res,
+     NULL,		0,			0,		NULL,
+     "Always scale games to XresxYres, keeping their aspect ratio. This overrides the scale options" },
+   { NULL,		NULL,			rc_link,	x11_input_opts,
+     NULL,		0,			0,		NULL,
+     NULL },
+   { NULL,		NULL,			rc_end,		NULL,
+     NULL,		0,			0,		NULL,
+     NULL }
+};
+
+static Cursor create_invisible_cursor (Display * display, Window win)
+{
+	Pixmap cursormask;
+	XGCValues xgc;
+	XColor dummycolour;
+	Cursor cursor;
+	GC gc;
+
+	cursormask = XCreatePixmap (display, win, 1, 1, 1 /*depth */ );
+	xgc.function = GXclear;
+	gc = XCreateGC (display, cursormask, GCFunction, &xgc);
+	XFillRectangle (display, cursormask, gc, 0, 0, 1, 1);
+	dummycolour.pixel = 0;
+	dummycolour.red = 0;
+	dummycolour.flags = 04;
+	cursor = XCreatePixmapCursor (display, cursormask, cursormask,
+			&dummycolour, &dummycolour, 0, 0);
+	XFreeGC (display, gc);
+	XFreePixmap (display, cursormask);
+	return cursor;
+}
+
+
+int sysdep_init(void)
+{
+   /* Open the display. */
+   display=XOpenDisplay(NULL);
+
+   if(!display) {
+      fprintf (stderr,"OSD ERROR: failed to open the display.\n");
+      return OSD_NOT_OK; 
+   }
+  
+   gl_bootstrap_resources();
+
+#ifndef NDEBUG
+   printf("GLINFO: xgl init !\n");
+#endif
+
+   return OSD_OK;
+}
+
+void sysdep_close(void)
+{
+   XCloseDisplay(display);
+
+   fprintf(stderr, xgl_version_str);
+  
+#ifndef NDEBUG
+   printf("GLINFO: xgl closed !\n");
+#endif
+}
+
+
+/* This name doesn't really cover this function, since it also sets up mouse
+   and keyboard. This is done over here, since on most display targets the
+   mouse and keyboard can't be setup before the display has. */
+int sysdep_create_display(int depth)
+{
+  int 		myscreen;
+  XEvent	event;
+  XSizeHints 	hints;
+  XWMHints 	wm_hints;
+  MotifWmHints	mwmhints;
+  unsigned long winmask;
+  Atom mwmatom;
+  char *glxfx;
+  int resizeEvtMask = 0;
+  VisualGC vgc;
+  int ownwin = 1;
+  int customSize=0;
+
+  /* If using 3Dfx, Resize the window to fullscreen so we don't lose focus
+     We have to do this after glXMakeCurrent(), or else the voodoo driver
+     will give us the wrong resolution */
+  if((glxfx=getenv("MESA_GLX_FX")) && (glxfx[0]=='f') )
+  	fullscreen=1;
+
+  if(gl_res!=NULL)
+  {
+     if( sscanf(gl_res, "%dx%d", &fullscreen_width, &fullscreen_height) != 2)
+     {
+        fprintf(stderr, "error: invalid value for glres: %s\n", gl_res);
+     } else {
+        customSize=1;
+	orig_width = fullscreen_width;
+	orig_height = fullscreen_height;
+     }
+  }
+  if(!fullscreen) 
+	  resizeEvtMask = StructureNotifyMask ;
+
+  fprintf(stderr, xgl_version_str);
+  
+  screen=DefaultScreenOfDisplay(display);
+  myscreen=DefaultScreen(display);
+  cursor=XCreateFontCursor(display,XC_trek);
+  
+  if(!customSize)
+  {
+  	fullscreen_width = screen->width;
+  	fullscreen_height = screen->height;
+
+	if( ! blit_swapxy )
+	{
+		  visual_orientated_width  = visual_width;
+		  visual_orientated_height = visual_height;
+		  orig_width  = visual_width*widthscale;
+		  orig_height = visual_height*heightscale;
+	} else {
+		  visual_orientated_width  = visual_height;
+		  visual_orientated_height = visual_width;
+		  orig_width  = visual_height*heightscale;
+		  orig_height = visual_width*widthscale;
+	}
+  }
+
+  if(fullscreen)
+  {
+	winwidth = fullscreen_width;
+	winheight = fullscreen_height;
+	is_fullscreen=1;
+  } else {
+	winwidth = orig_width;
+	winheight = orig_height;
+	is_fullscreen=0;
+  }
+
+  window_attr.background_pixel=0;
+  window_attr.border_pixel=WhitePixelOfScreen(screen);
+  window_attr.bit_gravity=ForgetGravity;
+  window_attr.win_gravity=NorthWestGravity;
+  window_attr.backing_store=NotUseful;
+  window_attr.override_redirect=False;
+  window_attr.save_under=False;
+  window_attr.event_mask=0; 
+  window_attr.do_not_propagate_mask=0;
+  window_attr.colormap=0; /* done later, within findVisualGlX .. */
+  window_attr.cursor=None;
+
+  if(fullscreen) 
+      winmask = CWBorderPixel | CWBackPixel | CWEventMask | CWDontPropagate | 
+                CWColormap    | CWCursor
+	        ;
+  else
+      winmask = CWBorderPixel | CWBackPixel | CWEventMask | CWColormap    
+	        ;
+
+  fetch_GL_FUNCS (libGLName, libGLUName, 1 /* force refetch ... */);
+
+  glCaps = glCapsDef;
+
+  glCaps.alphaBits=(alphablending>0)?1:0;
+  glCaps.buffer   =(doublebuffer>0)?BUFFER_DOUBLE:BUFFER_SINGLE;
+  glCaps.gl_supported = 1;
+
+  window = RootWindow(display,DefaultScreen( display ));
+  vgc = findVisualGlX( display, window,
+                       &window, winwidth, winheight, &glCaps, 
+		       &ownwin, &window_attr, winmask,
+		       NULL, 0, NULL, 
+#ifndef NDEBUG
+		       1);
+#else
+		       0);
+#endif
+
+  if(vgc.success==0)
+  {
+	fprintf(stderr,"OSD ERROR: failed to obtain visual.\n");
+	sysdep_display_close();
+	return OSD_NOT_OK; 
+  }
+
+  myvisual =vgc.visual;
+  glContext=vgc.gc;
+  colormap=window_attr.colormap;
+
+  if (!window) {
+	fprintf(stderr,"OSD ERROR: failed in XCreateWindow().\n");
+	sysdep_display_close();
+	return OSD_NOT_OK; 
+  }
+  
+  if(!glContext) {
+	fprintf(stderr,"OSD ERROR: failed to create OpenGL context.\n");
+	sysdep_display_close();
+	return OSD_NOT_OK; 
+  }
+  
+  setGLCapabilities ( display, myvisual, &glCaps);
+
+  alphablending= (glCaps.alphaBits>0)?1:0;
+  doublebuffer = (glCaps.buffer==BUFFER_DOUBLE)?1:0;
+  useColorIndex= (Machine->drv->video_attributes & VIDEO_RGB_DIRECT)==0;
+
+  /*  Placement hints etc. */
+  
+  hints.flags=PMinSize|PMaxSize;
+  
+  if(fullscreen) 
+  { 
+  	hints.flags|=USPosition|USSize;
+  } else {
+  	hints.flags|=PSize;
+  }
+
+  hints.min_width	= hints.max_width = hints.base_width = winwidth;
+  hints.min_height= hints.max_height = hints.base_height = winheight;
+  
+  wm_hints.input=TRUE;
+  wm_hints.flags=InputHint;
+  
+  XSetWMHints(display,window,&wm_hints);
+
+  if(fullscreen) 
+	  XSetWMNormalHints(display,window,&hints);
+
+  XStoreName(display,window,title);
+  
+  if(fullscreen) 
+	  XDefineCursor(display,window,create_invisible_cursor (display, window));
+  else
+	  XDefineCursor(display,window,cursor);
+
+  /* Hack to get rid of window title bar */
+  if(fullscreen) 
+  {
+	mwmhints.flags=MWM_HINTS_DECORATIONS;
+	mwmhints.decorations=0;
+	mwmatom=XInternAtom(display,"_MOTIF_WM_HINTS",0);
+  
+	XChangeProperty(display,window,mwmatom,mwmatom,32,
+			PropModeReplace,(unsigned char *)&mwmhints,4);
+  }
+  
+  /* Map and expose the window. */
+
+  if(use_mouse) {
+	/* grab the pointer and query MotionNotify events */
+
+	XSelectInput(display, 
+				 window, 
+				 FocusChangeMask   | ExposureMask | 
+				 KeyPressMask      | KeyReleaseMask | 
+				 EnterWindowMask   | LeaveWindowMask |
+				 PointerMotionMask | ButtonMotionMask |
+				 ButtonPressMask   | ButtonReleaseMask |
+				 resizeEvtMask 
+				 );
+	
+	XGrabPointer(display,
+				 window, /* RootWindow(display,DefaultScreen(display)), */
+				 False,
+				 PointerMotionMask | ButtonMotionMask |
+				 ButtonPressMask   | ButtonReleaseMask | 
+				 EnterWindowMask   | LeaveWindowMask ,
+				 GrabModeAsync, GrabModeAsync,
+				 None, cursor, CurrentTime );
+  }
+  else {
+	XSelectInput(display, 
+				 window, 
+				 FocusChangeMask | ExposureMask | 
+				 KeyPressMask | KeyReleaseMask  |
+				 resizeEvtMask 
+				 );
+  }
+  
+  XMapRaised(display,window);
+  XClearWindow(display,window);
+  XWindowEvent(display,window,ExposureMask,&event);
+  
+  XResizeWindow(display,window,winwidth,winheight);
+
+  if(fullscreen) {
+	hints.min_width	= hints.max_width = hints.base_width = screen->width;
+	hints.min_height= hints.max_height = hints.base_height = screen->height;
+
+	XSetWMNormalHints(display,window,&hints);
+  }
+
+  if ( (Machine->drv->video_attributes & VIDEO_TYPE_VECTOR) 
+       && drawbitmap ) drawbitmap=drawbitmapvec;
+
+  InitVScreen(depth);
+
+#ifndef NDEBUG
+  printf("GLINFO: xgl display created !\n");
+#endif
+
+  effect_init2(depth, depth, visual_width*widthscale);
+
+  return OSD_OK;
+}
+
+/*
+ * Shut down the display, also used to clean up if any error happens
+ * when creating the display
+ */
+
+void sysdep_display_close (void)
+{
+   disp__glXMakeCurrent(display, None, NULL);
+   disp__glXDestroyContext(display,glContext);
+   glContext=0;
+
+   CloseVScreen();  /* Shut down GL stuff */
+
+   if(window) {
+     /* ungrab the pointer */
+
+     if(use_mouse) XUngrabPointer(display,CurrentTime);
+
+     destroyOwnOverlayWin(display, &window, &window_attr);
+     colormap=window_attr.colormap;
+   }
+
+   XSync(display,False); /* send all events to sync; */
+
+#ifndef NDEBUG
+   printf("GLINFO: xgl display closed !\n");
+#endif
+}
+
+/* Swap GL video buffers */
+
+void SwapBuffers(void)
+{
+  disp__glXSwapBuffers(display,window);
+}
+
+void toggleFullscreen()
+{
+   if(is_fullscreen)
+   {
+	XMoveResizeWindow(display, window, 
+			  (fullscreen_width-orig_width)/2, 
+			  (fullscreen_height-orig_height)/2,
+			  orig_width, orig_height);
+        XSync(display,False); /* send all events to sync; */
+   } else {
+	Window rootwin, childwin;
+	int rx, ry, x, y, dx, dy;
+	int w, h;
+	unsigned int mask;
+	Bool ok;
+
+	/* sync with root window to coord 0/0 */
+	XMoveWindow(display,window, 0, 0);
+        XSync(display,False); /* send all events to sync; */
+
+	/* get the diff of both orig. coord */
+	ok = XQueryPointer(display, window, &rootwin, &childwin,
+			    &rx, &ry, &x, &y, &mask);
+	dx = rx-x;
+	dy = ry-y;
+	
+	/* get the aspect future full screen size */
+	w = fullscreen_width;
+	h = fullscreen_height;
+	xgl_fixaspectratio(&w, &h);
+
+	/* the new coords .. */
+	x = ( fullscreen_width  - w  ) / 2 - dx;
+	y = ( fullscreen_height - h ) / 2 - dy;
+
+#ifndef NDEBUG
+	printf("GLINFO: switching to max aspect %d/%d, %dx%d\n", x, y, w, h);
+#endif
+
+	XMoveResizeWindow(display, window, x, y, w, h);
+        XSync(display,False); /* send all events to sync; */
+    }
+    is_fullscreen = !is_fullscreen;
+}
diff --git a/src/unix/video-drivers/xil.c b/src/unix/video-drivers/xil.c
new file mode 100644
index 0000000..eb1e113
--- /dev/null
+++ b/src/unix/video-drivers/xil.c
@@ -0,0 +1,129 @@
+/*
+ *  Support for the XIL imaging library.
+ *
+ *  Elias Mrtenson (elias-m@algonet.se)
+ */
+
+/* moved above the #ifdef to avoid warning about empty c-files */
+#include <stdio.h>
+
+#ifdef USE_XIL
+
+#include <thread.h>
+#include <pthread.h>
+#include <X11/Xlib.h>
+#include <X11/Xutil.h>
+#include <xil/xil.h>
+#include "xmame.h"
+#include "x11.h"
+
+static void scale_screen( XilImage );
+static void *redraw_thread( void * );
+
+static XilSystemState state;
+static XilImage window_image, draw_image;
+static int draw_image_xsize, draw_image_ysize;
+static int window_width, window_height;
+
+static pthread_mutex_t img_mutex;
+static pthread_cond_t img_cond;
+static int paintflag;
+static XilImage back_image;
+
+void init_xil( void )
+{
+  if( (state = xil_open()) == NULL ) {
+    fprintf( stderr, "Failed to open XIL library, disabling\n" );
+    use_xil = 0;
+  }
+  else {
+    printf( "Using XIL library\n" );
+  }
+}
+
+void setup_xil_images( int xsize, int ysize )
+{
+  XilMemoryStorage storage_info;
+  pthread_t thread_id;
+
+  window_image = xil_create_from_window( state, display, window );
+
+  draw_image_xsize = xsize;
+  draw_image_ysize = ysize;
+
+  window_width = xsize;
+  window_height = ysize;
+
+  draw_image = xil_create( state, xsize, ysize, 1, XIL_SHORT );
+  xil_export( draw_image );
+  xil_get_memory_storage( draw_image, &storage_info );
+  scaled_buffer_ptr = (char *)storage_info.byte.data;
+
+  if( use_mt_xil ) {
+    printf( "initializing scaling thread\n" );
+    back_image = xil_create( state, xsize, ysize, 1, XIL_BYTE );
+    pthread_mutex_init( &img_mutex, NULL );
+    paintflag = 0;
+    pthread_create( &thread_id, NULL, redraw_thread, NULL );
+  }
+}
+
+void refresh_xil_screen( void )
+{
+  XilMemoryStorage storage_info;
+
+  xil_import( draw_image, TRUE );
+  if( use_mt_xil ) {
+    pthread_mutex_lock( &img_mutex );
+    while( paintflag ) {
+      pthread_cond_wait( &img_cond, &img_mutex );
+    }
+    xil_copy( draw_image, back_image );
+    paintflag = 1;
+    pthread_mutex_unlock( &img_mutex );
+    pthread_cond_signal( &img_cond );
+  }
+  else {
+    scale_screen( draw_image );
+  }
+
+  xil_export( draw_image );
+  xil_get_memory_storage( draw_image, &storage_info );
+  scaled_buffer_ptr = (char *)storage_info.byte.data;
+}
+
+static void scale_screen( XilImage source )
+{
+  xil_scale( source, window_image, "nearest",
+	     window_width / (float)draw_image_xsize,
+	     window_height / (float)draw_image_ysize );
+}
+
+void update_xil_window_size( int width, int height )
+{
+  window_width = width;
+  window_height = height;
+
+  if( window_image != NULL ) {
+    xil_destroy( window_image );
+  }
+  window_image = xil_create_from_window( state, display, window );
+}  
+
+static void *redraw_thread( void *arg )
+{
+  for( ;; ) {
+    pthread_mutex_lock( &img_mutex );
+    while( !paintflag ) {
+      pthread_cond_wait( &img_cond, &img_mutex );
+    }
+    scale_screen( back_image );
+    paintflag = 0;
+    pthread_mutex_unlock( &img_mutex );
+    pthread_cond_signal( &img_cond );
+  }
+
+  return NULL;
+}
+
+#endif
diff --git a/src/unix/video-drivers/xinput.c b/src/unix/video-drivers/xinput.c
new file mode 100644
index 0000000..7e89e1e
--- /dev/null
+++ b/src/unix/video-drivers/xinput.c
@@ -0,0 +1,325 @@
+/*
+ * X-Mame x11 input code
+ *
+ */
+#include <X11/Xlib.h>
+#include <X11/Xutil.h>
+#include <X11/keysym.h>
+#include "xmame.h"
+#include "devices.h"
+#include "x11.h"
+#include "xkeyboard.h"
+#include "keyboard.h"
+
+#ifdef xgl
+#include "glmame.h"
+static int xgl_aspect_resize_action = 0;
+#endif
+
+static int current_mouse[MOUSE_AXIS] = {0,0,0,0,0,0,0,0};
+static int x11_use_winkeys = 0;
+
+static int x11_mapkey(struct rc_option *option, const char *arg, int priority);
+
+struct rc_option x11_input_opts[] = {
+	/* name, shortname, type, dest, deflt, min, max, func, help */
+	{ "X11-input related", NULL, rc_seperator, NULL, NULL, 0, 0, NULL, NULL },
+	{ "grabmouse", "gm", rc_bool, &x11_grab_mouse, "0", 0, 0, NULL, "Enable/disable mousegrabbing (also alt + pagedown)" },
+	{ "grabkeyboard", "gkb", rc_bool, &x11_grab_keyboard, "0", 0, 0, NULL, "Enable/disable keyboardgrabbing (also alt + pageup)" },
+	{ "winkeys", "wk", rc_bool, &x11_use_winkeys, "0", 0, 0, NULL, "Enable/disable mapping of windowskeys under X" },
+	{ "mapkey", "mk", rc_use_function, NULL, NULL, 0, 0, x11_mapkey, "Set a specific key mapping, see xmamerc.dist" },
+	{ NULL, NULL, rc_end, NULL, NULL, 0, 0, NULL, NULL }
+};
+
+#if defined(__sgi) && !defined(MESS)
+/* Under Xmame, track if the game is paused due to window iconification */
+static unsigned char game_paused_by_unmap = FALSE;
+#endif
+
+/*
+ * Parse keyboard events
+ */
+void sysdep_update_keyboard (void)
+{
+	XEvent				E;
+	KeySym				keysym;
+	char				keyname[16+1];
+	int				mask;
+	struct xmame_keyboard_event	event;
+	static int			old_grab_mouse = FALSE;
+	/* grrr some windowmanagers send multiple focus events, this is used to
+	   filter them. */
+	static int			focus = FALSE;
+
+	/* handle winkey mappings */
+	if (x11_use_winkeys)
+	{
+		extended_code_table[XK_Meta_L&0x1FF] = KEY_LWIN; 
+		extended_code_table[XK_Meta_R&0x1FF] = KEY_RWIN; 
+	}
+
+#ifdef NOT_DEFINED /* x11 */
+	if(run_in_root_window && x11_video_mode == X11_WINDOW)
+	{
+		static int i=0;
+		i = ++i % 3;
+		switch (i)
+		{
+			case 0:
+				xkey[KEY_O] = 0;
+				xkey[KEY_K] = 0;
+				break;
+			case 1:
+				xkey[KEY_O] = 1;
+				xkey[KEY_K] = 0;
+				break;
+			case 2:
+				xkey[KEY_O] = 0;
+				xkey[KEY_K] = 1;
+				break;
+		}
+	}
+	else
+#endif
+
+		/* query all events that we have previously requested */
+		while ( XPending(display) )
+		{
+			mask = FALSE;
+			event.press = FALSE;
+
+			XNextEvent(display,&E);
+			/*  fprintf(stderr_file,"Event: %d\n",E.type); */
+
+			/* we don't have to check x11_video_mode or extensions like xil here,
+			   since our eventmask should make sure that we only get the event's matching
+			   the current update method */
+			switch (E.type)
+			{
+				/* display events */
+#ifdef x11
+				case Expose:
+					if ( E.xexpose.count == 0 ) x11_window_refresh_screen();
+					break;
+#endif
+#ifdef xgl
+				case ConfigureNotify:
+					if(E.xany.window == window)
+					{
+						if( xgl_aspect_resize_action == 0 &&
+								(
+								 abs(winwidth - E.xconfigure.width) > 50 ||
+								 abs(winheight - E.xconfigure.height) > 50
+								)
+						  )
+						{
+							xgl_aspect_resize_action = 1;
+
+							winwidth  = E.xconfigure.width;
+							winheight = E.xconfigure.height; 
+
+							xgl_fixaspectratio(&winwidth, &winheight);
+
+							XResizeWindow(display,window,winwidth, winheight);
+
+							xgl_resize(winwidth, winheight, 0);
+						} else {
+							xgl_aspect_resize_action = 0;
+						}
+					}
+					break;
+#endif
+				case FocusIn:
+					/* check for multiple events and ignore them */
+					if (focus) break;
+					focus = TRUE;
+					/* to avoid some meta-keys to get locked when wm iconify xmame, we must
+					   perform a key reset whenever we retrieve keyboard focus */
+					xmame_keyboard_clear();
+					if (old_grab_mouse)
+					{
+						if (!XGrabPointer(display, window, True, 0, GrabModeAsync,
+									GrabModeAsync, window, None, CurrentTime))
+						{
+							if (show_cursor) XDefineCursor(display,window,invisible_cursor);
+							x11_grab_mouse = TRUE;
+						}
+					}
+					break;
+				case FocusOut:
+					/* check for multiple events and ignore them */
+					if (!focus) break;
+					focus = FALSE;
+					old_grab_mouse = x11_grab_mouse;
+					if (x11_grab_mouse)
+					{
+						XUngrabPointer(display, CurrentTime);
+						if (show_cursor) XDefineCursor(display,window,normal_cursor);
+						x11_grab_mouse = FALSE;
+					}
+					break;
+				case EnterNotify:
+					if (use_private_cmap) XInstallColormap(display,colormap);
+					break;	
+				case LeaveNotify:
+					if (use_private_cmap) XInstallColormap(display,DefaultColormapOfScreen(screen));
+					break;	
+#ifdef USE_XIL
+				case ConfigureNotify:
+					update_xil_window_size( E.xconfigure.width, E.xconfigure.height );
+					break;
+#endif
+					/* input events */    
+				case MotionNotify:
+					current_mouse[0] += E.xmotion.x_root;
+					current_mouse[1] += E.xmotion.y_root;
+					break;
+				case ButtonPress:
+					mask = TRUE;
+#ifdef USE_DGA
+					/* Some buggy combination of XFree and virge screwup the viewport
+					   on the first mouseclick */
+					if(xf86_dga_first_click) { xf86_dga_first_click = 0; xf86_dga_fix_viewport = 1; }
+#endif          
+				case ButtonRelease:
+					mouse_data[0].buttons[E.xbutton.button-1] = mask;
+					break;
+				case KeyPress:
+					event.press = TRUE;
+				case KeyRelease:
+					/* get bare keysym, for the scancode */
+					keysym = XLookupKeysym ((XKeyEvent *) &E, 0);
+					/* get key name, using modifiers for the unicode */
+					XLookupString ((XKeyEvent *) &E, keyname, 16, NULL, NULL);
+
+					/*	fprintf(stderr, "Keyevent keycode: %04X, keysym: %04X, unicode: %02X\n",
+						E.xkey.keycode, (unsigned int)keysym, (unsigned int)keyname[0]); */
+
+					/* look which table should be used */
+					if ( (keysym & ~0x1ff) == 0xfe00 )
+						event.scancode = extended_code_table[keysym & 0x01ff];
+					else if (keysym < 0xff)
+						event.scancode = code_table[keysym & 0x00ff];
+					else
+						event.scancode = 0;
+
+					event.unicode = keyname[0];
+
+					xmame_keyboard_register_event(&event);
+					break;
+#if defined USE_XINPUT_DEVICES || defined X11_JOYSTICK
+				default:
+#endif
+#ifdef USE_XINPUT_DEVICES
+					if (XInputProcessEvent(&E)) break;
+#endif
+
+#if defined(__sgi) && !defined(MESS)
+					/*
+					 * Push the pause keycode in the Xmame keyboard queue, accordingly to
+					 * to the three rules explained below. This should pause/run the game if
+					 * Xmame window is unmapped/mapped.
+					 *
+					 * Rules:
+					 * - mapped with game paused by unmap -> restart the game
+					 * - unmapped with game running -> pause the game and flag the condition
+					 * - unmapped with game paused  -> no action (already paused by the user)
+					 */
+				case MapNotify:
+					game_paused_by_unmap = FALSE;
+					break;
+
+				case UnmapNotify:
+					if (! is_game_paused())
+						game_paused_by_unmap = TRUE;
+					break;
+#endif
+
+#ifdef X11_JOYSTICK
+					/* grrr we can't use case here since the event types for XInput devices
+					   aren't hardcoded, since we should have caught anything else above,
+					   just asume it's an XInput event */
+					process_x11_joy_event(&E);
+					break;
+#endif
+			} /* switch */
+		} /* while */
+}
+
+/*
+ *  keyboard remapping routine
+ *  invoiced in startup code
+ *  returns 0-> success 1-> invalid from or to
+ */
+static int x11_mapkey(struct rc_option *option, const char *arg, int priority)
+{
+	unsigned int from,to;
+	/* ultrix sscanf() requires explicit leading of 0x for hex numbers */
+	if ( sscanf(arg,"0x%x,0x%x",&from,&to) == 2)
+	{
+		/* perform tests */
+		/* fprintf(stderr,"trying to map %x to %x\n",from,to); */
+		if ( to <= 127 )
+		{
+			if ( from <= 0x00ff ) 
+			{
+				code_table[from]=to; return OSD_OK;
+			}
+			else if ( (from>=0xfe00) && (from<=0xffff) ) 
+			{
+				extended_code_table[from&0x01ff]=to; return OSD_OK;
+			}
+		}
+		/* stderr_file isn't defined yet when we're called. */
+		fprintf(stderr,"Invalid keymapping %s. Ignoring...\n", arg);
+	}
+	return OSD_NOT_OK;
+}
+
+void sysdep_mouse_poll (void)
+{
+	int i;
+	if(x11_video_mode == X11_DGA)
+	{
+		/* 2 should be MOUSE_AXIS but we don't support more
+		   then 2 axis at the moment so this is faster */
+		for (i=0; i<2; i++)
+		{
+			mouse_data[0].deltas[i] = current_mouse[i];
+			current_mouse[i] = 0;
+		}
+	}
+	else
+	{
+		Window root,child;
+		int root_x, root_y, pos_x, pos_y;
+		unsigned int keys_buttons;
+
+		if (!XQueryPointer(display,window, &root,&child, &root_x,&root_y,
+					&pos_x,&pos_y,&keys_buttons) )
+		{
+			mouse_data[0].deltas[0] = 0;
+			mouse_data[0].deltas[1] = 0;
+			return;
+		}
+
+		if ( x11_grab_mouse )
+		{
+			XWarpPointer(display, None, window, 0, 0, 0, 0,
+					visual_width/2, visual_height/2);
+			mouse_data[0].deltas[0] = pos_x - visual_width/2;
+			mouse_data[0].deltas[1] = pos_y - visual_height/2;
+		}
+		else
+		{
+			mouse_data[0].deltas[0] = pos_x - current_mouse[0];
+			mouse_data[0].deltas[1] = pos_y - current_mouse[1];
+			current_mouse[0] = pos_x;
+			current_mouse[1] = pos_y;
+		}
+	}
+}
+
+void sysdep_set_leds(int leds)
+{
+}
diff --git a/src/unix/video-drivers/xkeyboard.h b/src/unix/video-drivers/xkeyboard.h
new file mode 100644
index 0000000..d7573a2
--- /dev/null
+++ b/src/unix/video-drivers/xkeyboard.h
@@ -0,0 +1,823 @@
+#include "keyboard.h"
+
+/* translation table from X11 codes to raw keyboard scan codes */
+/* the idea is make a re-definable lookup table, instead a long case switch */
+
+/* following code is taken from keysmdef.h */
+
+/******************************************************************/
+/* $XConsortium: keysymdef.h /main/24 1996/02/02 14:28:10 kaleb $ */
+/******************************************************************/
+
+/* XK_VoidSymbol	0xFFFFFF	*/ /* void symbol */
+
+static int extended_code_table[512] = {
+/*                      		0xFE00  */ KEY_NONE,
+/* XK_ISO_Lock				0xFE01  */ KEY_NONE,
+/* XK_ISO_Level2_Latch			0xFE02  */ KEY_NONE,
+/* XK_ISO_Level3_Shift			0xFE03  */ KEY_NONE,
+/* XK_ISO_Level3_Latch			0xFE04  */ KEY_NONE,
+/* XK_ISO_Level3_Lock			0xFE05  */ KEY_NONE,
+/* XK_ISO_Group_Latch			0xFE06  */ KEY_NONE,
+/* XK_ISO_Group_Lock			0xFE07  */ KEY_NONE,
+/* XK_ISO_Next_Group			0xFE08  */ KEY_NONE,
+/* XK_ISO_Next_Group_Lock		0xFE09  */ KEY_NONE,
+/* XK_ISO_Prev_Group			0xFE0A  */ KEY_NONE,
+/* XK_ISO_Prev_Group_Lock		0xFE0B  */ KEY_NONE,
+/* XK_ISO_First_Group			0xFE0C  */ KEY_NONE,
+/* XK_ISO_First_Group_Lock		0xFE0D  */ KEY_NONE,
+/* XK_ISO_Last_Group			0xFE0E  */ KEY_NONE,
+/* XK_ISO_Last_Group_Lock		0xFE0F  */ KEY_NONE,
+/*					0xFE10  */ KEY_NONE,
+/*					0xFE11  */ KEY_NONE,
+/*					0xFE12  */ KEY_NONE,
+/*					0xFE13  */ KEY_NONE,
+/*					0xFE14  */ KEY_NONE,
+/*					0xFE15  */ KEY_NONE,
+/*					0xFE16  */ KEY_NONE,
+/*					0xFE17  */ KEY_NONE,
+/*					0xFE18  */ KEY_NONE,
+/*					0xFE19  */ KEY_NONE,
+/*					0xFE1A  */ KEY_NONE,
+/*					0xFE1B  */ KEY_NONE,
+/*					0xFE1C  */ KEY_NONE,
+/*					0xFE1D  */ KEY_NONE,
+/*					0xFE1E  */ KEY_NONE,
+/*					0xFE1F  */ KEY_NONE,
+/* XK_ISO_Left_Tab			0xFE20  */ KEY_TAB,
+/* XK_ISO_Move_Line_Up			0xFE21  */ KEY_UP,
+/* XK_ISO_Move_Line_Down		0xFE22  */ KEY_DOWN,
+/* XK_ISO_Partial_Line_Up		0xFE23  */ KEY_NONE,
+/* XK_ISO_Partial_Line_Down		0xFE24  */ KEY_NONE,
+/* XK_ISO_Partial_Space_Left		0xFE25  */ KEY_NONE,
+/* XK_ISO_Partial_Space_Right		0xFE26  */ KEY_NONE,
+/* XK_ISO_Set_Margin_Left		0xFE27  */ KEY_NONE,
+/* XK_ISO_Set_Margin_Right		0xFE28  */ KEY_NONE,
+/* XK_ISO_Release_Margin_Left		0xFE29  */ KEY_NONE,
+/* XK_ISO_Release_Margin_Right		0xFE2A  */ KEY_NONE,
+/* XK_ISO_Release_Both_Margins		0xFE2B  */ KEY_NONE,
+/* XK_ISO_Fast_Cursor_Left		0xFE2C  */ KEY_LEFT,
+/* XK_ISO_Fast_Cursor_Right		0xFE2D  */ KEY_RIGHT,
+/* XK_ISO_Fast_Cursor_Up		0xFE2E  */ KEY_UP,
+/* XK_ISO_Fast_Cursor_Down		0xFE2F  */ KEY_DOWN,
+/* XK_ISO_Continuous_Underline		0xFE30  */ KEY_MINUS,
+/* XK_ISO_Discontinuous_Underline	0xFE31  */ KEY_MINUS,
+/* XK_ISO_Emphasize			0xFE32  */ KEY_NONE,
+/* XK_ISO_Center_Object			0xFE33  */ KEY_NONE,
+/* XK_ISO_Enter				0xFE34  */ KEY_ENTER,
+/*					0xFE35  */ KEY_NONE,
+/*					0xFE36  */ KEY_NONE,
+/*					0xFE37  */ KEY_NONE,
+/*					0xFE38  */ KEY_NONE,
+/*					0xFE39  */ KEY_NONE,
+/*					0xFE3A  */ KEY_NONE,
+/*					0xFE3B  */ KEY_NONE,
+/*					0xFE3C  */ KEY_NONE,
+/*					0xFE3D  */ KEY_NONE,
+/*					0xFE3E  */ KEY_NONE,
+/*					0xFE3F  */ KEY_NONE,
+/*					0xFE40  */ KEY_NONE,
+/*					0xFE41  */ KEY_NONE,
+/*					0xFE42  */ KEY_NONE,
+/*					0xFE43  */ KEY_NONE,
+/*					0xFE44  */ KEY_NONE,
+/*					0xFE45  */ KEY_NONE,
+/*					0xFE46  */ KEY_NONE,
+/*					0xFE47  */ KEY_NONE,
+/*					0xFE48  */ KEY_NONE,
+/*					0xFE49  */ KEY_NONE,
+/*					0xFE4A  */ KEY_NONE,
+/*					0xFE4B  */ KEY_NONE,
+/*					0xFE4C  */ KEY_NONE,
+/*					0xFE4D  */ KEY_NONE,
+/*					0xFE4E  */ KEY_NONE,
+/*					0xFE4F  */ KEY_NONE,
+/* XK_dead_grave			0xFE50  */ KEY_TILDE,
+/* XK_dead_acute			0xFE51  */ KEY_NONE,
+/* XK_dead_circumflex			0xFE52  */ KEY_TILDE,
+/* XK_dead_tilde			0xFE53  */ KEY_TILDE,
+/* XK_dead_macron			0xFE54  */ KEY_NONE,
+/* XK_dead_breve			0xFE55  */ KEY_NONE,
+/* XK_dead_abovedot			0xFE56  */ KEY_NONE,
+/* XK_dead_diaeresis			0xFE57  */ KEY_NONE,
+/* XK_dead_abovering			0xFE58  */ KEY_NONE,
+/* XK_dead_doubleacute			0xFE59  */ KEY_NONE,
+/* XK_dead_caron			0xFE5A  */ KEY_NONE,
+/* XK_dead_cedilla			0xFE5B  */ KEY_NONE,
+/* XK_dead_ogonek			0xFE5C  */ KEY_NONE,
+/* XK_dead_iota				0xFE5D  */ KEY_NONE,
+/* XK_dead_voiced_sound			0xFE5E  */ KEY_NONE,
+/* XK_dead_semivoiced_sound		0xFE5F  */ KEY_NONE,
+/* XK_dead_belowdot			0xFE60  */ KEY_NONE,
+/*					0xFE61  */ KEY_NONE,
+/*					0xFE62  */ KEY_NONE,
+/*					0xFE63  */ KEY_NONE,
+/*					0xFE64  */ KEY_NONE,
+/*					0xFE65  */ KEY_NONE,
+/*					0xFE66  */ KEY_NONE,
+/*					0xFE67  */ KEY_NONE,
+/*					0xFE68  */ KEY_NONE,
+/*					0xFE69  */ KEY_NONE,
+/*					0xFE6A  */ KEY_NONE,
+/*					0xFE6B  */ KEY_NONE,
+/*					0xFE6C  */ KEY_NONE,
+/*					0xFE6D  */ KEY_NONE,
+/*					0xFE6E  */ KEY_NONE,
+/*					0xFE6F  */ KEY_NONE,
+/* XK_AccessX_Enable			0xFE70  */ KEY_NONE,
+/* XK_AccessX_Feedback_Enable		0xFE71  */ KEY_NONE,
+/* XK_RepeatKeys_Enable			0xFE72  */ KEY_NONE,
+/* XK_SlowKeys_Enable			0xFE73  */ KEY_NONE,
+/* XK_BounceKeys_Enable			0xFE74  */ KEY_NONE,
+/* XK_StickyKeys_Enable			0xFE75  */ KEY_NONE,
+/* XK_MouseKeys_Enable			0xFE76  */ KEY_NONE,
+/* XK_MouseKeys_Accel_Enable		0xFE77  */ KEY_NONE,
+/* XK_Overlay1_Enable			0xFE78  */ KEY_NONE,
+/* XK_Overlay2_Enable			0xFE79  */ KEY_NONE,
+/* XK_AudibleBell_Enable		0xFE7A  */ KEY_NONE,
+/*					0xFE7B  */ KEY_NONE,
+/*					0xFE7C  */ KEY_NONE,
+/*					0xFE7D  */ KEY_NONE,
+/*					0xFE7E  */ KEY_NONE,
+/*					0xFE7F  */ KEY_NONE,
+/*					0xFE80  */ KEY_NONE,
+/*					0xFE81  */ KEY_NONE,
+/*					0xFE82  */ KEY_NONE,
+/*					0xFE83  */ KEY_NONE,
+/*					0xFE84  */ KEY_NONE,
+/*					0xFE85  */ KEY_NONE,
+/*					0xFE86  */ KEY_NONE,
+/*					0xFE87  */ KEY_NONE,
+/*					0xFE88  */ KEY_NONE,
+/*					0xFE89  */ KEY_NONE,
+/*					0xFE8A  */ KEY_NONE,
+/*					0xFE8B  */ KEY_NONE,
+/*					0xFE8C  */ KEY_NONE,
+/*					0xFE8D  */ KEY_NONE,
+/*					0xFE8E  */ KEY_NONE,
+/*					0xFE8F  */ KEY_NONE,
+/*					0xFE90  */ KEY_NONE,
+/*					0xFE91  */ KEY_NONE,
+/*					0xFE92  */ KEY_NONE,
+/*					0xFE93  */ KEY_NONE,
+/*					0xFE94  */ KEY_NONE,
+/*					0xFE95  */ KEY_NONE,
+/*					0xFE96  */ KEY_NONE,
+/*					0xFE97  */ KEY_NONE,
+/*					0xFE98  */ KEY_NONE,
+/*					0xFE99  */ KEY_NONE,
+/*					0xFE9A  */ KEY_NONE,
+/*					0xFE9B  */ KEY_NONE,
+/*					0xFE9C  */ KEY_NONE,
+/*					0xFE9D  */ KEY_NONE,
+/*					0xFE9E  */ KEY_NONE,
+/*					0xFE9F  */ KEY_NONE,
+/*					0xFEA0  */ KEY_NONE,
+/*					0xFEA1  */ KEY_NONE,
+/*					0xFEA2  */ KEY_NONE,
+/*					0xFEA3  */ KEY_NONE,
+/*					0xFEA4  */ KEY_NONE,
+/*					0xFEA5  */ KEY_NONE,
+/*					0xFEA6  */ KEY_NONE,
+/*					0xFEA7  */ KEY_NONE,
+/*					0xFEA8  */ KEY_NONE,
+/*					0xFEA9  */ KEY_NONE,
+/*					0xFEAA  */ KEY_NONE,
+/*					0xFEAB  */ KEY_NONE,
+/*					0xFEAC  */ KEY_NONE,
+/*					0xFEAD  */ KEY_NONE,
+/*					0xFEAE  */ KEY_NONE,
+/*					0xFEAF  */ KEY_NONE,
+/*					0xFEB0  */ KEY_NONE,
+/*					0xFEB1  */ KEY_NONE,
+/*					0xFEB2  */ KEY_NONE,
+/*					0xFEB3  */ KEY_NONE,
+/*					0xFEB4  */ KEY_NONE,
+/*					0xFEB5  */ KEY_NONE,
+/*					0xFEB6  */ KEY_NONE,
+/*					0xFEB7  */ KEY_NONE,
+/*					0xFEB8  */ KEY_NONE,
+/*					0xFEB9  */ KEY_NONE,
+/*					0xFEBA  */ KEY_NONE,
+/*					0xFEBB  */ KEY_NONE,
+/*					0xFEBC  */ KEY_NONE,
+/*					0xFEBD  */ KEY_NONE,
+/*					0xFEBE  */ KEY_NONE,
+/*					0xFEBF  */ KEY_NONE,
+/*					0xFEC0  */ KEY_NONE,
+/*					0xFEC1  */ KEY_NONE,
+/*					0xFEC2  */ KEY_NONE,
+/*					0xFEC3  */ KEY_NONE,
+/*					0xFEC4  */ KEY_NONE,
+/*					0xFEC5  */ KEY_NONE,
+/*					0xFEC6  */ KEY_NONE,
+/*					0xFEC7  */ KEY_NONE,
+/*					0xFEC8  */ KEY_NONE,
+/*					0xFEC9  */ KEY_NONE,
+/*					0xFECA  */ KEY_NONE,
+/*					0xFECB  */ KEY_NONE,
+/*					0xFECC  */ KEY_NONE,
+/*					0xFECD  */ KEY_NONE,
+/*					0xFECE  */ KEY_NONE,
+/*					0xFECF  */ KEY_NONE,
+/* XK_First_Virtual_Screen		0xFED0  */ KEY_NONE,
+/* XK_Prev_Virtual_Screen		0xFED1  */ KEY_NONE,
+/* XK_Next_Virtual_Screen		0xFED2  */ KEY_NONE,
+/*					0xFED3  */ KEY_NONE,
+/* XK_Last_Virtual_Screen		0xFED4  */ KEY_NONE,
+/* XK_Terminate_Server			0xFED5  */ KEY_NONE,
+/*					0xFED6  */ KEY_NONE,
+/*					0xFED7  */ KEY_NONE,
+/*					0xFED8  */ KEY_NONE,
+/*					0xFED9  */ KEY_NONE,
+/*					0xFEDA  */ KEY_NONE,
+/*					0xFEDB  */ KEY_NONE,
+/*					0xFEDC  */ KEY_NONE,
+/*					0xFEDD  */ KEY_NONE,
+/*					0xFEDE  */ KEY_NONE,
+/*					0xFEDF  */ KEY_NONE,
+/* XK_Pointer_Left			0xFEE0  */ KEY_NONE,
+/* XK_Pointer_Right			0xFEE1  */ KEY_NONE,
+/* XK_Pointer_Up			0xFEE2  */ KEY_NONE,
+/* XK_Pointer_Down			0xFEE3  */ KEY_NONE,
+/* XK_Pointer_UpLeft			0xFEE4  */ KEY_NONE,
+/* XK_Pointer_UpRight			0xFEE5  */ KEY_NONE,
+/* XK_Pointer_DownLeft			0xFEE6  */ KEY_NONE,
+/* XK_Pointer_DownRight			0xFEE7  */ KEY_NONE,
+/* XK_Pointer_Button_Dflt		0xFEE8  */ KEY_NONE,
+/* XK_Pointer_Button1			0xFEE9  */ KEY_NONE,
+/* XK_Pointer_Button2			0xFEEA  */ KEY_NONE,
+/* XK_Pointer_Button3			0xFEEB  */ KEY_NONE,
+/* XK_Pointer_Button4			0xFEEC  */ KEY_NONE,
+/* XK_Pointer_Button5			0xFEED  */ KEY_NONE,
+/* XK_Pointer_DblClick_Dflt		0xFEEE  */ KEY_NONE,
+/* XK_Pointer_DblClick1			0xFEEF  */ KEY_NONE,
+/* XK_Pointer_DblClick2			0xFEF0  */ KEY_NONE,
+/* XK_Pointer_DblClick3			0xFEF1  */ KEY_NONE,
+/* XK_Pointer_DblClick4			0xFEF2  */ KEY_NONE,
+/* XK_Pointer_DblClick5			0xFEF3  */ KEY_NONE,
+/* XK_Pointer_Drag_Dflt			0xFEF4  */ KEY_NONE,
+/* XK_Pointer_Drag1			0xFEF5  */ KEY_NONE,
+/* XK_Pointer_Drag2			0xFEF6  */ KEY_NONE,
+/* XK_Pointer_Drag3			0xFEF7  */ KEY_NONE,
+/* XK_Pointer_Drag4			0xFEF8  */ KEY_NONE,
+/* XK_Pointer_EnableKeys		0xFEF9  */ KEY_NONE,
+/* XK_Pointer_Accelerate		0xFEFA  */ KEY_NONE,
+/* XK_Pointer_DfltBtnNext		0xFEFB  */ KEY_NONE,
+/* XK_Pointer_DfltBtnPrev		0xFEFC  */ KEY_NONE,
+/* XK_Pointer_Drag5			0xFEFD  */ KEY_NONE,
+/*					0xFEFE  */ KEY_NONE,
+/*					0xFEFF  */ KEY_NONE,
+/*					0xFF00  */ KEY_NONE,
+/*					0xFF01  */ KEY_NONE,
+/*					0xFF02  */ KEY_NONE,
+/*					0xFF03  */ KEY_NONE,
+/*					0xFF04  */ KEY_NONE,
+/*					0xFF05  */ KEY_NONE,
+/*					0xFF06  */ KEY_NONE,
+/*					0xFF07  */ KEY_NONE,
+/* XK_BackSpace				0xFF08	*/ KEY_BACKSPACE,
+/* XK_Tab				0xFF09	*/ KEY_TAB,
+/* XK_Linefeed				0xFF0A	*/ KEY_ENTER,
+/* XK_Clear				0xFF0B  */ KEY_DEL,
+/*					0xFF0C  */ KEY_NONE,
+/* XK_Return				0xFF0D	*/ KEY_ENTER,
+/*					0xFF0E  */ KEY_NONE,
+/*					0xFF0F  */ KEY_NONE,
+/*					0xFF10  */ KEY_F11,
+/*					0xFF11  */ KEY_F12,
+/*					0xFF12  */ KEY_NONE,
+/* XK_Pause				0xFF13	*/ KEY_PAUSE,
+/* XK_Scroll_Lock			0xFF14  */ KEY_SCRLOCK,
+/* XK_Sys_Req				0xFF15  */ KEY_PRTSCR,
+/*					0xFF16  */ KEY_NONE,
+/*					0xFF17  */ KEY_NONE,
+/*					0xFF18  */ KEY_NONE,
+/*					0xFF19  */ KEY_NONE,
+/*					0xFF1A  */ KEY_NONE,
+/* XK_Escape				0xFF1B  */ KEY_ESC,
+/*					0xFF1C  */ KEY_NONE,
+/*					0xFF1D  */ KEY_NONE,
+/*					0xFF1E  */ KEY_NONE,
+/*					0xFF1F  */ KEY_NONE,
+/* XK_Multi_key				0xFF20  */ KEY_NONE,
+/* XK_Kanji				0xFF21	*/ KEY_NONE,
+/* XK_Muhenkan				0xFF22  */ KEY_NONE,
+/* XK_Henkan_Mode			0xFF23  */ KEY_NONE,
+/* XK_Henkan				0xFF23  duplicated */
+/* XK_Romaji				0xFF24  */ KEY_NONE,
+/* XK_Hiragana				0xFF25  */ KEY_NONE,
+/* XK_Katakana				0xFF26  */ KEY_NONE,
+/* XK_Hiragana_Katakana			0xFF27  */ KEY_NONE,
+/* XK_Zenkaku				0xFF28  */ KEY_NONE,
+/* XK_Hankaku				0xFF29  */ KEY_NONE,
+/* XK_Zenkaku_Hankaku			0xFF2A  */ KEY_NONE,
+/* XK_Touroku				0xFF2B  */ KEY_NONE,
+/* XK_Massyo				0xFF2C  */ KEY_NONE,
+/* XK_Kana_Lock				0xFF2D  */ KEY_NONE,
+/* XK_Kana_Shift			0xFF2E  */ KEY_NONE,
+/* XK_Eisu_Shift			0xFF2F  */ KEY_NONE,
+/* XK_Eisu_toggle			0xFF30  */ KEY_NONE,
+/*					0xFF31  */ KEY_NONE,
+/*					0xFF32  */ KEY_NONE,
+/*					0xFF33  */ KEY_NONE,
+/*					0xFF34  */ KEY_NONE,
+/*					0xFF35  */ KEY_NONE,
+/*					0xFF36  */ KEY_NONE,
+/*					0xFF37  */ KEY_NONE,
+/*					0xFF38  */ KEY_NONE,
+/*					0xFF39  */ KEY_NONE,
+/*					0xFF3A  */ KEY_NONE,
+/*					0xFF3B  */ KEY_NONE,
+/*					0xFF3C  */ KEY_NONE,
+/*					0xFF3D  */ KEY_NONE,
+/*					0xFF3E  */ KEY_NONE,
+/*					0xFF3F  */ KEY_NONE,
+/*					0xFF40  */ KEY_NONE,
+/*					0xFF41  */ KEY_NONE,
+/*					0xFF42  */ KEY_NONE,
+/*					0xFF43  */ KEY_NONE,
+/*					0xFF44  */ KEY_NONE,
+/*					0xFF45  */ KEY_NONE,
+/*					0xFF46  */ KEY_NONE,
+/*					0xFF47  */ KEY_NONE,
+/*					0xFF48  */ KEY_NONE,
+/*					0xFF49  */ KEY_NONE,
+/*					0xFF4A  */ KEY_NONE,
+/*					0xFF4B  */ KEY_NONE,
+/*					0xFF4C  */ KEY_NONE,
+/*					0xFF4D  */ KEY_NONE,
+/*					0xFF4E  */ KEY_NONE,
+/*					0xFF4F  */ KEY_NONE,
+/* XK_Home				0xFF50  */ KEY_HOME,
+/* XK_Left				0xFF51	*/ KEY_LEFT,
+/* XK_Up				0xFF52	*/ KEY_UP,
+/* XK_Right				0xFF53	*/ KEY_RIGHT,
+/* XK_Down				0xFF54	*/ KEY_DOWN,
+/* XK_Prior				0xFF55	*/ KEY_PGUP,
+/* XK_Page_Up				0xFF55  duplicated */
+/* XK_Next				0xFF56	*/ KEY_PGDN,
+/* XK_Page_Down				0xFF56  duplicated */
+/* XK_End				0xFF57	*/ KEY_END,
+/* XK_Begin				0xFF58	*/ KEY_HOME,
+/*					0xFF59  */ KEY_NONE,
+/*					0xFF5A  */ KEY_NONE,
+/*					0xFF5B  */ KEY_NONE,
+/*					0xFF5C  */ KEY_NONE,
+/*					0xFF5D  */ KEY_NONE,
+/*					0xFF5E  */ KEY_NONE,
+/*					0xFF5F  */ KEY_NONE,
+/* XK_Select				0xFF60	*/ KEY_ENTER_PAD,
+/* XK_Print				0xFF61  */ KEY_PRTSCR,
+/* XK_Execute				0xFF62	*/ KEY_ENTER,
+/* XK_Insert				0xFF63	*/ KEY_INSERT,
+/*					0xFF64	*/ KEY_NONE,
+/* XK_Undo				0xFF65	*/ KEY_NONE,
+/* XK_Redo				0xFF66	*/ KEY_NONE,
+/* XK_Menu				0xFF67  */ KEY_MENU,
+/* XK_Find				0xFF68	*/ KEY_NONE,
+/* XK_Cancel				0xFF69	*/ KEY_ESC,
+/* XK_Help				0xFF6A	*/ KEY_NONE,
+/* XK_Break				0xFF6B  */ KEY_PAUSE,
+/* 					0xFF6C  */ KEY_NONE,
+/* 					0xFF6D  */ KEY_NONE,
+/* 					0xFF6E  */ KEY_NONE,
+/* 					0xFF6F  */ KEY_NONE,
+/* 					0xFF70  */ KEY_NONE,
+/* 					0xFF71  */ KEY_NONE,
+/* 					0xFF72  */ KEY_NONE,
+/* 					0xFF73  */ KEY_NONE,
+/* 					0xFF74  */ KEY_NONE,
+/* 					0xFF75  */ KEY_NONE,
+/* 					0xFF76  */ KEY_NONE,
+/* 					0xFF77  */ KEY_NONE,
+/* 					0xFF78  */ KEY_NONE,
+/* 					0xFF79  */ KEY_NONE,
+/* 					0xFF7A  */ KEY_NONE,
+/* 					0xFF7B  */ KEY_NONE,
+/* 					0xFF7C  */ KEY_NONE,
+/* 					0xFF7D  */ KEY_NONE,
+/* XK_Mode_switch			0xFF7E	*/ KEY_ALTGR,
+/* XK_script_switch			0xFF7E  duplicated */
+/* XK_Num_Lock				0xFF7F  */ KEY_NUMLOCK,
+/* XK_KP_Space				0xFF80	*/ KEY_SPACE,
+/* 					0xFF81  */ KEY_NONE,
+/* 					0xFF82  */ KEY_NONE,
+/* 					0xFF83  */ KEY_NONE,
+/* 					0xFF84  */ KEY_NONE,
+/* 					0xFF85  */ KEY_NONE,
+/* 					0xFF86  */ KEY_NONE,
+/* 					0xFF87  */ KEY_NONE,
+/* 					0xFF88  */ KEY_NONE,
+/* XK_KP_Tab				0xFF89  */ KEY_TAB,
+/* 					0xFF8A  */ KEY_NONE,
+/* 					0xFF8B  */ KEY_NONE,
+/* 					0xFF8C  */ KEY_NONE,
+/* XK_KP_Enter				0xFF8D	*/ KEY_ENTER_PAD,
+/* 					0xFF8E  */ KEY_NONE,
+/* 					0xFF8F  */ KEY_NONE,
+/* 					0xFF90  */ KEY_NONE,
+/* XK_KP_F1				0xFF91	*/ KEY_F1,
+/* XK_KP_F2				0xFF92  */ KEY_F2,
+/* XK_KP_F3				0xFF93  */ KEY_F3,
+/* XK_KP_F4				0xFF94  */ KEY_F4,
+/* XK_KP_Home				0xFF95  */ KEY_7_PAD,
+/* XK_KP_Left				0xFF96  */ KEY_4_PAD,
+/* XK_KP_Up				0xFF97  */ KEY_8_PAD,
+/* XK_KP_Right				0xFF98  */ KEY_6_PAD,
+/* XK_KP_Down				0xFF99  */ KEY_2_PAD,
+/* XK_KP_Prior				0xFF9A  */ KEY_9_PAD,
+/* XK_KP_Page_Up			0xFF9A  duplicated */
+/* XK_KP_Next				0xFF9B  */ KEY_3_PAD,
+/* XK_KP_Page_Down			0xFF9B  duplicated */
+/* XK_KP_End				0xFF9C  */ KEY_1_PAD,
+/* XK_KP_Begin				0xFF9D  */ KEY_5_PAD,
+/* XK_KP_Insert				0xFF9E  */ KEY_0_PAD,
+/* XK_KP_Delete				0xFF9F  */ KEY_DEL_PAD,
+/* 					0xFFA0  */ KEY_NONE,
+/* 					0xFFA1  */ KEY_NONE,
+/* 					0xFFA2  */ KEY_NONE,
+/* 					0xFFA3  */ KEY_NONE,
+/* 					0xFFA4  */ KEY_NONE,
+/* 					0xFFA5  */ KEY_NONE,
+/* 					0xFFA6  */ KEY_NONE,
+/* 					0xFFA7  */ KEY_NONE,
+/* 					0xFFA8  */ KEY_NONE,
+/* 					0xFFA9  */ KEY_NONE,
+/* XK_KP_Multiply			0xFFAA  */ KEY_ASTERISK,
+/* XK_KP_Add				0xFFAB  */ KEY_PLUS_PAD,
+/* XK_KP_Separator			0xFFAC	*/ KEY_DEL_PAD,
+/* XK_KP_Subtract			0xFFAD  */ KEY_MINUS_PAD,
+/* XK_KP_Decimal			0xFFAE  */ KEY_DEL_PAD,
+/* XK_KP_Divide				0xFFAF  */ KEY_SLASH_PAD,
+/* XK_KP_0				0xFFB0  */ KEY_0_PAD,
+/* XK_KP_1				0xFFB1  */ KEY_1_PAD,
+/* XK_KP_2				0xFFB2  */ KEY_2_PAD,
+/* XK_KP_3				0xFFB3  */ KEY_3_PAD,
+/* XK_KP_4				0xFFB4  */ KEY_4_PAD,
+/* XK_KP_5				0xFFB5  */ KEY_5_PAD,
+/* XK_KP_6				0xFFB6  */ KEY_6_PAD,
+/* XK_KP_7				0xFFB7  */ KEY_7_PAD,
+/* XK_KP_8				0xFFB8  */ KEY_8_PAD,
+/* XK_KP_9				0xFFB9  */ KEY_9_PAD,
+/* 					0xFFBA  */ KEY_NONE,
+/* 					0xFFBB  */ KEY_NONE,
+/* 					0xFFBC  */ KEY_NONE,
+/* XK_KP_Equal				0xFFBD	*/ KEY_ENTER_PAD,
+/* XK_F1				0xFFBE  */ KEY_F1,
+/* XK_F2				0xFFBF  */ KEY_F2,
+/* XK_F3				0xFFC0  */ KEY_F3,
+/* XK_F4				0xFFC1  */ KEY_F4,
+/* XK_F5				0xFFC2  */ KEY_F5,
+/* XK_F6				0xFFC3  */ KEY_F6,
+/* XK_F7				0xFFC4  */ KEY_F7,
+/* XK_F8				0xFFC5  */ KEY_F8,
+/* XK_F9				0xFFC6  */ KEY_F9,
+/* XK_F10				0xFFC7  */ KEY_F10,
+/* XK_F11				0xFFC8  */ KEY_F11,
+/* XK_L1				0xFFC8  duplicated */
+/* XK_F12				0xFFC9  */ KEY_F12,
+/* XK_L2				0xFFC9  duplicated */
+/* XK_F13				0xFFCA  */ KEY_NONE,
+/* XK_L3				0xFFCA  duplicated */
+/* XK_F14				0xFFCB  */ KEY_NONE,
+/* XK_L4				0xFFCB  duplicated */
+/* XK_F15				0xFFCC  */ KEY_NONE,
+/* XK_L5				0xFFCC  duplicated */
+/* XK_F16				0xFFCD  */ KEY_NONE,
+/* XK_L6				0xFFCD  duplicated */
+/* XK_F17				0xFFCE  */ KEY_NONE,
+/* XK_L7				0xFFCE  duplicated */
+/* XK_F18				0xFFCF  */ KEY_NONE,
+/* XK_L8				0xFFCF  duplicated */
+/* XK_F19				0xFFD0  */ KEY_NONE,
+/* XK_L9				0xFFD0  duplicated */
+/* XK_F20				0xFFD1  */ KEY_NONE,
+/* XK_L10				0xFFD1  duplicated */
+/* XK_F21				0xFFD2  */ KEY_NONE,
+/* XK_R1				0xFFD2  duplicated */
+/* XK_F22				0xFFD3  */ KEY_NONE,
+/* XK_R2				0xFFD3  duplicated */
+/* XK_F23				0xFFD4  */ KEY_NONE,
+/* XK_R3				0xFFD4  duplicated */
+/* XK_F24				0xFFD5  */ KEY_NONE,
+/* XK_R4				0xFFD5  duplicated */
+/* XK_F25				0xFFD6  */ KEY_NONE,
+/* XK_R5				0xFFD6  duplicated */
+/* XK_F26				0xFFD7  */ KEY_NONE,
+/* XK_R6				0xFFD7  duplicated */
+/* XK_F27				0xFFD8  */ KEY_NONE,
+/* XK_R7				0xFFD8  duplicated */
+/* XK_F28				0xFFD9  */ KEY_NONE,
+/* XK_R8				0xFFD9  duplicated */
+/* XK_F29				0xFFDA  */ KEY_NONE,
+/* XK_R9				0xFFDA  duplicated */
+/* XK_F30				0xFFDB  */ KEY_NONE,
+/* XK_R10				0xFFDB  duplicated */
+/* XK_F31				0xFFDC  */ KEY_NONE,
+/* XK_R11				0xFFDC  duplicated */
+/* XK_F32				0xFFDD  */ KEY_NONE,
+/* XK_R12				0xFFDD  duplicated */
+/* XK_F33				0xFFDE  */ KEY_NONE,
+/* XK_R13				0xFFDE  duplicated */
+/* XK_F34				0xFFDF  */ KEY_NONE,
+/* XK_R14				0xFFDF  duplicated */
+/* XK_F35				0xFFE0  */ KEY_NONE,
+/* XK_R15				0xFFE0  duplicated */
+/* XK_Shift_L				0xFFE1	*/ KEY_LSHIFT,
+/* XK_Shift_R				0xFFE2	*/ KEY_RSHIFT,
+/* XK_Control_L				0xFFE3	*/ KEY_LCONTROL,
+/* XK_Control_R				0xFFE4	*/ KEY_RCONTROL,
+/* XK_Caps_Lock				0xFFE5	*/ KEY_CAPSLOCK,
+/* XK_Shift_Lock			0xFFE6	*/ KEY_CAPSLOCK,
+/* XK_Meta_L				0xFFE7	*/ KEY_ALT,
+/* XK_Meta_R				0xFFE8	*/ KEY_ALT, 
+/* XK_Alt_L				0xFFE9	*/ KEY_ALT,
+/* XK_Alt_R				0xFFEA	*/ KEY_ALTGR,
+/* XK_Super_L				0xFFEB	*/ KEY_NONE,
+/* XK_Super_R				0xFFEC	*/ KEY_NONE,
+/* XK_Hyper_L				0xFFED	*/ KEY_NONE,
+/* XK_Hyper_R				0xFFEE	*/ KEY_NONE,
+/* 					0xFFEF  */ KEY_NONE,
+/* 					0xFFF0  */ KEY_NONE,
+/* 					0xFFF1  */ KEY_NONE,
+/* 					0xFFF2  */ KEY_NONE,
+/* 					0xFFF3  */ KEY_NONE,
+/* 					0xFFF4  */ KEY_NONE,
+/* 					0xFFF5  */ KEY_NONE,
+/* 					0xFFF6  */ KEY_NONE,
+/* 					0xFFF7  */ KEY_NONE,
+/* 					0xFFF8  */ KEY_NONE,
+/* 					0xFFF9  */ KEY_NONE,
+/* 					0xFFFA  */ KEY_NONE,
+/* 					0xFFFB  */ KEY_NONE,
+/* 					0xFFFC  */ KEY_NONE,
+/* 					0xFFFD  */ KEY_NONE,
+/* 					0xFFFE  */ KEY_NONE,
+/* XK_Delete				0xFFFF	*/ KEY_DEL
+}; 	/* extended_code_table */
+
+static int code_table[] = {
+
+/* 			  0x000  */ KEY_NONE,
+/* 			  0x001  */ KEY_NONE,
+/* 			  0x002  */ KEY_NONE,
+/* 			  0x003  */ KEY_NONE,
+/* 			  0x004  */ KEY_NONE,
+/* 			  0x005  */ KEY_NONE,
+/* 			  0x006  */ KEY_NONE,
+/* 			  0x007  */ KEY_NONE,
+/* 			  0x008  */ KEY_NONE,
+/* 			  0x009  */ KEY_NONE,
+/* 			  0x00a  */ KEY_NONE,
+/* 			  0x00b  */ KEY_NONE,
+/* 			  0x00c  */ KEY_NONE,
+/* 			  0x00d  */ KEY_NONE,
+/* 			  0x00e  */ KEY_NONE,
+/* 			  0x00f  */ KEY_NONE,
+/* 			  0x010  */ KEY_NONE,
+/* 			  0x011  */ KEY_NONE,
+/* 			  0x012  */ KEY_NONE,
+/* 			  0x013  */ KEY_NONE,
+/* 			  0x014  */ KEY_NONE,
+/* 			  0x015  */ KEY_NONE,
+/* 			  0x016  */ KEY_NONE,
+/* 			  0x017  */ KEY_NONE,
+/* 			  0x018  */ KEY_NONE,
+/* 			  0x019  */ KEY_NONE,
+/* 			  0x01a  */ KEY_NONE,
+/* 			  0x01b  */ KEY_NONE,
+/* 			  0x01c  */ KEY_NONE,
+/* 			  0x01d  */ KEY_NONE,
+/* 			  0x01e  */ KEY_NONE,
+/* 			  0x01f  */ KEY_NONE,
+/* XK_space               0x020  */ KEY_SPACE,
+/* XK_exclam              0x021  */ KEY_1,
+/* XK_quotedbl            0x022  */ KEY_QUOTE,
+/* XK_numbersign          0x023  */ KEY_3,
+/* XK_dollar              0x024  */ KEY_4,
+/* XK_percent             0x025  */ KEY_5,
+/* XK_ampersand           0x026  */ KEY_7,
+/* XK_apostrophe          0x027  */ KEY_QUOTE, /* keyboard dependent */
+/* XK_quoteright          0x027	 duplicated */ 
+/* XK_parenleft           0x028  */ KEY_9,
+/* XK_parenright          0x029  */ KEY_0,
+/* XK_asterisk            0x02a  */ KEY_ASTERISK,
+/* XK_plus                0x02b  */ KEY_EQUALS,/* keyboard dependent */
+/* XK_comma               0x02c  */ KEY_COMMA,
+/* XK_minus               0x02d  */ KEY_MINUS,
+/* XK_period              0x02e  */ KEY_STOP,
+/* XK_slash               0x02f  */ KEY_SLASH,
+/* XK_0                   0x030  */ KEY_0,
+/* XK_1                   0x031  */ KEY_1,
+/* XK_2                   0x032  */ KEY_2,
+/* XK_3                   0x033  */ KEY_3,
+/* XK_4                   0x034  */ KEY_4,
+/* XK_5                   0x035  */ KEY_5,
+/* XK_6                   0x036  */ KEY_6,
+/* XK_7                   0x037  */ KEY_7,
+/* XK_8                   0x038  */ KEY_8,
+/* XK_9                   0x039  */ KEY_9,
+/* XK_colon               0x03a  */ KEY_COLON,
+/* XK_semicolon           0x03b  */ KEY_COLON,
+/* XK_less                0x03c  */ KEY_COMMA,
+/* XK_equal               0x03d  */ KEY_EQUALS,
+/* XK_greater             0x03e  */ KEY_STOP,
+/* XK_question            0x03f  */ KEY_SLASH,
+/* XK_at                  0x040  */ KEY_2,
+/* XK_A                   0x041  */ KEY_A,
+/* XK_B                   0x042  */ KEY_B,
+/* XK_C                   0x043  */ KEY_C,
+/* XK_D                   0x044  */ KEY_D,
+/* XK_E                   0x045  */ KEY_E,
+/* XK_F                   0x046  */ KEY_F,
+/* XK_G                   0x047  */ KEY_G,
+/* XK_H                   0x048  */ KEY_H,
+/* XK_I                   0x049  */ KEY_I,
+/* XK_J                   0x04a  */ KEY_J,
+/* XK_K                   0x04b  */ KEY_K,
+/* XK_L                   0x04c  */ KEY_L,
+/* XK_M                   0x04d  */ KEY_M,
+/* XK_N                   0x04e  */ KEY_N,
+/* XK_O                   0x04f  */ KEY_O,
+/* XK_P                   0x050  */ KEY_P,
+/* XK_Q                   0x051  */ KEY_Q,
+/* XK_R                   0x052  */ KEY_R,
+/* XK_S                   0x053  */ KEY_S,
+/* XK_T                   0x054  */ KEY_T,
+/* XK_U                   0x055  */ KEY_U,
+/* XK_V                   0x056  */ KEY_V,
+/* XK_W                   0x057  */ KEY_W,
+/* XK_X                   0x058  */ KEY_X,
+/* XK_Y                   0x059  */ KEY_Y,
+/* XK_Z                   0x05a  */ KEY_Z,
+/* XK_bracketleft         0x05b  */ KEY_OPENBRACE,
+/* XK_backslash           0x05c  */ KEY_BACKSLASH,
+/* XK_bracketright        0x05d  */ KEY_CLOSEBRACE,
+/* XK_asciicircum         0x05e  */ KEY_TILDE,
+/* XK_underscore          0x05f  */ KEY_MINUS,
+/* XK_grave               0x060  */ KEY_TILDE, /* keyboard dependent */
+/* XK_quoteleft           0x060  duplicated */
+/* XK_a                   0x061  */ KEY_A,
+/* XK_b                   0x062  */ KEY_B,
+/* XK_c                   0x063  */ KEY_C,
+/* XK_d                   0x064  */ KEY_D,
+/* XK_e                   0x065  */ KEY_E,
+/* XK_f                   0x066  */ KEY_F,
+/* XK_g                   0x067  */ KEY_G,
+/* XK_h                   0x068  */ KEY_H,
+/* XK_i                   0x069  */ KEY_I,
+/* XK_j                   0x06a  */ KEY_J,
+/* XK_k                   0x06b  */ KEY_K,
+/* XK_l                   0x06c  */ KEY_L,
+/* XK_m                   0x06d  */ KEY_M,
+/* XK_n                   0x06e  */ KEY_N,
+/* XK_o                   0x06f  */ KEY_O,
+/* XK_p                   0x070  */ KEY_P,
+/* XK_q                   0x071  */ KEY_Q,
+/* XK_r                   0x072  */ KEY_R,
+/* XK_s                   0x073  */ KEY_S,
+/* XK_t                   0x074  */ KEY_T,
+/* XK_u                   0x075  */ KEY_U,
+/* XK_v                   0x076  */ KEY_V,
+/* XK_w                   0x077  */ KEY_W,
+/* XK_x                   0x078  */ KEY_X,
+/* XK_y                   0x079  */ KEY_Y,
+/* XK_z                   0x07a  */ KEY_Z,
+/* XK_braceleft           0x07b  */ KEY_OPENBRACE,
+/* XK_bar                 0x07c  */ KEY_NONE,
+/* XK_braceright          0x07d  */ KEY_CLOSEBRACE,
+/* XK_asciitilde          0x07e  */ KEY_TILDE,
+/*                        0x07f  */ KEY_NONE,
+/* 			  0x080  */ KEY_NONE,
+/* 			  0x081  */ KEY_NONE,
+/* 			  0x082  */ KEY_NONE,
+/* 			  0x083  */ KEY_NONE,
+/* 			  0x084  */ KEY_NONE,
+/* 			  0x085  */ KEY_NONE,
+/* 			  0x086  */ KEY_NONE,
+/* 			  0x087  */ KEY_NONE,
+/* 			  0x088  */ KEY_NONE,
+/* 			  0x089  */ KEY_NONE,
+/* 			  0x08a  */ KEY_NONE,
+/* 			  0x08b  */ KEY_NONE,
+/* 			  0x08c  */ KEY_NONE,
+/* 			  0x08d  */ KEY_NONE,
+/* 			  0x08e  */ KEY_NONE,
+/* 			  0x08f  */ KEY_NONE,
+/* 			  0x090  */ KEY_NONE,
+/* 			  0x091  */ KEY_NONE,
+/* 			  0x092  */ KEY_NONE,
+/* 			  0x093  */ KEY_NONE,
+/* 			  0x094  */ KEY_NONE,
+/* 			  0x095  */ KEY_NONE,
+/* 			  0x096  */ KEY_NONE,
+/* 			  0x097  */ KEY_NONE,
+/* 			  0x098  */ KEY_NONE,
+/* 			  0x099  */ KEY_NONE,
+/* 			  0x09a  */ KEY_NONE,
+/* 			  0x09b  */ KEY_NONE,
+/* 			  0x09c  */ KEY_NONE,
+/* 			  0x09d  */ KEY_NONE,
+/* 			  0x09e  */ KEY_NONE,
+/* 			  0x09f  */ KEY_NONE,
+/* XK_nobreakspace        0x0a0  */ KEY_NONE,
+/* XK_exclamdown          0x0a1  */ KEY_EQUALS, /* keyboard dependent */
+/* XK_cent                0x0a2  */ KEY_NONE,
+/* XK_sterling            0x0a3  */ KEY_NONE,
+/* XK_currency            0x0a4  */ KEY_NONE,
+/* XK_yen                 0x0a5  */ KEY_NONE,
+/* XK_brokenbar           0x0a6  */ KEY_NONE,
+/* XK_section             0x0a7  */ KEY_TILDE,
+/* XK_diaeresis           0x0a8  */ KEY_NONE,
+/* XK_copyright           0x0a9  */ KEY_NONE,
+/* XK_ordfeminine         0x0aa  */ KEY_NONE,
+/* XK_guillemotleft       0x0ab  */ KEY_NONE,
+/* XK_notsign             0x0ac  */ KEY_NONE,
+/* XK_hyphen              0x0ad  */ KEY_NONE,
+/* XK_registered          0x0ae  */ KEY_NONE,
+/* XK_macron              0x0af  */ KEY_NONE,
+/* XK_degree              0x0b0  */ KEY_NONE,
+/* XK_plusminus           0x0b1  */ KEY_NONE,
+/* XK_twosuperior         0x0b2  */ KEY_NONE,
+/* XK_treesuperior        0x0b3  */ KEY_NONE,
+/* XK_acute               0x0b4  */ KEY_QUOTE, /* keyboard dependent */
+/* XK_mu                  0x0b5  */ KEY_NONE,
+/* XK_paragraph           0x0b6  */ KEY_NONE,
+/* XK_periodcentered      0x0b7  */ KEY_NONE,
+/* XK_cedilla             0x0b8  */ KEY_NONE,
+/* XK_onesuperior         0x0b9  */ KEY_NONE,
+/* XK_masculine           0x0ba  */ KEY_NONE,
+/* XK_guillemotright      0x0bb  */ KEY_NONE,
+/* XK_onequarter          0x0bc  */ KEY_NONE,
+/* XK_onehalf             0x0bd  */ KEY_NONE,
+/* XK_threequarters       0x0be  */ KEY_NONE,
+/* XK_questiondown        0x0bf  */ KEY_NONE,
+/* XK_Agrave              0x0c0  */ KEY_NONE,
+/* XK_Aacute              0x0c1  */ KEY_NONE,
+/* XK_Acircumflex         0x0c2  */ KEY_NONE,
+/* XK_Atilde              0x0c3  */ KEY_NONE,
+/* XK_Adiaeresis          0x0c4  */ KEY_NONE,
+/* XK_Aring               0x0c5  */ KEY_NONE,
+/* XK_AE                  0x0c6  */ KEY_NONE,
+/* XK_Ccedilla            0x0c7  */ KEY_NONE,
+/* XK_Egrave              0x0c8  */ KEY_NONE,
+/* XK_Eacute              0x0c9  */ KEY_NONE,
+/* XK_Ecircumflex         0x0ca  */ KEY_NONE,
+/* XK_Ediaeresis          0x0cb  */ KEY_NONE,
+/* XK_Igrave              0x0cc  */ KEY_NONE,
+/* XK_Iacute              0x0cd  */ KEY_NONE,
+/* XK_Icircumflex         0x0ce  */ KEY_NONE,
+/* XK_Idiaeresis          0x0cf  */ KEY_NONE,
+/* XK_ETH                 0x0d0  */ KEY_NONE,
+/* XK_Eth                 0x0d0  duplicated */
+/* XK_Ntilde              0x0d1  */ KEY_NONE,
+/* XK_Ograve              0x0d2  */ KEY_NONE,
+/* XK_Oacute              0x0d3  */ KEY_NONE,
+/* XK_Ocircumflex         0x0d4  */ KEY_NONE,
+/* XK_Otilde              0x0d5  */ KEY_NONE,
+/* XK_Odiaeresis          0x0d6  */ KEY_NONE,
+/* XK_multiply            0x0d7  */ KEY_NONE,
+/* XK_Ooblique            0x0d8  */ KEY_NONE,
+/* XK_Ugrave              0x0d9  */ KEY_NONE,
+/* XK_Uacute              0x0da  */ KEY_NONE,
+/* XK_Ucircumflex         0x0db  */ KEY_NONE,
+/* XK_Udiaeresis          0x0dc  */ KEY_NONE,
+/* XK_Yacute              0x0dd  */ KEY_NONE,
+/* XK_THORN               0x0de  */ KEY_NONE,
+/* XK_Thorn               0x0de  duplicated */
+/* XK_ssharp              0x0df  */ KEY_NONE,
+/* XK_agrave              0x0e0  */ KEY_NONE,
+/* XK_aacute              0x0e1  */ KEY_NONE,
+/* XK_acircumflex         0x0e2  */ KEY_NONE,
+/* XK_atilde              0x0e3  */ KEY_NONE,
+/* XK_adiaeresis          0x0e4  */ KEY_NONE,
+/* XK_aring               0x0e5  */ KEY_NONE,
+/* XK_ae                  0x0e6  */ KEY_NONE,
+/* XK_ccedilla            0x0e7  */ KEY_SLASH, /* keyboard dependent */
+/* XK_egrave              0x0e8  */ KEY_NONE,
+/* XK_eacute              0x0e9  */ KEY_NONE,
+/* XK_ecircumflex         0x0ea  */ KEY_NONE,
+/* XK_ediaeresis          0x0eb  */ KEY_NONE,
+/* XK_igrave              0x0ec  */ KEY_NONE,
+/* XK_iacute              0x0ed  */ KEY_NONE,
+/* XK_icircumflex         0x0ee  */ KEY_NONE,
+/* XK_idiaeresis          0x0ef  */ KEY_NONE,
+/* XK_eth                 0x0f0  */ KEY_NONE,
+/* XK_ntilde              0x0f1  */ KEY_COLON, /* keyboard dependent */
+/* XK_ograve              0x0f2  */ KEY_NONE,
+/* XK_oacute              0x0f3  */ KEY_NONE,
+/* XK_ocircumflex         0x0f4  */ KEY_NONE,
+/* XK_otilde              0x0f5  */ KEY_NONE,
+/* XK_odiaeresis          0x0f6  */ KEY_NONE,
+/* XK_division            0x0f7  */ KEY_NONE,
+/* XK_oslash              0x0f8  */ KEY_NONE,
+/* XK_ugrave              0x0f9  */ KEY_NONE,
+/* XK_uacute              0x0fa  */ KEY_NONE,
+/* XK_ucircumflex         0x0fb  */ KEY_NONE,
+/* XK_udiaeresis          0x0fc  */ KEY_NONE,
+/* XK_yacute              0x0fd  */ KEY_NONE,
+/* XK_thorn               0x0fe  */ KEY_NONE,
+/* XK_ydiaeresis          0x0ff  */ KEY_NONE
+
+}; /* code_table */
diff --git a/src/unix/video.c b/src/unix/video.c
new file mode 100644
index 0000000..5279608
--- /dev/null
+++ b/src/unix/video.c
@@ -0,0 +1,1169 @@
+/*
+ * X-Mame generic video code
+ *
+ */
+#define __VIDEO_C_
+#include <math.h>
+#include "xmame.h"
+
+#ifdef xgl
+#include "video-drivers/glmame.h"
+#endif
+#include <stdio.h>
+#include "driver.h"
+#include "profiler.h"
+#include "input.h"
+#include "keyboard.h"
+/* for uclock */
+#include "sysdep/misc.h"
+#include "effect.h"
+
+#define FRAMESKIP_DRIVER_COUNT 2
+static const int safety = 16;
+int normal_widthscale = 1, normal_heightscale = 1;
+int yarbsize = 0;
+static char *vector_res = NULL;
+static int use_auto_double = 1;
+static int frameskipper = 0;
+static int bitmap_depth;
+static int using_15bpp_rgb_direct;
+static int debugger_has_focus = 0;
+static struct rectangle normal_visual;
+static struct rectangle debug_visual;
+
+static float f_beam;
+static float f_flicker;
+static float f_intensity;
+
+static int use_artwork = 1;
+static int use_backdrops = -1;
+static int use_overlays = -1;
+static int use_bezels = -1;
+
+static int video_norotate = 0;
+static int video_flipy = 0;
+static int video_flipx = 0;
+static int video_ror = 0;
+static int video_rol = 0;
+static int video_autoror = 0;
+static int video_autorol = 0;
+
+/* average FPS calculation */
+static cycles_t start_time = 0;
+static cycles_t end_time;
+static int frames_displayed;
+static int frames_to_display;
+
+#if (defined svgafx) || (defined xfx) 
+UINT16 *color_values;
+#endif
+
+int force_dirty_palette = 0;
+int emulation_paused = 0;
+
+extern UINT8 trying_to_quit;
+
+/* some prototypes */
+static int video_handle_scale(struct rc_option *option, const char *arg,
+		int priority);
+static int video_verify_beam(struct rc_option *option, const char *arg,
+		int priority);
+static int video_verify_flicker(struct rc_option *option, const char *arg,
+		int priority);
+static int video_verify_intensity(struct rc_option *option, const char *arg,
+		int priority);
+static int video_verify_bpp(struct rc_option *option, const char *arg,
+		int priority);
+static int video_verify_vectorres(struct rc_option *option, const char *arg,
+		int priority);
+
+#ifndef xgl
+static void adjust_bitmap_and_update_display(struct mame_bitmap *srcbitmap,
+		struct rectangle bounds);
+#endif
+
+static void change_debugger_focus(int new_debugger_focus);
+static void update_debug_display(struct mame_display *display);
+static void osd_free_colors(void);
+static void round_rectangle_to_8(struct rectangle *rect);
+static void update_visible_area(struct mame_display *display);
+static void update_palette(struct mame_display *display, int force_dirty);
+
+struct rc_option video_opts[] = {
+   /* name, shortname, type, dest, deflt, min, max, func, help */
+   { "Video Related",	NULL,			rc_seperator,	NULL,
+     NULL,		0,			0,		NULL,
+     NULL },
+   { "bpp",		"b",			rc_int,		&options.color_depth,
+     "0",		0,			0,		video_verify_bpp,
+     "Specify the colordepth the core should render, one of: auto(0), 8, 16" },
+   { "arbheight",	"ah",			rc_int,		&yarbsize,
+     "0",		0,			4096,		NULL,
+     "Scale video to exactly this height (0 = disable)" },
+   { "heightscale",	"hs",			rc_int,		&normal_heightscale,
+     "1",		1,			8,		NULL,
+     "Set Y-Scale aspect ratio" },
+   { "widthscale",	"ws",			rc_int,		&normal_widthscale,
+     "1",		1,			8,		NULL,
+     "Set X-Scale aspect ratio" },
+   { "scale",		"s",			rc_use_function, NULL,
+     NULL,		0,			0,		video_handle_scale,
+     "Set X-Y Scale to the same aspect ratio. For vector games scale (and also width- and heightscale) may have value's like 1.5 and even 0.5. For scaling of regular games this will be rounded to an int" },
+   { "effect",		"ef",			rc_int,		&effect,
+     EFFECT_NONE,	EFFECT_NONE,		EFFECT_LAST,	NULL,
+     "Video effect:\n"
+	     "0 = none (default)\n"
+	     "1 = scale2x (smooth scaling effect)\n"
+	     "2 = scan2 (light scanlines)\n"
+	     "3 = rgbstripe (3x2 rgb vertical stripes)\n"
+	     "4 = rgbscan (2x3 rgb horizontal scanlines)\n"
+	     "5 = scan3 (3x3 deluxe scanlines)\n" },
+   { "autodouble",	"adb",			rc_bool,	&use_auto_double,
+     "1",		0,			0,		NULL,
+     "Enable/disable automatic scale doubling for 1:2 pixel aspect ratio games" },
+   { "scanlines",	"sl",			rc_bool,	&use_scanlines,
+     "0",		0,			0,		NULL,
+     "Enable/disable displaying simulated scanlines" },
+   { "artwork",		"art",			rc_bool,	&use_artwork,
+     "1",		0,			0,		NULL,
+     "Use additional game artwork (sets default for specific options below)" },
+   { "use_backdrops",	"backdrop",		rc_bool,	&use_backdrops,
+     "1",		0,			0,		NULL,
+     "Use backdrop artwork" },
+   { "use_overlays",	"overlay",		rc_bool,	&use_overlays,
+     "1",		0,			0,		NULL,
+     "Use overlay artwork" },
+   { "use_bezels",	"bezel",		rc_bool,	&use_bezels,
+     "1",		0,			0,		NULL,
+     "Use bezel artwork" },
+   { "artwork_crop",	"artcrop",		rc_bool,	&options.artwork_crop,
+     "0",		0,			0,		NULL,
+     "Crop artwork to game screen only." },
+   { "artwork_resolution","artres",		rc_int,		&options.artwork_res,
+     "0",		0,			0,		NULL,
+     "Artwork resolution (0 for auto)" },
+   { "frameskipper",	"fsr",			rc_int,		&frameskipper,
+     "1",		0,			FRAMESKIP_DRIVER_COUNT-1, NULL,
+     "Select which autoframeskip and throttle routines to use. Available choices are:\n0 Dos frameskip code\n1 Enhanced frameskip code by William A. Barath" },
+   { "throttle",	"th",			rc_bool,	&throttle,
+     "1",		0,			0,		NULL,
+     "Enable/disable throttle" },
+   { "frames_to_run",	"ftr",			rc_int,		&frames_to_display,
+     "0",		0,			0,		NULL,
+     "Sets the number of frames to run within the game" },
+   { "sleepidle",	"si",			rc_bool,	&sleep_idle,
+     "0",		0,			0,		NULL,
+     "Enable/disable sleep during idle" },
+   { "autoframeskip",	"afs",			rc_bool,	&autoframeskip,
+     "1",		0,			0,		NULL,
+     "Enable/disable autoframeskip" },
+   { "maxautoframeskip", "mafs",		rc_int,		&max_autoframeskip,
+     "8",		0,			FRAMESKIP_LEVELS-1, NULL,
+     "Set highest allowed frameskip for autoframeskip" },
+   { "frameskip",	"fs",			rc_int,		&frameskip,
+     "0",		0,			FRAMESKIP_LEVELS-1, NULL,
+     "Set frameskip when not using autoframeskip" },
+   { "brightness",	"brt",			rc_float,	&options.brightness,
+     "1.0",		0.5,			2.0,		NULL,
+     "Set the brightness correction (0.5 - 2.0)" },
+   { "pause_brightness","pb",			rc_float,	&options.pause_bright,
+     "0.65",		0.5,			2.0,		NULL,
+     "Additional pause brightness" },
+   { "gamma",		"gc",			rc_float,	&options.gamma,
+     "1.0",		0.5,			2.0,		NULL,
+     "Set the gamma correction (0.5 - 2.0)" },
+   { "norotate",	"nr",			rc_bool,	&video_norotate,
+     "0",		0,			0,		NULL,
+     "Do not apply rotation" },
+   { "ror",		"rr",			rc_bool,	&video_ror,
+     "0",		0,			0,		NULL,
+     "Rotate screen clockwise" },
+   { "rol",		"rl",			rc_bool,	&video_rol,
+     "0",		0,			0,		NULL,
+     "Rotate screen counter-clockwise" },
+   { "autoror",		NULL,			rc_bool,	&video_autoror,
+     "0",		0,			0,		NULL,
+     "Automatically rotate screen clockwise for vertical games" },
+   { "autorol",		NULL,			rc_bool,	&video_autorol,
+     "0",		0,			0,		NULL,
+     "Automatically rotate screen counter-clockwise for vertical games" },
+   { "flipx",		"fx",			rc_bool,	&video_flipx,
+     "0",		0,			0,		NULL,
+     "Flip screen left-right" },
+   { "flipy",		"fy",			rc_bool,	&video_flipy,
+     "0",		0,			0,		NULL,
+     "Flip screen upside-down" },
+   { "Vector Games Related", NULL,		rc_seperator,	NULL,
+     NULL,		0,			0,		NULL,
+     NULL },
+   { "vectorres",	"vres",			rc_string,	&vector_res,
+     NULL,		0,			0,		video_verify_vectorres,
+     "Always scale vectorgames to XresxYres, keeping their aspect ratio. This overrides the scale options" },
+	{ "beam", "B", rc_float, &f_beam, "1.0", 1.0, 16.0, video_verify_beam, "Set the beam size for vector games" },
+	{ "flicker", "f", rc_float, &f_flicker, "0.0", 0.0, 100.0, video_verify_flicker, "Set the flicker for vector games" },
+	{ "intensity", NULL, rc_float, &f_intensity, "1.5", 0.5, 3.0, video_verify_intensity, "Set intensity in vector games" },
+   { "antialias",	"aa",			rc_bool,	&options.antialias,
+     "1",		0,			0,		NULL,
+     "Enable/disable antialiasing" },
+   { "translucency",	"t",			rc_bool,	&options.translucency,
+     "1",		0,			0,		NULL,
+     "Enable/disable tranlucency" },
+   { NULL,		NULL,			rc_link,	display_opts,
+     NULL,		0,			0,		NULL,
+     NULL },
+   { NULL, NULL, rc_end, NULL, NULL, 0, 0, NULL, NULL }
+};
+
+static int video_handle_scale(struct rc_option *option, const char *arg,
+   int priority)
+{
+	if (rc_set_option2(video_opts, "widthscale", arg, priority))
+		return -1;
+	if (rc_set_option2(video_opts, "heightscale", arg, priority))
+		return -1;
+
+	option->priority = priority;
+
+	return 0;
+}
+
+static int video_verify_beam(struct rc_option *option, const char *arg,
+		int priority)
+{
+	options.beam = (int)(f_beam * 0x00010000);
+	if (options.beam < 0x00010000)
+		options.beam = 0x00010000;
+	else if (options.beam > 0x00100000)
+		options.beam = 0x00100000;
+
+	option->priority = priority;
+
+	return 0;
+}
+
+static int video_verify_flicker(struct rc_option *option, const char *arg,
+		int priority)
+{
+	options.vector_flicker = (int)(f_flicker * 2.55);
+	if (options.vector_flicker < 0)
+		options.vector_flicker = 0;
+	else if (options.vector_flicker > 255)
+		options.vector_flicker = 255;
+
+	option->priority = priority;
+
+	return 0;
+}
+
+static int video_verify_intensity(struct rc_option *option, const char *arg,
+		int priority)
+{
+	options.vector_intensity = f_intensity;
+	option->priority = priority;
+	return 0;
+}
+
+static int video_verify_bpp(struct rc_option *option, const char *arg,
+   int priority)
+{
+	if (options.color_depth != 0
+			&& options.color_depth != 8
+			&& options.color_depth != 15
+			&& options.color_depth != 16
+			&& options.color_depth != 32)
+	{
+		options.color_depth = 0;
+		fprintf(stderr, "error: invalid value for bpp: %s\n", arg);
+		return -1;
+	}
+
+	option->priority = priority;
+
+	return 0;
+}
+
+static int video_verify_vectorres(struct rc_option *option, const char *arg,
+   int priority)
+{
+	if (sscanf(arg, "%dx%d", &options.vector_width, &options.vector_height) != 2)
+	{
+		options.vector_width = options.vector_height = 0;
+		fprintf(stderr, "error: invalid value for vectorres: %s\n", arg);
+		return -1;
+	}
+
+	option->priority = priority;
+
+	return 0;
+}
+
+void osd_video_initpre()
+{
+	/* first start with the game's built-in orientation */
+	int orientation = drivers[game_index]->flags & ORIENTATION_MASK;
+	options.ui_orientation = orientation;
+
+	if (options.ui_orientation & ORIENTATION_SWAP_XY)
+	{
+		/* if only one of the components is inverted, switch them */
+		if ((options.ui_orientation & ROT180) == ORIENTATION_FLIP_X ||
+				(options.ui_orientation & ROT180) == ORIENTATION_FLIP_Y)
+			options.ui_orientation ^= ROT180;
+	}
+
+	/* override if no rotation requested */
+	if (video_norotate)
+		orientation = options.ui_orientation = ROT0;
+
+	/* rotate right */
+	if (video_ror)
+	{
+		/* if only one of the components is inverted, switch them */
+		if ((orientation & ROT180) == ORIENTATION_FLIP_X ||
+				(orientation & ROT180) == ORIENTATION_FLIP_Y)
+			orientation ^= ROT180;
+
+		orientation ^= ROT90;
+	}
+
+	/* rotate left */
+	if (video_rol)
+	{
+		/* if only one of the components is inverted, switch them */
+		if ((orientation & ROT180) == ORIENTATION_FLIP_X ||
+				(orientation & ROT180) == ORIENTATION_FLIP_Y)
+			orientation ^= ROT180;
+
+		orientation ^= ROT270;
+	}
+
+	/* auto-rotate right (e.g. for rotating lcds), based on original orientation */
+	if (video_autoror && (drivers[game_index]->flags & ORIENTATION_SWAP_XY))
+	{
+		/* if only one of the components is inverted, switch them */
+		if ((orientation & ROT180) == ORIENTATION_FLIP_X ||
+				(orientation & ROT180) == ORIENTATION_FLIP_Y)
+			orientation ^= ROT180;
+
+		orientation ^= ROT90;
+	}
+
+	/* auto-rotate left (e.g. for rotating lcds), based on original orientation */
+	if (video_autorol && (drivers[game_index]->flags & ORIENTATION_SWAP_XY))
+	{
+		/* if only one of the components is inverted, switch them */
+		if ((orientation & ROT180) == ORIENTATION_FLIP_X ||
+				(orientation & ROT180) == ORIENTATION_FLIP_Y)
+			orientation ^= ROT180;
+
+		orientation ^= ROT270;
+	}
+
+	/* flip X/Y */
+	if (video_flipx)
+		orientation ^= ORIENTATION_FLIP_X;
+	if (video_flipy)
+		orientation ^= ORIENTATION_FLIP_Y;
+
+	blit_flipx = ((orientation & ORIENTATION_FLIP_X) != 0);
+	blit_flipy = ((orientation & ORIENTATION_FLIP_Y) != 0);
+	blit_swapxy = ((orientation & ORIENTATION_SWAP_XY) != 0);
+
+	if (options.vector_width == 0 && options.vector_height == 0)
+	{
+		options.vector_width = 640;
+		options.vector_height = 480;
+	}
+
+	if (blit_swapxy)
+	{
+		int temp;
+		temp = options.vector_width;
+		options.vector_width = options.vector_height;
+		options.vector_height = temp;
+	}
+
+
+	/* set the artwork options */
+	options.use_artwork = ARTWORK_USE_ALL;
+	if (use_backdrops == 0)
+		options.use_artwork &= ~ARTWORK_USE_BACKDROPS;
+	if (use_overlays == 0)
+		options.use_artwork &= ~ARTWORK_USE_OVERLAYS;
+	if (use_bezels == 0)
+		options.use_artwork &= ~ARTWORK_USE_BEZELS;
+	if (!use_artwork)
+		options.use_artwork = ARTWORK_USE_NONE;
+}
+
+void orient_rect(struct rectangle *rect)
+{
+	int temp;
+
+	/* apply X/Y swap first */
+	if (blit_swapxy)
+	{
+		temp = rect->min_x;
+		rect->min_x = rect->min_y;
+		rect->min_y = temp;
+
+		temp = rect->max_x;
+		rect->max_x = rect->max_y;
+		rect->max_y = temp;
+	}
+
+	/* apply X flip */
+	if (blit_flipx)
+	{
+		temp = video_width - rect->min_x - 1;
+		rect->min_x = video_width - rect->max_x - 1;
+		rect->max_x = temp;
+	}
+
+	/* apply Y flip */
+	if (blit_flipy)
+	{
+		temp = video_height - rect->min_y - 1;
+		rect->min_y = video_height - rect->max_y - 1;
+		rect->max_y = temp;
+	}
+}
+
+int osd_create_display(const struct osd_create_params *params, 
+		UINT32 *rgb_components)
+{
+	int r, g, b;
+
+	bitmap_depth = (params->depth == 15) ? 16 : params->depth;
+	using_15bpp_rgb_direct = (params->depth == 15);
+
+	current_palette = normal_palette = NULL;
+	debug_visual.min_x = 0;
+	debug_visual.max_x = options.debug_width - 1;
+	debug_visual.min_y = 0;
+	debug_visual.max_y = options.debug_height - 1;
+
+	if (use_auto_double)
+	{
+		if ((params->video_attributes & VIDEO_PIXEL_ASPECT_RATIO_MASK) 
+				== VIDEO_PIXEL_ASPECT_RATIO_1_2)
+		{
+			if (params->orientation & ORIENTATION_SWAP_XY)
+				normal_widthscale *= 2;
+			else
+				normal_heightscale *= 2;
+		}
+
+		if ((params->video_attributes & VIDEO_PIXEL_ASPECT_RATIO_MASK) 
+				== VIDEO_PIXEL_ASPECT_RATIO_2_1)
+		{
+			if (params->orientation & ORIENTATION_SWAP_XY)
+				normal_heightscale *= 2;
+			else
+				normal_widthscale *= 2;
+		}
+	}
+
+#ifndef xgl
+	if (blit_swapxy)
+	{
+		visual_width	= video_width	= params->height;
+		visual_height	= video_height	= params->width;
+	}
+	else
+	{
+#endif
+		visual_width	= video_width	= params->width;
+		visual_height	= video_height	= params->height;
+#ifndef xgl
+	}
+#endif
+	video_depth = (params->depth == 15) ? 16 : params->depth;
+
+	if (!blit_swapxy)
+		aspect_ratio = (double)params->aspect_x 
+			/ (double)params->aspect_y;
+	else
+		aspect_ratio = (double)params->aspect_y 
+			/ (double)params->aspect_x;
+
+	widthscale		= normal_widthscale;
+	heightscale		= normal_heightscale;
+	use_aspect_ratio	= normal_use_aspect_ratio;
+	video_fps		= params->fps;
+
+	if (sysdep_create_display(bitmap_depth) != OSD_OK)
+		return -1;
+
+#if 0 /* DEBUG */
+	fprintf(stderr_file, "viswidth = %d, visheight = %d, visstartx= %d,"
+			"visstarty= %d\n", visual_width, visual_height,
+			visual.min_x, visual.min_y);
+#endif
+
+	/* a lot of display_targets need to have the display initialised before
+	   initialising any input devices */
+	if (osd_input_initpost() != OSD_OK)
+		return -1;
+
+	if (bitmap_depth == 16)
+		fprintf(stderr_file,"Using 16bpp video mode\n");
+
+	if (!(normal_palette = sysdep_palette_create(bitmap_depth, 65536)))
+		return 1;
+
+	/* alloc the total number of colors that can be used by the palette */
+	if (sysdep_display_alloc_palette(65536))
+	{
+		osd_free_colors();
+		return 1;
+	}
+
+	/* initialize the palette to a fixed 5-5-5 mapping */
+	if (using_15bpp_rgb_direct)
+	{
+		for (r = 0; r < 32; r++)
+			for (g = 0; g < 32; g++)
+				for (b = 0; b < 32; b++)
+				{
+					int idx = (r << 10) | (g << 5) | b;
+					sysdep_palette_set_pen(normal_palette,
+							idx,
+							(r << 3) | (r >> 2),
+							(g << 3) | (g >> 2),
+							(b << 3) | (b >> 2));
+				}
+	}
+	else
+	{
+		for (r = 0; r < 32; r++)
+			for (g = 0; g < 32; g++)
+				for (b = 0; b < 32; b++)
+				{
+					int idx = (r << 10) | (g << 5) | b;
+					sysdep_palette_set_pen(normal_palette,
+							idx, r, g, b);
+				}
+	}
+
+	current_palette = normal_palette;
+
+	/*
+	 * Mark the palette dirty for Xv when running certain NeoGeo games.
+	 */
+	sysdep_palette_mark_dirty(normal_palette);
+
+	/* fill in the resulting RGB components */
+	if (rgb_components)
+	{
+		if (bitmap_depth == 32)
+		{
+			rgb_components[0] = (0xff << 16) | (0x00 << 8) | 0x00;
+			rgb_components[1] = (0x00 << 16) | (0xff << 8) | 0x00;
+			rgb_components[2] = (0x00 << 16) | (0x00 << 8) | 0xff;
+		}
+		else
+		{
+			rgb_components[0] = 0x7c00;
+			rgb_components[1] = 0x03e0;
+			rgb_components[2] = 0x001f;
+		}
+	}
+
+	return 0;
+}
+
+void osd_close_display(void)
+{
+	osd_free_colors();
+	sysdep_display_close();
+
+	/* print a final result to the stdout */
+	if (frames_displayed != 0)
+	{
+		cycles_t cps = osd_cycles_per_second();
+		fprintf(stderr_file, "Average FPS: %f (%d frames)\n", (double)cps / (end_time - start_time) * frames_displayed, frames_displayed);
+	}
+}
+
+static void osd_change_display_settings(struct rectangle *new_visual,
+		struct sysdep_palette_struct *new_palette, int new_widthscale,
+		int new_heightscale, int new_use_aspect_ratio)
+{
+	int new_visual_width, new_visual_height;
+
+	/* always update the visual info */
+	visual = *new_visual;
+
+	/* calculate the new visual width / height */
+	new_visual_width  = visual.max_x - visual.min_x + 1;
+	new_visual_height = visual.max_y - visual.min_y + 1;
+
+	if (current_palette != new_palette)
+		current_palette = new_palette;
+
+	if (visual_width != new_visual_width
+			|| visual_height != new_visual_height
+			|| widthscale != new_widthscale
+			|| heightscale != new_heightscale
+			|| use_aspect_ratio != new_use_aspect_ratio)
+	{
+		sysdep_display_close();
+
+		visual_width     = new_visual_width;
+		visual_height    = new_visual_height;
+		widthscale       = new_widthscale;
+		heightscale      = new_heightscale;
+		use_aspect_ratio = new_use_aspect_ratio;
+
+		if (sysdep_create_display(bitmap_depth) != OSD_OK)
+		{
+			/* oops this sorta sucks */
+			fprintf(stderr_file, "Argh, resizing the display failed in osd_set_visible_area, aborting\n");
+			exit(1);
+		}
+
+		/* only realloc the palette if it has been initialised */
+		if (current_palette && sysdep_display_alloc_palette(video_colors_used))
+		{
+			/* better restore the video mode before calling exit() */
+			sysdep_display_close();
+			/* oops this sorta sucks */
+			fprintf(stderr_file, "Argh, (re)allocating the palette failed in osd_set_visible_area, aborting\n");
+			exit(1);
+		}
+
+		/* to stop keys from getting stuck */
+		xmame_keyboard_clear();
+
+#if 0 /* DEBUG */
+		fprintf(stderr_file, "viswidth = %d, visheight = %d,"
+				"visstartx= %d, visstarty= %d\n",
+				visual_width, visual_height, visual.min_x,
+				visual.min_y);
+#endif
+	}
+}
+
+static void round_rectangle_to_8(struct rectangle *rect)
+{
+	if (rect->min_x & 7)
+	{
+		if ((rect->min_x - (rect->min_x & ~7)) < 4)
+			rect->min_x &= ~7;
+		else
+			rect->min_x = (rect->min_x + 7) & ~7;
+	}
+
+	if ((rect->max_x + 1) & 7)
+	{
+		if (((rect->max_x + 1) - ((rect->max_x + 1) & ~7)) > 4)
+			rect->max_x = ((rect->max_x + 1 + 7) & ~7) - 1;
+		else
+			rect->max_x = ((rect->max_x + 1) & ~7) - 1;
+	}
+}
+
+static void update_visible_area(struct mame_display *display)
+{
+	normal_visual = display->game_visible_area;
+
+#ifndef xgl
+	if (blit_swapxy)
+	{
+		video_width = display->game_bitmap->height;
+		video_height = display->game_bitmap->width;
+	}
+	else
+	{
+		video_width = display->game_bitmap->width;
+		video_height = display->game_bitmap->height;
+	}
+
+	orient_rect(&normal_visual);
+#endif
+
+	/* 
+	 * round to 8, since the new dirty code works with 8x8 blocks,
+	 * and we need to round to sizeof(long) for the long copies anyway
+	 */
+	round_rectangle_to_8(&normal_visual);
+
+	if (!debugger_has_focus)
+		osd_change_display_settings(&normal_visual, normal_palette, 
+				normal_widthscale, normal_heightscale, 
+				normal_use_aspect_ratio);
+
+	set_ui_visarea(display->game_visible_area.min_x,
+			display->game_visible_area.min_y,
+			display->game_visible_area.max_x,
+			display->game_visible_area.max_y);
+}
+
+static void update_palette(struct mame_display *display, int force_dirty)
+{
+	int i, j;
+
+	sysdep_palette_clear_dirty(current_palette);
+	/* loop over dirty colors in batches of 32 */
+	for (i = 0; i < display->game_palette_entries; i += 32)
+	{
+		UINT32 dirtyflags = display->game_palette_dirty[i / 32];
+		if (dirtyflags || force_dirty)
+		{
+			display->game_palette_dirty[i / 32] = 0;
+
+			/* loop over all 32 bits and update dirty entries */
+			for (j = 0; (j < 32) && (i + j < display->game_palette_entries); j++, dirtyflags >>= 1)
+				if (((dirtyflags & 1) || force_dirty) && (i + j < display->game_palette_entries))
+				{
+					/* extract the RGB values */
+					rgb_t rgbvalue = display->game_palette[i + j];
+					int r = RGB_RED(rgbvalue);
+					int g = RGB_GREEN(rgbvalue);
+					int b = RGB_BLUE(rgbvalue);
+
+					sysdep_palette_set_pen(current_palette,
+							i + j, r, g, b);
+					sysdep_palette_mark_dirty(current_palette);
+				}
+		}
+	}
+}
+
+static void update_debug_display(struct mame_display *display)
+{
+	struct sysdep_palette_struct *backup_palette = current_palette;
+
+	if (!debug_palette)
+	{
+		int  i, r, g, b;
+		debug_palette = sysdep_palette_create(16, 65536);
+		/* Initialize the lookup table for the debug palette. */
+
+		for (i = 0; i < DEBUGGER_TOTAL_COLORS; i++)
+		{
+			/* extract the RGB values */
+			rgb_t rgbvalue = display->debug_palette[i];
+			r = RGB_RED(rgbvalue);
+			g = RGB_GREEN(rgbvalue);
+			b = RGB_BLUE(rgbvalue);
+
+			sysdep_palette_set_pen(debug_palette, 
+					i, r, g, b);
+		}
+	}
+
+	current_palette = debug_palette;
+	sysdep_update_display(display->debug_bitmap);
+	current_palette = backup_palette;
+}
+
+static void osd_free_colors(void)
+{
+	if (normal_palette)
+	{
+		sysdep_palette_destroy(normal_palette);
+		normal_palette = NULL;
+	}
+
+	if (debug_palette)
+	{
+		sysdep_palette_destroy(debug_palette);
+		debug_palette = NULL;
+	}
+}
+
+static int skip_next_frame = 0;
+
+typedef int (*skip_next_frame_func)(void);
+static skip_next_frame_func skip_next_frame_functions[FRAMESKIP_DRIVER_COUNT] =
+{
+	dos_skip_next_frame,
+	barath_skip_next_frame
+};
+
+typedef int (*show_fps_frame_func)(char *buffer);
+static show_fps_frame_func show_fps_frame_functions[FRAMESKIP_DRIVER_COUNT] =
+{
+	dos_show_fps,
+	barath_show_fps
+};
+
+int osd_skip_this_frame(void)
+{
+	return skip_next_frame;
+}
+
+int osd_get_frameskip(void)
+{
+	return autoframeskip ? -(frameskip + 1) : frameskip;
+}
+
+void change_debugger_focus(int new_debugger_focus)
+{
+	if ((!debugger_has_focus && new_debugger_focus)
+			|| (debugger_has_focus && !new_debugger_focus))
+	{
+		if (new_debugger_focus)
+			osd_change_display_settings(&debug_visual, debug_palette,
+					1, 1, 0);
+		else
+			osd_change_display_settings(&normal_visual, normal_palette,
+					normal_widthscale, normal_heightscale, normal_use_aspect_ratio);
+
+		debugger_has_focus = new_debugger_focus;
+	}
+}
+
+/* Update the display. */
+void osd_update_video_and_audio(struct mame_display *display)
+{
+	int skip_this_frame;
+	cycles_t curr;
+
+	updatebounds = display->game_bitmap_update;
+
+	/* increment frameskip? */
+	if (input_ui_pressed(IPT_UI_FRAMESKIP_INC))
+	{
+		/* if autoframeskip, disable auto and go to 0 */
+		if (autoframeskip)
+		{
+			autoframeskip = 0;
+			frameskip = 0;
+		}
+
+		/* wrap from maximum to auto */
+		else if (frameskip == FRAMESKIP_LEVELS - 1)
+		{
+			frameskip = 0;
+			autoframeskip = 1;
+		}
+
+		/* else just increment */
+		else
+			frameskip++;
+
+		/* display the FPS counter for 2 seconds */
+		ui_show_fps_temp(2.0);
+
+		/* reset the frame counter so we'll measure the average FPS on a consistent status */
+		frames_displayed = 0;
+	}
+
+	/* decrement frameskip? */
+	if (input_ui_pressed(IPT_UI_FRAMESKIP_DEC))
+	{
+		/* if autoframeskip, disable auto and go to max */
+		if (autoframeskip)
+		{
+			autoframeskip = 0;
+			frameskip = FRAMESKIP_LEVELS-1;
+		}
+
+		/* wrap from 0 to auto */
+		else if (frameskip == 0)
+			autoframeskip = 1;
+
+		/* else just decrement */
+		else
+			frameskip--;
+
+		/* display the FPS counter for 2 seconds */
+		ui_show_fps_temp(2.0);
+
+		/* reset the frame counter so we'll measure the average FPS on a consistent status */
+		frames_displayed = 0;
+	}
+
+	if (input_ui_pressed(IPT_UI_THROTTLE))
+	{
+		if (!keyboard_pressed(KEYCODE_LSHIFT)
+				&& !keyboard_pressed(KEYCODE_RSHIFT))
+		{
+			throttle ^= 1;
+
+			/*
+			 * reset the frame counter so we'll measure the average
+			 * FPS on a consistent status
+			 */
+			frames_displayed = 0;
+		}
+		else if (keyboard_pressed(KEYCODE_RSHIFT)
+				|| keyboard_pressed(KEYCODE_LSHIFT))
+			sleep_idle ^= 1;
+	}
+
+	if (keyboard_pressed(KEYCODE_LCONTROL))
+	{ 
+		if (keyboard_pressed_memory(KEYCODE_INSERT))
+			frameskipper = 0;
+		if (keyboard_pressed_memory(KEYCODE_HOME))
+			frameskipper = 1;
+	}
+
+	if (keyboard_pressed(KEYCODE_LSHIFT))
+	{
+		int widthscale_mod  = 0;
+		int heightscale_mod = 0;
+
+		if (keyboard_pressed_memory(KEYCODE_INSERT))
+			widthscale_mod = 1;
+		if (keyboard_pressed_memory(KEYCODE_DEL))
+			widthscale_mod = -1;
+		if (keyboard_pressed_memory(KEYCODE_HOME))
+			heightscale_mod = 1;
+		if (keyboard_pressed_memory(KEYCODE_END))
+			heightscale_mod = -1;
+		if (keyboard_pressed_memory(KEYCODE_PGUP))
+		{
+			widthscale_mod  = 1;
+			heightscale_mod = 1;
+		}
+		if (keyboard_pressed_memory (KEYCODE_PGDN))
+		{
+			widthscale_mod  = -1;
+			heightscale_mod = -1;
+		}
+		if (widthscale_mod || heightscale_mod)
+		{
+			normal_widthscale  += widthscale_mod;
+			normal_heightscale += heightscale_mod;
+
+			if (normal_widthscale > 8)
+				normal_widthscale = 8;
+			else if (normal_widthscale < 1)
+				normal_widthscale = 1;
+
+			if (normal_heightscale > 8)
+				normal_heightscale = 8;
+			else if (normal_heightscale < 1)
+				normal_heightscale = 1;
+
+			if (!debugger_has_focus)
+				osd_change_display_settings(&normal_visual,
+						normal_palette,
+						normal_widthscale,
+						normal_heightscale,
+						normal_use_aspect_ratio);
+		}
+	}
+
+	skip_this_frame = skip_next_frame;
+	skip_next_frame = (*skip_next_frame_functions[frameskipper])();
+
+	if (sound_stream && sound_enabled)
+		sound_stream_update(sound_stream);
+
+	/* if the visible area has changed, update it */
+	if (display->changed_flags & GAME_VISIBLE_AREA_CHANGED)
+		update_visible_area(display);
+
+	/* if the debugger focus changed, update it */
+	if (display->changed_flags & DEBUG_FOCUS_CHANGED)
+		change_debugger_focus(display->debug_focus);
+
+	/*
+	 * If the user presses the F5 key, toggle the debugger's 
+	 * focus.  Eventually I'd like to just display both the 
+	 * debug and regular windows at the same time.
+	 */
+	else if (input_ui_pressed(IPT_UI_TOGGLE_DEBUG) && mame_debug)
+		change_debugger_focus(!debugger_has_focus);
+
+	/* update the debugger */
+	if ((display->changed_flags & DEBUG_BITMAP_CHANGED)
+			&& debugger_has_focus)
+		update_debug_display(display);
+
+	/* if the game palette has changed, update it */
+	if (force_dirty_palette)
+	{
+		update_palette(display, 1);
+		force_dirty_palette = 0;
+	}
+	else if (display->changed_flags & GAME_PALETTE_CHANGED)
+		update_palette(display, 0);
+
+	if (skip_this_frame == 0
+			&& (display->changed_flags & GAME_BITMAP_CHANGED)
+			&& !debugger_has_focus)
+	{
+		/* at the end, we need the current time */
+		curr = osd_cycles();
+
+		/* update stats for the FPS average calculation */
+		if (start_time == 0)
+		{
+			/* start the timer going 1 second into the game */
+			if (timer_get_time() > 1.0)
+				start_time = curr;
+		}
+		else
+		{
+			frames_displayed++;
+			if (frames_displayed + 1 == frames_to_display)
+				trying_to_quit = 1;
+			end_time = curr;
+		}
+
+		profiler_mark(PROFILER_BLIT);
+#ifdef xgl
+		sysdep_update_display(display->game_bitmap);
+#else
+		adjust_bitmap_and_update_display(display->game_bitmap,
+				updatebounds);
+#endif
+		profiler_mark(PROFILER_END);
+	}
+
+	/* if the LEDs have changed, update them */
+	if (display->changed_flags & LED_STATE_CHANGED)
+		sysdep_set_leds(display->led_state);
+
+	osd_poll_joysticks();
+}
+
+#ifndef xgl
+void adjust_bitmap_and_update_display(struct mame_bitmap *srcbitmap,
+		struct rectangle bounds)
+{
+	orient_rect(&bounds);
+
+	sysdep_update_display(srcbitmap);
+}
+#endif
+
+#ifndef xgl
+struct mame_bitmap *osd_override_snapshot(struct mame_bitmap *bitmap, 
+		struct rectangle *bounds)
+{
+	struct rectangle newbounds;
+	struct mame_bitmap *copy;
+	int x, y, w, h, t;
+
+	/* if we can send it in raw, no need to override anything */
+	if (!blit_swapxy && !blit_flipx && !blit_flipy)
+		return NULL;
+
+	/* allocate a copy */
+	w = blit_swapxy ? bitmap->height : bitmap->width;
+	h = blit_swapxy ? bitmap->width : bitmap->height;
+	copy = bitmap_alloc_depth(w, h, bitmap->depth);
+	if (!copy)
+		return NULL;
+
+	/* populate the copy */
+	for (y = bounds->min_y; y <= bounds->max_y; y++)
+		for (x = bounds->min_x; x <= bounds->max_x; x++)
+		{
+			int tx = x, ty = y;
+
+			/* apply the rotation/flipping */
+			if (blit_swapxy)
+			{
+				t = tx; tx = ty; ty = t;
+			}
+			if (blit_flipx)
+				tx = copy->width - tx - 1;
+			if (blit_flipy)
+				ty = copy->height - ty - 1;
+
+			/* read the old pixel and copy to the new location */
+			switch (copy->depth)
+			{
+				case 15:
+				case 16:
+					*((UINT16 *)copy->base + ty * copy->rowpixels + tx) =
+						*((UINT16 *)bitmap->base + y * bitmap->rowpixels + x);
+					break;
+
+				case 32:
+					*((UINT32 *)copy->base + ty * copy->rowpixels + tx) =
+						*((UINT32 *)bitmap->base + y * bitmap->rowpixels + x);
+					break;
+			}
+		}
+
+	/* compute the oriented bounds */
+	newbounds = *bounds;
+
+	/* apply X/Y swap first */
+	if (blit_swapxy)
+	{
+		t = newbounds.min_x; newbounds.min_x = newbounds.min_y; newbounds.min_y = t;
+		t = newbounds.max_x; newbounds.max_x = newbounds.max_y; newbounds.max_y = t;
+	}
+
+	/* apply X flip */
+	if (blit_flipx)
+	{
+		t = copy->width - newbounds.min_x - 1;
+		newbounds.min_x = copy->width - newbounds.max_x - 1;
+		newbounds.max_x = t;
+	}
+
+	/* apply Y flip */
+	if (blit_flipy)
+	{
+		t = copy->height - newbounds.min_y - 1;
+		newbounds.min_y = copy->height - newbounds.max_y - 1;
+		newbounds.max_y = t;
+	}
+
+	*bounds = newbounds;
+	return copy;
+}
+#endif
+
+void osd_pause(int paused)
+{
+	emulation_paused = paused;	
+}
+
+const char *osd_get_fps_text(const struct performance_info *performance)
+{
+	static char buffer[1024];
+	char *dest = buffer;
+
+	int chars_filled
+		= (*show_fps_frame_functions[frameskipper])(dest);
+
+	if (chars_filled)
+		dest += chars_filled;
+	else
+	{
+		/* display the FPS, frameskip, percent, fps and target fps */
+		dest += sprintf(dest, "%s%s%s%2d%4d%%%4d/%d fps", 
+				throttle ? "T " : "",
+				(throttle && sleep_idle) ? "S " : "",
+				autoframeskip ? "auto" : "fskp", frameskip, 
+				(int)(performance->game_speed_percent + 0.5), 
+				(int)(performance->frames_per_second + 0.5),
+				(int)(Machine->drv->frames_per_second + 0.5));
+	}
+
+	/* for vector games, add the number of vector updates */
+	if (Machine->drv->video_attributes & VIDEO_TYPE_VECTOR)
+	{
+		dest += sprintf(dest, "\n %d vector updates", performance->vector_updates_last_second);
+	}
+	else if (performance->partial_updates_this_frame > 1)
+	{
+		dest += sprintf(dest, "\n %d partial updates", performance->partial_updates_this_frame);
+	}
+
+	/* return a pointer to the static buffer */
+	return buffer;
+}
+
+/*
+ * We don't want to sleep when idle while the setup menu is 
+ * active, since this causes problems with registering 
+ * keypresses.
+ */
+int should_sleep_idle()
+{
+	return sleep_idle && !setup_active();
+}
diff --git a/src/unix/xmame.6-1 b/src/unix/xmame.6-1
new file mode 100644
index 0000000..e573b10
--- /dev/null
+++ b/src/unix/xmame.6-1
@@ -0,0 +1,80 @@
+.\"  -*- nroff -*-
+.\"
+.\" xmame.6
+.\"
+.\" Done by Ren Herrmann <rene.herrmann@berlin.de>, September 2000
+.\"
+.\" xmame should be distributed under terms of the license in
+.\" readme.mame.
+.\" The main issue involves ROM images. ROM images are protected under the
+.\" copyrights of their authors, and CANNOT be distributed in the same
+.\" package as xmame. Download any ROM images at your own risk and
+.\" responsibility.
+.\"
+.Dd 02. September 2000
+.Dt Xmame 6
+.Os
+.Sh NAME
+.Nm xmame
+.Nd THE Arcade game machine emulator for UNIX/X
+.Sh SYNOPSIS
+.Nm xmame[.x11|svga]
+.Op Fl options
+.Ar gamename
+.Sh EXAMPLES
+Some examples for those who are in a hurry.
+
+If you don't have/want a frontend, you'll mostly use
+.Nm xmame
+(with a well defined xmamerc) in the following way:
+
+.Nm xmame
+.Ar ladybug
+
+Plays Ladybug with all options defined in xmamerc. If there is no xmamerc the 
+game starts with the buildin defaults.
+
+.Nm xmame
+.Ar defender
+.Fl frameskip Ar 1
+.Fl cheat
+
+Starts
+.Ar defender
+using a frameskip of 1 and cheat is enabled.
+Useful for slower computers, if the game is running really slowly.
+And of course if you want (have?) to cheat. ;-)
+.Sh LEGAL NOTICE
+The main issue involves ROM images. ROM images are protected under the
+copyrights of their authors, and CANNOT be distributed in the same
+package as xmame. Download any ROM images at your own risk and
+responsibility.
+
+.Nm xmame
+should be distributed under terms of the license in doc/readme.mame
+
+XInputExtensions based Joystick support. Source code is entirely pure 
+hack work. No sample code, no info at all was found (only library 
+reference manual) and is copyrighted by me (Juan Antonio Marmnez).
+Use it under terms of GNU General Public License.
+
+PLEASE BE AWARE OF THE POSSIBLE LEGAL RAMIFICATIONS OF DOWNLOADING ROM
+IMAGES, BEFORE YOU ACTUALLY DO SO!  YOU HAVE BEEN WARNED, AND WE TAKE NO
+RESPONSIBILITY FOR YOUR ACTIONS -- YOU ARE ON YOUR OWN!
+
+Also, the
+.Nm xmame 
+authors ask that you DO NOT distribute any ROM images with either source
+code or binaries of the
+.Nm xmame
+emulator.
+.Sh DESCRIPTION
+.Nm xmame 
+is the (M)ulti (A)rcade (M)achine (E)mulator for UNIX-(X).  It emulates
+the hardware of realy many classic arcade game machines.
+
+Most games allow you to specify one or more options to control the behavior of
+.Nm xmame
+and the game of your choice. Below is a complete list of all the available
+options:
+.Bl -tag -width Ds
diff --git a/src/unix/xmame.6-3 b/src/unix/xmame.6-3
new file mode 100644
index 0000000..a189c00
--- /dev/null
+++ b/src/unix/xmame.6-3
@@ -0,0 +1,240 @@
+.It \fB*** Arguments ***\fR
+.It Ar game
+the name of the game you wish to play. You better choose one. :-)
+.El
+
+Note: There are really many options. You can set the default options and / or
+options per game in
+.Nm xmames
+config files see the RCFILES section below.
+.Sh INSTALLING GAMES
+Most game ROM images come in ZIP files.  Download the ZIP files for
+the games you want, and move them to a directory of your choice (i.e. it is
+a good idea to put them all in one dir).
+
+Note: There is no need to unzip the games in a separate directory, because
+.Nm xmame
+has zip file support through zlib.
+
+.Nm xmame
+uses a ":" seperated rompath to find out which dirs to search for
+roms/samples. The default rompath is XMAMEROOT as defined in the Makefile
+during the compilation (normaly /usr/local/share/xmame). If you put all 
+the zipped-ROM-Files in this dir everything will work automagicly.
+
+The rompath will be overwritten by any rompath in xmamerc. Which can be
+overwritten again with the -rompath commandline option.
+
+.Nm xmame
+searches every dir in this path for roms (and samples) in the following way:
+
+.TS
+tab (@);
+l l.
+<dir>/gamename.zip@(containing filename.ext)
+<dir>/gamename/filename.ext
+<dir>/gamename/filename.ext.gz@(containing filename.ext)
+<dir>/gamename/filename.zip@(containing filename.ext)
+.TE
+
+Note: If your neogeo games can't find neogeo.rom put it in a dir called
+neogeo somewhere in your rompath, or put it in neogeo.zip somewhere in
+your rompath.
+.Sh PLAYING GAMES
+After running
+.Nm xmame
+i.e.
+.Nm xmame
+.Ar ladybug
+you will see two screens.
+
+The first with a copyright message (PLEASE READ THIS!). If you type (ok)
+this screen will only come up again after the cfg-file of the game
+(romname.cfg) will be deleted.
+
+Another screen shows information about the game. Hit any key to continue.
+
+Note: If you want to see this information screen again, you could press
+\fI<TAB>\fR and select \fI<Game Information>\fR or hit \fI<ESC>\fR and
+restart. ;-)
+
+The game will then go through a `hardware self-test' (remember,
+.Nm xmame
+is emulating game HARDWARE). After the self-test, you are `in' the video game.
+Feed the hungry machine with some coins (key \fI<5>\fR for one coin)
+then start (key \fI<1>\fR) it. For more coins and player read the next section
+(KEYBOARD COMMANDS).
+
+HAVE A LOT OF FUN!
+.Sh KEYBOARD COMMANDS
+While playing a game, there are certain keyboard commands available for
+you to use.
+
+.TS
+tab (@);
+l l.
+\fBKEY@Action\fR
+<1> (the number `one')@Start a 1-player game.
+<2> (the number `two')@Start a 2-player game.
+<3> (the number `three')@Start a 3-player game.
+<4> (the number `four')@Start a 4-player game.
+<5> (the number `five')@Insert coin (slot 1).
+<6> (the number `six')@Insert coin (slot 2).
+<7> (the number `seven')@Insert coin (slot 3).
+<8> (the number `eight')@Insert coin (slot 4).
+<Tab>@Toggles the configuration menu.
+<~> (Tilde)@Toggles the `On Screen Display'.
+@Use the up and down arrow keys to select
+@the parameter (global volume, mixing level,
+@gamma correction etc.), left and right to
+@modify.
+<P>@Pauses the game.
+<Shift+P>@While paused, walk to the next frame.
+<F3>@Resets the game (start with
+@`hardware self-test').
+<F4>@Shows the game graphics. Use cursor keys
+@to change set/color, F4 or Esc to return to
+@the emulation.
+<F9>@Changes frame skip on the fly.
+<F10>@Toggles speed throttling.
+<F11>@Toggles speed display.
+<Shift+F11>@Toggles profiler display.
+<F12>@Saves a screen snapshot. The default
+@target directory is SNAP. You must create
+@this directory yourself; the program will
+@not create it if it doesn't exist.
+<ESC>@Exits the emulator.
+<L-CTRL>@is mostly used as a button.
+<L-ALT>)@is also mostly used as a button.
+<arrows>@will emulate the joystick, pad or
+@trakball. If you have a joystick (pad,
+@trakball ), you can use it with the
+@Input-Related options: -joytype, -jt 
+@and/or -[no]analogstick, -[no]as
+.TE
+
+For a complete list of the usefull keys in
+.Nm xmame
+start a game, press the \fI<tab>\fR button, select \fI<Input (general)>\fR or
+\fI<Input (this game)>\fR and you see a complete list of the related keys.
+.Sh RCFILES
+You can put the most commandline options in an (r)essource (c)onfiguration
+(rc) file. To generate a `clean' xmamerc you type in your ${HOME}/.xmame
+directory:
+
+.Nm xmame
+.Fl sc
+>
+.Ar xmamerc
+
+Now you have a good base to build your specific rc-file. Here is a piece
+from this file to tell you how the syntax works.
+
+    ### X11-window Related ###
+    cursor                  1
+    mitshm                  1
+    xsync                   1
+    privatecmap             0
+    xil                     1
+    mtxil                   0
+    run-in-root-window      0
+    root_window_id          0
+    geometry                640x480
+
+    ### XFree86 DGA Related ###
+
+    ### Video Mode Selection Related ###
+    keepaspect              1
+    displayaspectratio      1.330000
+
+The number `0' is equal to `no' or `false' and `1' means `yes' or `true'.
+
+Some parameters like `geometry' needs a string `800x600' and
+some others like `displayaspectratio' use a number `1.330000'.
+.Sh ENVIRONMENT
+The following environment variables are used:
+
+.TS
+tab (@);
+l l.
+\fBENV@USE\fR
+HOME@The user's home directory.  (normally set by the login process.)
+DISPLAY@X server to display in.
+.TE
+.Sh FILES
+The config files are parsed in the following order:
+
+.TS
+tab (@);
+l l.
+\fBPATH@CONFIG FILE\fR
+/usr/local/share/xmame/xmamerc@global configuration
+${HOME}/.xmame/xmamerc@user configuration
+/usr/local/share/xmame/xmame-x11rc@global per display
+@method
+${HOME}/.xmame/xmame-x11rc@user per display
+@method
+/usr/local/share/xmame/rc/<game>rc@global per game
+${HOME}/.xmame/rc/<game>rc@user per game
+.TE
+.Sh BUGS
+There might be some bugs. Take a look in the doc-dir for more info,
+because the xmame-project is always in progress. :-)
+.Sh CREDITS
+Lots and lots and lots of thank to everyone for there great help on the
+xmame project. I would like to thank the following people and of course anyone
+I've forgotten.
+
+Thank you all,
+
+Hans
+
+  1. Fathers of the mame-creature (main version)
+        Nicola Salmoria
+        Allard van der Bas
+        Mirko (Mix) Buffoni (General Mantainer)
+  2. Fathers of mess
+        Brad Oliver
+        Richard Bannister
+        Ben Bruscella (current coordinator)
+  3. Original UNIX/X11 port
+        Allard van der Bas
+        Dick the Ridder
+        Juan Antonio Marmnez
+  4. Unix maintainer
+        Hans de Goede
+  5. Alpha specific issues
+        Christian Groessler
+  6. Sun specific issues
+        Keith Hargrove
+        Mathis Rosenhau
+  7. Irix specific issues
+        Tristram Scott
+  8. GGI maintainance
+        Gabriele Boccone (original port)
+        Christian Groessler (current maintainer)
+  9. OpenGL code & maintainance
+        Mike Oliphant
+ 10. Network code
+        Eric Totel
+ 11. Perl scripts for automation of some porting issues
+        Bill Adams
+ 12. Xmame rpms
+        Jeremy Hansen
+ 13. Mailing list maintainer
+        Chris McCraw
+ 14. Bits and pieces
+        Christian Groessler
+        Torsten Paul
+ 15. AIX Sound code
+        Chris Sharpp
+ 16. IRIX Sound code
+        entropy@zippy.bernstein.com
+ 17. German readme
+        Robert Hamberger
+ 18. Documentation (SGML, HTML, MAN ...)
+        Rene Herrmann
+
+    And now you've come to the end of this man(ual).
+    Have a lot of fun
+    Rene'
diff --git a/src/unix/xmame.h b/src/unix/xmame.h
new file mode 100644
index 0000000..06b6607
--- /dev/null
+++ b/src/unix/xmame.h
@@ -0,0 +1,199 @@
+/*
+ ******************* X-Mame header file *********************
+ * file "xmame.h"
+ *
+ * by jantonio@dit.upm.es
+ *
+ ************************************************************
+*/
+
+#ifndef __XMAME_H_
+#define __XMAME_H_
+
+#ifdef __MAIN_C_
+#define EXTERN
+#else
+#define EXTERN extern
+#endif
+
+/*
+ * Include files.
+ */
+
+#ifdef openstep
+#include <libc.h>
+#include <math.h>
+#endif /* openstep */
+
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <errno.h>
+#include <ctype.h>
+#include <sys/time.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include "osdepend.h"
+#include "driver.h"
+#include "mame.h"
+#include "common.h"
+#include "sysdep/sysdep_palette.h"
+#include "sysdep/rc.h"
+#include "sysdep/sound_stream.h"
+
+/*
+ * Definitions.
+ */
+ 
+#ifndef TRUE
+#define	TRUE			(1)
+#endif
+
+#ifndef FALSE
+#define FALSE			(0)
+#endif
+
+#define OSD_OK			(0)
+#define OSD_NOT_OK		(1)
+
+#define DEBUG(x)
+
+#define FRAMESKIP_LEVELS 12
+
+/*
+ * Global variables.
+ */
+
+/* Used for the rc handling. */
+EXTERN struct rc_struct *rc;
+
+/* Used for artwork games. */
+EXTERN struct rectangle updatebounds;
+
+/* Orientation */
+EXTERN int		blit_hardware_rotation; /* e.g. by the xgl driver */
+EXTERN int		blit_flipx;
+EXTERN int		blit_flipy;
+EXTERN int		blit_swapxy;
+
+EXTERN int		doublebuffer;
+EXTERN void		*indirect;
+
+/* Aspect ratio */
+EXTERN double		aspect_ratio;
+
+/* global variables and miscellaneous flags */
+
+EXTERN int		sound_enabled;
+EXTERN int	 	widthscale;        /* X scale */
+EXTERN int	 	heightscale;       /* Y scale */
+extern int		yarbsize;          /* arbitrary height */
+EXTERN int		video_colors_used; /* max colors used by any palette */
+EXTERN float		video_fps;
+EXTERN int		video_width;
+EXTERN int		video_height;
+EXTERN int		video_depth;
+EXTERN char		*home_dir;
+EXTERN char		title[50];
+EXTERN int		use_mouse;
+EXTERN int		throttle;
+EXTERN int		autoframeskip;
+EXTERN int		frameskip;
+EXTERN int		game_index;
+EXTERN int		use_scanlines;
+EXTERN int		cabview;
+EXTERN char		*cabname;
+EXTERN float		display_aspect_ratio;
+EXTERN int 		sleep_idle;
+EXTERN int 		max_autoframeskip;
+EXTERN int		use_aspect_ratio;
+EXTERN int		normal_use_aspect_ratio;
+EXTERN struct sysdep_palette_info display_palette_info;
+EXTERN struct sysdep_palette_struct *current_palette;
+EXTERN struct sysdep_palette_struct *normal_palette;
+EXTERN struct sysdep_palette_struct *debug_palette;
+EXTERN struct sound_stream_struct *sound_stream;
+#ifdef MESS
+extern char		crcdir[];
+#endif
+
+/* visual is the visual part of the bitmap */
+EXTERN int 		visual_width;
+EXTERN int		visual_height;
+EXTERN struct rectangle visual;
+
+/* File descripters for stdout / stderr redirection, without svgalib inter
+   fering */
+extern FILE *stdout_file;
+extern FILE *stderr_file;
+
+/* system dependent functions */
+int  sysdep_init(void);
+void sysdep_close(void);
+int  sysdep_create_display(int depth);
+void sysdep_display_close(void);
+int  sysdep_display_alloc_palette(int writable_colors);
+int  sysdep_display_set_pen(int pen, unsigned char red, unsigned char green, unsigned char blue);
+int  sysdep_display_16bpp_capable(void);
+void sysdep_update_display(struct mame_bitmap *bitmap);
+int  sysdep_set_video_mode(void);
+void sysdep_set_text_mode(void);
+void sysdep_set_leds(int leds);
+
+/* input related */
+int  osd_input_initpre(void);
+int  osd_input_initpost(void);
+void osd_input_close(void);
+void osd_poll_joysticks(void);
+void sysdep_update_keyboard (void);
+void sysdep_mouse_poll(void);
+
+/* dirty functions */
+int  osd_dirty_init(void);
+void osd_dirty_close(void);
+
+/* network funtions */
+int  osd_net_init(void);
+void osd_net_close(void);
+
+/* debug functions */
+int  osd_debug_init(void);
+void osd_debug_close(void);
+
+/* mode handling functions */
+int mode_disabled(int width, int height, int depth);
+int mode_match(int width, int height);
+
+/* frameskip functions */
+int dos_skip_next_frame();
+int dos_show_fps(char *buffer);
+int barath_skip_next_frame();
+int barath_show_fps(char *buffer);
+
+/* miscelaneous */
+int config_init (int argc, char *argv[]);
+void config_exit(void);
+int frontend_list(char *gamename);
+int frontend_ident(char *gamename);
+void init_search_paths(void);
+void init_rom_path(char *path);
+int should_sleep_idle();
+#ifndef HAVE_SNPRINTF
+int snprintf(char *s, size_t maxlen, const char *fmt, ...);
+#endif
+
+/* option structs */
+extern struct rc_option video_opts[];
+extern struct rc_option display_opts[];
+extern struct rc_option mode_opts[];
+extern struct rc_option sound_opts[];
+extern struct rc_option input_opts[];
+extern struct rc_option network_opts[];
+extern struct rc_option fileio_opts[];
+extern struct rc_option frontend_list_opts[];
+extern struct rc_option frontend_ident_opts[];
+
+#undef EXTERN
+#endif
diff --git a/src/unix/xmamerc-keybinding-notes.txt b/src/unix/xmamerc-keybinding-notes.txt
new file mode 100644
index 0000000..23ae58f
--- /dev/null
+++ b/src/unix/xmamerc-keybinding-notes.txt
@@ -0,0 +1,58 @@
+### X11 keymapping ###
+#
+# mapkey	<Xcode>,<Scancode>
+#
+# Xcode means the HEX code of the key as appears in /usr/include/X11/keysymdef.h
+# Scancode means the hexadecimal code that represents the value used for Xmame
+# 	in keyboard inputs, as defined in src/unix/keyboard.h xmame source file
+# IMPORTANT: 
+#	1- Due to some limitations, only LATIN-1 X-codes ( 0x0000-0x00ff ) and
+#	Especial X-keycodes ( 0xff00-0xffff ) are supported
+#	2- Some keys are keyboard dependent: As Xmame works internally with
+#	Standard US-AT keyboard codes, you must take care in remmaping some keys
+#
+
+# An example: map space as "firebutton" (Mame predefines it as KEY_LCONTROL)
+# in symbolic Xlib/Mame notation it should be:
+#
+# mapkey XK_space,KEY_LCONTROL 
+# 
+# So, looking in X11/keysymdef.h and src/unix/keyboard.h, we'll write
+# mapkey 0x0020,0x001d
+#
+# (Other example). To use the F8 key to insert a coin, you should use
+# mapkey 0xffc5,0x0006
+
+### suggested german keymap mods by Peter Trauner <peter.trauner@jk.uni-linz.ac.at> ###
+#mapkey 0xfe52,0x0029
+#mapkey 0x00df,0x000c
+#mapkey 0xfe51,0x000d
+#mapkey 0x00fc,0x001a
+#mapkey 0x002b,0x001b
+#mapkey 0x00f6,0x0027
+#mapkey 0x00e4,0x0028
+#mapkey 0x0023,0x002b
+#mapkey 0x0059,0x002c
+#mapkey 0x005a,0x0015
+#mapkey 0x002d,0x0035
+
+### SDL keymapping ###
+#
+# sdlmapkey	<SDLcode>,<Scancode>
+#
+# SDLcode means the HEX code of the key as it appears in 
+#       include/SDL/SDL_keysym.h
+# Scancode means the hexadecimal code that represents the value used for Xmame
+# 	in keyboard inputs, as defined in src/unix/keyboard.h xmame source file
+#
+
+# An example: map space as "firebutton" (Mame predefines it as KEY_LCONTROL)
+# in symbolic SDL/Mame notation it should be:
+#
+# sdlmapkey SDLK_SPACE,KEY_LCONTROL 
+# 
+# So, looking in X11/keysymdef.h and src/unix/keyboard.h, we'll write
+# sdlmapkey 0x0020,0x001d
+#
+# (Other example). To use the F8 key to insert a coin, you should use
+# sdlmapkey 0x0121,0x0006
diff --git a/src/wpc/serial.c b/src/wpc/serial.c
new file mode 100644
index 0000000..ceeb877
--- /dev/null
+++ b/src/wpc/serial.c
@@ -0,0 +1,353 @@
+
+/* WPC serial port emulation */
+
+//#define STANDALONE
+
+
+#include <unistd.h>
+#include <sys/socket.h>
+#include <sys/types.h>
+#include <sys/time.h>
+#include <sys/select.h>
+#include <sys/errno.h>
+#include <netinet/in.h>
+#include <termios.h>
+#ifndef STANDALONE
+#include "driver.h"
+#include "core.h"
+#endif
+
+
+#ifdef WPC_ORKIN_DEBUG
+#define orkin_debug(fmt, rest...)		printf (fmt , ## rest )
+#else
+#define orkin_debug(fmt, rest...)
+#endif
+
+
+#ifdef STANDALONE
+typedef unsigned char UINT8;
+#endif
+
+/* Orkin (debugger) emulation
+ * 
+ * Control Port (0x3D61)
+ * Read
+ * Bit 1 : 1=Ready, 0=Busy
+ * Bit 0 : 1=Presence
+ *
+ * Data Port (0x3D60)
+ * Writes to this port sends a byte of data to the console display.
+ * Reads from this port receives the next character from the console keyboard.
+ *
+ * After a clear to ORKIN_DATA_PORT, the presence latch will read 0 on 
+ * the next single read.
+ *
+ * The game CPU will check presence three times before declaring that 
+ * the debugger is truly present.
+ *
+ * When control bit 1 is zero, the CPU will loop until it becomes clear
+ * before sending any more data.  Then the data register is read for
+ * some reason...
+ *
+ * Writes can occur whenever Presence=1 (Write Ready?)
+ * Bit 1=1 when a Read is pending
+ */
+
+/*
+ * The WPCMAME side of the debug interface creates a TCP socket at a
+ * well-known address.  Reads/writes are taken from small FIFOs
+ * that are driven by client apps connecting to the socket and
+ * doing their own reads/writes.  When no client exists, reads
+ * return 0xff and writes are ignored.  Only one client at a time
+ * is supported currently.
+ */
+
+#define SOCK_READABLE	0x1
+#define SOCK_WRITEABLE	0x2
+
+
+/* Configuration */
+static int server_port = 3333;
+
+/* Socket descriptions for the server and client */
+static int server_sd = 0;
+static int client_sd = 0;
+
+static int write_ready = 1;
+
+
+static int
+orkin_select (int sd)
+{
+	fd_set rds, wds, eds;
+	struct timeval to;
+	int rc;
+
+	FD_ZERO (&rds);
+	FD_ZERO (&wds);
+	FD_ZERO (&eds);
+	FD_SET(sd, &rds);
+	FD_SET(sd, &wds);
+
+	to.tv_sec = to.tv_usec = 0;
+	
+	rc = select (sd+1, &rds, &wds, &eds, &to);
+	if (rc > 0)
+	{
+		rc = 0;
+		if (FD_ISSET (sd, &rds))
+			rc |= SOCK_READABLE;
+		if (FD_ISSET (sd, &wds))
+			rc |= SOCK_WRITEABLE;
+	}
+	return (rc);
+}
+
+
+static int
+orkin_readable (int sd)
+{
+	return !!(orkin_select (sd) & SOCK_READABLE);
+}
+
+
+static int
+orkin_writeable (int sd)
+{
+	return !!(orkin_select (sd) & SOCK_WRITEABLE);
+}
+
+
+static int
+orkin_get_client_sd (void)
+{
+	if (client_sd)
+		return client_sd;
+
+	if (!orkin_readable (server_sd))
+		return 0;
+
+	client_sd = accept (server_sd, NULL, 0);
+	if (client_sd <= 0)
+		client_sd = 0;
+
+	return client_sd;
+}
+
+
+static void
+orkin_close_client (void)
+{
+	close (client_sd);
+	client_sd = 0;
+}
+
+
+UINT8
+orkin_control_read (void)
+{
+	int val = 0;
+	/* Check if data read ready and write ready, and return result */
+	int sd = orkin_get_client_sd ();
+	if (sd) 
+		val = (orkin_readable (sd) ? 0x2 : 0x0) + write_ready;
+
+	write_ready = 1;
+
+	orkin_debug ("Orkin Control Read = %02X\n", val);
+	return (val);
+}
+
+UINT8
+orkin_data_read (void)
+{
+	UINT8 val = 0xFF;
+	/* Return next byte of data written by client */
+	int sd = orkin_get_client_sd ();
+	if (sd) 
+		if (orkin_readable (sd))
+			if (read (sd, &val, 1) == 0)
+				orkin_close_client ();
+	orkin_debug ("Orkin Data Read = %02X\n", val);
+	return (val);
+}
+
+void
+orkin_control_write (UINT8 val)
+{
+	/* Control is never written, so just return */
+	orkin_debug ("Orkin Control Write(%02X) *** ERROR ***\n", val);
+	return;
+}
+
+void
+orkin_data_write (UINT8 val)
+{
+	/* Send data byte to the client socket if connected */
+	orkin_debug ("Orkin Data Write(%02X)\n", val);
+	int sd = orkin_get_client_sd ();
+	if (!sd) 
+		return;
+	write (sd, &val, 1);
+
+	write_ready = 0;
+
+	/* Clear input queue after sending a character */
+	while (orkin_readable (sd))
+		read (sd, &val, 1);
+}
+
+	
+int
+orkin_init (void)
+{
+	struct sockaddr_in addr;
+	int flag;
+
+	orkin_debug ("Initializing Orkin server.\n");
+
+	/* Create a TCP server socket */
+	if ((server_sd = socket (PF_INET, SOCK_STREAM, 0)) < 0)
+		goto socket_error;
+
+	/* Set reuse */
+	flag = 1;
+	if (setsockopt (server_sd, SOL_SOCKET, SO_REUSEADDR, &flag, sizeof (flag))
+			< 0)
+		goto reuse_error;
+
+	/* Bind to the well-known port number */
+	addr.sin_family = AF_INET;
+	addr.sin_port = server_port;
+	addr.sin_addr.s_addr = INADDR_ANY;
+	if (bind (server_sd, (struct sockaddr *)&addr, sizeof (addr)) < 0)
+		goto bind_error;
+
+	if (listen (server_sd, 1) < 0)
+		goto listen_error;
+
+	return (0);
+
+listen_error:;
+	orkin_debug ("Cleaning up listen error\n");
+
+bind_error:;
+	orkin_debug ("Cleaning up bind error\n");
+
+reuse_error:;
+	orkin_debug ("Cleaning up reuse error\n");
+
+socket_error:
+	orkin_debug ("Errno is %d\n", errno);
+	orkin_debug ("Closing socket\n");
+	close (server_sd);
+	server_sd = 0;
+	return (-1);
+}
+
+
+#ifdef STANDALONE
+
+int
+orkin_client (int argc, char *argv[])
+{
+	struct sockaddr_in addr;
+	int rc;	
+	int fd;
+	struct termios t;
+	int init;
+
+start:
+	fd = socket (PF_INET, SOCK_STREAM, 0);
+	if (fd < 0)
+	{
+		orkin_debug ("*** Could not open client socket.\n");
+		exit (1);
+	}
+
+	addr.sin_family = AF_INET;
+	addr.sin_port = server_port;
+	addr.sin_addr.s_addr = INADDR_ANY;
+	rc = -1;
+	printf (">>> Connecting...\n");
+	while (rc < 0)
+	{
+		rc = connect (fd, (struct sockaddr *)&addr, sizeof (addr));
+		if (rc < 0)
+		{
+			sleep (1);
+		}
+	}
+
+	tcgetattr (0, &t);
+	t.c_lflag &= ~ICANON;
+	tcsetattr (0, TCSANOW, &t);
+
+	for (init = 0; init < 2; init++)
+	{
+		int val;
+
+		printf (">>> Sending init byte #%d\n", init);
+		val = 0;
+		write (fd, &val, 1);
+
+		if (init == 1)
+			break;
+
+		printf (">>> Waiting for ACK from game...");
+		while (!orkin_readable (fd))
+			usleep (10000);
+		printf (" ACK received\n");
+
+		read (fd, &val, 1);
+		printf (">>> ACK byte was %02X\n", val);
+	}
+
+	printf ("\nREADY.\n");
+	for (;;)
+	{
+		UINT8 val;
+
+		if (orkin_readable (0))
+		{
+			read (0, &val, 1);
+			write (fd, &val, 1);
+			continue;
+		}
+
+		if (orkin_readable (fd))
+		{
+			if (read (fd, &val, 1) == 0)
+			{
+				close (fd);
+				goto start;
+			}
+			write (1, &val, 1);
+			continue;
+		}
+
+		usleep (25000);
+	}
+
+	return 0;
+}
+
+
+int
+main (int argc, char *argv[])
+{
+	if (argc > 1)
+		return orkin_client (argc, argv);
+		
+	orkin_init ();
+	for (;;)
+	{
+		printf ("CTL %02X DATA %02X\n",
+				orkin_control_read (), orkin_data_read ());
+		orkin_data_write ('.');
+		sleep (1);
+	}
+}
+#endif
+
diff --git a/src/wpc/sim.h b/src/wpc/sim.h
index bc308b5..e8d693e 100644
--- a/src/wpc/sim.h
+++ b/src/wpc/sim.h
@@ -1,6 +1,8 @@
 #ifndef INC_SIM
 #define INC_SIM
 
+#include "osdepend.h"
+
 /* 121200  Added SIM_STSWON, SIM_STSWOFF */
 /* 201100  Added new types for manual shooter */
 /* 111100  Updated solenoid numbering */
diff --git a/src/wpc/wpc.c b/src/wpc/wpc.c
index c79d0a1..ff97a7b 100644
--- a/src/wpc/wpc.c
+++ b/src/wpc/wpc.c
@@ -123,7 +123,9 @@ static MEMORY_READ_START(wpc_readmem)
   { 0x3600, 0x37ff, MRA_BANK7 },  /* DMD */
   { 0x3800, 0x39ff, MRA_BANK2 },  /* DMD */
   { 0x3A00, 0x3bff, MRA_BANK3 },  /* DMD */
-  { 0x3c00, 0x3faf, MRA_RAM },
+  { 0x3c00, 0x3d5f, MRA_RAM },
+  { 0x3d60, 0x3d61, orkin_r },
+  { 0x3d62, 0x3faf, MRA_RAM },
   { 0x3fb0, 0x3fff, wpc_r },
   { 0x4000, 0x7fff, MRA_BANK1 },
   { 0x8000, 0xffff, MRA_ROM },
@@ -137,7 +139,9 @@ static MEMORY_WRITE_START(wpc_writemem)
   { 0x3600, 0x37ff, MWA_BANK7 },  /* DMD */
   { 0x3800, 0x39ff, MWA_BANK2 },  /* DMD */
   { 0x3A00, 0x3bff, MWA_BANK3 },  /* DMD */
-  { 0x3c00, 0x3faf, MWA_RAM },
+  { 0x3c00, 0x3d5f, MWA_RAM },
+  { 0x3d60, 0x3d61, orkin_w },
+  { 0x3d62, 0x3faf, MWA_RAM },
   { 0x3fb0, 0x3fff, wpc_w, &wpc_data },
   { 0x8000, 0xffff, MWA_ROM },
 MEMORY_END
@@ -317,6 +321,27 @@ void wpc_firq(int set, int src) {
   cpu_set_irq_line(WPC_CPUNO, M6809_FIRQ_LINE, wpclocals.firqSrc ? HOLD_LINE : CLEAR_LINE);
 }
 
+/*---------------------------
+/ Emulate the Orkin debugger
+/----------------------------*/
+READ_HANDLER(orkin_r) {
+  switch (offset) {
+    case 0: return orkin_data_read (); break;
+    case 1: return orkin_control_read (); break;
+    default:
+	   return 0;
+  }
+}
+
+WRITE_HANDLER(orkin_w) {
+  switch (offset) {
+    case 0: orkin_data_write (data); break;
+    case 1: orkin_control_write (data); break;
+	 default: break;
+  }
+}
+
+
 /*----------------------
 / Emulate the WPC chip
 /-----------------------*/
@@ -603,6 +628,12 @@ WRITE_HANDLER(wpc_w) {
         mame_fwrite(wpc_printfile, &wpc_data[WPC_PRINTDATA], 1);
       }
       break;
+    case WPC_SERIAL_DATA:
+      break;
+    case WPC_SERIAL_CTRL:
+      break;
+    case WPC_SERIAL_BAUD:
+      break;
     default:
       DBGLOG(("wpc_w %4x %2x\n", offset+WPC_BASE, data));
       break;
@@ -752,6 +783,8 @@ static MACHINE_INIT(wpc) {
     *(memory_region(WPC_CPUREGION) + 0xffec) = 0x00;
     *(memory_region(WPC_CPUREGION) + 0xffed) = 0xff;
   }
+
+  orkin_init ();
 }
 
 static MACHINE_STOP(wpc) {
diff --git a/src/wpc/wpc.h b/src/wpc/wpc.h
index 6da4be9..f6c9cca 100644
--- a/src/wpc/wpc.h
+++ b/src/wpc/wpc.h
@@ -138,6 +138,11 @@ extern const core_tLCDLayout wpc_dispDMD[];
 #define WPC_PRINTBUSY     (0x3fc0 - WPC_BASE) /* xxxxx  R: Printer ready ??? */
 #define WPC_PRINTDATA     (0x3fc1 - WPC_BASE) /* xxxxx  W: send to printer */
 #define WPC_PRINTDATAX    (0x3fc2 - WPC_BASE) /* xxxxx  W: 0: Printer data available */
+#define WPC_SERIAL_DATA   (0x3fc3 - WPC_BASE)
+#define WPC_SERIAL_CTRL   (0x3fc4 - WPC_BASE)
+#define WPC_SERIAL_BAUD   (0x3fc5 - WPC_BASE)
+/* Ticket dispenser board */
+#define WPC_TICKET_DISP   (0x3fc6 - WPC_BASE)
 /* Fliptronics 2 Board */
 #define WPC_FLIPPERS      (0x3fd4 - WPC_BASE) /*   xxx  R: switches W: Solenoids */
 /* Sound board */
@@ -191,6 +197,11 @@ extern UINT8 *wpc_data;
 /*---------------------
 /  Exported functions
 /----------------------*/
+
+/*--- memory handlers for the Orkin debugger interface --*/
+extern READ_HANDLER(orkin_r);
+extern WRITE_HANDLER(orkin_w);
+
 /*-- use this if a fallback is required in a custom memory handler --*/
 extern READ_HANDLER(wpc_r);
 extern WRITE_HANDLER(wpc_w);
