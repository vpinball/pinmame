/***********************************************/
/* PINMAME - Interface function (Input/Output) */
/***********************************************/
#include <stdarg.h>
#include <math.h>
#include "driver.h"
#include "sim.h"
#include "snd_cmd.h"
#include "mech.h"
#include "core.h"
#include "video.h"
#include "bulb.h"

#ifdef PROC_SUPPORT
 #include "p-roc/p-roc.h"
#endif

#if defined(VPINMAME) || defined(LIBPINMAME)
 #ifndef LIBPINMAME
  #include <Windows.h>
 #endif
 #include "dmddevice.h"
 #include "../../ext/dmddevice/usbalphanumeric.h"

 UINT8  g_raw_dmdbuffer[DMD_MAXY*DMD_MAXX];
 UINT32 g_raw_colordmdbuffer[DMD_MAXY*DMD_MAXX];
 UINT32 g_raw_dmdx = ~0u;
 UINT32 g_raw_dmdy = ~0u;

 #ifdef LIBPINMAME
  extern int g_fDmdMode;

  int g_display_index = 0;
 #endif

 static UINT8 buffer1[DMD_MAXY*DMD_MAXX];
 static UINT8 buffer2[DMD_MAXY*DMD_MAXX];
 static UINT8 *currbuffer = buffer1;
 static UINT8 *oldbuffer = NULL;
 static UINT32 raw_dmdoffs = 0;
 static UINT8 has_DMD = 0;

 #include "gts3dmd.h"
 UINT8  g_raw_gtswpc_dmd[GTS3DMD_FRAMES_5C*0x200];
 UINT32 g_raw_gtswpc_dmdframes = 0;

 UINT8 g_needs_DMD_update = 1;
#endif

/* stuff to test VPINMAME */
#if 0
#define VPINMAME
int g_fHandleKeyboard = 1, g_fHandleMechanics = 1, g_fMechSamples = 1;
void OnSolenoid(int nSolenoid, int IsActive) {}
void OnStateChange(int nChange) {}
UINT64 vp_getSolMask64(void) { return -1; }
void vp_updateMech(void) {};
int vp_getDip(int bank) { return 0; }
void vp_setDIP(int bank, int value) { }
#endif

#if defined(VPINMAME)
  extern char g_szGameName[256];
#endif

#if defined(VPINMAME) || defined(LIBPINMAME)
  #include "vpintf.h"
  extern int g_fPause;
  extern int g_fHandleKeyboard, g_fHandleMechanics;
  extern char g_fShowWinDMD;
  extern char g_fShowPinDMD; /* pinDMD */
  extern int time_to_reset;  /* pinDMD */
  extern int g_fDumpFrames;
  extern void OnSolenoid(int nSolenoid, int IsActive);
  extern void OnStateChange(int nChange);
#else
  int g_fHandleKeyboard = 1;
  int g_fHandleMechanics = 0xff;
  #define OnSolenoid(nSolenoid, IsActive)
  #define OnStateChange(nChange)
  #define vp_getSolMask64() ((UINT64)(-1))
  #define vp_updateMech()
  #define vp_setDIP(x,y)
#endif

#ifdef LIBPINMAME
  extern void libpinmame_update_display(const int index, const struct core_dispLayout* p_layout, const void* p_data);
#endif

static void drawChar(struct mame_bitmap *bitmap, int row, int col, UINT32 bits, int type, int dimming);
static UINT32 core_initDisplaySize(const struct core_dispLayout *layout);
static VIDEO_UPDATE(core_status);

/*---------------------------
/    Global variables
/----------------------------*/
tPMoptions            pmoptions; /* PinMAME specific options */
core_tGlobals         coreGlobals;
struct pinMachine    *coreData;
const core_tGameData *core_gameData = NULL;  /* data about the running game */

/*---------------------
/  Global constants
/----------------------*/
const int core_bcd2seg7[16] = {
/* 0    1    2    3    4    5    6    7    8    9  */
  0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,0x7f,0x6f
#ifdef MAME_DEBUG
/* A    B    C    D    E */
 ,0x77,0x7c,0x39,0x5e,0x79
#endif /* MAME_DEBUG */
};
// including the 0x0a to 0x0e characters of a SN5446A type BCD-to-7-segment encoder
const int core_bcd2seg7e[16] = {
/* 0    1    2    3    4    5    6    7    8    9  */
  0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,0x7f,0x6f,
/* A    B    C    D    E */
#ifdef MAME_DEBUG
  0x77,0x7c,0x39,0x5e,0x79
#else /* display legible characters in debug mode only */
  0x58,0x4c,0x62,0x69,0x78
#endif /* MAME_DEBUG */
};
// missing top line for 6 and bottom line for 9 numbers (e.g. Atari)
const int core_bcd2seg7a[16] = {
/* 0    1    2    3    4    5    6    7    8    9  */
  0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7c,0x07,0x7f,0x67
#ifdef MAME_DEBUG
/* A    B    C    D    E */
 ,0x77,0x7c,0x39,0x5e,0x79
#endif /* MAME_DEBUG */
};
const int core_bcd2seg9[16] = {
/* 0    1     2    3    4    5    6    7    8    9  */
  0x3f,0x300,0x5b,0x4f,0x66,0x6d,0x7d,0x07,0x7f,0x6f
#ifdef MAME_DEBUG
/* A    B     C    D     E */
 ,0x77,0x34f,0x39,0x30f,0x79
#endif /* MAME_DEBUG */
};
// missing top line for 6 and bottom line for 9 numbers, and including the 0x0a to 0x0e characters (e.g. Gottlieb Sys80/a)
const int core_bcd2seg9a[16] = {
/* 0    1     2    3    4    5    6    7    8    9  */
  0x3f,0x300,0x5b,0x4f,0x66,0x6d,0x7c,0x07,0x7f,0x67,
#ifdef MAME_DEBUG
/* A    B     C    D     E */
  0x77,0x34f,0x39,0x30f,0x79
#else /* display legible characters in debug mode only */
/* A    B    C    D    E */
  0x58,0x4c,0x62,0x69,0x78
#endif /* MAME_DEBUG */
};

// patterns taken from Rockwell 10939 datasheet and adjusted to match regular 16 segments layout
const UINT16 core_ascii2seg16[] = {
  /* 0x00-0x07 */ 0x0000, 0x0000, 0x44BF, 0x2280, 0x08DB, 0x08CF, 0x08E6, 0x08ED, //   012345 with commas
  /* 0x08-0x0f */ 0x08FD, 0x0087, 0x08FF, 0x08EF, 0xC43F, 0xA200, 0x885B, 0x884F, // 67890123 with commas / dots
  /* 0x10-0x17 */ 0x8866, 0x886D, 0x887D, 0x8007, 0x887F, 0x886F, 0xC4BF, 0xA280, // 45678901 with dots / semicolons
  /* 0x18-0x1f */ 0x88DB, 0x88CF, 0x88E6, 0x88ED, 0x88FD, 0x8087, 0x88FF, 0x88EF, // 23456789 with semicolons
  /* 0x20-0x27 */ 0x0000, 0x0309, 0x0220, 0x2A4E, 0x2A6D, 0x6E65, 0x135D, 0x0400, //  !"#$%&'
  /* 0x28-0x2f */ 0x1400, 0x4100, 0x7F40, 0x2A40, 0x0080, 0x0840, 0x0008, 0x4400, // ()*+,-./
  /* 0x30-0x37 */ 0x443F, 0x2200, 0x085B, 0x084F, 0x0866, 0x086D, 0x087D, 0x0007, // 01234567
  /* 0x38-0x3f */ 0x087F, 0x086F, 0x0009, 0x4001, 0x4408, 0x0848, 0x1108, 0x2803, // 89:;<=>?
  /* 0x40-0x47 */ 0x205F, 0x0877, 0x2A0F, 0x0039, 0x220F, 0x0079, 0x0071, 0x083D, // @ABCDEFG
  /* 0x48-0x4f */ 0x0876, 0x2209, 0x001E, 0x1470, 0x0038, 0x0536, 0x1136, 0x003F, // HIJKLMNO
  /* 0x50-0x57 */ 0x0873, 0x103F, 0x1873, 0x086D, 0x2201, 0x003E, 0x4430, 0x5036, // PRQSTUVW
  /* 0x58-0x5f */ 0x5500, 0x2500, 0x4409, 0x0039, 0x1100, 0x000F, 0x5000, 0x0008, // XYZ[\]^_
  /* 0x60-0x67 */ 0x0001, 0x0001, 0x0002, 0x0004, 0x0008, 0x0008, 0x0010, 0x0020, // all segments, singular
  /* 0x68-0x6f */ 0x0200, 0x0400, 0x0800, 0x1000, 0x2000, 0x4000, 0x0040, 0x0100, // all segments, singular
  /* 0x70-0x77 */ 0x0001, 0x0001, 0x0003, 0x0007, 0x000F, 0x000F, 0x001F, 0x003F, // all segments, accumulating
  /* 0x78-0x7f */ 0x023F, 0x063F, 0x0E3F, 0x1E3F, 0x3E3F, 0x7E3F, 0x7E7F, 0x7F7F, // all segments, accumulating
};

// patterns taken from Rockwell 10939 datasheet and adjusted to match 16 segments layout with split top / bottom lines
const UINT16 core_ascii2seg16s[] = {
  /* 0x00-0x07 */ 0x0000, 0x0000, 0x44ff, 0x2200, 0x8877, 0x883f, 0x888c, 0x88bb, //   012345 with commas (no bits for these)
  /* 0x08-0x0f */ 0x88fb, 0x000f, 0x88ff, 0x88bf, 0x44ff, 0x2200, 0x8877, 0x883f, // 67890123 with commas / dots (no bits for these)
  /* 0x10-0x17 */ 0x888c, 0x88bb, 0x88fb, 0x000f, 0x88ff, 0x88bf, 0x44ff, 0x2200, // 45678901 with dots / semicolons (no bits for these)
  /* 0x18-0x1f */ 0x8877, 0x883f, 0x888c, 0x88bb, 0x88fb, 0x000f, 0x88ff, 0x88bf, // 23456789 with semicolons (no bits for these)
  /* 0x20-0x27 */ 0x0000, 0x0321, 0x0280, 0xaa3c, 0xaabb, 0xee99, 0x9379, 0x0400, //  !"#$%&'
  /* 0x28-0x2f */ 0x1400, 0x4100, 0xff00, 0xaa00, 0x4000, 0x8800, 0x0020, 0x4400, // ()*+,-./
  /* 0x30-0x37 */ 0x44ff, 0x2200, 0x8877, 0x883f, 0x888c, 0x88bb, 0x88fb, 0x000f, // 01234567
  /* 0x38-0x3f */ 0x88ff, 0x88bf, 0x0021, 0x4001, 0x4430, 0x8830, 0x1130, 0x2807, // 89:;<=>?
  /* 0x40-0x47 */ 0xa07f, 0x88cf, 0x2a3f, 0x00f3, 0x223f, 0x80f3, 0x80c3, 0x08fb, // @ABCDEFG
  /* 0x48-0x4f */ 0x88cc, 0x2233, 0x007c, 0x94c0, 0x00f0, 0x05cc, 0x11cc, 0x00ff, // HIJKLMNO
  /* 0x50-0x57 */ 0x88c7, 0x10ff, 0x98c7, 0x88bb, 0x2203, 0x00fc, 0x44c0, 0x50cc, // PRQSTUVW
  /* 0x58-0x5f */ 0x5500, 0x2500, 0x4433, 0x00e1, 0x1100, 0x001e, 0x5000, 0x0030, // XYZ[\]^_
  /* 0x60-0x67 */ 0x0001, 0x0002, 0x0004, 0x0008, 0x0010, 0x0020, 0x0040, 0x0080, // all segments, singular
  /* 0x68-0x6f */ 0x0200, 0x0400, 0x0800, 0x1000, 0x2000, 0x4000, 0x8000, 0x0100, // all segments, singular
  /* 0x70-0x77 */ 0x0001, 0x0003, 0x0007, 0x000f, 0x001f, 0x003f, 0x007f, 0x00ff, // all segments, accumulating
  /* 0x78-0x7f */ 0x02ff, 0x06ff, 0x0eff, 0x1eff, 0x3eff, 0x7eff, 0xfeff, 0xffff, // all segments, accumulating
};

/* makes it easier to swap bits */
                              // 0  1  2  3  4  5  6  7  8  9 10,11,12,13,14,15
const UINT8 core_swapNyb[16] = { 0, 8, 4,12, 2,10, 6,14, 1, 9, 5,13, 3,11, 7,15};
/* Palette */

static const unsigned char core_palette[48+COL_COUNT][3] = {
{/*  0 */ 0x00,0x00,0x00}, /* Background */
/* -- DMD DOT COLORS-- */
{/*  1 */ 0x30,0x00,0x00}, /* "Black" Dot - DMD Background */
{/*  2 */ 0x00,0x00,0x00}, /* Intensity  33% - Filled in @ Run Time */
{/*  3 */ 0x00,0x00,0x00}, /* Intensity  66% - Filled in @ Run Time */
{/*  4 */ 0xff,0xe0,0x20}, /* Intensity 100% - Changed @ Run Time to match config vars*/
/* -- PLAYFIELD LAMP COLORS -- */
{/*  5 */ 0x00,0x00,0x00}, /* Black */
{/*  6 */ 0xff,0xff,0xff}, /* White */
{/*  7 */ 0x40,0xff,0x00}, /* green */
{/*  8 */ 0xff,0x00,0x00}, /* Red */
{/*  9 */ 0xff,0x80,0x00}, /* orange */
{/* 10 */ 0xff,0xff,0x00}, /* yellow */
{/* 11 */ 0x00,0x80,0xff}, /* lblue */
{/* 12 */ 0x9f,0x40,0xff}  /* lpurple*/
};

/*------------------------------
/ Display segment drawing data
/------------------------------*/
typedef UINT32 tSegRow[17];
typedef struct { int rows, cols; tSegRow *segs; } tSegData;

static tSegRow segSize1C[6][20] = { /* with commas */
{ /* alphanumeric display characters */
/*                       all        0001       0002       0004       0008       0010       0020       0040       0080       0100       0200       0400       0800       1000       2000       4000       8000 */
/*    11111111111  */{0x00555554,0x00555554,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/*   1133331333311 */{0x017fdff5,0x003fcff0,0x00000001,0x00000000,0x00000000,0x00000000,0x01000000,0x00000000,0x00000000,0x00400000,0x00001000,0x00000004,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/*   11    1   1 1 */{0x01401011,0x00000000,0x00000001,0x00000000,0x00000000,0x00000000,0x01000000,0x00000000,0x00000000,0x00400000,0x00001000,0x00000010,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/*  31 1  31  1 31 */{0x0d10d04d,0x00000000,0x0000000d,0x00000000,0x00000000,0x00000000,0x0d000000,0x00000000,0x00000000,0x00100000,0x0000d000,0x00000040,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/*  32 1  32  1 32 */{0x0e10e04e,0x00000000,0x0000000e,0x00000000,0x00000000,0x00000000,0x0e000000,0x00000000,0x00000000,0x00100000,0x0000e000,0x00000040,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/*  22  1 22 1  22 */{0x0a04a10a,0x00000000,0x0000000a,0x00000000,0x00000000,0x00000000,0x0a000000,0x00000000,0x00000000,0x00040000,0x0000a000,0x00000100,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/*  23  1 231   23 */{0x0b04b40b,0x00000000,0x0000000b,0x00000000,0x00000000,0x00000000,0x0b000000,0x00000000,0x00000000,0x00040000,0x0000b000,0x00000400,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/*  13   1131   13 */{0x07017407,0x00000000,0x00000007,0x00000000,0x00000000,0x00000000,0x07000000,0x00000000,0x00000000,0x00010000,0x00007000,0x00000400,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/*  1333311133331  */{0x07fd5ff4,0x00000000,0x00000004,0x00000000,0x00000000,0x00000000,0x04000000,0x03fc0000,0x00000000,0x00010000,0x00004000,0x00001000,0x00000ff0,0x00000000,0x00000000,0x00000000,0x00000000},
/*  3111113111113  */{0x0d55d55c,0x00000000,0x0000000c,0x0000000c,0x00000000,0x0c000000,0x0c000000,0x0155c000,0x00000000,0x0000c000,0x0000c000,0x0000c000,0x0000d550,0x0000c000,0x0000c000,0x0000c000,0x00000000},
/*  1333311133331  */{0x07fd5ff4,0x00000000,0x00000000,0x00000004,0x00000000,0x04000000,0x00000000,0x03fc0000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000ff0,0x00001000,0x00004000,0x00010000,0x00000000},
/* 31   1311   31  */{0x34075034,0x00000000,0x00000000,0x00000034,0x00000000,0x34000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00001000,0x00034000,0x00040000,0x00000000},
/* 32   132 1  32  */{0x38078438,0x00000000,0x00000000,0x00000038,0x00000000,0x38000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000400,0x00038000,0x00040000,0x00000000},
/* 22  1 22 1  22  */{0x28128428,0x00000000,0x00000000,0x00000028,0x00000000,0x28000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000400,0x00028000,0x00100000,0x00000000},
/* 23 1  23  1 23  */{0x2c42c12c,0x00000000,0x00000000,0x0000002c,0x00000000,0x2c000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000100,0x0002c000,0x00400000,0x00000000},
/* 13 1  13  1 13  */{0x1c41c11c,0x00000000,0x00000000,0x0000001c,0x00000000,0x1c000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000100,0x0001c000,0x00400000,0x00000000},
/* 1 1   1    11   */{0x11010050,0x00000000,0x00000000,0x00000010,0x00000000,0x10000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000040,0x00010000,0x01000000,0x00000000},
/* 113333133331132 */{0x17fdff5e,0x00000000,0x00000000,0x00000010,0x03fcff00,0x10000000,0x00000000,0x00000000,0x0000000e,0x00000000,0x00000000,0x00000000,0x00000000,0x00000040,0x00010000,0x04000000,0x0000000e},
/*  11111111111 31 */{0x0555554d,0x00000000,0x00000000,0x00000000,0x05555540,0x00000000,0x00000000,0x00000000,0x0000000d,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x0000000d},
/*              1  */{0x00000004,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000004,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000}
},{ /* 8 segment LED characters */
/*    11111111111  */{0x00555554,0x00555554,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/*   1333333333331 */{0x01fffffd,0x00fffffc,0x00000001,0x00000000,0x00000000,0x00000000,0x01000000,0x00000000,0x00000000},
/*   1           1 */{0x01000001,0x00000000,0x00000001,0x00000000,0x00000000,0x00000000,0x01000000,0x00000000,0x00000000},
/*  31          31 */{0x0d00000d,0x00000000,0x0000000d,0x00000000,0x00000000,0x00000000,0x0d000000,0x00000000,0x00000000},
/*  32          32 */{0x0e00000e,0x00000000,0x0000000e,0x00000000,0x00000000,0x00000000,0x0e000000,0x00000000,0x00000000},
/*  22          22 */{0x0a00000a,0x00000000,0x0000000a,0x00000000,0x00000000,0x00000000,0x0a000000,0x00000000,0x00000000},
/*  23          23 */{0x0b00000b,0x00000000,0x0000000b,0x00000000,0x00000000,0x00000000,0x0b000000,0x00000000,0x00000000},
/*  13          13 */{0x07000007,0x00000000,0x00000007,0x00000000,0x00000000,0x00000000,0x07000000,0x00000000,0x00000000},
/*  1333333333331  */{0x07fffff4,0x00000000,0x00000004,0x00000000,0x00000000,0x00000000,0x04000000,0x03fffff0,0x00000000},
/*  3111111111113  */{0x0d55555c,0x00000000,0x0000000c,0x0000000c,0x00000000,0x0c000000,0x0c000000,0x0d55555c,0x00000000},
/*  1333333333331  */{0x07fffff4,0x00000000,0x00000000,0x00000004,0x00000000,0x04000000,0x00000000,0x03fffff0,0x00000000},
/* 31          31  */{0x34000034,0x00000000,0x00000000,0x00000034,0x00000000,0x34000000,0x00000000,0x00000000,0x00000000},
/* 32          32  */{0x38000038,0x00000000,0x00000000,0x00000038,0x00000000,0x38000000,0x00000000,0x00000000,0x00000000},
/* 22          22  */{0x28000028,0x00000000,0x00000000,0x00000028,0x00000000,0x28000000,0x00000000,0x00000000,0x00000000},
/* 23          23  */{0x2c00002c,0x00000000,0x00000000,0x0000002c,0x00000000,0x2c000000,0x00000000,0x00000000,0x00000000},
/* 13          13  */{0x1c00001c,0x00000000,0x00000000,0x0000001c,0x00000000,0x1c000000,0x00000000,0x00000000,0x00000000},
/* 1           1   */{0x10000010,0x00000000,0x00000000,0x00000010,0x00000000,0x10000000,0x00000000,0x00000000,0x00000000},
/* 133333333333132 */{0x1fffffde,0x00000000,0x00000000,0x00000010,0x0fffffc0,0x10000000,0x00000000,0x00000000,0x0000000e},
/*  11111111111 31 */{0x0555554d,0x00000000,0x00000000,0x00000000,0x05555540,0x00000000,0x00000000,0x00000000,0x0000000d},
/*              1  */{0x00000004,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000004}
},{ /* 10 segment LED characters */
/*    11111111111  */{0x00555554,0x00555554,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/*   1333331333331 */{0x01ffdffd,0x00ffcffc,0x00000001,0x00000000,0x00000000,0x00000000,0x01000000,0x00000000,0x00000000,0x00001000,0x00000000},
/*   1     1     1 */{0x01001001,0x00000000,0x00000001,0x00000000,0x00000000,0x00000000,0x01000000,0x00000000,0x00000000,0x00001000,0x00000000},
/*  31    31    31 */{0x0d00d00d,0x00000000,0x0000000d,0x00000000,0x00000000,0x00000000,0x0d000000,0x00000000,0x00000000,0x0000d000,0x00000000},
/*  32    32    32 */{0x0e00e00e,0x00000000,0x0000000e,0x00000000,0x00000000,0x00000000,0x0e000000,0x00000000,0x00000000,0x0000e000,0x00000000},
/*  22    22    22 */{0x0a00a00a,0x00000000,0x0000000a,0x00000000,0x00000000,0x00000000,0x0a000000,0x00000000,0x00000000,0x0000a000,0x00000000},
/*  23    23    23 */{0x0b00b00b,0x00000000,0x0000000b,0x00000000,0x00000000,0x00000000,0x0b000000,0x00000000,0x00000000,0x0000b000,0x00000000},
/*  13    13    13 */{0x07007007,0x00000000,0x00000007,0x00000000,0x00000000,0x00000000,0x07000000,0x00000000,0x00000000,0x00007000,0x00000000},
/*  1333331333331  */{0x07ff7ff4,0x00000000,0x00000004,0x00000000,0x00000000,0x00000000,0x04000000,0x03ff3ff0,0x00000000,0x00004000,0x00000000},
/*  3111111111113  */{0x0d55555c,0x00000000,0x0000000c,0x0000000c,0x00000000,0x0c000000,0x0c000000,0x0d55555c,0x00000000,0x0000c000,0x0000c000},
/*  1333331333331  */{0x07ff7ff4,0x00000000,0x00000000,0x00000004,0x00000000,0x04000000,0x00000000,0x03ff3ff0,0x00000000,0x00000000,0x00004000},
/* 31    31    31  */{0x34034034,0x00000000,0x00000000,0x00000034,0x00000000,0x34000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00034000},
/* 32    32    32  */{0x38038038,0x00000000,0x00000000,0x00000038,0x00000000,0x38000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00038000},
/* 22    22    22  */{0x28028028,0x00000000,0x00000000,0x00000028,0x00000000,0x28000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00028000},
/* 23    23    23  */{0x2c02c02c,0x00000000,0x00000000,0x0000002c,0x00000000,0x2c000000,0x00000000,0x00000000,0x00000000,0x00000000,0x0002c000},
/* 13    13    13  */{0x1c01c01c,0x00000000,0x00000000,0x0000001c,0x00000000,0x1c000000,0x00000000,0x00000000,0x00000000,0x00000000,0x0001c000},
/* 1     1     1   */{0x10010010,0x00000000,0x00000000,0x00000010,0x00000000,0x10000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00010000},
/* 133333133333132 */{0x1ffdffde,0x00000000,0x00000000,0x00000010,0x0ffcffc0,0x10000000,0x00000000,0x00000000,0x0000000e,0x00000000,0x00010000},
/*  11111111111 31 */{0x0555554d,0x00000000,0x00000000,0x00000000,0x05555540,0x00000000,0x00000000,0x00000000,0x0000000d,0x00000000,0x00000000},
/*              1  */{0x00000004,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000004,0x00000000,0x00000000}
},{ /* alphanumeric display characters (reversed comma with period) */
/*    11111111111  */{0x00555554,0x00555554,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/*   1133331333311 */{0x017fdff5,0x003fcff0,0x00000001,0x00000000,0x00000000,0x00000000,0x01000000,0x00000000,0x00000000,0x00400000,0x00001000,0x00000004,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/*   11    1   1 1 */{0x01401011,0x00000000,0x00000001,0x00000000,0x00000000,0x00000000,0x01000000,0x00000000,0x00000000,0x00400000,0x00001000,0x00000010,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/*  31 1  31  1 31 */{0x0d10d04d,0x00000000,0x0000000d,0x00000000,0x00000000,0x00000000,0x0d000000,0x00000000,0x00000000,0x00100000,0x0000d000,0x00000040,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/*  32 1  32  1 32 */{0x0e10e04e,0x00000000,0x0000000e,0x00000000,0x00000000,0x00000000,0x0e000000,0x00000000,0x00000000,0x00100000,0x0000e000,0x00000040,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/*  22  1 22 1  22 */{0x0a04a10a,0x00000000,0x0000000a,0x00000000,0x00000000,0x00000000,0x0a000000,0x00000000,0x00000000,0x00040000,0x0000a000,0x00000100,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/*  23  1 231   23 */{0x0b04b40b,0x00000000,0x0000000b,0x00000000,0x00000000,0x00000000,0x0b000000,0x00000000,0x00000000,0x00040000,0x0000b000,0x00000400,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/*  13   1131   13 */{0x07017407,0x00000000,0x00000007,0x00000000,0x00000000,0x00000000,0x07000000,0x00000000,0x00000000,0x00010000,0x00007000,0x00000400,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/*  1333311133331  */{0x07fd5ff4,0x00000000,0x00000004,0x00000000,0x00000000,0x00000000,0x04000000,0x03fc0000,0x00000000,0x00010000,0x00004000,0x00001000,0x00000ff0,0x00000000,0x00000000,0x00000000,0x00000000},
/*  3111113111113  */{0x0d55d55c,0x00000000,0x0000000c,0x0000000c,0x00000000,0x0c000000,0x0c000000,0x0155c000,0x00000000,0x0000c000,0x0000c000,0x0000c000,0x0000d550,0x0000c000,0x0000c000,0x0000c000,0x00000000},
/*  1333311133331  */{0x07fd5ff4,0x00000000,0x00000000,0x00000004,0x00000000,0x04000000,0x00000000,0x03fc0000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000ff0,0x00001000,0x00004000,0x00010000,0x00000000},
/* 31   1311   31  */{0x34075034,0x00000000,0x00000000,0x00000034,0x00000000,0x34000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00001000,0x00034000,0x00040000,0x00000000},
/* 32   132 1  32  */{0x38078438,0x00000000,0x00000000,0x00000038,0x00000000,0x38000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000400,0x00038000,0x00040000,0x00000000},
/* 22  1 22 1  22  */{0x28128428,0x00000000,0x00000000,0x00000028,0x00000000,0x28000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000400,0x00028000,0x00100000,0x00000000},
/* 23 1  23  1 23  */{0x2c42c12c,0x00000000,0x00000000,0x0000002c,0x00000000,0x2c000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000100,0x0002c000,0x00400000,0x00000000},
/* 13 1  13  1 13  */{0x1c41c11c,0x00000000,0x00000000,0x0000001c,0x00000000,0x1c000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000100,0x0001c000,0x00400000,0x00000000},
/* 1 1   1    11   */{0x11010050,0x00000000,0x00000000,0x00000010,0x00000000,0x10000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000040,0x00010000,0x01000000,0x00000000},
/* 113333133331132 */{0x17fdff5e,0x00000000,0x00000000,0x00000010,0x03fcff00,0x10000000,0x00000000,0x00000000,0x0000000e,0x00000000,0x00000000,0x00000000,0x00000000,0x00000040,0x00010000,0x04000000,0x0000000e},
/*  11111111111 31 */{0x0555554d,0x00000000,0x00000000,0x00000000,0x05555540,0x00000000,0x00000000,0x00000000,0x0000000d,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x0000000d},
/*              1  */{0x00000004,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000004}
},{ /* 8 segment LED characters with dots instead of commas */
/*    11111111111  */{0x00555554,0x00555554,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/*   1333333333331 */{0x01fffffd,0x00fffffc,0x00000001,0x00000000,0x00000000,0x00000000,0x01000000,0x00000000,0x00000000},
/*   1           1 */{0x01000001,0x00000000,0x00000001,0x00000000,0x00000000,0x00000000,0x01000000,0x00000000,0x00000000},
/*  31          31 */{0x0d00000d,0x00000000,0x0000000d,0x00000000,0x00000000,0x00000000,0x0d000000,0x00000000,0x00000000},
/*  32          32 */{0x0e00000e,0x00000000,0x0000000e,0x00000000,0x00000000,0x00000000,0x0e000000,0x00000000,0x00000000},
/*  22          22 */{0x0a00000a,0x00000000,0x0000000a,0x00000000,0x00000000,0x00000000,0x0a000000,0x00000000,0x00000000},
/*  23          23 */{0x0b00000b,0x00000000,0x0000000b,0x00000000,0x00000000,0x00000000,0x0b000000,0x00000000,0x00000000},
/*  13          13 */{0x07000007,0x00000000,0x00000007,0x00000000,0x00000000,0x00000000,0x07000000,0x00000000,0x00000000},
/*  1333333333331  */{0x07fffff4,0x00000000,0x00000004,0x00000000,0x00000000,0x00000000,0x04000000,0x03fffff0,0x00000000},
/*  3111111111113  */{0x0d55555c,0x00000000,0x0000000c,0x0000000c,0x00000000,0x0c000000,0x0c000000,0x0d55555c,0x00000000},
/*  1333333333331  */{0x07fffff4,0x00000000,0x00000000,0x00000004,0x00000000,0x04000000,0x00000000,0x03fffff0,0x00000000},
/* 31          31  */{0x34000034,0x00000000,0x00000000,0x00000034,0x00000000,0x34000000,0x00000000,0x00000000,0x00000000},
/* 32          32  */{0x38000038,0x00000000,0x00000000,0x00000038,0x00000000,0x38000000,0x00000000,0x00000000,0x00000000},
/* 22          22  */{0x28000028,0x00000000,0x00000000,0x00000028,0x00000000,0x28000000,0x00000000,0x00000000,0x00000000},
/* 23          23  */{0x2c00002c,0x00000000,0x00000000,0x0000002c,0x00000000,0x2c000000,0x00000000,0x00000000,0x00000000},
/* 13          13  */{0x1c00001c,0x00000000,0x00000000,0x0000001c,0x00000000,0x1c000000,0x00000000,0x00000000,0x00000000},
/* 1           1   */{0x10000010,0x00000000,0x00000000,0x00000010,0x00000000,0x10000000,0x00000000,0x00000000,0x00000000},
/* 133333333333132 */{0x1fffffde,0x00000000,0x00000000,0x00000010,0x0fffffc0,0x10000000,0x00000000,0x00000000,0x0000000e},
/*  11111111111 31 */{0x0555554d,0x00000000,0x00000000,0x00000000,0x05555540,0x00000000,0x00000000,0x00000000,0x0000000d},
/*                 */{0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000}
},{ /* alphanumeric display characters (period only) */
/*    11111111111  */{0x00555554,0x00555554,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/*   1133331333311 */{0x017fdff5,0x003fcff0,0x00000001,0x00000000,0x00000000,0x00000000,0x01000000,0x00000000,0x00000000,0x00400000,0x00001000,0x00000004,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/*   11    1   1 1 */{0x01401011,0x00000000,0x00000001,0x00000000,0x00000000,0x00000000,0x01000000,0x00000000,0x00000000,0x00400000,0x00001000,0x00000010,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/*  31 1  31  1 31 */{0x0d10d04d,0x00000000,0x0000000d,0x00000000,0x00000000,0x00000000,0x0d000000,0x00000000,0x00000000,0x00100000,0x0000d000,0x00000040,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/*  32 1  32  1 32 */{0x0e10e04e,0x00000000,0x0000000e,0x00000000,0x00000000,0x00000000,0x0e000000,0x00000000,0x00000000,0x00100000,0x0000e000,0x00000040,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/*  22  1 22 1  22 */{0x0a04a10a,0x00000000,0x0000000a,0x00000000,0x00000000,0x00000000,0x0a000000,0x00000000,0x00000000,0x00040000,0x0000a000,0x00000100,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/*  23  1 231   23 */{0x0b04b40b,0x00000000,0x0000000b,0x00000000,0x00000000,0x00000000,0x0b000000,0x00000000,0x00000000,0x00040000,0x0000b000,0x00000400,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/*  13   1131   13 */{0x07017407,0x00000000,0x00000007,0x00000000,0x00000000,0x00000000,0x07000000,0x00000000,0x00000000,0x00010000,0x00007000,0x00000400,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/*  1333311133331  */{0x07fd5ff4,0x00000000,0x00000004,0x00000000,0x00000000,0x00000000,0x04000000,0x03fc0000,0x00000000,0x00010000,0x00004000,0x00001000,0x00000ff0,0x00000000,0x00000000,0x00000000,0x00000000},
/*  3111113111113  */{0x0d55d55c,0x00000000,0x0000000c,0x0000000c,0x00000000,0x0c000000,0x0c000000,0x0155c000,0x00000000,0x0000c000,0x0000c000,0x0000c000,0x0000d550,0x0000c000,0x0000c000,0x0000c000,0x00000000},
/*  1333311133331  */{0x07fd5ff4,0x00000000,0x00000000,0x00000004,0x00000000,0x04000000,0x00000000,0x03fc0000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000ff0,0x00001000,0x00004000,0x00010000,0x00000000},
/* 31   1311   31  */{0x34075034,0x00000000,0x00000000,0x00000034,0x00000000,0x34000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00001000,0x00034000,0x00040000,0x00000000},
/* 32   132 1  32  */{0x38078438,0x00000000,0x00000000,0x00000038,0x00000000,0x38000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000400,0x00038000,0x00040000,0x00000000},
/* 22  1 22 1  22  */{0x28128428,0x00000000,0x00000000,0x00000028,0x00000000,0x28000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000400,0x00028000,0x00100000,0x00000000},
/* 23 1  23  1 23  */{0x2c42c12c,0x00000000,0x00000000,0x0000002c,0x00000000,0x2c000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000100,0x0002c000,0x00400000,0x00000000},
/* 13 1  13  1 13  */{0x1c41c11c,0x00000000,0x00000000,0x0000001c,0x00000000,0x1c000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000100,0x0001c000,0x00400000,0x00000000},
/* 1 1   1    11   */{0x11010050,0x00000000,0x00000000,0x00000010,0x00000000,0x10000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000040,0x00010000,0x01000000,0x00000000},
/* 113333133331132 */{0x17fdff5e,0x00000000,0x00000000,0x00000010,0x03fcff00,0x10000000,0x00000000,0x00000000,0x0000000e,0x00000000,0x00000000,0x00000000,0x00000000,0x00000040,0x00010000,0x04000000,0x0000000e},
/*  11111111111 31 */{0x0555554d,0x00000000,0x00000000,0x00000000,0x05555540,0x00000000,0x00000000,0x00000000,0x0000000d,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x0000000d},
/*                 */{0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000}
}};
static tSegRow segSize1[3][20] = { /* without commas */
{ /* alphanumeric display characters */
/*                       all        0001       0002       0004       0008       0010       0020       0040       0080       0100       0200       0400       0800       1000       2000       4000 */
/*    11111111111  */{0x00555554,0x00555554,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/*   1133331333311 */{0x017fdff5,0x003fcff0,0x00000001,0x00000000,0x00000000,0x00000000,0x01000000,0x00000000,0x00000000,0x00400000,0x00001000,0x00000004,0x00000000,0x00000000,0x00000000,0x00000000},
/*   11    1   1 1 */{0x01401011,0x00000000,0x00000001,0x00000000,0x00000000,0x00000000,0x01000000,0x00000000,0x00000000,0x00400000,0x00001000,0x00000010,0x00000000,0x00000000,0x00000000,0x00000000},
/*  31 1  31  1 31 */{0x0d10d04d,0x00000000,0x0000000d,0x00000000,0x00000000,0x00000000,0x0d000000,0x00000000,0x00000000,0x00100000,0x0000d000,0x00000040,0x00000000,0x00000000,0x00000000,0x00000000},
/*  32 1  32  1 32 */{0x0e10e04e,0x00000000,0x0000000e,0x00000000,0x00000000,0x00000000,0x0e000000,0x00000000,0x00000000,0x00100000,0x0000e000,0x00000040,0x00000000,0x00000000,0x00000000,0x00000000},
/*  22  1 22 1  22 */{0x0a04a10a,0x00000000,0x0000000a,0x00000000,0x00000000,0x00000000,0x0a000000,0x00000000,0x00000000,0x00040000,0x0000a000,0x00000100,0x00000000,0x00000000,0x00000000,0x00000000},
/*  23  1 231   23 */{0x0b04b40b,0x00000000,0x0000000b,0x00000000,0x00000000,0x00000000,0x0b000000,0x00000000,0x00000000,0x00040000,0x0000b000,0x00000400,0x00000000,0x00000000,0x00000000,0x00000000},
/*  13   1131   13 */{0x07017407,0x00000000,0x00000007,0x00000000,0x00000000,0x00000000,0x07000000,0x00000000,0x00000000,0x00010000,0x00007000,0x00000400,0x00000000,0x00000000,0x00000000,0x00000000},
/*  1333311133331  */{0x07fd5ff4,0x00000000,0x00000004,0x00000000,0x00000000,0x00000000,0x04000000,0x03fc0000,0x00000000,0x00010000,0x00004000,0x00001000,0x00000ff0,0x00000000,0x00000000,0x00000000},
/*  3111113111113  */{0x0d55d55c,0x00000000,0x0000000c,0x0000000c,0x00000000,0x0c000000,0x0c000000,0x0155c000,0x00000000,0x0000c000,0x0000c000,0x0000c000,0x0000d550,0x0000c000,0x0000c000,0x0000c000},
/*  1333311133331  */{0x07fd5ff4,0x00000000,0x00000000,0x00000004,0x00000000,0x04000000,0x00000000,0x03fc0000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000ff0,0x00001000,0x00004000,0x00010000},
/* 31   1311   31  */{0x34075034,0x00000000,0x00000000,0x00000034,0x00000000,0x34000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00001000,0x00034000,0x00040000},
/* 32   132 1  32  */{0x38078438,0x00000000,0x00000000,0x00000038,0x00000000,0x38000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000400,0x00038000,0x00040000},
/* 22  1 22 1  22  */{0x28128428,0x00000000,0x00000000,0x00000028,0x00000000,0x28000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000400,0x00028000,0x00100000},
/* 23 1  23  1 23  */{0x2c42c12c,0x00000000,0x00000000,0x0000002c,0x00000000,0x2c000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000100,0x0002c000,0x00400000},
/* 13 1  13  1 13  */{0x1c41c11c,0x00000000,0x00000000,0x0000001c,0x00000000,0x1c000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000100,0x0001c000,0x00400000},
/* 1 1   1    11   */{0x11010050,0x00000000,0x00000000,0x00000010,0x00000000,0x10000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000040,0x00010000,0x01000000},
/* 1133331333311   */{0x17fdff50,0x00000000,0x00000000,0x00000010,0x03fcff00,0x10000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000040,0x00010000,0x04000000},
/*  11111111111    */{0x05555540,0x00000000,0x00000000,0x00000000,0x05555540,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/*                 */{0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000}
},{ /* 7 segment LED characters */
/*    11111111111  */{0x00555554,0x00555554,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/*   1333333333331 */{0x01fffffd,0x00fffffc,0x00000001,0x00000000,0x00000000,0x00000000,0x01000000,0x00000000},
/*   1           1 */{0x01000001,0x00000000,0x00000001,0x00000000,0x00000000,0x00000000,0x01000000,0x00000000},
/*  31          31 */{0x0d00000d,0x00000000,0x0000000d,0x00000000,0x00000000,0x00000000,0x0d000000,0x00000000},
/*  32          32 */{0x0e00000e,0x00000000,0x0000000e,0x00000000,0x00000000,0x00000000,0x0e000000,0x00000000},
/*  22          22 */{0x0a00000a,0x00000000,0x0000000a,0x00000000,0x00000000,0x00000000,0x0a000000,0x00000000},
/*  23          23 */{0x0b00000b,0x00000000,0x0000000b,0x00000000,0x00000000,0x00000000,0x0b000000,0x00000000},
/*  13          13 */{0x07000007,0x00000000,0x00000007,0x00000000,0x00000000,0x00000000,0x07000000,0x00000000},
/*  1333333333331  */{0x07fffff4,0x00000000,0x00000004,0x00000000,0x00000000,0x00000000,0x04000000,0x03fffff0},
/*  3111111111113  */{0x0d55555c,0x00000000,0x0000000c,0x0000000c,0x00000000,0x0c000000,0x0c000000,0x0d55555c},
/*  1333333333331  */{0x07fffff4,0x00000000,0x00000000,0x00000004,0x00000000,0x04000000,0x00000000,0x03fffff0},
/* 31          31  */{0x34000034,0x00000000,0x00000000,0x00000034,0x00000000,0x34000000,0x00000000,0x00000000},
/* 32          32  */{0x38000038,0x00000000,0x00000000,0x00000038,0x00000000,0x38000000,0x00000000,0x00000000},
/* 22          22  */{0x28000028,0x00000000,0x00000000,0x00000028,0x00000000,0x28000000,0x00000000,0x00000000},
/* 23          23  */{0x2c00002c,0x00000000,0x00000000,0x0000002c,0x00000000,0x2c000000,0x00000000,0x00000000},
/* 13          13  */{0x1c00001c,0x00000000,0x00000000,0x0000001c,0x00000000,0x1c000000,0x00000000,0x00000000},
/* 1           1   */{0x10000010,0x00000000,0x00000000,0x00000010,0x00000000,0x10000000,0x00000000,0x00000000},
/* 1333333333331   */{0x1fffffd0,0x00000000,0x00000000,0x00000010,0x0fffffc0,0x10000000,0x00000000,0x00000000},
/*  11111111111    */{0x05555540,0x00000000,0x00000000,0x00000000,0x05555540,0x00000000,0x00000000,0x00000000},
/*                 */{0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000}
},{ /* 9 segment LED characters */
/*    11111111111  */{0x00555554,0x00555554,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/*   1333331333331 */{0x01ffdffd,0x00ffcffc,0x00000001,0x00000000,0x00000000,0x00000000,0x01000000,0x00000000,0x00000000,0x00001000,0x00000000},
/*   1     1     1 */{0x01001001,0x00000000,0x00000001,0x00000000,0x00000000,0x00000000,0x01000000,0x00000000,0x00000000,0x00001000,0x00000000},
/*  31    31    31 */{0x0d00d00d,0x00000000,0x0000000d,0x00000000,0x00000000,0x00000000,0x0d000000,0x00000000,0x00000000,0x0000d000,0x00000000},
/*  32    32    32 */{0x0e00e00e,0x00000000,0x0000000e,0x00000000,0x00000000,0x00000000,0x0e000000,0x00000000,0x00000000,0x0000e000,0x00000000},
/*  22    22    22 */{0x0a00a00a,0x00000000,0x0000000a,0x00000000,0x00000000,0x00000000,0x0a000000,0x00000000,0x00000000,0x0000a000,0x00000000},
/*  23    23    23 */{0x0b00b00b,0x00000000,0x0000000b,0x00000000,0x00000000,0x00000000,0x0b000000,0x00000000,0x00000000,0x0000b000,0x00000000},
/*  13    13    13 */{0x07007007,0x00000000,0x00000007,0x00000000,0x00000000,0x00000000,0x07000000,0x00000000,0x00000000,0x00007000,0x00000000},
/*  1333331333331  */{0x07ff7ff4,0x00000000,0x00000004,0x00000000,0x00000000,0x00000000,0x04000000,0x03ff3ff0,0x00000000,0x00004000,0x00000000},
/*  3111111111113  */{0x0d55555c,0x00000000,0x0000000c,0x0000000c,0x00000000,0x0c000000,0x0c000000,0x0d55555c,0x00000000,0x0000c000,0x0000c000},
/*  1333331333331  */{0x07ff7ff4,0x00000000,0x00000000,0x00000004,0x00000000,0x04000000,0x00000000,0x03ff3ff0,0x00000000,0x00000000,0x00004000},
/* 31    31    31  */{0x34034034,0x00000000,0x00000000,0x00000034,0x00000000,0x34000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00034000},
/* 32    32    32  */{0x38038038,0x00000000,0x00000000,0x00000038,0x00000000,0x38000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00038000},
/* 22    22    22  */{0x28028028,0x00000000,0x00000000,0x00000028,0x00000000,0x28000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00028000},
/* 23    23    23  */{0x2c02c02c,0x00000000,0x00000000,0x0000002c,0x00000000,0x2c000000,0x00000000,0x00000000,0x00000000,0x00000000,0x0002c000},
/* 13    13    13  */{0x1c01c01c,0x00000000,0x00000000,0x0000001c,0x00000000,0x1c000000,0x00000000,0x00000000,0x00000000,0x00000000,0x0001c000},
/* 1     1     1   */{0x10010010,0x00000000,0x00000000,0x00000010,0x00000000,0x10000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00010000},
/* 1333331333331   */{0x1ffdffd0,0x00000000,0x00000000,0x00000010,0x0ffcffc0,0x10000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00010000},
/*  11111111111    */{0x05555540,0x00000000,0x00000000,0x00000000,0x05555540,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/*                 */{0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000}
}};
static tSegRow segSize2C[6][12] = { /* with commas */
{ /* alphanumeric display characters */
/*                   all        0001       0002       0004       0008       0010       0020       0040       0080       0100       0200       0400       0800       1000       2000       4000       8000 */
/*  xxxxxxx    */{0x05554000,0x05554000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/* xx  x  xx   */{0x14105000,0x00000000,0x00001000,0x00000000,0x00000000,0x00000000,0x10000000,0x00000000,0x00000000,0x04000000,0x00100000,0x00004000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/* x x x x x   */{0x11111000,0x00000000,0x00001000,0x00000000,0x00000000,0x00000000,0x10000000,0x00000000,0x00000000,0x01000000,0x00100000,0x00010000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/* x x x x x   */{0x11111000,0x00000000,0x00001000,0x00000000,0x00000000,0x00000000,0x10000000,0x00000000,0x00000000,0x01000000,0x00100000,0x00010000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/* x  xxx  x   */{0x10541000,0x00000000,0x00001000,0x00000000,0x00000000,0x00000000,0x10000000,0x00000000,0x00000000,0x00400000,0x00100000,0x00040000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/*  xxx xxx    */{0x05454000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x05400000,0x00000000,0x00000000,0x00000000,0x00000000,0x00054000,0x00000000,0x00000000,0x00000000,0x00000000},
/* x  xxx  x   */{0x10541000,0x00000000,0x00000000,0x00001000,0x00000000,0x10000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00040000,0x00100000,0x00400000,0x00000000},
/* x x x x x   */{0x11111000,0x00000000,0x00000000,0x00001000,0x00000000,0x10000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00010000,0x00100000,0x01000000,0x00000000},
/* x x x x x   */{0x11111000,0x00000000,0x00000000,0x00001000,0x00000000,0x10000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00010000,0x00100000,0x01000000,0x00000000},
/* xx  x  xx x */{0x14105100,0x00000000,0x00000000,0x00001000,0x00000000,0x10000000,0x00000000,0x00000000,0x00000100,0x00000000,0x00000000,0x00000000,0x00000000,0x00004000,0x00100000,0x04000000,0x00000000},
/*  xxxxxxx  x */{0x05554100,0x00000000,0x00000000,0x00000000,0x05554000,0x00000000,0x00000000,0x00000000,0x00000100,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000100},
/*          x  */{0x00000400,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000400,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000}
},{ /* 8 segment LED characters */
/*  xxxxxxx    */{0x05554000,0x05554000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/* x       x   */{0x10001000,0x00000000,0x00001000,0x00000000,0x00000000,0x00000000,0x10000000,0x00000000,0x00000000},
/* x       x   */{0x10001000,0x00000000,0x00001000,0x00000000,0x00000000,0x00000000,0x10000000,0x00000000,0x00000000},
/* x       x   */{0x10001000,0x00000000,0x00001000,0x00000000,0x00000000,0x00000000,0x10000000,0x00000000,0x00000000},
/* x       x   */{0x10001000,0x00000000,0x00001000,0x00000000,0x00000000,0x00000000,0x10000000,0x00000000,0x00000000},
/*  xxxxxxx    */{0x05554000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x05554000,0x00000000},
/* x       x   */{0x10001000,0x00000000,0x00000000,0x00001000,0x00000000,0x10000000,0x00000000,0x00000000,0x00000000},
/* x       x   */{0x10001000,0x00000000,0x00000000,0x00001000,0x00000000,0x10000000,0x00000000,0x00000000,0x00000000},
/* x       x   */{0x10001000,0x00000000,0x00000000,0x00001000,0x00000000,0x10000000,0x00000000,0x00000000,0x00000000},
/* x       x x */{0x10001100,0x00000000,0x00000000,0x00001000,0x00000000,0x10000000,0x00000000,0x00000000,0x00000100},
/*  xxxxxxx  x */{0x05554100,0x00000000,0x00000000,0x00000000,0x05554000,0x00000000,0x00000000,0x00000000,0x00000100},
/*          x  */{0x00000400,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000400}
},{ /* 10 segment LED characters */
/*  xxxxxxx    */{0x05554000,0x05554000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/* x   x   x   */{0x10101000,0x00000000,0x00001000,0x00000000,0x00000000,0x00000000,0x10000000,0x00000000,0x00000000,0x00100000,0x00000000},
/* x   x   x   */{0x10101000,0x00000000,0x00001000,0x00000000,0x00000000,0x00000000,0x10000000,0x00000000,0x00000000,0x00100000,0x00000000},
/* x   x   x   */{0x10101000,0x00000000,0x00001000,0x00000000,0x00000000,0x00000000,0x10000000,0x00000000,0x00000000,0x00100000,0x00000000},
/* x   x   x   */{0x10101000,0x00000000,0x00001000,0x00000000,0x00000000,0x00000000,0x10000000,0x00000000,0x00000000,0x00100000,0x00000000},
/*  xxxxxxx    */{0x05554000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x05554000,0x00000000,0x00000000,0x00000000},
/* x   x   x   */{0x10101000,0x00000000,0x00000000,0x00001000,0x00000000,0x10000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00100000},
/* x   x   x   */{0x10101000,0x00000000,0x00000000,0x00001000,0x00000000,0x10000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00100000},
/* x   x   x   */{0x10101000,0x00000000,0x00000000,0x00001000,0x00000000,0x10000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00100000},
/* x   x   x x */{0x10101100,0x00000000,0x00000000,0x00001000,0x00000000,0x10000000,0x00000000,0x00000000,0x00000100,0x00000000,0x00100000},
/*  xxxxxxx  x */{0x05554100,0x00000000,0x00000000,0x00000000,0x05554000,0x00000000,0x00000000,0x00000000,0x00000100,0x00000000,0x00000000},
/*          x  */{0x00000400,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000400,0x00000000,0x00000000}
},{ /* alphanumeric display characters (reversed comma with period) */
/*  xxxxxxx    */{0x05554000,0x05554000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/* xx  x  xx   */{0x14105000,0x00000000,0x00001000,0x00000000,0x00000000,0x00000000,0x10000000,0x00000000,0x00000000,0x04000000,0x00100000,0x00004000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/* x x x x x   */{0x11111000,0x00000000,0x00001000,0x00000000,0x00000000,0x00000000,0x10000000,0x00000000,0x00000000,0x01000000,0x00100000,0x00010000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/* x x x x x   */{0x11111000,0x00000000,0x00001000,0x00000000,0x00000000,0x00000000,0x10000000,0x00000000,0x00000000,0x01000000,0x00100000,0x00010000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/* x  xxx  x   */{0x10541000,0x00000000,0x00001000,0x00000000,0x00000000,0x00000000,0x10000000,0x00000000,0x00000000,0x00400000,0x00100000,0x00040000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/*  xxx xxx    */{0x05454000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x05400000,0x00000000,0x00000000,0x00000000,0x00000000,0x00054000,0x00000000,0x00000000,0x00000000,0x00000000},
/* x  xxx  x   */{0x10541000,0x00000000,0x00000000,0x00001000,0x00000000,0x10000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00040000,0x00100000,0x00400000,0x00000000},
/* x x x x x   */{0x11111000,0x00000000,0x00000000,0x00001000,0x00000000,0x10000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00010000,0x00100000,0x01000000,0x00000000},
/* x x x x x   */{0x11111000,0x00000000,0x00000000,0x00001000,0x00000000,0x10000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00010000,0x00100000,0x01000000,0x00000000},
/* xx  x  xx x */{0x14105100,0x00000000,0x00000000,0x00001000,0x00000000,0x10000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00004000,0x00100000,0x04000000,0x00000100},
/*  xxxxxxx  x */{0x05554100,0x00000000,0x00000000,0x00000000,0x05554000,0x00000000,0x00000000,0x00000000,0x00000100,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000100},
/*          x  */{0x00000400,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000400}
},{ /* 8 segment LED characters with dots instead of commas */
/*  xxxxxxx    */{0x05554000,0x05554000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/* x       x   */{0x10001000,0x00000000,0x00001000,0x00000000,0x00000000,0x00000000,0x10000000,0x00000000,0x00000000},
/* x       x   */{0x10001000,0x00000000,0x00001000,0x00000000,0x00000000,0x00000000,0x10000000,0x00000000,0x00000000},
/* x       x   */{0x10001000,0x00000000,0x00001000,0x00000000,0x00000000,0x00000000,0x10000000,0x00000000,0x00000000},
/* x       x   */{0x10001000,0x00000000,0x00001000,0x00000000,0x00000000,0x00000000,0x10000000,0x00000000,0x00000000},
/*  xxxxxxx    */{0x05554000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x05554000,0x00000000},
/* x       x   */{0x10001000,0x00000000,0x00000000,0x00001000,0x00000000,0x10000000,0x00000000,0x00000000,0x00000000},
/* x       x   */{0x10001000,0x00000000,0x00000000,0x00001000,0x00000000,0x10000000,0x00000000,0x00000000,0x00000000},
/* x       x   */{0x10001000,0x00000000,0x00000000,0x00001000,0x00000000,0x10000000,0x00000000,0x00000000,0x00000000},
/* x       x   */{0x10001000,0x00000000,0x00000000,0x00001000,0x00000000,0x10000000,0x00000000,0x00000000,0x00000000},
/*  xxxxxxx  x */{0x05554100,0x00000000,0x00000000,0x00000000,0x05554000,0x00000000,0x00000000,0x00000000,0x00000100},
/*             */{0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000}
},{ /* alphanumeric display characters (period only) */
/*  xxxxxxx    */{0x05554000,0x05554000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/* xx  x  xx   */{0x14105000,0x00000000,0x00001000,0x00000000,0x00000000,0x00000000,0x10000000,0x00000000,0x00000000,0x04000000,0x00100000,0x00004000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/* x x x x x   */{0x11111000,0x00000000,0x00001000,0x00000000,0x00000000,0x00000000,0x10000000,0x00000000,0x00000000,0x01000000,0x00100000,0x00010000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/* x x x x x   */{0x11111000,0x00000000,0x00001000,0x00000000,0x00000000,0x00000000,0x10000000,0x00000000,0x00000000,0x01000000,0x00100000,0x00010000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/* x  xxx  x   */{0x10541000,0x00000000,0x00001000,0x00000000,0x00000000,0x00000000,0x10000000,0x00000000,0x00000000,0x00400000,0x00100000,0x00040000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/*  xxx xxx    */{0x05454000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x05400000,0x00000000,0x00000000,0x00000000,0x00000000,0x00054000,0x00000000,0x00000000,0x00000000,0x00000000},
/* x  xxx  x   */{0x10541000,0x00000000,0x00000000,0x00001000,0x00000000,0x10000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00040000,0x00100000,0x00400000,0x00000000},
/* x x x x x   */{0x11111000,0x00000000,0x00000000,0x00001000,0x00000000,0x10000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00010000,0x00100000,0x01000000,0x00000000},
/* x x x x x   */{0x11111000,0x00000000,0x00000000,0x00001000,0x00000000,0x10000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00010000,0x00100000,0x01000000,0x00000000},
/* xx  x  xx   */{0x14105000,0x00000000,0x00000000,0x00001000,0x00000000,0x10000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00004000,0x00100000,0x04000000,0x00000000},
/*  xxxxxxx  x */{0x05554100,0x00000000,0x00000000,0x00000000,0x05554000,0x00000000,0x00000000,0x00000000,0x00000100,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000100},
/*             */{0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000}
}};
static tSegRow segSize2[3][12] = { /* without commas */
{ /* alphanumeric display characters */
/*                   all        0001       0002       0004       0008       0010       0020       0040       0080       0100       0200       0400       0800       1000       2000       4000       8000 */
/*  xxxxxxx    */{0x05554000,0x05554000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/* xx  x  xx   */{0x14105000,0x00000000,0x00001000,0x00000000,0x00000000,0x00000000,0x10000000,0x00000000,0x00000000,0x04000000,0x00100000,0x00004000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/* x x x x x   */{0x11111000,0x00000000,0x00001000,0x00000000,0x00000000,0x00000000,0x10000000,0x00000000,0x00000000,0x01000000,0x00100000,0x00010000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/* x x x x x   */{0x11111000,0x00000000,0x00001000,0x00000000,0x00000000,0x00000000,0x10000000,0x00000000,0x00000000,0x01000000,0x00100000,0x00010000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/* x  xxx  x   */{0x10541000,0x00000000,0x00001000,0x00000000,0x00000000,0x00000000,0x10000000,0x00000000,0x00000000,0x00400000,0x00100000,0x00040000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/*  xxx xxx    */{0x05454000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x05400000,0x00000000,0x00000000,0x00000000,0x00000000,0x00054000,0x00000000,0x00000000,0x00000000,0x00000000},
/* x  xxx  x   */{0x10541000,0x00000000,0x00000000,0x00001000,0x00000000,0x10000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00040000,0x00100000,0x00400000,0x00000000},
/* x x x x x   */{0x11111000,0x00000000,0x00000000,0x00001000,0x00000000,0x10000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00010000,0x00100000,0x01000000,0x00000000},
/* x x x x x   */{0x11111000,0x00000000,0x00000000,0x00001000,0x00000000,0x10000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00010000,0x00100000,0x01000000,0x00000000},
/* xx  x  xx   */{0x14105000,0x00000000,0x00000000,0x00001000,0x00000000,0x10000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00004000,0x00100000,0x04000000,0x00000000},
/*  xxxxxxx    */{0x05554000,0x00000000,0x00000000,0x00000000,0x05554000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/*             */{0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000}
},{ /* 7 segment LED characters */
/*  xxxxxxx    */{0x05554000,0x05554000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/* x       x   */{0x10001000,0x00000000,0x00001000,0x00000000,0x00000000,0x00000000,0x10000000,0x00000000},
/* x       x   */{0x10001000,0x00000000,0x00001000,0x00000000,0x00000000,0x00000000,0x10000000,0x00000000},
/* x       x   */{0x10001000,0x00000000,0x00001000,0x00000000,0x00000000,0x00000000,0x10000000,0x00000000},
/* x       x   */{0x10001000,0x00000000,0x00001000,0x00000000,0x00000000,0x00000000,0x10000000,0x00000000},
/*  xxxxxxx    */{0x05554000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x05554000},
/* x       x   */{0x10001000,0x00000000,0x00000000,0x00001000,0x00000000,0x10000000,0x00000000,0x00000000},
/* x       x   */{0x10001000,0x00000000,0x00000000,0x00001000,0x00000000,0x10000000,0x00000000,0x00000000},
/* x       x   */{0x10001000,0x00000000,0x00000000,0x00001000,0x00000000,0x10000000,0x00000000,0x00000000},
/* x       x   */{0x10001000,0x00000000,0x00000000,0x00001000,0x00000000,0x10000000,0x00000000,0x00000000},
/*  xxxxxxx    */{0x05554000,0x00000000,0x00000000,0x00000000,0x05554000,0x00000000,0x00000000,0x00000000},
/*             */{0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000}
},{ /* 9 segment LED characters */
/*  xxxxxxx    */{0x05554000,0x05554000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/* x   x   x   */{0x10101000,0x00000000,0x00001000,0x00000000,0x00000000,0x00000000,0x10000000,0x00000000,0x00000000,0x00100000,0x00000000},
/* x   x   x   */{0x10101000,0x00000000,0x00001000,0x00000000,0x00000000,0x00000000,0x10000000,0x00000000,0x00000000,0x00100000,0x00000000},
/* x   x   x   */{0x10101000,0x00000000,0x00001000,0x00000000,0x00000000,0x00000000,0x10000000,0x00000000,0x00000000,0x00100000,0x00000000},
/* x   x   x   */{0x10101000,0x00000000,0x00001000,0x00000000,0x00000000,0x00000000,0x10000000,0x00000000,0x00000000,0x00100000,0x00000000},
/*  xxxxxxx    */{0x05554000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x05554000,0x00000000,0x00000000,0x00000000},
/* x   x   x   */{0x10101000,0x00000000,0x00000000,0x00001000,0x00000000,0x10000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00100000},
/* x   x   x   */{0x10101000,0x00000000,0x00000000,0x00001000,0x00000000,0x10000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00100000},
/* x   x   x   */{0x10101000,0x00000000,0x00000000,0x00001000,0x00000000,0x10000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00100000},
/* x   x   x   */{0x10101000,0x00000000,0x00000000,0x00001000,0x00000000,0x10000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00100000},
/*  xxxxxxx    */{0x05554000,0x00000000,0x00000000,0x00000000,0x05554000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/*             */{0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000}
}};
static tSegRow segSize3C[3][8] = {
{ /* alphanumeric display characters */
{0} /* not possible */
},{ /* 8 segment LED characters with commas */
/*               all        0001       0002       0004       0008       0010       0020       0040       0080       0100       0200 */
/*  xxx    */{0x05400000,0x05400000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/* x   x   */{0x10100000,0x00000000,0x00100000,0x00000000,0x00000000,0x00000000,0x10000000,0x00000000,0x00000000},
/* x   x   */{0x10100000,0x00000000,0x00100000,0x00000000,0x00000000,0x00000000,0x10000000,0x00000000,0x00000000},
/*  xxx    */{0x05400000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x05400000,0x00000000},
/* x   x   */{0x10100000,0x00000000,0x00000000,0x00100000,0x00000000,0x10000000,0x00000000,0x00000000,0x00000000},
/* x   x   */{0x10100000,0x00000000,0x00000000,0x00100000,0x00000000,0x10000000,0x00000000,0x00000000,0x00000000},
/*  xxx  x */{0x05410000,0x00000000,0x00000000,0x00000000,0x05400000,0x00000000,0x00000000,0x00000000,0x00010000},
/*      x  */{0x00040000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00040000}
},{ /* 10 segment LED characters with commas */
/*  xxx    */{0x05400000,0x05400000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/* x x x   */{0x11100000,0x00000000,0x00100000,0x00000000,0x00000000,0x00000000,0x10000000,0x00000000,0x00000000,0x01000000,0x00000000},
/* x x x   */{0x11100000,0x00000000,0x00100000,0x00000000,0x00000000,0x00000000,0x10000000,0x00000000,0x00000000,0x01000000,0x00000000},
/*  xxx    */{0x05400000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x05400000,0x00000000,0x00000000,0x00000000},
/* x x x   */{0x11100000,0x00000000,0x00000000,0x00100000,0x00000000,0x10000000,0x00000000,0x00000000,0x00000000,0x00000000,0x01000000},
/* x x x   */{0x11100000,0x00000000,0x00000000,0x00100000,0x00000000,0x10000000,0x00000000,0x00000000,0x00000000,0x00000000,0x01000000},
/*  xxx  x */{0x05410000,0x00000000,0x00000000,0x00000000,0x05400000,0x00000000,0x00000000,0x00000000,0x00010000,0x00000000,0x00000000},
/*      x  */{0x00040000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00040000,0x00000000,0x00000000}
}};
static tSegRow segSize3[3][8] = {
{ /* alphanumeric display characters */
{0} /* not possible */
},{ /* 8 segment LED characters without commas */
/*               all        0001       0002       0004       0008       0010       0020       0040       0080       0100       0200 */
/*  xxx    */{0x05400000,0x05400000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/* x   x   */{0x10100000,0x00000000,0x00100000,0x00000000,0x00000000,0x00000000,0x10000000,0x00000000},
/* x   x   */{0x10100000,0x00000000,0x00100000,0x00000000,0x00000000,0x00000000,0x10000000,0x00000000},
/*  xxx    */{0x05400000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x05400000},
/* x   x   */{0x10100000,0x00000000,0x00000000,0x00100000,0x00000000,0x10000000,0x00000000,0x00000000},
/* x   x   */{0x10100000,0x00000000,0x00000000,0x00100000,0x00000000,0x10000000,0x00000000,0x00000000},
/*  xxx    */{0x05400000,0x00000000,0x00000000,0x00000000,0x05400000,0x00000000,0x00000000,0x00000000},
/*         */{0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000}
},{ /* 10 segment LED characters without commas */
/*  xxx    */{0x05400000,0x05400000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/* x x x   */{0x11100000,0x00000000,0x00100000,0x00000000,0x00000000,0x00000000,0x10000000,0x00000000,0x00000000,0x01000000,0x00000000},
/* x x x   */{0x11100000,0x00000000,0x00100000,0x00000000,0x00000000,0x00000000,0x10000000,0x00000000,0x00000000,0x01000000,0x00000000},
/*  xxx    */{0x05400000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x05400000,0x00000000,0x00000000,0x00000000},
/* x x x   */{0x11100000,0x00000000,0x00000000,0x00100000,0x00000000,0x10000000,0x00000000,0x00000000,0x00000000,0x00000000,0x01000000},
/* x x x   */{0x11100000,0x00000000,0x00000000,0x00100000,0x00000000,0x10000000,0x00000000,0x00000000,0x00000000,0x00000000,0x01000000},
/*  xxx    */{0x05400000,0x00000000,0x00000000,0x00000000,0x05400000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/*         */{0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000}
}};
static tSegRow segSize1S[1][20] = { /* 16 segment displays without commas but split top & bottom lines */
{ /* alphanumeric display characters */
/*                       all        0001       0002       0004       0008       0010       0020       0040       0080       0100       0200       0400       0800       1000       2000       4000       8000 */
/*    11111311111  */{0x00557554,0x00557000,0x00003554,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/*   1133331333311 */{0x017fdff5,0x003fc000,0x00003ff0,0x00000001,0x00000000,0x00000000,0x00000000,0x00000000,0x01000000,0x00400000,0x00001000,0x00000004,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/*   11    1   1 1 */{0x01401011,0x00000000,0x00000000,0x00000001,0x00000000,0x00000000,0x00000000,0x00000000,0x01000000,0x00400000,0x00001000,0x00000010,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/*  31 1  31  1 31 */{0x0d10d04d,0x00000000,0x00000000,0x0000000d,0x00000000,0x00000000,0x00000000,0x00000000,0x0d000000,0x00100000,0x0000d000,0x00000040,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/*  32 1  32  1 32 */{0x0e10e04e,0x00000000,0x00000000,0x0000000e,0x00000000,0x00000000,0x00000000,0x00000000,0x0e000000,0x00100000,0x0000e000,0x00000040,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/*  22  1 22 1  22 */{0x0a04a10a,0x00000000,0x00000000,0x0000000a,0x00000000,0x00000000,0x00000000,0x00000000,0x0a000000,0x00040000,0x0000a000,0x00000100,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/*  23  1 231   23 */{0x0b04b40b,0x00000000,0x00000000,0x0000000b,0x00000000,0x00000000,0x00000000,0x00000000,0x0b000000,0x00040000,0x0000b000,0x00000400,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/*  13   1131   13 */{0x07017407,0x00000000,0x00000000,0x00000007,0x00000000,0x00000000,0x00000000,0x00000000,0x07000000,0x00010000,0x00007000,0x00000400,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/*  1333311133331  */{0x07fd5ff4,0x00000000,0x00000000,0x00000004,0x00000000,0x00000000,0x00000000,0x00000000,0x04000000,0x00010000,0x00004000,0x00001000,0x00000ff0,0x00000000,0x00000000,0x00000000,0x03fc0000},
/*  3111113111113  */{0x0d55d55c,0x00000000,0x00000000,0x0000000c,0x0000000c,0x00000000,0x00000000,0x0c000000,0x0c000000,0x0000c000,0x0000c000,0x0000c000,0x0000d550,0x0000c000,0x0000c000,0x0000c000,0x0155c000},
/*  1333311133331  */{0x07fd5ff4,0x00000000,0x00000000,0x00000000,0x00000004,0x00000000,0x00000000,0x04000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000ff0,0x00001000,0x00004000,0x00010000,0x03fc0000},
/* 31   1311   31  */{0x34075034,0x00000000,0x00000000,0x00000000,0x00000034,0x00000000,0x00000000,0x34000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00001000,0x00034000,0x00040000,0x00000000},
/* 32   132 1  32  */{0x38078438,0x00000000,0x00000000,0x00000000,0x00000038,0x00000000,0x00000000,0x38000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000400,0x00038000,0x00040000,0x00000000},
/* 22  1 22 1  22  */{0x28128428,0x00000000,0x00000000,0x00000000,0x00000028,0x00000000,0x00000000,0x28000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000400,0x00028000,0x00100000,0x00000000},
/* 23 1  23  1 23  */{0x2c42c12c,0x00000000,0x00000000,0x00000000,0x0000002c,0x00000000,0x00000000,0x2c000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000100,0x0002c000,0x00400000,0x00000000},
/* 13 1  13  1 13  */{0x1c41c11c,0x00000000,0x00000000,0x00000000,0x0000001c,0x00000000,0x00000000,0x1c000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000100,0x0001c000,0x00400000,0x00000000},
/* 1 1   1    11   */{0x11010050,0x00000000,0x00000000,0x00000000,0x00000010,0x00000000,0x00000000,0x10000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000040,0x00010000,0x01000000,0x00000000},
/* 1133331333311   */{0x17fdff50,0x00000000,0x00000000,0x00000000,0x00000010,0x0003ff00,0x03fc0000,0x10000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000040,0x00010000,0x04000000,0x00000000},
/*  11111311111    */{0x05575540,0x00000000,0x00000000,0x00000000,0x00000000,0x00035540,0x05570000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/*                 */{0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000}
}};
static tSegRow segSize2S[1][12] = { /* 16 segment displays without commas but split top & bottom lines */
{ /* alphanumeric display characters */
/*                   all        0001       0002       0004       0008       0010       0020       0040       0080       0100       0200       0400       0800       1000       2000       4000       8000 */
/*  xxxxxxx    */{0x05754000,0x05700000,0x00354000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/* xx  x  xx   */{0x14105000,0x00000000,0x00000000,0x00001000,0x00000000,0x00000000,0x00000000,0x00000000,0x10000000,0x04000000,0x00100000,0x00004000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/* x x x x x   */{0x11111000,0x00000000,0x00000000,0x00001000,0x00000000,0x00000000,0x00000000,0x00000000,0x10000000,0x01000000,0x00100000,0x00010000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/* x x x x x   */{0x11111000,0x00000000,0x00000000,0x00001000,0x00000000,0x00000000,0x00000000,0x00000000,0x10000000,0x01000000,0x00100000,0x00010000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/* x  xxx  x   */{0x10541000,0x00000000,0x00000000,0x00001000,0x00000000,0x00000000,0x00000000,0x00000000,0x10000000,0x00400000,0x00100000,0x00040000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/*  xxx xxx    */{0x05454000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00054000,0x00000000,0x00000000,0x00000000,0x05400000},
/* x  xxx  x   */{0x10541000,0x00000000,0x00000000,0x00000000,0x00001000,0x00000000,0x00000000,0x10000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00040000,0x00100000,0x00400000,0x00000000},
/* x x x x x   */{0x11111000,0x00000000,0x00000000,0x00000000,0x00001000,0x00000000,0x00000000,0x10000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00010000,0x00100000,0x01000000,0x00000000},
/* x x x x x   */{0x11111000,0x00000000,0x00000000,0x00000000,0x00001000,0x00000000,0x00000000,0x10000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00010000,0x00100000,0x01000000,0x00000000},
/* xx  x  xx   */{0x14105000,0x00000000,0x00000000,0x00000000,0x00001000,0x00000000,0x00000000,0x10000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00004000,0x00100000,0x04000000,0x00000000},
/*  xxxxxxx    */{0x05754000,0x00000000,0x00000000,0x00000000,0x00000000,0x00354000,0x05700000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/*             */{0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000}
}};

static tSegData segData[2][18] = {{
  {20,15,&segSize1C[0][0]},/* SEG16 */
#ifdef PROC_SUPPORT	//TODO/PROC: Will this work in normal PinMAME build too?
  /* Use segSize2C for P-ROC's alpha_on_dmd functionality as it maps better to the DMD. */
  {20,15,&segSize2C[0][0]},/* SEG16R */
#else
  {20,15,&segSize1C[3][0]},/* SEG16R */
#endif
  {20,15,&segSize1C[2][0]},/* SEG10 */
  {20,15,&segSize1[2][0]}, /* SEG9 */
  {20,15,&segSize1C[1][0]},/* SEG8 */
  {20,15,&segSize1C[4][0]},/* SEG8FD */
  {20,15,&segSize1[1][0]}, /* SEG7 */
  {20,15,&segSize1C[1][0]},/* SEG87 */
  {20,15,&segSize1C[1][0]},/* SEG87F */
  {20,15,&segSize1C[2][0]},/* SEG98 */
  {20,15,&segSize1C[2][0]},/* SEG98F */
  {12,11,&segSize2[1][0]}, /* SEG7S */
  {12,11,&segSize2C[1][0]},/* SEG7SC */
  {20,15,&segSize1S[0][0]},/* SEG16S */
  { 2, 2,NULL},            /* DMD */
  { 1, 1,NULL},            /* VIDEO */
  {20,15,&segSize1[0][0]}, /* SEG16N */
  {20,15,&segSize1C[5][0]} /* SEG16D */
},{
  {12,11,&segSize2C[0][0]},/* SEG16 */
  {12,11,&segSize2C[3][0]},/* SEG16R */
  {12,11,&segSize2C[2][0]},/* SEG10 */
  {12,11,&segSize2[2][0]}, /* SEG9 */
  {12,11,&segSize2C[1][0]},/* SEG8 */
  {12,11,&segSize2C[4][0]},/* SEG8D */
  {12,11,&segSize2[1][0]}, /* SEG7 */
  {12,11,&segSize2C[1][0]},/* SEG87 */
  {12,11,&segSize2C[1][0]},/* SEG87F */
  {12,11,&segSize2C[2][0]},/* SEG98 */
  {12,11,&segSize2C[2][0]},/* SEG98F */
  { 8, 7,&segSize3[1][0]}, /* SEG7S */
  { 8, 7,&segSize3C[1][0]},/* SEG7SC */
  {12,11,&segSize2S[0][0]},/* SEG16S */
  { 1, 1,NULL},            /* DMD */
  { 1, 1,NULL},            /* VIDEO */
  {12,11,&segSize2[0][0]}, /* SEG16N */
  {12,11,&segSize2C[5][0]} /* SEG16D */
}};

/*-------------------
/  local variables
/-------------------*/
static struct {
  core_tSeg lastSeg;       // previous segments values
  int       displaySize;   // 1=compact 2=normal
  tSegData  *segData;      // segments to use (normal/compact)
  void      *timers[5];    // allocated timers
  int       flipTimer[4];  // time since flipper was activated (used for EOS simulation)
  UINT8     flipMask;      // Flipper bits used for flippers
  int       firstSimRow, maxSimRows; // space available for simulator
  int       solLog[4];
  int       solLogCount;
} locals;

/*-------------------------------
/  Initialize the game palette
/-------------------------------*/
static PALETTE_INIT(core) {
  const int palSize = sizeof(core_palette)/3;
  unsigned char tmpPalette[sizeof(core_palette)/3][3];
  int rStart = 0xff, gStart = 0xe0, bStart = 0x20;
  int perc66 = 67, perc33 = 33, perc0  = 20;
  int ii;
  float diff;

  if ((pmoptions.dmd_red > 0) || (pmoptions.dmd_green > 0) || (pmoptions.dmd_blue > 0)) {
    rStart = pmoptions.dmd_red; gStart = pmoptions.dmd_green; bStart = pmoptions.dmd_blue;
  }
  if ((pmoptions.dmd_perc0 > 0) || (pmoptions.dmd_perc33 > 0) || (pmoptions.dmd_perc66 > 0)) {
    perc66 = pmoptions.dmd_perc66; perc33 = pmoptions.dmd_perc33; perc0  = pmoptions.dmd_perc0;
  }
  memcpy(tmpPalette, core_palette, sizeof(core_palette));

  /*-- Autogenerate DMD Color Shades--*/
  tmpPalette[COL_DMDOFF][0]   = rStart * perc0 / 100;
  tmpPalette[COL_DMDOFF][1]   = gStart * perc0 / 100;
  tmpPalette[COL_DMDOFF][2]   = bStart * perc0 / 100;
  tmpPalette[COL_DMD33][0]    = rStart * perc33 / 100;
  tmpPalette[COL_DMD33][1]    = gStart * perc33 / 100;
  tmpPalette[COL_DMD33][2]    = bStart * perc33 / 100;
  tmpPalette[COL_DMD66][0]    = rStart * perc66 / 100;
  tmpPalette[COL_DMD66][1]    = gStart * perc66 / 100;
  tmpPalette[COL_DMD66][2]    = bStart * perc66 / 100;
  tmpPalette[COL_DMDON][0]    = rStart;
  tmpPalette[COL_DMDON][1]    = gStart;
  tmpPalette[COL_DMDON][2]    = bStart;

  /*-- If the "colorize" option is set, use the individual option colors for the shades --*/
  if (pmoptions.dmd_colorize) { 
    if (pmoptions.dmd_red0 > 0 || pmoptions.dmd_green0 > 0 || pmoptions.dmd_blue0 > 0) {
      tmpPalette[COL_DMDOFF][0]   = pmoptions.dmd_red0;
      tmpPalette[COL_DMDOFF][1]   = pmoptions.dmd_green0;
      tmpPalette[COL_DMDOFF][2]   = pmoptions.dmd_blue0;
    }
    if (pmoptions.dmd_red33 > 0 || pmoptions.dmd_green33 > 0 || pmoptions.dmd_blue33 > 0) {
      tmpPalette[COL_DMD33][0]    = pmoptions.dmd_red33;
      tmpPalette[COL_DMD33][1]    = pmoptions.dmd_green33;
      tmpPalette[COL_DMD33][2]    = pmoptions.dmd_blue33;
    }
    if (pmoptions.dmd_red66 > 0 || pmoptions.dmd_green66 > 0 || pmoptions.dmd_blue66 > 0) {
      tmpPalette[COL_DMD66][0]    = pmoptions.dmd_red66;
      tmpPalette[COL_DMD66][1]    = pmoptions.dmd_green66;
      tmpPalette[COL_DMD66][2]    = pmoptions.dmd_blue66;
    }
  }
  
  /*-- segment display antialias colors --*/
  tmpPalette[COL_SEGAAON1][0] = rStart * 72 / 100;
  tmpPalette[COL_SEGAAON1][1] = gStart * 72 / 100;
  tmpPalette[COL_SEGAAON1][2] = bStart * 72 / 100;
  tmpPalette[COL_SEGAAON2][0] = rStart * 33 / 100;
  tmpPalette[COL_SEGAAON2][1] = gStart * 33 / 100;
  tmpPalette[COL_SEGAAON2][2] = bStart * 33 / 100;
  tmpPalette[COL_SEGAAOFF1][0] = rStart * perc0 * 72 / 10000;
  tmpPalette[COL_SEGAAOFF1][1] = gStart * perc0 * 72 / 10000;
  tmpPalette[COL_SEGAAOFF1][2] = bStart * perc0 * 72 / 10000;
  tmpPalette[COL_SEGAAOFF2][0] = rStart * perc0 * 33 / 10000;
  tmpPalette[COL_SEGAAOFF2][1] = gStart * perc0 * 33 / 10000;
  tmpPalette[COL_SEGAAOFF2][2] = bStart * perc0 * 33 / 10000;

  /*-- generate 16 shades of the segment color for all antialiased segments --*/
  diff = (float)(100 - perc0) / 15.0f;
  for (ii = 0; ii < 16; ii++) {
    tmpPalette[palSize-16+ii][0] = (unsigned char)(rStart * (perc0 + diff * ii) / 100);
    tmpPalette[palSize-16+ii][1] = (unsigned char)(gStart * (perc0 + diff * ii) / 100);
    tmpPalette[palSize-16+ii][2] = (unsigned char)(bStart * (perc0 + diff * ii) / 100);
    tmpPalette[palSize-32+ii][0] = (unsigned char)(rStart * (perc0 + diff * ii) * 72 / 10000);
    tmpPalette[palSize-32+ii][1] = (unsigned char)(gStart * (perc0 + diff * ii) * 72 / 10000);
    tmpPalette[palSize-32+ii][2] = (unsigned char)(bStart * (perc0 + diff * ii) * 72 / 10000);
    tmpPalette[palSize-48+ii][0] = (unsigned char)(rStart * (perc0 + diff * ii) * 33 / 10000);
    tmpPalette[palSize-48+ii][1] = (unsigned char)(gStart * (perc0 + diff * ii) * 33 / 10000);
    tmpPalette[palSize-48+ii][2] = (unsigned char)(bStart * (perc0 + diff * ii) * 33 / 10000);
  }

//for (int i = 0; i < palSize; i++) printf("Col %d: %02x %02x %02x\n", i, tmpPalette[i][0],tmpPalette[i][1],tmpPalette[i][2]);

  rStart = tmpPalette[COL_DMDOFF][0];
  gStart = tmpPalette[COL_DMDOFF][1];
  bStart = tmpPalette[COL_DMDOFF][2];

  /*-- Autogenerate Dark Playfield Lamp Colors --*/
  for (ii = 0; ii < COL_LAMPCOUNT; ii++) { /* Reduce by 75% */
    tmpPalette[COL_LAMP+COL_LAMPCOUNT+ii][0] = (tmpPalette[COL_LAMP+ii][0] * 25) / 100;
    tmpPalette[COL_LAMP+COL_LAMPCOUNT+ii][1] = (tmpPalette[COL_LAMP+ii][1] * 25) / 100;
    tmpPalette[COL_LAMP+COL_LAMPCOUNT+ii][2] = (tmpPalette[COL_LAMP+ii][2] * 25) / 100;
  }

  if (pmoptions.dmd_antialias)
  { /*-- Autogenerate antialias colours --*/
    int rStep, gStep, bStep;
    rStart = gStart = bStart = 0;

    rStep = (tmpPalette[COL_DMDON][0] * pmoptions.dmd_antialias / 100 - rStart) / 6;
    gStep = (tmpPalette[COL_DMDON][1] * pmoptions.dmd_antialias / 100 - gStart) / 6;
    bStep = (tmpPalette[COL_DMDON][2] * pmoptions.dmd_antialias / 100 - bStart) / 6;

    for (ii = 1; ii < COL_DMDAACOUNT; ii++) { // first is black
      tmpPalette[COL_DMDAA+ii][0] = rStart;
      tmpPalette[COL_DMDAA+ii][1] = gStart;
      tmpPalette[COL_DMDAA+ii][2] = bStart;
      rStart += rStep; gStart += gStep; bStart += bStep;
    }
  }

  for (ii = 0; ii < sizeof(tmpPalette)/3; ii++)
    palette_set_color(ii, tmpPalette[ii][0], tmpPalette[ii][1], tmpPalette[ii][2]);
}

/*-----------------------------------
/    Generic DMD display handler
/------------------------------------*/
void video_update_core_dmd(struct mame_bitmap *bitmap, const struct rectangle *cliprect, const struct core_dispLayout *layout) {
  UINT32 *dmdColor = &CORE_COLOR(COL_DMDOFF);
  UINT32 *aaColor  = &CORE_COLOR(COL_DMDAA);
  BMTYPE **lines = ((BMTYPE **)bitmap->line) + (layout->top*locals.displaySize);
  int noaa = !pmoptions.dmd_antialias || (layout->type & CORE_DMDNOAA);
  int ii, jj;

  // prepare all brightness & color/palette tables for mappings from internal DMD representation:
  const int shade_16_enabled = ((core_gameData->gen & (GEN_SAM|GEN_SPA|GEN_ALVG_DMD2)) ||
	  // extended handling also for some GTS3 games (SMB, SMBMW and CBW):
	  (strncasecmp(Machine->gamedrv->name, "smb", 3) == 0) || (strncasecmp(Machine->gamedrv->name, "cueball", 7) == 0));

#if defined(VPINMAME) || defined(LIBPINMAME)

  const UINT8 perc0 = (pmoptions.dmd_perc0  > 0) ? pmoptions.dmd_perc0  : 20;
  const UINT8 perc1 = (pmoptions.dmd_perc33 > 0) ? pmoptions.dmd_perc33 : 33;
  const UINT8 perc2 = (pmoptions.dmd_perc66 > 0) ? pmoptions.dmd_perc66 : 67;
  const UINT8 perc3 = 100;

  static const int levelgts3[16] = {0/*5*/, 30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80, 85, 90, 95, 100}; // GTS3 and AlvinG brightness seems okay
  static const int levelsam[16]  = {0/*5*/, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80, 90, 100}; // SAM brightness seems okay

  const int * const level = (core_gameData->gen & (GEN_SAM|GEN_SPA)) ? levelsam : levelgts3;

  const UINT8 raw_4[4]   = {perc0,perc1,perc2,perc3};
  const UINT8 raw_16[16] = {level[0],level[1],level[2],level[3],level[4],level[5],level[6],level[7],level[8],level[9],level[10],level[11],level[12],level[13],level[14],level[15]};

  UINT32 palette32_4[4];
  UINT32 palette32_16[16];
  unsigned char palette[4][3];

  has_DMD = 1;

  int rStart = 0xFF, gStart = 0xE0, bStart = 0x20;
  if ((pmoptions.dmd_red > 0) || (pmoptions.dmd_green > 0) || (pmoptions.dmd_blue > 0)) {
	  rStart = pmoptions.dmd_red; gStart = pmoptions.dmd_green; bStart = pmoptions.dmd_blue;
  }

  /*-- Autogenerate DMD Color Shades--*/
  palette[0][0] = rStart * perc0 / 100;
  palette[0][1] = gStart * perc0 / 100;
  palette[0][2] = bStart * perc0 / 100;
  palette[1][0] = rStart * perc1 / 100;
  palette[1][1] = gStart * perc1 / 100;
  palette[1][2] = bStart * perc1 / 100;
  palette[2][0] = rStart * perc2 / 100;
  palette[2][1] = gStart * perc2 / 100;
  palette[2][2] = bStart * perc2 / 100;
  palette[3][0] = rStart * perc3 / 100;
  palette[3][1] = gStart * perc3 / 100;
  palette[3][2] = bStart * perc3 / 100;

  /*-- If the "colorize" option is set, use the individual option colors for the shades --*/
  if (pmoptions.dmd_colorize) {
	  if (pmoptions.dmd_red0 > 0 || pmoptions.dmd_green0 > 0 || pmoptions.dmd_blue0 > 0) {
		  palette[0][0] = pmoptions.dmd_red0;
		  palette[0][1] = pmoptions.dmd_green0;
		  palette[0][2] = pmoptions.dmd_blue0;
	  }
	  if (pmoptions.dmd_red33 > 0 || pmoptions.dmd_green33 > 0 || pmoptions.dmd_blue33 > 0) {
		  palette[1][0] = pmoptions.dmd_red33;
		  palette[1][1] = pmoptions.dmd_green33;
		  palette[1][2] = pmoptions.dmd_blue33;
	  }
	  if (pmoptions.dmd_red66 > 0 || pmoptions.dmd_green66 > 0 || pmoptions.dmd_blue66 > 0) {
		  palette[2][0] = pmoptions.dmd_red66;
		  palette[2][1] = pmoptions.dmd_green66;
		  palette[2][2] = pmoptions.dmd_blue66;
	  }
  }

  for (ii = 0; ii < 4; ++ii)
     palette32_4[ii] = (UINT32)palette[ii][0] | (((UINT32)palette[ii][1]) << 8) | (((UINT32)palette[ii][2]) << 16);

  for(ii = 0; ii < 16; ++ii)
     palette32_16[ii] = (rStart*level[ii]/100) | ((gStart*level[ii]/100) << 8) | ((bStart*level[ii]/100) << 16);

  //

  if(layout->length >= 128) // Capcom hack
  {
      g_raw_dmdx = layout->length;
      g_raw_dmdy = layout->start;

      // Strikes N' Spares has 2 standard DMDs
      if (strncasecmp(Machine->gamedrv->name, "snspare", 7) == 0)
      {
          g_raw_dmdy = 64;
          // shift offset into the raw DMDs, depending on which display is updated in here
          if (layout->top != 0)
              raw_dmdoffs = 128 * 32;
          else
              raw_dmdoffs = 0;
      }
  }
#endif

  memset(&coreGlobals.dotCol[layout->start+1][0], 0, sizeof(coreGlobals.dotCol[0][0])*layout->length+1);
  memset(&coreGlobals.dotCol[0][0], 0, sizeof(coreGlobals.dotCol[0][0])*layout->length+1); // clear above
  for (ii = 0; ii < layout->start+1; ii++) {
    BMTYPE *line = (*lines++) + (layout->left*locals.displaySize);
    coreGlobals.dotCol[ii][layout->length] = 0;
    if (ii > 0) {
      for (jj = 0; jj < layout->length; jj++) {
        const UINT8 col = coreGlobals.dotCol[ii][jj];
#if defined(VPINMAME) || defined(LIBPINMAME)
        const int offs = (ii-1)*layout->length + jj;
        currbuffer[offs] = col;
#ifdef LIBPINMAME
        g_raw_dmdbuffer[offs] = (g_fDmdMode == 0) ? (shade_16_enabled ? raw_16[col] : raw_4[col]) : col;
#else
        if(layout->length >= 128) { // Capcom hack
          g_raw_dmdbuffer[offs + raw_dmdoffs] = shade_16_enabled ? raw_16[col] : raw_4[col];
          g_raw_colordmdbuffer[offs + raw_dmdoffs] = shade_16_enabled ? palette32_16[col] : palette32_4[col];
        }
#endif
#endif
        *line++ = shade_16_enabled ? dmdColor[col+63] : dmdColor[col];
        if (locals.displaySize > 1 && jj < layout->length-1)
          *line++ = noaa ? 0 : aaColor[col + coreGlobals.dotCol[ii][jj+1]];
      }
    }
    if (locals.displaySize > 1) {
      int col1 = coreGlobals.dotCol[ii][0] + coreGlobals.dotCol[ii+1][0];
      line = (*lines++) + (layout->left*locals.displaySize);
      for (jj = 0; jj < layout->length; jj++) {
        int col2 = coreGlobals.dotCol[ii][jj+1] + coreGlobals.dotCol[ii+1][jj+1];
        *line++ = noaa ? 0 : aaColor[col1];
        if (jj < layout->length-1)
          *line++ = noaa ? 0 : aaColor[2*(col1 + col2)/5];
        col1 = col2;
      }
    }
  }

  osd_mark_dirty(layout->left*locals.displaySize,layout->top*locals.displaySize,
                 (layout->left+layout->length)*locals.displaySize,(layout->top+layout->start)*locals.displaySize);

#ifdef VPINMAME
  if ((layout->length == 128) || (layout->length == 192) || (layout->length == 256)) { // filter 16x8 output from Flipper Football
	  //external dmd
	  if (g_fShowPinDMD)
	  {
          if (strncasecmp(Machine->gamedrv->name, "snspare", 7) == 0)
          {
              if (layout->top != 0)
                  renderDMDFrame(core_gameData->gen, layout->length, layout->start, currbuffer, g_fDumpFrames, Machine->gamedrv->name, g_raw_gtswpc_dmdframes, g_raw_gtswpc_dmd);
              else
                  render2ndDMDFrame(core_gameData->gen, layout->length, layout->start, currbuffer, g_fDumpFrames, Machine->gamedrv->name, g_raw_gtswpc_dmdframes, g_raw_gtswpc_dmd);
          } else {
              renderDMDFrame(core_gameData->gen, layout->length, layout->start, currbuffer, g_fDumpFrames, Machine->gamedrv->name, g_raw_gtswpc_dmdframes, g_raw_gtswpc_dmd);
              render2ndDMDFrame(core_gameData->gen, layout->length, layout->start, currbuffer, g_fDumpFrames, Machine->gamedrv->name, g_raw_gtswpc_dmdframes, g_raw_gtswpc_dmd);
          }
	  }

	  if (oldbuffer != NULL) { // detect if same frame again
		  if (memcmp(oldbuffer, currbuffer, (layout->length * layout->start)))
		  {
			  g_needs_DMD_update = 1;

			  if ((g_fShowPinDMD && g_fShowWinDMD) || g_fDumpFrames) // output dump frame to .txt
			  {
				  FILE *f;
				  char *ptr;
				  char DumpFilename[MAX_PATH];

				  const DWORD tick = timeGetTime();
#ifndef _WIN64
				  const HINSTANCE hInst = GetModuleHandle("VPinMAME.dll");
#else
				  const HINSTANCE hInst = GetModuleHandle("VPinMAME64.dll");
#endif
				  GetModuleFileName(hInst, DumpFilename, MAX_PATH);
				  ptr = strrchr(DumpFilename, '\\');
				  strcpy_s(ptr + 1, 11, "DmdDump\\");
				  strcat_s(DumpFilename, MAX_PATH, Machine->gamedrv->name);

				  if (g_raw_gtswpc_dmdframes != 0) {
					  FILE* fr;
					  char RawFilename[MAX_PATH];
					  strcpy_s(RawFilename, MAX_PATH, DumpFilename);
					  strcat_s(RawFilename, MAX_PATH, ".raw");
					  fr = fopen(RawFilename, "rb");
					  if (fr) {
						  fclose(fr);
						  fr = fopen(RawFilename, "ab");
					  }
					  else {
						  fr = fopen(RawFilename, "ab");
						  if(fr)
						  {
							  fputc(0x52, fr);
							  fputc(0x41, fr);
							  fputc(0x57, fr);
							  fputc(0x00, fr);
							  fputc(0x01, fr);
							  fputc(layout->length, fr);
							  fputc(layout->start, fr);
							  fputc(g_raw_gtswpc_dmdframes, fr);
						  }
					  }
					  if(fr)
					  {
						  fwrite(&tick, 1, 4, fr);
						  fwrite(g_raw_gtswpc_dmd, 1, (layout->length * layout->start / 8 * g_raw_gtswpc_dmdframes), fr);
						  fclose(fr);
					  }
				  }

				  strcat_s(DumpFilename, MAX_PATH, ".txt");
				  f = fopen(DumpFilename, "a");
				  if (f) {
					  fprintf(f, "0x%08x\n", tick);
					  for (jj = 0; jj < layout->start; jj++) {
						  for (ii = 0; ii < layout->length; ii++)
						  {
							  const UINT8 col = currbuffer[jj*layout->length + ii];
							  fprintf(f, "%01x", col);
						  }
						  fprintf(f, "\n");
					  }
					  fprintf(f, "\n");
					  fclose(f);
				  }
			  }
		  }
	  }

	  g_raw_gtswpc_dmdframes = 0;

	  // swap buffers
	  if (currbuffer == buffer1) {
		  currbuffer = buffer2;
		  oldbuffer = buffer1;
	  }
	  else {
		  currbuffer = buffer1;
		  oldbuffer = buffer2;
	  }
  }
#endif

#ifdef LIBPINMAME
  libpinmame_update_display(g_display_index, layout, g_raw_dmdbuffer);
  g_display_index++;
#endif
}

#ifdef VPINMAME
#  define inRect(r,l,t,w,h) FALSE
#else /* VPINMAME */
INLINE int inRect(const struct rectangle *r, int left, int top, int width, int height) {
  return (r->max_x >= left) && (r->max_y >= top) &&
         (r->min_x <= left + width) && (r->min_y <= top + height);
}
#endif /* VPINMAME */

/*-----------------------------------
/  Generic segment display handler
/------------------------------------*/
static void updateDisplay(struct mame_bitmap *bitmap, const struct rectangle *cliprect,
                          const struct core_dispLayout *layout, int *pos)
{
#if defined(VPINMAME) || defined(LIBPINMAME)
  static UINT16 seg_data[CORE_SEGCOUNT]; // use static, in case a dmddevice.dll keeps the pointers around
  static char seg_dim[CORE_SEGCOUNT];
  static UINT8 disp_num_segs[64]; // actually max seen was 48 so far, but.. // segments per display
  int seg_idx=0;
  UINT16* last_seg_data_ptr = seg_data;
  int total_disp=0;
#endif

  if (layout == NULL) { DBGLOG(("gen_refresh without LCD layout\n")); return; }

#if defined(VPINMAME) || defined(LIBPINMAME)
  memset(seg_data, 0, CORE_SEGCOUNT*sizeof(UINT16));
  memset(seg_dim, 0, CORE_SEGCOUNT*sizeof(char));
  disp_num_segs[0] = 0;
#endif

  for (; layout->length; layout += 1) {
    if (layout->type == CORE_IMPORT)
      { updateDisplay(bitmap, cliprect, layout->lptr, pos); continue; }
    if (layout->fptr)
      if (((ptPinMAMEvidUpdate)(layout->fptr))(bitmap,cliprect,layout) == 0) {
#ifdef LIBPINMAME
        if (layout->type == CORE_VIDEO) {
          libpinmame_update_display(g_display_index, layout, bitmap);
          g_display_index++;
        }
#endif
        continue;
      }
    {
      int left  = layout->left * (locals.segData[layout->type & CORE_SEGMASK].cols+1) / 2;
      int top   = layout->top  * (locals.segData[0].rows + 1) / 2;
      int ii    = layout->length;
      UINT16 *seg     = &coreGlobals.segments[layout->start].w;
      UINT16 *lastSeg = &locals.lastSeg[layout->start].w;
      const int step  = (layout->type & CORE_SEGREV) ? -1 : 1;

#if defined(VPINMAME) || defined(LIBPINMAME)
      disp_num_segs[total_disp++] = ii;
#endif

#ifdef PROC_SUPPORT
      static UINT16 proc_top[16];
      static UINT16 proc_bottom[16];
      int char_width = locals.segData[layout->type & 0x0f].cols+1;
#endif

      if (step < 0) { seg += ii-1; lastSeg += ii-1; }
      while (ii--) {
        UINT16 tmpSeg = *seg;
        int tmpType = layout->type & CORE_SEGMASK;

#ifdef VPINMAME
        //SJE: Force an update of the segments ALWAYS in VPM - corrects Pause Display Bugs
        if(1) {
#else
        if ((tmpSeg != *lastSeg) ||
            inRect(cliprect,left,top,locals.segData[layout->type & CORE_SEGALL].cols,locals.segData[layout->type & CORE_SEGALL].rows)) {
#endif
          tmpSeg >>= (layout->type & CORE_SEGHIBIT) ? 8 : 0;

          switch (tmpType) {

          case CORE_SEG87: case CORE_SEG87F:
            if ((ii > 0) && (ii % 3 == 0)) { // Handle Comma
              if ((tmpType == CORE_SEG87F) && tmpSeg) tmpSeg |= 0x80;
              tmpType = CORE_SEG8;
            } else
              tmpType = CORE_SEG7;
            break;
          case CORE_SEG98: case CORE_SEG98F:
            tmpSeg |= (tmpSeg & 0x100)<<1;
            if ((ii > 0) && (ii % 3 == 0)) { // Handle Comma
              if ((tmpType == CORE_SEG98F) && tmpSeg) tmpSeg |= 0x80;
              tmpType = CORE_SEG10;
            } else
              tmpType = CORE_SEG9;
            break;
          case CORE_SEG9:
            tmpSeg |= (tmpSeg & 0x100)<<1;
            break;
          }
#if defined(VPINMAME) || defined(LIBPINMAME)
          seg_dim[seg_idx] = coreGlobals.segDim[*pos] > 15 ? 15 : coreGlobals.segDim[*pos];
          seg_data[seg_idx++] = tmpSeg;
#endif
          if (!pmoptions.dmd_only || !(layout->fptr || layout->lptr)) {

            drawChar(bitmap,  top, left, tmpSeg, tmpType, coreGlobals.segDim[*pos] > 15 ? 15 : coreGlobals.segDim[*pos]);
#ifdef PROC_SUPPORT
            if (coreGlobals.p_rocEn) {
              if ((core_gameData->gen & (GEN_WPCALPHA_1 | GEN_WPCALPHA_2 | GEN_ALLS11)) &&
                  (!pmoptions.alpha_on_dmd)) {
                switch (top) {
                  case 0: proc_top[left/char_width + (doubleAlpha == 0)] = tmpSeg; break;
                  case 21:  // This is the ball/credit display if fitted, so work out which position
                    if (left == 12) proc_bottom[0] = tmpSeg;
                    else if (left == 24) proc_bottom[8] = tmpSeg;
                    else if (left == 48) proc_top[0] = tmpSeg;
                    else proc_top[8] = tmpSeg;
                    break;
                  default: proc_bottom[left/char_width + (doubleAlpha == 0)] = tmpSeg; break;
                }
              }
            }
#endif
          }
          coreGlobals.drawSeg[*pos] = tmpSeg;
        }
        (*pos)++;
        left += locals.segData[layout->type & CORE_SEGALL].cols+1;
        seg += step; lastSeg += step;
      }
#ifdef PROC_SUPPORT
      if (coreGlobals.p_rocEn) {
        if ((core_gameData->gen & (GEN_WPCALPHA_1 | GEN_WPCALPHA_2 | GEN_ALLS11)) &&
            (!pmoptions.alpha_on_dmd)) {
          procUpdateAlphaDisplay(proc_top, proc_bottom);
        }
      }
#endif 
    }

#ifdef LIBPINMAME
    libpinmame_update_display(g_display_index, layout, last_seg_data_ptr);
    last_seg_data_ptr += layout->length;
    g_display_index++;
#endif
  }

#ifdef VPINMAME
  //alpha frame
  if(g_fShowPinDMD)
    renderAlphanumericFrame(core_gameData->gen, seg_data, seg_dim, total_disp, disp_num_segs, Machine->gamedrv->name);
#endif

#if defined(VPINMAME) || defined(LIBPINMAME)
  // blit segments into a DMD, too (at the moment only to pass easily to VP, e.g. tournament mode verification)

  // Some GTS3 games like Teed Off update both empty alpha and real DMD.   If a DMD frame has been seen, 
  // block this from running.
  if(!has_DMD)
  {
#ifdef LIBPINMAME
    static struct core_dispLayout segDmdDispLayout = { 0, 0, 32, 128, CORE_DMD | CORE_DMDSEG, NULL, NULL };
#endif

    static UINT16 seg_data2[CORE_SEGCOUNT] = {0};
    const layout_t alpha_layout = layoutAlphanumericFrame(core_gameData->gen, seg_data, seg_data2, total_disp, disp_num_segs, Machine->gamedrv->name);

    if (alpha_layout != __Invalid) { // detect if same frame again
      int i;

      g_raw_dmdx = 128;
      g_raw_dmdy = 32;

      //

#ifdef VPINMAME
		memset(AlphaNumericFrameBuffer,0x00,2048);
#endif

#ifdef LIBPINMAME
		memset(AlphaNumericFrameBuffer,0x00,4096);
#endif

		switch (alpha_layout) {
			case __2x16Alpha :
				_2x16Alpha(seg_data);
				break;
			case __2x20Alpha :
				_2x20Alpha(seg_data);
				break;
			case __2x7Alpha_2x7Num :
				_2x7Alpha_2x7Num(seg_data);
				break;
			case __2x7Alpha_2x7Num_4x1Num :
				_2x7Alpha_2x7Num_4x1Num(seg_data);
				break;
			case __2x7Num_2x7Num_4x1Num :
				_2x7Num_2x7Num_4x1Num(seg_data);
				break;
			case __2x7Num_2x7Num_10x1Num :
				_2x7Num_2x7Num_10x1Num(seg_data,seg_data2);
				break;
			case __2x7Num_2x7Num_4x1Num_gen7 :
				_2x7Num_2x7Num_4x1Num_gen7(seg_data);
				break;
			case __2x7Num10_2x7Num10_4x1Num :
				_2x7Num10_2x7Num10_4x1Num(seg_data);
				break;
			case __2x6Num_2x6Num_4x1Num :
				_2x6Num_2x6Num_4x1Num(seg_data);
				break;
			case __2x6Num10_2x6Num10_4x1Num :
				_2x6Num10_2x6Num10_4x1Num(seg_data);
				break;
			case __4x7Num10 :
				_4x7Num10(seg_data);
				break;
			case __6x4Num_4x1Num :
				_6x4Num_4x1Num(seg_data);
				break;
			case __2x7Num_4x1Num_1x16Alpha :
				_2x7Num_4x1Num_1x16Alpha(seg_data);
				break;
			case __1x16Alpha_1x16Num_1x7Num :
				_1x16Alpha_1x16Num_1x7Num(seg_data);
				break;
			case __1x7Num_1x16Alpha_1x16Num :
				_1x7Num_1x16Alpha_1x16Num(seg_data);
				break;
			case __1x16Alpha_1x16Num_1x7Num_1x4Num :
				_1x16Alpha_1x16Num_1x7Num_1x4Num(seg_data);
				break;
			default:
				break;
		}

#ifdef VPINMAME
		for (i = 0; i < 512; ++i) {
			currbuffer[(i*8)]   = AlphaNumericFrameBuffer[i]    & 0x01 | AlphaNumericFrameBuffer[i+512]<<1 & 0x02 | AlphaNumericFrameBuffer[i+1024]<<2 & 0x04 | AlphaNumericFrameBuffer[i+1536]<<3 & 0x08;
			currbuffer[(i*8)+1] = AlphaNumericFrameBuffer[i]>>1 & 0x01 | AlphaNumericFrameBuffer[i+512]    & 0x02 | AlphaNumericFrameBuffer[i+1024]<<1 & 0x04 | AlphaNumericFrameBuffer[i+1536]<<2 & 0x08;
			currbuffer[(i*8)+2] = AlphaNumericFrameBuffer[i]>>2 & 0x01 | AlphaNumericFrameBuffer[i+512]>>1 & 0x02 | AlphaNumericFrameBuffer[i+1024]    & 0x04 | AlphaNumericFrameBuffer[i+1536]<<1 & 0x08;
			currbuffer[(i*8)+3] = AlphaNumericFrameBuffer[i]>>3 & 0x01 | AlphaNumericFrameBuffer[i+512]>>2 & 0x02 | AlphaNumericFrameBuffer[i+1024]>>1 & 0x04 | AlphaNumericFrameBuffer[i+1536]    & 0x08;
			currbuffer[(i*8)+4] = AlphaNumericFrameBuffer[i]>>4 & 0x01 | AlphaNumericFrameBuffer[i+512]>>3 & 0x02 | AlphaNumericFrameBuffer[i+1024]>>2 & 0x04 | AlphaNumericFrameBuffer[i+1536]>>1 & 0x08;
			currbuffer[(i*8)+5] = AlphaNumericFrameBuffer[i]>>5 & 0x01 | AlphaNumericFrameBuffer[i+512]>>4 & 0x02 | AlphaNumericFrameBuffer[i+1024]>>3 & 0x04 | AlphaNumericFrameBuffer[i+1536]>>2 & 0x08;
			currbuffer[(i*8)+6] = AlphaNumericFrameBuffer[i]>>6 & 0x01 | AlphaNumericFrameBuffer[i+512]>>5 & 0x02 | AlphaNumericFrameBuffer[i+1024]>>4 & 0x04 | AlphaNumericFrameBuffer[i+1536]>>3 & 0x08;
			currbuffer[(i*8)+7] = AlphaNumericFrameBuffer[i]>>7 & 0x01 | AlphaNumericFrameBuffer[i+512]>>6 & 0x02 | AlphaNumericFrameBuffer[i+1024]>>5 & 0x04 | AlphaNumericFrameBuffer[i+1536]>>4 & 0x08;
		}

      //

      if (oldbuffer != NULL && memcmp(oldbuffer, currbuffer, g_raw_dmdx*g_raw_dmdy))
      {
        for (i = 0; i < g_raw_dmdx*g_raw_dmdy; ++i)
          g_raw_dmdbuffer[i] = (UINT8)((int)currbuffer[i]*100/15);
        g_needs_DMD_update = 1;
      }

      // swap buffers
      if (currbuffer == buffer1) {
        currbuffer = buffer2;
        oldbuffer = buffer1;
      }
      else {
        currbuffer = buffer1;
        oldbuffer = buffer2;
      }
#endif

#ifdef LIBPINMAME
      libpinmame_update_display(g_display_index, &segDmdDispLayout, AlphaNumericFrameBuffer);
      g_display_index++;
#endif
    }
#ifdef LIBPINMAME
    else {
      libpinmame_update_display(g_display_index, &segDmdDispLayout, NULL);
      g_display_index++;
    }
#endif
  }
#endif
}

VIDEO_UPDATE(core_gen) {
  int count = 0;

#ifdef PROC_SUPPORT
  int alpha = (core_gameData->gen & (GEN_WPCALPHA_1|GEN_WPCALPHA_2|GEN_ALLS11)) != 0;
  if (coreGlobals.p_rocEn) {
    if (pmoptions.alpha_on_dmd && alpha) {
      procClearDMD();
    }
  }
  // If we don't want the DMD displayed on the screen, skip this code
  if (pmoptions.virtual_dmd) {
#endif

#ifdef LIBPINMAME
  g_display_index = 0;
#endif

  updateDisplay(bitmap, cliprect, core_gameData->lcdLayout, &count);
  memcpy(locals.lastSeg, coreGlobals.segments, sizeof(locals.lastSeg));
#ifdef PROC_SUPPORT
  }
  if (coreGlobals.p_rocEn) {
    if (pmoptions.alpha_on_dmd && alpha) {
      procUpdateDMD();
    }
  }
#endif

  video_update_core_status(bitmap,cliprect);
}

/*---------------------
/  Update all switches
/----------------------*/
void core_updateSw(int flipEn) {
  /*-- handle flippers--*/
  const int flip = core_gameData->hw.flippers;
  const int flipSwCol = (core_gameData->gen & (GEN_GTS3 | GEN_SPA | GEN_ALVG | GEN_ALVG_DMD2 | GEN_WICO)) ? 15 : CORE_FLIPPERSWCOL;
  int inports[CORE_MAXPORTS];
  UINT8 swFlip;
  int ii;

  if (g_fHandleKeyboard) {

    for (ii = 0; ii < CORE_COREINPORT+(coreData->coreDips+31)/16; ii++)
      inports[ii] = readinputport(ii);


    /*-- buttons --*/
    swFlip = 0;
    if (inports[CORE_FLIPINPORT] & CORE_LLFLIPKEY) swFlip |= CORE_SWLLFLIPBUTBIT;
    if (inports[CORE_FLIPINPORT] & CORE_LRFLIPKEY) swFlip |= CORE_SWLRFLIPBUTBIT;
    if (locals.flipMask & CORE_SWULFLIPBUTBIT) {    /* have UL switch */
      if (flip & FLIP_BUT(FLIP_UL))
        { if (inports[CORE_FLIPINPORT] & CORE_ULFLIPKEY) swFlip |= CORE_SWULFLIPBUTBIT; }
      else
        { if (inports[CORE_FLIPINPORT] & CORE_LLFLIPKEY) swFlip |= CORE_SWULFLIPBUTBIT; }
    }
    if (locals.flipMask & CORE_SWURFLIPBUTBIT) {    /* have UR switch */
      if (flip & FLIP_BUT(FLIP_UR))
        { if (inports[CORE_FLIPINPORT] & CORE_URFLIPKEY) swFlip |= CORE_SWURFLIPBUTBIT; }
      else
        { if (inports[CORE_FLIPINPORT] & CORE_LRFLIPKEY) swFlip |= CORE_SWURFLIPBUTBIT; }
    }
  }
  else
    swFlip = (coreGlobals.swMatrix[flipSwCol] ^ coreGlobals.invSw[flipSwCol]) & (CORE_SWULFLIPBUTBIT|CORE_SWURFLIPBUTBIT|CORE_SWLLFLIPBUTBIT|CORE_SWLRFLIPBUTBIT);

#ifdef PROC_SUPPORT
  /*-- Only handle flipper switches if we're not in a real game, otherwise they --*/
  /*-- will get physically activated anyway */
  if (!coreGlobals.p_rocEn) {
#endif

    /*-- set switches in matrix for non-fliptronic games --*/
    if (FLIP_SWL(flip)) core_setSw(FLIP_SWL(flip), swFlip & CORE_SWLLFLIPBUTBIT);
    if (FLIP_SWR(flip)) core_setSw(FLIP_SWR(flip), swFlip & CORE_SWLRFLIPBUTBIT);
#ifdef PROC_SUPPORT
  }
#endif

  /*-- fake solenoids if not CPU controlled --*/
  if ((flip & FLIP_SOL(FLIP_L)) == 0) {
    coreGlobals.solenoids2 &= 0xffffff00;
    if (flipEn) {
      if (swFlip & CORE_SWLLFLIPBUTBIT) coreGlobals.solenoids2 |= CORE_LLFLIPSOLBITS;
      if (swFlip & CORE_SWLRFLIPBUTBIT) coreGlobals.solenoids2 |= CORE_LRFLIPSOLBITS;
    }
  }

  /*-- EOS switches --*/
  if (locals.flipMask & CORE_SWULFLIPEOSBIT) {
    if (core_getSol(sULFlip)) locals.flipTimer[0] += 1;
    else                      locals.flipTimer[0] = 0;
    if (locals.flipTimer[0] >= CORE_FLIPSTROKETIME) swFlip |= CORE_SWULFLIPEOSBIT;
  }
  if (locals.flipMask & CORE_SWURFLIPEOSBIT) {
    if (core_getSol(sURFlip)) locals.flipTimer[1] += 1;
    else                      locals.flipTimer[1] = 0;
    if (locals.flipTimer[1] >= CORE_FLIPSTROKETIME) swFlip |= CORE_SWURFLIPEOSBIT;
  }
  if (locals.flipMask & CORE_SWLLFLIPEOSBIT) {
    if (core_getSol(sLLFlip)) locals.flipTimer[2] += 1;
    else                      locals.flipTimer[2] = 0;
    if (locals.flipTimer[2] >= CORE_FLIPSTROKETIME) swFlip |= CORE_SWLLFLIPEOSBIT;
  }
  if (locals.flipMask & CORE_SWLRFLIPEOSBIT) {
    if (core_getSol(sLRFlip)) locals.flipTimer[3] += 1;
    else                      locals.flipTimer[3] = 0;
    if (locals.flipTimer[3] >= CORE_FLIPSTROKETIME) swFlip |= CORE_SWLRFLIPEOSBIT;
  }
  coreGlobals.swMatrix[flipSwCol] = (coreGlobals.swMatrix[flipSwCol]         & ~locals.flipMask) |
                                    ((swFlip ^ coreGlobals.invSw[flipSwCol]) &  locals.flipMask);

  /*-- update core dependent switches --*/
  if (coreData->updSw)  coreData->updSw(g_fHandleKeyboard ? inports : NULL);

  /*-- update game dependent switches --*/
  if (g_fHandleMechanics) {
    if (core_gameData->hw.handleMech) core_gameData->hw.handleMech(g_fHandleMechanics);
  }
  /*-- Run simulator --*/
  if (coreGlobals.simAvail)
    sim_run(inports, CORE_COREINPORT+(coreData->coreDips+31)/16,
            (inports[CORE_SIMINPORT] & SIM_SWITCHKEY) == 0,
            (SIM_BALLS(inports[CORE_SIMINPORT])));
  { /*-- check changed solenoids --*/
    UINT64 allSol = core_getAllSol();
    UINT64 chgSol = (allSol ^ coreGlobals.lastSol) & vp_getSolMask64();

#ifdef LIBPINMAME
    int start = 0, end = CORE_FIRSTCUSTSOL+core_gameData->hw.custSol-1;

    if (options.usemodsol)
    {
       for(ii = 0; ii<CORE_MODSOL_MAX; ii++)
       {
          if (ii==40)
             ii=CORE_FIRSTCUSTSOL-1;

          if (coreGlobals.lastModSol[ii] != coreGlobals.modulatedSolenoids[CORE_MODSOL_CUR][ii])
          {
             coreGlobals.lastModSol[ii] = coreGlobals.modulatedSolenoids[CORE_MODSOL_CUR][ii];
             OnSolenoid(ii+1, coreGlobals.lastModSol[ii]);
          }
       }
       // Treat the VPM reserved solenoids the old way. 
       start = 40;
       end = CORE_FIRSTCUSTSOL-1;
       chgSol >>= start;
       allSol >>= start;
    }

    for (ii = start; ii < end; ii++) 
    {
       if (chgSol & 0x01)
          OnSolenoid(ii+1, allSol & 0x01);

       chgSol >>= 1;
       allSol >>= 1;
    }

    allSol = core_getAllSol();
    chgSol = (allSol ^ coreGlobals.lastSol) & vp_getSolMask64();
#endif

    if (chgSol) {
      coreGlobals.lastSol = allSol;
      for (ii = 1; ii < CORE_FIRSTCUSTSOL+core_gameData->hw.custSol; ii++) {
        if (chgSol & 0x01) {
          /*-- solenoid has changed state --*/

#ifndef LIBPINMAME
          OnSolenoid(ii, allSol & 0x01);
#endif
          /*-- log solenoid number on the display (except flippers) --*/
          if ((!pmoptions.dmd_only && (allSol & 0x01)) &&
              ((ii < CORE_FIRSTLFLIPSOL) || (ii >= CORE_FIRSTSIMSOL))) {
            locals.solLog[locals.solLogCount] = ii;
            core_textOutf(Machine->visible_area.max_x - 12*8,0,BLACK,"%2d %2d %2d %2d",
              locals.solLog[(locals.solLogCount+1) & 3],
              locals.solLog[(locals.solLogCount+2) & 3],
              locals.solLog[(locals.solLogCount+3) & 3],
              locals.solLog[(locals.solLogCount+0) & 3]);
            locals.solLogCount = (locals.solLogCount + 1) & 3;
          }
#ifdef ENABLE_MECHANICAL_SAMPLES
          if (coreGlobals.soundEn)
            proc_mechsounds(ii, allSol & 0x01);
#endif
        }
        chgSol >>= 1;
        allSol >>= 1;
      }
    }
  }

  /*-- check if we should use simulator keys --*/
  if (g_fHandleKeyboard &&
      (!coreGlobals.simAvail || inports[CORE_SIMINPORT] & SIM_SWITCHKEY)) {
    /*-- simulator keys disabled, use row+column keys --*/

    static int lastRow = 0, lastCol = 0;
    int row = 0, col = 0;
#ifdef MAME_DEBUG
    if (keyboard_pressed(KEYCODE_Z)) col = 9;
    if (keyboard_pressed(KEYCODE_X)) col = 10;
    if (keyboard_pressed(KEYCODE_C)) col = 11;
    if (keyboard_pressed(KEYCODE_V)) col = 12;
#endif
    if (!col && (((inports[CORE_MANSWINPORT] & CORE_MANSWCOLUMNS) == 0) ||
        ((inports[CORE_MANSWINPORT] & CORE_MANSWROWS) == 0)))
      lastRow = lastCol = 0;
    else {
      int bit = 0x0101;

      for (ii = 0; ii < 8; ii++) {
        if (inports[CORE_MANSWINPORT] & CORE_MANSWCOLUMNS & bit) col = ii+1;
        if (inports[CORE_MANSWINPORT] & CORE_MANSWROWS    & bit) row = ii+1;
        bit <<= 1;
      }
      if ((col != lastCol) || (row != lastRow)) {
        coreGlobals.swMatrix[col] ^= (1<<(row-1));
        lastCol = col; lastRow = row;
      }
    }
  }

#ifdef MAME_DEBUG /* Press W and E at the same time to insert a mark in logfile */
  if (g_fHandleKeyboard && ((inports[CORE_MANSWINPORT] & 0x06) == 0x06))
    logerror("\nLogfile Mark\n");
#endif /* MAME_DEBUG */
}

/*--------------------------
/ Write text on the screen
/---------------------------*/
void core_textOut(char *buf, int length, int x, int y, int color) {
  if (y < locals.maxSimRows) {
    int ii;

    const int l = (int)strlen(buf);
    for (ii = 0; ii < length; ii++) {
      const char c = (ii >= l) ? ' ' : buf[ii];

      drawgfx(Machine->scrbitmap, Machine->uifont, c, color-1, 0, 0,
              x + ii * Machine->uifont->width, y+locals.firstSimRow, 0,
              TRANSPARENCY_NONE, 0);
    }
  }
}

/*-----------------------------------
/ Write formatted text on the screen
/------------------------------------*/
void CLIB_DECL core_textOutf(int x, int y, int color, const char *text, ...) {
  va_list arg;
  if (y < locals.maxSimRows) {
    char buf[100];
    char *bufPtr = buf;

    va_start(arg, text); vsprintf(buf, text, arg); va_end(arg);

    while (*bufPtr) {
      drawgfx(Machine->scrbitmap, Machine->uifont, *bufPtr++, color-1, 0, 0,
              x, y+locals.firstSimRow, 0, TRANSPARENCY_NONE, 0);
      x += Machine->uifont->width;
    }
  }
}

/*--------------------------------------------
/ Draw status display
/ Lamps, Switches, Solenoids, Diagnostic LEDs
/---------------------------------------------*/
static VIDEO_UPDATE(core_status) {
  BMTYPE **lines = (BMTYPE **)bitmap->line;
  int startRow = 0, nextCol = 0, thisCol = 0;
  int ii, jj, bits;
  BMTYPE dotColor[2];

  /*-- anything to do ? --*/
  if ((pmoptions.dmd_only) || (locals.maxSimRows < 16) ||
      (coreGlobals.soundEn && (!manual_sound_commands(bitmap))))
    return;

  dotColor[0] = CORE_COLOR(COL_DMDOFF); dotColor[1] = CORE_COLOR(COL_DMDON);
  /*--  Draw lamps --*/
  if ((core_gameData->hw.lampData) &&
      (startRow + core_gameData->hw.lampData->startpos.x + core_gameData->hw.lampData->size.x < locals.maxSimRows)) {
    core_tLampDisplay *drawData = core_gameData->hw.lampData;
    const int startx = drawData->startpos.x;
    const int starty = drawData->startpos.y + thisCol;
    BMTYPE **line = &lines[locals.firstSimRow + startRow + startx];
    int num = 0;

    for (ii = 0; ii < CORE_CUSTLAMPCOL+core_gameData->hw.lampCol; ii++) {
      bits = coreGlobals.lampMatrix[ii];

      for (jj = 0; jj < 8; jj++) {
        int qq;
        for (qq = 0; qq < drawData->lamps[num].totnum; qq++) {
          const int color = drawData->lamps[num].lamppos[qq].color;
          const int lampx = drawData->lamps[num].lamppos[qq].x;
          const int lampy = drawData->lamps[num].lamppos[qq].y;
          line[lampx][starty + lampy] = CORE_COLOR((bits & 0x01) ? color : COL_SHADE(color));
        }
        bits >>= 1;
        num++;
      }
    }
    osd_mark_dirty(starty,  locals.firstSimRow + startRow + startx,
                   starty + drawData->size.y,
                   locals.firstSimRow + startRow + startx + drawData->size.x);
    startRow += startx + drawData->size.x;
    if (starty + drawData->size.y > nextCol) nextCol = starty + drawData->size.y;
  }
  /*-- Default square lamp matrix layout --*/
  else {
    for (ii = 0; ii < CORE_CUSTLAMPCOL + core_gameData->hw.lampCol; ii++) {
      BMTYPE **line = &lines[locals.firstSimRow + startRow];
      bits = coreGlobals.lampMatrix[ii];

      for (jj = 0; jj < 8; jj++) {
        line[0][thisCol + ii*2] = dotColor[bits & 0x01];
        line += 2; bits >>= 1;
      }
    }
    osd_mark_dirty(thisCol, locals.firstSimRow + startRow, thisCol + ii*2 ,locals.firstSimRow + startRow + 16);
    startRow += 16; if (thisCol + ii*2 > nextCol) nextCol = thisCol + ii*2;
  } /* else */

  /* Draw the switches */
  startRow += 3;
  if (startRow + 16 >= locals.maxSimRows) { startRow = 0; thisCol = nextCol + 5; }

  for (ii = 0; ii < CORE_CUSTSWCOL+core_gameData->hw.swCol; ii++) {
    BMTYPE **line = &lines[locals.firstSimRow + startRow];
    bits = coreGlobals.swMatrix[ii];

    for (jj = 0; jj < 8; jj++) {
      line[0][thisCol + ii*2] = dotColor[bits & 0x01];
      line += 2; bits >>= 1;
    }
  }
  osd_mark_dirty(thisCol, locals.firstSimRow + startRow, thisCol + ii*2, locals.firstSimRow + startRow + 16);
  startRow += 16; if (thisCol + ii*2 > nextCol) nextCol = thisCol + ii*2;

  /* Draw Solenoids and Flashers */
  startRow += 3;

  if (startRow + 16 >= locals.maxSimRows) { startRow = 0; thisCol = nextCol + 5; }

  {
    BMTYPE **line = &lines[locals.firstSimRow + startRow];
    UINT64 allSol = core_getAllSol();
    for (ii = 0; ii < CORE_FIRSTCUSTSOL+core_gameData->hw.custSol; ii++) {
      line[(ii/8)*2][thisCol + (ii%8)*2] = dotColor[allSol & 0x01];
      allSol >>= 1;
    }
    osd_mark_dirty(thisCol, locals.firstSimRow + startRow, thisCol + 16,
        locals.firstSimRow + startRow + 16);
    startRow += 16; if (thisCol + 16 > nextCol) nextCol = thisCol + 16;
  }

  /*-- draw diagnostic LEDs     --*/
  startRow += 3;

  if (startRow + 16 >= locals.maxSimRows) { startRow = 0; thisCol = nextCol; }

  if (coreData->diagLEDs == 0xff) { /* 7 SEG */
    drawChar(bitmap, locals.firstSimRow + startRow, thisCol, coreGlobals.diagnosticLed, CORE_SEG7, 0);
    startRow += 16; if (thisCol + 12 > nextCol) nextCol = thisCol + 12;
  }
  else {
    BMTYPE **line = &lines[locals.firstSimRow + startRow];
    bits = coreGlobals.diagnosticLed;

    // Draw LEDS Vertically
    if (coreData->diagLEDs & DIAGLED_VERTICAL) {
      for (ii = 0; ii < (coreData->diagLEDs & ~DIAGLED_VERTICAL); ii++) {
        line[0][thisCol + 3] = dotColor[bits & 0x01];
	line += 2; bits >>= 1;
      }
      osd_mark_dirty(thisCol + 3, locals.firstSimRow + startRow, thisCol + 4, locals.firstSimRow + startRow + ii*2);
      startRow += ii*2; if (thisCol + 4 > nextCol) nextCol = thisCol + 4;
    }
    else { // Draw LEDS Horizontally
      for (ii = 0; ii < coreData->diagLEDs; ii++) {
	line[0][thisCol + ii*2] = dotColor[bits & 0x01];
        bits >>= 1;
      }
      osd_mark_dirty(thisCol, locals.firstSimRow + startRow, thisCol + ii*2, locals.firstSimRow + startRow + 1);
      startRow += 1; if (thisCol + ii*2 > nextCol) nextCol = thisCol + ii*2;
    }
  }
  /*-- GI Strings --*/
  if (core_gameData->gen & GEN_ALLWPC) {
    startRow += 3;
    if (startRow + 2 >= locals.maxSimRows) { startRow = 0; thisCol = nextCol + 5; }

    for (ii = 0; ii < CORE_MAXGI; ii++)
	{
	  if(coreGlobals.gi[ii]==8)
		lines[locals.firstSimRow + startRow][thisCol + ii*2] = dotColor[1];
	  else
		lines[locals.firstSimRow + startRow][thisCol + ii*2] = 64+(coreGlobals.gi[ii]<<1);
	}
    osd_mark_dirty(thisCol, locals.firstSimRow + startRow, thisCol + ii*2, locals.firstSimRow + startRow + 1);
  }
  if (coreGlobals.simAvail) sim_draw(locals.firstSimRow);
  /*-- draw game specific mechanics --*/
  if (core_gameData->hw.drawMech) core_gameData->hw.drawMech((void *)&bitmap->line[locals.firstSimRow]);
}

/*-- lamp handling --*/
void core_setLamp(UINT8 *lampMatrix, int col, int row) {
  while (col) {
    if (col & 0x01) *lampMatrix |= row;
    col >>= 1;
    lampMatrix += 1;
  }
}
void core_setLampBlank(UINT8 *lampMatrix, int col, int row) {
  while (col) {
    if (col & 0x01) *lampMatrix = row;
    col >>= 1;
    lampMatrix += 1;
  }
}

/*-- "normal" switch/lamp numbering (1-64) --*/
int core_swSeq2m(int no) { return no+7; }
int core_m2swSeq(int col, int row) { return col*8+row-7; }

/*------------------------------------------
/  Read the current switch value
/
/  This function returns TRUE for active
/  switches even if the switch is active low.
/-------------------------------------------*/
int core_getSw(int swNo) {
  if (coreData->sw2m) swNo = coreData->sw2m(swNo); else swNo = (swNo/10)*8+(swNo%10-1);
  return (coreGlobals.swMatrix[swNo/8] ^ coreGlobals.invSw[swNo/8]) & (1<<(swNo%8));
}

int core_getSwCol(int colEn) {
  int ii = 1;
  if (colEn) {
    while ((colEn & 0x01) == 0) {
      colEn >>= 1;
      ii++;
    }
  }
  return coreGlobals.swMatrix[ii];
}

/*----------------------
/  Set/reset a switch
/-----------------------*/
void core_setSw(int swNo, int value) {
  if (coreData->sw2m) swNo = coreData->sw2m(swNo); else swNo = (swNo/10)*8+(swNo%10-1);
  //fprintf(stderr,"\nPinmame switch %d",swNo);
  coreGlobals.swMatrix[swNo/8] &= ~(1<<(swNo%8)); /* clear the bit first */
#ifdef PROC_SUPPORT
	if (coreGlobals.p_rocEn) {
		coreGlobals.swMatrix[swNo/8] |=  ((value ? 0xff : 0) ^ 0) & (1<<(swNo%8));
	} else {
#endif

  coreGlobals.swMatrix[swNo/8] |=  ((value ? 0xff : 0) ^ coreGlobals.invSw[swNo/8]) & (1<<(swNo%8));
#ifdef PROC_SUPPORT
	}
#endif
}

/*-------------------------
/  update active low/high
/-------------------------*/
void core_updInvSw(int swNo, int inv) {
  int bit;
  if (coreData->sw2m) swNo = coreData->sw2m(swNo); else swNo = (swNo/10)*8+(swNo%10-1);
  bit = (1 << (swNo%8));

  if (inv)
    inv = bit;
  if ((coreGlobals.invSw[swNo/8] ^ inv) & bit) {
    coreGlobals.invSw[swNo/8] ^= bit;
    coreGlobals.swMatrix[swNo/8] ^= bit;
  }
}

/*-------------------------------------
/  Read the status of a solenoid
/  For the standard solenoids this is
/  the "smoothed" value
/--------------------------------------*/
int core_getSol(int solNo) {
  if (solNo <= 28)
    return coreGlobals.solenoids & CORE_SOLBIT(solNo);
  else if (solNo <= 32) { // 29-32
    if (core_gameData->gen & GEN_ALLS11)
      return coreGlobals.solenoids & CORE_SOLBIT(solNo);
    else if (core_gameData->gen & GEN_ALLWPC) // GI circuits
      return coreGlobals.solenoids2 & (1<<(solNo-29+8)); // GameOn
  }
  else if (solNo <= 36) { // 33-36 Upper flipper (WPC only)
    if (core_gameData->gen & GEN_ALLWPC) {
      int mask;
      /*-- flipper coils --*/
      if      ((solNo == sURFlip) && (core_gameData->hw.flippers & FLIP_SOL(FLIP_UR)))
        mask = CORE_URFLIPSOLBITS;
      else if ((solNo == sULFlip) && (core_gameData->hw.flippers & FLIP_SOL(FLIP_UL)))
        mask = CORE_ULFLIPSOLBITS;
      else
        mask = 1<<(solNo - 33 + 4);
      return coreGlobals.solenoids2 & mask;
    }
  }
  else if (solNo <= 44) { // 37-44 WPC95 & S11 extra
    if (core_gameData->gen & (GEN_WPC95|GEN_WPC95DCS))
      return coreGlobals.solenoids & (1<<((solNo - 13)|4));
    if (core_gameData->gen & GEN_ALLS11)
      return coreGlobals.solenoids2 & (1<<(solNo - 37 + 8));
  }
  else if (solNo <= 48) { // 45-48 Lower flippers
    int mask = 1<<(solNo - 45);
    /*-- Game must have lower flippers but for symmetry we check anyway --*/
    if      ((solNo == sLRFlip) /*&& (core_gameData->hw.flippers & FLIP_SOL(FLIP_LR))*/)
      mask = CORE_LRFLIPSOLBITS;
    else if ((solNo == sLLFlip) /*&& (core_gameData->hw.flippers & FLIP_SOL(FLIP_LL))*/)
      mask = CORE_LLFLIPSOLBITS;
    return coreGlobals.solenoids2 & mask;
  }
  else if (solNo <= 50) // 49-50 simulated
    return sim_getSol(solNo);
  else if (core_gameData->hw.getSol)
    return core_gameData->hw.getSol(solNo);
  return 0;
}

/*-------------------------------------
/  Read the instant status of a solenoid
/--------------------------------------*/
int core_getPulsedSol(int solNo) {
  if (solNo <= 32)
    return coreGlobals.pulsedSolState & CORE_SOLBIT(solNo);
  else if ((core_gameData->gen & (GEN_WPC95|GEN_WPC95DCS)) && (solNo >= 37) && (solNo <= 44))
    // This is a little messy. Pulsed state is in 29-32 but 29-32 non pulsed is GameOn sol
    return coreGlobals.pulsedSolState & (1<<((solNo-13)|4));
  return core_getSol(solNo); /* sol is not smoothed anyway */
}

/*-------------------------------------------------
/  Get the value of all solenoids in one variable
/--------------------------------------------------*/
UINT64 core_getAllSol(void) {
  UINT64 sol = coreGlobals.solenoids;
  if (core_gameData->gen & GEN_ALLWPC) // 29-32 GameOn
    sol = (sol & 0x0fffffff) | ((coreGlobals.solenoids2 & 0x0f00)<<20);
  if (core_gameData->gen & (GEN_WPC95|GEN_WPC95DCS)) { // 37-44 WPC95 extra
    UINT64 tmp = coreGlobals.solenoids & 0xf0000000;
    sol |= (tmp<<12)|(tmp<<8);
  }
  if (core_gameData->gen & (GEN_ALLS11|GEN_SAM|GEN_SPA)) // 37-44 S11, SAM extra
    sol |= ((UINT64)(coreGlobals.solenoids2 & 0xff00))<<28;
  { // 33-36, 45-48 flipper solenoids
    UINT8 lFlip = (coreGlobals.solenoids2 & (CORE_LRFLIPSOLBITS|CORE_LLFLIPSOLBITS));
    UINT8 uFlip = (coreGlobals.solenoids2 & (CORE_URFLIPSOLBITS|CORE_ULFLIPSOLBITS));
    // hold coil is set if either coil is set
    lFlip = lFlip | ((lFlip & 0x05)<<1);
    if (core_gameData->hw.flippers & FLIP_SOL(FLIP_UR))
      uFlip = uFlip | ((uFlip & 0x10)<<1);
    if (core_gameData->hw.flippers & FLIP_SOL(FLIP_UL))
      uFlip = uFlip | ((uFlip & 0x40)<<1);
    sol |= (((UINT64)lFlip)<<44) | (((UINT64)uFlip)<<28);
  }
  /*-- simulated --*/
  sol |= sim_getSol(49) ? (((UINT64)1)<<48) : 0;
  /*-- custom --*/
  if ( core_gameData->hw.getSol ) {
    UINT64 bit = ((UINT64)1)<<(CORE_FIRSTCUSTSOL-1);
    int ii;

    for (ii = 0; ii < core_gameData->hw.custSol; ii++) {
      sol |= core_gameData->hw.getSol(CORE_FIRSTCUSTSOL + ii) ? bit : 0;
      bit <<= 1;
    }
  }
  return sol;
}

/*---------------------------------------
/  Get the status of a DIP bank (8 dips)
/-----------------------------------------*/
int core_getDip(int dipBank) {
#ifdef VPINMAME
  return vp_getDIP(dipBank);
#else /* VPINMAME */
  return (readinputport(CORE_COREINPORT+1+dipBank/2)>>((dipBank & 0x01)*8))&0xff;
#endif /* VPINMAME */
}

/*--------------------
/   Draw a LED digit
/---------------------*/
static void drawChar(struct mame_bitmap *bitmap, int row, int col, UINT32 bits, int type, int dimming) {
  const tSegData *s = &locals.segData[type];
  int palSize = sizeof(core_palette)/3;
  UINT32 pixel[21] = {0};
  int kk,ll;
  int pens[4][4] = {{             0, palSize-1-dimming, palSize-17-dimming, palSize-33-dimming },
                    { COL_DMDOFF,    palSize-1-dimming, palSize-17-dimming, palSize-33-dimming },
                    { COL_SEGAAOFF1, palSize-1-dimming, palSize-17-dimming, palSize-33-dimming },
                    { COL_SEGAAOFF2, palSize-1-dimming, palSize-17-dimming, palSize-33-dimming }};

  for (kk = 1; bits; kk++, bits >>= 1) {
    if (bits & 0x01) {
#ifdef PROC_SUPPORT
			if (coreGlobals.p_rocEn) {
				if (pmoptions.alpha_on_dmd) {
                                    	/* Draw alphanumeric segments on the DMD */
                                    switch (row) {
                                        case 0:
                                            procDrawSegment(col/2, 3, kk-1);
                                            break;
                                        case 21:
                                            // This is the ball/credit display on older Sys11
                                            // Push through an 11 as the row
                                            // number, the display routine will
                                            // take care of repositioning
                                            procDrawSegment(col/2,11,kk-1);
                                            break;
                                        case 42:
                                            procDrawSegment(col/2, 19, kk-1);
                                                break;
                                        default:
                                            break;

					}
				}
			}
#endif
      for (ll = 0; ll < s->rows; ll++)
        pixel[ll] |= s->segs[ll][kk];
    }
  }
  for (kk = 0; kk < s->rows; kk++) {
    BMTYPE * __restrict line = &((BMTYPE **)(bitmap->line))[row+kk][col + s->cols];
    // why don't the bitmap use the leftmost bits. i.e. size is limited to 15
    UINT32 p = pixel[kk]>>(30-2*s->cols), np = s->segs[kk][0]>>(30-2*s->cols);

    for (ll = 0; ll < s->cols; ll++, p >>= 2, np >>= 2)
      *(--line) = CORE_COLOR(pens[np & 0x03][p & 0x03]);
  }
  osd_mark_dirty(col,row,col+s->cols,row+s->rows);
}

/*----------------------
/  Initialize PinMAME
/-----------------------*/
static MACHINE_INIT(core) {
#ifdef PROC_SUPPORT
  char * yaml_filename = pmoptions.p_roc;
#endif

  if (!coreData) { // first time
    /*-- init variables --*/
    memset(&coreGlobals, 0, sizeof(coreGlobals));
    memset(&locals, 0, sizeof(locals));
    memset(&locals.lastSeg, -1, sizeof(locals.lastSeg));
    coreData = (struct pinMachine *)&Machine->drv->pinmame;
    //-- initialise timers --
    if (coreData->timers[0].callback) {
      int ii;
      for (ii = 0; ii < 5; ii++) {
        if (coreData->timers[ii].callback) {
          locals.timers[ii] = timer_alloc(coreData->timers[ii].callback);
          if (coreData->timers[ii].rate > 0.) {
            timer_adjust(locals.timers[ii], TIME_IN_HZ(coreData->timers[ii].rate), 0, TIME_IN_HZ(coreData->timers[ii].rate));
          } else { // negative = fractional hz value, e.g. as usec
            timer_adjust(locals.timers[ii], TIME_IN_USEC(-coreData->timers[ii].rate), 0, TIME_IN_USEC(-coreData->timers[ii].rate));
          }
        }
      }
    }
    /*-- init switch matrix --*/
    memcpy(coreGlobals.invSw, core_gameData->wpc.invSw, sizeof(core_gameData->wpc.invSw));
    memcpy(coreGlobals.swMatrix, coreGlobals.invSw, sizeof(coreGlobals.invSw));
    /*-- init bulb LUTs --*/
    bulb_init();
#ifdef PROC_SUPPORT
    /*-- P-ROC operation requires a YAML.  Disable P-ROC operation
     * if no YAML is specified. --*/

    coreGlobals.p_rocEn = strcmp(yaml_filename, "None") != 0;
    if (coreGlobals.p_rocEn) {
      /*-- Finish P-ROC initialization now that the sim is active. --*/
      coreGlobals.p_rocEn = procIsActive();
      /*-- If the initialization fails, disable the p-roc support --*/
      if (!coreGlobals.p_rocEn) {
        fprintf(stderr, "P-ROC initialization failed.  Disabling P-ROC support.\n");
        // TODO: deInit P-ROC here?
      }
      else {
        // read s11CreditDisplay, doubleAlpha and s11BallDisplay settings
        procBallCreditDisplay();

        // Added option to enable keyboard for direct switches to YAML
        g_fHandleKeyboard = procKeyboardWanted();

        // We don't want the PC to make the noises of pop bumpers etc
        g_fHandleMechanics= 0;
      }
    }
#endif

    /*-- masks bit used by flippers --*/
    {
      const int flip = core_gameData->hw.flippers;
      locals.flipMask = CORE_SWLRFLIPBUTBIT | CORE_SWLLFLIPBUTBIT |
         ((flip & FLIP_SW(FLIP_UL)) ? CORE_SWULFLIPBUTBIT : 0) |
         ((flip & FLIP_SW(FLIP_UR)) ? CORE_SWURFLIPBUTBIT : 0) |
         ((flip & FLIP_EOS(FLIP_UL))? CORE_SWULFLIPEOSBIT : 0) |
         ((flip & FLIP_EOS(FLIP_UR))? CORE_SWURFLIPEOSBIT : 0) |
         ((flip & FLIP_EOS(FLIP_LL))? CORE_SWLLFLIPEOSBIT : 0) |
         ((flip & FLIP_EOS(FLIP_LR))? CORE_SWLRFLIPEOSBIT : 0);
    }
    /*-- command line options --*/
    locals.displaySize = pmoptions.dmd_compact ? 1 : 2;
    {
      UINT32 size = core_initDisplaySize(core_gameData->lcdLayout) >> 16;
      if (((int)size > Machine->drv->screen_width) && (locals.displaySize > 1)) {
        /* force small display */
        locals.displaySize = 1;
        core_initDisplaySize(core_gameData->lcdLayout);
      }
    }
    /*-- Sound enabled ? */
    if (((Machine->gamedrv->flags & GAME_NO_SOUND) == 0) && Machine->sample_rate != 0.)
      coreGlobals.soundEn = TRUE;

    /*-- init simulator --*/
    if (g_fHandleKeyboard && core_gameData->simData) {
      int inports[CORE_MAXPORTS];
      int ii;
      for (ii = 0; ii < CORE_COREINPORT+(coreData->coreDips+31)/16; ii++)
        inports[ii] = readinputport(ii);

      coreGlobals.simAvail = sim_init((sim_tSimData *)core_gameData->simData,
                                      inports,CORE_COREINPORT+(coreData->coreDips+31)/16);
    }
    /*-- finally init the core --*/
    if (coreData->init) coreData->init();
    /*-- init sound commander --*/
    snd_cmd_init();
  }
  /*-- now reset everything --*/
  if (coreData->reset) coreData->reset();
  mech_emuInit();

#ifdef VPINMAME
  // DMD USB Init
  if(g_fShowPinDMD && !time_to_reset)
    pindmdInit(g_szGameName, core_gameData->gen, &pmoptions);
#endif

  OnStateChange(1); /* We have a lift-off */

/* TOM: this causes to draw the static sim text */
  schedule_full_refresh();
}

static MACHINE_STOP(core) {
  int ii;

#ifdef VPINMAME
  // DMD USB Kill
  if(g_fShowPinDMD && !time_to_reset)
    pindmdDeInit();
#endif

#if defined(VPINMAME) || defined(LIBPINMAME)
  g_raw_dmdx = ~0u;
  g_raw_dmdy = ~0u;

  currbuffer = buffer1;
  oldbuffer = NULL;
  raw_dmdoffs = 0;
  has_DMD = 0;

  g_raw_gtswpc_dmdframes = 0;

  g_needs_DMD_update = 1;
#endif

  mech_emuExit();
  if (coreData->stop) coreData->stop();
  snd_cmd_exit();
  for (ii = 0; ii < 5; ii++) {
    if (locals.timers[ii])
      timer_remove(locals.timers[ii]);
  }
  memset(locals.timers, 0, sizeof(locals.timers));
#ifdef PROC_SUPPORT
  if (coreGlobals.p_rocEn) {
    procDeinitialize();
  }
#endif
  coreData = NULL;
}

static void core_findSize(const struct core_dispLayout *layout, int *maxX, int *maxY) {
  if (layout) {
    for (; layout->length; layout += 1) {
      int tmpX, tmpY, type = layout->type & CORE_SEGMASK;
#if defined(VPINMAME) && !defined(MAME_DEBUG)
      if (layout->type & CORE_NODISP) continue;
#endif
      if (type == CORE_IMPORT)
        { core_findSize(layout->lptr, maxX, maxY); continue; }
      if (type == CORE_DMD || type == CORE_VIDEO) {
        tmpX = (layout->left + layout->length) * locals.segData[type].cols + 1;
        tmpY = (layout->top  + layout->start)  * locals.segData[type].rows + 1;
      }
      else {
        tmpX = (layout->left + 2*layout->length) * (locals.segData[type & 0x07].cols + 1) / 2;
        tmpY = (layout->top + 2) * (locals.segData[0].rows + 1) / 2;
      }
      if (tmpX > *maxX) *maxX = tmpX;
      if (tmpY > *maxY) *maxY = tmpY;
    }
#ifndef VPINMAME
    if (*maxX < 256) *maxX = 256;
#endif
  }
}

static UINT32 core_initDisplaySize(const struct core_dispLayout *layout) {
  int maxX = 0, maxY = 0;

  locals.segData = &segData[locals.displaySize == 1][0];
  if (layout)
    core_findSize(layout, &maxX, &maxY);
  else if (locals.displaySize > 1)
#ifdef VPINMAME
    { maxX = 257; maxY = 65; }
#else
    { maxX = 256; maxY = 65; }
#endif /* VPINMAME */
  else
    { maxX = 129; maxY = 33; }
  locals.firstSimRow = maxY + 3;
  locals.maxSimRows = Machine->drv->screen_height - locals.firstSimRow;
  if ((!pmoptions.dmd_only) || (maxY >= Machine->drv->screen_height))
    maxY = Machine->drv->screen_height;
#ifndef VPINMAME
  if (maxX == 257) maxX = 256;
#endif /* VPINMAME */
  set_visible_area(0, maxX-1, 0, maxY-1);
  return (maxX<<16) | maxY;
}

void core_nvram(void *file, int write, void *mem, size_t length, UINT8 init) {
  if (write)     mame_fwrite(file, mem, length); /* save */
  else if (file) mame_fread(file,  mem, length); /* load */
  else           memset(mem, init, length);     /* first time */
  mech_nv(file, write); /* save mech positions */
  { /*-- Load/Save DIP settings --*/
    UINT8 dips[6];
    int   ii;

    if (write) {
      for (ii = 0; ii < 6; ii++) dips[ii] = core_getDip(ii);
      mame_fwrite(file, dips, sizeof(dips));
    }
    else if (file) {
      /* set the defaults (for compabilty with older versions) */
      dips[0] = readinputport(CORE_COREINPORT+1) & 0xff;
      dips[1] = readinputport(CORE_COREINPORT+1)>>8;
      dips[2] = readinputport(CORE_COREINPORT+2) & 0xff;
      dips[3] = readinputport(CORE_COREINPORT+2)>>8;
      dips[4] = readinputport(CORE_COREINPORT+3) & 0xff;
      dips[5] = readinputport(CORE_COREINPORT+3)>>8;

      mame_fread(file, dips, sizeof(dips));
      for (ii = 0; ii < 6; ii++) vp_setDIP(ii, dips[ii]);

    }
    else { // always get the default from the inports
      /* coreData not initialised yet. Don't know exact number of DIPs */
      vp_setDIP(0, readinputport(CORE_COREINPORT+1) & 0xff);
      vp_setDIP(1, readinputport(CORE_COREINPORT+1)>>8);
      vp_setDIP(2, readinputport(CORE_COREINPORT+2) & 0xff);
      vp_setDIP(3, readinputport(CORE_COREINPORT+2)>>8);
      vp_setDIP(4, readinputport(CORE_COREINPORT+3) & 0xff);
      vp_setDIP(5, readinputport(CORE_COREINPORT+3)>>8);
    }
  }
}

static const unsigned char core_bits_set_table256[256] =
{
#   define B2(n) n,     n+1,     n+1,     n+2
#   define B4(n) B2(n), B2(n+1), B2(n+1), B2(n+2)
#   define B6(n) B4(n), B4(n+1), B4(n+1), B4(n+2)
    B6(0), B6(1), B6(1), B6(2)
};

UINT8 core_calc_modulated_light(UINT32 bits, UINT32 bit_count, volatile UINT8 *prev_level)
{
	//UINT8 outputlevel;
	UINT32 targetlevel;
	const UINT32 mask = (1 << bit_count) - 1;

	bits &= mask;
	targetlevel = ((UINT32)core_bits_set_table256[bits & 0xff] +
		core_bits_set_table256[(bits >> 8) & 0xff] +
		core_bits_set_table256[(bits >> 16) & 0xff] +
		core_bits_set_table256[(bits >> 24) & 0xff]) * 255 / bit_count;
	// Apply some smoothing with the previous level
	// 12/8 - Commenting out for now, causes AFM monsters to stop shaking intermittently.
	// outputlevel = (UINT8)((targetlevel + *prev_level) / 2);
	// return outputlevel;
	*prev_level = (UINT8)targetlevel;
	return targetlevel;
}

// Update modulated solenoid using custom PWM integration function
void core_perform_output_pwm_integration(core_tModulatedOutput* output, int samplePos, int nSamples, int zcPos, UINT8* samples, int bitpos, int stride)
{
   switch (output->type)
   {
   case CORE_MODOUT_PWM_RATIO:
   {
      int nPulse = 0;
      for (int i = 0; i < nSamples; i++, samplePos = (samplePos - 1) & (CORE_MODOUT_SAMPLE_MAX - 1))
         nPulse += (samples[samplePos * stride] >> bitpos) & 1;
      output->value = (UINT8)(nPulse * 255 / nSamples);
   }
   break;
   case CORE_MODOUT_BULB_44_6_3V_AC:
   case CORE_MODOUT_BULB_47_6_3V_AC:
   case CORE_MODOUT_BULB_86_6_3V_AC:
   case CORE_MODOUT_BULB_44_18V_DC_WPC:
   case CORE_MODOUT_BULB_44_18V_DC_GTS3:
   case CORE_MODOUT_BULB_44_18V_DC_S11:
   case CORE_MODOUT_BULB_89_20V_DC_WPC:
   case CORE_MODOUT_BULB_89_20V_DC_GTS3:
   case CORE_MODOUT_BULB_89_32V_DC_S11:
   {
      // Incandescent bulb model based on Dulli Chandra Agrawal's and others publications (Heating-times of tungsten filament incandescent lamps).
      // The bulb is a varying resistor depending on filament temperature, which is heated by the current (Ohm's law)
      // and cooled by radiating energy (Planck & Stefan/Boltzmann laws). The visible emission power is then evaluated from the filament temperature.
      const double dt = 1.0 / coreGlobals.pulsedOutStateSampleFreq;
      // processes the samples from the oldest to the most recent
      samplePos = (samplePos - nSamples) & (CORE_MODOUT_SAMPLE_MAX - 1);

      // Bulb driver electronics from a few schematics/photos:
      double U, serial_R = 0.0, acTime = 0.0;
      int isAC = FALSE;
      switch (output->type)
      {
      case CORE_MODOUT_BULB_44_6_3V_AC: // 6.3V AC used for GI
      case CORE_MODOUT_BULB_47_6_3V_AC:
      case CORE_MODOUT_BULB_86_6_3V_AC:
         // for AC power, we modulate the voltage instead of using RMS value since it gives a slightly smoother fading for WPC (maybe overkill ?).
         // If needed (WPC for example), machine driver needs to sync with zero crossing by calling 'core_zero_cross'
         U = 6.3;
         isAC = TRUE;
         acTime = ((samplePos - zcPos - 1) & (CORE_MODOUT_SAMPLE_MAX - 1)) * dt;
         break;
      case CORE_MODOUT_BULB_44_18V_DC_WPC:
         U = 18 - 0.7 - 0.7; // 18V switched through a TIP102 and a TIP107 (voltage drop supposed of 0.7V per semiconductor switch, datasheet states Vcesat=2V for I=3A)
         serial_R = 0.22; // From schematics (TZ, TOTAN, CFTBL, WPC95 general)
         break;
      case CORE_MODOUT_BULB_44_18V_DC_GTS3:
         U = 18 - 1.1; // Switched through MOSFETs (12P06 & 12N10L), serial 3,5 Ohms, then serie with 1N4004 voltage drop (1,1V) for bulbs / 120 Ohms with 1N4004 for LEDs
         serial_R = 3.5; // From schematics (Cue Ball Wizard)
         break;
      case CORE_MODOUT_BULB_44_18V_DC_S11:
         U = 18; // 18V switched through
         serial_R = 4.3; // From schematics (Guns'n Roses)
         break;
      case CORE_MODOUT_BULB_89_20V_DC_WPC:
         U = 20 - 0.7; // 20V DC switched through a TIP102 (voltage drop supposed of 0.7V per semiconductor switch, datasheet states Vcesat=2V for I=3A)
         serial_R = 0.12; // From WPC schematics (TZ, TOTAN, CFTBL, WPC95 general)
         break;
      case CORE_MODOUT_BULB_89_20V_DC_GTS3:
         U = 20; // 20V DC switched through a 12N10L Mosfet (no voltage drop)
         serial_R = 0.3; // From schematics (Cue Ball Wizard)
         break;
      case CORE_MODOUT_BULB_89_32V_DC_S11:
         U = 32 - 1.0 - 1.0; // 32V DC switched through a TIP 122 (Vcesat max= 2 to 4V, 1V used here) with a 3 Ohms serial resistor and a diode (1V voltage drop)
         serial_R = 3.0; // From board photos
         break;
      }

      // Bulb characteristics, estimated by fitting ratings (U,I,P) at a supposed steady state temperature of 2700K, then validating against high FPS video
      int bulb;
      switch (output->type)
      {
      case CORE_MODOUT_BULB_44_6_3V_AC: // Bulb #44/555: 6.3V 0.25A 1.575W 11.3lm (commonly used for GI & inserts)
      case CORE_MODOUT_BULB_44_18V_DC_WPC: 
      case CORE_MODOUT_BULB_44_18V_DC_GTS3:
      case CORE_MODOUT_BULB_44_18V_DC_S11:
         bulb = BULB_44;
         break;
      case CORE_MODOUT_BULB_47_6_3V_AC: // Bulb #47: 6.3V 0.15A 0.945W 6.3lm (used for GI with less heat)
         bulb = BULB_47;
         break;
      case CORE_MODOUT_BULB_89_20V_DC_WPC:// Bulb #89/906: 13V 0.58A 7.54W 75.4lm (commonly used for flashers)
      case CORE_MODOUT_BULB_89_20V_DC_GTS3:
      case CORE_MODOUT_BULB_89_32V_DC_S11:
         bulb = BULB_89;
         break;
      case CORE_MODOUT_BULB_86_6_3V_AC: // Bulb #86: 6.3V 0.2A 1.26W 5.027lm (seldom specific use)
         bulb = BULB_86;
         break;
      }

      // Initial perceived emission level
      double average_emission = 0.0;
      for (int i = 0; i < 16; i++)
      {
         average_emission += output->state.emission_history[i];
      }
      double T = output->state.filament_temperature;
      double max_emission = average_emission;

      // Iterates over each sampled output value and computes its impact on bulb filament
      UINT8 mask = 1 << bitpos;
      for (int i = 0; i < nSamples; i++, samplePos = (samplePos + 1) & (CORE_MODOUT_SAMPLE_MAX - 1))
      {
         T = T < 293.0 ? 293.0 : T > 2999.0 ? 2999.0 : T; // Keeps T within the range of the LUT (between room temperature and melt down point)
         if (samples[samplePos * stride] & mask)
         {
            // Little hack for AC power: we add 0.5% to avoid the slight flickering caused by the sampling process
            double U1 = isAC ? 1.005 * 1.414 * sin(60.0 * 2.0 * PI * acTime) * U : U;
            double dT = dt * bulb_heat_up_factor(bulb, T, U1, serial_R);
            T += dT > 1000.0 ? 1000.0 : dT;
         }
         else
         {
            T += dt * bulb_cool_down_factor(bulb, T);
         }
         double emission = bulb_filament_temperature_to_emission(T);

         // Compute the perceived emission by averaging the last 16 samples (sliding average)
         average_emission -= output->state.emission_history[output->state.emission_history_pos & 0x0F];
         output->state.emission_history[output->state.emission_history_pos & 0x0F] = emission;
         output->state.emission_history_pos = (output->state.emission_history_pos + 1) & 0x0F;
         average_emission += emission;
         max_emission = average_emission > max_emission ? average_emission : max_emission;

         acTime += dt;
      }
      output->state.filament_temperature = T;

      if (max_emission <= 0.0)
         output->value = 0;
      else if (max_emission >= 16.0)
         output->value = 255;
      else
         output->value = (UINT8) (max_emission * 255.0 / 16.0);
   }
   break;
   case CORE_MODOUT_LED: 
   {
      // LED reacts almost instantly (<1us), the integration is based on the human eye perception: 
      // flashing below 100Hz (limit between 50-100 depends on each human), dimming above (there should be a "flicker" range in the middle)
      int n = (int)(coreGlobals.pulsedOutStateSampleFreq / 100); // Go through samples of the last 1/100s (100Hz limit)
      int nPulse = 0;
      for (int i = 0; i < n; i++, samplePos = (samplePos - 1) & (CORE_MODOUT_SAMPLE_MAX - 1))
         nPulse += (samples[samplePos * stride] >> bitpos) & 1;
      output->value = (UINT8)(nPulse * 255 / (n - 1));
   }
   break;
   case CORE_MODOUT_MOTOR_LINEAR: 
   {
      // Linear motor position which increase linearly over time when voltage is high
      for (int i = 0; i < nSamples; i++, samplePos = (samplePos - 1) & (CORE_MODOUT_SAMPLE_MAX - 1))
         output->state.motor_position += (samples[samplePos * stride] >> bitpos) & 1;
      output->value = (UINT8)((output->state.motor_position * 100.0) / coreGlobals.pulsedOutStateSampleFreq); // normalize to 100 steps per seconds
   }
   break;
   case CORE_MODOUT_DEFAULT:
   default:
   {
      // Default is the modulated solenoid values as computed by each hardware driver, if implemented, or the non modulated value
      int index = (int)(((UINT8*)output - (UINT8*)&coreGlobals.modulatedOutputs) / sizeof(core_tModulatedOutput));
      if (index < CORE_MODOUT_SOL_MAX)
      {
         // For the time being, only GTS3, WPC and SAM have modulated solenoids directly implemented in the driver
         if ((core_gameData->gen & (GEN_ALLWPC | GEN_GTS3 | GEN_SAM)) && options.usemodsol)
            output->value = coreGlobals.modulatedSolenoids[CORE_MODSOL_CUR][index];
         else
            output->value = (coreGlobals.solenoids >> index) & 1;
      }
      else if (index < CORE_MODOUT_SOL_MAX + CORE_MODOUT_GI_MAX)
      {
         // WPC, SAM & Data East drivers write the GI state in this array, others will be at 0 (no dedicated GI output)
         output->value = coreGlobals.gi[index - CORE_MODOUT_SOL_MAX];
      }
      else if (index < CORE_MODOUT_SOL_MAX + CORE_MODOUT_GI_MAX + CORE_MODOUT_LAMP_MAX)
      {
         // TODO preliminary implementation, untested since Lamps are not yet supported
         int row = (index - CORE_MODOUT_SOL_MAX + CORE_MODOUT_GI_MAX) >> 8;
         int col = (index - CORE_MODOUT_SOL_MAX + CORE_MODOUT_GI_MAX) & 0x7;
         output->value = coreGlobals.lampMatrix[row] & (1 << col);
      }
   }
   break;
   }
}

/* PWM integration.This is only done on request for performance and because
 * the integration result depends on the integration period for some integrators.
 * For example a bulb will return the maximum averaged emission power over the
 * integration period (since the retina is analogous and persists brightness).
 */
void core_perform_pwm_integration()
{
   // Integration is performed on requested, therefore this can be called from another thread that the one of the main emulation.
   // To avoid threading issues:
   // - the emulation thread continuously fills the coreGlobals.pulsedSolStateSamples / coreGlobals.pulsedOutStateSamplePos / coreGlobals.lastACZeroCross
   // - the integration thread only reads from these, and is the only one allowed to write to coreGlobals.modulatedOutputs / coreGlobals.lastModulatedOutputIntegrationPos
   // This function is not allowed to call any of the core function which are nto thread safe (timer_get_time(),...)
   int newSamplePos = coreGlobals.pulsedOutStateSamplePos;
   int nSamples = newSamplePos - coreGlobals.lastModulatedOutputIntegrationPos;
   if (coreGlobals.pulsedOutStateSampleFreq > 0 && nSamples > 0)
   {
      int zcPos = coreGlobals.lastACZeroCross;
      int samplePos = newSamplePos & (CORE_MODOUT_SAMPLE_MAX - 1);
      for (int ii = 0; ii < CORE_MODOUT_SOL_MAX; ii++)
      {
         core_perform_output_pwm_integration(&coreGlobals.modulatedOutputs[ii], samplePos, nSamples, zcPos, ((UINT8*)coreGlobals.pulsedSolStateSamples) + (ii >> 3), ii & 7, 4);
      }
      for (int ii = 0; ii < CORE_MODOUT_GI_MAX; ii++)
      {
         core_perform_output_pwm_integration(&coreGlobals.modulatedOutputs[CORE_MODOUT_SOL_MAX + ii], samplePos, nSamples, zcPos, (UINT8*)coreGlobals.pulsedGIStateSamples, ii, 1);
      }
   }
   coreGlobals.lastModulatedOutputIntegrationPos = newSamplePos;
}

void core_sound_throttle_adj(int sIn, int *sOut, int buffersize, double samplerate)
{
	const int delta = (sIn >= *sOut) ? (sIn - *sOut) : (sIn + buffersize - *sOut);

#ifdef DEBUG_SOUND
	{
		char tmp[161];
		LARGE_INTEGER performance_count;
		QueryPerformanceCounter(&performance_count);

		sprintf(tmp, "snd clk: %llu in: %d out: %d size: %d delta %d", performance_count.QuadPart, sIn, *sOut, buffersize, delta);
		DebugSound(tmp);
	}
#endif

	if (delta > samplerate * 50 / 1000)
	{
		// Over 50ms delta and throttle didn't catch it fast enough.   Drop some samples, but not so
		// much that we have to restart from a zero buffer.
		*sOut = sIn - (int)(samplerate * 20 / 1000 + 0.5);
		if (*sOut < 0)
			*sOut += buffersize;

		SetThrottleAdj(0);
	}
	else if (delta > samplerate * 35 / 1000)
	{
		SetThrottleAdj(-4);
	}
	else if (delta > samplerate * 25 / 1000)
	{
		SetThrottleAdj(-1);
	}
	else if (delta < samplerate * 10 / 1000)
	{
		SetThrottleAdj(10);
	}
	else if (delta < samplerate * 20 / 1000)
	{
		SetThrottleAdj(2);
	}
	else
	{
		SetThrottleAdj(0);
	}
}

/*----------------------------------------------
/  Add a timer when building the machine driver
/-----------------------------------------------*/
void machine_add_timer(struct InternalMachineDriver *machine, void (*func)(int), double rate) {
  int ii;
  for (ii = 0; machine->pinmame.timers[ii].callback; ii++)
    ;
  machine->pinmame.timers[ii].callback = func;
  machine->pinmame.timers[ii].rate = rate;
}

/*---------------------------------------
/  Default machine driver for all games
/----------------------------------------*/
MACHINE_DRIVER_START(PinMAME)
  MDRV_VIDEO_ATTRIBUTES(VIDEO_TYPE_RASTER | VIDEO_SUPPORTS_DIRTY)
  MDRV_SCREEN_SIZE(CORE_SCREENX, CORE_SCREENY)
  MDRV_VISIBLE_AREA(0, CORE_SCREENX-1, 0, CORE_SCREENY-1)
  MDRV_PALETTE_INIT(core)
  MDRV_PALETTE_LENGTH(sizeof(core_palette)/sizeof(core_palette[0][0])/3)
  MDRV_FRAMES_PER_SECOND(60)
  MDRV_SWITCH_CONV(core_swSeq2m,core_m2swSeq)
  MDRV_LAMP_CONV(core_swSeq2m,core_m2swSeq)
  MDRV_MACHINE_INIT(core) MDRV_MACHINE_STOP(core)
  MDRV_VIDEO_UPDATE(core_gen)
MACHINE_DRIVER_END
