/***********************************************/
/* PINMAME - Interface function (Input/Output) */
/***********************************************/
#include <stdarg.h>
#include <math.h>
#include "driver.h"
#include "sim.h"
#include "snd_cmd.h"
#include "mech.h"
#include "core.h"
#include "video.h"
#include "bulb.h"

#ifdef PROC_SUPPORT
 #include "p-roc/p-roc.h"
#endif

#if defined(VPINMAME) || defined(LIBPINMAME)
 #ifndef LIBPINMAME
  #ifndef WIN32_LEAN_AND_MEAN
  #define WIN32_LEAN_AND_MEAN
  #endif
  #ifndef _WIN32_WINNT
  #if _MSC_VER >= 1800
   // Windows 2000 _WIN32_WINNT_WIN2K
   #define _WIN32_WINNT 0x0500
  #elif _MSC_VER < 1600
   #define _WIN32_WINNT 0x0400
  #else
   #define _WIN32_WINNT 0x0403
  #endif
  #define WINVER _WIN32_WINNT
  #endif
  #include <Windows.h>
 #endif
 
 #include "dmddevice.h"
 #include "../../ext/dmddevice/usbalphanumeric.h"

 UINT8  g_raw_dmdbuffer[DMD_MAXY*DMD_MAXX];
 UINT32 g_raw_colordmdbuffer[DMD_MAXY*DMD_MAXX];
 UINT32 g_raw_dmdx = ~0u;
 UINT32 g_raw_dmdy = ~0u;

 #ifdef LIBPINMAME
  extern int g_fDmdMode;
 #endif

 static UINT8 buffer1[DMD_MAXY*DMD_MAXX];
 static UINT8 buffer2[DMD_MAXY*DMD_MAXX];
 static UINT8 *currbuffer = buffer1;
 static UINT8 *oldbuffer = NULL;
 static UINT32 raw_dmdoffs = 0;
 static UINT8 has_DMD_Video = 0;

#define CORE_MAX_RAW_DMD_FRAMES 5
 UINT8  raw_dmd_frames[CORE_MAX_RAW_DMD_FRAMES * DMD_MAXX * DMD_MAXY / 8];
 UINT32 raw_dmd_frame_count = 0;

 UINT8 g_needs_DMD_update = 1;
#endif

/* stuff to test VPINMAME */
#if 0
#define VPINMAME
int g_fHandleKeyboard = 1, g_fHandleMechanics = 1, g_fMechSamples = 1;
void OnSolenoid(int nSolenoid, int IsActive) {}
void OnStateChange(int nChange) {}
UINT64 vp_getSolMask64(void) { return -1; }
void vp_updateMech(void) {};
int vp_getDip(int bank) { return 0; }
void vp_setDIP(int bank, int value) { }
#endif

#if defined(VPINMAME)
  extern char g_szGameName[256];
#endif

#if defined(VPINMAME) || defined(LIBPINMAME)
  #include "vpintf.h"
  extern int g_fPause;
  extern int g_fHandleKeyboard, g_fHandleMechanics;
  extern char g_fShowWinDMD;
  extern char g_fShowPinDMD; /* pinDMD */
  extern int time_to_reset;  /* pinDMD */
  extern int g_fDumpFrames;
  extern void OnSolenoid(int nSolenoid, int IsActive);
  extern void OnStateChange(int nChange);
#else
  int g_fHandleKeyboard = 1;
  int g_fHandleMechanics = 0xff;
  #define OnSolenoid(nSolenoid, IsActive)
  #define OnStateChange(nChange)
  #define vp_getSolMask64() ((UINT64)(-1))
  #define vp_updateMech()
  #define vp_setDIP(x,y)
#endif

#ifdef LIBPINMAME
  extern void libpinmame_update_display(const int index, const struct core_dispLayout* p_layout, const void* p_data);
#endif

#ifndef LIBPINMAME
  #include "gts3.h"
  extern tGTS3locals GTS3locals;
#endif

INLINE UINT8 saturatedByte(float v)
{
  v *= 255.f;
  if(v < 0.f)
    v = 0.f;
  if(v > 255.f)
    v = 255.f;
  return (UINT8)v;
}

static void drawChar(struct mame_bitmap *bitmap, int row, int col, UINT16 seg_bits, int type, UINT8 dimming[16]);
static UINT32 core_initDisplaySize(const struct core_dispLayout *layout);
static VIDEO_UPDATE(core_status);

/*---------------------------
/    Global variables
/----------------------------*/
tPMoptions            pmoptions; /* PinMAME specific options */
core_tGlobals         coreGlobals;
struct pinMachine    *coreData;
const core_tGameData *core_gameData = NULL;  /* data about the running game */

/*---------------------
/  Global constants
/----------------------*/
const int core_bcd2seg7[16] = {
/* 0    1    2    3    4    5    6    7    8    9  */
  0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,0x7f,0x6f
#ifdef MAME_DEBUG
/* A    B    C    D    E */
 ,0x77,0x7c,0x39,0x5e,0x79
#endif /* MAME_DEBUG */
};
// including the 0x0a to 0x0e characters of a SN5446A type BCD-to-7-segment encoder
const int core_bcd2seg7e[16] = {
/* 0    1    2    3    4    5    6    7    8    9  */
  0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,0x7f,0x6f,
/* A    B    C    D    E */
#ifdef MAME_DEBUG
  0x77,0x7c,0x39,0x5e,0x79
#else /* display legible characters in debug mode only */
  0x58,0x4c,0x62,0x69,0x78
#endif /* MAME_DEBUG */
};
// missing top line for 6 and bottom line for 9 numbers (e.g. Atari)
const int core_bcd2seg7a[16] = {
/* 0    1    2    3    4    5    6    7    8    9  */
  0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7c,0x07,0x7f,0x67
#ifdef MAME_DEBUG
/* A    B    C    D    E */
 ,0x77,0x7c,0x39,0x5e,0x79
#endif /* MAME_DEBUG */
};
const int core_bcd2seg9[16] = {
/* 0    1     2    3    4    5    6    7    8    9  */
  0x3f,0x300,0x5b,0x4f,0x66,0x6d,0x7d,0x07,0x7f,0x6f
#ifdef MAME_DEBUG
/* A    B     C    D     E */
 ,0x77,0x34f,0x39,0x30f,0x79
#endif /* MAME_DEBUG */
};
// missing top line for 6 and bottom line for 9 numbers, and including the 0x0a to 0x0e characters (e.g. Gottlieb Sys80/a)
const int core_bcd2seg9a[16] = {
/* 0    1     2    3    4    5    6    7    8    9  */
  0x3f,0x300,0x5b,0x4f,0x66,0x6d,0x7c,0x07,0x7f,0x67,
#ifdef MAME_DEBUG
/* A    B     C    D     E */
  0x77,0x34f,0x39,0x30f,0x79
#else /* display legible characters in debug mode only */
/* A    B    C    D    E */
  0x58,0x4c,0x62,0x69,0x78
#endif /* MAME_DEBUG */
};

// patterns taken from Rockwell 10939 datasheet and adjusted to match regular 16 segments layout
const UINT16 core_ascii2seg16[] = {
  /* 0x00-0x07 */ 0x0000, 0x0000, 0x44BF, 0x2280, 0x08DB, 0x08CF, 0x08E6, 0x08ED, //   012345 with commas
  /* 0x08-0x0f */ 0x08FD, 0x0087, 0x08FF, 0x08EF, 0xC43F, 0xA200, 0x885B, 0x884F, // 67890123 with commas / dots
  /* 0x10-0x17 */ 0x8866, 0x886D, 0x887D, 0x8007, 0x887F, 0x886F, 0xC4BF, 0xA280, // 45678901 with dots / semicolons
  /* 0x18-0x1f */ 0x88DB, 0x88CF, 0x88E6, 0x88ED, 0x88FD, 0x8087, 0x88FF, 0x88EF, // 23456789 with semicolons
  /* 0x20-0x27 */ 0x0000, 0x0309, 0x0220, 0x2A4E, 0x2A6D, 0x6E65, 0x135D, 0x0400, //  !"#$%&'
  /* 0x28-0x2f */ 0x1400, 0x4100, 0x7F40, 0x2A40, 0x0080, 0x0840, 0x0008, 0x4400, // ()*+,-./
  /* 0x30-0x37 */ 0x443F, 0x2200, 0x085B, 0x084F, 0x0866, 0x086D, 0x087D, 0x0007, // 01234567
  /* 0x38-0x3f */ 0x087F, 0x086F, 0x0009, 0x4001, 0x4408, 0x0848, 0x1108, 0x2803, // 89:;<=>?
  /* 0x40-0x47 */ 0x205F, 0x0877, 0x2A0F, 0x0039, 0x220F, 0x0079, 0x0071, 0x083D, // @ABCDEFG
  /* 0x48-0x4f */ 0x0876, 0x2209, 0x001E, 0x1470, 0x0038, 0x0536, 0x1136, 0x003F, // HIJKLMNO
  /* 0x50-0x57 */ 0x0873, 0x103F, 0x1873, 0x086D, 0x2201, 0x003E, 0x4430, 0x5036, // PRQSTUVW
  /* 0x58-0x5f */ 0x5500, 0x2500, 0x4409, 0x0039, 0x1100, 0x000F, 0x5000, 0x0008, // XYZ[\]^_
  /* 0x60-0x67 */ 0x0001, 0x0001, 0x0002, 0x0004, 0x0008, 0x0008, 0x0010, 0x0020, // all segments, singular
  /* 0x68-0x6f */ 0x0200, 0x0400, 0x0800, 0x1000, 0x2000, 0x4000, 0x0040, 0x0100, // all segments, singular
  /* 0x70-0x77 */ 0x0001, 0x0001, 0x0003, 0x0007, 0x000F, 0x000F, 0x001F, 0x003F, // all segments, accumulating
  /* 0x78-0x7f */ 0x023F, 0x063F, 0x0E3F, 0x1E3F, 0x3E3F, 0x7E3F, 0x7E7F, 0x7F7F, // all segments, accumulating
};

// patterns taken from Rockwell 10939 datasheet and adjusted to match 16 segments layout with split top / bottom lines
const UINT16 core_ascii2seg16s[] = {
  /* 0x00-0x07 */ 0x0000, 0x0000, 0x44ff, 0x2200, 0x8877, 0x883f, 0x888c, 0x88bb, //   012345 with commas (no bits for these)
  /* 0x08-0x0f */ 0x88fb, 0x000f, 0x88ff, 0x88bf, 0x44ff, 0x2200, 0x8877, 0x883f, // 67890123 with commas / dots (no bits for these)
  /* 0x10-0x17 */ 0x888c, 0x88bb, 0x88fb, 0x000f, 0x88ff, 0x88bf, 0x44ff, 0x2200, // 45678901 with dots / semicolons (no bits for these)
  /* 0x18-0x1f */ 0x8877, 0x883f, 0x888c, 0x88bb, 0x88fb, 0x000f, 0x88ff, 0x88bf, // 23456789 with semicolons (no bits for these)
  /* 0x20-0x27 */ 0x0000, 0x0321, 0x0280, 0xaa3c, 0xaabb, 0xee99, 0x9379, 0x0400, //  !"#$%&'
  /* 0x28-0x2f */ 0x1400, 0x4100, 0xff00, 0xaa00, 0x4000, 0x8800, 0x0020, 0x4400, // ()*+,-./
  /* 0x30-0x37 */ 0x44ff, 0x2200, 0x8877, 0x883f, 0x888c, 0x88bb, 0x88fb, 0x000f, // 01234567
  /* 0x38-0x3f */ 0x88ff, 0x88bf, 0x0021, 0x4001, 0x4430, 0x8830, 0x1130, 0x2807, // 89:;<=>?
  /* 0x40-0x47 */ 0xa07f, 0x88cf, 0x2a3f, 0x00f3, 0x223f, 0x80f3, 0x80c3, 0x08fb, // @ABCDEFG
  /* 0x48-0x4f */ 0x88cc, 0x2233, 0x007c, 0x94c0, 0x00f0, 0x05cc, 0x11cc, 0x00ff, // HIJKLMNO
  /* 0x50-0x57 */ 0x88c7, 0x10ff, 0x98c7, 0x88bb, 0x2203, 0x00fc, 0x44c0, 0x50cc, // PRQSTUVW
  /* 0x58-0x5f */ 0x5500, 0x2500, 0x4433, 0x00e1, 0x1100, 0x001e, 0x5000, 0x0030, // XYZ[\]^_
  /* 0x60-0x67 */ 0x0001, 0x0002, 0x0004, 0x0008, 0x0010, 0x0020, 0x0040, 0x0080, // all segments, singular
  /* 0x68-0x6f */ 0x0200, 0x0400, 0x0800, 0x1000, 0x2000, 0x4000, 0x8000, 0x0100, // all segments, singular
  /* 0x70-0x77 */ 0x0001, 0x0003, 0x0007, 0x000f, 0x001f, 0x003f, 0x007f, 0x00ff, // all segments, accumulating
  /* 0x78-0x7f */ 0x02ff, 0x06ff, 0x0eff, 0x1eff, 0x3eff, 0x7eff, 0xfeff, 0xffff, // all segments, accumulating
};

/* makes it easier to swap bits */
                              // 0  1  2  3  4  5  6  7  8  9 10,11,12,13,14,15
const UINT8 core_swapNyb[16] = { 0, 8, 4,12, 2,10, 6,14, 1, 9, 5,13, 3,11, 7,15};
/* Palette */

static const unsigned char core_palette[48+COL_COUNT][3] = {
{/*  0 */ 0x00,0x00,0x00}, /* Background */
/* -- DMD DOT COLORS-- */
{/*  1 */ 0x30,0x00,0x00}, /* "Black" Dot - DMD Background */
{/*  2 */ 0x00,0x00,0x00}, /* Intensity  33% - Filled in @ Run Time */
{/*  3 */ 0x00,0x00,0x00}, /* Intensity  66% - Filled in @ Run Time */
{/*  4 */ 0xff,0xe0,0x20}, /* Intensity 100% - Changed @ Run Time to match config vars*/
/* -- PLAYFIELD LAMP COLORS -- */
{/*  5 */ 0x00,0x00,0x00}, /* Black */
{/*  6 */ 0xff,0xff,0xff}, /* White */
{/*  7 */ 0x40,0xff,0x00}, /* green */
{/*  8 */ 0xff,0x00,0x00}, /* Red */
{/*  9 */ 0xff,0x80,0x00}, /* orange */
{/* 10 */ 0xff,0xff,0x00}, /* yellow */
{/* 11 */ 0x00,0x80,0xff}, /* lblue */
{/* 12 */ 0x9f,0x40,0xff}  /* lpurple*/
};

static UINT16 dim_LUT[3][257];

/*------------------------------
/ Display segment drawing data
/------------------------------*/
typedef UINT32 tSegRow[17];
typedef struct { int rows, cols; tSegRow *segs; } tSegData;

static const tSegRow segSize1C[6][20] = { /* with commas */
{ /* alphanumeric display characters */
/*                       all        0001       0002       0004       0008       0010       0020       0040       0080       0100       0200       0400       0800       1000       2000       4000       8000 */
/*    11111111111  */{0x00555554,0x00555554,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/*   1133331333311 */{0x017fdff5,0x003fcff0,0x00000001,0x00000000,0x00000000,0x00000000,0x01000000,0x00000000,0x00000000,0x00400000,0x00001000,0x00000004,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/*   11    1   1 1 */{0x01401011,0x00000000,0x00000001,0x00000000,0x00000000,0x00000000,0x01000000,0x00000000,0x00000000,0x00400000,0x00001000,0x00000010,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/*  31 1  31  1 31 */{0x0d10d04d,0x00000000,0x0000000d,0x00000000,0x00000000,0x00000000,0x0d000000,0x00000000,0x00000000,0x00100000,0x0000d000,0x00000040,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/*  32 1  32  1 32 */{0x0e10e04e,0x00000000,0x0000000e,0x00000000,0x00000000,0x00000000,0x0e000000,0x00000000,0x00000000,0x00100000,0x0000e000,0x00000040,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/*  22  1 22 1  22 */{0x0a04a10a,0x00000000,0x0000000a,0x00000000,0x00000000,0x00000000,0x0a000000,0x00000000,0x00000000,0x00040000,0x0000a000,0x00000100,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/*  23  1 231   23 */{0x0b04b40b,0x00000000,0x0000000b,0x00000000,0x00000000,0x00000000,0x0b000000,0x00000000,0x00000000,0x00040000,0x0000b000,0x00000400,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/*  13   1131   13 */{0x07017407,0x00000000,0x00000007,0x00000000,0x00000000,0x00000000,0x07000000,0x00000000,0x00000000,0x00010000,0x00007000,0x00000400,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/*  1333311133331  */{0x07fd5ff4,0x00000000,0x00000004,0x00000000,0x00000000,0x00000000,0x04000000,0x03fc0000,0x00000000,0x00010000,0x00004000,0x00001000,0x00000ff0,0x00000000,0x00000000,0x00000000,0x00000000},
/*  3111113111113  */{0x0d55d55c,0x00000000,0x0000000c,0x0000000c,0x00000000,0x0c000000,0x0c000000,0x0155c000,0x00000000,0x0000c000,0x0000c000,0x0000c000,0x0000d550,0x0000c000,0x0000c000,0x0000c000,0x00000000},
/*  1333311133331  */{0x07fd5ff4,0x00000000,0x00000000,0x00000004,0x00000000,0x04000000,0x00000000,0x03fc0000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000ff0,0x00001000,0x00004000,0x00010000,0x00000000},
/* 31   1311   31  */{0x34075034,0x00000000,0x00000000,0x00000034,0x00000000,0x34000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00001000,0x00034000,0x00040000,0x00000000},
/* 32   132 1  32  */{0x38078438,0x00000000,0x00000000,0x00000038,0x00000000,0x38000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000400,0x00038000,0x00040000,0x00000000},
/* 22  1 22 1  22  */{0x28128428,0x00000000,0x00000000,0x00000028,0x00000000,0x28000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000400,0x00028000,0x00100000,0x00000000},
/* 23 1  23  1 23  */{0x2c42c12c,0x00000000,0x00000000,0x0000002c,0x00000000,0x2c000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000100,0x0002c000,0x00400000,0x00000000},
/* 13 1  13  1 13  */{0x1c41c11c,0x00000000,0x00000000,0x0000001c,0x00000000,0x1c000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000100,0x0001c000,0x00400000,0x00000000},
/* 1 1   1    11   */{0x11010050,0x00000000,0x00000000,0x00000010,0x00000000,0x10000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000040,0x00010000,0x01000000,0x00000000},
/* 113333133331132 */{0x17fdff5e,0x00000000,0x00000000,0x00000010,0x03fcff00,0x10000000,0x00000000,0x00000000,0x0000000e,0x00000000,0x00000000,0x00000000,0x00000000,0x00000040,0x00010000,0x04000000,0x0000000e},
/*  11111111111 31 */{0x0555554d,0x00000000,0x00000000,0x00000000,0x05555540,0x00000000,0x00000000,0x00000000,0x0000000d,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x0000000d},
/*              1  */{0x00000004,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000004,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000}
},{ /* 8 segment LED characters */
/*    11111111111  */{0x00555554,0x00555554,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/*   1333333333331 */{0x01fffffd,0x00fffffc,0x00000001,0x00000000,0x00000000,0x00000000,0x01000000,0x00000000,0x00000000},
/*   1           1 */{0x01000001,0x00000000,0x00000001,0x00000000,0x00000000,0x00000000,0x01000000,0x00000000,0x00000000},
/*  31          31 */{0x0d00000d,0x00000000,0x0000000d,0x00000000,0x00000000,0x00000000,0x0d000000,0x00000000,0x00000000},
/*  32          32 */{0x0e00000e,0x00000000,0x0000000e,0x00000000,0x00000000,0x00000000,0x0e000000,0x00000000,0x00000000},
/*  22          22 */{0x0a00000a,0x00000000,0x0000000a,0x00000000,0x00000000,0x00000000,0x0a000000,0x00000000,0x00000000},
/*  23          23 */{0x0b00000b,0x00000000,0x0000000b,0x00000000,0x00000000,0x00000000,0x0b000000,0x00000000,0x00000000},
/*  13          13 */{0x07000007,0x00000000,0x00000007,0x00000000,0x00000000,0x00000000,0x07000000,0x00000000,0x00000000},
/*  1333333333331  */{0x07fffff4,0x00000000,0x00000004,0x00000000,0x00000000,0x00000000,0x04000000,0x03fffff0,0x00000000},
/*  3111111111113  */{0x0d55555c,0x00000000,0x0000000c,0x0000000c,0x00000000,0x0c000000,0x0c000000,0x0d55555c,0x00000000},
/*  1333333333331  */{0x07fffff4,0x00000000,0x00000000,0x00000004,0x00000000,0x04000000,0x00000000,0x03fffff0,0x00000000},
/* 31          31  */{0x34000034,0x00000000,0x00000000,0x00000034,0x00000000,0x34000000,0x00000000,0x00000000,0x00000000},
/* 32          32  */{0x38000038,0x00000000,0x00000000,0x00000038,0x00000000,0x38000000,0x00000000,0x00000000,0x00000000},
/* 22          22  */{0x28000028,0x00000000,0x00000000,0x00000028,0x00000000,0x28000000,0x00000000,0x00000000,0x00000000},
/* 23          23  */{0x2c00002c,0x00000000,0x00000000,0x0000002c,0x00000000,0x2c000000,0x00000000,0x00000000,0x00000000},
/* 13          13  */{0x1c00001c,0x00000000,0x00000000,0x0000001c,0x00000000,0x1c000000,0x00000000,0x00000000,0x00000000},
/* 1           1   */{0x10000010,0x00000000,0x00000000,0x00000010,0x00000000,0x10000000,0x00000000,0x00000000,0x00000000},
/* 133333333333132 */{0x1fffffde,0x00000000,0x00000000,0x00000010,0x0fffffc0,0x10000000,0x00000000,0x00000000,0x0000000e},
/*  11111111111 31 */{0x0555554d,0x00000000,0x00000000,0x00000000,0x05555540,0x00000000,0x00000000,0x00000000,0x0000000d},
/*              1  */{0x00000004,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000004}
},{ /* 10 segment LED characters */
/*    11111111111  */{0x00555554,0x00555554,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/*   1333331333331 */{0x01ffdffd,0x00ffcffc,0x00000001,0x00000000,0x00000000,0x00000000,0x01000000,0x00000000,0x00000000,0x00001000,0x00000000},
/*   1     1     1 */{0x01001001,0x00000000,0x00000001,0x00000000,0x00000000,0x00000000,0x01000000,0x00000000,0x00000000,0x00001000,0x00000000},
/*  31    31    31 */{0x0d00d00d,0x00000000,0x0000000d,0x00000000,0x00000000,0x00000000,0x0d000000,0x00000000,0x00000000,0x0000d000,0x00000000},
/*  32    32    32 */{0x0e00e00e,0x00000000,0x0000000e,0x00000000,0x00000000,0x00000000,0x0e000000,0x00000000,0x00000000,0x0000e000,0x00000000},
/*  22    22    22 */{0x0a00a00a,0x00000000,0x0000000a,0x00000000,0x00000000,0x00000000,0x0a000000,0x00000000,0x00000000,0x0000a000,0x00000000},
/*  23    23    23 */{0x0b00b00b,0x00000000,0x0000000b,0x00000000,0x00000000,0x00000000,0x0b000000,0x00000000,0x00000000,0x0000b000,0x00000000},
/*  13    13    13 */{0x07007007,0x00000000,0x00000007,0x00000000,0x00000000,0x00000000,0x07000000,0x00000000,0x00000000,0x00007000,0x00000000},
/*  1333331333331  */{0x07ff7ff4,0x00000000,0x00000004,0x00000000,0x00000000,0x00000000,0x04000000,0x03ff3ff0,0x00000000,0x00004000,0x00000000},
/*  3111111111113  */{0x0d55555c,0x00000000,0x0000000c,0x0000000c,0x00000000,0x0c000000,0x0c000000,0x0d55555c,0x00000000,0x0000c000,0x0000c000},
/*  1333331333331  */{0x07ff7ff4,0x00000000,0x00000000,0x00000004,0x00000000,0x04000000,0x00000000,0x03ff3ff0,0x00000000,0x00000000,0x00004000},
/* 31    31    31  */{0x34034034,0x00000000,0x00000000,0x00000034,0x00000000,0x34000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00034000},
/* 32    32    32  */{0x38038038,0x00000000,0x00000000,0x00000038,0x00000000,0x38000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00038000},
/* 22    22    22  */{0x28028028,0x00000000,0x00000000,0x00000028,0x00000000,0x28000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00028000},
/* 23    23    23  */{0x2c02c02c,0x00000000,0x00000000,0x0000002c,0x00000000,0x2c000000,0x00000000,0x00000000,0x00000000,0x00000000,0x0002c000},
/* 13    13    13  */{0x1c01c01c,0x00000000,0x00000000,0x0000001c,0x00000000,0x1c000000,0x00000000,0x00000000,0x00000000,0x00000000,0x0001c000},
/* 1     1     1   */{0x10010010,0x00000000,0x00000000,0x00000010,0x00000000,0x10000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00010000},
/* 133333133333132 */{0x1ffdffde,0x00000000,0x00000000,0x00000010,0x0ffcffc0,0x10000000,0x00000000,0x00000000,0x0000000e,0x00000000,0x00010000},
/*  11111111111 31 */{0x0555554d,0x00000000,0x00000000,0x00000000,0x05555540,0x00000000,0x00000000,0x00000000,0x0000000d,0x00000000,0x00000000},
/*              1  */{0x00000004,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000004,0x00000000,0x00000000}
},{ /* alphanumeric display characters (reversed comma with period) */
/*    11111111111  */{0x00555554,0x00555554,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/*   1133331333311 */{0x017fdff5,0x003fcff0,0x00000001,0x00000000,0x00000000,0x00000000,0x01000000,0x00000000,0x00000000,0x00400000,0x00001000,0x00000004,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/*   11    1   1 1 */{0x01401011,0x00000000,0x00000001,0x00000000,0x00000000,0x00000000,0x01000000,0x00000000,0x00000000,0x00400000,0x00001000,0x00000010,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/*  31 1  31  1 31 */{0x0d10d04d,0x00000000,0x0000000d,0x00000000,0x00000000,0x00000000,0x0d000000,0x00000000,0x00000000,0x00100000,0x0000d000,0x00000040,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/*  32 1  32  1 32 */{0x0e10e04e,0x00000000,0x0000000e,0x00000000,0x00000000,0x00000000,0x0e000000,0x00000000,0x00000000,0x00100000,0x0000e000,0x00000040,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/*  22  1 22 1  22 */{0x0a04a10a,0x00000000,0x0000000a,0x00000000,0x00000000,0x00000000,0x0a000000,0x00000000,0x00000000,0x00040000,0x0000a000,0x00000100,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/*  23  1 231   23 */{0x0b04b40b,0x00000000,0x0000000b,0x00000000,0x00000000,0x00000000,0x0b000000,0x00000000,0x00000000,0x00040000,0x0000b000,0x00000400,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/*  13   1131   13 */{0x07017407,0x00000000,0x00000007,0x00000000,0x00000000,0x00000000,0x07000000,0x00000000,0x00000000,0x00010000,0x00007000,0x00000400,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/*  1333311133331  */{0x07fd5ff4,0x00000000,0x00000004,0x00000000,0x00000000,0x00000000,0x04000000,0x03fc0000,0x00000000,0x00010000,0x00004000,0x00001000,0x00000ff0,0x00000000,0x00000000,0x00000000,0x00000000},
/*  3111113111113  */{0x0d55d55c,0x00000000,0x0000000c,0x0000000c,0x00000000,0x0c000000,0x0c000000,0x0155c000,0x00000000,0x0000c000,0x0000c000,0x0000c000,0x0000d550,0x0000c000,0x0000c000,0x0000c000,0x00000000},
/*  1333311133331  */{0x07fd5ff4,0x00000000,0x00000000,0x00000004,0x00000000,0x04000000,0x00000000,0x03fc0000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000ff0,0x00001000,0x00004000,0x00010000,0x00000000},
/* 31   1311   31  */{0x34075034,0x00000000,0x00000000,0x00000034,0x00000000,0x34000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00001000,0x00034000,0x00040000,0x00000000},
/* 32   132 1  32  */{0x38078438,0x00000000,0x00000000,0x00000038,0x00000000,0x38000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000400,0x00038000,0x00040000,0x00000000},
/* 22  1 22 1  22  */{0x28128428,0x00000000,0x00000000,0x00000028,0x00000000,0x28000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000400,0x00028000,0x00100000,0x00000000},
/* 23 1  23  1 23  */{0x2c42c12c,0x00000000,0x00000000,0x0000002c,0x00000000,0x2c000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000100,0x0002c000,0x00400000,0x00000000},
/* 13 1  13  1 13  */{0x1c41c11c,0x00000000,0x00000000,0x0000001c,0x00000000,0x1c000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000100,0x0001c000,0x00400000,0x00000000},
/* 1 1   1    11   */{0x11010050,0x00000000,0x00000000,0x00000010,0x00000000,0x10000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000040,0x00010000,0x01000000,0x00000000},
/* 113333133331132 */{0x17fdff5e,0x00000000,0x00000000,0x00000010,0x03fcff00,0x10000000,0x00000000,0x00000000,0x0000000e,0x00000000,0x00000000,0x00000000,0x00000000,0x00000040,0x00010000,0x04000000,0x0000000e},
/*  11111111111 31 */{0x0555554d,0x00000000,0x00000000,0x00000000,0x05555540,0x00000000,0x00000000,0x00000000,0x0000000d,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x0000000d},
/*              1  */{0x00000004,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000004}
},{ /* 8 segment LED characters with dots instead of commas */
/*    11111111111  */{0x00555554,0x00555554,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/*   1333333333331 */{0x01fffffd,0x00fffffc,0x00000001,0x00000000,0x00000000,0x00000000,0x01000000,0x00000000,0x00000000},
/*   1           1 */{0x01000001,0x00000000,0x00000001,0x00000000,0x00000000,0x00000000,0x01000000,0x00000000,0x00000000},
/*  31          31 */{0x0d00000d,0x00000000,0x0000000d,0x00000000,0x00000000,0x00000000,0x0d000000,0x00000000,0x00000000},
/*  32          32 */{0x0e00000e,0x00000000,0x0000000e,0x00000000,0x00000000,0x00000000,0x0e000000,0x00000000,0x00000000},
/*  22          22 */{0x0a00000a,0x00000000,0x0000000a,0x00000000,0x00000000,0x00000000,0x0a000000,0x00000000,0x00000000},
/*  23          23 */{0x0b00000b,0x00000000,0x0000000b,0x00000000,0x00000000,0x00000000,0x0b000000,0x00000000,0x00000000},
/*  13          13 */{0x07000007,0x00000000,0x00000007,0x00000000,0x00000000,0x00000000,0x07000000,0x00000000,0x00000000},
/*  1333333333331  */{0x07fffff4,0x00000000,0x00000004,0x00000000,0x00000000,0x00000000,0x04000000,0x03fffff0,0x00000000},
/*  3111111111113  */{0x0d55555c,0x00000000,0x0000000c,0x0000000c,0x00000000,0x0c000000,0x0c000000,0x0d55555c,0x00000000},
/*  1333333333331  */{0x07fffff4,0x00000000,0x00000000,0x00000004,0x00000000,0x04000000,0x00000000,0x03fffff0,0x00000000},
/* 31          31  */{0x34000034,0x00000000,0x00000000,0x00000034,0x00000000,0x34000000,0x00000000,0x00000000,0x00000000},
/* 32          32  */{0x38000038,0x00000000,0x00000000,0x00000038,0x00000000,0x38000000,0x00000000,0x00000000,0x00000000},
/* 22          22  */{0x28000028,0x00000000,0x00000000,0x00000028,0x00000000,0x28000000,0x00000000,0x00000000,0x00000000},
/* 23          23  */{0x2c00002c,0x00000000,0x00000000,0x0000002c,0x00000000,0x2c000000,0x00000000,0x00000000,0x00000000},
/* 13          13  */{0x1c00001c,0x00000000,0x00000000,0x0000001c,0x00000000,0x1c000000,0x00000000,0x00000000,0x00000000},
/* 1           1   */{0x10000010,0x00000000,0x00000000,0x00000010,0x00000000,0x10000000,0x00000000,0x00000000,0x00000000},
/* 133333333333132 */{0x1fffffde,0x00000000,0x00000000,0x00000010,0x0fffffc0,0x10000000,0x00000000,0x00000000,0x0000000e},
/*  11111111111 31 */{0x0555554d,0x00000000,0x00000000,0x00000000,0x05555540,0x00000000,0x00000000,0x00000000,0x0000000d},
/*                 */{0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000}
},{ /* alphanumeric display characters (period only) */
/*    11111111111  */{0x00555554,0x00555554,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/*   1133331333311 */{0x017fdff5,0x003fcff0,0x00000001,0x00000000,0x00000000,0x00000000,0x01000000,0x00000000,0x00000000,0x00400000,0x00001000,0x00000004,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/*   11    1   1 1 */{0x01401011,0x00000000,0x00000001,0x00000000,0x00000000,0x00000000,0x01000000,0x00000000,0x00000000,0x00400000,0x00001000,0x00000010,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/*  31 1  31  1 31 */{0x0d10d04d,0x00000000,0x0000000d,0x00000000,0x00000000,0x00000000,0x0d000000,0x00000000,0x00000000,0x00100000,0x0000d000,0x00000040,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/*  32 1  32  1 32 */{0x0e10e04e,0x00000000,0x0000000e,0x00000000,0x00000000,0x00000000,0x0e000000,0x00000000,0x00000000,0x00100000,0x0000e000,0x00000040,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/*  22  1 22 1  22 */{0x0a04a10a,0x00000000,0x0000000a,0x00000000,0x00000000,0x00000000,0x0a000000,0x00000000,0x00000000,0x00040000,0x0000a000,0x00000100,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/*  23  1 231   23 */{0x0b04b40b,0x00000000,0x0000000b,0x00000000,0x00000000,0x00000000,0x0b000000,0x00000000,0x00000000,0x00040000,0x0000b000,0x00000400,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/*  13   1131   13 */{0x07017407,0x00000000,0x00000007,0x00000000,0x00000000,0x00000000,0x07000000,0x00000000,0x00000000,0x00010000,0x00007000,0x00000400,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/*  1333311133331  */{0x07fd5ff4,0x00000000,0x00000004,0x00000000,0x00000000,0x00000000,0x04000000,0x03fc0000,0x00000000,0x00010000,0x00004000,0x00001000,0x00000ff0,0x00000000,0x00000000,0x00000000,0x00000000},
/*  3111113111113  */{0x0d55d55c,0x00000000,0x0000000c,0x0000000c,0x00000000,0x0c000000,0x0c000000,0x0155c000,0x00000000,0x0000c000,0x0000c000,0x0000c000,0x0000d550,0x0000c000,0x0000c000,0x0000c000,0x00000000},
/*  1333311133331  */{0x07fd5ff4,0x00000000,0x00000000,0x00000004,0x00000000,0x04000000,0x00000000,0x03fc0000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000ff0,0x00001000,0x00004000,0x00010000,0x00000000},
/* 31   1311   31  */{0x34075034,0x00000000,0x00000000,0x00000034,0x00000000,0x34000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00001000,0x00034000,0x00040000,0x00000000},
/* 32   132 1  32  */{0x38078438,0x00000000,0x00000000,0x00000038,0x00000000,0x38000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000400,0x00038000,0x00040000,0x00000000},
/* 22  1 22 1  22  */{0x28128428,0x00000000,0x00000000,0x00000028,0x00000000,0x28000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000400,0x00028000,0x00100000,0x00000000},
/* 23 1  23  1 23  */{0x2c42c12c,0x00000000,0x00000000,0x0000002c,0x00000000,0x2c000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000100,0x0002c000,0x00400000,0x00000000},
/* 13 1  13  1 13  */{0x1c41c11c,0x00000000,0x00000000,0x0000001c,0x00000000,0x1c000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000100,0x0001c000,0x00400000,0x00000000},
/* 1 1   1    11   */{0x11010050,0x00000000,0x00000000,0x00000010,0x00000000,0x10000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000040,0x00010000,0x01000000,0x00000000},
/* 113333133331132 */{0x17fdff5e,0x00000000,0x00000000,0x00000010,0x03fcff00,0x10000000,0x00000000,0x00000000,0x0000000e,0x00000000,0x00000000,0x00000000,0x00000000,0x00000040,0x00010000,0x04000000,0x0000000e},
/*  11111111111 31 */{0x0555554d,0x00000000,0x00000000,0x00000000,0x05555540,0x00000000,0x00000000,0x00000000,0x0000000d,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x0000000d},
/*                 */{0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000}
}};
static const tSegRow segSize1[3][20] = { /* without commas */
{ /* alphanumeric display characters */
/*                       all        0001       0002       0004       0008       0010       0020       0040       0080       0100       0200       0400       0800       1000       2000       4000 */
/*    11111111111  */{0x00555554,0x00555554,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/*   1133331333311 */{0x017fdff5,0x003fcff0,0x00000001,0x00000000,0x00000000,0x00000000,0x01000000,0x00000000,0x00000000,0x00400000,0x00001000,0x00000004,0x00000000,0x00000000,0x00000000,0x00000000},
/*   11    1   1 1 */{0x01401011,0x00000000,0x00000001,0x00000000,0x00000000,0x00000000,0x01000000,0x00000000,0x00000000,0x00400000,0x00001000,0x00000010,0x00000000,0x00000000,0x00000000,0x00000000},
/*  31 1  31  1 31 */{0x0d10d04d,0x00000000,0x0000000d,0x00000000,0x00000000,0x00000000,0x0d000000,0x00000000,0x00000000,0x00100000,0x0000d000,0x00000040,0x00000000,0x00000000,0x00000000,0x00000000},
/*  32 1  32  1 32 */{0x0e10e04e,0x00000000,0x0000000e,0x00000000,0x00000000,0x00000000,0x0e000000,0x00000000,0x00000000,0x00100000,0x0000e000,0x00000040,0x00000000,0x00000000,0x00000000,0x00000000},
/*  22  1 22 1  22 */{0x0a04a10a,0x00000000,0x0000000a,0x00000000,0x00000000,0x00000000,0x0a000000,0x00000000,0x00000000,0x00040000,0x0000a000,0x00000100,0x00000000,0x00000000,0x00000000,0x00000000},
/*  23  1 231   23 */{0x0b04b40b,0x00000000,0x0000000b,0x00000000,0x00000000,0x00000000,0x0b000000,0x00000000,0x00000000,0x00040000,0x0000b000,0x00000400,0x00000000,0x00000000,0x00000000,0x00000000},
/*  13   1131   13 */{0x07017407,0x00000000,0x00000007,0x00000000,0x00000000,0x00000000,0x07000000,0x00000000,0x00000000,0x00010000,0x00007000,0x00000400,0x00000000,0x00000000,0x00000000,0x00000000},
/*  1333311133331  */{0x07fd5ff4,0x00000000,0x00000004,0x00000000,0x00000000,0x00000000,0x04000000,0x03fc0000,0x00000000,0x00010000,0x00004000,0x00001000,0x00000ff0,0x00000000,0x00000000,0x00000000},
/*  3111113111113  */{0x0d55d55c,0x00000000,0x0000000c,0x0000000c,0x00000000,0x0c000000,0x0c000000,0x0155c000,0x00000000,0x0000c000,0x0000c000,0x0000c000,0x0000d550,0x0000c000,0x0000c000,0x0000c000},
/*  1333311133331  */{0x07fd5ff4,0x00000000,0x00000000,0x00000004,0x00000000,0x04000000,0x00000000,0x03fc0000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000ff0,0x00001000,0x00004000,0x00010000},
/* 31   1311   31  */{0x34075034,0x00000000,0x00000000,0x00000034,0x00000000,0x34000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00001000,0x00034000,0x00040000},
/* 32   132 1  32  */{0x38078438,0x00000000,0x00000000,0x00000038,0x00000000,0x38000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000400,0x00038000,0x00040000},
/* 22  1 22 1  22  */{0x28128428,0x00000000,0x00000000,0x00000028,0x00000000,0x28000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000400,0x00028000,0x00100000},
/* 23 1  23  1 23  */{0x2c42c12c,0x00000000,0x00000000,0x0000002c,0x00000000,0x2c000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000100,0x0002c000,0x00400000},
/* 13 1  13  1 13  */{0x1c41c11c,0x00000000,0x00000000,0x0000001c,0x00000000,0x1c000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000100,0x0001c000,0x00400000},
/* 1 1   1    11   */{0x11010050,0x00000000,0x00000000,0x00000010,0x00000000,0x10000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000040,0x00010000,0x01000000},
/* 1133331333311   */{0x17fdff50,0x00000000,0x00000000,0x00000010,0x03fcff00,0x10000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000040,0x00010000,0x04000000},
/*  11111111111    */{0x05555540,0x00000000,0x00000000,0x00000000,0x05555540,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/*                 */{0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000}
},{ /* 7 segment LED characters */
/*    11111111111  */{0x00555554,0x00555554,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/*   1333333333331 */{0x01fffffd,0x00fffffc,0x00000001,0x00000000,0x00000000,0x00000000,0x01000000,0x00000000},
/*   1           1 */{0x01000001,0x00000000,0x00000001,0x00000000,0x00000000,0x00000000,0x01000000,0x00000000},
/*  31          31 */{0x0d00000d,0x00000000,0x0000000d,0x00000000,0x00000000,0x00000000,0x0d000000,0x00000000},
/*  32          32 */{0x0e00000e,0x00000000,0x0000000e,0x00000000,0x00000000,0x00000000,0x0e000000,0x00000000},
/*  22          22 */{0x0a00000a,0x00000000,0x0000000a,0x00000000,0x00000000,0x00000000,0x0a000000,0x00000000},
/*  23          23 */{0x0b00000b,0x00000000,0x0000000b,0x00000000,0x00000000,0x00000000,0x0b000000,0x00000000},
/*  13          13 */{0x07000007,0x00000000,0x00000007,0x00000000,0x00000000,0x00000000,0x07000000,0x00000000},
/*  1333333333331  */{0x07fffff4,0x00000000,0x00000004,0x00000000,0x00000000,0x00000000,0x04000000,0x03fffff0},
/*  3111111111113  */{0x0d55555c,0x00000000,0x0000000c,0x0000000c,0x00000000,0x0c000000,0x0c000000,0x0d55555c},
/*  1333333333331  */{0x07fffff4,0x00000000,0x00000000,0x00000004,0x00000000,0x04000000,0x00000000,0x03fffff0},
/* 31          31  */{0x34000034,0x00000000,0x00000000,0x00000034,0x00000000,0x34000000,0x00000000,0x00000000},
/* 32          32  */{0x38000038,0x00000000,0x00000000,0x00000038,0x00000000,0x38000000,0x00000000,0x00000000},
/* 22          22  */{0x28000028,0x00000000,0x00000000,0x00000028,0x00000000,0x28000000,0x00000000,0x00000000},
/* 23          23  */{0x2c00002c,0x00000000,0x00000000,0x0000002c,0x00000000,0x2c000000,0x00000000,0x00000000},
/* 13          13  */{0x1c00001c,0x00000000,0x00000000,0x0000001c,0x00000000,0x1c000000,0x00000000,0x00000000},
/* 1           1   */{0x10000010,0x00000000,0x00000000,0x00000010,0x00000000,0x10000000,0x00000000,0x00000000},
/* 1333333333331   */{0x1fffffd0,0x00000000,0x00000000,0x00000010,0x0fffffc0,0x10000000,0x00000000,0x00000000},
/*  11111111111    */{0x05555540,0x00000000,0x00000000,0x00000000,0x05555540,0x00000000,0x00000000,0x00000000},
/*                 */{0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000}
},{ /* 9 segment LED characters */
/*    11111111111  */{0x00555554,0x00555554,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/*   1333331333331 */{0x01ffdffd,0x00ffcffc,0x00000001,0x00000000,0x00000000,0x00000000,0x01000000,0x00000000,0x00000000,0x00001000,0x00000000},
/*   1     1     1 */{0x01001001,0x00000000,0x00000001,0x00000000,0x00000000,0x00000000,0x01000000,0x00000000,0x00000000,0x00001000,0x00000000},
/*  31    31    31 */{0x0d00d00d,0x00000000,0x0000000d,0x00000000,0x00000000,0x00000000,0x0d000000,0x00000000,0x00000000,0x0000d000,0x00000000},
/*  32    32    32 */{0x0e00e00e,0x00000000,0x0000000e,0x00000000,0x00000000,0x00000000,0x0e000000,0x00000000,0x00000000,0x0000e000,0x00000000},
/*  22    22    22 */{0x0a00a00a,0x00000000,0x0000000a,0x00000000,0x00000000,0x00000000,0x0a000000,0x00000000,0x00000000,0x0000a000,0x00000000},
/*  23    23    23 */{0x0b00b00b,0x00000000,0x0000000b,0x00000000,0x00000000,0x00000000,0x0b000000,0x00000000,0x00000000,0x0000b000,0x00000000},
/*  13    13    13 */{0x07007007,0x00000000,0x00000007,0x00000000,0x00000000,0x00000000,0x07000000,0x00000000,0x00000000,0x00007000,0x00000000},
/*  1333331333331  */{0x07ff7ff4,0x00000000,0x00000004,0x00000000,0x00000000,0x00000000,0x04000000,0x03ff3ff0,0x00000000,0x00004000,0x00000000},
/*  3111111111113  */{0x0d55555c,0x00000000,0x0000000c,0x0000000c,0x00000000,0x0c000000,0x0c000000,0x0d55555c,0x00000000,0x0000c000,0x0000c000},
/*  1333331333331  */{0x07ff7ff4,0x00000000,0x00000000,0x00000004,0x00000000,0x04000000,0x00000000,0x03ff3ff0,0x00000000,0x00000000,0x00004000},
/* 31    31    31  */{0x34034034,0x00000000,0x00000000,0x00000034,0x00000000,0x34000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00034000},
/* 32    32    32  */{0x38038038,0x00000000,0x00000000,0x00000038,0x00000000,0x38000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00038000},
/* 22    22    22  */{0x28028028,0x00000000,0x00000000,0x00000028,0x00000000,0x28000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00028000},
/* 23    23    23  */{0x2c02c02c,0x00000000,0x00000000,0x0000002c,0x00000000,0x2c000000,0x00000000,0x00000000,0x00000000,0x00000000,0x0002c000},
/* 13    13    13  */{0x1c01c01c,0x00000000,0x00000000,0x0000001c,0x00000000,0x1c000000,0x00000000,0x00000000,0x00000000,0x00000000,0x0001c000},
/* 1     1     1   */{0x10010010,0x00000000,0x00000000,0x00000010,0x00000000,0x10000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00010000},
/* 1333331333331   */{0x1ffdffd0,0x00000000,0x00000000,0x00000010,0x0ffcffc0,0x10000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00010000},
/*  11111111111    */{0x05555540,0x00000000,0x00000000,0x00000000,0x05555540,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/*                 */{0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000}
}};
static const tSegRow segSize2C[6][12] = { /* with commas */
{ /* alphanumeric display characters */
/*                   all        0001       0002       0004       0008       0010       0020       0040       0080       0100       0200       0400       0800       1000       2000       4000       8000 */
/*  xxxxxxx    */{0x05554000,0x05554000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/* xx  x  xx   */{0x14105000,0x00000000,0x00001000,0x00000000,0x00000000,0x00000000,0x10000000,0x00000000,0x00000000,0x04000000,0x00100000,0x00004000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/* x x x x x   */{0x11111000,0x00000000,0x00001000,0x00000000,0x00000000,0x00000000,0x10000000,0x00000000,0x00000000,0x01000000,0x00100000,0x00010000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/* x x x x x   */{0x11111000,0x00000000,0x00001000,0x00000000,0x00000000,0x00000000,0x10000000,0x00000000,0x00000000,0x01000000,0x00100000,0x00010000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/* x  xxx  x   */{0x10541000,0x00000000,0x00001000,0x00000000,0x00000000,0x00000000,0x10000000,0x00000000,0x00000000,0x00400000,0x00100000,0x00040000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/*  xxx xxx    */{0x05454000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x05400000,0x00000000,0x00000000,0x00000000,0x00000000,0x00054000,0x00000000,0x00000000,0x00000000,0x00000000},
/* x  xxx  x   */{0x10541000,0x00000000,0x00000000,0x00001000,0x00000000,0x10000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00040000,0x00100000,0x00400000,0x00000000},
/* x x x x x   */{0x11111000,0x00000000,0x00000000,0x00001000,0x00000000,0x10000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00010000,0x00100000,0x01000000,0x00000000},
/* x x x x x   */{0x11111000,0x00000000,0x00000000,0x00001000,0x00000000,0x10000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00010000,0x00100000,0x01000000,0x00000000},
/* xx  x  xx x */{0x14105100,0x00000000,0x00000000,0x00001000,0x00000000,0x10000000,0x00000000,0x00000000,0x00000100,0x00000000,0x00000000,0x00000000,0x00000000,0x00004000,0x00100000,0x04000000,0x00000000},
/*  xxxxxxx  x */{0x05554100,0x00000000,0x00000000,0x00000000,0x05554000,0x00000000,0x00000000,0x00000000,0x00000100,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000100},
/*          x  */{0x00000400,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000400,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000}
},{ /* 8 segment LED characters */
/*  xxxxxxx    */{0x05554000,0x05554000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/* x       x   */{0x10001000,0x00000000,0x00001000,0x00000000,0x00000000,0x00000000,0x10000000,0x00000000,0x00000000},
/* x       x   */{0x10001000,0x00000000,0x00001000,0x00000000,0x00000000,0x00000000,0x10000000,0x00000000,0x00000000},
/* x       x   */{0x10001000,0x00000000,0x00001000,0x00000000,0x00000000,0x00000000,0x10000000,0x00000000,0x00000000},
/* x       x   */{0x10001000,0x00000000,0x00001000,0x00000000,0x00000000,0x00000000,0x10000000,0x00000000,0x00000000},
/*  xxxxxxx    */{0x05554000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x05554000,0x00000000},
/* x       x   */{0x10001000,0x00000000,0x00000000,0x00001000,0x00000000,0x10000000,0x00000000,0x00000000,0x00000000},
/* x       x   */{0x10001000,0x00000000,0x00000000,0x00001000,0x00000000,0x10000000,0x00000000,0x00000000,0x00000000},
/* x       x   */{0x10001000,0x00000000,0x00000000,0x00001000,0x00000000,0x10000000,0x00000000,0x00000000,0x00000000},
/* x       x x */{0x10001100,0x00000000,0x00000000,0x00001000,0x00000000,0x10000000,0x00000000,0x00000000,0x00000100},
/*  xxxxxxx  x */{0x05554100,0x00000000,0x00000000,0x00000000,0x05554000,0x00000000,0x00000000,0x00000000,0x00000100},
/*          x  */{0x00000400,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000400}
},{ /* 10 segment LED characters */
/*  xxxxxxx    */{0x05554000,0x05554000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/* x   x   x   */{0x10101000,0x00000000,0x00001000,0x00000000,0x00000000,0x00000000,0x10000000,0x00000000,0x00000000,0x00100000,0x00000000},
/* x   x   x   */{0x10101000,0x00000000,0x00001000,0x00000000,0x00000000,0x00000000,0x10000000,0x00000000,0x00000000,0x00100000,0x00000000},
/* x   x   x   */{0x10101000,0x00000000,0x00001000,0x00000000,0x00000000,0x00000000,0x10000000,0x00000000,0x00000000,0x00100000,0x00000000},
/* x   x   x   */{0x10101000,0x00000000,0x00001000,0x00000000,0x00000000,0x00000000,0x10000000,0x00000000,0x00000000,0x00100000,0x00000000},
/*  xxxxxxx    */{0x05554000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x05554000,0x00000000,0x00000000,0x00000000},
/* x   x   x   */{0x10101000,0x00000000,0x00000000,0x00001000,0x00000000,0x10000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00100000},
/* x   x   x   */{0x10101000,0x00000000,0x00000000,0x00001000,0x00000000,0x10000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00100000},
/* x   x   x   */{0x10101000,0x00000000,0x00000000,0x00001000,0x00000000,0x10000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00100000},
/* x   x   x x */{0x10101100,0x00000000,0x00000000,0x00001000,0x00000000,0x10000000,0x00000000,0x00000000,0x00000100,0x00000000,0x00100000},
/*  xxxxxxx  x */{0x05554100,0x00000000,0x00000000,0x00000000,0x05554000,0x00000000,0x00000000,0x00000000,0x00000100,0x00000000,0x00000000},
/*          x  */{0x00000400,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000400,0x00000000,0x00000000}
},{ /* alphanumeric display characters (reversed comma with period) */
/*  xxxxxxx    */{0x05554000,0x05554000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/* xx  x  xx   */{0x14105000,0x00000000,0x00001000,0x00000000,0x00000000,0x00000000,0x10000000,0x00000000,0x00000000,0x04000000,0x00100000,0x00004000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/* x x x x x   */{0x11111000,0x00000000,0x00001000,0x00000000,0x00000000,0x00000000,0x10000000,0x00000000,0x00000000,0x01000000,0x00100000,0x00010000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/* x x x x x   */{0x11111000,0x00000000,0x00001000,0x00000000,0x00000000,0x00000000,0x10000000,0x00000000,0x00000000,0x01000000,0x00100000,0x00010000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/* x  xxx  x   */{0x10541000,0x00000000,0x00001000,0x00000000,0x00000000,0x00000000,0x10000000,0x00000000,0x00000000,0x00400000,0x00100000,0x00040000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/*  xxx xxx    */{0x05454000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x05400000,0x00000000,0x00000000,0x00000000,0x00000000,0x00054000,0x00000000,0x00000000,0x00000000,0x00000000},
/* x  xxx  x   */{0x10541000,0x00000000,0x00000000,0x00001000,0x00000000,0x10000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00040000,0x00100000,0x00400000,0x00000000},
/* x x x x x   */{0x11111000,0x00000000,0x00000000,0x00001000,0x00000000,0x10000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00010000,0x00100000,0x01000000,0x00000000},
/* x x x x x   */{0x11111000,0x00000000,0x00000000,0x00001000,0x00000000,0x10000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00010000,0x00100000,0x01000000,0x00000000},
/* xx  x  xx x */{0x14105100,0x00000000,0x00000000,0x00001000,0x00000000,0x10000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00004000,0x00100000,0x04000000,0x00000100},
/*  xxxxxxx  x */{0x05554100,0x00000000,0x00000000,0x00000000,0x05554000,0x00000000,0x00000000,0x00000000,0x00000100,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000100},
/*          x  */{0x00000400,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000400}
},{ /* 8 segment LED characters with dots instead of commas */
/*  xxxxxxx    */{0x05554000,0x05554000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/* x       x   */{0x10001000,0x00000000,0x00001000,0x00000000,0x00000000,0x00000000,0x10000000,0x00000000,0x00000000},
/* x       x   */{0x10001000,0x00000000,0x00001000,0x00000000,0x00000000,0x00000000,0x10000000,0x00000000,0x00000000},
/* x       x   */{0x10001000,0x00000000,0x00001000,0x00000000,0x00000000,0x00000000,0x10000000,0x00000000,0x00000000},
/* x       x   */{0x10001000,0x00000000,0x00001000,0x00000000,0x00000000,0x00000000,0x10000000,0x00000000,0x00000000},
/*  xxxxxxx    */{0x05554000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x05554000,0x00000000},
/* x       x   */{0x10001000,0x00000000,0x00000000,0x00001000,0x00000000,0x10000000,0x00000000,0x00000000,0x00000000},
/* x       x   */{0x10001000,0x00000000,0x00000000,0x00001000,0x00000000,0x10000000,0x00000000,0x00000000,0x00000000},
/* x       x   */{0x10001000,0x00000000,0x00000000,0x00001000,0x00000000,0x10000000,0x00000000,0x00000000,0x00000000},
/* x       x   */{0x10001000,0x00000000,0x00000000,0x00001000,0x00000000,0x10000000,0x00000000,0x00000000,0x00000000},
/*  xxxxxxx  x */{0x05554100,0x00000000,0x00000000,0x00000000,0x05554000,0x00000000,0x00000000,0x00000000,0x00000100},
/*             */{0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000}
},{ /* alphanumeric display characters (period only) */
/*  xxxxxxx    */{0x05554000,0x05554000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/* xx  x  xx   */{0x14105000,0x00000000,0x00001000,0x00000000,0x00000000,0x00000000,0x10000000,0x00000000,0x00000000,0x04000000,0x00100000,0x00004000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/* x x x x x   */{0x11111000,0x00000000,0x00001000,0x00000000,0x00000000,0x00000000,0x10000000,0x00000000,0x00000000,0x01000000,0x00100000,0x00010000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/* x x x x x   */{0x11111000,0x00000000,0x00001000,0x00000000,0x00000000,0x00000000,0x10000000,0x00000000,0x00000000,0x01000000,0x00100000,0x00010000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/* x  xxx  x   */{0x10541000,0x00000000,0x00001000,0x00000000,0x00000000,0x00000000,0x10000000,0x00000000,0x00000000,0x00400000,0x00100000,0x00040000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/*  xxx xxx    */{0x05454000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x05400000,0x00000000,0x00000000,0x00000000,0x00000000,0x00054000,0x00000000,0x00000000,0x00000000,0x00000000},
/* x  xxx  x   */{0x10541000,0x00000000,0x00000000,0x00001000,0x00000000,0x10000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00040000,0x00100000,0x00400000,0x00000000},
/* x x x x x   */{0x11111000,0x00000000,0x00000000,0x00001000,0x00000000,0x10000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00010000,0x00100000,0x01000000,0x00000000},
/* x x x x x   */{0x11111000,0x00000000,0x00000000,0x00001000,0x00000000,0x10000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00010000,0x00100000,0x01000000,0x00000000},
/* xx  x  xx   */{0x14105000,0x00000000,0x00000000,0x00001000,0x00000000,0x10000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00004000,0x00100000,0x04000000,0x00000000},
/*  xxxxxxx  x */{0x05554100,0x00000000,0x00000000,0x00000000,0x05554000,0x00000000,0x00000000,0x00000000,0x00000100,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000100},
/*             */{0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000}
}};
static const tSegRow segSize2[3][12] = { /* without commas */
{ /* alphanumeric display characters */
/*                   all        0001       0002       0004       0008       0010       0020       0040       0080       0100       0200       0400       0800       1000       2000       4000       8000 */
/*  xxxxxxx    */{0x05554000,0x05554000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/* xx  x  xx   */{0x14105000,0x00000000,0x00001000,0x00000000,0x00000000,0x00000000,0x10000000,0x00000000,0x00000000,0x04000000,0x00100000,0x00004000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/* x x x x x   */{0x11111000,0x00000000,0x00001000,0x00000000,0x00000000,0x00000000,0x10000000,0x00000000,0x00000000,0x01000000,0x00100000,0x00010000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/* x x x x x   */{0x11111000,0x00000000,0x00001000,0x00000000,0x00000000,0x00000000,0x10000000,0x00000000,0x00000000,0x01000000,0x00100000,0x00010000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/* x  xxx  x   */{0x10541000,0x00000000,0x00001000,0x00000000,0x00000000,0x00000000,0x10000000,0x00000000,0x00000000,0x00400000,0x00100000,0x00040000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/*  xxx xxx    */{0x05454000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x05400000,0x00000000,0x00000000,0x00000000,0x00000000,0x00054000,0x00000000,0x00000000,0x00000000,0x00000000},
/* x  xxx  x   */{0x10541000,0x00000000,0x00000000,0x00001000,0x00000000,0x10000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00040000,0x00100000,0x00400000,0x00000000},
/* x x x x x   */{0x11111000,0x00000000,0x00000000,0x00001000,0x00000000,0x10000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00010000,0x00100000,0x01000000,0x00000000},
/* x x x x x   */{0x11111000,0x00000000,0x00000000,0x00001000,0x00000000,0x10000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00010000,0x00100000,0x01000000,0x00000000},
/* xx  x  xx   */{0x14105000,0x00000000,0x00000000,0x00001000,0x00000000,0x10000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00004000,0x00100000,0x04000000,0x00000000},
/*  xxxxxxx    */{0x05554000,0x00000000,0x00000000,0x00000000,0x05554000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/*             */{0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000}
},{ /* 7 segment LED characters */
/*  xxxxxxx    */{0x05554000,0x05554000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/* x       x   */{0x10001000,0x00000000,0x00001000,0x00000000,0x00000000,0x00000000,0x10000000,0x00000000},
/* x       x   */{0x10001000,0x00000000,0x00001000,0x00000000,0x00000000,0x00000000,0x10000000,0x00000000},
/* x       x   */{0x10001000,0x00000000,0x00001000,0x00000000,0x00000000,0x00000000,0x10000000,0x00000000},
/* x       x   */{0x10001000,0x00000000,0x00001000,0x00000000,0x00000000,0x00000000,0x10000000,0x00000000},
/*  xxxxxxx    */{0x05554000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x05554000},
/* x       x   */{0x10001000,0x00000000,0x00000000,0x00001000,0x00000000,0x10000000,0x00000000,0x00000000},
/* x       x   */{0x10001000,0x00000000,0x00000000,0x00001000,0x00000000,0x10000000,0x00000000,0x00000000},
/* x       x   */{0x10001000,0x00000000,0x00000000,0x00001000,0x00000000,0x10000000,0x00000000,0x00000000},
/* x       x   */{0x10001000,0x00000000,0x00000000,0x00001000,0x00000000,0x10000000,0x00000000,0x00000000},
/*  xxxxxxx    */{0x05554000,0x00000000,0x00000000,0x00000000,0x05554000,0x00000000,0x00000000,0x00000000},
/*             */{0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000}
},{ /* 9 segment LED characters */
/*  xxxxxxx    */{0x05554000,0x05554000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/* x   x   x   */{0x10101000,0x00000000,0x00001000,0x00000000,0x00000000,0x00000000,0x10000000,0x00000000,0x00000000,0x00100000,0x00000000},
/* x   x   x   */{0x10101000,0x00000000,0x00001000,0x00000000,0x00000000,0x00000000,0x10000000,0x00000000,0x00000000,0x00100000,0x00000000},
/* x   x   x   */{0x10101000,0x00000000,0x00001000,0x00000000,0x00000000,0x00000000,0x10000000,0x00000000,0x00000000,0x00100000,0x00000000},
/* x   x   x   */{0x10101000,0x00000000,0x00001000,0x00000000,0x00000000,0x00000000,0x10000000,0x00000000,0x00000000,0x00100000,0x00000000},
/*  xxxxxxx    */{0x05554000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x05554000,0x00000000,0x00000000,0x00000000},
/* x   x   x   */{0x10101000,0x00000000,0x00000000,0x00001000,0x00000000,0x10000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00100000},
/* x   x   x   */{0x10101000,0x00000000,0x00000000,0x00001000,0x00000000,0x10000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00100000},
/* x   x   x   */{0x10101000,0x00000000,0x00000000,0x00001000,0x00000000,0x10000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00100000},
/* x   x   x   */{0x10101000,0x00000000,0x00000000,0x00001000,0x00000000,0x10000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00100000},
/*  xxxxxxx    */{0x05554000,0x00000000,0x00000000,0x00000000,0x05554000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/*             */{0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000}
}};
static const tSegRow segSize3C[3][8] = {
{ /* alphanumeric display characters */
{0} /* not possible */
},{ /* 8 segment LED characters with commas */
/*               all        0001       0002       0004       0008       0010       0020       0040       0080       0100       0200 */
/*  xxx    */{0x05400000,0x05400000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/* x   x   */{0x10100000,0x00000000,0x00100000,0x00000000,0x00000000,0x00000000,0x10000000,0x00000000,0x00000000},
/* x   x   */{0x10100000,0x00000000,0x00100000,0x00000000,0x00000000,0x00000000,0x10000000,0x00000000,0x00000000},
/*  xxx    */{0x05400000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x05400000,0x00000000},
/* x   x   */{0x10100000,0x00000000,0x00000000,0x00100000,0x00000000,0x10000000,0x00000000,0x00000000,0x00000000},
/* x   x   */{0x10100000,0x00000000,0x00000000,0x00100000,0x00000000,0x10000000,0x00000000,0x00000000,0x00000000},
/*  xxx  x */{0x05410000,0x00000000,0x00000000,0x00000000,0x05400000,0x00000000,0x00000000,0x00000000,0x00010000},
/*      x  */{0x00040000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00040000}
},{ /* 10 segment LED characters with commas */
/*  xxx    */{0x05400000,0x05400000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/* x x x   */{0x11100000,0x00000000,0x00100000,0x00000000,0x00000000,0x00000000,0x10000000,0x00000000,0x00000000,0x01000000,0x00000000},
/* x x x   */{0x11100000,0x00000000,0x00100000,0x00000000,0x00000000,0x00000000,0x10000000,0x00000000,0x00000000,0x01000000,0x00000000},
/*  xxx    */{0x05400000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x05400000,0x00000000,0x00000000,0x00000000},
/* x x x   */{0x11100000,0x00000000,0x00000000,0x00100000,0x00000000,0x10000000,0x00000000,0x00000000,0x00000000,0x00000000,0x01000000},
/* x x x   */{0x11100000,0x00000000,0x00000000,0x00100000,0x00000000,0x10000000,0x00000000,0x00000000,0x00000000,0x00000000,0x01000000},
/*  xxx  x */{0x05410000,0x00000000,0x00000000,0x00000000,0x05400000,0x00000000,0x00000000,0x00000000,0x00010000,0x00000000,0x00000000},
/*      x  */{0x00040000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00040000,0x00000000,0x00000000}
}};
static const tSegRow segSize3[3][8] = {
{ /* alphanumeric display characters */
{0} /* not possible */
},{ /* 8 segment LED characters without commas */
/*               all        0001       0002       0004       0008       0010       0020       0040       0080       0100       0200 */
/*  xxx    */{0x05400000,0x05400000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/* x   x   */{0x10100000,0x00000000,0x00100000,0x00000000,0x00000000,0x00000000,0x10000000,0x00000000},
/* x   x   */{0x10100000,0x00000000,0x00100000,0x00000000,0x00000000,0x00000000,0x10000000,0x00000000},
/*  xxx    */{0x05400000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x05400000},
/* x   x   */{0x10100000,0x00000000,0x00000000,0x00100000,0x00000000,0x10000000,0x00000000,0x00000000},
/* x   x   */{0x10100000,0x00000000,0x00000000,0x00100000,0x00000000,0x10000000,0x00000000,0x00000000},
/*  xxx    */{0x05400000,0x00000000,0x00000000,0x00000000,0x05400000,0x00000000,0x00000000,0x00000000},
/*         */{0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000}
},{ /* 10 segment LED characters without commas */
/*  xxx    */{0x05400000,0x05400000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/* x x x   */{0x11100000,0x00000000,0x00100000,0x00000000,0x00000000,0x00000000,0x10000000,0x00000000,0x00000000,0x01000000,0x00000000},
/* x x x   */{0x11100000,0x00000000,0x00100000,0x00000000,0x00000000,0x00000000,0x10000000,0x00000000,0x00000000,0x01000000,0x00000000},
/*  xxx    */{0x05400000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x05400000,0x00000000,0x00000000,0x00000000},
/* x x x   */{0x11100000,0x00000000,0x00000000,0x00100000,0x00000000,0x10000000,0x00000000,0x00000000,0x00000000,0x00000000,0x01000000},
/* x x x   */{0x11100000,0x00000000,0x00000000,0x00100000,0x00000000,0x10000000,0x00000000,0x00000000,0x00000000,0x00000000,0x01000000},
/*  xxx    */{0x05400000,0x00000000,0x00000000,0x00000000,0x05400000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/*         */{0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000}
}};
static const tSegRow segSize1S[1][20] = { /* 16 segment displays without commas but split top & bottom lines */
{ /* alphanumeric display characters */
/*                       all        0001       0002       0004       0008       0010       0020       0040       0080       0100       0200       0400       0800       1000       2000       4000       8000 */
/*    11111311111  */{0x00557554,0x00557000,0x00003554,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/*   1133331333311 */{0x017fdff5,0x003fc000,0x00003ff0,0x00000001,0x00000000,0x00000000,0x00000000,0x00000000,0x01000000,0x00400000,0x00001000,0x00000004,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/*   11    1   1 1 */{0x01401011,0x00000000,0x00000000,0x00000001,0x00000000,0x00000000,0x00000000,0x00000000,0x01000000,0x00400000,0x00001000,0x00000010,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/*  31 1  31  1 31 */{0x0d10d04d,0x00000000,0x00000000,0x0000000d,0x00000000,0x00000000,0x00000000,0x00000000,0x0d000000,0x00100000,0x0000d000,0x00000040,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/*  32 1  32  1 32 */{0x0e10e04e,0x00000000,0x00000000,0x0000000e,0x00000000,0x00000000,0x00000000,0x00000000,0x0e000000,0x00100000,0x0000e000,0x00000040,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/*  22  1 22 1  22 */{0x0a04a10a,0x00000000,0x00000000,0x0000000a,0x00000000,0x00000000,0x00000000,0x00000000,0x0a000000,0x00040000,0x0000a000,0x00000100,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/*  23  1 231   23 */{0x0b04b40b,0x00000000,0x00000000,0x0000000b,0x00000000,0x00000000,0x00000000,0x00000000,0x0b000000,0x00040000,0x0000b000,0x00000400,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/*  13   1131   13 */{0x07017407,0x00000000,0x00000000,0x00000007,0x00000000,0x00000000,0x00000000,0x00000000,0x07000000,0x00010000,0x00007000,0x00000400,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/*  1333311133331  */{0x07fd5ff4,0x00000000,0x00000000,0x00000004,0x00000000,0x00000000,0x00000000,0x00000000,0x04000000,0x00010000,0x00004000,0x00001000,0x00000ff0,0x00000000,0x00000000,0x00000000,0x03fc0000},
/*  3111113111113  */{0x0d55d55c,0x00000000,0x00000000,0x0000000c,0x0000000c,0x00000000,0x00000000,0x0c000000,0x0c000000,0x0000c000,0x0000c000,0x0000c000,0x0000d550,0x0000c000,0x0000c000,0x0000c000,0x0155c000},
/*  1333311133331  */{0x07fd5ff4,0x00000000,0x00000000,0x00000000,0x00000004,0x00000000,0x00000000,0x04000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000ff0,0x00001000,0x00004000,0x00010000,0x03fc0000},
/* 31   1311   31  */{0x34075034,0x00000000,0x00000000,0x00000000,0x00000034,0x00000000,0x00000000,0x34000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00001000,0x00034000,0x00040000,0x00000000},
/* 32   132 1  32  */{0x38078438,0x00000000,0x00000000,0x00000000,0x00000038,0x00000000,0x00000000,0x38000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000400,0x00038000,0x00040000,0x00000000},
/* 22  1 22 1  22  */{0x28128428,0x00000000,0x00000000,0x00000000,0x00000028,0x00000000,0x00000000,0x28000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000400,0x00028000,0x00100000,0x00000000},
/* 23 1  23  1 23  */{0x2c42c12c,0x00000000,0x00000000,0x00000000,0x0000002c,0x00000000,0x00000000,0x2c000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000100,0x0002c000,0x00400000,0x00000000},
/* 13 1  13  1 13  */{0x1c41c11c,0x00000000,0x00000000,0x00000000,0x0000001c,0x00000000,0x00000000,0x1c000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000100,0x0001c000,0x00400000,0x00000000},
/* 1 1   1    11   */{0x11010050,0x00000000,0x00000000,0x00000000,0x00000010,0x00000000,0x00000000,0x10000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000040,0x00010000,0x01000000,0x00000000},
/* 1133331333311   */{0x17fdff50,0x00000000,0x00000000,0x00000000,0x00000010,0x0003ff00,0x03fc0000,0x10000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000040,0x00010000,0x04000000,0x00000000},
/*  11111311111    */{0x05575540,0x00000000,0x00000000,0x00000000,0x00000000,0x00035540,0x05570000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/*                 */{0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000}
}};
static const tSegRow segSize2S[1][12] = { /* 16 segment displays without commas but split top & bottom lines */
{ /* alphanumeric display characters */
/*                   all        0001       0002       0004       0008       0010       0020       0040       0080       0100       0200       0400       0800       1000       2000       4000       8000 */
/*  xxxxxxx    */{0x05754000,0x05700000,0x00354000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/* xx  x  xx   */{0x14105000,0x00000000,0x00000000,0x00001000,0x00000000,0x00000000,0x00000000,0x00000000,0x10000000,0x04000000,0x00100000,0x00004000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/* x x x x x   */{0x11111000,0x00000000,0x00000000,0x00001000,0x00000000,0x00000000,0x00000000,0x00000000,0x10000000,0x01000000,0x00100000,0x00010000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/* x x x x x   */{0x11111000,0x00000000,0x00000000,0x00001000,0x00000000,0x00000000,0x00000000,0x00000000,0x10000000,0x01000000,0x00100000,0x00010000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/* x  xxx  x   */{0x10541000,0x00000000,0x00000000,0x00001000,0x00000000,0x00000000,0x00000000,0x00000000,0x10000000,0x00400000,0x00100000,0x00040000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/*  xxx xxx    */{0x05454000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00054000,0x00000000,0x00000000,0x00000000,0x05400000},
/* x  xxx  x   */{0x10541000,0x00000000,0x00000000,0x00000000,0x00001000,0x00000000,0x00000000,0x10000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00040000,0x00100000,0x00400000,0x00000000},
/* x x x x x   */{0x11111000,0x00000000,0x00000000,0x00000000,0x00001000,0x00000000,0x00000000,0x10000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00010000,0x00100000,0x01000000,0x00000000},
/* x x x x x   */{0x11111000,0x00000000,0x00000000,0x00000000,0x00001000,0x00000000,0x00000000,0x10000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00010000,0x00100000,0x01000000,0x00000000},
/* xx  x  xx   */{0x14105000,0x00000000,0x00000000,0x00000000,0x00001000,0x00000000,0x00000000,0x10000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00004000,0x00100000,0x04000000,0x00000000},
/*  xxxxxxx    */{0x05754000,0x00000000,0x00000000,0x00000000,0x00000000,0x00354000,0x05700000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/*             */{0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000}
}};

// rows should not be larger than 20, cols not larger than 15, otherwise adapt all code that uses these fields!
static const tSegData segData[2][18] = {{
  {20,15,&segSize1C[0][0]},/* SEG16 */
#ifdef PROC_SUPPORT //TODO/PROC: Will this work in normal PinMAME build too?
  /* Use segSize2C for P-ROC's alpha_on_dmd functionality as it maps better to the DMD. */
  {20,15,&segSize2C[0][0]},/* SEG16R */
#else
  {20,15,&segSize1C[3][0]},/* SEG16R */
#endif
  {20,15,&segSize1C[2][0]},/* SEG10 */
  {20,15,&segSize1[2][0]}, /* SEG9 */
  {20,15,&segSize1C[1][0]},/* SEG8 */
  {20,15,&segSize1C[4][0]},/* SEG8FD */
  {20,15,&segSize1[1][0]}, /* SEG7 */
  {20,15,&segSize1C[1][0]},/* SEG87 */
  {20,15,&segSize1C[1][0]},/* SEG87F */
  {20,15,&segSize1C[2][0]},/* SEG98 */
  {20,15,&segSize1C[2][0]},/* SEG98F */
  {12,11,&segSize2[1][0]}, /* SEG7S */
  {12,11,&segSize2C[1][0]},/* SEG7SC */
  {20,15,&segSize1S[0][0]},/* SEG16S */
  { 2, 2,NULL},            /* DMD */
  { 1, 1,NULL},            /* VIDEO */
  {20,15,&segSize1[0][0]}, /* SEG16N */
  {20,15,&segSize1C[5][0]} /* SEG16D */
},{
  {12,11,&segSize2C[0][0]},/* SEG16 */
  {12,11,&segSize2C[3][0]},/* SEG16R */
  {12,11,&segSize2C[2][0]},/* SEG10 */
  {12,11,&segSize2[2][0]}, /* SEG9 */
  {12,11,&segSize2C[1][0]},/* SEG8 */
  {12,11,&segSize2C[4][0]},/* SEG8D */
  {12,11,&segSize2[1][0]}, /* SEG7 */
  {12,11,&segSize2C[1][0]},/* SEG87 */
  {12,11,&segSize2C[1][0]},/* SEG87F */
  {12,11,&segSize2C[2][0]},/* SEG98 */
  {12,11,&segSize2C[2][0]},/* SEG98F */
  { 8, 7,&segSize3[1][0]}, /* SEG7S */
  { 8, 7,&segSize3C[1][0]},/* SEG7SC */
  {12,11,&segSize2S[0][0]},/* SEG16S */
  { 1, 1,NULL},            /* DMD */
  { 1, 1,NULL},            /* VIDEO */
  {12,11,&segSize2[0][0]}, /* SEG16N */
  {12,11,&segSize2C[5][0]} /* SEG16D */
}};

/*-------------------
/  local variables
/-------------------*/
static struct {
  core_tSeg lastSeg;       // previous segments values
  UINT8     lastSegDim[CORE_SEGCOUNT * 16]; // previous segment dimming level
  int       displaySize;   // 1=compact 2=normal
  tSegData  *segData;      // segments to use (normal/compact)
  void      *timers[5];    // allocated timers
  int       flipTimer[4];  // time since flipper was activated (used for EOS simulation)
  UINT8     flipMask;      // Flipper bits used for flippers
  int       firstSimRow, maxSimRows; // space available for simulator
  int       solLog[4];
  int       solLogCount;
  /*-- Event reporting (used LibPinMAME and on screen display) --*/
  UINT8     lastPhysicsOutput[CORE_MODOUT_MAX];
  UINT8     lastLampMatrix[CORE_MAXLAMPCOL];
  int       lastGI[CORE_MAXGI];
  UINT64    lastSol;
  /*-- VPinMame specifics --*/
  #if defined(VPINMAME) || defined(LIBPINMAME)
    UINT8   vpm_dmd_last_lum[DMD_MAXY * DMD_MAXX];
    UINT8   vpm_dmd_luminance_lut[256];
    UINT32  vpm_dmd_color_lut[256];
  #endif
} locals;

/*-------------------------------
/  Initialize the game palette
/-------------------------------*/
static PALETTE_INIT(core) {
  const int palSize = sizeof(core_palette)/3;
  unsigned char tmpPalette[sizeof(core_palette)/3][3];
  int rStart = 0xff, gStart = 0xe0, bStart = 0x20;
  int perc66 = 67, perc33 = 33, perc0  = 20;
  int ii;

  if ((pmoptions.dmd_red > 0) || (pmoptions.dmd_green > 0) || (pmoptions.dmd_blue > 0)) {
    rStart = pmoptions.dmd_red; gStart = pmoptions.dmd_green; bStart = pmoptions.dmd_blue;
  }
  if ((pmoptions.dmd_perc0 > 0) || (pmoptions.dmd_perc33 > 0) || (pmoptions.dmd_perc66 > 0)) {
    perc66 = pmoptions.dmd_perc66; perc33 = pmoptions.dmd_perc33; perc0  = pmoptions.dmd_perc0;
  }
  memcpy(tmpPalette, core_palette, sizeof(core_palette));

  /*-- Autogenerate DMD Color Shades--*/
  tmpPalette[COL_DMDOFF][0]   = rStart * perc0 / 100;
  tmpPalette[COL_DMDOFF][1]   = gStart * perc0 / 100;
  tmpPalette[COL_DMDOFF][2]   = bStart * perc0 / 100;
  tmpPalette[COL_DMD33][0]    = rStart * perc33 / 100;
  tmpPalette[COL_DMD33][1]    = gStart * perc33 / 100;
  tmpPalette[COL_DMD33][2]    = bStart * perc33 / 100;
  tmpPalette[COL_DMD66][0]    = rStart * perc66 / 100;
  tmpPalette[COL_DMD66][1]    = gStart * perc66 / 100;
  tmpPalette[COL_DMD66][2]    = bStart * perc66 / 100;
  tmpPalette[COL_DMDON][0]    = rStart;
  tmpPalette[COL_DMDON][1]    = gStart;
  tmpPalette[COL_DMDON][2]    = bStart;

  /*-- If the "colorize" option is set, use the individual option colors for the shades --*/
  if (pmoptions.dmd_colorize) {
    if (pmoptions.dmd_red0 > 0 || pmoptions.dmd_green0 > 0 || pmoptions.dmd_blue0 > 0) {
      tmpPalette[COL_DMDOFF][0]   = pmoptions.dmd_red0;
      tmpPalette[COL_DMDOFF][1]   = pmoptions.dmd_green0;
      tmpPalette[COL_DMDOFF][2]   = pmoptions.dmd_blue0;
    }
    if (pmoptions.dmd_red33 > 0 || pmoptions.dmd_green33 > 0 || pmoptions.dmd_blue33 > 0) {
      tmpPalette[COL_DMD33][0]    = pmoptions.dmd_red33;
      tmpPalette[COL_DMD33][1]    = pmoptions.dmd_green33;
      tmpPalette[COL_DMD33][2]    = pmoptions.dmd_blue33;
    }
    if (pmoptions.dmd_red66 > 0 || pmoptions.dmd_green66 > 0 || pmoptions.dmd_blue66 > 0) {
      tmpPalette[COL_DMD66][0]    = pmoptions.dmd_red66;
      tmpPalette[COL_DMD66][1]    = pmoptions.dmd_green66;
      tmpPalette[COL_DMD66][2]    = pmoptions.dmd_blue66;
    }
  }

  /*-- segment display antialias colors --*/
  tmpPalette[COL_SEGAAON1][0] = rStart * (perc66+5) / 100;
  tmpPalette[COL_SEGAAON1][1] = gStart * (perc66+5) / 100;
  tmpPalette[COL_SEGAAON1][2] = bStart * (perc66+5) / 100;
  tmpPalette[COL_SEGAAON2][0] = rStart * perc33 / 100;
  tmpPalette[COL_SEGAAON2][1] = gStart * perc33 / 100;
  tmpPalette[COL_SEGAAON2][2] = bStart * perc33 / 100;
  tmpPalette[COL_SEGAAOFF1][0] = rStart * perc0 * (perc66+5) / 10000;
  tmpPalette[COL_SEGAAOFF1][1] = gStart * perc0 * (perc66+5) / 10000;
  tmpPalette[COL_SEGAAOFF1][2] = bStart * perc0 * (perc66+5) / 10000;
  tmpPalette[COL_SEGAAOFF2][0] = rStart * perc0 * perc33 / 10000;
  tmpPalette[COL_SEGAAOFF2][1] = gStart * perc0 * perc33 / 10000;
  tmpPalette[COL_SEGAAOFF2][2] = bStart * perc0 * perc33 / 10000;

  /*-- generate 16 shades of the segment color for all antialiased segments --*/
  for (ii = 0; ii < 16; ii++) {
    const int tmp = 15 * perc0 + ii * (100 - perc0);
    tmpPalette[palSize-16+ii][0] = (unsigned char)(rStart * tmp / 1500);
    tmpPalette[palSize-16+ii][1] = (unsigned char)(gStart * tmp / 1500);
    tmpPalette[palSize-16+ii][2] = (unsigned char)(bStart * tmp / 1500);
    tmpPalette[palSize-32+ii][0] = (unsigned char)(rStart * tmp * (perc66+5) / 150000);
    tmpPalette[palSize-32+ii][1] = (unsigned char)(gStart * tmp * (perc66+5) / 150000);
    tmpPalette[palSize-32+ii][2] = (unsigned char)(bStart * tmp * (perc66+5) / 150000);
    tmpPalette[palSize-48+ii][0] = (unsigned char)(rStart * tmp * perc33 / 150000);
    tmpPalette[palSize-48+ii][1] = (unsigned char)(gStart * tmp * perc33 / 150000);
    tmpPalette[palSize-48+ii][2] = (unsigned char)(bStart * tmp * perc33 / 150000);
  }

  /*-- generate segment colors for dimmed segments --*/
  for (ii = 0; ii <= 256; ii++) {
    const int tmp = 256 * perc0 + ii * (100 - perc0);
    dim_LUT[0][ii] = ((bStart * tmp / 25600)>>3) | (((gStart * tmp / 25600)>>3)<<5) | (((rStart * tmp / 25600)>>3)<<10);
    dim_LUT[1][ii] = ((bStart * tmp * (perc66+5) / 2560000)>>3) | (((gStart * tmp * (perc66+5) / 2560000)>>3)<<5) | (((rStart * tmp * (perc66+5)/ 2560000)>>3)<<10);
    dim_LUT[2][ii] = ((bStart * tmp *  perc33    / 2560000)>>3) | (((gStart * tmp *  perc33    / 2560000)>>3)<<5) | (((rStart * tmp *  perc33   / 2560000)>>3)<<10);
  }

//for (int i = 0; i < palSize; i++) printf("Col %d: %02x %02x %02x\n", i, tmpPalette[i][0],tmpPalette[i][1],tmpPalette[i][2]);

  /*-- Autogenerate Dark Playfield Lamp Colors --*/
  for (ii = 0; ii < COL_LAMPCOUNT; ii++) { /* Reduce by 75% */
    tmpPalette[COL_LAMP+COL_LAMPCOUNT+ii][0] = (tmpPalette[COL_LAMP+ii][0] * 25) / 100;
    tmpPalette[COL_LAMP+COL_LAMPCOUNT+ii][1] = (tmpPalette[COL_LAMP+ii][1] * 25) / 100;
    tmpPalette[COL_LAMP+COL_LAMPCOUNT+ii][2] = (tmpPalette[COL_LAMP+ii][2] * 25) / 100;
  }

  if (pmoptions.dmd_antialias)
  { /*-- Autogenerate antialias colours --*/
    int rStep, gStep, bStep;
    rStart = gStart = bStart = 0;
    //rStart = tmpPalette[COL_DMDOFF][0];
    //gStart = tmpPalette[COL_DMDOFF][1];
    //bStart = tmpPalette[COL_DMDOFF][2];

    rStep = (tmpPalette[COL_DMDON][0] * pmoptions.dmd_antialias / 100 - rStart) / 6;
    gStep = (tmpPalette[COL_DMDON][1] * pmoptions.dmd_antialias / 100 - gStart) / 6;
    bStep = (tmpPalette[COL_DMDON][2] * pmoptions.dmd_antialias / 100 - bStart) / 6;

    for (ii = 1; ii < COL_DMDAACOUNT; ii++) { // first is black
      tmpPalette[COL_DMDAA+ii][0] = rStart;
      tmpPalette[COL_DMDAA+ii][1] = gStart;
      tmpPalette[COL_DMDAA+ii][2] = bStart;
      rStart += rStep; gStart += gStep; bStart += bStep;
    }
  }

  for (ii = 0; ii < sizeof(tmpPalette)/3; ii++)
    palette_set_color(ii, tmpPalette[ii][0], tmpPalette[ii][1], tmpPalette[ii][2]);
}

/*-----------------------------------
/  Generic segment display handler
/------------------------------------*/
#ifdef VPINMAME
#  define inRect(r,l,t,w,h) FALSE
#else /* VPINMAME */
INLINE int inRect(const struct rectangle *r, int left, int top, int width, int height) {
  return (r->max_x >= left) && (r->max_y >= top) &&
         (r->min_x <= left + width) && (r->min_y <= top + height);
}
#endif /* VPINMAME */

static void updateDisplay(struct mame_bitmap *bitmap, const struct rectangle *cliprect, const struct core_dispLayout *layout_array)
{
  if (layout_array == NULL) { DBGLOG(("gen_refresh without LCD layout\n")); return; }

  #if defined(VPINMAME) || defined(LIBPINMAME)
    static UINT16 seg_data[CORE_SEGCOUNT]; // use static, in case a dmddevice.dll keeps the pointers around
    static UINT8 seg_dim[CORE_SEGCOUNT];
    static UINT8 disp_num_segs[64]; // actually max seen was 48 so far, but.. // segments per display
    int seg_idx = 0;
    int n_seg_layouts = 0;
    memset(seg_data, 0, CORE_SEGCOUNT*sizeof(UINT16));
    memset(seg_dim, 0, CORE_SEGCOUNT*sizeof(UINT8));
    disp_num_segs[0] = 0;
  #endif
  #ifdef LIBPINMAME
    UINT16* last_seg_data_ptr = seg_data;
    int display_index = 0;
  #endif

  int pos = 0;
  struct core_dispLayout* layout = layout_array;
  struct core_dispLayout* parent_layout = NULL;
  for (; layout->length || (parent_layout && parent_layout->length); layout += 1) {
    // Recursive import
    if (layout->length == 0)
    {
      layout = parent_layout;
      parent_layout = NULL;
    }
    if (layout->type == CORE_IMPORT) {
      assert(parent_layout == NULL); // IMPORT of IMPORT is not currently supported as it is not used by any driver so far
      parent_layout = layout + 1;
      layout = layout->lptr - 1;
      continue;
    }

    // Per driver renderer for DMD & video displays
    if (layout->fptr && (((ptPinMAMEvidUpdate)(layout->fptr))(bitmap,cliprect,layout) == 0)) {
      if (layout->type == CORE_VIDEO) {
        #if defined(VPINMAME) || defined(LIBPINMAME)
          has_DMD_Video = 1;
        #endif
      }
      #ifdef LIBPINMAME
        if ((layout->type == CORE_VIDEO) || ((layout->type & CORE_SEGALL) == CORE_DMD)) {
          libpinmame_update_display(display_index, layout, bitmap);
          display_index++;
        }
      #endif
      continue;
    }

    // Alphanumeric Segment display
    {
      int left = layout->left * (locals.segData[layout->type & CORE_SEGMASK].cols+1) / 2;
      int top  = layout->top  * (locals.segData[0].rows + 1) / 2;
      int ii   = layout->length;
      UINT16 *seg     = &coreGlobals.segments[layout->start].w;
      UINT16 *lastSeg = &locals.lastSeg[layout->start].w;
      UINT8  *lastSegDim = &locals.lastSegDim[layout->start * 16];
      const int step  = (layout->type & CORE_SEGREV) ? -1 : 1;
      #if defined(VPINMAME) || defined(LIBPINMAME)
        disp_num_segs[n_seg_layouts++] = (UINT8)layout->length;
      #endif
      #ifdef PROC_SUPPORT
        static UINT16 proc_top[16];
        static UINT16 proc_bottom[16];
        int char_width = locals.segData[layout->type & 0x0f].cols+1;
      #endif
      if (step < 0) { seg += ii-1; lastSeg += ii-1; lastSegDim += (ii-1)*16; }
      while (ii--) {
        UINT16 tmpSeg = *seg;
        UINT8  tmpSegDim[16] = { 0 }; // each of the 16 segments per character can be separately dimmed
        #if defined(VPINMAME) || defined(LIBPINMAME)
          UINT8 maxSegDim = 0;
        #endif
        int tmpType = layout->type & CORE_SEGMASK;
        if (options.usemodsol & (CORE_MODOUT_FORCE_ON | CORE_MODOUT_ENABLE_PHYSOUT_ALPHASEGS)) {
          int bits = tmpSeg;
          for (int kk = 0; bits; kk++, bits >>= 1) { // loop over max 16 segments of each character
            if (bits & 0x01) {
              UINT8 v = saturatedByte(coreGlobals.physicOutputState[CORE_MODOUT_SEG0 + (layout->start + layout->length - 1 - ii) * 16 + kk].value);
              #if defined(VPINMAME) || defined(LIBPINMAME)
                //!! TODO this evaluates dimming as a whole for the alpha numeric display character while it should be per segment
                if (v > maxSegDim) maxSegDim = v;
              #endif
              tmpSegDim[kk] = 255 - v; // per segment
            }
          }
        }

#ifdef VPINMAME
        //SJE: Force an update of the segments ALWAYS in VPM - corrects Pause Display Bugs
        if(1) {
#else
        if ((tmpSeg != *lastSeg) || memcmp(tmpSegDim, lastSegDim, sizeof(tmpSegDim)) != 0 ||
            inRect(cliprect,left,top,locals.segData[layout->type & CORE_SEGALL].cols,locals.segData[layout->type & CORE_SEGALL].rows)) {
#endif
          tmpSeg >>= (layout->type & CORE_SEGHIBIT) ? 8 : 0;
          memcpy(lastSegDim, tmpSegDim, sizeof(tmpSegDim));
          switch (tmpType) {
          case CORE_SEG87: case CORE_SEG87F:
            if ((ii > 0) && (ii % 3 == 0)) { // Handle Comma
              if ((tmpType == CORE_SEG87F) && tmpSeg) tmpSeg |= 0x80;
              tmpType = CORE_SEG8;
            } else
              tmpType = CORE_SEG7;
            break;
          case CORE_SEG98: case CORE_SEG98F:
            tmpSeg |= (tmpSeg & 0x100)<<1;
            if ((ii > 0) && (ii % 3 == 0)) { // Handle Comma
              if ((tmpType == CORE_SEG98F) && tmpSeg) tmpSeg |= 0x80;
              tmpType = CORE_SEG10;
            } else
              tmpType = CORE_SEG9;
            break;
          case CORE_SEG9:
            tmpSeg |= (tmpSeg & 0x100)<<1;
            break;
          }
          #if defined(VPINMAME) || defined(LIBPINMAME)
            seg_dim[seg_idx] = (255 - maxSegDim) >> 4;
            seg_data[seg_idx++] = tmpSeg;
          #endif
          if (!pmoptions.dmd_only || !(layout->fptr || layout->lptr)) {
            drawChar(bitmap, top, left, tmpSeg, tmpType, (options.usemodsol & (CORE_MODOUT_FORCE_ON | CORE_MODOUT_ENABLE_PHYSOUT_ALPHASEGS)) ? tmpSegDim : NULL);
            #ifdef PROC_SUPPORT
              if (coreGlobals.p_rocEn) {
                if ((core_gameData->gen & (GEN_WPCALPHA_1 | GEN_WPCALPHA_2 | GEN_ALLS11)) && (!pmoptions.alpha_on_dmd)) {
                  switch (top) {
                  case 0: proc_top[left/char_width + (doubleAlpha == 0)] = tmpSeg; break;
                  case 21:  // This is the ball/credit display if fitted, so work out which position
                    if (left == 12) proc_bottom[0] = tmpSeg;
                    else if (left == 24) proc_bottom[8] = tmpSeg;
                    else if (left == 48) proc_top[0] = tmpSeg;
                    else proc_top[8] = tmpSeg;
                    break;
                  default: proc_bottom[left/char_width + (doubleAlpha == 0)] = tmpSeg; break;
                  }
                }
              }
            #endif
          }
          coreGlobals.drawSeg[pos] = tmpSeg;
        }
        pos++;
        left += locals.segData[layout->type & CORE_SEGALL].cols+1;
        seg += step; lastSeg += step; lastSegDim += step;
      }
      #ifdef PROC_SUPPORT
        if (coreGlobals.p_rocEn && (core_gameData->gen & (GEN_WPCALPHA_1 | GEN_WPCALPHA_2 | GEN_ALLS11)) && (!pmoptions.alpha_on_dmd))
          procUpdateAlphaDisplay(proc_top, proc_bottom);
      #endif
    }

    #ifdef LIBPINMAME
      libpinmame_update_display(display_index, layout, last_seg_data_ptr);
      last_seg_data_ptr += layout->length;
      display_index++;
    #endif
  }

  // Sends segment data to dmddevice plugin
  #ifdef VPINMAME
    if(g_fShowPinDMD)
      renderAlphanumericFrame(core_gameData->gen, seg_data, seg_dim, n_seg_layouts, disp_num_segs, Machine->gamedrv->name);
  #endif

  // Render segments into a virtual DMD (at the moment only to pass easily to VP, e.g. tournament mode verification)
  #if defined(VPINMAME) || defined(LIBPINMAME)
    // Some GTS3 games like Teed Off update both empty alpha and real DMD. If a DMD frame has been seen, block this from running.
    if(!has_DMD_Video)
    {
      static UINT16 seg_data2[CORE_SEGCOUNT] = {0};
      const layout_t alpha_layout = layoutAlphanumericFrame(core_gameData->gen, seg_data, seg_data2, n_seg_layouts, disp_num_segs, Machine->gamedrv->name);
      if (alpha_layout != __Invalid) {
        memset(AlphaNumericFrameBuffer,0,sizeof(AlphaNumericFrameBuffer));
        switch (alpha_layout) {
          case __2x16Alpha: _2x16Alpha(seg_data); break;
          case __2x20Alpha: _2x20Alpha(seg_data); break;
          case __2x7Alpha_2x7Num: _2x7Alpha_2x7Num(seg_data); break;
          case __2x7Alpha_2x7Num_4x1Num: _2x7Alpha_2x7Num_4x1Num(seg_data); break;
          case __2x7Num_2x7Num_4x1Num: _2x7Num_2x7Num_4x1Num(seg_data); break;
          case __2x7Num_2x7Num_10x1Num: _2x7Num_2x7Num_10x1Num(seg_data,seg_data2); break;
          case __2x7Num_2x7Num_4x1Num_gen7: _2x7Num_2x7Num_4x1Num_gen7(seg_data); break;
          case __2x7Num10_2x7Num10_4x1Num: _2x7Num10_2x7Num10_4x1Num(seg_data); break;
          case __2x6Num_2x6Num_4x1Num: _2x6Num_2x6Num_4x1Num(seg_data); break;
          case __2x6Num10_2x6Num10_4x1Num: _2x6Num10_2x6Num10_4x1Num(seg_data); break;
          case __4x7Num10: _4x7Num10(seg_data); break;
          case __6x4Num_4x1Num: _6x4Num_4x1Num(seg_data); break;
          case __2x7Num_4x1Num_1x16Alpha: _2x7Num_4x1Num_1x16Alpha(seg_data); break;
          case __1x16Alpha_1x16Num_1x7Num: _1x16Alpha_1x16Num_1x7Num(seg_data); break;
          case __1x7Num_1x16Alpha_1x16Num: _1x7Num_1x16Alpha_1x16Num(seg_data); break;
          case __1x16Alpha_1x16Num_1x7Num_1x4Num : _1x16Alpha_1x16Num_1x7Num_1x4Num(seg_data); break;
          default: break;
        }
        #ifdef VPINMAME
          g_raw_dmdx = 128;
          g_raw_dmdy = 32;
          for (unsigned int i = 0; i < g_raw_dmdx * g_raw_dmdy; ++i)
            g_raw_dmdbuffer[i] = (UINT8)((int)AlphaNumericFrameBuffer[i] * 100 / 3);
          if (memcmp(buffer1, g_raw_dmdbuffer, g_raw_dmdx * g_raw_dmdy) != 0) {
            memcpy(buffer1, g_raw_dmdbuffer, g_raw_dmdx * g_raw_dmdy);
            g_needs_DMD_update = 1;
          }
        #endif
      }
      #ifdef LIBPINMAME
        static struct core_dispLayout segDmdDispLayout = { 0, 0, 32, 128, CORE_DMD | CORE_DMDSEG, NULL, NULL };
        libpinmame_update_display(display_index, &segDmdDispLayout, alpha_layout != __Invalid ? AlphaNumericFrameBuffer : NULL);
        display_index++;
      #endif
    }
  #endif

  memcpy(locals.lastSeg, coreGlobals.segments, sizeof(locals.lastSeg));
}

VIDEO_UPDATE(core_gen) {
  // Update physic output state:
  // - PinMame: at 60Hz on display update
  // - PROC: at 60Hz on display update
  // - VPinMame: on request
  // - LibPinMame: on request
  #if !defined(LIBPINMAME) && !defined(VPINMAME)
    core_update_pwm_gis();
    core_update_pwm_lamps();
    core_update_pwm_segments();
    core_update_pwm_solenoids();
  #endif

  // Update displays (alphanumeric segments, video display, large and mini DMDs):
  // - PinMame: at 60Hz on display update
  // - PROC: at 60Hz on display update if virtual DMD is enabled
  // - VPinMame: at 60Hz on display update TODO should update here if virtual DMD is enabled, but also update on DMD frame request (at requester pace to  limit stuttering)
  // - LibPinMame: at 60Hz on display update TODO to be defined more precisely
  int need_display_update = 1;
  #ifdef PROC_SUPPORT
    int alpha = (core_gameData->gen & (GEN_WPCALPHA_1|GEN_WPCALPHA_2|GEN_ALLS11)) != 0;
    if (coreGlobals.p_rocEn && pmoptions.alpha_on_dmd && alpha) {
      procClearDMD();
    need_display_update = pmoptions.virtual_dmd;
  #endif
  if (need_display_update)
    updateDisplay(bitmap, cliprect, core_gameData->lcdLayout);
  #ifdef PROC_SUPPORT
    if (coreGlobals.p_rocEn && pmoptions.alpha_on_dmd && alpha) {
      procUpdateDMD();
  #endif

  // Update lamp, solenoids, status LEDs, misc. infos...
  video_update_core_status(bitmap, cliprect);
}

/*---------------------
/  Update all switches
/----------------------*/
void core_updateSw(int flipEn) {
  /*-- handle flippers--*/
  const int flip = core_gameData->hw.flippers;
  const int flipSwCol = (core_gameData->gen & (GEN_GTS3 | GEN_SPA | GEN_ALVG | GEN_ALVG_DMD2 | GEN_WICO)) ? 15 : CORE_FLIPPERSWCOL;
  int inports[CORE_MAXPORTS];
  UINT8 swFlip;
  int ii;

  if (g_fHandleKeyboard) {

    for (ii = 0; ii < CORE_COREINPORT+(coreData->coreDips+31)/16; ii++)
      inports[ii] = readinputport(ii);


    /*-- buttons --*/
    swFlip = 0;
    if (inports[CORE_FLIPINPORT] & CORE_LLFLIPKEY) swFlip |= CORE_SWLLFLIPBUTBIT;
    if (inports[CORE_FLIPINPORT] & CORE_LRFLIPKEY) swFlip |= CORE_SWLRFLIPBUTBIT;
    if (locals.flipMask & CORE_SWULFLIPBUTBIT) {    /* have UL switch */
      if (flip & FLIP_BUT(FLIP_UL))
        { if (inports[CORE_FLIPINPORT] & CORE_ULFLIPKEY) swFlip |= CORE_SWULFLIPBUTBIT; }
      else
        { if (inports[CORE_FLIPINPORT] & CORE_LLFLIPKEY) swFlip |= CORE_SWULFLIPBUTBIT; }
    }
    if (locals.flipMask & CORE_SWURFLIPBUTBIT) {    /* have UR switch */
      if (flip & FLIP_BUT(FLIP_UR))
        { if (inports[CORE_FLIPINPORT] & CORE_URFLIPKEY) swFlip |= CORE_SWURFLIPBUTBIT; }
      else
        { if (inports[CORE_FLIPINPORT] & CORE_LRFLIPKEY) swFlip |= CORE_SWURFLIPBUTBIT; }
    }
  }
  else
    swFlip = (coreGlobals.swMatrix[flipSwCol] ^ coreGlobals.invSw[flipSwCol]) & (CORE_SWULFLIPBUTBIT|CORE_SWURFLIPBUTBIT|CORE_SWLLFLIPBUTBIT|CORE_SWLRFLIPBUTBIT);

#ifdef PROC_SUPPORT
  /*-- Only handle flipper switches if we're not in a real game, otherwise they --*/
  /*-- will get physically activated anyway */
  if (!coreGlobals.p_rocEn) {
#endif

    /*-- set switches in matrix for non-fliptronic games --*/
    if (FLIP_SWL(flip)) core_setSw(FLIP_SWL(flip), swFlip & CORE_SWLLFLIPBUTBIT);
    if (FLIP_SWR(flip)) core_setSw(FLIP_SWR(flip), swFlip & CORE_SWLRFLIPBUTBIT);
#ifdef PROC_SUPPORT
  }
#endif

  /*-- fake solenoids if not CPU controlled --*/
  if ((flip & FLIP_SOL(FLIP_L)) == 0) {
    coreGlobals.solenoids2 &= 0xffffff00;
    if (flipEn) {
      if (swFlip & CORE_SWLLFLIPBUTBIT) coreGlobals.solenoids2 |= CORE_LLFLIPSOLBITS;
      if (swFlip & CORE_SWLRFLIPBUTBIT) coreGlobals.solenoids2 |= CORE_LRFLIPSOLBITS;
    }
  }

  /*-- EOS switches --*/
  if (locals.flipMask & CORE_SWULFLIPEOSBIT) {
    if (core_getSol(sULFlip)) locals.flipTimer[0] += 1;
    else                      locals.flipTimer[0] = 0;
    if (locals.flipTimer[0] >= CORE_FLIPSTROKETIME) swFlip |= CORE_SWULFLIPEOSBIT;
  }
  if (locals.flipMask & CORE_SWURFLIPEOSBIT) {
    if (core_getSol(sURFlip)) locals.flipTimer[1] += 1;
    else                      locals.flipTimer[1] = 0;
    if (locals.flipTimer[1] >= CORE_FLIPSTROKETIME) swFlip |= CORE_SWURFLIPEOSBIT;
  }
  if (locals.flipMask & CORE_SWLLFLIPEOSBIT) {
    if (core_getSol(sLLFlip)) locals.flipTimer[2] += 1;
    else                      locals.flipTimer[2] = 0;
    if (locals.flipTimer[2] >= CORE_FLIPSTROKETIME) swFlip |= CORE_SWLLFLIPEOSBIT;
  }
  if (locals.flipMask & CORE_SWLRFLIPEOSBIT) {
    if (core_getSol(sLRFlip)) locals.flipTimer[3] += 1;
    else                      locals.flipTimer[3] = 0;
    if (locals.flipTimer[3] >= CORE_FLIPSTROKETIME) swFlip |= CORE_SWLRFLIPEOSBIT;
  }
  coreGlobals.swMatrix[flipSwCol] = (coreGlobals.swMatrix[flipSwCol]         & ~locals.flipMask) |
                                    ((swFlip ^ coreGlobals.invSw[flipSwCol]) &  locals.flipMask);

  /*-- update core dependent switches --*/
  if (coreData->updSw)  coreData->updSw(g_fHandleKeyboard ? inports : NULL);

  /*-- update game dependent switches --*/
  if (g_fHandleMechanics) {
    if (core_gameData->hw.handleMech) core_gameData->hw.handleMech(g_fHandleMechanics);
  }

  /*-- run simulator --*/
  if (coreGlobals.simAvail)
    sim_run(inports, CORE_COREINPORT+(coreData->coreDips+31)/16,
            (inports[CORE_SIMINPORT] & SIM_SWITCHKEY) == 0,
            (SIM_BALLS(inports[CORE_SIMINPORT])));
  
  /*-- Report changed solenoids --*/
  if (coreGlobals.nSolenoids && 
     ((options.usemodsol & (CORE_MODOUT_ENABLE_PHYSOUT_SOLENOIDS | CORE_MODOUT_FORCE_ON)) || ((core_gameData->gen & (GEN_ALLWPC | GEN_SAM)) && (options.usemodsol & CORE_MODOUT_ENABLE_MODSOL)) ))
  {
    float state[CORE_MODOUT_SOL_MAX];
    core_getAllPhysicSols(state);
    for (ii = 1; ii <= coreGlobals.nSolenoids; ii++) {
      UINT8 v = saturatedByte(state[ii - 1]);
      if (v != locals.lastPhysicsOutput[CORE_MODOUT_SOL0 + ii - 1]) {
        #ifdef LIBPINMAME
        OnSolenoid(ii, v);
        #else
        if ((v > 128) != (locals.lastPhysicsOutput[CORE_MODOUT_SOL0 + ii - 1] > 128)) {
          OnSolenoid(ii, v);
          /*-- log solenoid number on the display (except flippers) --*/
          if ((!pmoptions.dmd_only && ((ii < CORE_FIRSTLFLIPSOL) || (ii >= CORE_FIRSTSIMSOL)))) {
            locals.solLog[locals.solLogCount] = ii;
            core_textOutf(Machine->visible_area.max_x - 12 * 8, 0, BLACK, "%2d %2d %2d %2d",
              locals.solLog[(locals.solLogCount + 1) & 3],
              locals.solLog[(locals.solLogCount + 2) & 3],
              locals.solLog[(locals.solLogCount + 3) & 3],
              locals.solLog[(locals.solLogCount + 0) & 3]);
            locals.solLogCount = (locals.solLogCount + 1) & 3;
          }
          #ifdef ENABLE_MECHANICAL_SAMPLES
          if (coreGlobals.soundEn)
            proc_mechsounds(ii, v > 128);
          #endif
        }
        #endif
        locals.lastPhysicsOutput[CORE_MODOUT_SOL0 + ii - 1] = v;
      }
    }
  }
  else {
    UINT64 allSol = core_getAllSol();
    UINT64 chgSol = (allSol ^ locals.lastSol) & vp_getSolMask64();
    locals.lastSol = allSol;
    for (ii = 1; ii < CORE_FIRSTCUSTSOL + core_gameData->hw.custSol; ii++)
    {
      if (chgSol & 0x01) {
        OnSolenoid(ii, allSol & 0x01);
        /*-- log solenoid number on the display (except flippers) --*/
        if ((!pmoptions.dmd_only && (allSol & 0x01)) && ((ii < CORE_FIRSTLFLIPSOL) || (ii >= CORE_FIRSTSIMSOL))) {
          locals.solLog[locals.solLogCount] = ii;
          core_textOutf(Machine->visible_area.max_x - 12 * 8, 0, BLACK, "%2d %2d %2d %2d",
            locals.solLog[(locals.solLogCount + 1) & 3],
            locals.solLog[(locals.solLogCount + 2) & 3],
            locals.solLog[(locals.solLogCount + 3) & 3],
            locals.solLog[(locals.solLogCount + 0) & 3]);
          locals.solLogCount = (locals.solLogCount + 1) & 3;
        }
        #ifdef ENABLE_MECHANICAL_SAMPLES
        if (coreGlobals.soundEn)
           proc_mechsounds(ii, allSol & 0x01);
        #endif
      }
      chgSol >>= 1;
      allSol >>= 1;
    }
  }

  /*-- check if we should use simulator keys --*/
  if (g_fHandleKeyboard &&
      (!coreGlobals.simAvail || inports[CORE_SIMINPORT] & SIM_SWITCHKEY)) {
    /*-- simulator keys disabled, use row+column keys --*/

    static int lastRow = 0, lastCol = 0;
    int row = 0, col = 0;
#ifdef MAME_DEBUG
    if (keyboard_pressed(KEYCODE_Z)) col = 9;
    if (keyboard_pressed(KEYCODE_X)) col = 10;
    if (keyboard_pressed(KEYCODE_C)) col = 11;
    if (keyboard_pressed(KEYCODE_V)) col = 12;
#endif
    if (!col && (((inports[CORE_MANSWINPORT] & CORE_MANSWCOLUMNS) == 0) ||
        ((inports[CORE_MANSWINPORT] & CORE_MANSWROWS) == 0)))
      lastRow = lastCol = 0;
    else {
      int bit = 0x0101;

      for (ii = 0; ii < 8; ii++) {
        if (inports[CORE_MANSWINPORT] & CORE_MANSWCOLUMNS & bit) col = ii+1;
        if (inports[CORE_MANSWINPORT] & CORE_MANSWROWS    & bit) row = ii+1;
        bit <<= 1;
      }
      if ((col != lastCol) || (row != lastRow)) {
        coreGlobals.swMatrix[col] ^= (1<<(row-1));
        lastCol = col; lastRow = row;
      }
    }
  }

#ifdef MAME_DEBUG /* Press W and E at the same time to insert a mark in logfile */
  if (g_fHandleKeyboard && ((inports[CORE_MANSWINPORT] & 0x06) == 0x06))
    logerror("\nLogfile Mark\n");
#endif /* MAME_DEBUG */
}

/*--------------------------
/ Write text on the screen
/---------------------------*/
void core_textOut(char *buf, int length, int x, int y, int color) {
  if (y < locals.maxSimRows) {
    int ii;

    const int l = (int)strlen(buf);
    for (ii = 0; ii < length; ii++) {
      const char c = (ii >= l) ? ' ' : buf[ii];

      drawgfx(Machine->scrbitmap, Machine->uifont, c, color-1, 0, 0,
              x + ii * Machine->uifont->width, y+locals.firstSimRow, 0,
              TRANSPARENCY_NONE, 0);
    }
  }
}

/*-----------------------------------
/ Write formatted text on the screen
/------------------------------------*/
void CLIB_DECL core_textOutf(int x, int y, int color, const char *text, ...) {
  va_list arg;
  if (y < locals.maxSimRows) {
    char buf[100];
    char *bufPtr = buf;

    va_start(arg, text); vsprintf(buf, text, arg); va_end(arg);

    while (*bufPtr) {
      drawgfx(Machine->scrbitmap, Machine->uifont, *bufPtr++, color-1, 0, 0,
              x, y+locals.firstSimRow, 0, TRANSPARENCY_NONE, 0);
      x += Machine->uifont->width;
    }
  }
}

/*--------------------------------------------
/ Draw status display
/ Lamps, Switches, Solenoids, Diagnostic LEDs
/---------------------------------------------*/
static VIDEO_UPDATE(core_status) {
  BMTYPE **lines = (BMTYPE **)bitmap->line;
  int startRow = 0, nextCol = 0, thisCol = 0;
  int ii, jj;
  BMTYPE dotColor[2];

  /*-- anything to do ? --*/
  if ((pmoptions.dmd_only) || (locals.maxSimRows < 16) ||
      (coreGlobals.soundEn && (!manual_sound_commands(bitmap))))
    return;

  dotColor[0] = Machine->pens[COL_DMDOFF]; dotColor[1] = Machine->pens[COL_DMDON];
  /*--  Draw lamps --*/
  if ((core_gameData->hw.lampData) &&
      (startRow + core_gameData->hw.lampData->startpos.x + core_gameData->hw.lampData->size.x < locals.maxSimRows)) {
    core_tLampDisplay *drawData = core_gameData->hw.lampData;
    const int startx = drawData->startpos.x;
    const int starty = drawData->startpos.y + thisCol;
    BMTYPE **line = &lines[locals.firstSimRow + startRow + startx];
    int num = 0;

    for (ii = 0; ii < CORE_CUSTLAMPCOL+core_gameData->hw.lampCol; ii++) {
      int bits = coreGlobals.lampMatrix[ii];

      for (jj = 0; jj < 8; jj++) {
        int qq;
        for (qq = 0; qq < drawData->lamps[num].totnum; qq++) {
          const int lampx = drawData->lamps[num].lamppos[qq].x;
          const int lampy = drawData->lamps[num].lamppos[qq].y;
          if (options.usemodsol & (CORE_MODOUT_ENABLE_PHYSOUT_LAMPS | CORE_MODOUT_FORCE_ON)) {
            UINT8 v = saturatedByte(coreGlobals.physicOutputState[CORE_MODOUT_LAMP0 + ii * 8 + jj].value);
            line[lampx][starty + lampy] = 64 + (v >> 4);
          }
          else {
            const int color = drawData->lamps[num].lamppos[qq].color;
            line[lampx][starty + lampy] = Machine->pens[(bits & 0x01) ? color : COL_SHADE(color)];
          }
        }
        bits >>= 1;
        num++;
      }
    }
    startRow += startx + drawData->size.x;
    if (starty + drawData->size.y > nextCol) nextCol = starty + drawData->size.y;
  }
  /*-- Default square lamp matrix layout --*/
  else {
    assert((coreGlobals.nLamps == 0) || ((coreGlobals.nLamps + 7) >> 3 == CORE_CUSTLAMPCOL + core_gameData->hw.lampCol));
    for (ii = 0; ii < CORE_CUSTLAMPCOL + core_gameData->hw.lampCol; ii++) {
      BMTYPE** line = &lines[locals.firstSimRow + startRow];
      int bits = coreGlobals.lampMatrix[ii];
      for (jj = 0; jj < 8; jj++) {
        if (options.usemodsol & (CORE_MODOUT_ENABLE_PHYSOUT_LAMPS | CORE_MODOUT_FORCE_ON)) {
          UINT8 v = saturatedByte(coreGlobals.physicOutputState[CORE_MODOUT_LAMP0 + ii * 8 + jj].value);
          line[0][thisCol + ii * 2] = 64 + (v >> 4);
        } else
          line[0][thisCol + ii * 2] = dotColor[bits & 0x01];
        line += 2; bits >>= 1;
      }
    }
    startRow += 16; if (thisCol + ii*2 > nextCol) nextCol = thisCol + ii*2;
  } /* else */

  /* Draw the switches */
  startRow += 3;
  if (startRow + 16 >= locals.maxSimRows) { startRow = 0; thisCol = nextCol + 5; }

  for (ii = 0; ii < CORE_CUSTSWCOL+core_gameData->hw.swCol; ii++) {
    BMTYPE **line = &lines[locals.firstSimRow + startRow];
    int bits = coreGlobals.swMatrix[ii];

    for (jj = 0; jj < 8; jj++) {
      line[0][thisCol + ii*2] = dotColor[bits & 0x01];
      line += 2; bits >>= 1;
    }
  }
  startRow += 16; if (thisCol + ii*2 > nextCol) nextCol = thisCol + ii*2;

  /* Draw Solenoids and Flashers */
  startRow += 3;

  if (startRow + 16 >= locals.maxSimRows) { startRow = 0; thisCol = nextCol + 5; }

  {
    BMTYPE **line = &lines[locals.firstSimRow + startRow];
    if (options.usemodsol & (CORE_MODOUT_ENABLE_PHYSOUT_SOLENOIDS | CORE_MODOUT_ENABLE_MODSOL | CORE_MODOUT_FORCE_ON))
    {
      float state[CORE_MODOUT_SOL_MAX];
      core_getAllPhysicSols(state);
      for (ii = 0; ii < coreGlobals.nSolenoids; ii++) {
         line[(ii / 8) * 2][thisCol + (ii % 8) * 2] = 64 + (int) (15 * state[ii]);
      }
    }
    else
    {
      UINT64 allSol = core_getAllSol();
      for (ii = 0; ii < CORE_FIRSTCUSTSOL + core_gameData->hw.custSol; ii++) {
        line[(ii / 8) * 2][thisCol + (ii % 8) * 2] = dotColor[allSol & 0x01];
        allSol >>= 1;
      }
    }
    startRow += 16; if (thisCol + 16 > nextCol) nextCol = thisCol + 16;
  }

  /*-- draw diagnostic LEDs     --*/
  startRow += 3;

  if (startRow + 16 >= locals.maxSimRows) { startRow = 0; thisCol = nextCol; }

  if (coreData->diagLEDs == 0xff) { /* 7 SEG */
    drawChar(bitmap, locals.firstSimRow + startRow, thisCol, coreGlobals.diagnosticLed, CORE_SEG7, 0);
    startRow += 16; if (thisCol + 12 > nextCol) nextCol = thisCol + 12;
  }
  else {
    BMTYPE **line = &lines[locals.firstSimRow + startRow];
    int bits = coreGlobals.diagnosticLed;

    // Draw LEDs Vertically
    if (coreData->diagLEDs & DIAGLED_VERTICAL) {
      for (ii = 0; ii < (coreData->diagLEDs & ~DIAGLED_VERTICAL); ii++) {
        line[0][thisCol + 3] = dotColor[bits & 0x01];
        line += 2; bits >>= 1;
      }
      startRow += ii*2; if (thisCol + 4 > nextCol) nextCol = thisCol + 4;
    }
    else { // Draw LEDs Horizontally
      for (ii = 0; ii < coreData->diagLEDs; ii++) {
        line[0][thisCol + ii*2] = dotColor[bits & 0x01];
        bits >>= 1;
      }
      startRow += 1; if (thisCol + ii*2 > nextCol) nextCol = thisCol + ii*2;
    }
  }
  /*-- GI Strings --*/
  if (core_gameData->gen & GEN_ALLWPC) {
    startRow += 3;
    if (startRow + 2 >= locals.maxSimRows) { startRow = 0; thisCol = nextCol + 5; }

    for (ii = 0; ii < CORE_MAXGI; ii++)
    {
      if (options.usemodsol & (CORE_MODOUT_ENABLE_PHYSOUT_GI | CORE_MODOUT_FORCE_ON))
      {
        UINT8 v = saturatedByte(coreGlobals.physicOutputState[CORE_MODOUT_GI0 + ii].value);
        lines[locals.firstSimRow + startRow][thisCol + ii * 2] = 64 + (v >> 4);
      }
      else if (coreGlobals.gi[ii] == 8)
        lines[locals.firstSimRow + startRow][thisCol + ii*2] = dotColor[1];
      else
        lines[locals.firstSimRow + startRow][thisCol + ii*2] = 64+(coreGlobals.gi[ii]<<1);
    }
  }
  if (coreGlobals.simAvail) sim_draw(locals.firstSimRow);
  /*-- draw game specific mechanics --*/
  if (core_gameData->hw.drawMech) core_gameData->hw.drawMech((void *)&bitmap->line[locals.firstSimRow]);
}

/*-- lamp handling --*/
void core_setLamp(UINT8 *lampMatrix, int col, int row) {
  while (col) {
    if (col & 0x01) *lampMatrix |= row;
    col >>= 1;
    lampMatrix += 1;
  }
}
void core_setLampBlank(UINT8 *lampMatrix, int col, int row) {
  while (col) {
    if (col & 0x01) *lampMatrix = row;
    col >>= 1;
    lampMatrix += 1;
  }
}

/*-- "normal" switch/lamp numbering (1-64) --*/
int core_swSeq2m(int no) { return no+7; }
int core_m2swSeq(int col, int row) { return col*8+row-7; }

/*------------------------------------------
/  Read the current switch value
/
/  This function returns TRUE for active
/  switches even if the switch is active low.
/-------------------------------------------*/
int core_getSw(int swNo) {
  if (coreData->sw2m) swNo = coreData->sw2m(swNo); else swNo = (swNo/10)*8+(swNo%10-1);
  return (coreGlobals.swMatrix[swNo/8] ^ coreGlobals.invSw[swNo/8]) & (1<<(swNo%8));
}

int core_getSwCol(int colEn) {
  int ii = 1;
  if (colEn) {
    while ((colEn & 0x01) == 0) {
      colEn >>= 1;
      ii++;
    }
  }
  return coreGlobals.swMatrix[ii];
}

/*----------------------
/  Set/reset a switch
/-----------------------*/
void core_setSw(int swNo, int value) {
  if (coreData->sw2m) swNo = coreData->sw2m(swNo); else swNo = (swNo/10)*8+(swNo%10-1);
  //fprintf(stderr,"\nPinMAME switch %d",swNo);
  coreGlobals.swMatrix[swNo/8] &= ~(1<<(swNo%8)); /* clear the bit first */
#ifdef PROC_SUPPORT
   if (coreGlobals.p_rocEn) {
      coreGlobals.swMatrix[swNo/8] |=  ((value ? 0xff : 0) ^ 0) & (1<<(swNo%8));
   } else {
#endif

  coreGlobals.swMatrix[swNo/8] |=  ((value ? 0xff : 0) ^ coreGlobals.invSw[swNo/8]) & (1<<(swNo%8));
#ifdef PROC_SUPPORT
   }
#endif
}

/*-------------------------
/  update active low/high
/-------------------------*/
void core_updInvSw(int swNo, int inv) {
  int bit;
  if (coreData->sw2m) swNo = coreData->sw2m(swNo); else swNo = (swNo/10)*8+(swNo%10-1);
  bit = (1 << (swNo%8));

  if (inv)
    inv = bit;
  if ((coreGlobals.invSw[swNo/8] ^ inv) & bit) {
    coreGlobals.invSw[swNo/8] ^= bit;
    coreGlobals.swMatrix[swNo/8] ^= bit;
  }
}

/*-------------------------------------
/  Read the status of a solenoid
/  For the standard solenoids this is
/  the "smoothed" value
/--------------------------------------*/
int core_getSol(int solNo) {
  if (solNo <= 28)
    return coreGlobals.nSolenoids && (options.usemodsol & (CORE_MODOUT_ENABLE_PHYSOUT_SOLENOIDS | CORE_MODOUT_ENABLE_MODSOL | CORE_MODOUT_FORCE_ON)) ? saturatedByte(coreGlobals.physicOutputState[CORE_MODOUT_SOL0 + solNo - 1].value) : coreGlobals.solenoids & CORE_SOLBIT(solNo);
  else if (solNo <= 32) { // 29-32
    if (core_gameData->gen & GEN_ALLS11)
      return coreGlobals.nSolenoids && (options.usemodsol & (CORE_MODOUT_ENABLE_PHYSOUT_SOLENOIDS | CORE_MODOUT_ENABLE_MODSOL | CORE_MODOUT_FORCE_ON)) ? saturatedByte(coreGlobals.physicOutputState[CORE_MODOUT_SOL0 + solNo - 1].value) : coreGlobals.solenoids & CORE_SOLBIT(solNo);
    else if (core_gameData->gen & GEN_ALLWPC) // GI circuits
      return coreGlobals.solenoids2 & (1<<(solNo-29+8)); // GameOn
  }
  else if (solNo <= 36) { // 33-36 Upper flipper (WPC only)
    if (core_gameData->gen & GEN_ALLWPC) {
      int mask;
      /*-- flipper coils --*/
      if      ((solNo == sURFlip) && (core_gameData->hw.flippers & FLIP_SOL(FLIP_UR)))
        mask = CORE_URFLIPSOLBITS;
      else if ((solNo == sULFlip) && (core_gameData->hw.flippers & FLIP_SOL(FLIP_UL)))
        mask = CORE_ULFLIPSOLBITS;
      else
        mask = 1<<(solNo - 33 + 4);
      return coreGlobals.solenoids2 & mask;
    }
  }
  else if (solNo <= 44) { // 37-44 WPC95 & S11 extra
    if (core_gameData->gen & (GEN_WPC95|GEN_WPC95DCS)) // Duplicated in 37..40 / 41..44, so always read from 41..44 (hence the |4 in the index/mask)
      return coreGlobals.nSolenoids && (options.usemodsol & (CORE_MODOUT_ENABLE_PHYSOUT_SOLENOIDS | CORE_MODOUT_ENABLE_MODSOL | CORE_MODOUT_FORCE_ON)) ? saturatedByte(coreGlobals.physicOutputState[CORE_MODOUT_SOL0 + ((solNo - 13) | 4)].value) : coreGlobals.solenoids & (1<<((solNo - 13)|4));
    if (core_gameData->gen & GEN_ALLS11)
      return coreGlobals.nSolenoids && (options.usemodsol & (CORE_MODOUT_ENABLE_PHYSOUT_SOLENOIDS | CORE_MODOUT_ENABLE_MODSOL | CORE_MODOUT_FORCE_ON)) ? saturatedByte(coreGlobals.physicOutputState[CORE_MODOUT_SOL0 + 32 + solNo - 37 + 8].value) : coreGlobals.solenoids2 & (1<<(solNo - 37 + 8));
  }
  else if (solNo <= 48) { // 45-48 Lower flippers
    int mask = 1<<(solNo - 45);
    /*-- Game must have lower flippers but for symmetry we check anyway --*/
    if      ((solNo == sLRFlip) /*&& (core_gameData->hw.flippers & FLIP_SOL(FLIP_LR))*/)
      mask = CORE_LRFLIPSOLBITS;
    else if ((solNo == sLLFlip) /*&& (core_gameData->hw.flippers & FLIP_SOL(FLIP_LL))*/)
      mask = CORE_LLFLIPSOLBITS;
    return coreGlobals.solenoids2 & mask;
  }
  else if (solNo <= 50) // 49-50 simulated
    return sim_getSol(solNo);
  else if (core_gameData->hw.getSol)
    return core_gameData->hw.getSol(solNo);
  return 0;
}

/*-------------------------------------
/  Read the instant status of a solenoid
/--------------------------------------*/
int core_getPulsedSol(int solNo) {
  if (solNo <= 32)
    return coreGlobals.pulsedSolState & CORE_SOLBIT(solNo);
  else if ((core_gameData->gen & (GEN_WPC95|GEN_WPC95DCS)) && (solNo >= 37) && (solNo <= 44))
    // This is a little messy. Pulsed state is in 29-32 but 29-32 non pulsed is GameOn sol
    return coreGlobals.pulsedSolState & (1<<((solNo-13)|4));
  return core_getSol(solNo); /* sol is not smoothed anyway */
}

/*-------------------------------------------------
/  Get the value of all solenoids in one variable
/--------------------------------------------------*/
UINT64 core_getAllSol(void) {
  UINT64 sol = coreGlobals.solenoids;
  if (core_gameData->gen & GEN_ALLWPC) // 29-32 GameOn
    sol = (sol & 0x0fffffff) | ((coreGlobals.solenoids2 & 0x0f00)<<20);
  if (core_gameData->gen & (GEN_WPC95|GEN_WPC95DCS)) { // 37-44 WPC95 extra
    UINT64 tmp = coreGlobals.solenoids & 0xf0000000;
    sol |= (tmp<<12)|(tmp<<8);
  }
  if (core_gameData->gen & (GEN_ALLS11|GEN_SAM|GEN_SPA)) // 37-44 S11, SAM extra
    sol |= ((UINT64)(coreGlobals.solenoids2 & 0xff00))<<28;
  { // 33-36, 45-48 flipper solenoids
    UINT8 lFlip = (coreGlobals.solenoids2 & (CORE_LRFLIPSOLBITS|CORE_LLFLIPSOLBITS));
    UINT8 uFlip = (coreGlobals.solenoids2 & (CORE_URFLIPSOLBITS|CORE_ULFLIPSOLBITS));
    // hold coil is set if either coil is set
    lFlip |= (lFlip & 0x05)<<1;
    if (core_gameData->hw.flippers & FLIP_SOL(FLIP_UR))
      uFlip |= (uFlip & 0x10)<<1;
    if (core_gameData->hw.flippers & FLIP_SOL(FLIP_UL))
      uFlip |= (uFlip & 0x40)<<1;
    sol |= (((UINT64)lFlip)<<44) | (((UINT64)uFlip)<<28);
  }
  /*-- simulated --*/
  sol |= sim_getSol(49) ? (((UINT64)1)<<48) : 0;
  /*-- custom --*/
  if ( core_gameData->hw.getSol ) {
    UINT64 bit = ((UINT64)1)<<(CORE_FIRSTCUSTSOL-1);
    int ii;
    for (ii = 0; ii < core_gameData->hw.custSol; ii++) {
      sol |= core_gameData->hw.getSol(CORE_FIRSTCUSTSOL + ii) ? bit : 0;
      bit <<= 1;
    }
  }
  return sol;
}

/*-------------------------------------------------
/  Get the modulated value of all solenoids in the provided array
/--------------------------------------------------*/
void core_getAllPhysicSols(float* const state)
{
  assert(coreGlobals.nSolenoids && (options.usemodsol & (CORE_MODOUT_ENABLE_PHYSOUT_SOLENOIDS | CORE_MODOUT_ENABLE_MODSOL | CORE_MODOUT_FORCE_ON)));
  memset(state, 0, CORE_MODOUT_SOL_MAX * sizeof(float)); // To avoid reporting garbage states for unused solenoid slots
  /*-- 1..32, hardware solenoids --*/
  if (core_gameData->gen & GEN_ALLWPC) {
    for (int i = 0; i < 28; i++)
      state[i] = coreGlobals.physicOutputState[CORE_MODOUT_SOL0 + i].value;
    // 29..32 GameOn (not modulated, stored in 0x0F00 of solenoids2)
    for (int i = 28; i < 32; i++)
      state[i] = coreGlobals.solenoids2 & (1 << (i - 28 + 8)) ? 1.0f : 0.0f;
  }
  else
    for (int i = 0; i < 32; i++)
      state[i] = coreGlobals.physicOutputState[CORE_MODOUT_SOL0 + i].value;
  /*-- 33..36 upper flipper solenoids (not modulated for the time being) --*/
  {
    UINT8 uFlip = (coreGlobals.solenoids2 & (CORE_URFLIPSOLBITS | CORE_ULFLIPSOLBITS));
    if (core_gameData->hw.flippers & FLIP_SOL(FLIP_UR))
      uFlip = uFlip | ((uFlip & 0x10)<<1);
    if (core_gameData->hw.flippers & FLIP_SOL(FLIP_UL))
      uFlip = uFlip | ((uFlip & 0x40)<<1);
    state[32] = uFlip & 0x10 ? 1.0f : 0.0f;
    state[33] = uFlip & 0x20 ? 1.0f : 0.0f;
    state[34] = uFlip & 0x40 ? 1.0f : 0.0f;
    state[35] = uFlip & 0x80 ? 1.0f : 0.0f;
  }
  /*-- 37..44, extra solenoids --*/
  if (core_gameData->gen & (GEN_WPC95 | GEN_WPC95DCS)) { // 37-44 WPC95 extra (duplicated 37..40 / 41..44)
    for (int i = 28; i < 32; i++)
    {
      state[i +  8] = coreGlobals.physicOutputState[CORE_MODOUT_SOL0 + i].value;
      state[i + 12] = coreGlobals.physicOutputState[CORE_MODOUT_SOL0 + i].value;
    }
  }
  else if (core_gameData->gen & (GEN_ALLS11 | GEN_SAM | GEN_SPA)) // 37-44 S11, SAM extra
    for (int i = 40; i < 48; i++)
      state[i - 4] = coreGlobals.physicOutputState[CORE_MODOUT_SOL0 + i].value;
  /*-- 45..48 lower flipper solenoids (not modulated for the time being) --*/
  {
    UINT8 lFlip = (coreGlobals.solenoids2 & (CORE_LRFLIPSOLBITS|CORE_LLFLIPSOLBITS));
    lFlip |= (lFlip & 0x05)<<1; // hold coil is set if either coil is set
    state[44] = lFlip & 0x01 ? 1.0f : 0.0f;
    state[45] = lFlip & 0x02 ? 1.0f : 0.0f;
    state[46] = lFlip & 0x04 ? 1.0f : 0.0f;
    state[47] = lFlip & 0x08 ? 1.0f : 0.0f;
  }
  /*-- 49..50 simulated --*/
  state[48] = sim_getSol(49) ? 1.0f : 0.0f;
  //state[49] = 0.0f; // unused reserved simulated solenoid
  /*-- 51..66 custom --*/
  for (int i = 0; i < core_gameData->hw.custSol; i++) {
    int sol = CORE_FIRSTCUSTSOL - 1 + i;
    state[sol] = sol < coreGlobals.nSolenoids ? coreGlobals.physicOutputState[CORE_MODOUT_SOL0 + sol].value : (core_gameData->hw.getSol ? (core_gameData->hw.getSol(sol + 1) ? 1.0f : 0.0f) : 0.0f);
  }
}

/*---------------------------------------
/  Get the status of a DIP bank (8 dips)
/-----------------------------------------*/
int core_getDip(int dipBank) {
#if defined(VPINMAME) || defined(LIBPINMAME)
  return vp_getDIP(dipBank);
#else /* VPINMAME */
  return (readinputport(CORE_COREINPORT+1+dipBank/2)>>((dipBank & 0x01)*8))&0xff;
#endif /* VPINMAME */
}

/*--------------------
/   Draw a LED digit
/---------------------*/
static void drawChar(struct mame_bitmap *bitmap, int row, int col, UINT16 seg_bits, int type, UINT8 dimming[16]) {
  const tSegData *s = &locals.segData[type];
  UINT32 pixel[20] = {0}; // max 20 rows
  UINT16 dim[20][15] = {0}; // max 20 rows, 15 cols
  static const int offPens[4] = { 0, COL_DMDOFF, COL_SEGAAOFF1, COL_SEGAAOFF2 };
  int sb, kk, ll;
  const int palSize = sizeof(core_palette) / 3;
  for (sb = 1; seg_bits; sb++, seg_bits >>= 1) { // loop over each segment
    if (seg_bits & 0x01) {
      #ifdef PROC_SUPPORT
        if (coreGlobals.p_rocEn && pmoptions.alpha_on_dmd) {
          /* Draw alphanumeric segments on the DMD */
          switch (row) {
          case 0:
            procDrawSegment(col/2, 3,sb-1);
            break;
          case 21:
            // This is the ball/credit display on older Sys11
            // Push through an 11 as the row
            // number, the display routine will
            // take care of repositioning
            procDrawSegment(col/2,11,sb-1);
            break;
          case 42:
            procDrawSegment(col/2,19,sb-1);
            break;
          default:
            break;
          }
        }
      #endif
      for (kk = 0; kk < s->rows; kk++)
      {
        pixel[kk] |= s->segs[kk][sb]; // 'sum' up anti-aliasing

        // to combine this with dimming fill dim[][] with weighted AA/dimming of each segment
        UINT32 p = pixel[kk]>>(30-2*s->cols);
        if (dimming)
          for (ll = 0; ll < s->cols; ll++, p >>= 2)
            if (p & 0x03) // segment set?
            {
              const UINT16 tmp = 256 - dimming[sb - 1]; // 256 instead of 255 to exploit full range (as 0 is off state)
              if (tmp > dim[kk][ll]) // always take largest value, to make the crude anti-aliasing work at least somehow per segment
                dim[kk][ll] = tmp;
            }
      }
    }
  }

  for (kk = 0; kk < s->rows; kk++) {
    BMTYPE * __restrict line = &((BMTYPE **)(bitmap->line))[row+kk][col + s->cols];
    // size is limited to 15 cols
    UINT32 p = pixel[kk]>>(30-2*s->cols), np = s->segs[kk][0]>>(30-2*s->cols);

    for (ll = 0; ll < s->cols; ll++, p >>= 2, np >>= 2)
    {
      if (p & 0x03) // segment set?
        *(--line) = dimming ? dim_LUT[(p & 0x03)-1][dim[kk][ll]] : Machine->pens[palSize - 33 + (3 - (p & 0x03))*16];
      else
        *(--line) = Machine->pens[offPens[np & 0x03]];
    }
  }
}


/*----------------------
/  Initialize PinMAME
/-----------------------*/
static MACHINE_INIT(core) {
#ifdef PROC_SUPPORT
  char * yaml_filename = pmoptions.p_roc;
#endif

  if (!coreData) { // first time
    /*-- init variables --*/
    memset(&coreGlobals, 0, sizeof(coreGlobals));
    memset(&locals, 0, sizeof(locals));
    memset(&locals.lastSeg, -1, sizeof(locals.lastSeg));
    memset(&locals.lastSegDim, 0, sizeof(locals.lastSegDim));
    coreData = (struct pinMachine *)&Machine->drv->pinmame;
    coreGlobals.flipperCoils = 0xFFFFFFFFFFFFFFFFull;
    //-- initialise timers --
    if (coreData->timers[0].callback) {
      int ii;
      for (ii = 0; ii < 5; ii++) {
        if (coreData->timers[ii].callback) {
          locals.timers[ii] = timer_alloc(coreData->timers[ii].callback);
          if (coreData->timers[ii].rate > 0.) {
            timer_adjust(locals.timers[ii], TIME_IN_HZ(coreData->timers[ii].rate), 0, TIME_IN_HZ(coreData->timers[ii].rate));
          } else { // negative = fractional hz value, e.g. as usec
            timer_adjust(locals.timers[ii], TIME_IN_USEC(-coreData->timers[ii].rate), 0, TIME_IN_USEC(-coreData->timers[ii].rate));
          }
        }
      }
    }
    /*-- init switch matrix --*/
    memcpy(coreGlobals.invSw, core_gameData->wpc.invSw, sizeof(core_gameData->wpc.invSw));
    memcpy(coreGlobals.swMatrix, coreGlobals.invSw, sizeof(coreGlobals.invSw));
#ifdef PROC_SUPPORT
    /*-- P-ROC operation requires a YAML.  Disable P-ROC operation
     * if no YAML is specified. --*/

    coreGlobals.p_rocEn = strcmp(yaml_filename, "None") != 0;
    if (coreGlobals.p_rocEn) {
      /*-- Finish P-ROC initialization now that the sim is active. --*/
      coreGlobals.p_rocEn = procIsActive();
      /*-- If the initialization fails, disable the p-roc support --*/
      if (!coreGlobals.p_rocEn) {
        fprintf(stderr, "P-ROC initialization failed.  Disabling P-ROC support.\n");
        // TODO: deInit P-ROC here?
      }
      else {
        // read s11CreditDisplay, doubleAlpha and s11BallDisplay settings
        procBallCreditDisplay();

        // Added option to enable keyboard for direct switches to YAML
        g_fHandleKeyboard = procKeyboardWanted();

        // We don't want the PC to make the noises of pop bumpers etc
        g_fHandleMechanics= 0;
      }
    }
#endif

    /*-- masks bit used by flippers --*/
    {
      const int flip = core_gameData->hw.flippers;
      locals.flipMask = CORE_SWLRFLIPBUTBIT | CORE_SWLLFLIPBUTBIT |
         ((flip & FLIP_SW(FLIP_UL)) ? CORE_SWULFLIPBUTBIT : 0) |
         ((flip & FLIP_SW(FLIP_UR)) ? CORE_SWURFLIPBUTBIT : 0) |
         ((flip & FLIP_EOS(FLIP_UL))? CORE_SWULFLIPEOSBIT : 0) |
         ((flip & FLIP_EOS(FLIP_UR))? CORE_SWURFLIPEOSBIT : 0) |
         ((flip & FLIP_EOS(FLIP_LL))? CORE_SWLLFLIPEOSBIT : 0) |
         ((flip & FLIP_EOS(FLIP_LR))? CORE_SWLRFLIPEOSBIT : 0);
    }
    /*-- command line options --*/
    locals.displaySize = pmoptions.dmd_compact ? 1 : 2;
    {
      UINT32 width = core_initDisplaySize(core_gameData->lcdLayout) >> 16;
      if (((int)width > Machine->drv->screen_width) && (locals.displaySize > 1)) {
        /* force small display */
        locals.displaySize = 1;
        core_initDisplaySize(core_gameData->lcdLayout);
      }
    }
    /*-- Sound enabled ? */
    if (((Machine->gamedrv->flags & GAME_NO_SOUND) == 0) && Machine->sample_rate != 0.)
      coreGlobals.soundEn = TRUE;

    /*-- init simulator --*/
    if (g_fHandleKeyboard && core_gameData->simData) {
      int inports[CORE_MAXPORTS];
      int ii;
      for (ii = 0; ii < CORE_COREINPORT+(coreData->coreDips+31)/16; ii++)
        inports[ii] = readinputport(ii);

      coreGlobals.simAvail = sim_init((sim_tSimData *)core_gameData->simData,
                                      inports,CORE_COREINPORT+(coreData->coreDips+31)/16);
    }

    /*-- default output types --*/
    core_set_pwm_output_type(CORE_MODOUT_SOL0, CORE_MODOUT_SOL_MAX, CORE_MODOUT_NONE);
    core_set_pwm_output_type(CORE_MODOUT_SOL0 + CORE_FIRSTCUSTSOL - 1, CORE_MAXSOL - CORE_FIRSTCUSTSOL, CORE_MODOUT_SOL_CUSTOM);
    core_set_pwm_output_type(CORE_MODOUT_GI0, CORE_MODOUT_GI_MAX, CORE_MODOUT_NONE);
    core_set_pwm_output_type(CORE_MODOUT_LAMP0, CORE_MODOUT_LAMP_MAX, CORE_MODOUT_NONE);
    core_set_pwm_output_type(CORE_MODOUT_SEG0, CORE_MODOUT_SEG_MAX, CORE_MODOUT_NONE);

    /*-- finally init the core --*/
    if (coreData->init) coreData->init();

    /*-- init PWM integration (needs to be done after coreData->init() which defines the number of outputs and the physical model to be used on each output) --*/
#ifndef LIBPINMAME // dimmed segments not wired at the moment?!
#ifdef VPINMAME
    if(g_fShowWinDMD || g_fShowPinDMD)
#endif
    // Enable PWM/dimmed segments for corresponding alphanum segment machines
    if(((core_gameData->gen & GEN_GTS3) && GTS3locals.alphagen) || (core_gameData->gen & (GEN_WPCALPHA_1 | GEN_WPCALPHA_2)))
      options.usemodsol |= CORE_MODOUT_ENABLE_PHYSOUT_ALPHASEGS; // use CORE_MODOUT_ENABLE_PHYSOUT_ALL to enable/test all physical/PWM outputs
#endif

    /*-- init bulb model LUTs --*/
    bulb_init();

    /*-- init sound commander --*/
    snd_cmd_init();
  }
  /*-- now reset everything --*/
  if (coreData->reset) coreData->reset();
  mech_emuInit();

#ifdef VPINMAME
  // DMD USB Init
  if(g_fShowPinDMD && !time_to_reset)
    pindmdInit(g_szGameName, core_gameData->gen, &pmoptions);
#endif

  /*-- Generate LUTs for VPinMame DMD --*/
  #ifdef VPINMAME
  {
    int rStart = 0xff, gStart = 0xe0, bStart = 0x20;
    int perc66 = 67, perc33 = 33, perc00 = 20;
    if ((pmoptions.dmd_red > 0) || (pmoptions.dmd_green > 0) || (pmoptions.dmd_blue > 0)) {
      rStart = pmoptions.dmd_red; gStart = pmoptions.dmd_green; bStart = pmoptions.dmd_blue;
    }
    if ((pmoptions.dmd_perc0 > 0) || (pmoptions.dmd_perc33 > 0) || (pmoptions.dmd_perc66 > 0)) {
      perc66 = pmoptions.dmd_perc66; perc33 = pmoptions.dmd_perc33; perc00 = pmoptions.dmd_perc0;
    }
    int r100 = rStart, g100 = gStart, b100 = bStart;
    int r00, g00, b00, r33, g33, b33, r66, g66, b66;
    if (pmoptions.dmd_colorize) {
      r00 = pmoptions.dmd_red0;  g00 = pmoptions.dmd_green0;  b00 = pmoptions.dmd_blue0;
      r33 = pmoptions.dmd_red33; g33 = pmoptions.dmd_green33; b33 = pmoptions.dmd_blue33;
      r66 = pmoptions.dmd_red66; g66 = pmoptions.dmd_green66; b66 = pmoptions.dmd_blue66;
    }
    else {
      r00 = rStart * perc00 / 100; g00 = gStart * perc00 / 100; b00 = bStart * perc00 / 100;
      r33 = rStart * perc33 / 100; g33 = gStart * perc33 / 100; b33 = bStart * perc33 / 100;
      r66 = rStart * perc66 / 100; g66 = gStart * perc66 / 100; b66 = bStart * perc66 / 100;
    }
    #define LERP0(p, a, b) ((1.-(double)p)*(double)a + (double)p*(double)b)
    #define LERP(i, v0, v33, v66, v100) (i < 85 ? LERP0(((double)i)/85., v0, v33) : (i < 170 ? LERP0(((double)i-85.)/170., v33, v66) : LERP0(((double)i-170.)/255., v66, v100)))
    for (int i = 0; i < 256; i++) {
      locals.vpm_dmd_luminance_lut[i] = (UINT8) LERP(i, perc00, perc33, perc66, 100);
      UINT32 r = (UINT32) LERP(i, r00, r33, r66, rStart);
      UINT32 g = (UINT32) LERP(i, g00, g33, g66, gStart);
      UINT32 b = (UINT32) LERP(i, b00, b33, b66, bStart);
      locals.vpm_dmd_color_lut[i] = r | (g << 8) | (b << 16);;
    }
    #undef LERP0
    #undef LERP
  }
  #endif

  OnStateChange(1); /* We have a lift-off */

/* TOM: this causes to draw the static sim text */
  schedule_full_refresh();
}

static MACHINE_STOP(core) {
  int ii;

#ifdef VPINMAME
  // DMD USB Kill
  if(g_fShowPinDMD && !time_to_reset)
    pindmdDeInit();
#endif
#if defined(VPINMAME) || defined(LIBPINMAME)
  g_raw_dmdx = ~0u;
  g_raw_dmdy = ~0u;

  currbuffer = buffer1;
  oldbuffer = NULL;
  raw_dmdoffs = 0;
  has_DMD_Video = 0;

  raw_dmd_frame_count = 0;

  g_needs_DMD_update = 1;
#endif

  mech_emuExit();
  if (coreData->stop) coreData->stop();
  snd_cmd_exit();
  for (ii = 0; ii < 5; ii++) {
    if (locals.timers[ii])
      timer_remove(locals.timers[ii]);
  }
  memset(locals.timers, 0, sizeof(locals.timers));
#ifdef PROC_SUPPORT
  if (coreGlobals.p_rocEn) {
    procDeinitialize();
  }
#endif
  coreData = NULL;
}

static void core_findSize(const struct core_dispLayout *layout, int *maxX, int *maxY) {
  if (layout) {
    for (; layout->length; layout += 1) {
      int tmpX, tmpY, type = layout->type & CORE_SEGMASK;
#if defined(VPINMAME) && !defined(MAME_DEBUG)
      if (layout->type & CORE_NODISP) continue;
#endif
      if (type == CORE_IMPORT)
        { core_findSize(layout->lptr, maxX, maxY); continue; }
      if (type == CORE_DMD || type == CORE_VIDEO) {
        tmpX = (layout->left + layout->length) * locals.segData[type].cols + 1;
        tmpY = (layout->top  + layout->start)  * locals.segData[type].rows + 1;
      }
      else {
        tmpX = (layout->left + 2*layout->length) * (locals.segData[type & 0x07].cols + 1) / 2;
        tmpY = (layout->top + 2) * (locals.segData[0].rows + 1) / 2;
      }
      if (tmpX > *maxX) *maxX = tmpX;
      if (tmpY > *maxY) *maxY = tmpY;
    }
#ifndef VPINMAME
    if (*maxX < 256) *maxX = 256;
#endif
  }
}

static UINT32 core_initDisplaySize(const struct core_dispLayout *layout) {
  int maxX = 0, maxY = 0;

  locals.segData = &segData[locals.displaySize == 1][0];
  if (layout)
    core_findSize(layout, &maxX, &maxY);
  else if (locals.displaySize > 1)
    { maxX = 256; maxY = 65; }
  else
    { maxX = 129; maxY = 33; }
  locals.firstSimRow = maxY + 3;
  locals.maxSimRows = Machine->drv->screen_height - locals.firstSimRow;
  if ((!pmoptions.dmd_only) || (maxY >= Machine->drv->screen_height))
    maxY = Machine->drv->screen_height;
  logerror("Resolution set to %dx%d\n", maxX, maxY);
  set_visible_area(0, maxX-1, 0, maxY-1);
  return (maxX<<16) | maxY;
}

void core_nvram(void *file, int write, void *mem, size_t length, UINT8 init) {
  if (write)     mame_fwrite(file, mem, length); /* save */
  else if (file) mame_fread(file,  mem, length); /* load */
  else           memset(mem, init, length);      /* first time */
  mech_nv(file, write); /* save mech positions */
  { /*-- Load/Save DIP settings --*/
    UINT8 dips[6];
    int   ii;

    if (write) {
      for (ii = 0; ii < 6; ii++) dips[ii] = core_getDip(ii);
      mame_fwrite(file, dips, sizeof(dips));
    }
    else if (file) {
      /* set the defaults (for compatibility with older versions) */
      dips[0] = readinputport(CORE_COREINPORT+1) & 0xff;
      dips[1] = readinputport(CORE_COREINPORT+1)>>8;
      dips[2] = readinputport(CORE_COREINPORT+2) & 0xff;
      dips[3] = readinputport(CORE_COREINPORT+2)>>8;
      dips[4] = readinputport(CORE_COREINPORT+3) & 0xff;
      dips[5] = readinputport(CORE_COREINPORT+3)>>8;

      mame_fread(file, dips, sizeof(dips));
      for (ii = 0; ii < 6; ii++) vp_setDIP(ii, dips[ii]);

    }
    else { // always get the default from the inports
      /* coreData not initialized yet. Don't know exact number of DIPs */
      vp_setDIP(0, readinputport(CORE_COREINPORT+1) & 0xff);
      vp_setDIP(1, readinputport(CORE_COREINPORT+1)>>8);
      vp_setDIP(2, readinputport(CORE_COREINPORT+2) & 0xff);
      vp_setDIP(3, readinputport(CORE_COREINPORT+2)>>8);
      vp_setDIP(4, readinputport(CORE_COREINPORT+3) & 0xff);
      vp_setDIP(5, readinputport(CORE_COREINPORT+3)>>8);
    }
  }
}

/*---------- Emulation of physical/analog devices wired to binary outputs ----------*/

/*
 * Physical output emulation
 * 
 * This is meant to be used with any output and should allow to have a physical model whatever is connected to the binary PWM output. 
 * Drivers must declare the number of outputs they drive of each type and push binary state change accordingly.
 * The implementation is not thread safe. Since VPinMAME reads state asynchronously, the integration is only performed if requested
 * asynchronously through a 1ms timer.
 */

//#define LOG_PWM_OUT (CORE_MODOUT_LAMP0 + 18)
//#define LOG_PWM_OUT (CORE_MODOUT_SOL0 + CORE_FIRSTCUSTSOL - 1)
//#define LOG_PWM_OUT (CORE_MODOUT_SEG0 + 0)
//#define LOG_PWM_OUT (CORE_MODOUT_SOL0 + 16 - 1)

// No operation output: just keep the last value directly defined by the driver
void core_update_pwm_output_nop(const double now, const int index, const int isFlip, const int state)
{
}

// Pulse output: simply report the binary output state without any processing
void core_update_pwm_output_pulse(const double now, const int index, const int isFlip, const int state)
{
  coreGlobals.physicOutputState[index].value = state ? 1.f : 0.f;
}

// Custom output: update the value from the driver's custom getSol implementation
void core_update_pwm_output_custom(const double now, const int index, const int isFlip, const int state)
{
  coreGlobals.physicOutputState[index].value = core_gameData->hw.getSol ? (core_gameData->hw.getSol(index - CORE_MODOUT_SOL0 + 1) ? 1.f : 0.f) : 0.f;
  #ifdef LOG_PWM_OUT
  if (index == LOG_PWM_OUT)
    printf("Custom #%d t=%8.5f v=%f\n", index, now, coreGlobals.physicOutputState[index].value);
  #endif
}

// Simple 2 state solenoid output
// Flip to ON state is taken in account directly, while flip to OFF state is only reported after a delay to filter out any PWM pulses
void core_update_pwm_output_sol_2_state(const double now, const int index, const int isFlip, const int state)
{
  core_tPhysicOutput* const output = &coreGlobals.physicOutputState[index];
  const float prevValue = output->value;
  if (isFlip)
     output->state.sol.lastFlipTimestamp = now;
  if (isFlip && state == 0) {
     // If binary output is flipping to ON state, immediately retain and report the ON state
     output->value = 1.0f;
  }
  else if ((float)(now - output->state.sol.lastFlipTimestamp) > output->state.sol.switchDownLatency) {
     // Output is in a stable state (not PWMed since at least the defined switch down latency), just report its value
     output->value = state ? 1.f : 0.f;
  }
  #ifdef LOG_PWM_OUT
  if (index == LOG_PWM_OUT)
    printf("Sol #%d t=%8.5f v=%f s=%s\n", index - CORE_MODOUT_SOL0 + 1, now, output->value, isFlip ? (state ? "x > -" : "- > x") : (state ? "    x" : "    -"));
  #endif
  // Apply the legacy solenoid behavior but directly updating coreGlobals.solenoids, avoiding the latency of legacy implementation which handles PWM
  // by 'or'ing solenoids states for a few 'VBlank's then deliver them, 'VBlank' being a custom 60Hz interrupt not corresponding to any hardware.
  if (output->state.sol.fastOn && (prevValue != output->value)) {
    const int sol = index - CORE_MODOUT_SOL0;
    const UINT32 state = output->value > 0.5f ? 1 : 0;
    if (sol == (coreGlobals.flipperCoils & 0xFF))              // Lower Left Flipper coil
      coreGlobals.solenoids2 = (coreGlobals.solenoids2 & ~0x04) | (state ? 0x04 : 0x00);
    else if (sol == ((coreGlobals.flipperCoils >>  8) & 0xFF)) // Lower Right Flipper coil
      coreGlobals.solenoids2 = (coreGlobals.solenoids2 & ~0x01) | (state ? 0x01 : 0x00);
    else if (sol == ((coreGlobals.flipperCoils >> 16) & 0xFF)) // Upper Left Flipper coil
      coreGlobals.solenoids2 = (coreGlobals.solenoids2 & ~0x40) | (state ? 0x40 : 0x00);
    else if (sol == ((coreGlobals.flipperCoils >> 24) & 0xFF)) // Upper Right Flipper coil
      coreGlobals.solenoids2 = (coreGlobals.solenoids2 & ~0x10) | (state ? 0x10 : 0x00);
    else if (sol == ((coreGlobals.flipperCoils >> 32) & 0xFF)) // Lower Left Flipper Hold coil
      coreGlobals.solenoids2 = (coreGlobals.solenoids2 & ~0x08) | (state ? 0x08 : 0x00);
    else if (sol == ((coreGlobals.flipperCoils >> 40) & 0xFF)) // Lower Right Flipper Hold coil
      coreGlobals.solenoids2 = (coreGlobals.solenoids2 & ~0x02) | (state ? 0x02 : 0x00);
    else if (sol == ((coreGlobals.flipperCoils >> 48) & 0xFF)) // Upper Left Flipper Hold coil
      coreGlobals.solenoids2 = (coreGlobals.solenoids2 & ~0x80) | (state ? 0x80 : 0x00);
    else if (sol == ((coreGlobals.flipperCoils >> 56) & 0xFF)) // Upper Right Flipper Hold coil
      coreGlobals.solenoids2 = (coreGlobals.solenoids2 & ~0x20) | (state ? 0x20 : 0x00);
    if (sol < 28)
      coreGlobals.solenoids = (coreGlobals.solenoids & ~(1 << sol)) | (state << sol);
    else if (sol < 32) {
      if (core_gameData->gen & (GEN_WPC95 | GEN_WPC95DCS)) {
        coreGlobals.solenoids = (coreGlobals.solenoids & ~(1 << (sol +  8))) | (state << (sol + 8));
        coreGlobals.solenoids = (coreGlobals.solenoids & ~(1 << (sol + 12))) | (state << (sol + 12));
      }
      else if ((core_gameData->gen & GEN_ALLWPC) == 0)
        coreGlobals.solenoids = (coreGlobals.solenoids & ~(1 << sol)) | (state << sol);
      else if (core_gameData->gen & (GEN_ALLS11 | GEN_SAM | GEN_SPA) && 40 <= sol && sol < 48)
        coreGlobals.solenoids = (coreGlobals.solenoids & ~(1 << (sol - 4))) | (state << (sol - 4));
    }
  }
}

INLINE float cube(const float x)
{
  return x * x * x;
}

INLINE void core_eye_flicker_fusion(core_tPhysicOutput* output, const float emission)
{
   // Compute the perceived emission using a hacky simplified eye integration model
   // We want to model the flicker-fusion eye/brain behavior while keeping the output latency low (filter delay) and limit the flicker (still keeping it, if it can be seen on the real machine)
   // Note that videos can not be used as references for fitting the model since the camera perform a different luminance integration. Comparisons are only valid with real humans looking at real PWM/strobed incandescent bulbs.

   // The model is a 4 steps RC-IIR/decay low pass filter (with decreased ringing/rippling).
   // I tested it following advice from a scientific paper that suggested to use a single pass RC filter for the eye model in the flicker-fusion study (I can't find the paper anymore...)
   //  (this is oversimplifying the human vision system complexity, but is mostly good enough for our use-case)
   // The overall filter delay is around 20ms. The key factor is the 0.1 constant (lower it for more smoothness, increasing the filter delay), increase it for faster response but more flicker.
   // From my test, when you look at a steady strobed lamp from a WPC (for example, lower left insert of Monster Bash), you can clearly see that the strobe is too slow (2ms/16ms) causing noticeable flicker.
   // This behavior would be obtained with a value of around 0.15 but I don't think this is the expected behavior so we smooth it a bit more to limit the flicker more than what it is on a real pinball.
   // By now we also use a log function to map intensities (resulting range [~0.07..~0.11], kinda magic). This is according to the Ferry-Porter law, where higher intensities need a larger frequency in order to make
   //  flicker fusion work, and lower intensities already work at smaller ones. (main ff frequency range is roughly 20Hz to 70Hz, BUT with a lot of outlier situations)

   const float eye_integration_old[3] = { output->state.bulb.eye_integration[0], output->state.bulb.eye_integration[1], output->state.bulb.eye_integration[2] };
   const float eyeIntegrationFactor = /*0.1f*/ (0.07f + 0.02f * /*logf(output->value*6.f + 1.f) approx:*/ 2.f*sqrtf(fmaxf(output->value,0.f))), revEyeIntegrationFactor = 1.0f - eyeIntegrationFactor;
   output->state.bulb.eye_integration[0] = (eyeIntegrationFactor * 0.5f) * (emission                +output->state.bulb.eye_emission_old) + revEyeIntegrationFactor * eye_integration_old[0];
   output->state.bulb.eye_integration[1] = (eyeIntegrationFactor * 0.5f) * (output->state.bulb.eye_integration[0]+eye_integration_old[0]) + revEyeIntegrationFactor * eye_integration_old[1];
   output->state.bulb.eye_integration[2] = (eyeIntegrationFactor * 0.5f) * (output->state.bulb.eye_integration[1]+eye_integration_old[1]) + revEyeIntegrationFactor * eye_integration_old[2];
   output->value                         = (eyeIntegrationFactor * 0.5f) * (output->state.bulb.eye_integration[2]+eye_integration_old[2]) + revEyeIntegrationFactor * output->value;
   output->state.bulb.eye_emission_old   = emission;

#ifdef LOG_PWM_OUT
   if (output == &coreGlobals.physicOutputState[LOG_PWM_OUT])
     printf("Eye flicker fusion out=%0.5f in=%0.5f\n", output->value, emission);
#endif
}

static const double BULB_INTEGRATION_PERIOD = 0.001; // do the integration in a loop of small steps

// Incandescent bulb model based on Dulli Chandra Agrawal's and others publications (Heating-times of tungsten filament incandescent lamps).
// The bulb is a varying resistor depending on filament temperature, which is heated by the current (Ohm's law)
// and cooled by radiating energy (Planck & Stefan/Boltzmann laws). The visible emission power is then evaluated from the filament temperature.
// Integration is performed after (roughly) 1ms delay in (roughly) 1ms cycles
// isFlip signals a state flip, BUT we track this internally anyways now
void core_update_pwm_output_bulb(const double now, const int index, const int isFlip, const int state)
{
  core_tPhysicOutput* output = &coreGlobals.physicOutputState[index];
  const float U = (state ^ output->state.bulb.isReversed) ? output->state.bulb.U : 0.f;
  const float dt_diff = (float)(output->state.bulb.integrationTimestamp - output->state.bulb.prevIntegrationTimestamp);

  if(U != output->state.bulb.prevIntegrationValue        // state flip?
     || dt_diff >= (float)(BULB_INTEGRATION_PERIOD*20.)) // or we waited long enough to get a stable discrete integration
  {
    // do the integration in a loop of small steps, roughly in BULB_INTEGRATION_PERIOD sized steps (but rounded up/down to have same sized cycles in here)
    float countf = floorf(dt_diff*(float)(1./BULB_INTEGRATION_PERIOD) + 0.5f);
    if(countf < 1.f) // single cycle/short pulses need to use the 'original' cycle time as a workaround
      countf = 1.f;
    const int count = (int)countf;
    const float dt = dt_diff/countf;
    for(int i = 0; i < count; ++i) {
      // Keeps T within the range of the LUT (between room temperature and melt down point)
      output->state.bulb.filament_temperature = output->state.bulb.filament_temperature < 293.0f ? 293.0f : output->state.bulb.filament_temperature > (float) BULB_T_MAX ? (float) BULB_T_MAX : output->state.bulb.filament_temperature;
      const float Ut = output->state.bulb.isAC ? (1.41421356f * sinf((float)(60.0 * 2.0 * PI) * (float)(output->state.bulb.prevIntegrationTimestamp - coreGlobals.lastACZeroCrossTimeStamp)) * output->state.bulb.prevIntegrationValue) : output->state.bulb.prevIntegrationValue;
      const float dT = dt * bulb_heat_up_factor(output->state.bulb.bulb, output->state.bulb.filament_temperature, Ut, output->state.bulb.serial_R);
      output->state.bulb.filament_temperature += dT < 1000.0f ? dT : 1000.0f; // Limit initial current surge (1ms is a bit long when emulating this part of the heating)
      core_eye_flicker_fusion(output, bulb_filament_temperature_to_emission(output->state.bulb.bulb, output->state.bulb.filament_temperature));
      output->state.bulb.prevIntegrationTimestamp += dt;
    }
    output->state.bulb.prevIntegrationTimestamp = output->state.bulb.integrationTimestamp;
    output->state.bulb.prevIntegrationValue = U;
  }
  // else: wait with the integration until some more time vanished or the state will flip
  output->state.bulb.integrationTimestamp = now;

  #ifdef LOG_PWM_OUT
  if (index == LOG_PWM_OUT)
    printf("Output #%d t=%8.5f T=%5.0f e=%0.3f V=%0.3f S=%s F=%s\n", index, now, output->state.bulb.filament_temperature, bulb_filament_temperature_to_emission(output->state.bulb.bulb, output->state.bulb.filament_temperature), output->value, state ? "x" : "-", isFlip ? "/" : ".");
    //printf("Output #%d t=%8.5f T=%5.0f e=%0.3f V=%0.3f S=%s\n", index, now, output->state.bulb.filament_temperature, bulb_filament_temperature_to_emission(output->state.bulb.bulb, output->state.bulb.filament_temperature), output->value, ((coreGlobals.binaryOutputState[index >> 3] >> (index & 7)) & 1) ? "x" : "-");
  #endif
}

// LED and VFD behave similarly:
// - LED reacts almost instantly (<1us)
// - The documentation for the behavior of Vacuum Fluorescent Display (used by alphanum displays) is sparse, so the integrator likely needs more work. From the searchs made, it appears that:
//   - the relative brightness (in steady state) is linear to PWM duty ratio.
//   - the off -> on speed is very short (below 1ms), therefore ignored
//   - the on -> off, called persistence depends a lot on used phosphor, for blue VFD uses P11 (0.5ms decay), green VFD uses P24 (0.01ms decay), therefore ignored too
//
// Sources:
// - https://en.wikipedia.org/wiki/Phosphor has a large phosphor chart
// - https://www.noritake-elec.com/technology/general-technical-information/vfd-operation states a linear relation between PWM and relative brightness
// - http://www.futabahk.com.hk/FTS/-%20FTP_DataBase/Docs_05TechDocs/VFD/AN-1103A-EN%20%20VFD%20Characteristics%20and%20Operation%20Guide%20(EN).pdf states the same
// isFlip signals a state flip, BUT we track this internally anyways now
void core_update_pwm_output_led(const double now, const int index, const int isFlip, const int state)
{
  core_tPhysicOutput* output = &coreGlobals.physicOutputState[index];
  const float power = state ? output->state.bulb.relative_brightness : 0.f;
  const float dt_diff = (float)(output->state.bulb.integrationTimestamp - output->state.bulb.prevIntegrationTimestamp);

  if(power != output->state.bulb.prevIntegrationValue    // state flip?
     || dt_diff >= (float)(BULB_INTEGRATION_PERIOD*20.)) // or we waited long enough to get a stable discrete integration
  {
    // do the integration in a loop of small steps, roughly in BULB_INTEGRATION_PERIOD sized steps (but rounded up/down to have same sized cycles in here)
    float countf = floorf(dt_diff*(float)(1./BULB_INTEGRATION_PERIOD) + 0.5f);
    if(countf < 1.f) // single cycle/short pulses need to use the 'original' cycle time as a workaround
      countf = 1.f;
    const int count = (int)countf;
    const float dt = dt_diff/countf;
    const float dt_ratio = dt*(float)(1./BULB_INTEGRATION_PERIOD);
    const float emission = output->state.bulb.prevIntegrationValue * /*powf(dt_ratio,(float)(1./1.3)) approx:*/ cube(sqrtf(sqrtf(dt_ratio))); // pow boosts the emission artificially a bit, especially for GTS3/WPC alphaseg, as the power-on cycle is somehow too short?!?
    for(int i = 0; i < count; ++i)
      core_eye_flicker_fusion(output, emission);

    // No real need to do this anymore, rather let the low pass filter over/undershoot to be more 'correct'
    /*if (output->state.bulb.prevIntegrationValue != 0.f && output->value > (float)(254./255.)) // Stabilize Steady-On state
      output->value = 1.f;
    else if (output->state.bulb.prevIntegrationValue == 0.f && output->value < (float)(1./255.)) // Stabilize Steady-Off state
      output->value = 0.f;*/
    output->state.bulb.prevIntegrationTimestamp = output->state.bulb.integrationTimestamp;
    output->state.bulb.prevIntegrationValue = power;
  }
  // else: wait with the integration until some more time vanished or the state will flip
  output->state.bulb.integrationTimestamp = now;

  #ifdef LOG_PWM_OUT
  if (index == LOG_PWM_OUT)
    printf("Output #%d t=%8.5f T=%5.0f e=%0.3f V=%0.3f S=%s\n", index, now, output->state.bulb.filament_temperature, bulb_filament_temperature_to_emission(output->state.bulb.bulb, output->state.bulb.filament_temperature), output->value, state ? "x" : "-");
  #endif
}

void core_set_pwm_output_type(int startIndex, int count, int type)
{
  for (int i = startIndex; i < startIndex + count; i++) {
    memset(&(coreGlobals.physicOutputState[i]), 0, sizeof(core_tPhysicOutput));
    coreGlobals.physicOutputState[i].flipBufferPos = (coreGlobals.binaryOutputState[i >> 3] >> (i & 7)) & 1;
    coreGlobals.physicOutputState[i].type = type;
    switch (type) {
    case CORE_MODOUT_NONE:
      coreGlobals.physicOutputState[i].integrator = &core_update_pwm_output_nop;
      break;
    case CORE_MODOUT_PULSE:
      coreGlobals.physicOutputState[i].integrator = &core_update_pwm_output_pulse;
      break;
    case CORE_MODOUT_SOL_CUSTOM:
      coreGlobals.physicOutputState[i].integrator = &core_update_pwm_output_custom;
      break;
    case CORE_MODOUT_SOL_2_STATE:
      coreGlobals.physicOutputState[i].state.sol.fastOn = TRUE;
      // TODO 60ms is likely too much. For example for Stern SAM, the sequence is 40ms pulse to lift flipper then 1ms pulse every 12ms to hold.
      coreGlobals.physicOutputState[i].state.sol.switchDownLatency = 0.060f;
      coreGlobals.physicOutputState[i].integrator = &core_update_pwm_output_sol_2_state;
      break;
    case CORE_MODOUT_LEGACY_SOL_2_STATE:
      coreGlobals.physicOutputState[i].state.sol.fastOn = FALSE;
      // TODO 60ms is likely too much. For example for Stern SAM, the sequence is 40ms pulse to lift flipper then 1ms pulse every 12ms to hold.
      coreGlobals.physicOutputState[i].state.sol.switchDownLatency = 0.060f;
      coreGlobals.physicOutputState[i].integrator = &core_update_pwm_output_sol_2_state;
      break;
    case CORE_MODOUT_BULB_44_5_7V_AC: // Sega/Stern Whitestar uses 5.7V AC wired to #44 bulbs for GI which leads to a (very slow) bulb equilibrium around 78% of the rated bulb brightness. Likely for less heat and longer bulb life ?
      coreGlobals.physicOutputState[i].state.bulb.bulb = BULB_44;
      coreGlobals.physicOutputState[i].state.bulb.U = 5.7f;
      coreGlobals.physicOutputState[i].state.bulb.isAC = TRUE;
      coreGlobals.physicOutputState[i].state.bulb.serial_R = 0.0f;
      coreGlobals.physicOutputState[i].state.bulb.relative_brightness = 1.f;
      coreGlobals.physicOutputState[i].integrator = &core_update_pwm_output_bulb;
      break;
    case CORE_MODOUT_BULB_44_6_3V_AC: // AC bulb outputs used for GI strings. Voltage drop through WPC triacs are considered as neglectable.
      coreGlobals.physicOutputState[i].state.bulb.bulb = BULB_44;
      coreGlobals.physicOutputState[i].state.bulb.U = 6.3f;
      coreGlobals.physicOutputState[i].state.bulb.isAC = TRUE;
      coreGlobals.physicOutputState[i].state.bulb.serial_R = 0.0f;
      coreGlobals.physicOutputState[i].state.bulb.relative_brightness = 1.f;
      coreGlobals.physicOutputState[i].integrator = &core_update_pwm_output_bulb;
      break;
    case CORE_MODOUT_BULB_44_6_3V_AC_REV: // Same but reversed through a relay (S11 hardware uses this for GI)
      coreGlobals.physicOutputState[i].state.bulb.bulb = BULB_44;
      coreGlobals.physicOutputState[i].state.bulb.U = 6.3f;
      coreGlobals.physicOutputState[i].state.bulb.isAC = TRUE;
      coreGlobals.physicOutputState[i].state.bulb.serial_R = 0.0f;
      coreGlobals.physicOutputState[i].state.bulb.relative_brightness = 1.f;
      coreGlobals.physicOutputState[i].integrator = &core_update_pwm_output_bulb;
      coreGlobals.physicOutputState[i].state.bulb.isReversed = TRUE;
      break;
    case CORE_MODOUT_BULB_47_6_3V_AC:
      coreGlobals.physicOutputState[i].state.bulb.bulb = BULB_47;
      coreGlobals.physicOutputState[i].state.bulb.U = 6.3f;
      coreGlobals.physicOutputState[i].state.bulb.isAC = TRUE;
      coreGlobals.physicOutputState[i].state.bulb.serial_R = 0.0f;
      coreGlobals.physicOutputState[i].state.bulb.relative_brightness = 1.f;
      coreGlobals.physicOutputState[i].integrator = &core_update_pwm_output_bulb;
      break;
    case CORE_MODOUT_BULB_86_6_3V_AC:
      coreGlobals.physicOutputState[i].state.bulb.bulb = BULB_86;
      coreGlobals.physicOutputState[i].state.bulb.U = 6.3f;
      coreGlobals.physicOutputState[i].state.bulb.isAC = TRUE;
      coreGlobals.physicOutputState[i].state.bulb.serial_R = 0.0f;
      coreGlobals.physicOutputState[i].state.bulb.relative_brightness = 1.f;
      coreGlobals.physicOutputState[i].integrator = &core_update_pwm_output_bulb;
      break;
    case CORE_MODOUT_BULB_44_18V_DC_WPC: // Strobed bulb, 18V switched through a TIP102 and a TIP107 (voltage drop supposed of 0.7V per semiconductor switch, datasheet states Vcesat=2V for I=3A), resistor from schematics (TZ, TOTAN, CFTBL, WPC95 general)
      coreGlobals.physicOutputState[i].state.bulb.bulb = BULB_44;
      coreGlobals.physicOutputState[i].state.bulb.U = 18.f - 0.7f - 0.7f;
      coreGlobals.physicOutputState[i].state.bulb.isAC = FALSE;
      coreGlobals.physicOutputState[i].state.bulb.serial_R = 0.22f;
      coreGlobals.physicOutputState[i].state.bulb.relative_brightness = 1.f;
      coreGlobals.physicOutputState[i].integrator = &core_update_pwm_output_bulb;
      break;
    case CORE_MODOUT_BULB_44_20V_DC_GTS3: // Strobed bulb, Switched through MOSFETs (12P06 & 12N10L, no drop), serial 3,5 Ohms, then series with 1N4004 (0,7V drop) for bulbs / 120 Ohms with 1N4004 for LEDs, resistor from schematics (Cue Ball Wizard)
      coreGlobals.physicOutputState[i].state.bulb.bulb = BULB_44;
      coreGlobals.physicOutputState[i].state.bulb.U = 20.f - 0.7f;
      coreGlobals.physicOutputState[i].state.bulb.isAC = FALSE;
      coreGlobals.physicOutputState[i].state.bulb.serial_R = 3.5f;
      coreGlobals.physicOutputState[i].state.bulb.relative_brightness = 1.f;
      coreGlobals.physicOutputState[i].integrator = &core_update_pwm_output_bulb;
      break;
    case CORE_MODOUT_BULB_44_18V_DC_S11: // Strobed bulb, 18V switched through ?, resistor from schematics (Guns'n Roses)
      coreGlobals.physicOutputState[i].state.bulb.bulb = BULB_44;
      coreGlobals.physicOutputState[i].state.bulb.U = 18.f;
      coreGlobals.physicOutputState[i].state.bulb.isAC = FALSE;
      coreGlobals.physicOutputState[i].state.bulb.serial_R = 4.3f;
      coreGlobals.physicOutputState[i].state.bulb.relative_brightness = 1.f;
      coreGlobals.physicOutputState[i].integrator = &core_update_pwm_output_bulb;
      break;
    case CORE_MODOUT_BULB_44_18V_DC_SE: // Strobed bulb, 18V switched through VN02N (Solid State Relay, 0.4 Ohms resistor), a 19N06L MOSFET transistor (no drop) and a diode (0.7V drop) from Sega/Stern Whitestar schematics
      coreGlobals.physicOutputState[i].state.bulb.bulb = BULB_44;
      coreGlobals.physicOutputState[i].state.bulb.U = 18.f - 0.7f;
      coreGlobals.physicOutputState[i].state.bulb.isAC = FALSE;
      coreGlobals.physicOutputState[i].state.bulb.serial_R = 0.4f;
      coreGlobals.physicOutputState[i].state.bulb.relative_brightness = 1.f;
      coreGlobals.physicOutputState[i].integrator = &core_update_pwm_output_bulb;
      break;
    case CORE_MODOUT_BULB_44_20V_DC_CC: // Strobed bulb, 20V switched through VN02 (Solid State Relay, 0.4 Ohms resistor), a STP20N10L MOSFET transistor (no drop), a 0.02 Ohms resistor, and 2x 1N4004 diode (0.7V drop) from Capcom schematics
      coreGlobals.physicOutputState[i].state.bulb.bulb = BULB_44;
      coreGlobals.physicOutputState[i].state.bulb.U = 20.f - 0.7f - 0.7f;
      coreGlobals.physicOutputState[i].state.bulb.isAC = FALSE;
      coreGlobals.physicOutputState[i].state.bulb.serial_R = 0.4f + 0.02f;
      coreGlobals.physicOutputState[i].state.bulb.relative_brightness = 1.f;
      coreGlobals.physicOutputState[i].integrator = &core_update_pwm_output_bulb;
      break;
    case CORE_MODOUT_BULB_89_20V_DC_WPC: // Flasher 20V DC switched through a TIP102 (voltage drop supposed of 0.7V per semiconductor switch, datasheet states Vcesat=2V for I=3A), resistor from WPC schematics (TZ, TOTAN, CFTBL, WPC95 general)
      coreGlobals.physicOutputState[i].state.bulb.bulb = BULB_89;
      coreGlobals.physicOutputState[i].state.bulb.U = 20.f - 0.7f;
      coreGlobals.physicOutputState[i].state.bulb.isAC = FALSE;
      coreGlobals.physicOutputState[i].state.bulb.serial_R = 0.12f;
      coreGlobals.physicOutputState[i].state.bulb.relative_brightness = 1.f;
      coreGlobals.physicOutputState[i].integrator = &core_update_pwm_output_bulb;
      break;
    case CORE_MODOUT_BULB_89_20V_DC_GTS3: // Flasher 20V DC switched through a 12N10L Mosfet (no voltage drop), resistor from schematics (Cue Ball Wizard)
      coreGlobals.physicOutputState[i].state.bulb.bulb = BULB_89;
      coreGlobals.physicOutputState[i].state.bulb.U = 20.f;
      coreGlobals.physicOutputState[i].state.bulb.isAC = FALSE;
      coreGlobals.physicOutputState[i].state.bulb.serial_R = 0.3f;
      coreGlobals.physicOutputState[i].state.bulb.relative_brightness = 1.f;
      coreGlobals.physicOutputState[i].integrator = &core_update_pwm_output_bulb;
      break;
    case CORE_MODOUT_BULB_89_32V_DC_S11: // Flasher 32V DC switched through a TIP 122 (Vcesat max= 2 to 4V, 1V used here) with a 3 Ohms serial resistor and a diode (1V voltage drop), resistor from board photos
      coreGlobals.physicOutputState[i].state.bulb.bulb = BULB_89;
      coreGlobals.physicOutputState[i].state.bulb.U = 32.f - 1.0f - 1.0f;
      coreGlobals.physicOutputState[i].state.bulb.isAC = FALSE;
      coreGlobals.physicOutputState[i].state.bulb.serial_R = 3.f;
      coreGlobals.physicOutputState[i].state.bulb.relative_brightness = 1.f;
      coreGlobals.physicOutputState[i].integrator = &core_update_pwm_output_bulb;
      break;
    case CORE_MODOUT_BULB_89_25V_DC_S11: // Flasher 25V DC switched through a TIP 122 (Vcesat max= 2 to 4V, 1V used here) with a 1,5 Ohms serial resistor and a diode (1V voltage drop), from Police Force (and others) schematics
      coreGlobals.physicOutputState[i].state.bulb.bulb = BULB_89;
      coreGlobals.physicOutputState[i].state.bulb.U = 25.f - 1.0f - 1.0f;
      coreGlobals.physicOutputState[i].state.bulb.isAC = FALSE;
      coreGlobals.physicOutputState[i].state.bulb.serial_R = 1.5f;
      coreGlobals.physicOutputState[i].state.bulb.relative_brightness = 1.f;
      coreGlobals.physicOutputState[i].integrator = &core_update_pwm_output_bulb;
      break;
    case CORE_MODOUT_BULB_906_20V_DC_WPC: // Flasher 20V DC switched through a TIP102 (voltage drop supposed of 0.7V per semiconductor switch, datasheet states Vcesat=2V for I=3A), resistor from WPC schematics (TZ, TOTAN, CFTBL, WPC95 general)
       coreGlobals.physicOutputState[i].state.bulb.bulb = BULB_906;
       coreGlobals.physicOutputState[i].state.bulb.U = 20.f - 0.7f;
       coreGlobals.physicOutputState[i].state.bulb.isAC = FALSE;
       coreGlobals.physicOutputState[i].state.bulb.serial_R = 0.12f;
       coreGlobals.physicOutputState[i].state.bulb.relative_brightness = 1.f;
       coreGlobals.physicOutputState[i].integrator = &core_update_pwm_output_bulb;
       break;
    case CORE_MODOUT_BULB_906_20V_DC_GTS3: // Flasher 20V DC switched through a 12N10L Mosfet (no voltage drop), resistor from schematics (Cue Ball Wizard)
       coreGlobals.physicOutputState[i].state.bulb.bulb = BULB_906;
       coreGlobals.physicOutputState[i].state.bulb.U = 20.f;
       coreGlobals.physicOutputState[i].state.bulb.isAC = FALSE;
       coreGlobals.physicOutputState[i].state.bulb.serial_R = 0.3f;
       coreGlobals.physicOutputState[i].state.bulb.relative_brightness = 1.f;
       coreGlobals.physicOutputState[i].integrator = &core_update_pwm_output_bulb;
       break;
    case CORE_MODOUT_BULB_906_32V_DC_S11: // Flasher 32V DC switched through a TIP 122 (Vcesat max= 2 to 4V, 1V used here) with a 3 Ohms serial resistor and a diode (1V voltage drop), resistor from board photos
       coreGlobals.physicOutputState[i].state.bulb.bulb = BULB_906;
       coreGlobals.physicOutputState[i].state.bulb.U = 32.f - 1.0f - 1.0f;
       coreGlobals.physicOutputState[i].state.bulb.isAC = FALSE;
       coreGlobals.physicOutputState[i].state.bulb.serial_R = 3.f;
       coreGlobals.physicOutputState[i].state.bulb.relative_brightness = 1.f;
       coreGlobals.physicOutputState[i].integrator = &core_update_pwm_output_bulb;
       break;
    case CORE_MODOUT_BULB_906_25V_DC_S11: // Flasher 25V DC switched through a TIP 122 (Vcesat max= 2 to 4V, 1V used here) with a 1,5 Ohms serial resistor and a diode (1V voltage drop), from Police Force (and others) schematics
       coreGlobals.physicOutputState[i].state.bulb.bulb = BULB_906;
       coreGlobals.physicOutputState[i].state.bulb.U = 25.f - 1.0f - 1.0f;
       coreGlobals.physicOutputState[i].state.bulb.isAC = FALSE;
       coreGlobals.physicOutputState[i].state.bulb.serial_R = 1.5f;
       coreGlobals.physicOutputState[i].state.bulb.relative_brightness = 1.f;
       coreGlobals.physicOutputState[i].integrator = &core_update_pwm_output_bulb;
       break;
    case CORE_MODOUT_LED:
      coreGlobals.physicOutputState[i].state.bulb.relative_brightness = 1.f;
      coreGlobals.physicOutputState[i].integrator = &core_update_pwm_output_led;
      break;
    case CORE_MODOUT_LED_STROBE_1_10MS:
      coreGlobals.physicOutputState[i].state.bulb.relative_brightness = 10.f / 1.f;
      coreGlobals.physicOutputState[i].integrator = &core_update_pwm_output_led;
      break;
    case CORE_MODOUT_LED_STROBE_1_5MS:
       coreGlobals.physicOutputState[i].state.bulb.relative_brightness = 5.f / 1.f;
       coreGlobals.physicOutputState[i].integrator = &core_update_pwm_output_led;
       break;
    case CORE_MODOUT_LED_STROBE_8_16MS:
       coreGlobals.physicOutputState[i].state.bulb.relative_brightness = 16.f / 8.f;
       coreGlobals.physicOutputState[i].integrator = &core_update_pwm_output_led;
       break;
    case CORE_MODOUT_VFD_STROBE_05_20MS:
      coreGlobals.physicOutputState[i].state.bulb.relative_brightness = 20.f / 0.5f;
      coreGlobals.physicOutputState[i].integrator = &core_update_pwm_output_led;
      break;
    case CORE_MODOUT_VFD_STROBE_1_16MS:
      coreGlobals.physicOutputState[i].state.bulb.relative_brightness = 16.f / 1.f;
      coreGlobals.physicOutputState[i].integrator = &core_update_pwm_output_led;
      break;
    default: // Unimplemented integrator
      logerror("Unsupported physical output #%d of type %d\n", i, type);
      assert(FALSE);
    }
  }
}

void core_set_pwm_output_bulb(int startIndex, int count, int bulb, float U, int isAC, float serial_R, float relative_brightness)
{
  for (int i = startIndex; i < startIndex + count; i++) {
    memset(&(coreGlobals.physicOutputState[i]), 0, sizeof(core_tPhysicOutput));
    coreGlobals.physicOutputState[i].flipBufferPos = (coreGlobals.binaryOutputState[i >> 3] >> (i & 7)) & 1;
    coreGlobals.physicOutputState[i].type = CORE_MODOUT_CUSTOM_INTEGRATOR;
    coreGlobals.physicOutputState[i].state.bulb.bulb = bulb;
    coreGlobals.physicOutputState[i].state.bulb.U = U;
    coreGlobals.physicOutputState[i].state.bulb.isAC = isAC;
    coreGlobals.physicOutputState[i].state.bulb.serial_R = serial_R;
    coreGlobals.physicOutputState[i].state.bulb.relative_brightness = relative_brightness;
    coreGlobals.physicOutputState[i].integrator = &core_update_pwm_output_bulb;
  }
}

void core_set_pwm_output_types(int startIndex, int count, int* outputTypes)
{
   for (int i = 0; i < count; i++)
      core_set_pwm_output_type(startIndex + i, 1, outputTypes[i]);
}

// Perform emulation of the requested physical outputs from the stored PWM digital output states
// Initial implementation was performing this task upon digital output writes causing DMD animation stutters and sound buffer underflow.
// This is now performed on physic output reads, moving the CPU load to the caller thread. The client is responsible and has the ability
// to manage this load according to its use. It also allows to limit the update to the requested outputs (physics should be updated 
// according to physic engine constants while visual should be updated according to output display characteristics).
void core_update_pwm_outputs(const int startIndex, const int count)
{
   // HACK timer_get_time is not thread safe and can only be called from emulation thread. Therefore we use a fake timer with timer_starttime which is thread safe as a workaround.
   // const double now = timer_get_time();
   mame_timer fake_timer = { 0 };
   const double now = timer_starttime(&fake_timer);
   for (int i = 0; i < count; i++)
   {
      const unsigned int index = startIndex + i;
      core_tPhysicOutput* const output = &coreGlobals.physicOutputState[index];
      // Perform integration of flip states that appended since last integration and before now if any
      while (output->lastIntegrationFlipPos != output->flipBufferPos)
      {
         output->lastIntegrationFlipPos = (output->lastIntegrationFlipPos + 1) % FLIP_BUFFER_SIZE;
         output->integrator(output->flipTimeStamps[output->lastIntegrationFlipPos], index, TRUE, (output->lastIntegrationFlipPos & 1) ^ 1);
      }
      // Perform integration of stable state up to now
      output->integrator(now, index, FALSE, output->lastIntegrationFlipPos & 1);
   }
}

// Write binary state of outputs, taking care of PWM integration based on physical model of the connected device
void core_write_pwm_output(int index, int count, UINT8 bitStates)
{
   const float now = (float) timer_get_time();
   core_tPhysicOutput* output = &coreGlobals.physicOutputState[index];
   for (int i = 0; i < count; i++, bitStates = bitStates >> 1, index++, output++) {
      const int pos = index >> 3, ofs = index & 7;
      if (((coreGlobals.binaryOutputState[pos] >> ofs) & 1) != (bitStates & 1)) {
         const unsigned int bufferPos = (output->flipBufferPos + 1) % FLIP_BUFFER_SIZE;
         output->flipTimeStamps[bufferPos] = now;
         output->flipBufferPos = bufferPos;
         coreGlobals.binaryOutputState[pos] ^= 1 << ofs;
      }
   }
}

void core_write_pwm_output_8b(int index, UINT8 bitStates)
{
   assert((index & 7) == 0);
   UINT8 changeMask = coreGlobals.binaryOutputState[index >> 3] ^ bitStates;
   if (!changeMask)
      return;
   const float now = (float) timer_get_time();
   for (core_tPhysicOutput* output = &coreGlobals.physicOutputState[index]; changeMask; changeMask >>= 1, output++)
      if (changeMask & 1)
      {
         const unsigned int bufferPos = (output->flipBufferPos + 1) % FLIP_BUFFER_SIZE;
         output->flipTimeStamps[bufferPos] = now;
         output->flipBufferPos = bufferPos;
      } 
   coreGlobals.binaryOutputState[index >> 3] = bitStates;
}

void core_write_masked_pwm_output_8b(int index, UINT8 bitStates, UINT8 bitMask)
{
   assert((index & 7) == 0);
   UINT8 changeMask = bitMask & (coreGlobals.binaryOutputState[index >> 3] ^ bitStates); // Identify differences
   if (!changeMask)
      return;
   const float now = (float) timer_get_time();
   for (core_tPhysicOutput* output = &coreGlobals.physicOutputState[index]; changeMask; changeMask >>= 1, output++)
      if (changeMask & 1)
      {
         const unsigned int bufferPos = (output->flipBufferPos + 1) % FLIP_BUFFER_SIZE;
         output->flipTimeStamps[bufferPos] = now;
         output->flipBufferPos = bufferPos;
      }
   coreGlobals.binaryOutputState[index >> 3] = (coreGlobals.binaryOutputState[index >> 3] & ~bitMask) | (bitStates & bitMask);
}

// Write a 8xn lamp matrix, taking care of PWM integration based on physical model of connected device
void core_write_pwm_output_lamp_matrix(int startIndex, UINT8 columns, UINT8 rows, int nCols)
{
   if (options.usemodsol & (CORE_MODOUT_ENABLE_PHYSOUT_LAMPS | CORE_MODOUT_FORCE_ON))
   {
      for (const int endIndex = startIndex + nCols * 8; startIndex < endIndex; columns >>= 1, startIndex += 8) {
         if (columns & 1) {
            coreGlobals.tmpLampMatrix[(startIndex - CORE_MODOUT_LAMP0) >> 3] |= rows;
            core_write_pwm_output_8b(startIndex, rows);
         }
         else {
            core_write_pwm_output_8b(startIndex, 0);
         }
      }
   }
   else {
      core_setLamp(coreGlobals.tmpLampMatrix, columns << ((startIndex - CORE_MODOUT_LAMP0) / 8), rows);
   }
}


//
//
//

/* Generic DMD PWM integration.

  All hardware so far (Alvin G, Data East, Sega/Stern Whitestar, GTS3, WPC, SAM, Capcom, Sleic (Spain), Spinball)
  creates shades using PWM on a plasma or LED display (later Stern games). Therefore, PinMame offers access to the
  raw high frequency frames (f.e. for coloring) or to a PWM integrated view (f.e. for rendering).

  Unlike lamps which have varying strobe periods, DMD are rasterized at a fixed frequency. Therefore, the implementation
  simply stores the frames at this frequency and apply a (simple) low pass filter to account for the eye flicker-fusion limit.
  The integration period (number of frame to store) and cut-off frequency are selected from the observed PWM pattern of 
  common hardware: WPC is 122/3 = 40.7Hz, GTS3 is 376/10 = 37.6Hz, so an overall plasma inertia & flicker fusion period
  of around 40ms (25Hz).

  Filters are computed using the following script in GNU Octave:

pkg load signal

fc = 15; % Cut-off frequency (Hz), PWM patterns/frequency suggests something below 35Hz
int_factor = 65000; % Integer arithmetic fixed point scaling


% Data East DMD 128x32 & Sega/Stern Whitestar
n = 16
fs = 233.5; % Sampling rate (Hz) = DMD VBlank
data=[repmat([0;0;1],100,1), repmat([1;1;0],100,1), repmat([1;1;1],100,1)];

% GTS3
n = 24
fs = 376; % Sampling rate (Hz) = DMD VBlank
data=[repmat([0;0;0;0;0;0;0;1],30,1), repmat([0;0;0;0;0;1;1;1],30,1)];

% WPC
n = 8
fs = 122.1; % Sampling rate (Hz) = DMD VBlank
data=[repmat([0;0;1],100,1),repmat([0;1;1],100,1)];

% Alvin G
n = 8
fs = 293.; % Sampling rate (Hz) = DMD VBlank
data=[repmat([0;0;0;1],100,1),repmat([0;1;0;1],100,1),repmat([0;0;1;1],100,1),repmat([0;1;1;1],100,1)];

b = fir1(n, fc/(fs/2));
b = round(int_factor * b) / int_factor

filtered = filter(b,1,data);

clf
x = (0:(max(size(data))-1)) / fs;
filtered = round(255*filtered)
for i_plot = 1:size(data,2)
  subplot ( columns ( filtered ), 1, i_plot)
  stairs(x, filtered(:,i_plot),";PWM Pattern;")
endfor

fprintf('n=%i (suggested n=%i from fs/fc)\n', n+1, round(fs/fc));
fprintf('filter=[');
fprintf('%i, ', int_factor * b);
fprintf(']\n');
fprintf('sum=%i\n', sum(int_factor * b));
*/

void core_dmd_pwm_init(core_tDMDPWMState* dmd_state, const int width, const int height, const int filter, const int raw_combiner) {
  assert((width & 0x0007) == 0);
  dmd_state->width = width;
  dmd_state->height = height;
  dmd_state->frameSize = width * height;
  dmd_state->rawFrameSize = dmd_state->frameSize / 8;
  dmd_state->raw_combiner = raw_combiner;
  static const UINT16 fir_colorization_3_frames[] = { 20000, 20000, 20000 };
  switch (filter)
  {
  case CORE_DMD_PWM_FILTER_DE_128x16: // Data East 128x16: 177.5Hz refresh rate / 15Hz low pass filter / 2 frames PWM pattern
    {
      static const UINT16 fir_177_15[] = { 549, 2291, 7523, 13954, 16901, 13954, 7523, 2291, 549 };
      dmd_state->fir_weights = fir_177_15;
      dmd_state->fir_sum = 65535;
      dmd_state->fir_size = dmd_state->nFrames = sizeof(fir_177_15) / sizeof(UINT16);
    }
    break;
  case CORE_DMD_PWM_FILTER_DE_128x32: // Data East & Sega/Stern Whitestar: 234Hz refresh rate / 15Hz low pass filter / 2 frames (2/3 - 1/3 length) PWM pattern
  case CORE_DMD_PWM_FILTER_DE_192x64: // Sega: 224Hz refresh rate / 15Hz low pass filter / 2 frames (2/3 - 1/3 length) PWM pattern
    {
      static const UINT16 fir_230_15[] = { 789, 2657, 7755, 13529, 16075, 13529, 7755, 2657, 789 };
      dmd_state->fir_weights = fir_230_15;
      dmd_state->fir_sum = 65533;
      dmd_state->fir_size = dmd_state->nFrames = sizeof(fir_230_15) / sizeof(UINT16);
    }
    break;
  case CORE_DMD_PWM_FILTER_GTS3: // GTS3: 376Hz refresh rate / 15Hz low pass filter / 1,3,6,8,10 frames PWM pattern
    {
      static const UINT16 fir_376_15[] = { 233, 321, 544, 921, 1452, 2115, 2868, 3651, 4396, 5032, 5495, 5739, 5740, 5495, 5032, 4396, 3651, 2868, 2115, 1452, 921, 544, 321, 233 };
      dmd_state->fir_weights = fir_376_15;
      dmd_state->fir_sum = 65535;
      dmd_state->fir_size = dmd_state->nFrames = sizeof(fir_376_15) / sizeof(UINT16);
    }
    break;
  case CORE_DMD_PWM_FILTER_WPC: // WPC: 122Hz refresh rate / 15Hz low pass filter / 3 frames PWM pattern (there seems to be longer PWM patterns, see T2 gun animation sequence)
    {
      static const UINT16 fir_122_15[] = { 269, 2570, 10580, 19348, 19349, 10580, 2570, 269 };
      dmd_state->fir_weights = fir_122_15;
      dmd_state->fir_sum = 65535;
      dmd_state->fir_size = dmd_state->nFrames = sizeof(fir_122_15) / sizeof(UINT16);
    }
    break;
  case CORE_DMD_PWM_FILTER_ALVG1: // Alvin G. DMD Generation 1: 1194.4Hz refresh rate / 15Hz low pass filter / 4 frames PWM pattern
    {
      static const UINT16 fir_1194_15[] = { 938, 1985, 4737, 8160, 10943, 12009, 10943, 8160, 4737, 1985, 938 };
      dmd_state->fir_weights = fir_1194_15;
      dmd_state->fir_sum = 65535;
      dmd_state->fir_size = dmd_state->nFrames = sizeof(fir_1194_15) / sizeof(UINT16);
    }
    break;
  case CORE_DMD_PWM_FILTER_ALVG2: // Alvin G. DMD Generation 2: 298.6Hz refresh rate / 15Hz low pass filter / 4 frames PWM pattern
    {
      static const UINT16 fir_299_15[] = { 656, 1633, 4384, 8185, 11501, 12817, 11501, 8185, 4384, 1633, 656 };
      dmd_state->fir_weights = fir_299_15;
      dmd_state->fir_sum = 65535;
      dmd_state->fir_size = dmd_state->nFrames = sizeof(fir_299_15) / sizeof(UINT16);
    }
    break;
  default:
    assert(0); // Unsupported filter
  }
  dmd_state->rawFrames = malloc(dmd_state->nFrames * dmd_state->rawFrameSize);
  dmd_state->shadedFrame = malloc(dmd_state->frameSize * sizeof(UINT16));
  dmd_state->bitplaneFrame = malloc(dmd_state->frameSize * sizeof(UINT8));
  dmd_state->luminanceFrame = malloc(dmd_state->frameSize * sizeof(UINT8));
  assert(dmd_state->rawFrames != NULL && dmd_state->shadedFrame != NULL && dmd_state->bitplaneFrame != NULL && dmd_state->luminanceFrame != NULL);
  memset(dmd_state->rawFrames, 0, dmd_state->nFrames * dmd_state->rawFrameSize);
  memset(dmd_state->shadedFrame, 0, dmd_state->frameSize * sizeof(UINT16));
  memset(dmd_state->bitplaneFrame, 0, dmd_state->frameSize * sizeof(UINT8));
  memset(dmd_state->luminanceFrame, 0, dmd_state->frameSize * sizeof(UINT8));
  dmd_state->nextFrame = 0;
}

void core_dmd_pwm_exit(core_tDMDPWMState* dmd_state) {
   free(dmd_state->rawFrames);
   dmd_state->rawFrames = NULL;
   free(dmd_state->shadedFrame);
   dmd_state->shadedFrame = NULL;
   free(dmd_state->bitplaneFrame);
   dmd_state->bitplaneFrame = NULL;
   free(dmd_state->luminanceFrame);
   dmd_state->luminanceFrame = NULL;
}

// TODO for the time being, DMD are always updated from core/updateDisplay, running at a fixed 60Hz. This may lead to stutters
// as it is not aligned with real display refresh rate. We should update DMD on request but this needs to make these functions
// thread safe. To avoid synchronization, a simple loop model with consumer accesing data before barrier, and provider pushing
// data after the barrier should be enough.
void core_dmd_submit_frame(core_tDMDPWMState* dmd_state, const UINT8* frame, const int ntimes) {
  for (int i = 0; i < ntimes; i++) {
    memcpy(dmd_state->rawFrames + dmd_state->nextFrame * dmd_state->rawFrameSize, frame, dmd_state->rawFrameSize);
    dmd_state->nextFrame = (dmd_state->nextFrame + 1) % dmd_state->nFrames;
    dmd_state->frame_index++;
  }
}

void core_dmd_update_pwm(core_tDMDPWMState* dmd_state) {
  int ii, jj, kk;

  // Apply low pass filter over stored frames then scale down to final shades
  memset(dmd_state->shadedFrame, 0, dmd_state->width * dmd_state->height * sizeof(UINT16));
  for (ii = 0; ii < dmd_state->fir_size; ii++) {
    const UINT16 frame_weight = dmd_state->fir_weights[ii];
    UINT16* line = dmd_state->shadedFrame;
    UINT8* frameData = dmd_state->rawFrames + ((dmd_state->nextFrame + (dmd_state->nFrames - 1) + (dmd_state->nFrames - ii)) % dmd_state->nFrames) * dmd_state->rawFrameSize;
    for (jj = 0; jj < dmd_state->rawFrameSize; jj++) {
      UINT8 data = *frameData++;
      if (dmd_state->revByte) {
        for (kk = 0; kk < 8; kk++, data >>= 1, line++)
          if (data & 0x01) (*line) += frame_weight;
      } else {
        for (kk = 0; kk < 8; kk++, data <<= 1, line++)
          if (data & 0x80) (*line) += frame_weight;
      }
    }
  }
  UINT16* line = dmd_state->shadedFrame;
  for (ii = 0; ii < dmd_state->height * dmd_state->width; ii++) {
    unsigned int data = (unsigned int) (*line++); // unsigned int precision is needed here
    dmd_state->luminanceFrame[ii] = (UINT8)((255u * data) / dmd_state->fir_sum);
  }

  // Compute combined bitplane frames as they used to be for backward compatibility with colorization plugins
  #if defined(VPINMAME) || defined(LIBPINMAME)
  switch (dmd_state->raw_combiner) {
  case CORE_DMD_PWM_COMBINER_LUM_4:
    for (ii = 0; ii < dmd_state->height * dmd_state->width; ii++)
      dmd_state->bitplaneFrame[ii] = dmd_state->luminanceFrame[ii] >> 6;
    break;
  case CORE_DMD_PWM_COMBINER_LUM_16: // GTS3 never had a stable combiner since PWM patterns vary over 1/3/6/8/10 frames, hence it provided raw 1 bitplane frame and not really stable combined one
    for (ii = 0; ii < dmd_state->height * dmd_state->width; ii++)
      dmd_state->bitplaneFrame[ii] = dmd_state->luminanceFrame[ii] >> 4;
    break;
  case CORE_DMD_PWM_COMBINER_SUM_3: // Sum of the last 3 raw frames seen (WPC)
    {
      UINT8* rawData = &dmd_state->bitplaneFrame[0];
      UINT8* frame0 = dmd_state->rawFrames + ((dmd_state->nextFrame + (dmd_state->nFrames - 1)) % dmd_state->nFrames) * dmd_state->rawFrameSize;
      UINT8* frame1 = dmd_state->rawFrames + ((dmd_state->nextFrame + (dmd_state->nFrames - 2)) % dmd_state->nFrames) * dmd_state->rawFrameSize;
      UINT8* frame2 = dmd_state->rawFrames + ((dmd_state->nextFrame + (dmd_state->nFrames - 3)) % dmd_state->nFrames) * dmd_state->rawFrameSize;
      for (kk = 0; kk < dmd_state->rawFrameSize; kk++) {
        const unsigned int intens1 = (frame0[kk] & 0x55) + (frame1[kk] & 0x55) + (frame2[kk] & 0x55); // 0x55 = 01010101 binary mask
        const unsigned int intens2 = (frame0[kk] & 0xaa) + (frame1[kk] & 0xaa) + (frame2[kk] & 0xaa); // 0xaa = 10101010 binary mask
        *rawData++ =  intens1       & 0x03;
        *rawData++ = (intens2 >> 1) & 0x03;
        *rawData++ = (intens1 >> 2) & 0x03;
        *rawData++ = (intens2 >> 3) & 0x03;
        *rawData++ = (intens1 >> 4) & 0x03;
        *rawData++ = (intens2 >> 5) & 0x03;
        *rawData++ = (intens1 >> 6) & 0x03;
        *rawData++ = (intens2 >> 7) & 0x03;
      }
    }
    break;
  case CORE_DMD_PWM_COMBINER_SUM_2_1: // high bit for double length frame, low bit for single length frame
  case CORE_DMD_PWM_COMBINER_SUM_1_2:
    {
      UINT8 *rawData = &dmd_state->bitplaneFrame[0], *frame0, *frame1;
      if (dmd_state->raw_combiner == CORE_DMD_PWM_COMBINER_SUM_2_1) { // double length frame are the 2 before last one, single length frame is the last one (Data East 128x32, Sega/Stern Whitestar)
        frame0 = dmd_state->rawFrames + ((dmd_state->nextFrame + (dmd_state->nFrames - 2)) % dmd_state->nFrames) * dmd_state->rawFrameSize;
        frame1 = dmd_state->rawFrames + ((dmd_state->nextFrame + (dmd_state->nFrames - 1)) % dmd_state->nFrames) * dmd_state->rawFrameSize;
      }
      else if (dmd_state->raw_combiner == CORE_DMD_PWM_COMBINER_SUM_1_2) { // double length frame are the 2 last ones, single length frame is the one before (Data East 128x16)
        frame0 = dmd_state->rawFrames + ((dmd_state->nextFrame + (dmd_state->nFrames - 1)) % dmd_state->nFrames) * dmd_state->rawFrameSize;
        frame1 = dmd_state->rawFrames + ((dmd_state->nextFrame + (dmd_state->nFrames - 3)) % dmd_state->nFrames) * dmd_state->rawFrameSize;
      }
      for (kk = 0; kk < dmd_state->rawFrameSize; kk++) {
        const unsigned int intens1 = 2*(frame0[kk] & 0x55) + (frame1[kk] & 0x55);   // 0x55 = 01010101 binary mask
        const unsigned int intens2 =   (frame0[kk] & 0xaa) + (frame1[kk] & 0xaa)/2; // 0xaa = 10101010 binary mask
        *rawData++ = (intens2 >> 6) & 0x03;
        *rawData++ = (intens1 >> 6) & 0x03;
        *rawData++ = (intens2 >> 4) & 0x03;
        *rawData++ = (intens1 >> 4) & 0x03;
        *rawData++ = (intens2 >> 2) & 0x03;
        *rawData++ = (intens1 >> 2) & 0x03;
        *rawData++ =  intens2       & 0x03;
        *rawData++ =  intens1       & 0x03;
      }
    }
    break;
  case CORE_DMD_PWM_COMBINER_SUM_4: // Sum of the last 4 frames (Alvin G. for Pistol Poker & Mystery Castle)
    {
      UINT8* rawData = &dmd_state->bitplaneFrame[0];
      UINT8* frame0 = dmd_state->rawFrames + ((dmd_state->nextFrame + (dmd_state->nFrames - 1)) % dmd_state->nFrames) * dmd_state->rawFrameSize;
      UINT8* frame1 = dmd_state->rawFrames + ((dmd_state->nextFrame + (dmd_state->nFrames - 2)) % dmd_state->nFrames) * dmd_state->rawFrameSize;
      UINT8* frame2 = dmd_state->rawFrames + ((dmd_state->nextFrame + (dmd_state->nFrames - 3)) % dmd_state->nFrames) * dmd_state->rawFrameSize;
      UINT8* frame3 = dmd_state->rawFrames + ((dmd_state->nextFrame + (dmd_state->nFrames - 4)) % dmd_state->nFrames) * dmd_state->rawFrameSize;
      for (kk = 0; kk < dmd_state->rawFrameSize; kk++) {
        UINT8 v0 = frame0[kk], v1 = frame1[kk], v2 = frame2[kk], v3 = frame3[kk];
        for (ii = 0; ii < 8; ii++, v0 >>= 1, v1 >>= 1, v2 >>= 1, v3 >>= 1)
          *rawData++ = (v0 & 0x01) + (v1 & 0x01) + (v1 & 0x02) + (v3 & 0x01);
      }
    }
    break;
  default:
    assert(0); // Unsupported combiner
  }
  #endif

  // For GTS3, WPC and Alvin G. 2 also store raw single bitplane frame for backward compatibility with colorization plugins
  // TODO move these data to dmd_state struct (for cleanup and to fix multiple DMD support for GTS3 Strikes N' Spares)
  #if defined(VPINMAME) || defined(LIBPINMAME)
  if (core_gameData->gen & (GEN_ALLWPC | GEN_GTS3 | GEN_ALVG_DMD2)) {
    raw_dmd_frame_count = dmd_state->nFrames > CORE_MAX_RAW_DMD_FRAMES ? CORE_MAX_RAW_DMD_FRAMES : dmd_state->nFrames;
    UINT8* rawData = &raw_dmd_frames[0];
    for (int frame = 0; frame < (int)raw_dmd_frame_count; frame++) {
      UINT8* frameData = dmd_state->rawFrames + ((dmd_state->nextFrame + (dmd_state->nFrames - 1) + (dmd_state->nFrames - frame)) % dmd_state->nFrames) * dmd_state->rawFrameSize;
      for (int jj = 0; jj < dmd_state->rawFrameSize; jj++) {
        *rawData = dmd_state->revByte ? (*frameData++) : core_revbyte(*frameData++);
        rawData++;
      }
    }
  }
  else {
    raw_dmd_frame_count = 0;
  }
  #endif
}

// Render to internal display, using provided luminance, if there is a visible display (PinMame always, and VPinMame when its window is shown)
// FIXME apply colors LUT ?
#if defined(PINMAME) || defined(VPINMAME)
void core_dmd_render_internal(struct mame_bitmap *bitmap, const int x, const int y, const int width, const int height, const UINT8* dmdDotLum, const int apply_aa) {
  #define DMD_OFS(row, col) ((row)*width + col)
  #define DMD_PAL(x) ((int)sizeof(core_palette) / 3 - 48 + ((3 * (int)x) >> 4)) // The trail of PinMame palette has 48 DMD dot shades
  //#define DMD_PAL(x) = dmdColor[63 + (x >> 4)]
  int ii, jj;
  pen_t *dmdColor = &Machine->pens[COL_DMDOFF];
  BMTYPE **lines = ((BMTYPE **)bitmap->line) + (y * locals.displaySize);
  for (ii = 0; ii < height; ii++) {
    BMTYPE *line = (*lines) + (x * locals.displaySize);
    for (jj = 0; jj < width; jj++) {
       int p = dmdDotLum[DMD_OFS(ii, jj)], q = DMD_PAL(dmdDotLum[DMD_OFS(ii, jj)]);
      *line = DMD_PAL(dmdDotLum[DMD_OFS(ii, jj)]);
      line += locals.displaySize;
    }
    lines += locals.displaySize;
  }
  // Apply antialiasing if enabled or clear pixels between dots
  assert((locals.displaySize == 1) || (locals.displaySize == 2));
  if (locals.displaySize == 2) {
    lines = ((BMTYPE **)bitmap->line) + (y * locals.displaySize);
    for (ii = 0; ii < height * 2 - 1; ii++) {
      BMTYPE *line = (*lines) + x;
      for (jj = 0; jj < width *  2 - 1; jj++) {
        int pi = (ii - 1) >> 1, pj = (jj - 1) >> 1;
        if (!apply_aa) {
          if ((ii & 1) || (jj & 1))
            *line = DMD_PAL(0);
        } else if ((ii & 1) && (jj & 1)) { // Corner point
          int lum = ((int)dmdDotLum[DMD_OFS(pi, pj)] + (int)dmdDotLum[DMD_OFS(pi+1, pj)] + (int)dmdDotLum[DMD_OFS(pi, pj+1)] + (int)dmdDotLum[DMD_OFS(pi+1, pj+1)]) / 6;
          *line = DMD_PAL(lum);
        } else if (ii & 1) { // Vertical side point
          int lum = ((int)dmdDotLum[DMD_OFS(pi, pj+1)] + (int)dmdDotLum[DMD_OFS(pi+1, pj+1)]) / 3;
          *line = DMD_PAL(lum);
        } else if (jj & 1) { // Horizontal side point
          int lum = ((int)dmdDotLum[DMD_OFS(pi+1, pj)] + (int)dmdDotLum[DMD_OFS(pi+1, pj+1)]) / 3;
          *line = DMD_PAL(lum);
        }
        line ++;
      }
      lines ++;
    }
  }
  #undef DMD_OFS
  #undef DMD_PAL
}
#endif

// Prepare data for VPinMame interface, using computed luminance and applying user LUT for luminance/color (Controller.RawDmdPixels / Controller.RawColoredDmdPixels)
#ifdef VPINMAME
void core_dmd_render_vpm(const int width, const int height, const UINT8* dmdDotLum) {
  const int size = width * height;
  g_raw_dmdx = width;
  g_raw_dmdy = height;
  if (memcmp(locals.vpm_dmd_last_lum, dmdDotLum, size) != 0) {
    memcpy(locals.vpm_dmd_last_lum, dmdDotLum, size);
    UINT8* rawLum = g_raw_dmdbuffer;
    UINT32* rawCol = g_raw_colordmdbuffer;
    for (int ii = 0; ii < size; ii++) {
      UINT8 lum = dmdDotLum[ii];
      (*rawLum++) = locals.vpm_dmd_luminance_lut[lum];
      (*rawCol++) = locals.vpm_dmd_color_lut[lum];
    }
    g_needs_DMD_update = 1;
  }
}
#endif

// Prepare data for LibPinMame interface (similar to VPinMame but without color LUT, and with a global flag to select luminance/bitplanes)
#ifdef LIBPINMAME
void core_dmd_render_lpm(const int width, const int height, const UINT8* dmdDotLum, const UINT8* dmdDotRaw) {
  const int size = width * height;
  g_raw_dmdx = width;
  g_raw_dmdy = height;
  if (g_fDmdMode == 0) { // PINMAME_DMD_MODE_BRIGHTNESS
    if (memcmp(locals.vpm_dmd_last_lum, dmdDotLum, size) != 0) {
      memcpy(locals.vpm_dmd_last_lum, dmdDotLum, size);
      UINT8* rawLum = g_raw_dmdbuffer;
      for (int ii = 0; ii < size; ii++)
        (*rawLum++) = locals.vpm_dmd_luminance_lut[dmdDotLum[ii]];
      g_needs_DMD_update = 1;
	}
  }
  else if (g_fDmdMode == 1) {// PINMAME_DMD_MODE_RAW
    if (memcmp(g_raw_dmdbuffer, dmdDotRaw, size) != 0) {
      memcpy(g_raw_dmdbuffer, dmdDotRaw, size);
      g_needs_DMD_update = 1;
	}
  }
}
#endif

// Send main DMD bitplane frame to dmddevice plugins
#ifdef VPINMAME
void core_dmd_render_dmddevice(const int width, const int height, const UINT8* dmdDotRaw, const int isDMD2) {
  if (g_fShowPinDMD) {
    const int isStrikeNSpares = strncasecmp(Machine->gamedrv->name, "snspare", 7) == 0;
    if (isStrikeNSpares) {
      if (isDMD2)
        renderDMDFrame(core_gameData->gen, width, height, dmdDotRaw, g_fDumpFrames, Machine->gamedrv->name, raw_dmd_frame_count, raw_dmd_frames);
      else
        render2ndDMDFrame(core_gameData->gen, width, height, dmdDotRaw, g_fDumpFrames, Machine->gamedrv->name, raw_dmd_frame_count, raw_dmd_frames);
    }
    else {
      renderDMDFrame(core_gameData->gen, width, height, dmdDotRaw, g_fDumpFrames, Machine->gamedrv->name, raw_dmd_frame_count, raw_dmd_frames);
      render2ndDMDFrame(core_gameData->gen, width, height, dmdDotRaw, g_fDumpFrames, Machine->gamedrv->name, raw_dmd_frame_count, raw_dmd_frames);
    }
  }
}
#endif

// Save main DMD bitplane and raw frames to a capture file
// TODO this is disabled for Strikes'n Spares which has 2 DMDs
// TODO not sure to understand why frame capture is performed if dmddevice is enabled simultaneously with virtual DMD. Remove it ?
#ifdef VPINMAME
void core_dmd_capture_frame(const int width, const int height, const UINT8* dmdDotRaw, const int rawFrameCount, const UINT8* rawFrame) {
  const int isStrikeNSpares = strncasecmp(Machine->gamedrv->name, "snspare", 7) == 0;
  if (!isStrikeNSpares && (g_fDumpFrames || (g_fShowPinDMD && g_fShowWinDMD))) {
    FILE *f;
    char *ptr;
    char DumpFilename[MAX_PATH];
    const DWORD tick = GetTickCount();
    #ifndef _WIN64
      const HINSTANCE hInst = GetModuleHandle("VPinMAME.dll");
    #else
      const HINSTANCE hInst = GetModuleHandle("VPinMAME64.dll");
    #endif
    GetModuleFileName(hInst, DumpFilename, MAX_PATH);
    ptr = strrchr(DumpFilename, '\\');
    strcpy_s(ptr + 1, 11, "DmdDump\\");
    strcat_s(DumpFilename, MAX_PATH, Machine->gamedrv->name);

    // Additional single bitplane raw frames for GTS3, WPC and Alvin G.
    if (rawFrameCount != 0) {
      FILE* fr;
      char RawFilename[MAX_PATH];
      strcpy_s(RawFilename, MAX_PATH, DumpFilename);
      strcat_s(RawFilename, MAX_PATH, ".raw");
      fr = fopen(RawFilename, "rb");
      if (fr) {
        fclose(fr);
        fr = fopen(RawFilename, "ab");
      }
      else {
        fr = fopen(RawFilename, "ab");
        if (fr) {
          fputc(0x52, fr);
          fputc(0x41, fr);
          fputc(0x57, fr);
          fputc(0x00, fr);
          fputc(0x01, fr);
          fputc(width, fr);
          fputc(height, fr);
          fputc(rawFrameCount, fr);
        }
      }
      if (fr) {
        fwrite(&tick, 1, 4, fr);
        fwrite(rawFrame, 1, (width * height / 8 * rawFrameCount), fr);
        fclose(fr);
      }
    }

    // Bitplane frame combined from PWM pattern of raw frames
    strcat_s(DumpFilename, MAX_PATH, ".txt");
    f = fopen(DumpFilename, "a");
    if (f) {
      fprintf(f, "0x%08x\n", tick);
      for (int jj = 0; jj < height; jj++) {
        for (int ii = 0; ii < width; ii++)
          fprintf(f, "%01x", dmdDotRaw[jj*width + ii]);
        fprintf(f, "\n");
      }
      fprintf(f, "\n");
      fclose(f);
    }
  }
}
#endif

void core_dmd_video_update(struct mame_bitmap *bitmap, const struct rectangle *cliprect, const struct core_dispLayout *layout, core_tDMDPWMState* dmd_state) {
  UINT8 *dmdDotRaw, *dmdDotLum;
  
  if (dmd_state) { // Full DMD state with luminance and bitplane state
    dmdDotRaw = dmd_state->bitplaneFrame;
    dmdDotLum = dmd_state->luminanceFrame;
  }
  else { // Only bitplane state: consider luminance equal to (scaled) bitplane output
    dmdDotRaw = &coreGlobals.dmdDotRaw[0];
    dmdDotLum = &coreGlobals.dmdDotLum[0];
    const int shift = (core_gameData->gen & (GEN_SAM|GEN_SPA)) != 0 ? 4 : 6;
    for (int ii = 0; ii < layout->length; ii++)
      dmdDotLum[ii] = dmdDotRaw[ii] << shift;
  }

  #if defined(LIBPINMAME)
    const int isMainDMD = layout->length >= 128; // Up to 2 main DMDs (1 for all games, except Strike'n Spares which has 2)
    if (isMainDMD) {
      core_dmd_render_lpm(layout->length, layout->start, dmdDotLum, dmdDotRaw);
      has_DMD_Video = 1;
    }

  #elif defined(VPINMAME)
    const int isMainDMD = layout->length >= 128; // Up to 2 main DMDs (1 for all games, except Strike'n Spares which has 2)
    // FIXME check for VPinMame window hidden/shown state, and do not render if hidden
    core_dmd_render_internal(bitmap, layout->left, layout->top, layout->length, layout->start, dmdDotLum, pmoptions.dmd_antialias && !(layout->type & CORE_DMDNOAA));
    if (isMainDMD) {
      core_dmd_render_vpm(layout->length, layout->start, dmdDotLum);
      core_dmd_render_dmddevice(layout->length, layout->start, dmdDotRaw, layout->top != 0);
      core_dmd_capture_frame(layout->length, layout->start, dmdDotRaw, raw_dmd_frame_count ,raw_dmd_frames);
      has_DMD_Video = 1;
    }
  
  #elif defined(PINMAME)
    core_dmd_render_internal(bitmap, layout->left, layout->top, layout->length, layout->start, dmdDotLum, pmoptions.dmd_antialias && !(layout->type & CORE_DMDNOAA));

  #endif
}


//
//
//

void core_sound_throttle_adj(int sIn, int *sOut, int buffersize, double samplerate)
{
   const int delta = (sIn >= *sOut) ? (sIn - *sOut) : (sIn + buffersize - *sOut);

#ifdef DEBUG_SOUND
   {
      char tmp[161];
      LARGE_INTEGER performance_count;
      QueryPerformanceCounter(&performance_count);

      sprintf(tmp, "snd clk: %llu in: %d out: %d size: %d delta %d", performance_count.QuadPart, sIn, *sOut, buffersize, delta);
      DebugSound(tmp);
   }
#endif

   if (delta > samplerate * 50 / 1000)
   {
      // Over 50ms delta and throttle didn't catch it fast enough.   Drop some samples, but not so
      // much that we have to restart from a zero buffer.
      *sOut = sIn - (int)(samplerate * 20 / 1000 + 0.5);
      if (*sOut < 0)
         *sOut += buffersize;

      SetThrottleAdj(0);
   }
   else if (delta > samplerate * 35 / 1000)
   {
      SetThrottleAdj(-4);
   }
   else if (delta > samplerate * 25 / 1000)
   {
      SetThrottleAdj(-1);
   }
   else if (delta < samplerate * 10 / 1000)
   {
      SetThrottleAdj(10);
   }
   else if (delta < samplerate * 20 / 1000)
   {
      SetThrottleAdj(2);
   }
   else
   {
      SetThrottleAdj(0);
   }
}

/*----------------------------------------------
/  Add a timer when building the machine driver
/-----------------------------------------------*/
void machine_add_timer(struct InternalMachineDriver *machine, void (*func)(int), double rate) {
  int ii;
  for (ii = 0; machine->pinmame.timers[ii].callback; ii++)
    ;
  machine->pinmame.timers[ii].callback = func;
  machine->pinmame.timers[ii].rate = rate;
}

/*---------------------------------------
/  Default machine driver for all games
/----------------------------------------*/
MACHINE_DRIVER_START(PinMAME)
  MDRV_VIDEO_ATTRIBUTES(VIDEO_TYPE_RASTER)
  MDRV_SCREEN_SIZE(CORE_SCREENX, CORE_SCREENY)
  MDRV_VISIBLE_AREA(0, CORE_SCREENX-1, 0, CORE_SCREENY-1)
  MDRV_PALETTE_INIT(core)
  MDRV_PALETTE_LENGTH(sizeof(core_palette)/sizeof(core_palette[0][0])/3)
  MDRV_FRAMES_PER_SECOND(60)
  MDRV_SWITCH_CONV(core_swSeq2m,core_m2swSeq)
  MDRV_LAMP_CONV(core_swSeq2m,core_m2swSeq)
  MDRV_MACHINE_INIT(core) MDRV_MACHINE_STOP(core)
  MDRV_VIDEO_UPDATE(core_gen)
MACHINE_DRIVER_END
