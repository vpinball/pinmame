/***********************************************/
/* PINMAME - Interface function (Input/Output) */
/***********************************************/
#include <stdarg.h>
#include <math.h>
#include "driver.h"
#include "sim.h"
#include "snd_cmd.h"
#include "mech.h"
#include "core.h"
#include "video.h"
#include "bulb.h"

#ifdef PROC_SUPPORT
 #include "p-roc/p-roc.h"
#endif

#if defined(VPINMAME) || defined(LIBPINMAME)
 #ifndef LIBPINMAME
  #ifndef WIN32_LEAN_AND_MEAN
  #define WIN32_LEAN_AND_MEAN
  #endif
  #ifndef _WIN32_WINNT
  #if _MSC_VER >= 1800
   // Windows 2000 _WIN32_WINNT_WIN2K
   #define _WIN32_WINNT 0x0500
  #elif _MSC_VER < 1600
   #define _WIN32_WINNT 0x0400
  #else
   #define _WIN32_WINNT 0x0403
  #endif
  #define WINVER _WIN32_WINNT
  #endif
  #include <Windows.h>
 #endif

 #include "../../ext/dmddevice/usbalphanumeric.h"

 UINT8  g_raw_dmdbuffer[DMD_MAXY*DMD_MAXX];
 UINT32 g_raw_colordmdbuffer[DMD_MAXY*DMD_MAXX];
 UINT32 g_raw_dmdx = ~0u;
 UINT32 g_raw_dmdy = ~0u;

 #ifdef LIBPINMAME
  extern int g_fDmdMode;
 #endif

 #ifdef VPINMAME
  static UINT8 old_g_raw_dmdbuffer[DMD_MAXY*DMD_MAXX];
 #endif

 static UINT8 has_DMD_Video = 0;

#define CORE_MAX_RAW_DMD_FRAMES 5
 static UINT8  raw_dmd_frames[CORE_MAX_RAW_DMD_FRAMES * DMD_MAXX*DMD_MAXY / 8];
 static UINT32 raw_dmd_frame_count = 0;

 UINT8 g_needs_DMD_update = 1;

 #ifdef VPINMAME
  UINT8 g_VPM_ignore_pwm_segments_update = 0; // workaround if both the VPM/external DMD is running AND the table script also renders/pulls the segment data
 #endif
#endif

/* stuff to test VPINMAME */
#if 0
#define VPINMAME
int g_fHandleKeyboard = 1, g_fHandleMechanics = 1, g_fMechSamples = 1;
void OnSolenoid(int nSolenoid, int IsActive) {}
void OnStateChange(int nChange) {}
UINT64 vp_getSolMask64(void) { return -1; }
int vp_getDip(int bank) { return 0; }
void vp_setDIP(int bank, int value) { }
#endif

#if defined(VPINMAME)
  extern char g_szGameName[256];
#endif

#if defined(VPINMAME) || defined(LIBPINMAME)
  #include "vpintf.h"
  extern int g_fHandleKeyboard, g_fHandleMechanics;
  extern char g_fShowWinDMD;
  extern char g_fShowPinDMD; /* pinDMD */
  extern int time_to_reset;  /* pinDMD */
  extern int g_fDumpFrames;
  extern void OnSolenoid(int nSolenoid, int IsActive);
  extern void OnStateChange(int nChange);
#else
  int g_fHandleKeyboard = 1;
  int g_fHandleMechanics = 0xff;
  #define OnSolenoid(nSolenoid, IsActive)
  #define OnStateChange(nChange)
  #define vp_getSolMask64() ((UINT64)(-1))
  #define vp_setDIP(x,y)
#endif

#ifdef LIBPINMAME
  extern void libpinmame_update_display(const int index, const struct core_dispLayout* p_layout, const void* p_data);
#endif

#ifndef LIBPINMAME
  #include "gts3.h"
  extern tGTS3locals GTS3locals;
#endif

#ifndef MIN
 #define MIN(x,y) ((x)<(y)?(x):(y))
#endif

INLINE UINT8 saturatedByte(float v)
{
  v *= 255.f;
  if(v < 0.f)
    v = 0.f;
  if(v > 255.f)
    v = 255.f;
  return (UINT8)v;
}

static void drawChar(struct mame_bitmap *bitmap, int row, int col, UINT16 seg_bits, int type, UINT8 dimming[16]);
static UINT32 core_initDisplaySize(const struct core_dispLayout *layout);
static VIDEO_UPDATE(core_status);

/*---------------------------
/  Global variables
/----------------------------*/
tPMoptions            pmoptions; /* PinMAME specific options */
core_tGlobals         coreGlobals;
volatile struct pinMachine *coreData = NULL;
const core_tGameData *core_gameData = NULL;  /* data about the running game */

/*---------------------
/  Global constants
/----------------------*/
const int core_bcd2seg7[16] = {
/* 0    1    2    3    4    5    6    7    8    9  */
  0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,0x7f,0x6f
#ifdef MAME_DEBUG
/* A    B    C    D    E */
 ,0x77,0x7c,0x39,0x5e,0x79
#endif /* MAME_DEBUG */
};
// including the 0x0a to 0x0e characters of a SN5446A type BCD-to-7-segment encoder
const int core_bcd2seg7e[16] = {
/* 0    1    2    3    4    5    6    7    8    9  */
  0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,0x7f,0x6f,
/* A    B    C    D    E */
#ifdef MAME_DEBUG
  0x77,0x7c,0x39,0x5e,0x79
#else /* display legible characters in debug mode only */
  0x58,0x4c,0x62,0x69,0x78
#endif /* MAME_DEBUG */
};
// missing top line for 6 and bottom line for 9 numbers (e.g. Atari)
const int core_bcd2seg7a[16] = {
/* 0    1    2    3    4    5    6    7    8    9  */
  0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7c,0x07,0x7f,0x67
#ifdef MAME_DEBUG
/* A    B    C    D    E */
 ,0x77,0x7c,0x39,0x5e,0x79
#endif /* MAME_DEBUG */
};
const int core_bcd2seg9[16] = {
/* 0    1     2    3    4    5    6    7    8    9  */
  0x3f,0x300,0x5b,0x4f,0x66,0x6d,0x7d,0x07,0x7f,0x6f
#ifdef MAME_DEBUG
/* A    B     C    D     E */
 ,0x77,0x34f,0x39,0x30f,0x79
#endif /* MAME_DEBUG */
};
// missing top line for 6 and bottom line for 9 numbers, and including the 0x0a to 0x0e characters (e.g. Gottlieb Sys80/a)
const int core_bcd2seg9a[16] = {
/* 0    1     2    3    4    5    6    7    8    9  */
  0x3f,0x300,0x5b,0x4f,0x66,0x6d,0x7c,0x07,0x7f,0x67,
#ifdef MAME_DEBUG
/* A    B     C    D     E */
  0x77,0x34f,0x39,0x30f,0x79
#else /* display legible characters in debug mode only */
/* A    B    C    D    E */
  0x58,0x4c,0x62,0x69,0x78
#endif /* MAME_DEBUG */
};

// patterns taken from Rockwell 10939 datasheet and adjusted to match regular 16 segments layout
const UINT16 core_ascii2seg16[] = {
  /* 0x00-0x07 */ 0x0000, 0x0000, 0x44BF, 0x2280, 0x08DB, 0x08CF, 0x08E6, 0x08ED, //   012345 with commas
  /* 0x08-0x0f */ 0x08FD, 0x0087, 0x08FF, 0x08EF, 0xC43F, 0xA200, 0x885B, 0x884F, // 67890123 with commas / dots
  /* 0x10-0x17 */ 0x8866, 0x886D, 0x887D, 0x8007, 0x887F, 0x886F, 0xC4BF, 0xA280, // 45678901 with dots / semicolons
  /* 0x18-0x1f */ 0x88DB, 0x88CF, 0x88E6, 0x88ED, 0x88FD, 0x8087, 0x88FF, 0x88EF, // 23456789 with semicolons
  /* 0x20-0x27 */ 0x0000, 0x0309, 0x0220, 0x2A4E, 0x2A6D, 0x6E65, 0x135D, 0x0400, //  !"#$%&'
  /* 0x28-0x2f */ 0x1400, 0x4100, 0x7F40, 0x2A40, 0x0080, 0x0840, 0x0008, 0x4400, // ()*+,-./
  /* 0x30-0x37 */ 0x443F, 0x2200, 0x085B, 0x084F, 0x0866, 0x086D, 0x087D, 0x0007, // 01234567
  /* 0x38-0x3f */ 0x087F, 0x086F, 0x0009, 0x4001, 0x4408, 0x0848, 0x1108, 0x2803, // 89:;<=>?
  /* 0x40-0x47 */ 0x205F, 0x0877, 0x2A0F, 0x0039, 0x220F, 0x0079, 0x0071, 0x083D, // @ABCDEFG
  /* 0x48-0x4f */ 0x0876, 0x2209, 0x001E, 0x1470, 0x0038, 0x0536, 0x1136, 0x003F, // HIJKLMNO
  /* 0x50-0x57 */ 0x0873, 0x103F, 0x1873, 0x086D, 0x2201, 0x003E, 0x4430, 0x5036, // PRQSTUVW
  /* 0x58-0x5f */ 0x5500, 0x2500, 0x4409, 0x0039, 0x1100, 0x000F, 0x5000, 0x0008, // XYZ[\]^_
  /* 0x60-0x67 */ 0x0001, 0x0001, 0x0002, 0x0004, 0x0008, 0x0008, 0x0010, 0x0020, // all segments, singular
  /* 0x68-0x6f */ 0x0200, 0x0400, 0x0800, 0x1000, 0x2000, 0x4000, 0x0040, 0x0100, // all segments, singular
  /* 0x70-0x77 */ 0x0001, 0x0001, 0x0003, 0x0007, 0x000F, 0x000F, 0x001F, 0x003F, // all segments, accumulating
  /* 0x78-0x7f */ 0x023F, 0x063F, 0x0E3F, 0x1E3F, 0x3E3F, 0x7E3F, 0x7E7F, 0x7F7F, // all segments, accumulating
};

// patterns taken from Rockwell 10939 datasheet and adjusted to match 16 segments layout with split top / bottom lines
const UINT16 core_ascii2seg16s[] = {
  /* 0x00-0x07 */ 0x0000, 0x0000, 0x44ff, 0x2200, 0x8877, 0x883f, 0x888c, 0x88bb, //   012345 with commas (no bits for these)
  /* 0x08-0x0f */ 0x88fb, 0x000f, 0x88ff, 0x88bf, 0x44ff, 0x2200, 0x8877, 0x883f, // 67890123 with commas / dots (no bits for these)
  /* 0x10-0x17 */ 0x888c, 0x88bb, 0x88fb, 0x000f, 0x88ff, 0x88bf, 0x44ff, 0x2200, // 45678901 with dots / semicolons (no bits for these)
  /* 0x18-0x1f */ 0x8877, 0x883f, 0x888c, 0x88bb, 0x88fb, 0x000f, 0x88ff, 0x88bf, // 23456789 with semicolons (no bits for these)
  /* 0x20-0x27 */ 0x0000, 0x0321, 0x0280, 0xaa3c, 0xaabb, 0xee99, 0x9379, 0x0400, //  !"#$%&'
  /* 0x28-0x2f */ 0x1400, 0x4100, 0xff00, 0xaa00, 0x4000, 0x8800, 0x0020, 0x4400, // ()*+,-./
  /* 0x30-0x37 */ 0x44ff, 0x2200, 0x8877, 0x883f, 0x888c, 0x88bb, 0x88fb, 0x000f, // 01234567
  /* 0x38-0x3f */ 0x88ff, 0x88bf, 0x0021, 0x4001, 0x4430, 0x8830, 0x1130, 0x2807, // 89:;<=>?
  /* 0x40-0x47 */ 0xa07f, 0x88cf, 0x2a3f, 0x00f3, 0x223f, 0x80f3, 0x80c3, 0x08fb, // @ABCDEFG
  /* 0x48-0x4f */ 0x88cc, 0x2233, 0x007c, 0x94c0, 0x00f0, 0x05cc, 0x11cc, 0x00ff, // HIJKLMNO
  /* 0x50-0x57 */ 0x88c7, 0x10ff, 0x98c7, 0x88bb, 0x2203, 0x00fc, 0x44c0, 0x50cc, // PRQSTUVW
  /* 0x58-0x5f */ 0x5500, 0x2500, 0x4433, 0x00e1, 0x1100, 0x001e, 0x5000, 0x0030, // XYZ[\]^_
  /* 0x60-0x67 */ 0x0001, 0x0002, 0x0004, 0x0008, 0x0010, 0x0020, 0x0040, 0x0080, // all segments, singular
  /* 0x68-0x6f */ 0x0200, 0x0400, 0x0800, 0x1000, 0x2000, 0x4000, 0x8000, 0x0100, // all segments, singular
  /* 0x70-0x77 */ 0x0001, 0x0003, 0x0007, 0x000f, 0x001f, 0x003f, 0x007f, 0x00ff, // all segments, accumulating
  /* 0x78-0x7f */ 0x02ff, 0x06ff, 0x0eff, 0x1eff, 0x3eff, 0x7eff, 0xfeff, 0xffff, // all segments, accumulating
};

#if !(defined(_M_ARM64) || defined(__aarch64__))
/* makes it easier to swap bits */
                              // 0  1  2  3  4  5  6  7  8  9 10,11,12,13,14,15
const UINT8 core_swapNyb[16] = { 0, 8, 4,12, 2,10, 6,14, 1, 9, 5,13, 3,11, 7,15};
#endif

/* Palette */
static const unsigned char core_palette[COL_COUNT+48+48+48][3] = {
{/*  0 */ 0x00,0x00,0x00}, /* Background */
/* -- DMD DOT COLORS-- */
{/*  1 */ 0x30,0x00,0x00}, /* "Black" Dot - DMD Background */
{/*  2 */ 0x00,0x00,0x00}, /* Intensity  33% - Filled in @ Run Time */
{/*  3 */ 0x00,0x00,0x00}, /* Intensity  66% - Filled in @ Run Time */
{/*  4 */ 0xff,0xe0,0x20}, /* Intensity 100% - Changed @ Run Time to match config vars */
/* -- PLAYFIELD LAMP COLORS -- */
{/*  5 */ 0x00,0x00,0x00}, /* Black */
{/*  6 */ 0xff,0xff,0xff}, /* White */
{/*  7 */ 0x40,0xff,0x00}, /* Green */
{/*  8 */ 0xff,0x00,0x00}, /* Red */
{/*  9 */ 0xff,0x80,0x00}, /* Orange */
{/* 10 */ 0xff,0xff,0x00}, /* Yellow */
{/* 11 */ 0x00,0x80,0xff}, /* Blue */
{/* 12 */ 0x9f,0x40,0xff}  /* Purple */
// Followed by 48 DMD (and UI-lamp) shades
// Followed by 48 DMD AA shades
// Followed by 48 Alphanum shades
};
#define DMD_PAL(x)  ((unsigned int)sizeof(core_palette)/3u - (48u+48u+48u) + (unsigned int)(x) * 47u / 255u)
#define LAMP_PAL(x) ((unsigned int)sizeof(core_palette)/3u - (48u+48u+48u) + (unsigned int)(x) * 47u / 255u) // (ab)use DMD shades
static UINT32 TRAFO_AA(const UINT32 x)
{
	return (x == 0 ? 0 : (x*(47-12)/255 + 12)); // off stays counted as off, otherwise trafo from 0..255 -> 12..47 to map the DMD luminance into the DMD AA shade world (as DMD AA also maps 0..perc0)
}
#define DMD_AA_PAL(x,m,d) ((unsigned int)sizeof(core_palette)/3u - (48u+48u) + (unsigned int)(x) * (m) / (d))
#define ALPHA_PAL(x) ((unsigned int)sizeof(core_palette)/3u - 48u + (unsigned int)(x) * 47u / 255u)

/*------------------------------
/  Display segment drawing data
/------------------------------*/
typedef UINT32 tSegRow[17];
typedef struct { int rows, cols; const tSegRow *segs; } tSegData;

static const tSegRow segSize1C[6][20] = { /* with commas */
{ /* alphanumeric display characters */
/*                       all        0001       0002       0004       0008       0010       0020       0040       0080       0100       0200       0400       0800       1000       2000       4000       8000 */
/*    11111111111  */{0x00555554,0x00555554,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/*   1133331333311 */{0x017fdff5,0x003fcff0,0x00000001,0x00000000,0x00000000,0x00000000,0x01000000,0x00000000,0x00000000,0x00400000,0x00001000,0x00000004,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/*   11    1   1 1 */{0x01401011,0x00000000,0x00000001,0x00000000,0x00000000,0x00000000,0x01000000,0x00000000,0x00000000,0x00400000,0x00001000,0x00000010,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/*  31 1  31  1 31 */{0x0d10d04d,0x00000000,0x0000000d,0x00000000,0x00000000,0x00000000,0x0d000000,0x00000000,0x00000000,0x00100000,0x0000d000,0x00000040,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/*  32 1  32  1 32 */{0x0e10e04e,0x00000000,0x0000000e,0x00000000,0x00000000,0x00000000,0x0e000000,0x00000000,0x00000000,0x00100000,0x0000e000,0x00000040,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/*  22  1 22 1  22 */{0x0a04a10a,0x00000000,0x0000000a,0x00000000,0x00000000,0x00000000,0x0a000000,0x00000000,0x00000000,0x00040000,0x0000a000,0x00000100,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/*  23  1 231   23 */{0x0b04b40b,0x00000000,0x0000000b,0x00000000,0x00000000,0x00000000,0x0b000000,0x00000000,0x00000000,0x00040000,0x0000b000,0x00000400,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/*  13   1131   13 */{0x07017407,0x00000000,0x00000007,0x00000000,0x00000000,0x00000000,0x07000000,0x00000000,0x00000000,0x00010000,0x00007000,0x00000400,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/*  1333311133331  */{0x07fd5ff4,0x00000000,0x00000004,0x00000000,0x00000000,0x00000000,0x04000000,0x03fc0000,0x00000000,0x00010000,0x00004000,0x00001000,0x00000ff0,0x00000000,0x00000000,0x00000000,0x00000000},
/*  3111113111113  */{0x0d55d55c,0x00000000,0x0000000c,0x0000000c,0x00000000,0x0c000000,0x0c000000,0x0155c000,0x00000000,0x0000c000,0x0000c000,0x0000c000,0x0000d550,0x0000c000,0x0000c000,0x0000c000,0x00000000},
/*  1333311133331  */{0x07fd5ff4,0x00000000,0x00000000,0x00000004,0x00000000,0x04000000,0x00000000,0x03fc0000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000ff0,0x00001000,0x00004000,0x00010000,0x00000000},
/* 31   1311   31  */{0x34075034,0x00000000,0x00000000,0x00000034,0x00000000,0x34000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00001000,0x00034000,0x00040000,0x00000000},
/* 32   132 1  32  */{0x38078438,0x00000000,0x00000000,0x00000038,0x00000000,0x38000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000400,0x00038000,0x00040000,0x00000000},
/* 22  1 22 1  22  */{0x28128428,0x00000000,0x00000000,0x00000028,0x00000000,0x28000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000400,0x00028000,0x00100000,0x00000000},
/* 23 1  23  1 23  */{0x2c42c12c,0x00000000,0x00000000,0x0000002c,0x00000000,0x2c000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000100,0x0002c000,0x00400000,0x00000000},
/* 13 1  13  1 13  */{0x1c41c11c,0x00000000,0x00000000,0x0000001c,0x00000000,0x1c000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000100,0x0001c000,0x00400000,0x00000000},
/* 1 1   1    11   */{0x11010050,0x00000000,0x00000000,0x00000010,0x00000000,0x10000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000040,0x00010000,0x01000000,0x00000000},
/* 113333133331132 */{0x17fdff5e,0x00000000,0x00000000,0x00000010,0x03fcff00,0x10000000,0x00000000,0x00000000,0x0000000e,0x00000000,0x00000000,0x00000000,0x00000000,0x00000040,0x00010000,0x04000000,0x0000000e},
/*  11111111111 31 */{0x0555554d,0x00000000,0x00000000,0x00000000,0x05555540,0x00000000,0x00000000,0x00000000,0x0000000d,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x0000000d},
/*              1  */{0x00000004,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000004,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000}
},{ /* 8 segment LED characters */
/*    11111111111  */{0x00555554,0x00555554,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/*   1333333333331 */{0x01fffffd,0x00fffffc,0x00000001,0x00000000,0x00000000,0x00000000,0x01000000,0x00000000,0x00000000},
/*   1           1 */{0x01000001,0x00000000,0x00000001,0x00000000,0x00000000,0x00000000,0x01000000,0x00000000,0x00000000},
/*  31          31 */{0x0d00000d,0x00000000,0x0000000d,0x00000000,0x00000000,0x00000000,0x0d000000,0x00000000,0x00000000},
/*  32          32 */{0x0e00000e,0x00000000,0x0000000e,0x00000000,0x00000000,0x00000000,0x0e000000,0x00000000,0x00000000},
/*  22          22 */{0x0a00000a,0x00000000,0x0000000a,0x00000000,0x00000000,0x00000000,0x0a000000,0x00000000,0x00000000},
/*  23          23 */{0x0b00000b,0x00000000,0x0000000b,0x00000000,0x00000000,0x00000000,0x0b000000,0x00000000,0x00000000},
/*  13          13 */{0x07000007,0x00000000,0x00000007,0x00000000,0x00000000,0x00000000,0x07000000,0x00000000,0x00000000},
/*  1333333333331  */{0x07fffff4,0x00000000,0x00000004,0x00000000,0x00000000,0x00000000,0x04000000,0x03fffff0,0x00000000},
/*  3111111111113  */{0x0d55555c,0x00000000,0x0000000c,0x0000000c,0x00000000,0x0c000000,0x0c000000,0x0d55555c,0x00000000},
/*  1333333333331  */{0x07fffff4,0x00000000,0x00000000,0x00000004,0x00000000,0x04000000,0x00000000,0x03fffff0,0x00000000},
/* 31          31  */{0x34000034,0x00000000,0x00000000,0x00000034,0x00000000,0x34000000,0x00000000,0x00000000,0x00000000},
/* 32          32  */{0x38000038,0x00000000,0x00000000,0x00000038,0x00000000,0x38000000,0x00000000,0x00000000,0x00000000},
/* 22          22  */{0x28000028,0x00000000,0x00000000,0x00000028,0x00000000,0x28000000,0x00000000,0x00000000,0x00000000},
/* 23          23  */{0x2c00002c,0x00000000,0x00000000,0x0000002c,0x00000000,0x2c000000,0x00000000,0x00000000,0x00000000},
/* 13          13  */{0x1c00001c,0x00000000,0x00000000,0x0000001c,0x00000000,0x1c000000,0x00000000,0x00000000,0x00000000},
/* 1           1   */{0x10000010,0x00000000,0x00000000,0x00000010,0x00000000,0x10000000,0x00000000,0x00000000,0x00000000},
/* 133333333333132 */{0x1fffffde,0x00000000,0x00000000,0x00000010,0x0fffffc0,0x10000000,0x00000000,0x00000000,0x0000000e},
/*  11111111111 31 */{0x0555554d,0x00000000,0x00000000,0x00000000,0x05555540,0x00000000,0x00000000,0x00000000,0x0000000d},
/*              1  */{0x00000004,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000004}
},{ /* 10 segment LED characters */
/*    11111111111  */{0x00555554,0x00555554,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/*   1333331333331 */{0x01ffdffd,0x00ffcffc,0x00000001,0x00000000,0x00000000,0x00000000,0x01000000,0x00000000,0x00000000,0x00001000,0x00000000},
/*   1     1     1 */{0x01001001,0x00000000,0x00000001,0x00000000,0x00000000,0x00000000,0x01000000,0x00000000,0x00000000,0x00001000,0x00000000},
/*  31    31    31 */{0x0d00d00d,0x00000000,0x0000000d,0x00000000,0x00000000,0x00000000,0x0d000000,0x00000000,0x00000000,0x0000d000,0x00000000},
/*  32    32    32 */{0x0e00e00e,0x00000000,0x0000000e,0x00000000,0x00000000,0x00000000,0x0e000000,0x00000000,0x00000000,0x0000e000,0x00000000},
/*  22    22    22 */{0x0a00a00a,0x00000000,0x0000000a,0x00000000,0x00000000,0x00000000,0x0a000000,0x00000000,0x00000000,0x0000a000,0x00000000},
/*  23    23    23 */{0x0b00b00b,0x00000000,0x0000000b,0x00000000,0x00000000,0x00000000,0x0b000000,0x00000000,0x00000000,0x0000b000,0x00000000},
/*  13    13    13 */{0x07007007,0x00000000,0x00000007,0x00000000,0x00000000,0x00000000,0x07000000,0x00000000,0x00000000,0x00007000,0x00000000},
/*  1333331333331  */{0x07ff7ff4,0x00000000,0x00000004,0x00000000,0x00000000,0x00000000,0x04000000,0x03ff3ff0,0x00000000,0x00004000,0x00000000},
/*  3111111111113  */{0x0d55555c,0x00000000,0x0000000c,0x0000000c,0x00000000,0x0c000000,0x0c000000,0x0d55555c,0x00000000,0x0000c000,0x0000c000},
/*  1333331333331  */{0x07ff7ff4,0x00000000,0x00000000,0x00000004,0x00000000,0x04000000,0x00000000,0x03ff3ff0,0x00000000,0x00000000,0x00004000},
/* 31    31    31  */{0x34034034,0x00000000,0x00000000,0x00000034,0x00000000,0x34000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00034000},
/* 32    32    32  */{0x38038038,0x00000000,0x00000000,0x00000038,0x00000000,0x38000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00038000},
/* 22    22    22  */{0x28028028,0x00000000,0x00000000,0x00000028,0x00000000,0x28000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00028000},
/* 23    23    23  */{0x2c02c02c,0x00000000,0x00000000,0x0000002c,0x00000000,0x2c000000,0x00000000,0x00000000,0x00000000,0x00000000,0x0002c000},
/* 13    13    13  */{0x1c01c01c,0x00000000,0x00000000,0x0000001c,0x00000000,0x1c000000,0x00000000,0x00000000,0x00000000,0x00000000,0x0001c000},
/* 1     1     1   */{0x10010010,0x00000000,0x00000000,0x00000010,0x00000000,0x10000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00010000},
/* 133333133333132 */{0x1ffdffde,0x00000000,0x00000000,0x00000010,0x0ffcffc0,0x10000000,0x00000000,0x00000000,0x0000000e,0x00000000,0x00010000},
/*  11111111111 31 */{0x0555554d,0x00000000,0x00000000,0x00000000,0x05555540,0x00000000,0x00000000,0x00000000,0x0000000d,0x00000000,0x00000000},
/*              1  */{0x00000004,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000004,0x00000000,0x00000000}
},{ /* alphanumeric display characters (reversed comma with period) */
/*    11111111111  */{0x00555554,0x00555554,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/*   1133331333311 */{0x017fdff5,0x003fcff0,0x00000001,0x00000000,0x00000000,0x00000000,0x01000000,0x00000000,0x00000000,0x00400000,0x00001000,0x00000004,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/*   11    1   1 1 */{0x01401011,0x00000000,0x00000001,0x00000000,0x00000000,0x00000000,0x01000000,0x00000000,0x00000000,0x00400000,0x00001000,0x00000010,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/*  31 1  31  1 31 */{0x0d10d04d,0x00000000,0x0000000d,0x00000000,0x00000000,0x00000000,0x0d000000,0x00000000,0x00000000,0x00100000,0x0000d000,0x00000040,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/*  32 1  32  1 32 */{0x0e10e04e,0x00000000,0x0000000e,0x00000000,0x00000000,0x00000000,0x0e000000,0x00000000,0x00000000,0x00100000,0x0000e000,0x00000040,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/*  22  1 22 1  22 */{0x0a04a10a,0x00000000,0x0000000a,0x00000000,0x00000000,0x00000000,0x0a000000,0x00000000,0x00000000,0x00040000,0x0000a000,0x00000100,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/*  23  1 231   23 */{0x0b04b40b,0x00000000,0x0000000b,0x00000000,0x00000000,0x00000000,0x0b000000,0x00000000,0x00000000,0x00040000,0x0000b000,0x00000400,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/*  13   1131   13 */{0x07017407,0x00000000,0x00000007,0x00000000,0x00000000,0x00000000,0x07000000,0x00000000,0x00000000,0x00010000,0x00007000,0x00000400,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/*  1333311133331  */{0x07fd5ff4,0x00000000,0x00000004,0x00000000,0x00000000,0x00000000,0x04000000,0x03fc0000,0x00000000,0x00010000,0x00004000,0x00001000,0x00000ff0,0x00000000,0x00000000,0x00000000,0x00000000},
/*  3111113111113  */{0x0d55d55c,0x00000000,0x0000000c,0x0000000c,0x00000000,0x0c000000,0x0c000000,0x0155c000,0x00000000,0x0000c000,0x0000c000,0x0000c000,0x0000d550,0x0000c000,0x0000c000,0x0000c000,0x00000000},
/*  1333311133331  */{0x07fd5ff4,0x00000000,0x00000000,0x00000004,0x00000000,0x04000000,0x00000000,0x03fc0000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000ff0,0x00001000,0x00004000,0x00010000,0x00000000},
/* 31   1311   31  */{0x34075034,0x00000000,0x00000000,0x00000034,0x00000000,0x34000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00001000,0x00034000,0x00040000,0x00000000},
/* 32   132 1  32  */{0x38078438,0x00000000,0x00000000,0x00000038,0x00000000,0x38000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000400,0x00038000,0x00040000,0x00000000},
/* 22  1 22 1  22  */{0x28128428,0x00000000,0x00000000,0x00000028,0x00000000,0x28000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000400,0x00028000,0x00100000,0x00000000},
/* 23 1  23  1 23  */{0x2c42c12c,0x00000000,0x00000000,0x0000002c,0x00000000,0x2c000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000100,0x0002c000,0x00400000,0x00000000},
/* 13 1  13  1 13  */{0x1c41c11c,0x00000000,0x00000000,0x0000001c,0x00000000,0x1c000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000100,0x0001c000,0x00400000,0x00000000},
/* 1 1   1    11   */{0x11010050,0x00000000,0x00000000,0x00000010,0x00000000,0x10000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000040,0x00010000,0x01000000,0x00000000},
/* 113333133331132 */{0x17fdff5e,0x00000000,0x00000000,0x00000010,0x03fcff00,0x10000000,0x00000000,0x00000000,0x0000000e,0x00000000,0x00000000,0x00000000,0x00000000,0x00000040,0x00010000,0x04000000,0x0000000e},
/*  11111111111 31 */{0x0555554d,0x00000000,0x00000000,0x00000000,0x05555540,0x00000000,0x00000000,0x00000000,0x0000000d,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x0000000d},
/*              1  */{0x00000004,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000004}
},{ /* 8 segment LED characters with dots instead of commas */
/*    11111111111  */{0x00555554,0x00555554,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/*   1333333333331 */{0x01fffffd,0x00fffffc,0x00000001,0x00000000,0x00000000,0x00000000,0x01000000,0x00000000,0x00000000},
/*   1           1 */{0x01000001,0x00000000,0x00000001,0x00000000,0x00000000,0x00000000,0x01000000,0x00000000,0x00000000},
/*  31          31 */{0x0d00000d,0x00000000,0x0000000d,0x00000000,0x00000000,0x00000000,0x0d000000,0x00000000,0x00000000},
/*  32          32 */{0x0e00000e,0x00000000,0x0000000e,0x00000000,0x00000000,0x00000000,0x0e000000,0x00000000,0x00000000},
/*  22          22 */{0x0a00000a,0x00000000,0x0000000a,0x00000000,0x00000000,0x00000000,0x0a000000,0x00000000,0x00000000},
/*  23          23 */{0x0b00000b,0x00000000,0x0000000b,0x00000000,0x00000000,0x00000000,0x0b000000,0x00000000,0x00000000},
/*  13          13 */{0x07000007,0x00000000,0x00000007,0x00000000,0x00000000,0x00000000,0x07000000,0x00000000,0x00000000},
/*  1333333333331  */{0x07fffff4,0x00000000,0x00000004,0x00000000,0x00000000,0x00000000,0x04000000,0x03fffff0,0x00000000},
/*  3111111111113  */{0x0d55555c,0x00000000,0x0000000c,0x0000000c,0x00000000,0x0c000000,0x0c000000,0x0d55555c,0x00000000},
/*  1333333333331  */{0x07fffff4,0x00000000,0x00000000,0x00000004,0x00000000,0x04000000,0x00000000,0x03fffff0,0x00000000},
/* 31          31  */{0x34000034,0x00000000,0x00000000,0x00000034,0x00000000,0x34000000,0x00000000,0x00000000,0x00000000},
/* 32          32  */{0x38000038,0x00000000,0x00000000,0x00000038,0x00000000,0x38000000,0x00000000,0x00000000,0x00000000},
/* 22          22  */{0x28000028,0x00000000,0x00000000,0x00000028,0x00000000,0x28000000,0x00000000,0x00000000,0x00000000},
/* 23          23  */{0x2c00002c,0x00000000,0x00000000,0x0000002c,0x00000000,0x2c000000,0x00000000,0x00000000,0x00000000},
/* 13          13  */{0x1c00001c,0x00000000,0x00000000,0x0000001c,0x00000000,0x1c000000,0x00000000,0x00000000,0x00000000},
/* 1           1   */{0x10000010,0x00000000,0x00000000,0x00000010,0x00000000,0x10000000,0x00000000,0x00000000,0x00000000},
/* 133333333333132 */{0x1fffffde,0x00000000,0x00000000,0x00000010,0x0fffffc0,0x10000000,0x00000000,0x00000000,0x0000000e},
/*  11111111111 31 */{0x0555554d,0x00000000,0x00000000,0x00000000,0x05555540,0x00000000,0x00000000,0x00000000,0x0000000d},
/*                 */{0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000}
},{ /* alphanumeric display characters (period only) */
/*    11111111111  */{0x00555554,0x00555554,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/*   1133331333311 */{0x017fdff5,0x003fcff0,0x00000001,0x00000000,0x00000000,0x00000000,0x01000000,0x00000000,0x00000000,0x00400000,0x00001000,0x00000004,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/*   11    1   1 1 */{0x01401011,0x00000000,0x00000001,0x00000000,0x00000000,0x00000000,0x01000000,0x00000000,0x00000000,0x00400000,0x00001000,0x00000010,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/*  31 1  31  1 31 */{0x0d10d04d,0x00000000,0x0000000d,0x00000000,0x00000000,0x00000000,0x0d000000,0x00000000,0x00000000,0x00100000,0x0000d000,0x00000040,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/*  32 1  32  1 32 */{0x0e10e04e,0x00000000,0x0000000e,0x00000000,0x00000000,0x00000000,0x0e000000,0x00000000,0x00000000,0x00100000,0x0000e000,0x00000040,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/*  22  1 22 1  22 */{0x0a04a10a,0x00000000,0x0000000a,0x00000000,0x00000000,0x00000000,0x0a000000,0x00000000,0x00000000,0x00040000,0x0000a000,0x00000100,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/*  23  1 231   23 */{0x0b04b40b,0x00000000,0x0000000b,0x00000000,0x00000000,0x00000000,0x0b000000,0x00000000,0x00000000,0x00040000,0x0000b000,0x00000400,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/*  13   1131   13 */{0x07017407,0x00000000,0x00000007,0x00000000,0x00000000,0x00000000,0x07000000,0x00000000,0x00000000,0x00010000,0x00007000,0x00000400,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/*  1333311133331  */{0x07fd5ff4,0x00000000,0x00000004,0x00000000,0x00000000,0x00000000,0x04000000,0x03fc0000,0x00000000,0x00010000,0x00004000,0x00001000,0x00000ff0,0x00000000,0x00000000,0x00000000,0x00000000},
/*  3111113111113  */{0x0d55d55c,0x00000000,0x0000000c,0x0000000c,0x00000000,0x0c000000,0x0c000000,0x0155c000,0x00000000,0x0000c000,0x0000c000,0x0000c000,0x0000d550,0x0000c000,0x0000c000,0x0000c000,0x00000000},
/*  1333311133331  */{0x07fd5ff4,0x00000000,0x00000000,0x00000004,0x00000000,0x04000000,0x00000000,0x03fc0000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000ff0,0x00001000,0x00004000,0x00010000,0x00000000},
/* 31   1311   31  */{0x34075034,0x00000000,0x00000000,0x00000034,0x00000000,0x34000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00001000,0x00034000,0x00040000,0x00000000},
/* 32   132 1  32  */{0x38078438,0x00000000,0x00000000,0x00000038,0x00000000,0x38000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000400,0x00038000,0x00040000,0x00000000},
/* 22  1 22 1  22  */{0x28128428,0x00000000,0x00000000,0x00000028,0x00000000,0x28000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000400,0x00028000,0x00100000,0x00000000},
/* 23 1  23  1 23  */{0x2c42c12c,0x00000000,0x00000000,0x0000002c,0x00000000,0x2c000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000100,0x0002c000,0x00400000,0x00000000},
/* 13 1  13  1 13  */{0x1c41c11c,0x00000000,0x00000000,0x0000001c,0x00000000,0x1c000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000100,0x0001c000,0x00400000,0x00000000},
/* 1 1   1    11   */{0x11010050,0x00000000,0x00000000,0x00000010,0x00000000,0x10000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000040,0x00010000,0x01000000,0x00000000},
/* 113333133331132 */{0x17fdff5e,0x00000000,0x00000000,0x00000010,0x03fcff00,0x10000000,0x00000000,0x00000000,0x0000000e,0x00000000,0x00000000,0x00000000,0x00000000,0x00000040,0x00010000,0x04000000,0x0000000e},
/*  11111111111 31 */{0x0555554d,0x00000000,0x00000000,0x00000000,0x05555540,0x00000000,0x00000000,0x00000000,0x0000000d,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x0000000d},
/*                 */{0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000}
}};
static const tSegRow segSize1[3][20] = { /* without commas */
{ /* alphanumeric display characters */
/*                       all        0001       0002       0004       0008       0010       0020       0040       0080       0100       0200       0400       0800       1000       2000       4000 */
/*    11111111111  */{0x00555554,0x00555554,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/*   1133331333311 */{0x017fdff5,0x003fcff0,0x00000001,0x00000000,0x00000000,0x00000000,0x01000000,0x00000000,0x00000000,0x00400000,0x00001000,0x00000004,0x00000000,0x00000000,0x00000000,0x00000000},
/*   11    1   1 1 */{0x01401011,0x00000000,0x00000001,0x00000000,0x00000000,0x00000000,0x01000000,0x00000000,0x00000000,0x00400000,0x00001000,0x00000010,0x00000000,0x00000000,0x00000000,0x00000000},
/*  31 1  31  1 31 */{0x0d10d04d,0x00000000,0x0000000d,0x00000000,0x00000000,0x00000000,0x0d000000,0x00000000,0x00000000,0x00100000,0x0000d000,0x00000040,0x00000000,0x00000000,0x00000000,0x00000000},
/*  32 1  32  1 32 */{0x0e10e04e,0x00000000,0x0000000e,0x00000000,0x00000000,0x00000000,0x0e000000,0x00000000,0x00000000,0x00100000,0x0000e000,0x00000040,0x00000000,0x00000000,0x00000000,0x00000000},
/*  22  1 22 1  22 */{0x0a04a10a,0x00000000,0x0000000a,0x00000000,0x00000000,0x00000000,0x0a000000,0x00000000,0x00000000,0x00040000,0x0000a000,0x00000100,0x00000000,0x00000000,0x00000000,0x00000000},
/*  23  1 231   23 */{0x0b04b40b,0x00000000,0x0000000b,0x00000000,0x00000000,0x00000000,0x0b000000,0x00000000,0x00000000,0x00040000,0x0000b000,0x00000400,0x00000000,0x00000000,0x00000000,0x00000000},
/*  13   1131   13 */{0x07017407,0x00000000,0x00000007,0x00000000,0x00000000,0x00000000,0x07000000,0x00000000,0x00000000,0x00010000,0x00007000,0x00000400,0x00000000,0x00000000,0x00000000,0x00000000},
/*  1333311133331  */{0x07fd5ff4,0x00000000,0x00000004,0x00000000,0x00000000,0x00000000,0x04000000,0x03fc0000,0x00000000,0x00010000,0x00004000,0x00001000,0x00000ff0,0x00000000,0x00000000,0x00000000},
/*  3111113111113  */{0x0d55d55c,0x00000000,0x0000000c,0x0000000c,0x00000000,0x0c000000,0x0c000000,0x0155c000,0x00000000,0x0000c000,0x0000c000,0x0000c000,0x0000d550,0x0000c000,0x0000c000,0x0000c000},
/*  1333311133331  */{0x07fd5ff4,0x00000000,0x00000000,0x00000004,0x00000000,0x04000000,0x00000000,0x03fc0000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000ff0,0x00001000,0x00004000,0x00010000},
/* 31   1311   31  */{0x34075034,0x00000000,0x00000000,0x00000034,0x00000000,0x34000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00001000,0x00034000,0x00040000},
/* 32   132 1  32  */{0x38078438,0x00000000,0x00000000,0x00000038,0x00000000,0x38000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000400,0x00038000,0x00040000},
/* 22  1 22 1  22  */{0x28128428,0x00000000,0x00000000,0x00000028,0x00000000,0x28000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000400,0x00028000,0x00100000},
/* 23 1  23  1 23  */{0x2c42c12c,0x00000000,0x00000000,0x0000002c,0x00000000,0x2c000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000100,0x0002c000,0x00400000},
/* 13 1  13  1 13  */{0x1c41c11c,0x00000000,0x00000000,0x0000001c,0x00000000,0x1c000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000100,0x0001c000,0x00400000},
/* 1 1   1    11   */{0x11010050,0x00000000,0x00000000,0x00000010,0x00000000,0x10000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000040,0x00010000,0x01000000},
/* 1133331333311   */{0x17fdff50,0x00000000,0x00000000,0x00000010,0x03fcff00,0x10000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000040,0x00010000,0x04000000},
/*  11111111111    */{0x05555540,0x00000000,0x00000000,0x00000000,0x05555540,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/*                 */{0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000}
},{ /* 7 segment LED characters */
/*    11111111111  */{0x00555554,0x00555554,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/*   1333333333331 */{0x01fffffd,0x00fffffc,0x00000001,0x00000000,0x00000000,0x00000000,0x01000000,0x00000000},
/*   1           1 */{0x01000001,0x00000000,0x00000001,0x00000000,0x00000000,0x00000000,0x01000000,0x00000000},
/*  31          31 */{0x0d00000d,0x00000000,0x0000000d,0x00000000,0x00000000,0x00000000,0x0d000000,0x00000000},
/*  32          32 */{0x0e00000e,0x00000000,0x0000000e,0x00000000,0x00000000,0x00000000,0x0e000000,0x00000000},
/*  22          22 */{0x0a00000a,0x00000000,0x0000000a,0x00000000,0x00000000,0x00000000,0x0a000000,0x00000000},
/*  23          23 */{0x0b00000b,0x00000000,0x0000000b,0x00000000,0x00000000,0x00000000,0x0b000000,0x00000000},
/*  13          13 */{0x07000007,0x00000000,0x00000007,0x00000000,0x00000000,0x00000000,0x07000000,0x00000000},
/*  1333333333331  */{0x07fffff4,0x00000000,0x00000004,0x00000000,0x00000000,0x00000000,0x04000000,0x03fffff0},
/*  3111111111113  */{0x0d55555c,0x00000000,0x0000000c,0x0000000c,0x00000000,0x0c000000,0x0c000000,0x0d55555c},
/*  1333333333331  */{0x07fffff4,0x00000000,0x00000000,0x00000004,0x00000000,0x04000000,0x00000000,0x03fffff0},
/* 31          31  */{0x34000034,0x00000000,0x00000000,0x00000034,0x00000000,0x34000000,0x00000000,0x00000000},
/* 32          32  */{0x38000038,0x00000000,0x00000000,0x00000038,0x00000000,0x38000000,0x00000000,0x00000000},
/* 22          22  */{0x28000028,0x00000000,0x00000000,0x00000028,0x00000000,0x28000000,0x00000000,0x00000000},
/* 23          23  */{0x2c00002c,0x00000000,0x00000000,0x0000002c,0x00000000,0x2c000000,0x00000000,0x00000000},
/* 13          13  */{0x1c00001c,0x00000000,0x00000000,0x0000001c,0x00000000,0x1c000000,0x00000000,0x00000000},
/* 1           1   */{0x10000010,0x00000000,0x00000000,0x00000010,0x00000000,0x10000000,0x00000000,0x00000000},
/* 1333333333331   */{0x1fffffd0,0x00000000,0x00000000,0x00000010,0x0fffffc0,0x10000000,0x00000000,0x00000000},
/*  11111111111    */{0x05555540,0x00000000,0x00000000,0x00000000,0x05555540,0x00000000,0x00000000,0x00000000},
/*                 */{0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000}
},{ /* 9 segment LED characters */
/*    11111111111  */{0x00555554,0x00555554,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/*   1333331333331 */{0x01ffdffd,0x00ffcffc,0x00000001,0x00000000,0x00000000,0x00000000,0x01000000,0x00000000,0x00000000,0x00001000,0x00000000},
/*   1     1     1 */{0x01001001,0x00000000,0x00000001,0x00000000,0x00000000,0x00000000,0x01000000,0x00000000,0x00000000,0x00001000,0x00000000},
/*  31    31    31 */{0x0d00d00d,0x00000000,0x0000000d,0x00000000,0x00000000,0x00000000,0x0d000000,0x00000000,0x00000000,0x0000d000,0x00000000},
/*  32    32    32 */{0x0e00e00e,0x00000000,0x0000000e,0x00000000,0x00000000,0x00000000,0x0e000000,0x00000000,0x00000000,0x0000e000,0x00000000},
/*  22    22    22 */{0x0a00a00a,0x00000000,0x0000000a,0x00000000,0x00000000,0x00000000,0x0a000000,0x00000000,0x00000000,0x0000a000,0x00000000},
/*  23    23    23 */{0x0b00b00b,0x00000000,0x0000000b,0x00000000,0x00000000,0x00000000,0x0b000000,0x00000000,0x00000000,0x0000b000,0x00000000},
/*  13    13    13 */{0x07007007,0x00000000,0x00000007,0x00000000,0x00000000,0x00000000,0x07000000,0x00000000,0x00000000,0x00007000,0x00000000},
/*  1333331333331  */{0x07ff7ff4,0x00000000,0x00000004,0x00000000,0x00000000,0x00000000,0x04000000,0x03ff3ff0,0x00000000,0x00004000,0x00000000},
/*  3111111111113  */{0x0d55555c,0x00000000,0x0000000c,0x0000000c,0x00000000,0x0c000000,0x0c000000,0x0d55555c,0x00000000,0x0000c000,0x0000c000},
/*  1333331333331  */{0x07ff7ff4,0x00000000,0x00000000,0x00000004,0x00000000,0x04000000,0x00000000,0x03ff3ff0,0x00000000,0x00000000,0x00004000},
/* 31    31    31  */{0x34034034,0x00000000,0x00000000,0x00000034,0x00000000,0x34000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00034000},
/* 32    32    32  */{0x38038038,0x00000000,0x00000000,0x00000038,0x00000000,0x38000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00038000},
/* 22    22    22  */{0x28028028,0x00000000,0x00000000,0x00000028,0x00000000,0x28000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00028000},
/* 23    23    23  */{0x2c02c02c,0x00000000,0x00000000,0x0000002c,0x00000000,0x2c000000,0x00000000,0x00000000,0x00000000,0x00000000,0x0002c000},
/* 13    13    13  */{0x1c01c01c,0x00000000,0x00000000,0x0000001c,0x00000000,0x1c000000,0x00000000,0x00000000,0x00000000,0x00000000,0x0001c000},
/* 1     1     1   */{0x10010010,0x00000000,0x00000000,0x00000010,0x00000000,0x10000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00010000},
/* 1333331333331   */{0x1ffdffd0,0x00000000,0x00000000,0x00000010,0x0ffcffc0,0x10000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00010000},
/*  11111111111    */{0x05555540,0x00000000,0x00000000,0x00000000,0x05555540,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/*                 */{0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000}
}};
static const tSegRow segSize2C[6][12] = { /* with commas */
{ /* alphanumeric display characters */
/*                   all        0001       0002       0004       0008       0010       0020       0040       0080       0100       0200       0400       0800       1000       2000       4000       8000 */
/*  xxxxxxx    */{0x05554000,0x05554000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/* xx  x  xx   */{0x14105000,0x00000000,0x00001000,0x00000000,0x00000000,0x00000000,0x10000000,0x00000000,0x00000000,0x04000000,0x00100000,0x00004000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/* x x x x x   */{0x11111000,0x00000000,0x00001000,0x00000000,0x00000000,0x00000000,0x10000000,0x00000000,0x00000000,0x01000000,0x00100000,0x00010000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/* x x x x x   */{0x11111000,0x00000000,0x00001000,0x00000000,0x00000000,0x00000000,0x10000000,0x00000000,0x00000000,0x01000000,0x00100000,0x00010000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/* x  xxx  x   */{0x10541000,0x00000000,0x00001000,0x00000000,0x00000000,0x00000000,0x10000000,0x00000000,0x00000000,0x00400000,0x00100000,0x00040000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/*  xxx xxx    */{0x05454000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x05400000,0x00000000,0x00000000,0x00000000,0x00000000,0x00054000,0x00000000,0x00000000,0x00000000,0x00000000},
/* x  xxx  x   */{0x10541000,0x00000000,0x00000000,0x00001000,0x00000000,0x10000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00040000,0x00100000,0x00400000,0x00000000},
/* x x x x x   */{0x11111000,0x00000000,0x00000000,0x00001000,0x00000000,0x10000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00010000,0x00100000,0x01000000,0x00000000},
/* x x x x x   */{0x11111000,0x00000000,0x00000000,0x00001000,0x00000000,0x10000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00010000,0x00100000,0x01000000,0x00000000},
/* xx  x  xx x */{0x14105100,0x00000000,0x00000000,0x00001000,0x00000000,0x10000000,0x00000000,0x00000000,0x00000100,0x00000000,0x00000000,0x00000000,0x00000000,0x00004000,0x00100000,0x04000000,0x00000000},
/*  xxxxxxx  x */{0x05554100,0x00000000,0x00000000,0x00000000,0x05554000,0x00000000,0x00000000,0x00000000,0x00000100,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000100},
/*          x  */{0x00000400,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000400,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000}
},{ /* 8 segment LED characters */
/*  xxxxxxx    */{0x05554000,0x05554000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/* x       x   */{0x10001000,0x00000000,0x00001000,0x00000000,0x00000000,0x00000000,0x10000000,0x00000000,0x00000000},
/* x       x   */{0x10001000,0x00000000,0x00001000,0x00000000,0x00000000,0x00000000,0x10000000,0x00000000,0x00000000},
/* x       x   */{0x10001000,0x00000000,0x00001000,0x00000000,0x00000000,0x00000000,0x10000000,0x00000000,0x00000000},
/* x       x   */{0x10001000,0x00000000,0x00001000,0x00000000,0x00000000,0x00000000,0x10000000,0x00000000,0x00000000},
/*  xxxxxxx    */{0x05554000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x05554000,0x00000000},
/* x       x   */{0x10001000,0x00000000,0x00000000,0x00001000,0x00000000,0x10000000,0x00000000,0x00000000,0x00000000},
/* x       x   */{0x10001000,0x00000000,0x00000000,0x00001000,0x00000000,0x10000000,0x00000000,0x00000000,0x00000000},
/* x       x   */{0x10001000,0x00000000,0x00000000,0x00001000,0x00000000,0x10000000,0x00000000,0x00000000,0x00000000},
/* x       x x */{0x10001100,0x00000000,0x00000000,0x00001000,0x00000000,0x10000000,0x00000000,0x00000000,0x00000100},
/*  xxxxxxx  x */{0x05554100,0x00000000,0x00000000,0x00000000,0x05554000,0x00000000,0x00000000,0x00000000,0x00000100},
/*          x  */{0x00000400,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000400}
},{ /* 10 segment LED characters */
/*  xxxxxxx    */{0x05554000,0x05554000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/* x   x   x   */{0x10101000,0x00000000,0x00001000,0x00000000,0x00000000,0x00000000,0x10000000,0x00000000,0x00000000,0x00100000,0x00000000},
/* x   x   x   */{0x10101000,0x00000000,0x00001000,0x00000000,0x00000000,0x00000000,0x10000000,0x00000000,0x00000000,0x00100000,0x00000000},
/* x   x   x   */{0x10101000,0x00000000,0x00001000,0x00000000,0x00000000,0x00000000,0x10000000,0x00000000,0x00000000,0x00100000,0x00000000},
/* x   x   x   */{0x10101000,0x00000000,0x00001000,0x00000000,0x00000000,0x00000000,0x10000000,0x00000000,0x00000000,0x00100000,0x00000000},
/*  xxxxxxx    */{0x05554000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x05554000,0x00000000,0x00000000,0x00000000},
/* x   x   x   */{0x10101000,0x00000000,0x00000000,0x00001000,0x00000000,0x10000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00100000},
/* x   x   x   */{0x10101000,0x00000000,0x00000000,0x00001000,0x00000000,0x10000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00100000},
/* x   x   x   */{0x10101000,0x00000000,0x00000000,0x00001000,0x00000000,0x10000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00100000},
/* x   x   x x */{0x10101100,0x00000000,0x00000000,0x00001000,0x00000000,0x10000000,0x00000000,0x00000000,0x00000100,0x00000000,0x00100000},
/*  xxxxxxx  x */{0x05554100,0x00000000,0x00000000,0x00000000,0x05554000,0x00000000,0x00000000,0x00000000,0x00000100,0x00000000,0x00000000},
/*          x  */{0x00000400,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000400,0x00000000,0x00000000}
},{ /* alphanumeric display characters (reversed comma with period) */
/*  xxxxxxx    */{0x05554000,0x05554000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/* xx  x  xx   */{0x14105000,0x00000000,0x00001000,0x00000000,0x00000000,0x00000000,0x10000000,0x00000000,0x00000000,0x04000000,0x00100000,0x00004000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/* x x x x x   */{0x11111000,0x00000000,0x00001000,0x00000000,0x00000000,0x00000000,0x10000000,0x00000000,0x00000000,0x01000000,0x00100000,0x00010000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/* x x x x x   */{0x11111000,0x00000000,0x00001000,0x00000000,0x00000000,0x00000000,0x10000000,0x00000000,0x00000000,0x01000000,0x00100000,0x00010000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/* x  xxx  x   */{0x10541000,0x00000000,0x00001000,0x00000000,0x00000000,0x00000000,0x10000000,0x00000000,0x00000000,0x00400000,0x00100000,0x00040000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/*  xxx xxx    */{0x05454000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x05400000,0x00000000,0x00000000,0x00000000,0x00000000,0x00054000,0x00000000,0x00000000,0x00000000,0x00000000},
/* x  xxx  x   */{0x10541000,0x00000000,0x00000000,0x00001000,0x00000000,0x10000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00040000,0x00100000,0x00400000,0x00000000},
/* x x x x x   */{0x11111000,0x00000000,0x00000000,0x00001000,0x00000000,0x10000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00010000,0x00100000,0x01000000,0x00000000},
/* x x x x x   */{0x11111000,0x00000000,0x00000000,0x00001000,0x00000000,0x10000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00010000,0x00100000,0x01000000,0x00000000},
/* xx  x  xx x */{0x14105100,0x00000000,0x00000000,0x00001000,0x00000000,0x10000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00004000,0x00100000,0x04000000,0x00000100},
/*  xxxxxxx  x */{0x05554100,0x00000000,0x00000000,0x00000000,0x05554000,0x00000000,0x00000000,0x00000000,0x00000100,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000100},
/*          x  */{0x00000400,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000400}
},{ /* 8 segment LED characters with dots instead of commas */
/*  xxxxxxx    */{0x05554000,0x05554000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/* x       x   */{0x10001000,0x00000000,0x00001000,0x00000000,0x00000000,0x00000000,0x10000000,0x00000000,0x00000000},
/* x       x   */{0x10001000,0x00000000,0x00001000,0x00000000,0x00000000,0x00000000,0x10000000,0x00000000,0x00000000},
/* x       x   */{0x10001000,0x00000000,0x00001000,0x00000000,0x00000000,0x00000000,0x10000000,0x00000000,0x00000000},
/* x       x   */{0x10001000,0x00000000,0x00001000,0x00000000,0x00000000,0x00000000,0x10000000,0x00000000,0x00000000},
/*  xxxxxxx    */{0x05554000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x05554000,0x00000000},
/* x       x   */{0x10001000,0x00000000,0x00000000,0x00001000,0x00000000,0x10000000,0x00000000,0x00000000,0x00000000},
/* x       x   */{0x10001000,0x00000000,0x00000000,0x00001000,0x00000000,0x10000000,0x00000000,0x00000000,0x00000000},
/* x       x   */{0x10001000,0x00000000,0x00000000,0x00001000,0x00000000,0x10000000,0x00000000,0x00000000,0x00000000},
/* x       x   */{0x10001000,0x00000000,0x00000000,0x00001000,0x00000000,0x10000000,0x00000000,0x00000000,0x00000000},
/*  xxxxxxx  x */{0x05554100,0x00000000,0x00000000,0x00000000,0x05554000,0x00000000,0x00000000,0x00000000,0x00000100},
/*             */{0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000}
},{ /* alphanumeric display characters (period only) */
/*  xxxxxxx    */{0x05554000,0x05554000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/* xx  x  xx   */{0x14105000,0x00000000,0x00001000,0x00000000,0x00000000,0x00000000,0x10000000,0x00000000,0x00000000,0x04000000,0x00100000,0x00004000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/* x x x x x   */{0x11111000,0x00000000,0x00001000,0x00000000,0x00000000,0x00000000,0x10000000,0x00000000,0x00000000,0x01000000,0x00100000,0x00010000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/* x x x x x   */{0x11111000,0x00000000,0x00001000,0x00000000,0x00000000,0x00000000,0x10000000,0x00000000,0x00000000,0x01000000,0x00100000,0x00010000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/* x  xxx  x   */{0x10541000,0x00000000,0x00001000,0x00000000,0x00000000,0x00000000,0x10000000,0x00000000,0x00000000,0x00400000,0x00100000,0x00040000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/*  xxx xxx    */{0x05454000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x05400000,0x00000000,0x00000000,0x00000000,0x00000000,0x00054000,0x00000000,0x00000000,0x00000000,0x00000000},
/* x  xxx  x   */{0x10541000,0x00000000,0x00000000,0x00001000,0x00000000,0x10000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00040000,0x00100000,0x00400000,0x00000000},
/* x x x x x   */{0x11111000,0x00000000,0x00000000,0x00001000,0x00000000,0x10000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00010000,0x00100000,0x01000000,0x00000000},
/* x x x x x   */{0x11111000,0x00000000,0x00000000,0x00001000,0x00000000,0x10000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00010000,0x00100000,0x01000000,0x00000000},
/* xx  x  xx   */{0x14105000,0x00000000,0x00000000,0x00001000,0x00000000,0x10000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00004000,0x00100000,0x04000000,0x00000000},
/*  xxxxxxx  x */{0x05554100,0x00000000,0x00000000,0x00000000,0x05554000,0x00000000,0x00000000,0x00000000,0x00000100,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000100},
/*             */{0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000}
}};
static const tSegRow segSize2[3][12] = { /* without commas */
{ /* alphanumeric display characters */
/*                   all        0001       0002       0004       0008       0010       0020       0040       0080       0100       0200       0400       0800       1000       2000       4000       8000 */
/*  xxxxxxx    */{0x05554000,0x05554000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/* xx  x  xx   */{0x14105000,0x00000000,0x00001000,0x00000000,0x00000000,0x00000000,0x10000000,0x00000000,0x00000000,0x04000000,0x00100000,0x00004000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/* x x x x x   */{0x11111000,0x00000000,0x00001000,0x00000000,0x00000000,0x00000000,0x10000000,0x00000000,0x00000000,0x01000000,0x00100000,0x00010000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/* x x x x x   */{0x11111000,0x00000000,0x00001000,0x00000000,0x00000000,0x00000000,0x10000000,0x00000000,0x00000000,0x01000000,0x00100000,0x00010000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/* x  xxx  x   */{0x10541000,0x00000000,0x00001000,0x00000000,0x00000000,0x00000000,0x10000000,0x00000000,0x00000000,0x00400000,0x00100000,0x00040000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/*  xxx xxx    */{0x05454000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x05400000,0x00000000,0x00000000,0x00000000,0x00000000,0x00054000,0x00000000,0x00000000,0x00000000,0x00000000},
/* x  xxx  x   */{0x10541000,0x00000000,0x00000000,0x00001000,0x00000000,0x10000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00040000,0x00100000,0x00400000,0x00000000},
/* x x x x x   */{0x11111000,0x00000000,0x00000000,0x00001000,0x00000000,0x10000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00010000,0x00100000,0x01000000,0x00000000},
/* x x x x x   */{0x11111000,0x00000000,0x00000000,0x00001000,0x00000000,0x10000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00010000,0x00100000,0x01000000,0x00000000},
/* xx  x  xx   */{0x14105000,0x00000000,0x00000000,0x00001000,0x00000000,0x10000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00004000,0x00100000,0x04000000,0x00000000},
/*  xxxxxxx    */{0x05554000,0x00000000,0x00000000,0x00000000,0x05554000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/*             */{0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000}
},{ /* 7 segment LED characters */
/*  xxxxxxx    */{0x05554000,0x05554000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/* x       x   */{0x10001000,0x00000000,0x00001000,0x00000000,0x00000000,0x00000000,0x10000000,0x00000000},
/* x       x   */{0x10001000,0x00000000,0x00001000,0x00000000,0x00000000,0x00000000,0x10000000,0x00000000},
/* x       x   */{0x10001000,0x00000000,0x00001000,0x00000000,0x00000000,0x00000000,0x10000000,0x00000000},
/* x       x   */{0x10001000,0x00000000,0x00001000,0x00000000,0x00000000,0x00000000,0x10000000,0x00000000},
/*  xxxxxxx    */{0x05554000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x05554000},
/* x       x   */{0x10001000,0x00000000,0x00000000,0x00001000,0x00000000,0x10000000,0x00000000,0x00000000},
/* x       x   */{0x10001000,0x00000000,0x00000000,0x00001000,0x00000000,0x10000000,0x00000000,0x00000000},
/* x       x   */{0x10001000,0x00000000,0x00000000,0x00001000,0x00000000,0x10000000,0x00000000,0x00000000},
/* x       x   */{0x10001000,0x00000000,0x00000000,0x00001000,0x00000000,0x10000000,0x00000000,0x00000000},
/*  xxxxxxx    */{0x05554000,0x00000000,0x00000000,0x00000000,0x05554000,0x00000000,0x00000000,0x00000000},
/*             */{0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000}
},{ /* 9 segment LED characters */
/*  xxxxxxx    */{0x05554000,0x05554000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/* x   x   x   */{0x10101000,0x00000000,0x00001000,0x00000000,0x00000000,0x00000000,0x10000000,0x00000000,0x00000000,0x00100000,0x00000000},
/* x   x   x   */{0x10101000,0x00000000,0x00001000,0x00000000,0x00000000,0x00000000,0x10000000,0x00000000,0x00000000,0x00100000,0x00000000},
/* x   x   x   */{0x10101000,0x00000000,0x00001000,0x00000000,0x00000000,0x00000000,0x10000000,0x00000000,0x00000000,0x00100000,0x00000000},
/* x   x   x   */{0x10101000,0x00000000,0x00001000,0x00000000,0x00000000,0x00000000,0x10000000,0x00000000,0x00000000,0x00100000,0x00000000},
/*  xxxxxxx    */{0x05554000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x05554000,0x00000000,0x00000000,0x00000000},
/* x   x   x   */{0x10101000,0x00000000,0x00000000,0x00001000,0x00000000,0x10000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00100000},
/* x   x   x   */{0x10101000,0x00000000,0x00000000,0x00001000,0x00000000,0x10000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00100000},
/* x   x   x   */{0x10101000,0x00000000,0x00000000,0x00001000,0x00000000,0x10000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00100000},
/* x   x   x   */{0x10101000,0x00000000,0x00000000,0x00001000,0x00000000,0x10000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00100000},
/*  xxxxxxx    */{0x05554000,0x00000000,0x00000000,0x00000000,0x05554000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/*             */{0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000}
}};
static const tSegRow segSize3C[3][8] = {
{ /* alphanumeric display characters */
{0} /* not possible */
},{ /* 8 segment LED characters with commas */
/*               all        0001       0002       0004       0008       0010       0020       0040       0080       0100       0200 */
/*  xxx    */{0x05400000,0x05400000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/* x   x   */{0x10100000,0x00000000,0x00100000,0x00000000,0x00000000,0x00000000,0x10000000,0x00000000,0x00000000},
/* x   x   */{0x10100000,0x00000000,0x00100000,0x00000000,0x00000000,0x00000000,0x10000000,0x00000000,0x00000000},
/*  xxx    */{0x05400000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x05400000,0x00000000},
/* x   x   */{0x10100000,0x00000000,0x00000000,0x00100000,0x00000000,0x10000000,0x00000000,0x00000000,0x00000000},
/* x   x   */{0x10100000,0x00000000,0x00000000,0x00100000,0x00000000,0x10000000,0x00000000,0x00000000,0x00000000},
/*  xxx  x */{0x05410000,0x00000000,0x00000000,0x00000000,0x05400000,0x00000000,0x00000000,0x00000000,0x00010000},
/*      x  */{0x00040000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00040000}
},{ /* 10 segment LED characters with commas */
/*  xxx    */{0x05400000,0x05400000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/* x x x   */{0x11100000,0x00000000,0x00100000,0x00000000,0x00000000,0x00000000,0x10000000,0x00000000,0x00000000,0x01000000,0x00000000},
/* x x x   */{0x11100000,0x00000000,0x00100000,0x00000000,0x00000000,0x00000000,0x10000000,0x00000000,0x00000000,0x01000000,0x00000000},
/*  xxx    */{0x05400000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x05400000,0x00000000,0x00000000,0x00000000},
/* x x x   */{0x11100000,0x00000000,0x00000000,0x00100000,0x00000000,0x10000000,0x00000000,0x00000000,0x00000000,0x00000000,0x01000000},
/* x x x   */{0x11100000,0x00000000,0x00000000,0x00100000,0x00000000,0x10000000,0x00000000,0x00000000,0x00000000,0x00000000,0x01000000},
/*  xxx  x */{0x05410000,0x00000000,0x00000000,0x00000000,0x05400000,0x00000000,0x00000000,0x00000000,0x00010000,0x00000000,0x00000000},
/*      x  */{0x00040000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00040000,0x00000000,0x00000000}
}};
static const tSegRow segSize3[3][8] = {
{ /* alphanumeric display characters */
{0} /* not possible */
},{ /* 8 segment LED characters without commas */
/*               all        0001       0002       0004       0008       0010       0020       0040       0080       0100       0200 */
/*  xxx    */{0x05400000,0x05400000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/* x   x   */{0x10100000,0x00000000,0x00100000,0x00000000,0x00000000,0x00000000,0x10000000,0x00000000},
/* x   x   */{0x10100000,0x00000000,0x00100000,0x00000000,0x00000000,0x00000000,0x10000000,0x00000000},
/*  xxx    */{0x05400000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x05400000},
/* x   x   */{0x10100000,0x00000000,0x00000000,0x00100000,0x00000000,0x10000000,0x00000000,0x00000000},
/* x   x   */{0x10100000,0x00000000,0x00000000,0x00100000,0x00000000,0x10000000,0x00000000,0x00000000},
/*  xxx    */{0x05400000,0x00000000,0x00000000,0x00000000,0x05400000,0x00000000,0x00000000,0x00000000},
/*         */{0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000}
},{ /* 10 segment LED characters without commas */
/*  xxx    */{0x05400000,0x05400000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/* x x x   */{0x11100000,0x00000000,0x00100000,0x00000000,0x00000000,0x00000000,0x10000000,0x00000000,0x00000000,0x01000000,0x00000000},
/* x x x   */{0x11100000,0x00000000,0x00100000,0x00000000,0x00000000,0x00000000,0x10000000,0x00000000,0x00000000,0x01000000,0x00000000},
/*  xxx    */{0x05400000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x05400000,0x00000000,0x00000000,0x00000000},
/* x x x   */{0x11100000,0x00000000,0x00000000,0x00100000,0x00000000,0x10000000,0x00000000,0x00000000,0x00000000,0x00000000,0x01000000},
/* x x x   */{0x11100000,0x00000000,0x00000000,0x00100000,0x00000000,0x10000000,0x00000000,0x00000000,0x00000000,0x00000000,0x01000000},
/*  xxx    */{0x05400000,0x00000000,0x00000000,0x00000000,0x05400000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/*         */{0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000}
}};
static const tSegRow segSize1S[1][20] = { /* 16 segment displays without commas but split top & bottom lines */
{ /* alphanumeric display characters */
/*                       all        0001       0002       0004       0008       0010       0020       0040       0080       0100       0200       0400       0800       1000       2000       4000       8000 */
/*    11111311111  */{0x00557554,0x00557000,0x00003554,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/*   1133331333311 */{0x017fdff5,0x003fc000,0x00003ff0,0x00000001,0x00000000,0x00000000,0x00000000,0x00000000,0x01000000,0x00400000,0x00001000,0x00000004,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/*   11    1   1 1 */{0x01401011,0x00000000,0x00000000,0x00000001,0x00000000,0x00000000,0x00000000,0x00000000,0x01000000,0x00400000,0x00001000,0x00000010,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/*  31 1  31  1 31 */{0x0d10d04d,0x00000000,0x00000000,0x0000000d,0x00000000,0x00000000,0x00000000,0x00000000,0x0d000000,0x00100000,0x0000d000,0x00000040,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/*  32 1  32  1 32 */{0x0e10e04e,0x00000000,0x00000000,0x0000000e,0x00000000,0x00000000,0x00000000,0x00000000,0x0e000000,0x00100000,0x0000e000,0x00000040,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/*  22  1 22 1  22 */{0x0a04a10a,0x00000000,0x00000000,0x0000000a,0x00000000,0x00000000,0x00000000,0x00000000,0x0a000000,0x00040000,0x0000a000,0x00000100,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/*  23  1 231   23 */{0x0b04b40b,0x00000000,0x00000000,0x0000000b,0x00000000,0x00000000,0x00000000,0x00000000,0x0b000000,0x00040000,0x0000b000,0x00000400,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/*  13   1131   13 */{0x07017407,0x00000000,0x00000000,0x00000007,0x00000000,0x00000000,0x00000000,0x00000000,0x07000000,0x00010000,0x00007000,0x00000400,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/*  1333311133331  */{0x07fd5ff4,0x00000000,0x00000000,0x00000004,0x00000000,0x00000000,0x00000000,0x00000000,0x04000000,0x00010000,0x00004000,0x00001000,0x00000ff0,0x00000000,0x00000000,0x00000000,0x03fc0000},
/*  3111113111113  */{0x0d55d55c,0x00000000,0x00000000,0x0000000c,0x0000000c,0x00000000,0x00000000,0x0c000000,0x0c000000,0x0000c000,0x0000c000,0x0000c000,0x0000d550,0x0000c000,0x0000c000,0x0000c000,0x0155c000},
/*  1333311133331  */{0x07fd5ff4,0x00000000,0x00000000,0x00000000,0x00000004,0x00000000,0x00000000,0x04000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000ff0,0x00001000,0x00004000,0x00010000,0x03fc0000},
/* 31   1311   31  */{0x34075034,0x00000000,0x00000000,0x00000000,0x00000034,0x00000000,0x00000000,0x34000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00001000,0x00034000,0x00040000,0x00000000},
/* 32   132 1  32  */{0x38078438,0x00000000,0x00000000,0x00000000,0x00000038,0x00000000,0x00000000,0x38000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000400,0x00038000,0x00040000,0x00000000},
/* 22  1 22 1  22  */{0x28128428,0x00000000,0x00000000,0x00000000,0x00000028,0x00000000,0x00000000,0x28000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000400,0x00028000,0x00100000,0x00000000},
/* 23 1  23  1 23  */{0x2c42c12c,0x00000000,0x00000000,0x00000000,0x0000002c,0x00000000,0x00000000,0x2c000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000100,0x0002c000,0x00400000,0x00000000},
/* 13 1  13  1 13  */{0x1c41c11c,0x00000000,0x00000000,0x00000000,0x0000001c,0x00000000,0x00000000,0x1c000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000100,0x0001c000,0x00400000,0x00000000},
/* 1 1   1    11   */{0x11010050,0x00000000,0x00000000,0x00000000,0x00000010,0x00000000,0x00000000,0x10000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000040,0x00010000,0x01000000,0x00000000},
/* 1133331333311   */{0x17fdff50,0x00000000,0x00000000,0x00000000,0x00000010,0x0003ff00,0x03fc0000,0x10000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000040,0x00010000,0x04000000,0x00000000},
/*  11111311111    */{0x05575540,0x00000000,0x00000000,0x00000000,0x00000000,0x00035540,0x05570000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/*                 */{0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000}
}};
static const tSegRow segSize2S[1][12] = { /* 16 segment displays without commas but split top & bottom lines */
{ /* alphanumeric display characters */
/*                   all        0001       0002       0004       0008       0010       0020       0040       0080       0100       0200       0400       0800       1000       2000       4000       8000 */
/*  xxxxxxx    */{0x05754000,0x05700000,0x00354000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/* xx  x  xx   */{0x14105000,0x00000000,0x00000000,0x00001000,0x00000000,0x00000000,0x00000000,0x00000000,0x10000000,0x04000000,0x00100000,0x00004000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/* x x x x x   */{0x11111000,0x00000000,0x00000000,0x00001000,0x00000000,0x00000000,0x00000000,0x00000000,0x10000000,0x01000000,0x00100000,0x00010000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/* x x x x x   */{0x11111000,0x00000000,0x00000000,0x00001000,0x00000000,0x00000000,0x00000000,0x00000000,0x10000000,0x01000000,0x00100000,0x00010000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/* x  xxx  x   */{0x10541000,0x00000000,0x00000000,0x00001000,0x00000000,0x00000000,0x00000000,0x00000000,0x10000000,0x00400000,0x00100000,0x00040000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/*  xxx xxx    */{0x05454000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00054000,0x00000000,0x00000000,0x00000000,0x05400000},
/* x  xxx  x   */{0x10541000,0x00000000,0x00000000,0x00000000,0x00001000,0x00000000,0x00000000,0x10000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00040000,0x00100000,0x00400000,0x00000000},
/* x x x x x   */{0x11111000,0x00000000,0x00000000,0x00000000,0x00001000,0x00000000,0x00000000,0x10000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00010000,0x00100000,0x01000000,0x00000000},
/* x x x x x   */{0x11111000,0x00000000,0x00000000,0x00000000,0x00001000,0x00000000,0x00000000,0x10000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00010000,0x00100000,0x01000000,0x00000000},
/* xx  x  xx   */{0x14105000,0x00000000,0x00000000,0x00000000,0x00001000,0x00000000,0x00000000,0x10000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00004000,0x00100000,0x04000000,0x00000000},
/*  xxxxxxx    */{0x05754000,0x00000000,0x00000000,0x00000000,0x00000000,0x00354000,0x05700000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000},
/*             */{0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000,0x00000000}
}};

// rows should not be larger than 20, cols not larger than 15, otherwise adapt all code that uses these fields!
static const tSegData segData[2][18] = {{
  {20,15,&segSize1C[0][0]},/* SEG16 */
#ifdef PROC_SUPPORT //TODO/PROC: Will this work in normal PinMAME build too?
  /* Use segSize2C for P-ROC's alpha_on_dmd functionality as it maps better to the DMD. */
  {20,15,&segSize2C[0][0]},/* SEG16R */
#else
  {20,15,&segSize1C[3][0]},/* SEG16R */
#endif
  {20,15,&segSize1C[2][0]},/* SEG10 */
  {20,15,&segSize1[2][0]}, /* SEG9 */
  {20,15,&segSize1C[1][0]},/* SEG8 */
  {20,15,&segSize1C[4][0]},/* SEG8FD */
  {20,15,&segSize1[1][0]}, /* SEG7 */
  {20,15,&segSize1C[1][0]},/* SEG87 */
  {20,15,&segSize1C[1][0]},/* SEG87F */
  {20,15,&segSize1C[2][0]},/* SEG98 */
  {20,15,&segSize1C[2][0]},/* SEG98F */
  {12,11,&segSize2[1][0]}, /* SEG7S */
  {12,11,&segSize2C[1][0]},/* SEG7SC */
  {20,15,&segSize1S[0][0]},/* SEG16S */
  { 2, 2,NULL},            /* DMD */
  { 1, 1,NULL},            /* VIDEO */
  {20,15,&segSize1[0][0]}, /* SEG16N */
  {20,15,&segSize1C[5][0]} /* SEG16D */
},{
  {12,11,&segSize2C[0][0]},/* SEG16 */
  {12,11,&segSize2C[3][0]},/* SEG16R */
  {12,11,&segSize2C[2][0]},/* SEG10 */
  {12,11,&segSize2[2][0]}, /* SEG9 */
  {12,11,&segSize2C[1][0]},/* SEG8 */
  {12,11,&segSize2C[4][0]},/* SEG8D */
  {12,11,&segSize2[1][0]}, /* SEG7 */
  {12,11,&segSize2C[1][0]},/* SEG87 */
  {12,11,&segSize2C[1][0]},/* SEG87F */
  {12,11,&segSize2C[2][0]},/* SEG98 */
  {12,11,&segSize2C[2][0]},/* SEG98F */
  { 8, 7,&segSize3[1][0]}, /* SEG7S */
  { 8, 7,&segSize3C[1][0]},/* SEG7SC */
  {12,11,&segSize2S[0][0]},/* SEG16S */
  { 1, 1,NULL},            /* DMD */
  { 1, 1,NULL},            /* VIDEO */
  {12,11,&segSize2[0][0]}, /* SEG16N */
  {12,11,&segSize2C[5][0]} /* SEG16D */
}};

/*-------------------
/  local variables
/-------------------*/
static struct {
  int       displaySize;   // 1=compact 2=normal
  const tSegData *segData; // segments to use (normal/compact)
  void      *timers[5];    // allocated timers
  int       flipTimer[4];  // time since flipper was activated (used for EOS simulation)
  UINT8     flipMask;      // Flipper bits used for flippers
  int       firstSimRow, maxSimRows; // space available for simulator
  int       solLog[4];
  int       solLogCount;
  /*-- Event reporting (used LibPinMAME and on screen display) --*/
  UINT8     lastPhysicsOutput[CORE_MODOUT_MAX];
  UINT8     lastLampMatrix[CORE_MAXLAMPCOL];
  int       lastGI[CORE_MAXGI];
  UINT64    lastSol;
  /*-- VPinMAME specifics --*/
  #if defined(VPINMAME) || defined(LIBPINMAME)
    UINT8   vpm_dmd_last_lum[DMD_MAXY * DMD_MAXX];
    UINT8   vpm_dmd_luminance_lut[256];
  #endif
  #if defined(VPINMAME)
    UINT32  vpm_dmd_color_lut[256];
  #endif
} locals;

/*-------------------------------
/  Initialize the game palette
/-------------------------------*/
static PALETTE_INIT(core) {
  const int palSize = sizeof(core_palette)/3;
  unsigned char tmpPalette[sizeof(core_palette)/3][3];
  int rStart = 0xff, gStart = 0xe0, bStart = 0x20;
  int perc66 = 67, perc33 = 33, perc0 = 20;
  int ii;

  if ((pmoptions.dmd_red > 0) || (pmoptions.dmd_green > 0) || (pmoptions.dmd_blue > 0)) {
    rStart = pmoptions.dmd_red; gStart = pmoptions.dmd_green; bStart = pmoptions.dmd_blue;
  }
  if ((pmoptions.dmd_perc0 > 0) || (pmoptions.dmd_perc33 > 0) || (pmoptions.dmd_perc66 > 0)) {
    perc66 = pmoptions.dmd_perc66; perc33 = pmoptions.dmd_perc33; perc0  = pmoptions.dmd_perc0;
  }
  memcpy(tmpPalette, core_palette, sizeof(core_palette));

  /*-- Autogenerate DMD Color Shades--*/
  tmpPalette[COL_DMDOFF][0]   = (unsigned char)(rStart * perc0  / 100);
  tmpPalette[COL_DMDOFF][1]   = (unsigned char)(gStart * perc0  / 100);
  tmpPalette[COL_DMDOFF][2]   = (unsigned char)(bStart * perc0  / 100);
  tmpPalette[COL_DMD33][0]    = (unsigned char)(rStart * perc33 / 100);
  tmpPalette[COL_DMD33][1]    = (unsigned char)(gStart * perc33 / 100);
  tmpPalette[COL_DMD33][2]    = (unsigned char)(bStart * perc33 / 100);
  tmpPalette[COL_DMD66][0]    = (unsigned char)(rStart * perc66 / 100);
  tmpPalette[COL_DMD66][1]    = (unsigned char)(gStart * perc66 / 100);
  tmpPalette[COL_DMD66][2]    = (unsigned char)(bStart * perc66 / 100);
  tmpPalette[COL_DMDON][0]    = (unsigned char)rStart;
  tmpPalette[COL_DMDON][1]    = (unsigned char)gStart;
  tmpPalette[COL_DMDON][2]    = (unsigned char)bStart;

  /*-- If the "colorize" option is set, use the individual option colors for the shades --*/
  if (pmoptions.dmd_colorize) {
    if (pmoptions.dmd_red0 > 0 || pmoptions.dmd_green0 > 0 || pmoptions.dmd_blue0 > 0) {
      tmpPalette[COL_DMDOFF][0] = pmoptions.dmd_red0;
      tmpPalette[COL_DMDOFF][1] = pmoptions.dmd_green0;
      tmpPalette[COL_DMDOFF][2] = pmoptions.dmd_blue0;
    }
    if (pmoptions.dmd_red33 > 0 || pmoptions.dmd_green33 > 0 || pmoptions.dmd_blue33 > 0) {
      tmpPalette[COL_DMD33][0]  = pmoptions.dmd_red33;
      tmpPalette[COL_DMD33][1]  = pmoptions.dmd_green33;
      tmpPalette[COL_DMD33][2]  = pmoptions.dmd_blue33;
    }
    if (pmoptions.dmd_red66 > 0 || pmoptions.dmd_green66 > 0 || pmoptions.dmd_blue66 > 0) {
      tmpPalette[COL_DMD66][0]  = pmoptions.dmd_red66;
      tmpPalette[COL_DMD66][1]  = pmoptions.dmd_green66;
      tmpPalette[COL_DMD66][2]  = pmoptions.dmd_blue66;
    }
  }

  /*-- generate 3*16 shades of the dmd color for all faded dots --*/
  for (ii = 0; ii < 16; ii++) {
    tmpPalette[palSize-48-48-48+ii][0] = (UINT8)((rStart * ((16 - ii) * perc0  + ii * perc33)) / 1600);
    tmpPalette[palSize-48-48-48+ii][1] = (UINT8)((gStart * ((16 - ii) * perc0  + ii * perc33)) / 1600);
    tmpPalette[palSize-48-48-48+ii][2] = (UINT8)((bStart * ((16 - ii) * perc0  + ii * perc33)) / 1600);
    tmpPalette[palSize-48-48-32+ii][0] = (UINT8)((rStart * ((16 - ii) * perc33 + ii * perc66)) / 1600);
    tmpPalette[palSize-48-48-32+ii][1] = (UINT8)((gStart * ((16 - ii) * perc33 + ii * perc66)) / 1600);
    tmpPalette[palSize-48-48-32+ii][2] = (UINT8)((bStart * ((16 - ii) * perc33 + ii * perc66)) / 1600);
    tmpPalette[palSize-48-48-16+ii][0] = (UINT8)((rStart * ((16 - ii) * perc66 + ii *    100)) / 1600);
    tmpPalette[palSize-48-48-16+ii][1] = (UINT8)((gStart * ((16 - ii) * perc66 + ii *    100)) / 1600);
    tmpPalette[palSize-48-48-16+ii][2] = (UINT8)((bStart * ((16 - ii) * perc66 + ii *    100)) / 1600);
  }
  // as aboves interpolation does end 'one entry too early', force last entry to 100%
  tmpPalette[palSize-48-48-16+15][0] = (UINT8)rStart;
  tmpPalette[palSize-48-48-16+15][1] = (UINT8)gStart;
  tmpPalette[palSize-48-48-16+15][2] = (UINT8)bStart;

  /*-- generate 4*12 shades of the dmd color for all antialiased dots --*/
  for (ii = 0; ii < 12; ii++) {
    tmpPalette[palSize-48-48+ii][0] = (UINT8)((rStart * ((12 - ii) *     0  + ii * perc0 )) / 1200);
    tmpPalette[palSize-48-48+ii][1] = (UINT8)((gStart * ((12 - ii) *     0  + ii * perc0 )) / 1200);
    tmpPalette[palSize-48-48+ii][2] = (UINT8)((bStart * ((12 - ii) *     0  + ii * perc0 )) / 1200);
    tmpPalette[palSize-48-36+ii][0] = (UINT8)((rStart * ((12 - ii) * perc0  + ii * perc33)) / 1200);
    tmpPalette[palSize-48-36+ii][1] = (UINT8)((gStart * ((12 - ii) * perc0  + ii * perc33)) / 1200);
    tmpPalette[palSize-48-36+ii][2] = (UINT8)((bStart * ((12 - ii) * perc0  + ii * perc33)) / 1200);
    tmpPalette[palSize-48-24+ii][0] = (UINT8)((rStart * ((12 - ii) * perc33 + ii * perc66)) / 1200);
    tmpPalette[palSize-48-24+ii][1] = (UINT8)((gStart * ((12 - ii) * perc33 + ii * perc66)) / 1200);
    tmpPalette[palSize-48-24+ii][2] = (UINT8)((bStart * ((12 - ii) * perc33 + ii * perc66)) / 1200);
    tmpPalette[palSize-48-12+ii][0] = (UINT8)((rStart * ((12 - ii) * perc66 + ii *    100)) / 1200);
    tmpPalette[palSize-48-12+ii][1] = (UINT8)((gStart * ((12 - ii) * perc66 + ii *    100)) / 1200);
    tmpPalette[palSize-48-12+ii][2] = (UINT8)((bStart * ((12 - ii) * perc66 + ii *    100)) / 1200);
  }
  // as aboves interpolation does end 'one entry too early', force last entry to 100%
  tmpPalette[palSize-48-12+12][0] = (UINT8)rStart;
  tmpPalette[palSize-48-12+12][1] = (UINT8)gStart;
  tmpPalette[palSize-48-12+12][2] = (UINT8)bStart;

  /*-- segment display antialias colors --*/
  // reset to default values, DMD levels should not be applied to segments
  perc66 = 67;
  perc33 = 33;
  perc0  = 20;

  tmpPalette[COL_SEGAAON1] [0] = (unsigned char)(rStart * (perc66+5) / 100);
  tmpPalette[COL_SEGAAON1] [1] = (unsigned char)(gStart * (perc66+5) / 100);
  tmpPalette[COL_SEGAAON1] [2] = (unsigned char)(bStart * (perc66+5) / 100);
  tmpPalette[COL_SEGAAON2] [0] = (unsigned char)(rStart * perc33 / 100);
  tmpPalette[COL_SEGAAON2] [1] = (unsigned char)(gStart * perc33 / 100);
  tmpPalette[COL_SEGAAON2] [2] = (unsigned char)(bStart * perc33 / 100);
  tmpPalette[COL_SEGAAOFF1][0] = (unsigned char)(rStart * perc0 * (perc66+5) / 10000);
  tmpPalette[COL_SEGAAOFF1][1] = (unsigned char)(gStart * perc0 * (perc66+5) / 10000);
  tmpPalette[COL_SEGAAOFF1][2] = (unsigned char)(bStart * perc0 * (perc66+5) / 10000);
  tmpPalette[COL_SEGAAOFF2][0] = (unsigned char)(rStart * perc0 * perc33 / 10000);
  tmpPalette[COL_SEGAAOFF2][1] = (unsigned char)(gStart * perc0 * perc33 / 10000);
  tmpPalette[COL_SEGAAOFF2][2] = (unsigned char)(bStart * perc0 * perc33 / 10000);

  /*-- generate 3*16 shades of the segment color for all antialiased or dimmed segments --*/
  perc66 = 66;
  perc33 = 33;
  perc0 = 0;
  for (ii = 0; ii < 16; ii++) {
    tmpPalette[palSize-48+ii][0] = (UINT8)((rStart * ((16 - ii) * perc0  + ii * perc33)) / 1600);
    tmpPalette[palSize-48+ii][1] = (UINT8)((gStart * ((16 - ii) * perc0  + ii * perc33)) / 1600);
    tmpPalette[palSize-48+ii][2] = (UINT8)((bStart * ((16 - ii) * perc0  + ii * perc33)) / 1600);
    tmpPalette[palSize-32+ii][0] = (UINT8)((rStart * ((16 - ii) * perc33 + ii * perc66)) / 1600);
    tmpPalette[palSize-32+ii][1] = (UINT8)((gStart * ((16 - ii) * perc33 + ii * perc66)) / 1600);
    tmpPalette[palSize-32+ii][2] = (UINT8)((bStart * ((16 - ii) * perc33 + ii * perc66)) / 1600);
    tmpPalette[palSize-16+ii][0] = (UINT8)((rStart * ((16 - ii) * perc66 + ii *    100)) / 1600);
    tmpPalette[palSize-16+ii][1] = (UINT8)((gStart * ((16 - ii) * perc66 + ii *    100)) / 1600);
    tmpPalette[palSize-16+ii][2] = (UINT8)((bStart * ((16 - ii) * perc66 + ii *    100)) / 1600);
  }
  // as aboves interpolation does end 'one entry too early', force last entry to 100%
  tmpPalette[palSize-16+15][0] = (UINT8)rStart;
  tmpPalette[palSize-16+15][1] = (UINT8)gStart;
  tmpPalette[palSize-16+15][2] = (UINT8)bStart;

  /*-- Autogenerate Dark Playfield Lamp Colors --*/
  for (ii = 0; ii < COL_LAMPCOUNT; ii++) { /* Reduce by 75% */
    tmpPalette[COL_LAMP+COL_LAMPCOUNT+ii][0] = (tmpPalette[COL_LAMP+ii][0] * 25) / 100;
    tmpPalette[COL_LAMP+COL_LAMPCOUNT+ii][1] = (tmpPalette[COL_LAMP+ii][1] * 25) / 100;
    tmpPalette[COL_LAMP+COL_LAMPCOUNT+ii][2] = (tmpPalette[COL_LAMP+ii][2] * 25) / 100;
  }

  if (pmoptions.dmd_antialias)
  { /*-- Autogenerate antialias colours --*/
    int rStep, gStep, bStep;
    rStart = gStart = bStart = 0;
    //rStart = tmpPalette[COL_DMDOFF][0];
    //gStart = tmpPalette[COL_DMDOFF][1];
    //bStart = tmpPalette[COL_DMDOFF][2];

    rStep = (tmpPalette[COL_DMDON][0] * pmoptions.dmd_antialias / 100 - rStart) / (COL_DMDAACOUNT-1);
    gStep = (tmpPalette[COL_DMDON][1] * pmoptions.dmd_antialias / 100 - gStart) / (COL_DMDAACOUNT-1);
    bStep = (tmpPalette[COL_DMDON][2] * pmoptions.dmd_antialias / 100 - bStart) / (COL_DMDAACOUNT-1);

    for (ii = 1; ii < COL_DMDAACOUNT; ii++) { // first is black
      tmpPalette[COL_DMDAA+ii][0] = (unsigned char)rStart;
      tmpPalette[COL_DMDAA+ii][1] = (unsigned char)gStart;
      tmpPalette[COL_DMDAA+ii][2] = (unsigned char)bStart;
      rStart += rStep; gStart += gStep; bStart += bStep;
    }
  }

  for (ii = 0; ii < sizeof(tmpPalette)/3; ii++)
    palette_set_color(ii, tmpPalette[ii][0], tmpPalette[ii][1], tmpPalette[ii][2]);
}

/*-----------------------------------
/  Generic segment display handler
/------------------------------------*/
#ifdef VPINMAME
void core_dmd_capture_frame(const int width, const int height, const UINT8* const dmdDotRaw, const int rawFrameCount, const UINT8* const rawFrame);

// VPinMAME function to send DMD/Alphanumeric information to an external dmddevice/dmdscreen.dll plugin
// Note that this part of the header is not used externally of VPinMAME (move it to something like core_dmdevice.h/core_dmddevice.c ?)
extern int dmddeviceInit(const char* GameName, UINT64 HardwareGeneration, const tPMoptions* Options);
extern void dmddeviceRenderDMDFrame(const int width, const int height, UINT8* dmdDotLum, UINT8* dmdDotRaw, UINT32 noOfRawFrames, UINT8* rawbuffer, const int isDMD2);
extern void dmddeviceRenderAlphanumericFrame(core_segOverallLayout_t layout, UINT16* seg_data, UINT16* seg_data2, char* seg_dim);
extern void dmddeviceFwdConsoleData(UINT8 data);
extern void dmddeviceDeInit(void);
#endif /* VPINMAME */

core_segOverallLayout_t layoutAlphanumericFrame(UINT64 gen, UINT8 total_disp, UINT8 *disp_num_segs, const char* GameName) {
	// TODO this should be moved to the driver's definition, or MACHINE_INIT, setting it once and for all at machine startup from core_gameData->lcdLayout
	core_segOverallLayout_t layout = CORE_SEGLAYOUT_None;

	// switch to current game tech
	switch(gen){
		// williams
		case GEN_S3:
		case GEN_S3C:
		case GEN_S4:
		case GEN_S6:
			layout = CORE_SEGLAYOUT_2x6Num_2x6Num_4x1Num;
			if ((strncasecmp(GameName, "algar", 5) == 0) || // Sys6A with 7 digit displays
				(strncasecmp(GameName, "alpok", 5) == 0) ||
				(strncasecmp(GameName, "frpwr_b6", 8) == 0) ||
				(strncasecmp(GameName, "frpwr_c6", 8) == 0))
				layout = CORE_SEGLAYOUT_2x7Num_2x7Num_4x1Num_gen7;
			break;
		case GEN_S7:
			if (strncasecmp(GameName, "hypbl", 5) == 0) // Hyperball
				layout = CORE_SEGLAYOUT_2x7Num_4x1Num_1x16Alpha;
			else
				layout = CORE_SEGLAYOUT_2x7Num_2x7Num_4x1Num_gen7;
			break;
		case GEN_S9:
			layout = CORE_SEGLAYOUT_2x7Num10_2x7Num10_4x1Num;
			break;

		case GEN_WPCALPHA_1:
		case GEN_WPCALPHA_2:
		case GEN_S11C:
		case GEN_S11B2:
			if (strncasecmp(GameName, "rvrbt", 5) == 0) // Additional displays for Riverboat Gambler
				layout = CORE_SEGLAYOUT_1x16Alpha_1x16Num_1x7Num_1x4Num;
			else if (strncasecmp(GameName, "polic", 5) == 0) // Police force has an additional display (jackpot)
				layout = CORE_SEGLAYOUT_1x7Num_1x16Alpha_1x16Num;
			else
				layout = CORE_SEGLAYOUT_2x16Alpha;
			break;
		case GEN_S11:
			layout = CORE_SEGLAYOUT_6x4Num_4x1Num;
			break;
		case GEN_S11X: // incl. GEN_S11A, GEN_S11B
			switch(total_disp){
				case 2:
					layout = CORE_SEGLAYOUT_2x16Alpha;
					break;
				case 3:
					layout = CORE_SEGLAYOUT_1x16Alpha_1x16Num_1x7Num;
					break;
				case 4:
					layout = CORE_SEGLAYOUT_2x7Alpha_2x7Num;
					break;
				case 8:
					layout = CORE_SEGLAYOUT_2x7Alpha_2x7Num_4x1Num;
					break;
			}
			if (strncasecmp(GameName, "polic", 5) == 0)
				layout = CORE_SEGLAYOUT_1x7Num_1x16Alpha_1x16Num;
			break;

		// dataeast
		case GEN_DE:
			switch(total_disp){
				case 2:
					layout = CORE_SEGLAYOUT_2x16Alpha;
					break;
				case 4:
					layout = CORE_SEGLAYOUT_2x7Alpha_2x7Num;
					break;
				case 8:
					layout = CORE_SEGLAYOUT_2x7Alpha_2x7Num_4x1Num;
					break;
			}
			break;

		// gottlieb
		case GEN_GTS1:
		case GEN_GTS80:
			switch(disp_num_segs[0]){
				case 6:
					layout = CORE_SEGLAYOUT_2x6Num10_2x6Num10_4x1Num;
					break;
				case 7:
					layout = CORE_SEGLAYOUT_2x7Num10_2x7Num10_4x1Num;
					break;
			}
			break;
		case GEN_GTS80B:
		case GEN_GTS3:
			layout = CORE_SEGLAYOUT_2x20Alpha;
			break;

		// stern
		case GEN_STMPU100:
		case GEN_STMPU200:
			switch(disp_num_segs[0]){
				case 6:
					layout = CORE_SEGLAYOUT_2x6Num_2x6Num_4x1Num;
					break;
				case 7:
					layout = CORE_SEGLAYOUT_2x7Num_2x7Num_4x1Num;
					break;
			}
			break;

		// bally
		case GEN_BY17:
		case GEN_BY35:
			// check for   total:8 = 6x6num + 4x1num
			if(total_disp==8){
				//!! ??
			}else{
				switch(disp_num_segs[0]){
					case 6:
						layout = CORE_SEGLAYOUT_2x6Num_2x6Num_4x1Num;
						break;
					case 7:
						if (strncasecmp(GameName, "medusa", 6) == 0)
							layout = CORE_SEGLAYOUT_2x7Num_2x7Num_10x1Num;
						else
							layout = CORE_SEGLAYOUT_2x7Num_2x7Num_4x1Num;
						break;
				}
			}
			break;
		case GEN_BY6803:
		case GEN_BY6803A:
			layout = CORE_SEGLAYOUT_4x7Num10;
			break;
		case GEN_BYPROTO:
			layout = CORE_SEGLAYOUT_2x6Num_2x6Num_4x1Num;
			break;

		// hankin
		case GEN_HNK:
			layout = CORE_SEGLAYOUT_2x20Alpha;
			break;

		//!! unsupported so far:
		// astro
		case GEN_ASTRO:
			break;
		case GEN_BOWLING:
			break;
		// zaccaria
		case GEN_ZAC1:
			break;
		case GEN_ZAC2:
			break;
	}

	return layout;
}

static void updateDisplay(struct mame_bitmap *bitmap, const struct rectangle *cliprect, const struct core_dispLayout *layout_array)
{
  if (layout_array == NULL) { DBGLOG(("gen_refresh without LCD layout\n")); return; }

  #if defined(VPINMAME) || defined(LIBPINMAME)
    static UINT16 seg_data[CORE_SEGCOUNT]; // use static, in case a dmddevice.dll keeps the pointers around
    static UINT8 seg_dim[CORE_SEGCOUNT];
    static UINT8 disp_num_segs[64]; // actually max seen was 48 so far, but.. // segments per display
    int seg_idx = 0;
    int n_seg_layouts = 0;
    memset(seg_data, 0, sizeof(seg_data));
    memset(seg_dim, 0, sizeof(seg_dim));
    disp_num_segs[0] = 0;
  #endif
  #ifdef LIBPINMAME
    UINT16* last_seg_data_ptr = seg_data;
    int display_index = 0;
  #endif

  int pos = 0;
  const struct core_dispLayout* layout = layout_array;
  const struct core_dispLayout* parent_layout = NULL;
  for (; layout->length || (parent_layout && parent_layout->length); layout += 1) {
    // Recursive import
    if (layout->length == 0)
    {
      layout = parent_layout;
      parent_layout = NULL;
    }
    if (layout->type == CORE_IMPORT) {
      assert(parent_layout == NULL); // IMPORT of IMPORT is not currently supported as it is not used by any driver so far
      parent_layout = layout + 1;
      layout = layout->lptr - 1;
      continue;
    }

    // Per driver renderer for DMD & video displays
    if (layout->fptr && (((ptPinMAMEvidUpdate)(layout->fptr))(bitmap,cliprect,layout) == 0)) {
      if (layout->type == CORE_VIDEO) {
        #if defined(VPINMAME) || defined(LIBPINMAME)
          has_DMD_Video = 1;
        #endif
        #ifdef LIBPINMAME
          libpinmame_update_display(display_index, layout, bitmap);
          display_index++;
        #endif
      }
      #ifdef LIBPINMAME
      else if ((layout->type & CORE_SEGALL) == CORE_DMD) {
         libpinmame_update_display(display_index, layout, g_raw_dmdbuffer);
         display_index++;
      }
      #endif
      continue;
    }

    // Alphanumeric Segment display
    {
      int left = layout->left * (locals.segData[layout->type & CORE_SEGMASK].cols + 1) / 2;
      int top  = layout->top  * (locals.segData[0].rows + 1) / 2;
      int ii   = layout->length;
      UINT16 *seg    = &coreGlobals.segments[layout->start].w;
      const int step = (layout->type & CORE_SEGREV) ? -1 : 1;
      #if defined(VPINMAME) || defined(LIBPINMAME)
        disp_num_segs[n_seg_layouts++] = (UINT8)layout->length;
      #endif
      #ifdef PROC_SUPPORT
        static UINT16 proc_top[16];
        static UINT16 proc_bottom[16];
        int char_width = locals.segData[layout->type & 0x0f].cols+1;
      #endif
      if (step < 0) { seg += ii-1; }
      while (ii--) {
        UINT16 tmpSeg = *seg;
        UINT8  tmpSegDim[16] = { 0 }; // each of the 16 segments per character can be separately dimmed
        #if defined(VPINMAME) || defined(LIBPINMAME)
          UINT8 maxSegDim = 0;
        #endif
        int tmpType = layout->type & CORE_SEGMASK;
        if (coreGlobals.nAlphaSegs && (options.usemodsol & (CORE_MODOUT_FORCE_ON | CORE_MODOUT_ENABLE_PHYSOUT_ALPHASEGS))) {
          int bits = tmpSeg;
          for (int kk = 0; bits; kk++, bits >>= 1) { // loop over max 16 segments of each character
            if (bits & 0x01) {
              UINT8 v = saturatedByte(coreGlobals.physicOutputState[CORE_MODOUT_SEG0 + (layout->start + layout->length - 1 - ii) * 16 + kk].value);
              #if defined(VPINMAME) || defined(LIBPINMAME)
                //!! TODO this evaluates dimming as a whole for the alpha numeric display character while it should be per segment
                if (v > maxSegDim) maxSegDim = v;
              #endif
              tmpSegDim[kk] = 255 - v; // per segment
            }
          }
        }

        // Force an update of the segments ALWAYS (originally only in VPM - corrected Pause Display Bugs)
        if(1) {
          tmpSeg >>= (layout->type & CORE_SEGHIBIT) ? 8 : 0;
          switch (tmpType) {
          case CORE_SEG87: case CORE_SEG87F:
            if ((ii > 0) && (ii % 3 == 0)) { // Handle Comma
              if ((tmpType == CORE_SEG87F) && tmpSeg) tmpSeg |= 0x80;
              tmpType = CORE_SEG8;
            } else
              tmpType = CORE_SEG7;
            break;
          case CORE_SEG98: case CORE_SEG98F:
            tmpSeg |= (tmpSeg & 0x100)<<1;
            if ((ii > 0) && (ii % 3 == 0)) { // Handle Comma
              if ((tmpType == CORE_SEG98F) && tmpSeg) tmpSeg |= 0x80;
              tmpType = CORE_SEG10;
            } else
              tmpType = CORE_SEG9;
            break;
          case CORE_SEG9:
            tmpSeg |= (tmpSeg & 0x100)<<1;
            break;
          }
          #if defined(VPINMAME) || defined(LIBPINMAME)
            seg_dim[seg_idx] = (255 - maxSegDim) >> 4;
            seg_data[seg_idx++] = tmpSeg;
          #endif
          if (!pmoptions.dmd_only || !(layout->fptr || layout->lptr)) {
            drawChar(bitmap, top, left, tmpSeg, tmpType, (coreGlobals.nAlphaSegs && (options.usemodsol & (CORE_MODOUT_FORCE_ON | CORE_MODOUT_ENABLE_PHYSOUT_ALPHASEGS))) ? tmpSegDim : NULL);
            #ifdef PROC_SUPPORT
              if (coreGlobals.p_rocEn) {
                if ((core_gameData->gen & (GEN_WPCALPHA_1 | GEN_WPCALPHA_2 | GEN_ALLS11)) && (!pmoptions.alpha_on_dmd)) {
                  switch (top) {
                  case 0: proc_top[left/char_width + (doubleAlpha == 0)] = tmpSeg; break;
                  case 21:  // This is the ball/credit display if fitted, so work out which position
                    if (left == 12) proc_bottom[0] = tmpSeg;
                    else if (left == 24) proc_bottom[8] = tmpSeg;
                    else if (left == 48) proc_top[0] = tmpSeg;
                    else proc_top[8] = tmpSeg;
                    break;
                  default: proc_bottom[left/char_width + (doubleAlpha == 0)] = tmpSeg; break;
                  }
                }
              }
            #endif
          }
          coreGlobals.drawSeg[pos] = tmpSeg;
        }
        pos++;
        left += locals.segData[layout->type & CORE_SEGALL].cols+1;
        seg += step;
      }
      #ifdef PROC_SUPPORT
        if (coreGlobals.p_rocEn && (core_gameData->gen & (GEN_WPCALPHA_1 | GEN_WPCALPHA_2 | GEN_ALLS11)) && (!pmoptions.alpha_on_dmd))
          procUpdateAlphaDisplay(proc_top, proc_bottom);
      #endif
    }

    #ifdef LIBPINMAME
      libpinmame_update_display(display_index, layout, last_seg_data_ptr);
      last_seg_data_ptr += layout->length;
      display_index++;
    #endif
  }

  // Sends/Renders segment data
  #if defined(VPINMAME) || defined(LIBPINMAME)
    // Some GTS3 games like Teed Off update both empty alpha and real DMD. If a DMD frame has been seen, block this from running.
    if(!has_DMD_Video)
    {
      // Identify alphaseg layout
      const core_segOverallLayout_t alpha_layout = layoutAlphanumericFrame(core_gameData->gen, n_seg_layouts, disp_num_segs, Machine->gamedrv->name);
      assert(alpha_layout != CORE_SEGLAYOUT_Invalid);

      // Port of legacy hack that would call updateDisplay twice, once with the default display (4x7 and 2x2) then once for the additional display (3x2)
      // Now, all of these are processed at once, but we still need to copy the data for external dmddevice.dll backward compatibility
      static UINT16 seg_data2[CORE_SEGCOUNT] = { 0 };
      if ((core_gameData->gen == GEN_BY35) && (disp_num_segs[0] == 7) && (strncasecmp(Machine->gamedrv->name, "medusa", 6) == 0))
         memcpy(seg_data2, seg_data + 4 * 7 + 2 * 2, 3 * 2 * sizeof(UINT16));

      // Sends segment data to dmddevice plugin
      #ifdef VPINMAME
        if(g_fShowPinDMD)
           dmddeviceRenderAlphanumericFrame(alpha_layout, seg_data, seg_data2, seg_dim);
      #endif

      // Render segments into a virtual DMD (at the moment only to pass easily to VP, e.g. tournament mode verification)
      memset(AlphaNumericFrameBuffer,0,sizeof(AlphaNumericFrameBuffer));
      switch (alpha_layout) {
        case CORE_SEGLAYOUT_2x16Alpha: _2x16Alpha(seg_data); break;
        case CORE_SEGLAYOUT_2x20Alpha: _2x20Alpha(seg_data); break;
        case CORE_SEGLAYOUT_2x7Alpha_2x7Num: _2x7Alpha_2x7Num(seg_data); break;
        case CORE_SEGLAYOUT_2x7Alpha_2x7Num_4x1Num: _2x7Alpha_2x7Num_4x1Num(seg_data); break;
        case CORE_SEGLAYOUT_2x7Num_2x7Num_4x1Num: _2x7Num_2x7Num_4x1Num(seg_data); break;
        case CORE_SEGLAYOUT_2x7Num_2x7Num_10x1Num: _2x7Num_2x7Num_10x1Num(seg_data,seg_data2); break;
        case CORE_SEGLAYOUT_2x7Num_2x7Num_4x1Num_gen7: _2x7Num_2x7Num_4x1Num_gen7(seg_data); break;
        case CORE_SEGLAYOUT_2x7Num10_2x7Num10_4x1Num: _2x7Num10_2x7Num10_4x1Num(seg_data); break;
        case CORE_SEGLAYOUT_2x6Num_2x6Num_4x1Num: _2x6Num_2x6Num_4x1Num(seg_data); break;
        case CORE_SEGLAYOUT_2x6Num10_2x6Num10_4x1Num: _2x6Num10_2x6Num10_4x1Num(seg_data); break;
        case CORE_SEGLAYOUT_4x7Num10: _4x7Num10(seg_data); break;
        case CORE_SEGLAYOUT_6x4Num_4x1Num: _6x4Num_4x1Num(seg_data); break;
        case CORE_SEGLAYOUT_2x7Num_4x1Num_1x16Alpha: _2x7Num_4x1Num_1x16Alpha(seg_data); break;
        case CORE_SEGLAYOUT_1x16Alpha_1x16Num_1x7Num: _1x16Alpha_1x16Num_1x7Num(seg_data); break;
        case CORE_SEGLAYOUT_1x7Num_1x16Alpha_1x16Num: _1x7Num_1x16Alpha_1x16Num(seg_data); break;
        case CORE_SEGLAYOUT_1x16Alpha_1x16Num_1x7Num_1x4Num : _1x16Alpha_1x16Num_1x7Num_1x4Num(seg_data); break;
        default: break;
      }
      #ifdef VPINMAME
        g_raw_dmdx = 128;
        g_raw_dmdy = 32;
        for (unsigned int i = 0; i < g_raw_dmdx * g_raw_dmdy; ++i)
          g_raw_dmdbuffer[i] = (UINT8)((int)AlphaNumericFrameBuffer[i] * 100 / 3);
        if (memcmp(old_g_raw_dmdbuffer, g_raw_dmdbuffer, g_raw_dmdx * g_raw_dmdy) != 0) {
          memcpy(old_g_raw_dmdbuffer, g_raw_dmdbuffer, g_raw_dmdx * g_raw_dmdy);
          core_dmd_capture_frame(g_raw_dmdx, g_raw_dmdy, AlphaNumericFrameBuffer, 0, NULL);
          g_needs_DMD_update = 1;
        }
      #elif defined(LIBPINMAME)
        static struct core_dispLayout segDmdDispLayout = { 0, 0, 32, 128, CORE_DMD | CORE_DMDSEG, NULL, NULL };
        libpinmame_update_display(display_index, &segDmdDispLayout, AlphaNumericFrameBuffer);
        display_index++;
      #endif
    }
  #endif
}

VIDEO_UPDATE(core_gen) {
  // Update physic output state:
  // - PinMAME: at 60Hz on display update
  // - PROC: at 60Hz on display update
  // - VPinMAME: on request
  // - LibPinMAME: on request
  #if !defined(LIBPINMAME) && !defined(VPINMAME)
    core_update_pwm_gis();
    core_update_pwm_lamps();
    core_update_pwm_segments();
    core_update_pwm_solenoids();
  #elif defined(VPINMAME) // TODO this works around the missing updated dimmed segments if the VPM-window is running with 'legacy' tables, or when testing it separately
    g_VPM_ignore_pwm_segments_update = (g_fShowWinDMD || g_fShowPinDMD);
    if (g_VPM_ignore_pwm_segments_update && coreGlobals.nAlphaSegs && (options.usemodsol & (CORE_MODOUT_FORCE_ON | CORE_MODOUT_ENABLE_PHYSOUT_ALPHASEGS)))
      core_update_pwm_segments();
  #endif

  // Update displays (alphanumeric segments, video display, large and mini DMDs):
  // - PinMAME: at 60Hz on display update
  // - PROC: at 60Hz on display update if virtual DMD is enabled
  // - VPinMAME: at 60Hz on display update TODO should update here if virtual DMD is enabled, but also update on DMD frame request (at requester pace to limit stuttering)
  // - LibPinMAME: at 60Hz on display update TODO to be defined more precisely
  int need_display_update = 1;
  #ifdef PROC_SUPPORT
    int alpha = (core_gameData->gen & (GEN_WPCALPHA_1|GEN_WPCALPHA_2|GEN_ALLS11)) != 0;
    if (coreGlobals.p_rocEn && pmoptions.alpha_on_dmd && alpha) {
      procClearDMD();
    need_display_update = pmoptions.virtual_dmd;
  #endif
  if (need_display_update)
    updateDisplay(bitmap, cliprect, core_gameData->lcdLayout);
  #ifdef PROC_SUPPORT
    if (coreGlobals.p_rocEn && pmoptions.alpha_on_dmd && alpha) {
      procUpdateDMD();
  #endif

  // Update lamp, solenoids, status LEDs, misc. infos...
  video_update_core_status(bitmap, cliprect);
}

/*---------------------
/  Update all switches
/----------------------*/
void core_updateSw(int flipEn) {
  /*-- handle flippers--*/
  const int flip = core_gameData->hw.flippers;
  const int flipSwCol = (core_gameData->gen & (GEN_GTS3 | GEN_SPA | GEN_ALVG | GEN_ALVG_DMD2 | GEN_WICO)) ? 15 : CORE_FLIPPERSWCOL;
  int inports[CORE_MAXPORTS];
  UINT8 swFlip;
  int ii;

  if (g_fHandleKeyboard) {
    const int n = CORE_COREINPORT+(coreData->coreDips+31)/16;
    for (ii = 0; ii < n; ii++)
      inports[ii] = readinputport(ii);

    /*-- buttons --*/
    swFlip = 0;
    if (inports[CORE_FLIPINPORT] & CORE_LLFLIPKEY) swFlip |= CORE_SWLLFLIPBUTBIT;
    if (inports[CORE_FLIPINPORT] & CORE_LRFLIPKEY) swFlip |= CORE_SWLRFLIPBUTBIT;
    if (locals.flipMask & CORE_SWULFLIPBUTBIT) {    /* have UL switch */
      if (flip & FLIP_BUT(FLIP_UL))
        { if (inports[CORE_FLIPINPORT] & CORE_ULFLIPKEY) swFlip |= CORE_SWULFLIPBUTBIT; }
      else
        { if (inports[CORE_FLIPINPORT] & CORE_LLFLIPKEY) swFlip |= CORE_SWULFLIPBUTBIT; }
    }
    if (locals.flipMask & CORE_SWURFLIPBUTBIT) {    /* have UR switch */
      if (flip & FLIP_BUT(FLIP_UR))
        { if (inports[CORE_FLIPINPORT] & CORE_URFLIPKEY) swFlip |= CORE_SWURFLIPBUTBIT; }
      else
        { if (inports[CORE_FLIPINPORT] & CORE_LRFLIPKEY) swFlip |= CORE_SWURFLIPBUTBIT; }
    }
  }
  else
    swFlip = (coreGlobals.swMatrix[flipSwCol] ^ coreGlobals.invSw[flipSwCol]) & (CORE_SWULFLIPBUTBIT|CORE_SWURFLIPBUTBIT|CORE_SWLLFLIPBUTBIT|CORE_SWLRFLIPBUTBIT);

#ifdef PROC_SUPPORT
  /*-- Only handle flipper switches if we're not in a real game, otherwise they --*/
  /*-- will get physically activated anyway */
  if (!coreGlobals.p_rocEn) {
#endif

    /*-- set switches in matrix for non-fliptronic games --*/
    if (FLIP_SWL(flip)) core_setSw(FLIP_SWL(flip), swFlip & CORE_SWLLFLIPBUTBIT);
    if (FLIP_SWR(flip)) core_setSw(FLIP_SWR(flip), swFlip & CORE_SWLRFLIPBUTBIT);
#ifdef PROC_SUPPORT
  }
#endif

  /*-- fake solenoids if not CPU controlled --*/
  if ((flip & FLIP_SOL(FLIP_L)) == 0) {
    coreGlobals.solenoids2 &= 0xffffff00;
    if (flipEn) {
      if (swFlip & CORE_SWLLFLIPBUTBIT) coreGlobals.solenoids2 |= CORE_LLFLIPSOLBITS;
      if (swFlip & CORE_SWLRFLIPBUTBIT) coreGlobals.solenoids2 |= CORE_LRFLIPSOLBITS;
    }
  }

  /*-- EOS switches --*/
  if (locals.flipMask & CORE_SWULFLIPEOSBIT) {
    if (core_getSol(sULFlip)) locals.flipTimer[0] += 1;
    else                      locals.flipTimer[0] = 0;
    if (locals.flipTimer[0] >= CORE_FLIPSTROKETIME) swFlip |= CORE_SWULFLIPEOSBIT;
  }
  if (locals.flipMask & CORE_SWURFLIPEOSBIT) {
    if (core_getSol(sURFlip)) locals.flipTimer[1] += 1;
    else                      locals.flipTimer[1] = 0;
    if (locals.flipTimer[1] >= CORE_FLIPSTROKETIME) swFlip |= CORE_SWURFLIPEOSBIT;
  }
  if (locals.flipMask & CORE_SWLLFLIPEOSBIT) {
    if (core_getSol(sLLFlip)) locals.flipTimer[2] += 1;
    else                      locals.flipTimer[2] = 0;
    if (locals.flipTimer[2] >= CORE_FLIPSTROKETIME) swFlip |= CORE_SWLLFLIPEOSBIT;
  }
  if (locals.flipMask & CORE_SWLRFLIPEOSBIT) {
    if (core_getSol(sLRFlip)) locals.flipTimer[3] += 1;
    else                      locals.flipTimer[3] = 0;
    if (locals.flipTimer[3] >= CORE_FLIPSTROKETIME) swFlip |= CORE_SWLRFLIPEOSBIT;
  }
  coreGlobals.swMatrix[flipSwCol] = (coreGlobals.swMatrix[flipSwCol]         & ~locals.flipMask) |
                                    ((swFlip ^ coreGlobals.invSw[flipSwCol]) &  locals.flipMask);

  /*-- update core dependent switches --*/
  if (coreData->updSw)  coreData->updSw(g_fHandleKeyboard ? inports : NULL);

  /*-- update game dependent switches --*/
  if (g_fHandleMechanics) {
    if (core_gameData->hw.handleMech) core_gameData->hw.handleMech(g_fHandleMechanics);
  }

  /*-- run simulator --*/
  if (coreGlobals.simAvail)
    sim_run(inports, CORE_COREINPORT+(coreData->coreDips+31)/16,
            (inports[CORE_SIMINPORT] & SIM_SWITCHKEY) == 0,
            (SIM_BALLS(inports[CORE_SIMINPORT])));

  /*-- Report changed solenoids --*/
  if (coreGlobals.nSolenoids && 
     ((options.usemodsol & (CORE_MODOUT_ENABLE_PHYSOUT_SOLENOIDS | CORE_MODOUT_FORCE_ON)) || ((core_gameData->gen & (GEN_ALLWPC | GEN_SAM)) && (options.usemodsol & CORE_MODOUT_ENABLE_MODSOL)) ))
  {
    float state[CORE_MODOUT_SOL_MAX];
    core_getAllPhysicSols(state);
    for (ii = 1; ii <= coreGlobals.nSolenoids; ii++) {
      UINT8 v = saturatedByte(state[ii - 1]);
      if (v != locals.lastPhysicsOutput[CORE_MODOUT_SOL0 + ii - 1]) {
        #ifdef LIBPINMAME
        OnSolenoid(ii, v);
        #else
        if ((v > 128) != (locals.lastPhysicsOutput[CORE_MODOUT_SOL0 + ii - 1] > 128)) {
          OnSolenoid(ii, v);
          /*-- log solenoid number on the display (except flippers) --*/
          if ((!pmoptions.dmd_only && ((ii < CORE_FIRSTLFLIPSOL) || (ii >= CORE_FIRSTSIMSOL)))) {
            locals.solLog[locals.solLogCount] = ii;
            core_textOutf(Machine->visible_area.max_x - 12 * 8, 0, BLACK, "%2d %2d %2d %2d",
              locals.solLog[(locals.solLogCount + 1) & 3],
              locals.solLog[(locals.solLogCount + 2) & 3],
              locals.solLog[(locals.solLogCount + 3) & 3],
              locals.solLog[(locals.solLogCount + 0) & 3]);
            locals.solLogCount = (locals.solLogCount + 1) & 3;
          }
          #ifdef ENABLE_MECHANICAL_SAMPLES
          if (coreGlobals.soundEn)
            proc_mechsounds(ii, v > 128);
          #endif
        }
        #endif
        locals.lastPhysicsOutput[CORE_MODOUT_SOL0 + ii - 1] = v;
      }
    }
  }
  else {
    UINT64 allSol = core_getAllSol();
    UINT64 chgSol = (allSol ^ locals.lastSol) & vp_getSolMask64();
    locals.lastSol = allSol;
    for (ii = 1; ii < CORE_FIRSTCUSTSOL + core_gameData->hw.custSol; ii++)
    {
      if (chgSol & 0x01) {
        OnSolenoid(ii, allSol & 0x01);
        /*-- log solenoid number on the display (except flippers) --*/
        if ((!pmoptions.dmd_only && (allSol & 0x01)) && ((ii < CORE_FIRSTLFLIPSOL) || (ii >= CORE_FIRSTSIMSOL))) {
          locals.solLog[locals.solLogCount] = ii;
          core_textOutf(Machine->visible_area.max_x - 12 * 8, 0, BLACK, "%2d %2d %2d %2d",
            locals.solLog[(locals.solLogCount + 1) & 3],
            locals.solLog[(locals.solLogCount + 2) & 3],
            locals.solLog[(locals.solLogCount + 3) & 3],
            locals.solLog[(locals.solLogCount + 0) & 3]);
          locals.solLogCount = (locals.solLogCount + 1) & 3;
        }
        #ifdef ENABLE_MECHANICAL_SAMPLES
        if (coreGlobals.soundEn)
           proc_mechsounds(ii, allSol & 0x01);
        #endif
      }
      chgSol >>= 1;
      allSol >>= 1;
    }
  }

  /*-- check if we should use simulator keys --*/
  if (g_fHandleKeyboard &&
      (!coreGlobals.simAvail || inports[CORE_SIMINPORT] & SIM_SWITCHKEY)) {
    /*-- simulator keys disabled, use row+column keys --*/

    static int lastRow = 0, lastCol = 0;
    int row = 0, col = 0;
#ifdef MAME_DEBUG
    if (keyboard_pressed(KEYCODE_Z)) col = 9;
    if (keyboard_pressed(KEYCODE_X)) col = 10;
    if (keyboard_pressed(KEYCODE_C)) col = 11;
    if (keyboard_pressed(KEYCODE_V)) col = 12;
#endif
    if (!col && (((inports[CORE_MANSWINPORT] & CORE_MANSWCOLUMNS) == 0) ||
        ((inports[CORE_MANSWINPORT] & CORE_MANSWROWS) == 0)))
      lastRow = lastCol = 0;
    else {
      int bit = 0x0101;

      for (ii = 0; ii < 8; ii++) {
        if (inports[CORE_MANSWINPORT] & CORE_MANSWCOLUMNS & bit) col = ii+1;
        if (inports[CORE_MANSWINPORT] & CORE_MANSWROWS    & bit) row = ii+1;
        bit <<= 1;
      }
      if ((col != lastCol) || (row != lastRow)) {
        coreGlobals.swMatrix[col] ^= (1<<(row-1));
        lastCol = col; lastRow = row;
      }
    }
  }

#ifdef MAME_DEBUG /* Press W and E at the same time to insert a mark in logfile */
  if (g_fHandleKeyboard && ((inports[CORE_MANSWINPORT] & 0x06) == 0x06))
    logerror("\nLogfile Mark\n");
#endif /* MAME_DEBUG */
}

/*--------------------------
/ Write text on the screen
/---------------------------*/
void core_textOut(const char *buf, int length, int x, int y, int color) {
  if (y < locals.maxSimRows) {
    int ii;

    const int l = (int)strlen(buf);
    for (ii = 0; ii < length; ii++) {
      const char c = (ii >= l) ? ' ' : buf[ii];

      drawgfx(Machine->scrbitmap, Machine->uifont, c, color-1, 0, 0,
              x + ii * Machine->uifont->width, y+locals.firstSimRow, 0,
              TRANSPARENCY_NONE, 0);
    }
  }
}

/*-----------------------------------
/ Write formatted text on the screen
/------------------------------------*/
void CLIB_DECL core_textOutf(int x, int y, int color, const char *text, ...) {
  va_list arg;
  if (y < locals.maxSimRows) {
    char buf[100];
    char *bufPtr = buf;

    va_start(arg, text); vsprintf(buf, text, arg); va_end(arg);

    while (*bufPtr) {
      drawgfx(Machine->scrbitmap, Machine->uifont, *bufPtr++, color-1, 0, 0,
              x, y+locals.firstSimRow, 0, TRANSPARENCY_NONE, 0);
      x += Machine->uifont->width;
    }
  }
}

/*--------------------------------------------
/ Draw status display
/ Lamps, Switches, Solenoids, Diagnostic LEDs
/---------------------------------------------*/
static VIDEO_UPDATE(core_status) {
  BMTYPE **lines = (BMTYPE **)bitmap->line;
  int startRow = 0, nextCol = 0, thisCol = 0;
  int ii, jj;
  BMTYPE dotColor[2];

  /*-- anything to do ? --*/
  if ((pmoptions.dmd_only) || (locals.maxSimRows < 16) ||
      (coreGlobals.soundEn && (!manual_sound_commands(bitmap))))
    return;

  dotColor[0] = Machine->pens[COL_DMDOFF]; dotColor[1] = Machine->pens[COL_DMDON];
  /*--  Draw lamps --*/
  if ((core_gameData->hw.lampData) &&
      (startRow + core_gameData->hw.lampData->startpos.x + core_gameData->hw.lampData->size.x < locals.maxSimRows)) {
    core_tLampDisplay *drawData = core_gameData->hw.lampData;
    const int startx = drawData->startpos.x;
    const int starty = drawData->startpos.y + thisCol;
    BMTYPE **line = &lines[locals.firstSimRow + startRow + startx];
    int num = 0;

    for (ii = 0; ii < CORE_CUSTLAMPCOL+core_gameData->hw.lampCol; ii++) {
      int bits = coreGlobals.lampMatrix[ii];

      for (jj = 0; jj < 8; jj++) {
        int qq;
        for (qq = 0; qq < drawData->lamps[num].totnum; qq++) {
          const int lampx = drawData->lamps[num].lamppos[qq].x;
          const int lampy = drawData->lamps[num].lamppos[qq].y;
          if (options.usemodsol & (CORE_MODOUT_ENABLE_PHYSOUT_LAMPS | CORE_MODOUT_FORCE_ON)) {
            UINT8 v = saturatedByte(coreGlobals.physicOutputState[CORE_MODOUT_LAMP0 + ii * 8 + jj].value);
            line[lampx][starty + lampy] = LAMP_PAL(v);
          }
          else {
            const int color = drawData->lamps[num].lamppos[qq].color;
            line[lampx][starty + lampy] = Machine->pens[(bits & 0x01) ? color : COL_SHADE(color)];
          }
        }
        bits >>= 1;
        num++;
      }
    }
    startRow += startx + drawData->size.x;
    if (starty + drawData->size.y > nextCol) nextCol = starty + drawData->size.y;
  }
  /*-- Default square lamp matrix layout --*/
  else {
    assert((coreGlobals.nLamps == 0) || ((coreGlobals.nLamps + 7) >> 3 == CORE_CUSTLAMPCOL + core_gameData->hw.lampCol));
    for (ii = 0; ii < CORE_CUSTLAMPCOL + core_gameData->hw.lampCol; ii++) {
      BMTYPE** line = &lines[locals.firstSimRow + startRow];
      int bits = coreGlobals.lampMatrix[ii];
      for (jj = 0; jj < 8; jj++) {
        if (options.usemodsol & (CORE_MODOUT_ENABLE_PHYSOUT_LAMPS | CORE_MODOUT_FORCE_ON)) {
          UINT8 v = saturatedByte(coreGlobals.physicOutputState[CORE_MODOUT_LAMP0 + ii * 8 + jj].value);
          line[0][thisCol + ii * 2] = LAMP_PAL(v);
        } else
          line[0][thisCol + ii * 2] = dotColor[bits & 0x01];
        line += 2; bits >>= 1;
      }
    }
    startRow += 16; if (thisCol + ii*2 > nextCol) nextCol = thisCol + ii*2;
  } /* else */

  /* Draw the switches */
  startRow += 3;
  if (startRow + 16 >= locals.maxSimRows) { startRow = 0; thisCol = nextCol + 5; }

  for (ii = 0; ii < CORE_CUSTSWCOL+core_gameData->hw.swCol; ii++) {
    BMTYPE **line = &lines[locals.firstSimRow + startRow];
    int bits = coreGlobals.swMatrix[ii];

    for (jj = 0; jj < 8; jj++) {
      line[0][thisCol + ii*2] = dotColor[bits & 0x01];
      line += 2; bits >>= 1;
    }
  }
  startRow += 16; if (thisCol + ii*2 > nextCol) nextCol = thisCol + ii*2;

  /* Draw Solenoids and Flashers */
  startRow += 3;

  if (startRow + 16 >= locals.maxSimRows) { startRow = 0; thisCol = nextCol + 5; }

  {
    BMTYPE **line = &lines[locals.firstSimRow + startRow];
    if (options.usemodsol & (CORE_MODOUT_ENABLE_PHYSOUT_SOLENOIDS | CORE_MODOUT_ENABLE_MODSOL | CORE_MODOUT_FORCE_ON))
    {
      float state[CORE_MODOUT_SOL_MAX];
      core_getAllPhysicSols(state);
      for (ii = 0; ii < coreGlobals.nSolenoids; ii++) {
         line[(ii / 8) * 2][thisCol + (ii % 8) * 2] = LAMP_PAL(saturatedByte(state[ii]));
      }
    }
    else
    {
      UINT64 allSol = core_getAllSol();
      for (ii = 0; ii < CORE_FIRSTCUSTSOL + core_gameData->hw.custSol; ii++) {
        line[(ii / 8) * 2][thisCol + (ii % 8) * 2] = dotColor[allSol & 0x01];
        allSol >>= 1;
      }
    }
    startRow += 16; if (thisCol + 16 > nextCol) nextCol = thisCol + 16;
  }

  /*-- draw diagnostic LEDs     --*/
  startRow += 3;

  if (startRow + 16 >= locals.maxSimRows) { startRow = 0; thisCol = nextCol; }

  if (coreData->diagLEDs == 0xff) { /* 7 SEG */
    drawChar(bitmap, locals.firstSimRow + startRow, thisCol, coreGlobals.diagnosticLed, CORE_SEG7, 0);
    startRow += 16; if (thisCol + 12 > nextCol) nextCol = thisCol + 12;
  }
  else {
    BMTYPE **line = &lines[locals.firstSimRow + startRow];
    int bits = coreGlobals.diagnosticLed;

    // Draw LEDs Vertically
    if (coreData->diagLEDs & DIAGLED_VERTICAL) {
      const int n = (coreData->diagLEDs & ~DIAGLED_VERTICAL);
      for (ii = 0; ii < n; ii++) {
        line[0][thisCol + 3] = dotColor[bits & 0x01];
        line += 2; bits >>= 1;
      }
      startRow += ii*2; if (thisCol + 4 > nextCol) nextCol = thisCol + 4;
    }
    else { // Draw LEDs Horizontally
      const int n = coreData->diagLEDs;
      for (ii = 0; ii < n; ii++) {
        line[0][thisCol + ii*2] = dotColor[bits & 0x01];
        bits >>= 1;
      }
      startRow += 1; if (thisCol + ii*2 > nextCol) nextCol = thisCol + ii*2;
    }
  }
  /*-- GI Strings --*/
  if (core_gameData->gen & GEN_ALLWPC) {
    startRow += 3;
    if (startRow + 2 >= locals.maxSimRows) { startRow = 0; thisCol = nextCol + 5; }

    for (ii = 0; ii < CORE_MAXGI; ii++)
    {
      if (options.usemodsol & (CORE_MODOUT_ENABLE_PHYSOUT_GI | CORE_MODOUT_FORCE_ON))
      {
        UINT8 v = saturatedByte(coreGlobals.physicOutputState[CORE_MODOUT_GI0 + ii].value);
        lines[locals.firstSimRow + startRow][thisCol + ii * 2] = LAMP_PAL(v);
      }
      else if (coreGlobals.gi[ii] == 8)
        lines[locals.firstSimRow + startRow][thisCol + ii*2] = dotColor[1];
      else
        lines[locals.firstSimRow + startRow][thisCol + ii*2] = 64+(coreGlobals.gi[ii]<<1);
    }
  }
  if (coreGlobals.simAvail) sim_draw(locals.firstSimRow);
  /*-- draw game specific mechanics --*/
  if (core_gameData->hw.drawMech) core_gameData->hw.drawMech((void *)&bitmap->line[locals.firstSimRow]);
}

/*-- lamp handling --*/
void core_setLamp(volatile UINT8 *lampMatrix, int col, int row) {
  while (col) {
    if (col & 0x01) *lampMatrix |= row;
    col >>= 1;
    lampMatrix += 1;
  }
}
void core_setLampBlank(volatile UINT8 *lampMatrix, int col, int row) {
  while (col) {
    if (col & 0x01) *lampMatrix = row;
    col >>= 1;
    lampMatrix += 1;
  }
}

/*-- "normal" switch/lamp numbering (1-64) --*/
int core_swSeq2m(int no) { return no+7; }
int core_m2swSeq(int col, int row) { return col*8+row-7; }

/*------------------------------------------
/  Read the current switch value
/
/  This function returns TRUE for active
/  switches even if the switch is active low.
/-------------------------------------------*/
int core_getSw(int swNo) {
  if (coreData->sw2m) swNo = coreData->sw2m(swNo); else swNo = (swNo/10)*8+(swNo%10-1);
  return (coreGlobals.swMatrix[swNo/8] ^ coreGlobals.invSw[swNo/8]) & (1<<(swNo%8));
}

int core_getSwCol(int colEn) {
  int ii = 1;
  if (colEn) {
    while ((colEn & 0x01) == 0) {
      colEn >>= 1;
      ii++;
    }
  }
  return coreGlobals.swMatrix[ii];
}

/*----------------------
/  Set/reset a switch
/-----------------------*/
void core_setSw(int swNo, int value) {
  if (coreData->sw2m) swNo = coreData->sw2m(swNo); else swNo = (swNo/10)*8+(swNo%10-1);
  //fprintf(stderr,"\nPinMAME switch %d",swNo);
  coreGlobals.swMatrix[swNo/8] &= ~(1<<(swNo%8)); /* clear the bit first */
#ifdef PROC_SUPPORT
   if (coreGlobals.p_rocEn) {
      coreGlobals.swMatrix[swNo/8] |=  ((value ? 0xff : 0) ^ 0) & (1<<(swNo%8));
   } else {
#endif

  coreGlobals.swMatrix[swNo/8] |=  ((value ? 0xff : 0) ^ coreGlobals.invSw[swNo/8]) & (1<<(swNo%8));
#ifdef PROC_SUPPORT
   }
#endif
}

/*-------------------------
/  update active low/high
/-------------------------*/
void core_updInvSw(int swNo, int inv) {
  int bit;
  if (coreData->sw2m) swNo = coreData->sw2m(swNo); else swNo = (swNo/10)*8+(swNo%10-1);
  bit = (1 << (swNo%8));

  if (inv)
    inv = bit;
  if ((coreGlobals.invSw[swNo/8] ^ inv) & bit) {
    coreGlobals.invSw[swNo/8] ^= bit;
    coreGlobals.swMatrix[swNo/8] ^= bit;
  }
}

/*-------------------------------------
/  Read the status of a solenoid
/  For the standard solenoids this is
/  the "smoothed" value
/--------------------------------------*/
int core_getSol(int solNo) {
  if (solNo <= 28)
    return coreGlobals.nSolenoids && (options.usemodsol & (CORE_MODOUT_ENABLE_PHYSOUT_SOLENOIDS | CORE_MODOUT_ENABLE_MODSOL | CORE_MODOUT_FORCE_ON)) ? saturatedByte(coreGlobals.physicOutputState[CORE_MODOUT_SOL0 + solNo - 1].value) : coreGlobals.solenoids & CORE_SOLBIT(solNo);
  else if (solNo <= 32) { // 29-32
    if (core_gameData->gen & GEN_ALLS11)
      return coreGlobals.nSolenoids && (options.usemodsol & (CORE_MODOUT_ENABLE_PHYSOUT_SOLENOIDS | CORE_MODOUT_ENABLE_MODSOL | CORE_MODOUT_FORCE_ON)) ? saturatedByte(coreGlobals.physicOutputState[CORE_MODOUT_SOL0 + solNo - 1].value) : coreGlobals.solenoids & CORE_SOLBIT(solNo);
    else if (core_gameData->gen & GEN_ALLWPC) // WPC GameOn
      return coreGlobals.solenoids2 & (1<<(solNo-29+8));
  }
  else if (solNo <= 36) { // 33-36 driver specific sols
    if (core_gameData->gen & GEN_ALLWPC) { // WPC only: Upper flipper 
      if ((core_gameData->gen & (GEN_WPCFLIPTRON | GEN_WPCDCS | GEN_WPCSECURITY | GEN_WPC95 | GEN_WPC95DCS)) && (coreGlobals.nSolenoids && (options.usemodsol & (CORE_MODOUT_ENABLE_PHYSOUT_SOLENOIDS | CORE_MODOUT_ENABLE_MODSOL | CORE_MODOUT_FORCE_ON))))
        return saturatedByte(coreGlobals.physicOutputState[CORE_MODOUT_SOL0 + solNo - 1].value);
      int mask;
      /*-- flipper coils --*/
      if      ((solNo == sURFlip) && (core_gameData->hw.flippers & FLIP_SOL(FLIP_UR)))
        mask = CORE_URFLIPSOLBITS;
      else if ((solNo == sULFlip) && (core_gameData->hw.flippers & FLIP_SOL(FLIP_UL)))
        mask = CORE_ULFLIPSOLBITS;
      else
        mask = 1<<(solNo - 33 + 4);
      return coreGlobals.solenoids2 & mask;
    }
    else if (core_gameData->gen & GEN_SAM) // SAM only: fake GameOn solenoid for fast flips
       return coreGlobals.solenoids2 & 0x10;
  }
  else if (solNo <= 44) { // 37-44 WPC95 & S11 extra
    if (core_gameData->gen & (GEN_WPC95|GEN_WPC95DCS)) // Duplicated in 37..40 / 41..44, so always read from 41..44 (hence the |4 in the index/mask)
      return coreGlobals.nSolenoids && (options.usemodsol & (CORE_MODOUT_ENABLE_PHYSOUT_SOLENOIDS | CORE_MODOUT_ENABLE_MODSOL | CORE_MODOUT_FORCE_ON)) ? saturatedByte(coreGlobals.physicOutputState[CORE_MODOUT_SOL0 + ((solNo - 13) | 4)].value) : coreGlobals.solenoids & (1<<((solNo - 13)|4));
    if (core_gameData->gen & GEN_ALLS11)
      return coreGlobals.nSolenoids && (options.usemodsol & (CORE_MODOUT_ENABLE_PHYSOUT_SOLENOIDS | CORE_MODOUT_ENABLE_MODSOL | CORE_MODOUT_FORCE_ON)) ? saturatedByte(coreGlobals.physicOutputState[CORE_MODOUT_SOL0 + 32 + solNo - 37 + 8].value) : coreGlobals.solenoids2 & (1<<(solNo - 37 + 8));
  }
  else if (solNo <= 48) { // 45-48 Lower flippers
    if ((core_gameData->gen & (GEN_WPCFLIPTRON | GEN_WPCDCS | GEN_WPCSECURITY | GEN_WPC95 | GEN_WPC95DCS)) && (coreGlobals.nSolenoids && (options.usemodsol & (CORE_MODOUT_ENABLE_PHYSOUT_SOLENOIDS | CORE_MODOUT_ENABLE_MODSOL | CORE_MODOUT_FORCE_ON))))
      return saturatedByte(coreGlobals.physicOutputState[CORE_MODOUT_SOL0 + solNo - 1].value);
    int mask = 1<<(solNo - 45);
    /*-- Game must have lower flippers but for symmetry we check anyway --*/
    if      /*(*/(solNo == sLRFlip) //&& (core_gameData->hw.flippers & FLIP_SOL(FLIP_LR)))
      mask = CORE_LRFLIPSOLBITS;
    else if /*(*/(solNo == sLLFlip) //&& (core_gameData->hw.flippers & FLIP_SOL(FLIP_LL)))
      mask = CORE_LLFLIPSOLBITS;
    return coreGlobals.solenoids2 & mask;
  }
  else if (solNo <= 50) // 49-50 simulated
    return sim_getSol(solNo);
  else if (core_gameData->hw.getSol)
    return core_gameData->hw.getSol(solNo);
  return 0;
}

/*-------------------------------------
/  Read the instant status of a solenoid
/--------------------------------------*/
int core_getPulsedSol(int solNo) {
  if (solNo <= 32)
    return coreGlobals.pulsedSolState & CORE_SOLBIT(solNo);
  else if ((core_gameData->gen & (GEN_WPC95|GEN_WPC95DCS)) && (solNo >= 37) && (solNo <= 44))
    // This is a little messy. Pulsed state is in 29-32 but 29-32 non pulsed is GameOn sol
    return coreGlobals.pulsedSolState & (1<<((solNo-13)|4));
  return core_getSol(solNo); /* sol is not smoothed anyway */
}

/*-------------------------------------------------
/  Get the value of all solenoids in one variable
/--------------------------------------------------*/
UINT64 core_getAllSol(void) {
  UINT64 sol = coreGlobals.solenoids;
  if (core_gameData->gen & GEN_ALLWPC) // 29-32 GameOn
    sol = (sol & 0x0fffffffull) | ((coreGlobals.solenoids2 & 0x0f00ull)<<20);
  if (core_gameData->gen & (GEN_WPC95|GEN_WPC95DCS)) { // 37-44 WPC95 extra, duplicated at 0x......XX........
    UINT64 tmp = coreGlobals.solenoids & 0xf0000000;
    sol |= (tmp<<12)|(tmp<<8);
  }
  if (core_gameData->gen & GEN_ALLWPC) { // 33-36 WPC upper flipper solenoids (hold coil is set if either coil is set)
    UINT8 uFlip = (coreGlobals.solenoids2 & (CORE_URFLIPSOLBITS|CORE_ULFLIPSOLBITS));
    if (core_gameData->hw.flippers & FLIP_SOL(FLIP_UR))
      uFlip |= (uFlip & 0x10)<<1;
    if (core_gameData->hw.flippers & FLIP_SOL(FLIP_UL))
      uFlip |= (uFlip & 0x40)<<1;
    sol |= (((UINT64)uFlip)<<28);
  }
  else if (core_gameData->gen & GEN_SAM) // 33 SAM fake GameOn sol for fast flips
     sol |= (((UINT64)(coreGlobals.solenoids2 & 0x10)) << 28);
  else if (core_gameData->gen & GEN_ALLWS) // 33..36 various aux board outputs
     sol |= ((UINT64)(coreGlobals.solenoids2 & 0x00f0)) << 28;
  if (core_gameData->gen & (GEN_ALLS11 | GEN_SAM | GEN_SPA)) // 37-44 S11, SAM extra
     sol |= ((UINT64)(coreGlobals.solenoids2 & 0xff00)) << 28;
  { // 45-48 flipper solenoids (hold coil is set if either coil is set)
    UINT8 lFlip = (coreGlobals.solenoids2 & (CORE_LRFLIPSOLBITS|CORE_LLFLIPSOLBITS));
    lFlip |= (lFlip & 0x05)<<1;
    sol |= (((UINT64)lFlip)<<44);
  }
  /*-- simulated --*/
  sol |= sim_getSol(49) ? (((UINT64)1)<<48) : 0;
  /*-- custom --*/
  if ( core_gameData->hw.getSol ) {
    UINT64 bit = ((UINT64)1)<<(CORE_FIRSTCUSTSOL-1);
    int ii;
    for (ii = 0; ii < core_gameData->hw.custSol; ii++) {
      sol |= core_gameData->hw.getSol(CORE_FIRSTCUSTSOL + ii) ? bit : 0;
      bit <<= 1;
    }
  }
  return sol;
}

/*-------------------------------------------------
/  Get the modulated value of all solenoids in the provided array
/--------------------------------------------------*/
void core_getAllPhysicSols(float* const state)
{
  assert(coreGlobals.nSolenoids && (options.usemodsol & (CORE_MODOUT_ENABLE_PHYSOUT_SOLENOIDS | CORE_MODOUT_ENABLE_MODSOL | CORE_MODOUT_FORCE_ON)));
  memset(state, 0, CORE_MODOUT_SOL_MAX * sizeof(float)); // To avoid reporting garbage states for unused solenoid slots
  if (core_gameData->gen & GEN_ALLWPC) {
     /*-- 1..28, hardware solenoids --*/
     for (int i = 0; i < 28; i++)
      state[i] = coreGlobals.physicOutputState[CORE_MODOUT_SOL0 + i].value;
    // 29..32 GameOn (not modulated, stored in 0x0700 of solenoids2)
    for (int i = 28; i < 32; i++)
      state[i] = coreGlobals.solenoids2 & (1 << (i - 28 + 8)) ? 1.0f : 0.0f;
  }
  else
     /*-- 29..32, hardware solenoids --*/
     for (int i = 0; i < 32; i++)
      state[i] = coreGlobals.physicOutputState[CORE_MODOUT_SOL0 + i].value;
  /*-- 33..36 [WPC only] upper flipper solenoids --*/
  if (core_gameData->gen & GEN_ALLWPC) {
    if ((core_gameData->gen & (GEN_WPCFLIPTRON | GEN_WPCDCS | GEN_WPCSECURITY | GEN_WPC95 | GEN_WPC95DCS)) && (coreGlobals.nSolenoids && (options.usemodsol & (CORE_MODOUT_ENABLE_PHYSOUT_SOLENOIDS | CORE_MODOUT_ENABLE_MODSOL | CORE_MODOUT_FORCE_ON))))
      for (int i = 32; i < 36; i++)
        state[i] = coreGlobals.physicOutputState[CORE_MODOUT_SOL0 + i].value;
    else {
      UINT8 uFlip = (coreGlobals.solenoids2 & (CORE_URFLIPSOLBITS | CORE_ULFLIPSOLBITS));
      if (core_gameData->hw.flippers & FLIP_SOL(FLIP_UR))
        uFlip = uFlip | ((uFlip & 0x10)<<1);
      if (core_gameData->hw.flippers & FLIP_SOL(FLIP_UL))
        uFlip = uFlip | ((uFlip & 0x40)<<1);
      state[32] = uFlip & 0x10 ? 1.0f : 0.0f;
      state[33] = uFlip & 0x20 ? 1.0f : 0.0f;
      state[34] = uFlip & 0x40 ? 1.0f : 0.0f;
      state[35] = uFlip & 0x80 ? 1.0f : 0.0f;
    }
  }
  /*-- 33 [SAM only] fake GameOn solenoid for fast flips --*/
  else if (core_gameData->gen & GEN_SAM)
    state[32] = coreGlobals.physicOutputState[CORE_MODOUT_SOL0 + 33 - 1].value;
  /*-- 33..36 Whitestar various aux board outputs --*/
  else if (core_gameData->gen & GEN_ALLWS)
     for (int i = 32; i < 36; i++)
        state[i] = coreGlobals.physicOutputState[CORE_MODOUT_SOL0 + i].value;
  /*-- 37..44, extra solenoids --*/
  if (core_gameData->gen & (GEN_WPC95 | GEN_WPC95DCS)) { // 37-44 WPC95 extra (duplicated 37..40 / 41..44)
    for (int i = 28; i < 32; i++) {
      state[i +  8] = coreGlobals.physicOutputState[CORE_MODOUT_SOL0 + i].value;
      state[i + 12] = coreGlobals.physicOutputState[CORE_MODOUT_SOL0 + i].value;
    }
  }
  else if (core_gameData->gen & (GEN_ALLS11 | GEN_SAM | GEN_SPA)) // 37-44 S11, SAM extra
    for (int i = 40; i < 48; i++)
      state[i - 4] = coreGlobals.physicOutputState[CORE_MODOUT_SOL0 + i].value;
  /*-- 45..48 lower flipper solenoids (only modulated for WPC) --*/
  if ((core_gameData->gen & (GEN_WPCFLIPTRON | GEN_WPCDCS | GEN_WPCSECURITY | GEN_WPC95 | GEN_WPC95DCS)) && (coreGlobals.nSolenoids && (options.usemodsol & (CORE_MODOUT_ENABLE_PHYSOUT_SOLENOIDS | CORE_MODOUT_ENABLE_MODSOL | CORE_MODOUT_FORCE_ON))))
    for (int i = 44; i < 48; i++)
      state[i] = coreGlobals.physicOutputState[CORE_MODOUT_SOL0 + i].value;
  else {
    UINT8 lFlip = (coreGlobals.solenoids2 & (CORE_LRFLIPSOLBITS|CORE_LLFLIPSOLBITS));
    lFlip |= (lFlip & 0x05)<<1; // hold coil is set if either coil is set
    state[44] = lFlip & 0x01 ? 1.0f : 0.0f;
    state[45] = lFlip & 0x02 ? 1.0f : 0.0f;
    state[46] = lFlip & 0x04 ? 1.0f : 0.0f;
    state[47] = lFlip & 0x08 ? 1.0f : 0.0f;
  }
  /*-- 49..50 simulated --*/
  state[48] = sim_getSol(49) ? 1.0f : 0.0f;
  //state[49] = 0.0f; // unused reserved simulated solenoid
  /*-- 51..66 custom --*/
  for (int i = 0; i < core_gameData->hw.custSol; i++) {
    int sol = CORE_FIRSTCUSTSOL - 1 + i;
    state[sol] = sol < coreGlobals.nSolenoids ? coreGlobals.physicOutputState[CORE_MODOUT_SOL0 + sol].value : (core_gameData->hw.getSol ? (core_gameData->hw.getSol(sol + 1) ? 1.0f : 0.0f) : 0.0f);
  }
}

/*---------------------------------------
/  Get the status of a DIP bank (8 dips)
/-----------------------------------------*/
int core_getDip(int dipBank) {
#if defined(VPINMAME) || defined(LIBPINMAME)
  return vp_getDIP(dipBank);
#else /* VPINMAME */
  return (readinputport(CORE_COREINPORT+1+dipBank/2)>>((dipBank & 0x01)*8))&0xff;
#endif /* VPINMAME */
}

/*--------------------
/   Draw a LED digit
/---------------------*/
static void drawChar(struct mame_bitmap *bitmap, int row, int col, UINT16 seg_bits, int type, UINT8 dimming[16]) {
  const tSegData *s = &locals.segData[type];
  UINT32 pixel[20] = {0}; // max 20 rows
  UINT8 dim[20][15] = {{0}}; // max 20 rows, 15 cols
  int sb, kk, ll;
  for (sb = 1; seg_bits; sb++, seg_bits >>= 1) { // loop over each segment
    if (seg_bits & 0x01) {
      #ifdef PROC_SUPPORT
        if (coreGlobals.p_rocEn && pmoptions.alpha_on_dmd) {
          /* Draw alphanumeric segments on the DMD */
          switch (row) {
          case 0:
            procDrawSegment(col/2, 3,sb-1);
            break;
          case 21:
            // This is the ball/credit display on older Sys11
            // Push through an 11 as the row
            // number, the display routine will
            // take care of repositioning
            procDrawSegment(col/2,11,sb-1);
            break;
          case 42:
            procDrawSegment(col/2,19,sb-1);
            break;
          default:
            break;
          }
        }
      #endif
      for (kk = 0; kk < s->rows; kk++)
      {
        pixel[kk] |= s->segs[kk][sb]; // 'sum' up anti-aliasing

        // to combine this with dimming fill dim[][] with weighted AA/dimming of each segment
        UINT32 p = pixel[kk]>>(30-2*s->cols);
        if (dimming)
          for (ll = 0; ll < s->cols; ll++, p >>= 2)
            if (p & 0x03) // segment set?
            {
              const UINT8 tmp = MIN(255,256 - dimming[sb - 1]); // 256 instead of 255 to exploit full range (as 0 is off state)
              if (tmp > dim[kk][ll]) // always take largest value, to make the crude anti-aliasing work at least somehow per segment
                dim[kk][ll] = tmp;
            }
      }
    }
  }

  #define ALPHA_OFF_LUM 48u
  #define ALPHA_ON_LUM (255u - ALPHA_OFF_LUM)
  static const UINT8 aa[] = { 0, 100, 66, 33 }; // AA factor
  for (kk = 0; kk < s->rows; kk++) {
    BMTYPE * __restrict line = &(((BMTYPE **)bitmap->line)[row+kk][col + s->cols]);
    // size is limited to 15 cols
    UINT32 p = pixel[kk]>>(30-2*s->cols), np = s->segs[kk][0]>>(30-2*s->cols);
    for (ll = 0; ll < s->cols; ll++, p >>= 2, np >>= 2)
    {
      if (p & 3) // segment set?
        *(--line) = dimming ? ALPHA_PAL(ALPHA_OFF_LUM + (ALPHA_ON_LUM * dim[kk][ll] * aa[p&3]) / 25500u) : ALPHA_PAL(ALPHA_OFF_LUM + (ALPHA_ON_LUM * 255u * aa[p&3]) / 25500u);
      else
        *(--line) = ALPHA_PAL((ALPHA_OFF_LUM * aa[np&3]) / 100u);
    }
  }
}


/*----------------------
/  Initialize PinMAME
/-----------------------*/
static MACHINE_INIT(core) {
#ifdef PROC_SUPPORT
  char * yaml_filename = pmoptions.p_roc;
#endif

  if (!coreData) { // first time
    /*-- init variables --*/
    memset(&coreGlobals, 0, sizeof(coreGlobals));
    memset(&locals, 0, sizeof(locals));
    coreData = (struct pinMachine *)&Machine->drv->pinmame;
    coreGlobals.flipperCoils = 0xFFFFFFFFFFFFFFFFull;
    //-- initialise timers --
    if (coreData->timers[0].callback) {
      int ii;
      for (ii = 0; ii < 5; ii++) {
        if (coreData->timers[ii].callback) {
          locals.timers[ii] = timer_alloc(coreData->timers[ii].callback);
          if (coreData->timers[ii].rate > 0.) {
            timer_adjust(locals.timers[ii], TIME_IN_HZ(coreData->timers[ii].rate), 0, TIME_IN_HZ(coreData->timers[ii].rate));
          } else { // negative = fractional hz value, e.g. as usec
            timer_adjust(locals.timers[ii], TIME_IN_USEC(-coreData->timers[ii].rate), 0, TIME_IN_USEC(-coreData->timers[ii].rate));
          }
        }
      }
    }
    /*-- init switch matrix --*/
    memcpy((void*)coreGlobals.invSw, (void*)core_gameData->wpc.invSw, sizeof(core_gameData->wpc.invSw));
    memcpy((void*)coreGlobals.swMatrix, (void*)coreGlobals.invSw, sizeof(coreGlobals.invSw));
#ifdef PROC_SUPPORT
    /*-- P-ROC operation requires a YAML.  Disable P-ROC operation
     * if no YAML is specified. --*/

    coreGlobals.p_rocEn = strcmp(yaml_filename, "None") != 0;
    if (coreGlobals.p_rocEn) {
      /*-- Finish P-ROC initialization now that the sim is active. --*/
      coreGlobals.p_rocEn = procIsActive();
      /*-- If the initialization fails, disable the p-roc support --*/
      if (!coreGlobals.p_rocEn) {
        fprintf(stderr, "P-ROC initialization failed.  Disabling P-ROC support.\n");
        // TODO: deInit P-ROC here?
      }
      else {
        // read s11CreditDisplay, doubleAlpha and s11BallDisplay settings
        procBallCreditDisplay();

        // Added option to enable keyboard for direct switches to YAML
        g_fHandleKeyboard = procKeyboardWanted();

        // We don't want the PC to make the noises of pop bumpers etc
        g_fHandleMechanics= 0;
      }
    }
#endif

    /*-- masks bit used by flippers --*/
    {
      const UINT32 flip = core_gameData->hw.flippers;
      locals.flipMask = CORE_SWLRFLIPBUTBIT | CORE_SWLLFLIPBUTBIT |
         ((flip & FLIP_SW(FLIP_UL)) ? CORE_SWULFLIPBUTBIT : 0) |
         ((flip & FLIP_SW(FLIP_UR)) ? CORE_SWURFLIPBUTBIT : 0) |
         ((flip & FLIP_EOS(FLIP_UL))? CORE_SWULFLIPEOSBIT : 0) |
         ((flip & FLIP_EOS(FLIP_UR))? CORE_SWURFLIPEOSBIT : 0) |
         ((flip & FLIP_EOS(FLIP_LL))? CORE_SWLLFLIPEOSBIT : 0) |
         ((flip & FLIP_EOS(FLIP_LR))? CORE_SWLRFLIPEOSBIT : 0);
    }
    /*-- command line options --*/
    locals.displaySize = pmoptions.dmd_compact ? 1 : 2;
    {
      UINT32 width = core_initDisplaySize(core_gameData->lcdLayout) >> 16;
      if (((int)width > Machine->drv->screen_width) && (locals.displaySize > 1)) {
        /* force small display */
        locals.displaySize = 1;
        core_initDisplaySize(core_gameData->lcdLayout);
      }
    }
    /*-- Sound enabled ? */
    if (((Machine->gamedrv->flags & GAME_NO_SOUND) == 0) && Machine->sample_rate != 0.)
      coreGlobals.soundEn = TRUE;

    /*-- init simulator --*/
    if (g_fHandleKeyboard && core_gameData->simData) {
      int inports[CORE_MAXPORTS];
      int ii;
      for (ii = 0; ii < CORE_COREINPORT+(coreData->coreDips+31)/16; ii++)
        inports[ii] = readinputport(ii);

      coreGlobals.simAvail = sim_init((sim_tSimData *)core_gameData->simData,
                                      inports,CORE_COREINPORT+(coreData->coreDips+31)/16);
    }

    /*-- default output types --*/
    core_set_pwm_output_type(CORE_MODOUT_SOL0, CORE_MODOUT_SOL_MAX, CORE_MODOUT_NONE);
    core_set_pwm_output_type(CORE_MODOUT_SOL0 + CORE_FIRSTCUSTSOL - 1, CORE_MAXSOL - CORE_FIRSTCUSTSOL, CORE_MODOUT_SOL_CUSTOM);
    core_set_pwm_output_type(CORE_MODOUT_GI0, CORE_MODOUT_GI_MAX, CORE_MODOUT_NONE);
    core_set_pwm_output_type(CORE_MODOUT_LAMP0, CORE_MODOUT_LAMP_MAX, CORE_MODOUT_NONE);
    core_set_pwm_output_type(CORE_MODOUT_SEG0, CORE_MODOUT_SEG_MAX, CORE_MODOUT_NONE);

    /*-- finally init the core --*/
    if (coreData->init) coreData->init();

    /*-- init PWM integration (needs to be done after coreData->init() which defines the number of outputs and the physical model to be used on each output) --*/
#ifndef LIBPINMAME // dimmed segments not wired at the moment?!
#ifdef VPINMAME
    if(g_fShowWinDMD || g_fShowPinDMD)
#endif
    // Enable PWM/dimmed segments for corresponding alphanum segment machines
    if (coreGlobals.nAlphaSegs > 0)
      options.usemodsol |= CORE_MODOUT_ENABLE_PHYSOUT_ALPHASEGS;
#endif
    //options.usemodsol |= CORE_MODOUT_ENABLE_PHYSOUT_ALL; // For debugging, enable/test all physical/PWM outputs

    /*-- init bulb model LUTs --*/
    bulb_init();

    /*-- init sound commander --*/
    snd_cmd_init();
  }
  /*-- now reset everything --*/
  if (coreData->reset) coreData->reset();
  mech_emuInit();

#ifdef VPINMAME
  // DMD USB Init
  if(g_fShowPinDMD && !time_to_reset)
    dmddeviceInit(g_szGameName, core_gameData->gen, &pmoptions);
#endif

  /*-- Generate LUTs for VPinMAME DMD --*/
  #ifdef VPINMAME
  {
    int rStart = 0xff, gStart = 0xe0, bStart = 0x20;
    int perc66 = 67, perc33 = 33, perc00 = 20;
    if ((pmoptions.dmd_red > 0) || (pmoptions.dmd_green > 0) || (pmoptions.dmd_blue > 0)) {
      rStart = pmoptions.dmd_red; gStart = pmoptions.dmd_green; bStart = pmoptions.dmd_blue;
    }
    if ((pmoptions.dmd_perc0 > 0) || (pmoptions.dmd_perc33 > 0) || (pmoptions.dmd_perc66 > 0)) {
      perc66 = pmoptions.dmd_perc66; perc33 = pmoptions.dmd_perc33; perc00 = pmoptions.dmd_perc0;
    }
    if ((core_gameData->gen & (GEN_SAM | GEN_SPA | GEN_ALVG_DMD2)) || (strncasecmp(Machine->gamedrv->name, "smb", 3) == 0) || (strncasecmp(Machine->gamedrv->name, "cueball", 7) == 0)) {
      // Backward compatibility: 16 shades mode has no colorization and fixed lighting levels ranging from 0 to 100
      //static const UINT8 levelgts3[16] = {0/*5*/, 30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80, 85, 90, 95, 100}; // GTS3 and AlvinG brightness seems okay
      //static const UINT8 levelsam[16]  = {0/*5*/, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80, 90, 100}; // SAM brightness seems okay
      //const UINT8* const level = (core_gameData->gen & (GEN_SAM|GEN_SPA)) ? levelsam : levelgts3;
      for (int i = 0; i < 256; i++) {
        const float v = (float)i * (float)(1.0/255.); // level[i >> 4] / 100.f;
        locals.vpm_dmd_luminance_lut[i] = (UINT8)(v * 100.f);
        const UINT32 r = (UINT32)((float)rStart * v);
        const UINT32 g = (UINT32)((float)gStart * v);
        const UINT32 b = (UINT32)((float)bStart * v);
        locals.vpm_dmd_color_lut[i] = r | (g << 8) | (b << 16);
      }
    }
    else {
      const int r100 = rStart, g100 = gStart, b100 = bStart;
      int r00, g00, b00, r33, g33, b33, r66, g66, b66;
      if (pmoptions.dmd_colorize) {
        r00 = pmoptions.dmd_red0;  g00 = pmoptions.dmd_green0;  b00 = pmoptions.dmd_blue0;
        r33 = pmoptions.dmd_red33; g33 = pmoptions.dmd_green33; b33 = pmoptions.dmd_blue33;
        r66 = pmoptions.dmd_red66; g66 = pmoptions.dmd_green66; b66 = pmoptions.dmd_blue66;
      }
      else {
        r00 = (r100 * perc00) / 100; g00 = (g100 * perc00) / 100; b00 = (b100 * perc00) / 100;
        r33 = (r100 * perc33) / 100; g33 = (g100 * perc33) / 100; b33 = (b100 * perc33) / 100;
        r66 = (r100 * perc66) / 100; g66 = (g100 * perc66) / 100; b66 = (b100 * perc66) / 100;
      }
      #define LERP0(p, a, b) ((1.-(double)(p))*(double)(a) + (double)(p)*(double)(b))
      #define LERP(i, v0, v33, v66, v100) (i < 85 ? LERP0(((double)i)/85., v0, v33) : (i < 170 ? LERP0(((double)i-85.)/85., v33, v66) : LERP0(((double)i-170.)/85., v66, v100)))
      for (int i = 0; i < 256; i++) {
        locals.vpm_dmd_luminance_lut[i] = (UINT8) LERP(i, perc00, perc33, perc66, 100);
        const UINT32 r = (UINT32) LERP(i, r00, r33, r66, r100);
        const UINT32 g = (UINT32) LERP(i, g00, g33, g66, g100);
        const UINT32 b = (UINT32) LERP(i, b00, b33, b66, b100);
        locals.vpm_dmd_color_lut[i] = r | (g << 8) | (b << 16);
      }
      #undef LERP0
      #undef LERP
    }
  }
  #endif

  OnStateChange(1); /* We have a lift-off */

/* TOM: this causes to draw the static sim text */
  schedule_full_refresh();
}

static MACHINE_STOP(core) {
  int ii;

#ifdef VPINMAME
  // DMD USB Kill
  if(g_fShowPinDMD && !time_to_reset)
   dmddeviceDeInit();
#endif
#if defined(VPINMAME) || defined(LIBPINMAME)
  g_raw_dmdx = ~0u;
  g_raw_dmdy = ~0u;

  has_DMD_Video = 0;

  raw_dmd_frame_count = 0;

  g_needs_DMD_update = 1;
#endif

  mech_emuExit();
  if (coreData->stop) coreData->stop();
  snd_cmd_exit();
  for (ii = 0; ii < 5; ii++) {
    if (locals.timers[ii])
      timer_remove(locals.timers[ii]);
  }
  memset(locals.timers, 0, sizeof(locals.timers));
#ifdef PROC_SUPPORT
  if (coreGlobals.p_rocEn) {
    procDeinitialize();
  }
#endif
  coreData = NULL; //!! FIXME this can still be in use when reading lamps via VPM / VPX-script
}

static void core_findSize(const struct core_dispLayout *layout, int *maxX, int *maxY) {
  if (layout) {
    for (; layout->length; layout += 1) {
      int tmpX, tmpY, type = layout->type & CORE_SEGMASK;
#if defined(VPINMAME) && !defined(MAME_DEBUG)
      if (layout->type & CORE_NODISP) continue;
#endif
      if (type == CORE_IMPORT)
        { core_findSize(layout->lptr, maxX, maxY); continue; }
      if (type == CORE_DMD || type == CORE_VIDEO) {
        tmpX = (layout->left + layout->length) * locals.segData[type].cols + 1;
        tmpY = (layout->top  + layout->start)  * locals.segData[type].rows + 1;
      }
      else {
        tmpX = (layout->left + 2*layout->length) * (locals.segData[type & 0x07].cols + 1) / 2;
        tmpY = (layout->top + 2) * (locals.segData[0].rows + 1) / 2;
      }
      if (tmpX > *maxX) *maxX = tmpX;
      if (tmpY > *maxY) *maxY = tmpY;
    }
#ifndef VPINMAME
    if (*maxX < 256) *maxX = 256;
#endif
  }
}

static UINT32 core_initDisplaySize(const struct core_dispLayout *layout) {
  int maxX = 0, maxY = 0;

  locals.segData = &segData[locals.displaySize == 1][0];
  if (layout)
    core_findSize(layout, &maxX, &maxY);
  else if (locals.displaySize > 1)
    { maxX = 256; maxY = 65; }
  else
    { maxX = 129; maxY = 33; }
  locals.firstSimRow = maxY + 3;
  locals.maxSimRows = Machine->drv->screen_height - locals.firstSimRow;
  if ((!pmoptions.dmd_only) || (maxY >= Machine->drv->screen_height))
    maxY = Machine->drv->screen_height;
  logerror("Resolution set to %dx%d\n", maxX, maxY);
  set_visible_area(0, maxX-1, 0, maxY-1);
  return (maxX<<16) | maxY;
}

void core_nvram(void *file, int write, void *mem, size_t length, UINT8 init) {
  if (write)     mame_fwrite(file, mem, length); /* save */
  else if (file) mame_fread(file,  mem, length); /* load */
  else           memset(mem, init, length);      /* first time */
  mech_nv(file, write); /* save mech positions */
  { /*-- Load/Save DIP settings --*/
    UINT8 dips[6];
    int   ii;

    if (write) {
      for (ii = 0; ii < 6; ii++) dips[ii] = core_getDip(ii);
      mame_fwrite(file, dips, sizeof(dips));
    }
    else if (file) {
      /* set the defaults (for compatibility with older versions) */
      dips[0] = readinputport(CORE_COREINPORT+1) & 0xff;
      dips[1] = readinputport(CORE_COREINPORT+1)>>8;
      dips[2] = readinputport(CORE_COREINPORT+2) & 0xff;
      dips[3] = readinputport(CORE_COREINPORT+2)>>8;
      dips[4] = readinputport(CORE_COREINPORT+3) & 0xff;
      dips[5] = readinputport(CORE_COREINPORT+3)>>8;

      mame_fread(file, dips, sizeof(dips));
      for (ii = 0; ii < 6; ii++) vp_setDIP(ii, dips[ii]);
    }
    else { // always get the default from the inports
      /* coreData not initialized yet. Don't know exact number of DIPs */
      vp_setDIP(0, readinputport(CORE_COREINPORT+1) & 0xff);
      vp_setDIP(1, readinputport(CORE_COREINPORT+1)>>8);
      vp_setDIP(2, readinputport(CORE_COREINPORT+2) & 0xff);
      vp_setDIP(3, readinputport(CORE_COREINPORT+2)>>8);
      vp_setDIP(4, readinputport(CORE_COREINPORT+3) & 0xff);
      vp_setDIP(5, readinputport(CORE_COREINPORT+3)>>8);
    }
  }
}

/*---------- Emulation of physical/analog devices wired to binary outputs ----------*/

/*
 * Physical output emulation
 * 
 * This is meant to be used with any output and should allow to have a physical model whatever is connected to the binary PWM output. 
 * Drivers must declare the number of outputs they drive of each type and push binary state change accordingly.
 * The implementation is not thread safe. Since VPinMAME reads state asynchronously, the integration is only performed if requested
 * asynchronously through a 1ms timer.
 */

//#define LOG_PWM_OUT (CORE_MODOUT_LAMP0 + 18)
//#define LOG_PWM_OUT (CORE_MODOUT_SOL0 + CORE_FIRSTCUSTSOL - 1)
//#define LOG_PWM_OUT (CORE_MODOUT_SEG0 + 0)
//#define LOG_PWM_OUT (CORE_MODOUT_SOL0 + 16 - 1)

// No operation output: just keep the last value directly defined by the driver
void core_update_pwm_output_nop(const double now, const int index, const int isFlip, const int state)
{
}

// Pulse output: simply report the binary output state without any processing
void core_update_pwm_output_pulse(const double now, const int index, const int isFlip, const int state)
{
  coreGlobals.physicOutputState[index].value = state ? 1.f : 0.f;
}

// Custom output: update the value from the driver's custom getSol implementation
void core_update_pwm_output_custom(const double now, const int index, const int isFlip, const int state)
{
  coreGlobals.physicOutputState[index].value = core_gameData->hw.getSol ? (core_gameData->hw.getSol(index - CORE_MODOUT_SOL0 + 1) ? 1.f : 0.f) : 0.f;
  #ifdef LOG_PWM_OUT
  if (index == LOG_PWM_OUT)
    printf("Custom #%d t=%8.5f v=%f\n", index, now, coreGlobals.physicOutputState[index].value);
  #endif
}

// Simple 2 state solenoid output
// Flip to ON state is taken in account directly, while flip to OFF state is only reported after a delay to filter out any PWM pulses
void core_update_pwm_output_sol_2_state(const double now, const int index, const int isFlip, const int state)
{
  core_tPhysicOutput* const output = &coreGlobals.physicOutputState[index];
  const float prevValue = output->value;
  if (isFlip)
     output->state.sol.lastFlipTimestamp = now;
  if (isFlip && state == 0) {
     // If binary output is flipping to ON state, immediately retain and report the ON state
     output->value = 1.0f;
  }
  else if ((float)(now - output->state.sol.lastFlipTimestamp) > output->state.sol.switchDownLatency) {
     // Output is in a stable state (not PWMed since at least the defined switch down latency), just report its value
     output->value = state ? 1.f : 0.f;
  }
  #ifdef LOG_PWM_OUT
  if (index == LOG_PWM_OUT)
    printf("Sol #%d t=%8.5f v=%f s=%s\n", index - CORE_MODOUT_SOL0 + 1, now, output->value, isFlip ? (state ? "x > -" : "- > x") : (state ? "    x" : "    -"));
  #endif
  // Apply the legacy solenoid behavior but directly updating coreGlobals.solenoids, avoiding the latency of legacy implementation which handles PWM
  // by 'or'ing solenoids states for a few 'VBlank's then deliver them, 'VBlank' being a custom 60Hz interrupt not corresponding to any hardware.
  if (output->state.sol.fastOn && (prevValue != output->value)) {
    const int sol = index - CORE_MODOUT_SOL0;
    const UINT32 state = output->value > 0.5f ? 1 : 0;
    if (sol == (coreGlobals.flipperCoils & 0xFF))              // Lower Left Flipper coil
      coreGlobals.solenoids2 = (coreGlobals.solenoids2 & ~0x04) | (state ? 0x04 : 0x00);
    else if (sol == ((coreGlobals.flipperCoils >>  8) & 0xFF)) // Lower Right Flipper coil
      coreGlobals.solenoids2 = (coreGlobals.solenoids2 & ~0x01) | (state ? 0x01 : 0x00);
    else if (sol == ((coreGlobals.flipperCoils >> 16) & 0xFF)) // Upper Left Flipper coil
      coreGlobals.solenoids2 = (coreGlobals.solenoids2 & ~0x40) | (state ? 0x40 : 0x00);
    else if (sol == ((coreGlobals.flipperCoils >> 24) & 0xFF)) // Upper Right Flipper coil
      coreGlobals.solenoids2 = (coreGlobals.solenoids2 & ~0x10) | (state ? 0x10 : 0x00);
    else if (sol == ((coreGlobals.flipperCoils >> 32) & 0xFF)) // Lower Left Flipper Hold coil
      coreGlobals.solenoids2 = (coreGlobals.solenoids2 & ~0x08) | (state ? 0x08 : 0x00);
    else if (sol == ((coreGlobals.flipperCoils >> 40) & 0xFF)) // Lower Right Flipper Hold coil
      coreGlobals.solenoids2 = (coreGlobals.solenoids2 & ~0x02) | (state ? 0x02 : 0x00);
    else if (sol == ((coreGlobals.flipperCoils >> 48) & 0xFF)) // Upper Left Flipper Hold coil
      coreGlobals.solenoids2 = (coreGlobals.solenoids2 & ~0x80) | (state ? 0x80 : 0x00);
    else if (sol == ((coreGlobals.flipperCoils >> 56) & 0xFF)) // Upper Right Flipper Hold coil
      coreGlobals.solenoids2 = (coreGlobals.solenoids2 & ~0x20) | (state ? 0x20 : 0x00);
    if (sol < 28)
      coreGlobals.solenoids = (coreGlobals.solenoids & ~(1 << sol)) | (state << sol);
    else if (sol < 32) {
      if (core_gameData->gen & (GEN_WPC95 | GEN_WPC95DCS)) {
        coreGlobals.solenoids = (coreGlobals.solenoids & ~(1 << (sol +  8))) | (state << (sol + 8));
        coreGlobals.solenoids = (coreGlobals.solenoids & ~(1 << (sol + 12))) | (state << (sol + 12));
      }
      else if ((core_gameData->gen & GEN_ALLWPC) == 0)
        coreGlobals.solenoids = (coreGlobals.solenoids & ~(1 << sol)) | (state << sol);
      else if (core_gameData->gen & (GEN_ALLS11 | GEN_SAM | GEN_SPA) && 40 <= sol && sol < 48)
        coreGlobals.solenoids = (coreGlobals.solenoids & ~(1 << (sol - 4))) | (state << (sol - 4));
    }
  }
}

INLINE float cube(const float x)
{
  return x * x * x;
}

INLINE void core_eye_flicker_fusion(core_tPhysicOutput* output, const float emission)
{
   // Compute the perceived emission using a hacky simplified eye integration model
   // We want to model the flicker-fusion eye/brain behavior while keeping the output latency low (filter delay) and limit the flicker (still keeping it, if it can be seen on the real machine)
   // Note that videos can not be used as references for fitting the model since the camera perform a different luminance integration. Comparisons are only valid with real humans looking at real PWM/strobed incandescent bulbs.

   // The model is a 4 steps RC-IIR/decay low pass filter (with decreased ringing/rippling).
   // I tested it following advice from a scientific paper that suggested to use a single pass RC filter for the eye model in the flicker-fusion study (I can't find the paper anymore...)
   //  (this is oversimplifying the human vision system complexity, but is mostly good enough for our use-case)
   // The overall filter delay is around 20ms. The key factor is the 0.1 constant (lower it for more smoothness, increasing the filter delay), increase it for faster response but more flicker.
   // From my test, when you look at a steady strobed lamp from a WPC (for example, lower left insert of Monster Bash), you can clearly see that the strobe is too slow (2ms/16ms) causing noticeable flicker.
   // This behavior would be obtained with a value of around 0.15 but I don't think this is the expected behavior so we smooth it a bit more to limit the flicker more than what it is on a real pinball.
   // By now we also use a log function to map intensities (resulting range [~0.07..~0.11], kinda magic). This is according to the Ferry-Porter law, where higher intensities need a larger frequency in order to make
   //  flicker fusion work, and lower intensities already work at smaller ones. (main ff frequency range is roughly 20Hz to 70Hz, BUT with a lot of outlier situations)

   const float eye_integration_old[3] = { output->state.bulb.eye_integration[0], output->state.bulb.eye_integration[1], output->state.bulb.eye_integration[2] };
   const float eyeIntegrationFactor = /*0.1f*/ (0.07f + 0.02f * /*logf(output->value*6.f + 1.f) approx:*/ 2.f*sqrtf(fmaxf(output->value,0.f))), revEyeIntegrationFactor = 1.0f - eyeIntegrationFactor;
   output->state.bulb.eye_integration[0] = (eyeIntegrationFactor * 0.5f) * (emission                +output->state.bulb.eye_emission_old) + revEyeIntegrationFactor * eye_integration_old[0];
   output->state.bulb.eye_integration[1] = (eyeIntegrationFactor * 0.5f) * (output->state.bulb.eye_integration[0]+eye_integration_old[0]) + revEyeIntegrationFactor * eye_integration_old[1];
   output->state.bulb.eye_integration[2] = (eyeIntegrationFactor * 0.5f) * (output->state.bulb.eye_integration[1]+eye_integration_old[1]) + revEyeIntegrationFactor * eye_integration_old[2];
   output->value                         = (eyeIntegrationFactor * 0.5f) * (output->state.bulb.eye_integration[2]+eye_integration_old[2]) + revEyeIntegrationFactor * output->value;
   output->state.bulb.eye_emission_old   = emission;

#ifdef LOG_PWM_OUT
   if (output == &coreGlobals.physicOutputState[LOG_PWM_OUT])
     printf("Eye flicker fusion out=%0.5f in=%0.5f\n", output->value, emission);
#endif
}

static const double BULB_INTEGRATION_PERIOD = 0.001; // do the integration in a loop of small steps

// Incandescent bulb model based on Dulli Chandra Agrawal's and others publications (Heating-times of tungsten filament incandescent lamps).
// The bulb is a varying resistor depending on filament temperature, which is heated by the current (Ohm's law)
// and cooled by radiating energy (Planck & Stefan/Boltzmann laws). The visible emission power is then evaluated from the filament temperature.
// Integration is performed after (roughly) 1ms delay in (roughly) 1ms cycles
// isFlip signals a state flip, BUT we track this internally anyways now
void core_update_pwm_output_bulb(const double now, const int index, const int isFlip, const int state)
{
  core_tPhysicOutput* output = &coreGlobals.physicOutputState[index];
  const float U = (state ^ output->state.bulb.isReversed) ? output->state.bulb.U : 0.f;
  const float dt_diff = (float)(output->state.bulb.integrationTimestamp - output->state.bulb.prevIntegrationTimestamp);

  if(U != output->state.bulb.prevIntegrationValue        // state flip?
     || dt_diff >= (float)(BULB_INTEGRATION_PERIOD*20.)) // or we waited long enough to get a stable discrete integration
  {
    // do the integration in a loop of small steps, roughly in BULB_INTEGRATION_PERIOD sized steps (but rounded up/down to have same sized cycles in here)
    float countf = floorf(dt_diff*(float)(1./BULB_INTEGRATION_PERIOD) + 0.5f);
    if(countf < 1.f) // single cycle/short pulses need to use the 'original' cycle time as a workaround
      countf = 1.f;
    const int count = (int)countf;
    const float dt = dt_diff/countf;
    for(int i = 0; i < count; ++i) {
      // Keeps T within the range of the LUT (between room temperature and melt down point)
      output->state.bulb.filament_temperature = output->state.bulb.filament_temperature < 293.0f ? 293.0f : output->state.bulb.filament_temperature > (float) BULB_T_MAX ? (float) BULB_T_MAX : output->state.bulb.filament_temperature;
      const float Ut = output->state.bulb.isAC ? (1.41421356f * sinf((float)(60.0 * 2.0 * PI) * (float)(output->state.bulb.prevIntegrationTimestamp - coreGlobals.lastACZeroCrossTimeStamp)) * output->state.bulb.prevIntegrationValue) : output->state.bulb.prevIntegrationValue;
      const float dT = dt * bulb_heat_up_factor(output->state.bulb.bulb, output->state.bulb.filament_temperature, Ut, output->state.bulb.serial_R);
      output->state.bulb.filament_temperature += dT < 1000.0f ? dT : 1000.0f; // Limit initial current surge (1ms is a bit long when emulating this part of the heating)
      core_eye_flicker_fusion(output, bulb_filament_temperature_to_emission(output->state.bulb.bulb, output->state.bulb.filament_temperature));
      output->state.bulb.prevIntegrationTimestamp += dt;
    }
    output->state.bulb.prevIntegrationTimestamp = output->state.bulb.integrationTimestamp;
    output->state.bulb.prevIntegrationValue = U;
  }
  // else: wait with the integration until some more time vanished or the state will flip
  output->state.bulb.integrationTimestamp = now;

  #ifdef LOG_PWM_OUT
  if (index == LOG_PWM_OUT)
    printf("Output #%d t=%8.5f T=%5.0f e=%0.3f V=%0.3f S=%s F=%s\n", index, now, output->state.bulb.filament_temperature, bulb_filament_temperature_to_emission(output->state.bulb.bulb, output->state.bulb.filament_temperature), output->value, state ? "x" : "-", isFlip ? "/" : ".");
    //printf("Output #%d t=%8.5f T=%5.0f e=%0.3f V=%0.3f S=%s\n", index, now, output->state.bulb.filament_temperature, bulb_filament_temperature_to_emission(output->state.bulb.bulb, output->state.bulb.filament_temperature), output->value, ((coreGlobals.binaryOutputState[index >> 3] >> (index & 7)) & 1) ? "x" : "-");
  #endif
}

// LED and VFD behave similarly:
// - LED reacts almost instantly (<1us)
// - The documentation for the behavior of Vacuum Fluorescent Display (used by alphanum displays) is sparse, so the integrator likely needs more work. From the searchs made, it appears that:
//   - the relative brightness (in steady state) is linear to PWM duty ratio.
//   - the off -> on speed is very short (below 1ms), therefore ignored
//   - the on -> off, called persistence depends a lot on used phosphor, for blue VFD uses P11 (0.5ms decay), green VFD uses P24 (0.01ms decay), therefore ignored too
//
// Sources:
// - https://en.wikipedia.org/wiki/Phosphor has a large phosphor chart
// - https://www.noritake-elec.com/technology/general-technical-information/vfd-operation states a linear relation between PWM and relative brightness
// - http://www.futabahk.com.hk/FTS/-%20FTP_DataBase/Docs_05TechDocs/VFD/AN-1103A-EN%20%20VFD%20Characteristics%20and%20Operation%20Guide%20(EN).pdf states the same
// isFlip signals a state flip, BUT we track this internally anyways now
void core_update_pwm_output_led(const double now, const int index, const int isFlip, const int state)
{
  core_tPhysicOutput* output = &coreGlobals.physicOutputState[index];
  const float power = state ? output->state.bulb.relative_brightness : 0.f;
  const float dt_diff = (float)(output->state.bulb.integrationTimestamp - output->state.bulb.prevIntegrationTimestamp);

  if(power != output->state.bulb.prevIntegrationValue    // state flip?
     || dt_diff >= (float)(BULB_INTEGRATION_PERIOD*20.)) // or we waited long enough to get a stable discrete integration
  {
    // do the integration in a loop of small steps, roughly in BULB_INTEGRATION_PERIOD sized steps (but rounded up/down to have same sized cycles in here)
    float countf = floorf(dt_diff*(float)(1./BULB_INTEGRATION_PERIOD) + 0.5f);
    if(countf < 1.f) // single cycle/short pulses need to use the 'original' cycle time as a workaround
      countf = 1.f;
    const int count = (int)countf;
    const float dt = dt_diff/countf;
    const float dt_ratio = dt*(float)(1./BULB_INTEGRATION_PERIOD);
    const float emission = output->state.bulb.prevIntegrationValue * /*powf(dt_ratio,(float)(1./1.3)) approx:*/ cube(sqrtf(sqrtf(dt_ratio))); // pow boosts the emission artificially a bit, especially for GTS3/WPC alphaseg, as the power-on cycle is somehow too short?!?
    for(int i = 0; i < count; ++i)
      core_eye_flicker_fusion(output, emission);

    // No real need to do this anymore, rather let the low pass filter over/undershoot to be more 'correct'
    /*if (output->state.bulb.prevIntegrationValue != 0.f && output->value > (float)(254./255.)) // Stabilize Steady-On state
      output->value = 1.f;
    else if (output->state.bulb.prevIntegrationValue == 0.f && output->value < (float)(1./255.)) // Stabilize Steady-Off state
      output->value = 0.f;*/
    output->state.bulb.prevIntegrationTimestamp = output->state.bulb.integrationTimestamp;
    output->state.bulb.prevIntegrationValue = power;
  }
  // else: wait with the integration until some more time vanished or the state will flip
  output->state.bulb.integrationTimestamp = now;

  #ifdef LOG_PWM_OUT
  if (index == LOG_PWM_OUT)
    printf("Output #%d t=%8.5f T=%5.0f e=%0.3f V=%0.3f S=%s\n", index, now, output->state.bulb.filament_temperature, bulb_filament_temperature_to_emission(output->state.bulb.bulb, output->state.bulb.filament_temperature), output->value, state ? "x" : "-");
  #endif
}

void core_set_pwm_output_type(int startIndex, int count, int type)
{
  for (int i = startIndex; i < startIndex + count; i++) {
    memset(&(coreGlobals.physicOutputState[i]), 0, sizeof(core_tPhysicOutput));
    coreGlobals.physicOutputState[i].flipBufferPos = (coreGlobals.binaryOutputState[i >> 3] >> (i & 7)) & 1;
    coreGlobals.physicOutputState[i].type = type;
    switch (type) {
    case CORE_MODOUT_NONE:
      coreGlobals.physicOutputState[i].integrator = &core_update_pwm_output_nop;
      break;
    case CORE_MODOUT_PULSE:
      coreGlobals.physicOutputState[i].integrator = &core_update_pwm_output_pulse;
      break;
    case CORE_MODOUT_SOL_CUSTOM:
      coreGlobals.physicOutputState[i].integrator = &core_update_pwm_output_custom;
      break;
    case CORE_MODOUT_SOL_2_STATE:
      coreGlobals.physicOutputState[i].state.sol.fastOn = TRUE;
      // TODO 60ms is likely too much. For example for Stern SAM, the sequence is 40ms pulse to lift flipper then 1ms pulse every 12ms to hold.
      coreGlobals.physicOutputState[i].state.sol.switchDownLatency = 0.060f;
      coreGlobals.physicOutputState[i].integrator = &core_update_pwm_output_sol_2_state;
      break;
    case CORE_MODOUT_LEGACY_SOL_2_STATE:
      coreGlobals.physicOutputState[i].state.sol.fastOn = FALSE;
      // TODO 60ms is likely too much. For example for Stern SAM, the sequence is 40ms pulse to lift flipper then 1ms pulse every 12ms to hold.
      coreGlobals.physicOutputState[i].state.sol.switchDownLatency = 0.060f;
      coreGlobals.physicOutputState[i].integrator = &core_update_pwm_output_sol_2_state;
      break;
    case CORE_MODOUT_BULB_44_5_7V_AC: // Sega/Stern Whitestar uses 5.7V AC wired to #44 bulbs for GI which leads to a (very slow) bulb equilibrium around 78% of the rated bulb brightness. Likely for less heat and longer bulb life ?
      coreGlobals.physicOutputState[i].state.bulb.bulb = BULB_44;
      coreGlobals.physicOutputState[i].state.bulb.U = 5.7f;
      coreGlobals.physicOutputState[i].state.bulb.isAC = TRUE;
      coreGlobals.physicOutputState[i].state.bulb.serial_R = 0.0f;
      coreGlobals.physicOutputState[i].state.bulb.relative_brightness = 1.f;
      coreGlobals.physicOutputState[i].integrator = &core_update_pwm_output_bulb;
      break;
    case CORE_MODOUT_BULB_44_6_3V_AC: // AC bulb outputs used for GI strings. Voltage drop through WPC triacs are considered as neglectable.
      coreGlobals.physicOutputState[i].state.bulb.bulb = BULB_44;
      coreGlobals.physicOutputState[i].state.bulb.U = 6.3f;
      coreGlobals.physicOutputState[i].state.bulb.isAC = TRUE;
      coreGlobals.physicOutputState[i].state.bulb.serial_R = 0.0f;
      coreGlobals.physicOutputState[i].state.bulb.relative_brightness = 1.f;
      coreGlobals.physicOutputState[i].integrator = &core_update_pwm_output_bulb;
      break;
    case CORE_MODOUT_BULB_44_6_3V_AC_REV: // Same but reversed through a relay (S11 hardware uses this for GI)
      coreGlobals.physicOutputState[i].state.bulb.bulb = BULB_44;
      coreGlobals.physicOutputState[i].state.bulb.U = 6.3f;
      coreGlobals.physicOutputState[i].state.bulb.isAC = TRUE;
      coreGlobals.physicOutputState[i].state.bulb.serial_R = 0.0f;
      coreGlobals.physicOutputState[i].state.bulb.relative_brightness = 1.f;
      coreGlobals.physicOutputState[i].integrator = &core_update_pwm_output_bulb;
      coreGlobals.physicOutputState[i].state.bulb.isReversed = TRUE;
      break;
    case CORE_MODOUT_BULB_47_6_3V_AC:
      coreGlobals.physicOutputState[i].state.bulb.bulb = BULB_47;
      coreGlobals.physicOutputState[i].state.bulb.U = 6.3f;
      coreGlobals.physicOutputState[i].state.bulb.isAC = TRUE;
      coreGlobals.physicOutputState[i].state.bulb.serial_R = 0.0f;
      coreGlobals.physicOutputState[i].state.bulb.relative_brightness = 1.f;
      coreGlobals.physicOutputState[i].integrator = &core_update_pwm_output_bulb;
      break;
    case CORE_MODOUT_BULB_86_6_3V_AC:
      coreGlobals.physicOutputState[i].state.bulb.bulb = BULB_86;
      coreGlobals.physicOutputState[i].state.bulb.U = 6.3f;
      coreGlobals.physicOutputState[i].state.bulb.isAC = TRUE;
      coreGlobals.physicOutputState[i].state.bulb.serial_R = 0.0f;
      coreGlobals.physicOutputState[i].state.bulb.relative_brightness = 1.f;
      coreGlobals.physicOutputState[i].integrator = &core_update_pwm_output_bulb;
      break;
    case CORE_MODOUT_BULB_44_18V_DC_WPC: // Strobed bulb, 18V switched through a TIP102 and a TIP107 (voltage drop supposed of 0.7V per semiconductor switch, datasheet states Vcesat=2V for I=3A), resistor from schematics (TZ, TOTAN, CFTBL, WPC95 general)
      coreGlobals.physicOutputState[i].state.bulb.bulb = BULB_44;
      coreGlobals.physicOutputState[i].state.bulb.U = 18.f - 0.7f - 0.7f;
      coreGlobals.physicOutputState[i].state.bulb.isAC = FALSE;
      coreGlobals.physicOutputState[i].state.bulb.serial_R = 0.22f;
      coreGlobals.physicOutputState[i].state.bulb.relative_brightness = 1.f;
      coreGlobals.physicOutputState[i].integrator = &core_update_pwm_output_bulb;
      break;
    case CORE_MODOUT_BULB_44_20V_DC_GTS3: // Strobed bulb, Switched through MOSFETs (12P06 & 12N10L, no drop), serial 3,5 Ohms, then series with 1N4004 (0,7V drop) for bulbs / 120 Ohms with 1N4004 for LEDs, resistor from schematics (Cue Ball Wizard)
      coreGlobals.physicOutputState[i].state.bulb.bulb = BULB_44;
      coreGlobals.physicOutputState[i].state.bulb.U = 20.f - 0.7f;
      coreGlobals.physicOutputState[i].state.bulb.isAC = FALSE;
      coreGlobals.physicOutputState[i].state.bulb.serial_R = 3.5f;
      coreGlobals.physicOutputState[i].state.bulb.relative_brightness = 1.f;
      coreGlobals.physicOutputState[i].integrator = &core_update_pwm_output_bulb;
      break;
    case CORE_MODOUT_BULB_44_18V_DC_S11: // Strobed bulb, 18V switched through ?, resistor from schematics (Guns'n Roses)
      coreGlobals.physicOutputState[i].state.bulb.bulb = BULB_44;
      coreGlobals.physicOutputState[i].state.bulb.U = 18.f;
      coreGlobals.physicOutputState[i].state.bulb.isAC = FALSE;
      coreGlobals.physicOutputState[i].state.bulb.serial_R = 4.3f;
      coreGlobals.physicOutputState[i].state.bulb.relative_brightness = 1.f;
      coreGlobals.physicOutputState[i].integrator = &core_update_pwm_output_bulb;
      break;
    case CORE_MODOUT_BULB_44_18V_DC_SE: // Strobed bulb, 18V switched through VN02N (Solid State Relay, 0.4 Ohms resistor), a 19N06L MOSFET transistor (no drop) and a diode (0.7V drop) from Sega/Stern Whitestar schematics
      coreGlobals.physicOutputState[i].state.bulb.bulb = BULB_44;
      coreGlobals.physicOutputState[i].state.bulb.U = 18.f - 0.7f;
      coreGlobals.physicOutputState[i].state.bulb.isAC = FALSE;
      coreGlobals.physicOutputState[i].state.bulb.serial_R = 0.4f;
      coreGlobals.physicOutputState[i].state.bulb.relative_brightness = 1.f;
      coreGlobals.physicOutputState[i].integrator = &core_update_pwm_output_bulb;
      break;
    case CORE_MODOUT_BULB_44_20V_DC_CC: // Strobed bulb, 20V switched through VN02 (Solid State Relay, 0.4 Ohms resistor), a STP20N10L MOSFET transistor (no drop), a 0.02 Ohms resistor, and 2x 1N4004 diode (0.7V drop) from Capcom schematics
      coreGlobals.physicOutputState[i].state.bulb.bulb = BULB_44;
      coreGlobals.physicOutputState[i].state.bulb.U = 20.f - 0.7f - 0.7f;
      coreGlobals.physicOutputState[i].state.bulb.isAC = FALSE;
      coreGlobals.physicOutputState[i].state.bulb.serial_R = 0.4f + 0.02f;
      coreGlobals.physicOutputState[i].state.bulb.relative_brightness = 1.f;
      coreGlobals.physicOutputState[i].integrator = &core_update_pwm_output_bulb;
      break;
    case CORE_MODOUT_BULB_89_20V_DC_WPC: // Flasher 20V DC switched through a TIP102 (voltage drop supposed of 0.7V per semiconductor switch, datasheet states Vcesat=2V for I=3A), resistor from WPC schematics (TZ, TOTAN, CFTBL, WPC95 general)
      coreGlobals.physicOutputState[i].state.bulb.bulb = BULB_89;
      coreGlobals.physicOutputState[i].state.bulb.U = 20.f - 0.7f;
      coreGlobals.physicOutputState[i].state.bulb.isAC = FALSE;
      coreGlobals.physicOutputState[i].state.bulb.serial_R = 0.12f;
      coreGlobals.physicOutputState[i].state.bulb.relative_brightness = 1.f;
      coreGlobals.physicOutputState[i].integrator = &core_update_pwm_output_bulb;
      break;
    case CORE_MODOUT_BULB_89_20V_DC_GTS3: // Flasher 20V DC switched through a 12N10L Mosfet (no voltage drop), resistor from schematics (Cue Ball Wizard)
      coreGlobals.physicOutputState[i].state.bulb.bulb = BULB_89;
      coreGlobals.physicOutputState[i].state.bulb.U = 20.f;
      coreGlobals.physicOutputState[i].state.bulb.isAC = FALSE;
      coreGlobals.physicOutputState[i].state.bulb.serial_R = 0.3f;
      coreGlobals.physicOutputState[i].state.bulb.relative_brightness = 1.f;
      coreGlobals.physicOutputState[i].integrator = &core_update_pwm_output_bulb;
      break;
    case CORE_MODOUT_BULB_89_32V_DC_S11: // Flasher 32V DC switched through a TIP 122 (Vcesat max= 2 to 4V, 1V used here) with a 3 Ohms serial resistor and a diode (1V voltage drop), resistor from board photos
      coreGlobals.physicOutputState[i].state.bulb.bulb = BULB_89;
      coreGlobals.physicOutputState[i].state.bulb.U = 32.f - 1.0f - 1.0f;
      coreGlobals.physicOutputState[i].state.bulb.isAC = FALSE;
      coreGlobals.physicOutputState[i].state.bulb.serial_R = 3.f;
      coreGlobals.physicOutputState[i].state.bulb.relative_brightness = 1.f;
      coreGlobals.physicOutputState[i].integrator = &core_update_pwm_output_bulb;
      break;
    case CORE_MODOUT_BULB_89_25V_DC_S11: // Flasher 25V DC switched through a TIP 122 (Vcesat max= 2 to 4V, 1V used here) with a 1,5 Ohms serial resistor and a diode (1V voltage drop), from Police Force (and others) schematics
      coreGlobals.physicOutputState[i].state.bulb.bulb = BULB_89;
      coreGlobals.physicOutputState[i].state.bulb.U = 25.f - 1.0f - 1.0f;
      coreGlobals.physicOutputState[i].state.bulb.isAC = FALSE;
      coreGlobals.physicOutputState[i].state.bulb.serial_R = 1.5f;
      coreGlobals.physicOutputState[i].state.bulb.relative_brightness = 1.f;
      coreGlobals.physicOutputState[i].integrator = &core_update_pwm_output_bulb;
      break;
    case CORE_MODOUT_BULB_906_20V_DC_WPC: // Flasher 20V DC switched through a TIP102 (voltage drop supposed of 0.7V per semiconductor switch, datasheet states Vcesat=2V for I=3A), resistor from WPC schematics (TZ, TOTAN, CFTBL, WPC95 general)
       coreGlobals.physicOutputState[i].state.bulb.bulb = BULB_906;
       coreGlobals.physicOutputState[i].state.bulb.U = 20.f - 0.7f;
       coreGlobals.physicOutputState[i].state.bulb.isAC = FALSE;
       coreGlobals.physicOutputState[i].state.bulb.serial_R = 0.12f;
       coreGlobals.physicOutputState[i].state.bulb.relative_brightness = 1.f;
       coreGlobals.physicOutputState[i].integrator = &core_update_pwm_output_bulb;
       break;
    case CORE_MODOUT_BULB_906_20V_DC_GTS3: // Flasher 20V DC switched through a 12N10L Mosfet (no voltage drop), resistor from schematics (Cue Ball Wizard)
       coreGlobals.physicOutputState[i].state.bulb.bulb = BULB_906;
       coreGlobals.physicOutputState[i].state.bulb.U = 20.f;
       coreGlobals.physicOutputState[i].state.bulb.isAC = FALSE;
       coreGlobals.physicOutputState[i].state.bulb.serial_R = 0.3f;
       coreGlobals.physicOutputState[i].state.bulb.relative_brightness = 1.f;
       coreGlobals.physicOutputState[i].integrator = &core_update_pwm_output_bulb;
       break;
    case CORE_MODOUT_BULB_906_32V_DC_S11: // Flasher 32V DC switched through a TIP 122 (Vcesat max= 2 to 4V, 1V used here) with a 3 Ohms serial resistor and a diode (1V voltage drop), resistor from board photos
       coreGlobals.physicOutputState[i].state.bulb.bulb = BULB_906;
       coreGlobals.physicOutputState[i].state.bulb.U = 32.f - 1.0f - 1.0f;
       coreGlobals.physicOutputState[i].state.bulb.isAC = FALSE;
       coreGlobals.physicOutputState[i].state.bulb.serial_R = 3.f;
       coreGlobals.physicOutputState[i].state.bulb.relative_brightness = 1.f;
       coreGlobals.physicOutputState[i].integrator = &core_update_pwm_output_bulb;
       break;
    case CORE_MODOUT_BULB_906_25V_DC_S11: // Flasher 25V DC switched through a TIP 122 (Vcesat max= 2 to 4V, 1V used here) with a 1,5 Ohms serial resistor and a diode (1V voltage drop), from Police Force (and others) schematics
       coreGlobals.physicOutputState[i].state.bulb.bulb = BULB_906;
       coreGlobals.physicOutputState[i].state.bulb.U = 25.f - 1.0f - 1.0f;
       coreGlobals.physicOutputState[i].state.bulb.isAC = FALSE;
       coreGlobals.physicOutputState[i].state.bulb.serial_R = 1.5f;
       coreGlobals.physicOutputState[i].state.bulb.relative_brightness = 1.f;
       coreGlobals.physicOutputState[i].integrator = &core_update_pwm_output_bulb;
       break;
    case CORE_MODOUT_LED:
      coreGlobals.physicOutputState[i].state.bulb.relative_brightness = 1.f;
      coreGlobals.physicOutputState[i].integrator = &core_update_pwm_output_led;
      break;
    case CORE_MODOUT_LED_STROBE_1_10MS:
      coreGlobals.physicOutputState[i].state.bulb.relative_brightness = 10.f / 1.f;
      coreGlobals.physicOutputState[i].integrator = &core_update_pwm_output_led;
      break;
    case CORE_MODOUT_LED_STROBE_1_5MS:
       coreGlobals.physicOutputState[i].state.bulb.relative_brightness = 5.f / 1.f;
       coreGlobals.physicOutputState[i].integrator = &core_update_pwm_output_led;
       break;
    case CORE_MODOUT_LED_STROBE_8_16MS:
       coreGlobals.physicOutputState[i].state.bulb.relative_brightness = 16.f / 8.f;
       coreGlobals.physicOutputState[i].integrator = &core_update_pwm_output_led;
       break;
    case CORE_MODOUT_VFD_STROBE_05_20MS:
      coreGlobals.physicOutputState[i].state.bulb.relative_brightness = 20.f / 0.5f;
      coreGlobals.physicOutputState[i].integrator = &core_update_pwm_output_led;
      break;
    case CORE_MODOUT_VFD_STROBE_1_16MS:
      coreGlobals.physicOutputState[i].state.bulb.relative_brightness = 16.f / 1.f;
      coreGlobals.physicOutputState[i].integrator = &core_update_pwm_output_led;
      break;
    default: // Unimplemented integrator
      logerror("Unsupported physical output #%d of type %d\n", i, type);
      assert(FALSE);
    }
  }
}

void core_set_pwm_output_bulb(int startIndex, int count, int bulb, float U, int isAC, float serial_R, float relative_brightness)
{
  for (int i = startIndex; i < startIndex + count; i++) {
    memset(&(coreGlobals.physicOutputState[i]), 0, sizeof(core_tPhysicOutput));
    coreGlobals.physicOutputState[i].flipBufferPos = (coreGlobals.binaryOutputState[i >> 3] >> (i & 7)) & 1;
    coreGlobals.physicOutputState[i].type = CORE_MODOUT_CUSTOM_INTEGRATOR;
    coreGlobals.physicOutputState[i].state.bulb.bulb = bulb;
    coreGlobals.physicOutputState[i].state.bulb.U = U;
    coreGlobals.physicOutputState[i].state.bulb.isAC = isAC;
    coreGlobals.physicOutputState[i].state.bulb.serial_R = serial_R;
    coreGlobals.physicOutputState[i].state.bulb.relative_brightness = relative_brightness;
    coreGlobals.physicOutputState[i].integrator = &core_update_pwm_output_bulb;
  }
}

void core_set_pwm_output_types(int startIndex, int count, int* outputTypes)
{
   for (int i = 0; i < count; i++)
      core_set_pwm_output_type(startIndex + i, 1, outputTypes[i]);
}

// Perform emulation of the requested physical outputs from the stored PWM digital output states
// Initial implementation was performing this task upon digital output writes causing DMD animation stutters and sound buffer underflow.
// This is now performed on physic output reads, moving the CPU load to the caller thread. The client is responsible and has the ability
// to manage this load according to its use. It also allows to limit the update to the requested outputs (physics should be updated 
// according to physic engine constants while visual should be updated according to output display characteristics).
void core_update_pwm_outputs(const int startIndex, const int count)
{
   // HACK timer_get_time is not thread safe and can only be called from emulation thread. Therefore we use a fake timer with timer_starttime which is thread safe as a workaround.
   // const double now = timer_get_time();
   mame_timer fake_timer = { 0 };
   const double now = timer_starttime(&fake_timer);
   for (int i = 0; i < count; i++)
   {
      const unsigned int index = startIndex + i;
      core_tPhysicOutput* const output = &coreGlobals.physicOutputState[index];
      // Perform integration of flip states that appended since last integration and before now if any
      while (output->lastIntegrationFlipPos != output->flipBufferPos)
      {
         output->lastIntegrationFlipPos = (output->lastIntegrationFlipPos + 1) % FLIP_BUFFER_SIZE;
         output->integrator(output->flipTimeStamps[output->lastIntegrationFlipPos], index, TRUE, (output->lastIntegrationFlipPos & 1) ^ 1);
      }
      // Perform integration of stable state up to now
      output->integrator(now, index, FALSE, output->lastIntegrationFlipPos & 1);
   }
   // Also update non PWM data structure if needed
   if (options.usemodsol & CORE_MODOUT_FORCE_ON)
   {
      if (((options.usemodsol & CORE_MODOUT_ENABLE_PHYSOUT_LAMPS) == 0) && (startIndex < CORE_MODOUT_LAMP0 + CORE_MODOUT_LAMP_MAX) && (startIndex + count >= CORE_MODOUT_LAMP0))
      {
         for (int i = 0; i < 8 + core_gameData->hw.lampCol; i++)
         {
            UINT8 col = 0;
            for (int j = 0; j < 8; j++)
               if (coreGlobals.physicOutputState[CORE_MODOUT_LAMP0 + i * 8 + j].value >= 0.1f)
                  col |= (UINT8)1 << j;
            coreGlobals.lampMatrix[i] = col;
         }
      }
      if (((options.usemodsol & (CORE_MODOUT_ENABLE_MODSOL | CORE_MODOUT_ENABLE_PHYSOUT_SOLENOIDS)) == 0) && (startIndex < CORE_MODOUT_SOL0 + CORE_MODOUT_SOL_MAX) && (startIndex + count >= CORE_MODOUT_SOL0))
      {
         UINT32 sols = 0;
         for (int i = 0; i < 32; i++)
            if (coreGlobals.physicOutputState[CORE_MODOUT_SOL0 + i].value >= 0.5f)
               sols |= 1u << i;
         coreGlobals.solenoids = sols;
      }
   }
}

// Write binary state of outputs, taking care of PWM integration based on physical model of the connected device
void core_write_pwm_output(int index, int count, UINT8 bitStates)
{
   const double now = timer_get_time();
   core_tPhysicOutput* output = &coreGlobals.physicOutputState[index];
   for (int i = 0; i < count; i++, bitStates = bitStates >> 1, index++, output++) {
      const int pos = index >> 3, ofs = index & 7;
      if (((coreGlobals.binaryOutputState[pos] >> ofs) & 1) != (bitStates & 1)) {
         const unsigned int bufferPos = (output->flipBufferPos + 1) % FLIP_BUFFER_SIZE;
         output->flipTimeStamps[bufferPos] = now;
         output->flipBufferPos = bufferPos;
         coreGlobals.binaryOutputState[pos] ^= 1 << ofs;
      }
   }
}

void core_write_pwm_output_8b(int index, UINT8 bitStates)
{
   assert((index & 7) == 0);
   UINT8 changeMask = coreGlobals.binaryOutputState[index >> 3] ^ bitStates;
   if (!changeMask)
      return;
   const double now = timer_get_time();
   for (core_tPhysicOutput* output = &coreGlobals.physicOutputState[index]; changeMask; changeMask >>= 1, output++)
      if (changeMask & 1)
      {
         const unsigned int bufferPos = (output->flipBufferPos + 1) % FLIP_BUFFER_SIZE;
         output->flipTimeStamps[bufferPos] = now;
         output->flipBufferPos = bufferPos;
      } 
   coreGlobals.binaryOutputState[index >> 3] = bitStates;
}

void core_write_masked_pwm_output_8b(int index, UINT8 bitStates, UINT8 bitMask)
{
   assert((index & 7) == 0);
   UINT8 changeMask = bitMask & (coreGlobals.binaryOutputState[index >> 3] ^ bitStates); // Identify differences
   if (!changeMask)
      return;
   const double now = timer_get_time();
   for (core_tPhysicOutput* output = &coreGlobals.physicOutputState[index]; changeMask; changeMask >>= 1, output++)
      if (changeMask & 1)
      {
         const unsigned int bufferPos = (output->flipBufferPos + 1) % FLIP_BUFFER_SIZE;
         output->flipTimeStamps[bufferPos] = now;
         output->flipBufferPos = bufferPos;
      }
   coreGlobals.binaryOutputState[index >> 3] = (coreGlobals.binaryOutputState[index >> 3] & ~bitMask) | (bitStates & bitMask);
}

// Write a 8xn lamp matrix, taking care of PWM integration based on physical model of connected device
void core_write_pwm_output_lamp_matrix(int startIndex, UINT8 columns, UINT8 rows, int nCols)
{
   if (options.usemodsol & (CORE_MODOUT_ENABLE_PHYSOUT_LAMPS | CORE_MODOUT_FORCE_ON))
   {
      for (const int endIndex = startIndex + nCols * 8; startIndex < endIndex; columns >>= 1, startIndex += 8) {
         if (columns & 1) {
            coreGlobals.tmpLampMatrix[(startIndex - CORE_MODOUT_LAMP0) >> 3] |= rows;
            core_write_pwm_output_8b(startIndex, rows);
         }
         else {
            core_write_pwm_output_8b(startIndex, 0);
         }
      }
   }
   else {
      core_setLamp(coreGlobals.tmpLampMatrix, columns << ((startIndex - CORE_MODOUT_LAMP0) / 8), rows);
   }
}


//
//
//

/* Generic DMD PWM integration.

  All hardware so far (Alvin G, Data East, Sega/Stern Whitestar, GTS3, WPC, SAM, Capcom, Sleic (Spain), Spinball)
  creates shades using PWM on a plasma or LED display (later Stern games). Therefore, PinMAME offers access to the
  raw high frequency frames (e.g. for coloring) or to a PWM integrated view (e.g. for rendering).

  Unlike lamps, which have varying strobe periods, DMDs are rasterized at a fixed frequency. Therefore, the implementation
  simply stores the frames at this frequency and applies a (simple) low pass filter to account for the eye flicker-fusion limit.
  The integration period (number of frames to store) and cut-off frequency are selected from the observed PWM pattern of 
  common hardware: WPC is 122/3 = 40.7Hz, GTS3 is 376/10 = 37.6Hz, WPC Phantom Haus limit pattern length to 2 to stay above 30Hz,
  so an overall plasma inertia & flicker fusion period of around 30ms (33Hz).

  Filters are computed using the following script in GNU Octave:

pkg load signal

fc = 15; % Cut-off frequency (Hz), PWM patterns/frequency suggests something around 33Hz
int_factor = 65535*65530; % Integer arithmetic fixed point scaling


% WPC Phantom Haus
%n = 10
%fs = 61.05; % Sampling rate (Hz) = DMD VBlank
%data=[repmat([0;1],100,1)];

% WPC
%n = 8
%fs = 122.1; % Sampling rate (Hz) = DMD VBlank
%data=[repmat([0;0;1],100,1),repmat([0;1;1],100,1)];

% Data East DMD 128x16
%n = 8
%fs = 177.5; % Sampling rate (Hz) = DMD VBlank
%data=[repmat([0;0;1],100,1), repmat([1;1;0],100,1), repmat([1;1;1],100,1)];

% Data East DMD 128x32 & Sega/Stern Whitestar & Sega 192x64
%n = 8
%fs = 230.; % Sampling rate (Hz) = DMD VBlank
%data=[repmat([0;0;1],100,1), repmat([1;1;0],100,1), repmat([1;1;1],100,1)];

% GTS3
%n = 24
%fs = 376.; % Sampling rate (Hz) = DMD VBlank
%data=[repmat([0;0;0;0;0;0;0;1],30,1), repmat([0;0;0;0;0;1;1;1],30,1)];

% Alvin G
%n = 10
%fs = 298.6; % Sampling rate (Hz) = DMD VBlank
%fs = 1194.4; % Sampling rate (Hz) = DMD VBlank
%data=[repmat([0;0;0;1],100,1),repmat([0;1;0;1],100,1),repmat([0;0;1;1],100,1),repmat([0;1;1;1],100,1)];

%fs = 230.;
%n = floor(fs/fc) + 1

b = fir1(n - 1, fc/(fs/2));
b = round(int_factor * b) / int_factor

filtered = filter(b,1,data);

clf
x = (0:(max(size(data))-1)) / fs;
filtered = round(255*filtered)
for i_plot = 1:size(data,2)
  subplot ( columns ( filtered ), 1, i_plot)
  stairs(x, filtered(:,i_plot),";PWM Pattern;")
endfor

fprintf('n=%i (suggested n=%i from fs/fc with fs=%d fc=%d)\n', n, floor(fs/fc)+1, fs, fc);
fprintf('filter=[');
fprintf('%i, ', int_factor * b);
fprintf(']\n');
*/

void core_dmd_pwm_init(core_tDMDPWMState* dmd_state, const int width, const int height, const int filter, const int raw_combiner) {
  assert((width & 0x0007) == 0);
  memset(dmd_state, 0, sizeof(core_tDMDPWMState));
  dmd_state->width = width;
  dmd_state->height = height;
  dmd_state->frameSize = width * height;
  dmd_state->rawFrameSize = dmd_state->frameSize / 8;
  dmd_state->raw_combiner = raw_combiner;
  switch (filter)
  {
  case CORE_DMD_PWM_FILTER_WPC_PH: // WPC Phantom Haus: 61Hz refresh rate / 15Hz low pass filter / 2 frames PWM pattern
    {
      static const UINT32 fir_61_15[] = { 255, 255 };
      dmd_state->fir_weights = fir_61_15;
      dmd_state->fir_size = dmd_state->nFrames = sizeof(fir_61_15) / sizeof(UINT32);
    }
    break;
  case CORE_DMD_PWM_FILTER_WPC: // WPC: 122Hz refresh rate / 15Hz low pass filter / 3 frames PWM pattern (there seems to be longer PWM patterns, see T2 gun animation sequence)
    {
      static const UINT32 fir_122_15[] = { 2171530, 86962941, 442229424, 985918760, 1259943241, 985918760, 442229424, 86962941, 2171530 };
      dmd_state->fir_weights = fir_122_15;
      dmd_state->fir_size = dmd_state->nFrames = sizeof(fir_122_15) / sizeof(UINT32);
    }
    break;
  case CORE_DMD_PWM_FILTER_DE_128x16: // Data East 128x16: 177.5Hz refresh rate / 15Hz low pass filter / 2 frames PWM pattern
    {
      static const UINT32 fir_177_15[] = { 5806203, 39898456, 162292893, 397050141, 675509028, 866697553, 866697553, 675509028, 397050141, 162292893, 39898456, 5806203 };
      dmd_state->fir_weights = fir_177_15;
      dmd_state->fir_size = dmd_state->nFrames = sizeof(fir_177_15) / sizeof(UINT32);
    }
    break;
  case CORE_DMD_PWM_FILTER_DE_128x32: // Data East & Sega/Stern Whitestar: 234Hz refresh rate / 15Hz low pass filter / 2 frames (2/3 - 1/3 length) PWM pattern
  case CORE_DMD_PWM_FILTER_DE_192x64: // Sega: 224Hz refresh rate / 15Hz low pass filter / 2 frames (2/3 - 1/3 length) PWM pattern
    {
      static const UINT32 fir_230_15[] = { 5683808, 23123723, 77603279, 187082483, 344389128, 514464295, 646635594, 696543928, 646635594, 514464295, 344389128, 187082483, 77603279, 23123723, 5683808 };
      dmd_state->fir_weights = fir_230_15;
      dmd_state->fir_size = dmd_state->nFrames = sizeof(fir_230_15) / sizeof(UINT32);
    }
    break;
  case CORE_DMD_PWM_FILTER_ALVG2: // Alvin G. DMD Generation 2: 298.6Hz refresh rate / 15Hz low pass filter / 4 frames PWM pattern
    {
      static const UINT32 fir_299_15[] = { 2410896, 9610314, 28210405, 66396021, 128313971, 211717997, 307413991, 400841556, 475445398, 516893726, 516893726, 475445398, 400841556, 307413991, 211717997, 128313971, 66396021, 28210405, 9610314, 2410896 };
      dmd_state->fir_weights = fir_299_15;
      dmd_state->fir_size = dmd_state->nFrames = sizeof(fir_299_15) / sizeof(UINT32);
    }
    break;
  case CORE_DMD_PWM_FILTER_GTS3: // GTS3: 376Hz refresh rate / 15Hz low pass filter / 1,3,6,8,10 frames PWM pattern
  case CORE_DMD_PWM_FILTER_ALVG1: // FIXME frame rate seems too high to be true (so we use the 376Hz) / Alvin G. DMD Generation 1: 1194.4Hz refresh rate / 15Hz low pass filter / 4 frames PWM pattern
    {
      static const UINT32 fir_376_15[] = { 487657, 3888687, 10976383, 24969201, 48529031, 83073390, 128267628, 181813266, 239594638, 296177312, 345582023, 382201229, 401693831, 401693831, 382201229, 345582023, 296177312, 239594638, 181813266, 128267628, 83073390, 48529031, 24969201, 10976383, 3888687, 487657 };
      dmd_state->fir_weights = fir_376_15;
      dmd_state->fir_size = dmd_state->nFrames = sizeof(fir_376_15) / sizeof(UINT32);
    }
    break;
  default:
    assert(0); // Unsupported filter
  }
  for (int i = 0; i < dmd_state->fir_size; i++)
    dmd_state->fir_sum += dmd_state->fir_weights[i];
  dmd_state->fir_sum /= 255;
  dmd_state->rawFrames = malloc(dmd_state->nFrames * dmd_state->rawFrameSize);
  dmd_state->shadedFrame = malloc(dmd_state->frameSize * sizeof(UINT32));
  dmd_state->bitplaneFrame = malloc(dmd_state->frameSize * sizeof(UINT8));
  dmd_state->luminanceFrame = malloc(dmd_state->frameSize * sizeof(UINT8));
  assert(dmd_state->rawFrames != NULL && dmd_state->shadedFrame != NULL && dmd_state->bitplaneFrame != NULL && dmd_state->luminanceFrame != NULL);
  memset(dmd_state->rawFrames, 0, dmd_state->nFrames * dmd_state->rawFrameSize);
  memset(dmd_state->shadedFrame, 0, dmd_state->frameSize * sizeof(UINT32));
  memset(dmd_state->bitplaneFrame, 0, dmd_state->frameSize * sizeof(UINT8));
  memset(dmd_state->luminanceFrame, 0, dmd_state->frameSize * sizeof(UINT8));
  dmd_state->nextFrame = 0;
}

void core_dmd_pwm_exit(core_tDMDPWMState* dmd_state) {
  free(dmd_state->rawFrames);
  dmd_state->rawFrames = NULL;
  free(dmd_state->shadedFrame);
  dmd_state->shadedFrame = NULL;
  free(dmd_state->bitplaneFrame);
  dmd_state->bitplaneFrame = NULL;
  free(dmd_state->luminanceFrame);
  dmd_state->luminanceFrame = NULL;
}

// TODO for the time being, DMDs are always updated from core/updateDisplay, running at a fixed 60Hz. This may lead to stutters
// as it is not aligned with real display refresh rate. We should update DMD on request but this needs to make these functions
// thread safe. To avoid synchronization, a simple loop model with consumer accesing data before barrier, and provider pushing
// data after the barrier should be enough.
void core_dmd_submit_frame(core_tDMDPWMState* dmd_state, const UINT8* frame, const int ntimes) {
  for (int i = 0; i < ntimes; i++) {
    memcpy(dmd_state->rawFrames + dmd_state->nextFrame * dmd_state->rawFrameSize, frame, dmd_state->rawFrameSize);
    dmd_state->nextFrame = (dmd_state->nextFrame + 1) % dmd_state->nFrames;
    dmd_state->frame_index++;
  }
}

void core_dmd_update_pwm(core_tDMDPWMState* dmd_state) {
  // Apply low pass filter over stored frames then scale down to final shades
  memset(dmd_state->shadedFrame, 0, dmd_state->width * dmd_state->height * sizeof(UINT32));
  for (int ii = 0; ii < dmd_state->fir_size; ii++) {
    const UINT32 frame_weight = dmd_state->fir_weights[ii];
    UINT32* line = dmd_state->shadedFrame;
    const UINT8* frameData = dmd_state->rawFrames + ((dmd_state->nextFrame + (dmd_state->nFrames - 1) + (dmd_state->nFrames - ii)) % dmd_state->nFrames) * dmd_state->rawFrameSize;
    for (int jj = 0; jj < dmd_state->rawFrameSize; jj++) {
      UINT8 data = *frameData++;
      if (dmd_state->revByte) {
        for (int kk = 0; kk < 8; kk++, data >>= 1, line++)
          if (data & 0x01) (*line) += frame_weight;
      } else {
        for (int kk = 0; kk < 8; kk++, data <<= 1, line++)
          if (data & 0x80) (*line) += frame_weight;
      }
    }
  }
  const UINT32* line = dmd_state->shadedFrame;
  for (int ii = 0; ii < dmd_state->height * dmd_state->width; ii++) {
    const unsigned int data = (unsigned int) (*line++); // unsigned int precision is needed here
    dmd_state->luminanceFrame[ii] = (UINT8)(data / dmd_state->fir_sum);
  }

  // Compute combined bitplane frames as they used to be for backward compatibility with colorization plugins
  #if defined(VPINMAME) || defined(LIBPINMAME)
  switch (dmd_state->raw_combiner) {
  case CORE_DMD_PWM_COMBINER_GTS3_4C_A: // Reproduce previous (somewhat hacky) frame combiner used by GTS3 driver
  case CORE_DMD_PWM_COMBINER_GTS3_4C_B:
  case CORE_DMD_PWM_COMBINER_GTS3_5C:
    {
      static const UINT8 level4_a[7]  = { 0, 1, 2, 2, 2, 2, 3 }; // 4 colors
      static const UINT8 level4_a2[7] = { 0, 1, 1, 2, 2, 2, 3 }; // 4 colors
      static const UINT8 level4_b[9]  = { 0, 1, 2, 2, 2, 2, 2, 2, 3 }; // 4 colors
      static const UINT8 level5[13]   = { 0, 3, 3, 7, 7, 7, 11, 11, 11, 11, 11, 11, 15 }; // 5 colors
      const UINT8* level = dmd_state->raw_combiner == CORE_DMD_PWM_COMBINER_GTS3_4C_A ? level4_a
                         : dmd_state->raw_combiner == CORE_DMD_PWM_COMBINER_GTS3_4C_B ? level4_b
                         :                         /* CORE_DMD_PWM_COMBINER_GTS3_5C */  level5;
      const int nFrames = dmd_state->raw_combiner == CORE_DMD_PWM_COMBINER_GTS3_4C_A ? 6
                        : dmd_state->raw_combiner == CORE_DMD_PWM_COMBINER_GTS3_4C_B ? 8
                        :                         /* CORE_DMD_PWM_COMBINER_GTS3_5C */  12;
      memset(dmd_state->bitplaneFrame, 0, dmd_state->frameSize);
      for (int i = 1; i <= nFrames; i++)
      {
        UINT8* rawData = &dmd_state->bitplaneFrame[0];
        const UINT8* frameData = dmd_state->rawFrames + ((dmd_state->nextFrame + (dmd_state->nFrames - i)) % dmd_state->nFrames) * dmd_state->rawFrameSize;
        for (int kk = 0; kk < dmd_state->rawFrameSize; kk++)
          for (UINT8 ll = 0, data = *frameData++; ll < 8; ll++, data <<= 1)
            (*rawData++) += (data >> 7);
      }
      if (dmd_state->raw_combiner == CORE_DMD_PWM_COMBINER_GTS3_4C_A)
        for (int kk = 0; kk < dmd_state->frameSize; kk++)
          if (dmd_state->bitplaneFrame[kk] == 4) {
            level = level4_a2;
            break;
          }
      for (int kk = 0; kk < dmd_state->frameSize; kk++)
        dmd_state->bitplaneFrame[kk] = level[dmd_state->bitplaneFrame[kk]];
    }
    break;
  case CORE_DMD_PWM_COMBINER_SUM_2: // Sum of the last 2 raw frames seen (WPC/Phantom Haus)
    {
      UINT8* rawData = &dmd_state->bitplaneFrame[0];
      const UINT8* const frame0 = dmd_state->rawFrames + ((dmd_state->nextFrame + (dmd_state->nFrames - 1)) % dmd_state->nFrames) * dmd_state->rawFrameSize;
      const UINT8* const frame1 = dmd_state->rawFrames + ((dmd_state->nextFrame + (dmd_state->nFrames - 2)) % dmd_state->nFrames) * dmd_state->rawFrameSize;
      for (int kk = 0; kk < dmd_state->rawFrameSize; kk++) {
        const unsigned int intens1 = (frame0[kk] & 0x55) + (frame1[kk] & 0x55); // 0x55 = 01010101 binary mask
        const unsigned int intens2 = (frame0[kk] & 0xaa) + (frame1[kk] & 0xaa); // 0xaa = 10101010 binary mask
        *rawData++ =  intens1       & 0x03;
        *rawData++ = (intens2 >> 1) & 0x03;
        *rawData++ = (intens1 >> 2) & 0x03;
        *rawData++ = (intens2 >> 3) & 0x03;
        *rawData++ = (intens1 >> 4) & 0x03;
        *rawData++ = (intens2 >> 5) & 0x03;
        *rawData++ = (intens1 >> 6) & 0x03;
        *rawData++ = (intens2 >> 7) & 0x03;
      }
    }
    break;
  case CORE_DMD_PWM_COMBINER_SUM_3: // Sum of the last 3 raw frames seen (WPC)
    {
      UINT8* rawData = &dmd_state->bitplaneFrame[0];
      const UINT8* const frame0 = dmd_state->rawFrames + ((dmd_state->nextFrame + (dmd_state->nFrames - 1)) % dmd_state->nFrames) * dmd_state->rawFrameSize;
      const UINT8* const frame1 = dmd_state->rawFrames + ((dmd_state->nextFrame + (dmd_state->nFrames - 2)) % dmd_state->nFrames) * dmd_state->rawFrameSize;
      const UINT8* const frame2 = dmd_state->rawFrames + ((dmd_state->nextFrame + (dmd_state->nFrames - 3)) % dmd_state->nFrames) * dmd_state->rawFrameSize;
      for (int kk = 0; kk < dmd_state->rawFrameSize; kk++) {
        const unsigned int intens1 = (frame0[kk] & 0x55) + (frame1[kk] & 0x55) + (frame2[kk] & 0x55); // 0x55 = 01010101 binary mask
        const unsigned int intens2 = (frame0[kk] & 0xaa) + (frame1[kk] & 0xaa) + (frame2[kk] & 0xaa); // 0xaa = 10101010 binary mask
        *rawData++ =  intens1       & 0x03;
        *rawData++ = (intens2 >> 1) & 0x03;
        *rawData++ = (intens1 >> 2) & 0x03;
        *rawData++ = (intens2 >> 3) & 0x03;
        *rawData++ = (intens1 >> 4) & 0x03;
        *rawData++ = (intens2 >> 5) & 0x03;
        *rawData++ = (intens1 >> 6) & 0x03;
        *rawData++ = (intens2 >> 7) & 0x03;
      }
    }
    break;
  case CORE_DMD_PWM_COMBINER_SUM_2_1: // high bit for double length frame, low bit for single length frame
  case CORE_DMD_PWM_COMBINER_SUM_1_2:
    {
      UINT8 *rawData = &dmd_state->bitplaneFrame[0];
      const UINT8 *frame0, *frame1;
      if (dmd_state->raw_combiner == CORE_DMD_PWM_COMBINER_SUM_2_1) { // double length frame are the 2 before last one, single length frame is the last one (Data East 128x32, Sega/Stern Whitestar)
        frame0 = dmd_state->rawFrames + ((dmd_state->nextFrame + (dmd_state->nFrames - 2)) % dmd_state->nFrames) * dmd_state->rawFrameSize;
        frame1 = dmd_state->rawFrames + ((dmd_state->nextFrame + (dmd_state->nFrames - 1)) % dmd_state->nFrames) * dmd_state->rawFrameSize;
      }
      else { //if (dmd_state->raw_combiner == CORE_DMD_PWM_COMBINER_SUM_1_2) { // double length frame are the 2 last ones, single length frame is the one before (Data East 128x16)
        frame0 = dmd_state->rawFrames + ((dmd_state->nextFrame + (dmd_state->nFrames - 1)) % dmd_state->nFrames) * dmd_state->rawFrameSize;
        frame1 = dmd_state->rawFrames + ((dmd_state->nextFrame + (dmd_state->nFrames - 3)) % dmd_state->nFrames) * dmd_state->rawFrameSize;
      }
      for (int kk = 0; kk < dmd_state->rawFrameSize; kk++) {
        const unsigned int intens1 = 2*(frame0[kk] & 0x55) + (frame1[kk] & 0x55);   // 0x55 = 01010101 binary mask
        const unsigned int intens2 =   (frame0[kk] & 0xaa) + (frame1[kk] & 0xaa)/2; // 0xaa = 10101010 binary mask
        *rawData++ = (intens2 >> 6) & 0x03;
        *rawData++ = (intens1 >> 6) & 0x03;
        *rawData++ = (intens2 >> 4) & 0x03;
        *rawData++ = (intens1 >> 4) & 0x03;
        *rawData++ = (intens2 >> 2) & 0x03;
        *rawData++ = (intens1 >> 2) & 0x03;
        *rawData++ =  intens2       & 0x03;
        *rawData++ =  intens1       & 0x03;
      }
    }
    break;
  case CORE_DMD_PWM_COMBINER_SUM_4: // Sum of the last 4 frames (Alvin G. for Pistol Poker & Mystery Castle)
    {
      static const UINT8 level[5] = { 0, 3, 7, 11, 15 }; // brightness mapping 0,25,50,75,100% (backward compatible to encode 5 levels on 4 bits)
      UINT8* rawData = &dmd_state->bitplaneFrame[0];
      const UINT8* const frame0 = dmd_state->rawFrames + ((dmd_state->nextFrame + (dmd_state->nFrames - 1)) % dmd_state->nFrames) * dmd_state->rawFrameSize;
      const UINT8* const frame1 = dmd_state->rawFrames + ((dmd_state->nextFrame + (dmd_state->nFrames - 2)) % dmd_state->nFrames) * dmd_state->rawFrameSize;
      const UINT8* const frame2 = dmd_state->rawFrames + ((dmd_state->nextFrame + (dmd_state->nFrames - 3)) % dmd_state->nFrames) * dmd_state->rawFrameSize;
      const UINT8* const frame3 = dmd_state->rawFrames + ((dmd_state->nextFrame + (dmd_state->nFrames - 4)) % dmd_state->nFrames) * dmd_state->rawFrameSize;
      for (int kk = 0; kk < dmd_state->rawFrameSize; kk++) {
        UINT8 v0 = frame0[kk], v1 = frame1[kk], v2 = frame2[kk], v3 = frame3[kk];
        for (int ii = 0; ii < 8; ii++, v0 <<= 1, v1 <<= 1, v2 <<= 1, v3 <<= 1)
          *rawData++ = level[((v0 >> 7) & 0x01) + ((v1 >> 7) & 0x01) + ((v1 >> 7) & 0x02) + ((v3 >> 7) & 0x01)];
      }
    }
    break;
  default:
    assert(0); // Unsupported combiner
  }
  #endif

  // For GTS3, WPC and Alvin G. 2 also store raw single bitplane frame for backward compatibility with colorization plugins
  // TODO move these data to dmd_state struct (for cleanup and to fix multiple DMD support for GTS3 Strikes N' Spares)
  #if defined(VPINMAME) || defined(LIBPINMAME)
  if (core_gameData->gen & (GEN_ALLWPC | GEN_GTS3 | GEN_ALVG_DMD2)) {
    raw_dmd_frame_count = dmd_state->nFrames > CORE_MAX_RAW_DMD_FRAMES ? CORE_MAX_RAW_DMD_FRAMES : dmd_state->nFrames;
    UINT8* rawData = &raw_dmd_frames[0];
    for (int frame = 0; frame < (int)raw_dmd_frame_count; frame++) {
      const UINT8* frameData = dmd_state->rawFrames + ((dmd_state->nextFrame + (dmd_state->nFrames - 1) + (dmd_state->nFrames - frame)) % dmd_state->nFrames) * dmd_state->rawFrameSize;
      for (int jj = 0; jj < dmd_state->rawFrameSize; jj++) {
        *rawData = dmd_state->revByte ? (*frameData++) : core_revbyte(*frameData++);
        rawData++;
      }
    }
  }
  else {
    raw_dmd_frame_count = 0;
  }
  #endif
}

// Render to internal display, using provided luminance, if there is a visible display (PinMAME always, and VPinMAME when its window is shown)
// FIXME apply colors LUT ?
#if defined(PINMAME) || defined(VPINMAME)
void core_dmd_render_internal(struct mame_bitmap *bitmap, const int x, const int y, const int width, const int height, const UINT8* const dmdDotLum, const int apply_aa) {
  #define DMD_OFS(row, col) ((row)*width + (col))
  BMTYPE **lines = ((BMTYPE **)bitmap->line) + (y * locals.displaySize);
  for (int ii = 0; ii < height; ii++) {
    BMTYPE *line = (*lines) + (x * locals.displaySize);
    for (int jj = 0; jj < width; jj++) {
      *line = DMD_PAL(dmdDotLum[DMD_OFS(ii, jj)]);
      line += locals.displaySize;
    }
    lines += locals.displaySize;
  }
  // Apply antialiasing if enabled, or clear pixels between dots otherwise, do via a triangle filter:
  // 1 2 1
  // 2 4 2
  // 1 2 1
  // Note that pixels which are off are always counted as contributing 0 (so NOT the 'off-color/brightness')
  assert((locals.displaySize == 1) || (locals.displaySize == 2));
  if (apply_aa && locals.displaySize == 2) {
    lines = ((BMTYPE **)bitmap->line) + (y * 2);
    for (int ii = 0; ii < height * 2 - 1; ii++) {
      const int pi = (ii - 1) >> 1;
      BMTYPE *line = (*lines) + (x * 2);
      for (int jj = 0; jj < width * 2 - 1; jj++) {
        const int pj = (jj - 1) >> 1;
        if ((ii & 1) & (jj & 1)) { // Corner point
          // x 0 x
          // 0 0 0
          // x 0 x
          const UINT32 lum = TRAFO_AA(dmdDotLum[DMD_OFS(pi, pj)]) + TRAFO_AA(dmdDotLum[DMD_OFS(pi+1, pj)]) + TRAFO_AA(dmdDotLum[DMD_OFS(pi, pj+1)]) + TRAFO_AA(dmdDotLum[DMD_OFS(pi+1, pj+1)]);
          *line = lum == 0 ? 0 : DMD_AA_PAL(lum * pmoptions.dmd_antialias,1,16u*100 /3u); // /3 = heuristic to kinda match old AA behavior
        } else if (ii & 1) { // Vertical side point
          // 0 x 0
          // 0 0 0
          // 0 x 0
          const UINT32 lum = TRAFO_AA(dmdDotLum[DMD_OFS(pi, pj+1)]) + TRAFO_AA(dmdDotLum[DMD_OFS(pi+1, pj+1)]);
          *line = lum == 0 ? 0 : DMD_AA_PAL(lum * pmoptions.dmd_antialias,2,16u*100 /3u); // /3 = heuristic to kinda match old AA behavior
        } else if (jj & 1) { // Horizontal side point
          // 0 0 0
          // x 0 x
          // 0 0 0
          const UINT32 lum = TRAFO_AA(dmdDotLum[DMD_OFS(pi+1, pj)]) + TRAFO_AA(dmdDotLum[DMD_OFS(pi+1, pj+1)]);
          *line = lum == 0 ? 0 : DMD_AA_PAL(lum * pmoptions.dmd_antialias,2,16u*100 /3u); // /3 = heuristic to kinda match old AA behavior
        }
        line++;
      }
      lines++;
    }
  }
  #undef DMD_OFS
}
#endif

// Prepare data for VPinMAME interface, using computed luminance and applying user LUT for luminance/color (Controller.RawDmdPixels / Controller.RawColoredDmdPixels)
#ifdef VPINMAME
void core_dmd_render_vpm(const int width, const int height, const UINT8* const dmdDotLum) {
  const int size = width * height;
  g_raw_dmdx = width;
  g_raw_dmdy = height;
  if (memcmp(locals.vpm_dmd_last_lum, dmdDotLum, size) != 0) {
    memcpy(locals.vpm_dmd_last_lum, dmdDotLum, size);
    UINT8* rawLum = g_raw_dmdbuffer;
    UINT32* rawCol = g_raw_colordmdbuffer;
    for (int ii = 0; ii < size; ii++) {
      const UINT8 lum = dmdDotLum[ii];
      (*rawLum++) = locals.vpm_dmd_luminance_lut[lum];
      (*rawCol++) = locals.vpm_dmd_color_lut[lum];
    }
    g_needs_DMD_update = 1;
  }
}
#endif

// Prepare data for LibPinMAME interface (similar to VPinMAME but without color LUT, and with a global flag to select luminance/bitplanes)
#ifdef LIBPINMAME
void core_dmd_render_lpm(const int width, const int height, const UINT8* const dmdDotLum, const UINT8* const dmdDotRaw) {
  const int size = width * height;
  g_raw_dmdx = width;
  g_raw_dmdy = height;
  if (g_fDmdMode == 0) { // PINMAME_DMD_MODE_BRIGHTNESS
    if (memcmp(locals.vpm_dmd_last_lum, dmdDotLum, size) != 0) {
      memcpy(locals.vpm_dmd_last_lum, dmdDotLum, size);
      UINT8* rawLum = g_raw_dmdbuffer;
      for (int ii = 0; ii < size; ii++)
        (*rawLum++) = locals.vpm_dmd_luminance_lut[dmdDotLum[ii]];
      g_needs_DMD_update = 1;
    }
  }
  else if (g_fDmdMode == 1) {// PINMAME_DMD_MODE_RAW
    if (memcmp(g_raw_dmdbuffer, dmdDotRaw, size) != 0) {
      memcpy(g_raw_dmdbuffer, dmdDotRaw, size);
      g_needs_DMD_update = 1;
    }
  }
}
#endif

// Send main DMD to dmddevice plugins
#ifdef VPINMAME
void core_dmd_render_dmddevice(const int width, const int height, const UINT8* const dmdDotLum, const UINT8* const dmdDotRaw, const int isDMD2) {
  if (g_fShowPinDMD) {
    const int isStrikesNSpares = strncasecmp(Machine->gamedrv->name, "snspare", 7) == 0;
    dmddeviceRenderDMDFrame(width, height, dmdDotLum, dmdDotRaw, raw_dmd_frame_count, raw_dmd_frames, isStrikesNSpares ? (isDMD2 ? 2 : 1) : 3);
  }
}
#endif

// Save main DMD bitplane and raw frames to a capture file
// DMD frame capture can be enabled either by:
// - setting g_fDumpFrames (not supported as it is only available through keyboard input which VPinMame doesn't have)
// - setting g_fShowPinDMD (enable dmddevice.dll) and g_fShowWinDMD (enable VPinMAME rendering) simultaneously
// TODO this is not yet implemented for Strikes N' Spares which has 2 DMDs
#ifdef VPINMAME
void core_dmd_capture_frame(const int width, const int height, const UINT8* const dmdDotRaw, const int rawFrameCount, const UINT8* const rawFrame) {
  const int isStrikeNSpares = strncasecmp(Machine->gamedrv->name, "snspare", 7) == 0;
  if (!isStrikeNSpares && (g_fDumpFrames || (g_fShowPinDMD && g_fShowWinDMD))) {
    char *ptr;
    char DumpFilename[MAX_PATH];
    const DWORD tick = GetTickCount();
    #ifndef _WIN64
      const HINSTANCE hInst = GetModuleHandle("VPinMAME.dll");
    #else
      const HINSTANCE hInst = GetModuleHandle("VPinMAME64.dll");
    #endif
    GetModuleFileName(hInst, DumpFilename, MAX_PATH);
    ptr = strrchr(DumpFilename, '\\');
    strcpy_s(ptr + 1, 11, "DmdDump\\");
    strcat_s(DumpFilename, MAX_PATH, Machine->gamedrv->name);

    // Additional single bitplane raw frames for GTS3, WPC and Alvin G.
    if (rawFrameCount != 0) {
      FILE* fr;
      char RawFilename[MAX_PATH];
      strcpy_s(RawFilename, MAX_PATH, DumpFilename);
      strcat_s(RawFilename, MAX_PATH, ".raw");
      fr = fopen(RawFilename, "rb");
      if (fr) {
        fclose(fr);
        fr = fopen(RawFilename, "ab");
      }
      else {
        fr = fopen(RawFilename, "ab");
        if (fr) {
          fputc(0x52, fr);
          fputc(0x41, fr);
          fputc(0x57, fr);
          fputc(0x00, fr);
          fputc(0x01, fr);
          fputc(width, fr);
          fputc(height, fr);
          fputc(rawFrameCount, fr);
        }
      }
      if (fr) {
        fwrite(&tick, 1, 4, fr);
        fwrite(rawFrame, 1, (width * height / 8 * rawFrameCount), fr);
        fclose(fr);
      }
    }

    // Bitplane frame combined from PWM pattern of raw frames
    static UINT8 lastCapture[DMD_MAXX * DMD_MAXY] = { 0 };
    if (memcmp(lastCapture, dmdDotRaw, width * height) != 0)
    {
       FILE *f;
       memcpy(lastCapture, dmdDotRaw, width * height);
       strcat_s(DumpFilename, MAX_PATH, ".txt");
       f = fopen(DumpFilename, "a");
       if (f) {
          fprintf(f, "0x%08x\n", tick);
          for (int jj = 0; jj < height; jj++) {
             for (int ii = 0; ii < width; ii++)
                fprintf(f, "%01x", dmdDotRaw[jj * width + ii]);
             fprintf(f, "\n");
          }
          fprintf(f, "\n");
          fclose(f);
       }
    }
  }
}
#endif

void core_dmd_video_update(struct mame_bitmap *bitmap, const struct rectangle *cliprect, const struct core_dispLayout *layout, core_tDMDPWMState* dmd_state) {
  const UINT8 *dmdDotRaw;
  UINT8 *dmdDotLum;

  if (dmd_state) { // Full DMD state with luminance and bitplane state
    dmdDotRaw = dmd_state->bitplaneFrame;
    dmdDotLum = dmd_state->luminanceFrame;
  }
  else { // Only bitplane state: consider luminance equal to (scaled) bitplane output
    dmdDotRaw = &coreGlobals.dmdDotRaw[0];
    dmdDotLum = &coreGlobals.dmdDotLum[0];
    if ((core_gameData->gen & GEN_SAM) == 0) {
      static const UINT8 lum4[] = { 0, 85, 170, 255 };
      static const UINT8 lum16[] = { 0, 17, 34, 51, 68, 85, 102, 119, 136, 153, 170, 187, 204, 221, 238, 255 };
      const UINT8* const lum = (core_gameData->gen & GEN_SPA) != 0 ? lum16 : lum4;
      for (int ii = 0; ii < layout->length * layout->start; ii++)
        dmdDotLum[ii] = lum[dmdDotRaw[ii]];
    }
  }

  #if defined(LIBPINMAME)
    const int isMainDMD = layout->length >= 128; // Up to 2 main DMDs (1 for all games, except Strikes N' Spares which has 2)
    if (isMainDMD) {
      core_dmd_render_lpm(layout->length, layout->start, dmdDotLum, dmdDotRaw);
      has_DMD_Video = 1;
    }

  #elif defined(VPINMAME)
    const int isMainDMD = layout->length >= 128; // Up to 2 main DMDs (1 for all games, except Strikes N' Spares which has 2)
    // FIXME check for VPinMame window hidden/shown state, and do not render if hidden
    core_dmd_render_internal(bitmap, layout->left, layout->top, layout->length, layout->start, dmdDotLum, pmoptions.dmd_antialias && !(layout->type & CORE_DMDNOAA));
    if (isMainDMD) {
      has_DMD_Video = 1;
      core_dmd_render_vpm(layout->length, layout->start, dmdDotLum);
      core_dmd_render_dmddevice(layout->length, layout->start, dmdDotLum, dmdDotRaw, layout->top != 0);
      core_dmd_capture_frame(layout->length, layout->start, dmdDotRaw, raw_dmd_frame_count ,raw_dmd_frames);
    }
  
  #elif defined(PINMAME)
    core_dmd_render_internal(bitmap, layout->left, layout->top, layout->length, layout->start, dmdDotLum, pmoptions.dmd_antialias && !(layout->type & CORE_DMDNOAA));

  #endif
}

//
//
//

void core_sound_throttle_adj(int sIn, int *sOut, int buffersize, double samplerate)
{
   const int delta = (sIn >= *sOut) ? (sIn - *sOut) : (sIn + buffersize - *sOut);

#ifdef DEBUG_SOUND
   {
      char tmp[161];
      LARGE_INTEGER performance_count;
      QueryPerformanceCounter(&performance_count);

      sprintf(tmp, "snd clk: %llu in: %d out: %d size: %d delta %d", performance_count.QuadPart, sIn, *sOut, buffersize, delta);
      DebugSound(tmp);
   }
#endif

   if (delta > samplerate * 50 / 1000)
   {
      // Over 50ms delta and throttle didn't catch it fast enough.   Drop some samples, but not so
      // much that we have to restart from a zero buffer.
      *sOut = sIn - (int)(samplerate * 20 / 1000 + 0.5);
      if (*sOut < 0)
         *sOut += buffersize;

      SetThrottleAdj(0);
   }
   else if (delta > samplerate * 35 / 1000)
   {
      SetThrottleAdj(-4);
   }
   else if (delta > samplerate * 25 / 1000)
   {
      SetThrottleAdj(-1);
   }
   else if (delta < samplerate * 10 / 1000)
   {
      SetThrottleAdj(10);
   }
   else if (delta < samplerate * 20 / 1000)
   {
      SetThrottleAdj(2);
   }
   else
   {
      SetThrottleAdj(0);
   }
}

/*----------------------------------------------
/  Add a timer when building the machine driver
/-----------------------------------------------*/
void machine_add_timer(struct InternalMachineDriver *machine, void (*func)(int), double rate) {
  int ii;
  for (ii = 0; machine->pinmame.timers[ii].callback; ii++)
    ;
  machine->pinmame.timers[ii].callback = func;
  machine->pinmame.timers[ii].rate = rate;
}

/*---------------------------------------
/  Default machine driver for all games
/----------------------------------------*/
MACHINE_DRIVER_START(PinMAME)
  MDRV_VIDEO_ATTRIBUTES(VIDEO_TYPE_RASTER)
  MDRV_SCREEN_SIZE(CORE_SCREENX, CORE_SCREENY)
  MDRV_VISIBLE_AREA(0, CORE_SCREENX-1, 0, CORE_SCREENY-1)
  MDRV_PALETTE_INIT(core)
  MDRV_PALETTE_LENGTH(sizeof(core_palette)/sizeof(core_palette[0][0])/3)
  MDRV_FRAMES_PER_SECOND(60)
  MDRV_SWITCH_CONV(core_swSeq2m,core_m2swSeq)
  MDRV_LAMP_CONV(core_swSeq2m,core_m2swSeq)
  MDRV_MACHINE_INIT(core) MDRV_MACHINE_STOP(core)
  MDRV_VIDEO_UPDATE(core_gen)
MACHINE_DRIVER_END
